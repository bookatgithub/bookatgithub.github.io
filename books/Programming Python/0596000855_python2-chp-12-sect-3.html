<html><head>
<META http-equiv="Content-Type" content="text/html">
<!--SafClassName="docSection1Title"--><!--SafTocEntry="12.3 Climbing the CGI Learning Curve"-->
<link rel="STYLESHEET" type="text/css" href="FILES/style.css">
<link rel="STYLESHEET" type="text/css" href="FILES/docsafari.css">
</head>
<body>
<table width="100%" border="0" cellspacing="0" cellpadding="0" bgcolor="#CCCCCC">
<td><font color="black" size=1>I l<font color="#FF0000">@</font>ve RuBoard</td>
<td valign="top" class="v2" align="right">
	<a href="0596000855_python2-CHP-12-SECT-2.html"><img src="FILES/previous.gif" width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a>
	<a href="0596000855_python2-CHP-12-SECT-4.html"><img src="FILES/next.gif" width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a>
</td></table>
<br>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<tr>
<td valign="top"><A NAME="python2-CHP-12-SECT-3"></A>
<H3 class="docSection1Title">12.3 Climbing the CGI Learning Curve</H3>

<P class="docText">Okay, it's time to get into concrete programming details. This
section introduces CGI coding one step at a time -- from simple,
noninteractive scripts to larger programs that utilize all the common
web page user input devices (what we called "widgets" in
the Tkinter GUI chapters of <A class="docLink" HREF="0596000855_python2-PART-II.html#python2-PART-II">Part II</A>).
We'll move slowly at first, to learn all the basics; the next
two chapters will use the ideas presented here to build up larger and
more realistic web site examples. For now, let's work though a
simple CGI tutorial, with just enough HTML thrown in to write basic
server-side scripts.
</P>

<A NAME="python2-CHP-12-SECT-3.1"></A>
<H4 class="docSection2Title">12.3.1 A First Web Page</H4>

<P class="docText"><A NAME="python2-IDXTERM-1074"></A>
<A NAME="python2-IDXTERM-1075"></A>As
mentioned, CGI scripts are intimately bound up with HTML, so
let's start with a simple HTML page. The file
<I>test0.html</I>, shown in <A class="docLink" HREF="#python2-CHP-12-EX-1">Example 12-1</A>, defines a bona fide, fully functional web
page -- a text file containing HTML code, which specifies the
structure and contents of a simple web page.
</P>


<H5 class="docExampleTitle"><A NAME="python2-CHP-12-EX-1"></A>Example 12-1. PP2E\Internet\Cgi-Web\Basics\test0.html </H5>
<PRE>&lt;HTML&gt;&lt;BODY&gt;
&lt;TITLE&gt;HTML 101&lt;/TITLE&gt;
&lt;H1&gt;A First HTML page&lt;/H1&gt;
&lt;P&gt;Hello, HTML World!&lt;/P&gt;
&lt;/BODY&gt;&lt;/HTML&gt;</PRE>


<P class="docText">If you point your favorite web browser to the Internet address of
this file (or to its local path on your own machine), you should see
a page like that shown in <A class="docLink" HREF="#python2-CHP-12-FIG-2">Figure 12-2</A>. This figure
shows the Internet Explorer browser at work; other browsers render
the page similarly.
</P>

<CENTER>
<H5 class="docFigureTitle"><A NAME="python2-CHP-12-FIG-2"></A>Figure 12-2. A simple web page from an HTML file</H5>
<IMG BORDER="0" WIDTH="466" HEIGHT="203" src="FILES/ppy2_1202.gif" ALT="figs/ppy2_1202.gif"></CENTER>

<P class="docText">To truly understand how this little file does its work, you need to
know something about permission rules, HTML syntax, and Internet
addresses. Let's take a quick first look at each of these
topics before we move on to larger examples.
</P>

<A NAME="python2-CHP-12-SECT-3.1.1"></A>
<H5 class="docSection3Title">12.3.1.1 HTML file permission constraints</H5>

<P class="docText"><A NAME="IXT-12-337494"></A>
<A NAME="IXT-12-337495"></A>
<A NAME="IXT-12-337496"></A>First of all, if you want to
install this code on a different machine, it's usually
necessary to grant web page files and their directories
world-readable permission. That's because they are loaded by
arbitrary people over the Web (actually, by someone named
"nobody", who we'll introduce in a moment). An
appropriate <I>chmod</I> command can be used to change
permissions on Unix-like machines. For instance, a
<TT>chmod</TT> <TT>755</TT>
<TT><I>filename</I></TT> shell command usually suffices;
it makes <TT><I>filename</I></TT> readable and executable
by everyone, and writable by you only.<sup class="docFootnote"><A class="docLink" HREF="#">[2]</A></sup> These directory and file permission details are typical,
but they can vary from server to server. Be sure to find out about
the local server's conventions if you upload this file to your
site.
</P>
<blockquote><p class="docFootnote"><sup><A NAME="">[2]</A></sup> These are not
necessarily magic numbers. On Unix machines, mode 755 is a bit mask.
The first <I>7</I> simply means that you (the
file's owner) can read, write, and execute the file (7 in
binary is 111 -- each bit enables an access mode). The two 5s
(binary 101) say that everyone else (your group and others) can read
and execute (but not write) the file. See your system's manpage
on the <I>chmod</I> command for more details.</p></blockquote>



<A NAME="python2-CHP-12-SECT-3.1.2"></A>
<H5 class="docSection3Title">12.3.1.2 HTML basics</H5>

<P class="docText"><A NAME="IXT-12-337497"></A>I promised
that I wouldn't teach much HTML in this book, but you need to
know enough to make sense of examples. In short, HTML is a
descriptive markup language, based on
<span class="docEmphasis">tags --</span> items enclosed in
<TT>&lt;&gt;</TT> pairs. Some tags stand alone (e.g.,
<TT>&lt;HR&gt;</TT> specifies a horizontal rule). Others
appear in begin/end pairs where the end tag includes an extra slash.
</P>

<P class="docText">For instance, to specify the text of a level-1 header line, we write
HTML code of the form
<TT>&lt;H1&gt;</TT><TT><I>text</I></TT><TT>&lt;/H1&gt;</TT>;
the text between the tags shows up on the web page. Some tags also
allow us to specify options. For example, a tag pair like
<TT>&lt;A</TT>
<TT>href="</TT><TT><I>address</I></TT><TT>"&gt;</TT><TT><I>text</I></TT><TT>&lt;/A&gt;</TT>
specifies a <span class="docEmphasis">hyperlink</span> : pressing the
link's text in the page directs the browser to access the
Internet address (URL) listed in the <TT>href</TT>
option.<A NAME="IXT-12-337498"></A> <A NAME="IXT-12-337499"></A>
</P>

<P class="docText">It's important to keep in mind that HTML is used only to
describe pages: your web browser reads it and translates its
description to a web page with headers, paragraphs, links, and the
like. Notably absent is both <span class="docEmphasis">layout
information --</span> the browser is responsible for arranging
components on the page <span class="docEmphasis">--</span> and syntax for
<span class="docEmphasis">programming logic</span> -- there are no
"if" statements, loops, and so on. There is also no
Python code in this file anywhere to be found; raw HTML is strictly
for defining pages, not for coding programs or specifying all
user-interface details.
</P>

<P class="docText">HTML's lack of user interface control and programmability is
both a strength and a weakness. It's well-suited to describing
pages and simple user interfaces at a high level. The browser, not
you, handles physically laying out the page on your screen. On the
other hand, HTML does not directly support full-blown GUIs and
requires us to introduce CGI scripts (and other technologies) to web
sites, in order to add dynamic programmability to otherwise static
HTML.
</P>



<A NAME="python2-CHP-12-SECT-3.1.3"></A>
<H5 class="docSection3Title">12.3.1.3 Internet addresses (URLs)</H5>

<P class="docText"><A NAME="python2-IDXTERM-1082"></A> <A NAME="python2-IDXTERM-1083"></A>Once
you write an HTML file, you need to put it some place where the
outside world can find it. Like all HTML files,
<I>test0.html</I> must be stored in a directory on the
server machine, from which the resident web server program allows
browsers to fetch pages. On the server where this example lives, the
page's file must be stored in or below the
<I>public_html</I> directory of my personal home
directory -- that is, somewhere in the directory tree rooted at
<I>/home/lutz/public_html</I>. For this section,
examples live in a <I>Basics</I> subdirectory, so the
complete Unix pathname of this file on the server is:
</P>

<PRE>/home/lutz/public_html/Basics/test0.html </PRE>

<P class="docText">This path is different than its
<I>PP2E\Internet\Cgi-Web\Basics</I> location on the
book's CD <A class="docLink" target="_blank" HREF="http://examples.oreilly.com/python2">http://examples.oreilly.com/python2</A>), as given in the example file listing's title.
When you reference this file on the client, though, you must specify
its Internet address, sometimes called a <span class="docEmphasis">URL</span>,
instead. To load the remote page, type the following text in your
browser's address field (or click the example root page's
<A class="docLink" target="_blank" HREF="test0.html">test0.html</A> hyperlink, which
refers to same address):
</P>

<PRE>http://starship.python.net/~lutz/Basics/test0.html</PRE>

<P class="docText">This string is a URL composed of multiple parts:</P>

<A NAME="IXT-12-337500"></A>

<DL class="docList">
<DT><I><span class="docPubcolor">Protocol name: http</span></I></DT>
<DD>
<P class="docList">The protocol part of this URL tells the browser to communicate with
the HTTP server program on the server machine, using the HTTP message
protocol. URLs used in browsers can also name different
protocols -- for example, <span class="docEmphasis">ftp://</span> to reference a file managed by the FTP
protocol and server, <I>telnet</I> to start a Telnet
client session, and so on.
</P>
</DD><DT><I><span class="docPubcolor">Server machine name: starship.python.net</span></I></DT>
<DD>
<P class="docList">A URL also names the target server machine following the protocol
type. Here, we list the domain name of the server machine were the
examples are installed; the machine name listed is used to open a
socket to talk to the server. For HTTP, the socket is usually
connected to port number 80.
</P>
</DD><DT><I><span class="docPubcolor">File path: ~lutz/Basics/test0.html</span></I></DT>
<DD>
<P class="docList">Finally, the URL gives the path to the desired file on the remote
machine. The HTTP web server automatically translates the URL's
file path to the file's true Unix pathname: on my server,
<I>~lutz</I> is automatically translated to the
<I>public_html</I> directory in my home directory. URLs
typically map to such files, but can reference other sorts of items
as well.
</P>
</DD><DT><I><span class="docPubcolor">Parameters (used in later examples)</span></I></DT>
<DD>
<P class="docList">URLs may also be followed by additional input parameters for CGI
programs. When used, they are introduced by a <TT>?</TT>
and separated by <TT>&amp;</TT> characters; for instance, a
string of the form <TT>?name=bob&amp;job=hacker</TT> at the
end of a URL passes parameters named <TT>name</TT> and
<TT>job</TT> to the CGI script named earlier in the URL.
These values are sometimes called URL <span class="docEmphasis">query string
parameters</span> and are treated the same as form inputs. More
on both forms and parameters in a moment.
</P>
</DD>
</DL>

<P class="docText">For completeness, you should also know that URLs can contain
additional information (e.g., the server name part can specify a port
number following a <TT>:</TT>), but we'll ignore
these extra formatting rules here. If you're interested in more
details, you might start by reading the <TT>urlparse</TT>
module's entry in Python's library manual, as well as its
source code in the Python standard library. You might also notice
that a URL you type to access a page looks a bit different after the
page is fetched (spaces become <TT>+</TT> characters,
<TT>%</TT>s are added, etc.). This is simply because
browsers must also generally follow URL escaping (i.e., translation)
conventions, which we'll explore later in this chapter.
</P>



<A NAME="python2-CHP-12-SECT-3.1.4"></A>
<H5 class="docSection3Title">12.3.1.4 Using minimal URLs</H5>

<P class="docText"><A NAME="IXT-12-337501"></A>
<A NAME="IXT-12-337502"></A> <A NAME="IXT-12-337503"></A>Because browsers remember the prior
page's Internet address, URLs embedded in HTML files can often
omit the protocol and server names, as well as the file's
directory path. If missing, the browser simply uses these
components' values from the last page's address. This
minimal syntax works both for URLs embedded in hyperlinks and form
actions (we'll meet forms later in this chapter). For example,
within a page that was fetched from directory
<I>dirpath</I> on server <span class="docEmphasis">www.server.com</span>, minimal hyperlinks and form
actions such as:
</P>

<PRE>&lt;A HREF="more.html"&gt;
&lt;FORM ACTION="next.cgi"  ...&gt;</PRE>

<P class="docText">are treated exactly as if we had specified a complete URL with
explicit server and path components, like the following:
</P>

<PRE>&lt;A HREF="http://www.server.com/dirpath/more.html"&gt;
&lt;FORM ACTION="http://www.server.com/dirpath/next.cgi"  ...&gt;</PRE>

<P class="docText">The first minimal URL refers to file <I>more.html</I>
on the same server and in the same directory that the page containing
this hyperlink was fetched from; it is expanded to a complete URL
within the browser. URLs can also employ Unix-style relative path
syntax in the file path component. For instance, a hyperlink tag like
<TT>&lt;A</TT> <TT>HREF="http://spam.gif"&gt;</TT>
names a GIF file on the server machine and parent directory of the
file that contains this link's URL.
</P>

<P class="docText">Why all the fuss about shorter URLs? Besides extending the life of
your keyboard and eyesight, the main advantage of such minimal URLs
is that they don't need to be changed if you ever move your
pages to a new directory or server -- the server and path are
inferred when the page is used, not hardcoded into its HTML. The
flipside of this can be fairly painful: examples that do include
explicit site and pathnames in URLs embedded within HTML code cannot
be copied to other servers without source code changes. Scripts can
help here, but editing source code can be error-prone.<sup class="docFootnote"><A class="docLink" HREF="#">[3]</A></sup>
</P>
<blockquote><p class="docFootnote"><sup><A NAME="">[3]</A></sup> To make this process easier, the
<I>fixsitename.py</I> script presented in the next
section largely automates the necessary changes by performing global
search-and-replace operations and directory walks. A few book
examples do use complete URLs, so be sure to run this script after
copying examples to a new site.</p></blockquote>

<P class="docText">The downside of minimal URLs is that they don't trigger
automatic Internet connection when followed. This becomes apparent
only when you load pages from local files on your computer. For
example, we can generally open HTML pages without connecting to the
Internet at all, by pointing a web browser to a page's file
that lives on the local machine (e.g., by clicking on its file icon).
When browsing a page locally like this, following a fully specified
URL makes the browser automatically connect to the Internet to fetch
the referenced page or script. Minimal URLs, though, are opened on
the local machine again; usually, the browser simply displays the
referenced page or script's source code.
</P>

<P class="docText">The net effect is that minimal URLs are more portable, but tend to
work better when running all pages live on the Internet. To make it
easier to work with the examples in this book, they will often omit
the server and path components in URLs they contain. In this book, to
derive a page or script's true URL from a minimal URL, imagine
that the string:
</P>

<PRE>http://starship.python.net/~lutz/subdir </PRE>

<P class="docText">appears before the filename given by the URL. Your browser will, even
if you don't.<A NAME="IXTR3-284"></A> <A NAME="IXTR3-285"></A><A NAME="IXTR3-286"></A>
</P>



<A NAME="python2-CHP-12-SECT-3.2"></A>
<H4 class="docSection2Title">12.3.2 A First CGI Script</H4>

<P class="docText"><A NAME="python2-IDXTERM-1091"></A> <A NAME="python2-IDXTERM-1092"></A>
<A NAME="python2-IDXTERM-1093"></A>The HTML file we just saw is just
that -- an HTML file, not a CGI script. When referenced by a
browser, the remote web server simply sends back the file's
text to produce a new page in the browser. To illustrate the nature
of CGI scripts, let's recode the example as a Python CGI
program, as shown in <A class="docLink" HREF="#python2-CHP-12-EX-2">Example 12-2</A>.
</P>


<H5 class="docExampleTitle"><A NAME="python2-CHP-12-EX-2"></A>Example 12-2. PP2E\Internet\Cgi-Web\Basics\test0.cgi </H5>
<PRE>#!/usr/bin/python
#######################################################
# runs on the server, prints html to create a new page;
# executable permissions, stored in ~lutz/public_html,
# url=http://starship.python.net/~lutz/Basics/test0.cgi
#######################################################

print "Content-type: text/html\n"
print "&lt;TITLE&gt;CGI 101&lt;/TITLE&gt;"
print "&lt;H1&gt;A First CGI script&lt;/H1&gt;"
print "&lt;P&gt;Hello, CGI World!&lt;/P&gt;"</PRE>


<P class="docText">This file, <I>test0.cgi</I>, makes the same sort of
page if you point your browser at it (simply replace <A class="docLink" target="_blank" HREF=".html">.html</A> with .<A class="docLink" target="_blank" HREF="cgi">cgi</A> in the URL). But it's a very
different kind of animal -- it's an <span class="docEmphasis">executable
program</span> that is run on the server in response to your
access request. It's also a completely legal Python program, in
which the page's HTML is printed dynamically, rather than being
precoded in a static file. In fact, there is little that is
CGI-specific about this Python program at all; if run from the system
command line, it simply prints HTML rather than generating a browser
page:
</P>

<PRE>C:\...\PP2E\Internet\Cgi-Web\Basics&gt;<B>python test0.cgi</B>
Content-type: text/html

&lt;TITLE&gt;CGI 101&lt;/TITLE&gt;
&lt;H1&gt;A First CGI script&lt;/H1&gt;
&lt;P&gt;Hello, CGI World!&lt;/P&gt;</PRE>

<P class="docText"><A NAME="IXT-12-337504"></A>When run by the HTTP server program on a
web server machine, however, the standard output stream is tied to a
socket read by the browser on the client machine. In this context,
all the output is sent across the Internet to your browser. As such,
it must be formatted per the browser's expectations. In
particular, when the script's output reaches your browser, the
first printed line is interpreted as a header, describing the text
that follows. There can be more than one header line in the printed
response, but there must always be a blank line between the headers
and the start of the HTML code (or other data).
</P>

<P class="docText">In this script, the first header line tells the browser that the rest
of the transmission is HTML text (<A class="docLink" target="_blank" HREF="text/html">text/html</A>), and the newline character (<TT>\n</TT>) at
the end of the first <TT>print</TT> statement generates one
more line-feed than the <TT>print</TT> statement itself.
The rest of this program's output is standard HTML and is used
by the browser to generate a web page on a client, exactly as if the
HTML lived in a static HTML file on the server.<sup class="docFootnote"><A class="docLink" HREF="#">[4]</A></sup>
</P>
<blockquote><p class="docFootnote"><sup><A NAME="">[4]</A></sup> Notice that the script does not generate the enclosing
<TT>&lt;HEAD&gt;</TT> and <TT>&lt;BODY&gt;</TT>
tags in the static HTML file of the prior section. Strictly speaking,
it should -- HTML without such tags is invalid. But all commonly
used browsers simply ignore the omission.</p></blockquote>

<P class="docText">CGI scripts are accessed just like HTML files: you either type the
full URL of this script into your browser's address field, or
click on the <I>test0.cgi</I> link line in the examples
root page (which follows a minimal hyperlink that resolves to the
script's full URL). <A class="docLink" HREF="#python2-CHP-12-FIG-3">Figure 12-3</A> shows the
result page generated if you point your browser at this script to
make it go.
</P>

<CENTER>
<H5 class="docFigureTitle"><A NAME="python2-CHP-12-FIG-3"></A>Figure 12-3. A simple web page from a CGI script</H5>
<IMG BORDER="0" WIDTH="466" HEIGHT="205" src="FILES/ppy2_1203.gif" ALT="figs/ppy2_1203.gif"></CENTER>

<A NAME="python2-CHP-12-SECT-3.2.1"></A>
<H5 class="docSection3Title">12.3.2.1 Installing CGI scripts</H5>

<P class="docText"><A NAME="python2-IDXTERM-1095"></A>
<A NAME="python2-IDXTERM-1096"></A> <A NAME="python2-IDXTERM-1097"></A>Like HTML files, CGI scripts are simple text
files that you can either create on your local machine and upload to
the server by FTP, or write with a text editor running directly on
the server machine (perhaps using a telnet client). However, because
CGI scripts are run as programs, they have some unique installation
requirements that differ from simple HTML files. In particular, they
usually must be stored and named specially, and they must be
configured as programs that are executable by arbitrary users.
Depending on your needs, CGI scripts may also need help finding
imported modules and may need to be converted to the server
platform's text file format after being uploaded. Let's
look at each install constraint in more depth:
</P>

<A NAME="IXT-12-337505"></A><A NAME="IXT-12-337506"></A><A NAME="IXT-12-337507"></A><A NAME="IXT-12-337508"></A><A NAME="IXT-12-337509"></A><A NAME="IXT-12-337510"></A><A NAME="IXT-12-337511"></A><A NAME="IXT-12-337512"></A><A NAME="IXT-12-337513"></A><A NAME="IXT-12-337514"></A><A NAME="IXT-12-337515"></A><A NAME="IXT-12-337516"></A><A NAME="IXT-12-337517"></A><DL class="docList">
<DT><I><span class="docPubcolor">Directory and filename conventions </span></I></DT>
<DD>
<P class="docList"><A NAME="IXT-12-337505"></A>
<A NAME="IXT-12-337506"></A>First of all, CGI scripts need to be
placed in a directory that your web server recognizes as a program
directory, and they need to be given a name that your server
recognizes as a CGI script. On the server where these examples
reside, CGI scripts can be stored in each user's
<I>public_html</I> directory just like HTML files, but
must have a filename ending in a <I>.cgi</I> suffix,
not <I>.py</I>. Some servers allow
<I>.py</I> filename suffixes too, and may recognize
other program directories (<I>cgi-bin</I> is common),
but this varies widely, too, and can sometimes be configured per
server or user.
</P>
</DD><DT><I><span class="docPubcolor">Execution conventions </span></I></DT>
<DD>
<P class="docList"><A NAME="IXT-12-337507"></A>Because they must be executed by the web
server on behalf of arbitrary users on the Web, CGI script files also
need to be given executable file permissions to mark them as
programs, and they must be made executable by others. Again, a shell
command <TT>chmod</TT> <TT>0755</TT>
<TT><I>filename</I></TT> does the trick on most servers.
CGI scripts also generally need the special <TT>#!</TT>
line at the top, to identify the Python interpreter that runs the
file's code. The text after the <TT>#!</TT> in the
first line simply gives the directory path to the Python executable
on your server machine. See <A class="docLink" HREF="0596000855_python2-CHP-2.html#python2-CHP-2">Chapter 2</A>, for more
details on this special first line, and be sure to check your
server's conventions for more details on non-Unix platforms.
</P>

<P class="docList">One subtlety worth noting. As we saw earlier in the book, the special
first line in executable text files can normally contain either a
hardcoded path to the Python interpreter (e.g.,
<I>#!/usr/bin/python</I>) or an invocation of the
<TT>env</TT> program (e.g., <I>#!/usr/bin/env
python</I>), which deduces where Python lives from environment
variable settings (i.e., your $PATH). The <TT>env</TT>
trick is less useful in CGI scripts, though, because their
environment settings are those of user "nobody" (not your
own), as explained in the next
paragraph.<A NAME="IXT-12-337508"></A>
</P>
</DD><DT><I><span class="docPubcolor">Module search path configuration (optional)</span></I></DT>
<DD>
<P class="docList"><A NAME="IXT-12-337509"></A>
<A NAME="IXT-12-337510"></A>
<A NAME="IXT-12-337511"></A>HTTP servers generally run CGI
scripts with username "nobody" for security reasons (this
limits the user's access to the server machine). That's
why files you publish on the Web must have special permission
settings that make them accessible to other users. It also means that
CGI scripts can't rely on the Python module search path to be
configured in any particular way. As we've seen, the module
path is normally initialized from the user's PYTHONPATH setting
plus defaults. But because CGI scripts are run by user
"nobody", PYTHONPATH may be arbitrary when a CGI script
runs.<A NAME="IXT-12-337512"></A> <A NAME="IXT-12-337513"></A>
<A NAME="IXT-12-337514"></A>
</P>

<P class="docList">Before you puzzle over this too hard, you should know that this is
often not a concern in practice. Because Python usually searches the
current directory for imported modules by default, this is not an
issue if all of your scripts and any modules and packages they use
are stored in your web directory (which is the installation structure
on the book's site). But if the module lives elsewhere, you may
need to tweak the <TT>sys.path</TT> list in your scripts to
adjust the search path manually before imports (e.g., with
<TT>sys.path.append(</TT><TT><I>dirname</I></TT><TT>)</TT>
calls, index assignments, and so on).
</P>
</DD><DT><I><span class="docPubcolor">End-of-line conventions (optional)</span></I></DT>
<DD>
<P class="docList"><A NAME="IXT-12-337515"></A>
<A NAME="IXT-12-337516"></A>
<A NAME="IXT-12-337517"></A>Finally, on some Unix (and Linux)
servers, you might also have to make sure that your script text files
follow the Unix end-of-line convention (<TT>\n</TT>), not
DOS (<TT>\r\n</TT>). This isn't an issue if you edit
and debug right on the server (or on another Unix machine) or FTP
files one by one in text mode. But if you edit and upload your
scripts from a PC to a Unix server in a tar file (or in FTP binary
mode), you may need to convert end-of-lines after the upload. For
instance, the server that was used to develop this text returns a
default error page for scripts whose end-of-lines are in DOS format
(see later in this chapter for a converter script).
</P>
</DD>
</DL>

<P class="docText">This installation process may sound a bit complex at first glance,
but it's not bad once you've worked through it on your
own: it's only a concern at install time and can usually be
automated to some extent with Python scripts run on the server. To
summarize, most Python CGI scripts are text files of Python code,
which:
</P>

<UL>
<LI><P class="docList">Are named according to your web server's conventions (e.g.,
<A class="docLink" target="_blank" HREF="file.cgi">file.cgi</A>)
</P></LI>
<LI><P class="docList">Are stored in a directory recognized by your web server (e.g.,
<I>cgi-bin/ </I>)
</P></LI>
<LI><P class="docList">Are given executable file permissions (e.g., <TT>chmod 755
file.cgi</TT>)
</P></LI>
<LI><P class="docList">Usually have the special <TT>#!pythonpath</TT> line at the
top (but not <TT>env</TT>)
</P></LI>
<LI><P class="docList">Configure <TT>sys.path</TT> only if needed to see modules
in other directories
</P></LI>
<LI><P class="docList">Use Unix end-of-line conventions, only if your server rejects DOS
format
</P></LI>
<LI><P class="docList">Print headers and HTML to generate a response page in the browser, if
any
</P></LI>
<LI><P class="docList">Use the <TT>cgi</TT> module to parse incoming form data, if
any (more about forms later in this chapter)
</P></LI>
</UL>
<P class="docText">Even if you must use a server machine configured by someone else,
most of the machine's conventions should be easy to root out.
For instance, on some servers you can rename this example to
<I>test0.py</I> and it will continue to be run when
accessed. On others, you might instead see the file's source
code in a popped-up text editor when you access it. Try a <A class="docLink" target="_blank" HREF=".cgi">.cgi</A> suffix if the text is displayed rather
than executed. CGI directory conventions can vary, too, but try the
directory where you normally store HTML files first. As usual, you
should consult the conventions for any machine that you plan to copy
these example files to.<A NAME="IXTR3-287"></A> <A NAME="IXTR3-288"></A>
</P>



<A NAME="python2-CHP-12-SECT-3.2.2"></A>
<H5 class="docSection3Title">12.3.2.2 Automating installation steps</H5>

<P class="docText"><A NAME="python2-IDXTERM-1113"></A>But
wait -- why do things the hard way? Before you start installing
scripts by hand, remember that Python programs can usually do much of
your work for you. It's easy to write Python scripts that
automate some of the CGI installation steps using the operating
systems tools that we met earlier in the book.
</P>

<P class="docText">For instance, while developing the examples in this chapter, I did
all editing on my PC (it's generally more dependable than a
telnet client). To install, I put all the examples in a
<TT>tar</TT> file, which is uploaded to the Linux server by
FTP in a single step. Unfortunately, my server expects CGI scripts to
have Unix (not DOS) end-of-line markers; unpacking the
<TT>tar</TT> file did not convert end-of-lines or retain
executable permission settings. But rather than tracking down all the
web CGI scripts and fixing them by hand, I simply run the Python
script in <A class="docLink" HREF="#python2-CHP-12-EX-3">Example 12-3</A> from within a Unix
<I>find</I> command after each upload.
</P>


<H5 class="docExampleTitle"><A NAME="python2-CHP-12-EX-3"></A>Example 12-3. PP2E\Internet\Cgi-Web\fixcgi.py </H5>
<PRE>########################################################################
# run fom a unix find command to automate some cgi script install steps;
# example:  find . -name "*.cgi" -print -exec python fixcgi.py \{} \;
# which converts all cgi scripts to unix line-feed format (needed on 
# starship) and gives all cgi files executable mode, else won't be run;
# do also: chmod 777 PyErrata/DbaseFiles/*, vi Extern/Email/mailconfig*;
# related: fixsitename.py, PyTools/fixeoln*.py, System/Filetools
########################################################################

# after: ungzip, untar, cp -r Cgi-Web/* ~/public_html

import sys, string, os
fname = sys.argv[1]
old   = open(fname, 'rb').read(  )
new   = string.replace(old, '\r\n', '\n')
open(fname, 'wb').write(new)
if fname[-3:] == 'cgi': os.chmod(fname, 0755)       # note octal int: rwx,sgo</PRE>


<P class="docText">This script is kicked off at the top of the
<I>Cgi-Web</I> directory, using a Unix
<TT>csh</TT> shell command to apply it to every CGI file in
a directory tree, like this:
</P>

<PRE>% <B>find . -name "*.cgi" -print -exec python fixcgi.py \{} \; </B>
./Basics/languages-src.cgi
./Basics/getfile.cgi
./Basics/languages.cgi
./Basics/languages2.cgi
./Basics/languages2reply.cgi
./Basics/putfile.cgi
<I> ...more...</I></PRE>

<P class="docText">Recall from <A class="docLink" HREF="0596000855_python2-CHP-2.html#python2-CHP-2">Chapter 2</A> that there are various ways to walk directory
trees and find matching files in pure Python code, including the
<TT>find</TT> module, <TT>os.path.walk</TT>, and
one we'll use in the next section's script. For instance,
a pure Python and more portable alternative could be kicked off like
this:
</P>

<PRE>C:\...\PP2E\Internet\Cgi-Web&gt;<B>python </B>
&gt;&gt;&gt; <B>import os </B>
&gt;&gt;&gt; <B>from PP2E.PyTools.find import find </B>
&gt;&gt;&gt; <B>for filename in find('*.cgi', '.'): </B>
...     <B>print filename </B>
...     <B>stat = os.system('python fixcgi.py ' + filename) </B>
...
.\Basics\getfile.cgi
.\Basics\languages-src.cgi
.\Basics\languages.cgi
.\Basics\languages2.cgi
<I> ...more...</I></PRE>

<P class="docText">The Unix <I>find</I> command simply does the same, but
outside the scope of Python: the command line after
-<TT>exec</TT> is run for each matching file found. For
more details about the <TT>find</TT> command, see its
manpage. Within the Python script, <TT>string.replace</TT>
translates to Unix end-of-line markers, and
<TT>os.chmod</TT> works just like a shell
<I>chmod</I> command. There are other ways to translate
end-of-lines, too; see <A class="docLink" HREF="0596000855_python2-CHP-5.html#python2-CHP-5">Chapter 5</A>.<A NAME="IXTR3-289"></A>
</P>



<A NAME="python2-CHP-12-SECT-3.2.3"></A>
<H5 class="docSection3Title">12.3.2.3 Automating site move edits</H5>

<P class="docText"><A NAME="python2-IDXTERM-1115"></A> <A NAME="python2-IDXTERM-1116"></A> <A NAME="python2-IDXTERM-1117"></A>Speaking
of installation tasks, a common pitfall of web programming is that
hardcoded site names embedded in HTML code stop working the minute
you relocate the site to a new server. Minimal URLs (just the
filename) are more portable, but for various reasons are not always
used. Somewhere along the way, I also grew tired of updating URLs in
hyperlinks and form actions, and wrote a Python script to do it all
for me (see <A class="docLink" HREF="#python2-CHP-12-EX-4">Example 12-4</A>).
</P>


<H5 class="docExampleTitle"><A NAME="python2-CHP-12-EX-4"></A>Example 12-4. PP2E\Internet\Cgi-Web\fixsitename.py </H5>
<PRE>#!/usr/bin/env python
###############################################################
# run this script in Cgi-Web dir after copying book web 
# examples to a new server--automatically changes all starship 
# server references in hyperlinks and form action tags to the 
# new server/site; warns about references that weren't changed
# (may need manual editing); note that starship references are 
# not usually needed or used--since browsers have memory, server 
# and path can usually be omitted from a URL in the prior page 
# if it lives at the same place (e.g., "file.cgi" is assumed to 
# be in the same server/path as a page that contains this name,
# with a real url like "http://lastserver/lastpath/file.cgi"),
# but a handful of URLs are fully specified in book examples;
# reuses the Visitor class developed in the system chapters,
# to visit and convert all files at and below current dir;
###############################################################

import os, string
from PP2E.PyTools.visitor import FileVisitor           # os.path.walk wrapper

listonly = 0
oldsite  = 'starship.python.net/~lutz'                 # server/rootdir in book
newsite  = 'XXXXXX/YYYYYY'                             # change to your site
warnof   = ['starship.python', 'lutz']                 # warn if left after fix
fixext   = ['.py', '.html', '.cgi']                    # file types to check

class FixStarship(FileVisitor):
    def __init__(self, listonly=0):                     # replace oldsite refs
        FileVisitor.__init__(self, listonly=listonly)   # in all web text files
        self.changed, self.warning = [], []             # need diff lists here
    def visitfile(self, fname):                         # or use find.find list
        FileVisitor.visitfile(self, fname)
        if self.listonly:
            return
        if os.path.splitext(fname)[1] in fixext:
            text = open(fname, 'r').read(  )
            if string.find(text, oldsite) != -1:    
                text = string.replace(text, oldsite, newsite)
                open(fname, 'w').write(text)
                self.changed.append(fname)
            for word in warnof:
                if string.find(text, word) != -1:
                    self.warning.append(fname); break

if __name__ == '__main__':
    # don't run auto if clicked
    go = raw_input('This script changes site in all web files; continue?') 
    if go != 'y':
        raw_input('Canceled - hit enter key')
    else:
        walker = FixStarship(listonly)
        walker.run(  )
        print 'Visited %d files and %d dirs' % (walker.fcount, walker.dcount)

        def showhistory(label, flist):
            print '\n%s in %d files:' % (label, len(flist))
            for fname in flist:
                print '=&gt;', fname
        showhistory('Made changes', walker.changed)
        showhistory('Saw warnings', walker.warning)

        def edithistory(flist):
            for fname in flist:                      # your editor here
                os.system('vi ' + fname) 
        if raw_input('Edit changes?') == 'y':  edithistory(walker.changed)
        if raw_input('Edit warnings?') == 'y': edithistory(walker.warning)</PRE>


<P class="docText"><A NAME="IXT-12-337518"></A>This is a more complex script that
reuses the <I>visitor.py</I> module we wrote in <A class="docLink" HREF="0596000855_python2-CHP-5.html#python2-CHP-5">Chapter 5</A> to wrap the <TT>os.path.walk</TT>
call. If you read that chapter, this script will make sense. If not,
we won't go into many more details here again. Suffice it to
say that this program visits all source code files at and below the
directory where it is run, globally changing all <span class="docEmphasis">starship.python.net/~lutz</span> appearances to
whatever you've assigned to variable <TT>newsite</TT>
within the script. On request, it will also launch your editor to
view files changed, as well as files that contain potentially
suspicious strings. As coded, it launches the Unix vi text editor at
the end, but you can change this to start whatever editor you like
(this is Python, after all):
</P>

<PRE>C:\...\PP2E\Internet\Cgi-Web&gt;<B>python fixsitename.py </B>
This script changes site in all web files; continue?<B>y </B>
. ...
1 =&gt; .\PyInternetDemos.html
2 =&gt; .\README.txt
3 =&gt; .\fixcgi.py
4 =&gt; .\fixsitename.py
5 =&gt; .\index.html
6 =&gt; .\python_snake_ora.gif
.\Basics ...
7 =&gt; .\Basics\mlutz.jpg
8 =&gt; .\Basics\languages.html
9 =&gt; .\Basics\languages-src.cgi
<I> ...more...</I>
146 =&gt; .\PyMailCgi\temp\secret.doc.txt
Visited 146 files and 16 dirs

Made changes in 8 files:
=&gt; .\fixsitename.py
=&gt; .\Basics\languages.cgi
=&gt; .\Basics\test3.html
=&gt; .\Basics\test0.py
=&gt; .\Basics\test0.cgi
=&gt; .\Basics\test5c.html
=&gt; .\PyMailCgi\commonhtml.py
=&gt; .\PyMailCgi\sendurl.py

Saw warnings in 14 files:
=&gt; .\PyInternetDemos.html
=&gt; .\fixsitename.py
=&gt; .\index.html
=&gt; .\Basics\languages.cgi
<I> ...more...</I>
=&gt; .\PyMailCgi\pymailcgi.html
=&gt; .\PyMailCgi\commonhtml.py
=&gt; .\PyMailCgi\sendurl.py
Edit changes?<B>n </B>
Edit warnings?<B>y </B></PRE>

<P class="docText">The net effect is that this script automates part of the site
relocation task: running it will update all pages' URLs for the
new site name automatically, which is considerably less aggravating
than manually hunting down and editing each such reference by hand.
</P>

<P class="docText">There aren't many hardcoded <I>starship</I> site
references in web examples in this book (the script found and fixed
eight above), but be sure to run this script in the
<I>Cgi-Web</I> directory from a command line, after
copying the book examples to your own site. To use this script for
other site moves, simply set both <TT>oldsite</TT> and
<TT>newsite</TT> as appropriate. The truly ambitious
scriptmaster might even run such a script from within another that
first copies a site's contents by FTP (see
<TT>ftplib</TT> in the previous chapter).<sup class="docFootnote"><A class="docLink" HREF="#">[5]</A></sup><A NAME="IXTR3-290"></A> <A NAME="IXTR3-291"></A> <A NAME="IXTR3-292"></A>
</P>
<blockquote><p class="docFootnote"><sup><A NAME="">[5]</A></sup> As I mentioned at the start of this chapter, there are often
multiple ways to accomplish any given webmaster-y task. For instance,
the HTML <TT>&lt;BASE&gt;</TT> tag may provide an
alternative way to map absolute URLs, and FTPing your web site files
to your server individually and in text mode might obviate line-end
issues. There are undoubtedly other ways to handle such tasks, too.
On the other hand, such alternatives wouldn't be all that
useful in a book that illustrates Python coding techniques.</p></blockquote>



<A NAME="python2-CHP-12-SECT-3.2.4"></A>
<H5 class="docSection3Title">12.3.2.4 Finding Python on the server</H5>

<P class="docText"><A NAME="IXT-12-337519"></A>
<A NAME="IXT-12-337520"></A> <A NAME="IXT-12-337521"></A>One last install pointer: even though
Python doesn't have to be installed on any
<span class="docEmphasis">clients</span> in the context of a server-side web
application, it does have to exist on the <span class="docEmphasis">server</span>
machine where your CGI scripts are expected to run. If you are using
a web server that you did not configure yourself, you must be sure
that Python lives on that machine. Moreover, you need to find where
it is on that machine so that you can specify its path in the
<TT>#!</TT> line at the top of your script.
</P>

<P class="docText">By now, Python is a pervasive tool, so this generally isn't as
big a concern as it once was. As time goes by, it will become even
more common to find Python as a standard component of server
machines. But if you're not sure if or where Python lives on
yours, here are some tips:
</P>

<UL>
<LI><P class="docList"><A NAME="IXT-12-337522"></A>Especially on Unix systems, you
should first assume that Python lives in a standard place (e.g.,
<I>/usr/local/bin/python</I>), and see if it works.
Chances are that Python already lives on such machines. If you have
Telnet access on your server, a Unix <I>find</I> command
starting at <I>/usr</I> may help.
</P></LI>
<LI><P class="docList"><A NAME="IXT-12-337523"></A>If your server runs Linux,
you're probably set to go. Python ships as a standard part of
Linux distributions these days, and many web sites and Internet
Service Providers (ISPs) run the Linux operating system; at such
sites, Python probably already lives at
<I>/usr/bin/python</I>.
</P></LI>
<LI><P class="docList">In other environments where you cannot control the server machine
yourself, it may be harder to obtain access to an already-installed
Python. If so, you can relocate your site to a server that does have
Python installed, talk your ISP into installing Python on the machine
you're trying to use, or install Python on the server machine
yourself.
</P></LI>
</UL>
<P class="docText"><A NAME="IXT-12-337524"></A>If
your ISP is unsympathetic to your need for Python and you are willing
to relocate your site to one that is, you can find lists of
Python-friendly ISPs by searching <A class="docLink" target="_blank" HREF="http://www.python.org/default.htm">http://www.python.org</A>. And if you choose to
install Python on your server machine yourself, be sure to check out
the <span class="docEmphasis">freeze</span> tool shipped with the Python source
distribution (in the <I>Tools</I> directory). With
<span class="docEmphasis">freeze</span>, you can create a single executable
program file that contains the entire Python interpreter, as well as
all the standard library modules. Such a frozen interpreter can be
uploaded to your web account by FTP in a single step, and it
won't require a full-blown Python installation on the
server.<A NAME="IXTR3-293"></A> <A NAME="IXTR3-294"></A> <A NAME="IXTR3-295"></A><A NAME="IXT-12-337525"></A> <A NAME="IXT-12-337526"></A>
</P>



<A NAME="python2-CHP-12-SECT-3.3"></A>
<H4 class="docSection2Title">12.3.3 Adding Pictures and Generating Tables</H4>

<P class="docText"><A NAME="python2-IDXTERM-1133"></A> <A NAME="python2-IDXTERM-1134"></A> <A NAME="python2-IDXTERM-1135"></A><A NAME="python2-IDXTERM-1136"></A> <A NAME="python2-IDXTERM-1137"></A> <A NAME="python2-IDXTERM-1138"></A>Now let's
get back to writing server-side code. As anyone who's ever
surfed the Web knows, web pages usually consist of more than simple
text. <A class="docLink" HREF="#python2-CHP-12-EX-5">Example 12-5</A> is a Python CGI script that prints
an <TT>&lt;IMG&gt;</TT> HTML tag in its output to produce a
graphic image in the client browser. There's not much
Python-specific about this example, but note that just as for simple
HTML files, the image file (<I>ppsmall.gif </I>) lives
on and is downloaded from the server machine when the browser
interprets the output of this script.
</P>


<H5 class="docExampleTitle"><A NAME="python2-CHP-12-EX-5"></A>Example 12-5. PP2E\Internet\Cgi-Web\Basics\test1.cgi </H5>
<PRE>#!/usr/bin/python

text = """Content-type: text/html

&lt;TITLE&gt;CGI 101&lt;/TITLE&gt;
&lt;H1&gt;A Second CGI script&lt;/H1&gt;
&lt;HR&gt;
&lt;P&gt;Hello, CGI World!&lt;/P&gt;
&lt;IMG src="ppsmall.gif" BORDER=1 ALT=[image]&gt;
&lt;HR&gt;
"""

print text</PRE>


<P class="docText">Notice the use of the triple-quoted string block here; the entire
HTML string is sent to the browser in one fell swoop, with the print
statement at the end. If client and server are both functional, a
page that looks like <A class="docLink" HREF="#python2-CHP-12-FIG-4">Figure 12-4</A> will be generated
when this script is referenced and run.
</P>

<CENTER>
<H5 class="docFigureTitle"><A NAME="python2-CHP-12-FIG-4"></A>Figure 12-4. A page with an image generated by test1.cgi</H5>
<IMG BORDER="0" WIDTH="341" HEIGHT="284" src="FILES/ppy2_1204.gif" ALT="figs/ppy2_1204.gif"></CENTER>

<P class="docText">So far, our CGI scripts have been putting out canned HTML that could
have just as easily been stored in an HTML file. But because CGI
scripts are executable programs, they can also be used to generate
HTML on the fly, dynamically -- even, possibly, in response to a
particular set of user inputs sent to the script. That's the
whole purpose of CGI scripts, after all. Let's start using this
to better advantage now, and write a Python script that builds up
response HTML programmatically (see <A class="docLink" HREF="#python2-CHP-12-EX-6">Example 12-6</A>).
</P>


<H5 class="docExampleTitle"><A NAME="python2-CHP-12-EX-6"></A>Example 12-6. PP2E\Internet\Cgi-Web\Basics\test2.cgi </H5>
<PRE>#!/usr/bin/python

print """Content-type: text/html

&lt;TITLE&gt;CGI 101&lt;/TITLE&gt;
&lt;H1&gt;A Third CGI script&lt;/H1&gt;
&lt;HR&gt;
&lt;P&gt;Hello, CGI World!&lt;/P&gt;

&lt;table border=1&gt;
"""

for i in range(5):
    print "&lt;tr&gt;"
    for j in range(4):
        print "&lt;td&gt;%d.%d&lt;/td&gt;" % (i, j)
    print "&lt;/tr&gt;"

print """
&lt;/table&gt;
&lt;HR&gt;
"""</PRE>


<P class="docText">Despite all the tags, this really is Python code -- the
<I>test2.cgi</I> script uses triple-quoted strings to
embed blocks of HTML again. But this time, the script also uses
nested Python <TT>for</TT> loops to dynamically generate
part of the HTML that is sent to the browser. Specifically, it emits
HTML to lay out a two-dimensional table in the middle of a page, as
shown in <A class="docLink" HREF="#python2-CHP-12-FIG-5">Figure 12-5</A>.
</P>

<CENTER>
<H5 class="docFigureTitle"><A NAME="python2-CHP-12-FIG-5"></A>Figure 12-5. A page with a table generated by test2.cgi</H5>
<IMG BORDER="0" WIDTH="341" HEIGHT="284" src="FILES/ppy2_1205.gif" ALT="figs/ppy2_1205.gif"></CENTER>

<P class="docText">Each row in the table displays a "row.column" pair, as
generated by the executing Python script. If you're curious how
the generated HTML looks, select your browser's View Source
option after you've accessed this page. It's a single
HTML page composed of the HTML generated by the first
<TT>print</TT> in the script, then the
<TT>for</TT> loops, and finally the last
<TT>print</TT>. In other words, the concatenation of this
script's output is an HTML document with headers.
</P>

<A NAME="python2-CHP-12-SECT-3.3.1"></A>
<H5 class="docSection3Title">12.3.3.1 Table tags</H5>

<P class="docText"><A NAME="IXT-12-337527"></A>
<A NAME="IXT-12-337528"></A>This script
generates HTML table tags. Again, we're not out to learn HTML
here, but we'll take a quick look just so you can make sense of
the example. Tables are declared by the text between
<TT>&lt;table&gt;</TT> and
<TT>&lt;/table&gt;</TT> tags in HTML. Typically, a
table's text in turn declares the contents of each table row
between <TT>&lt;tr&gt;</TT> and
<TT>&lt;/tr&gt;</TT> tags and each column within a row
between <TT>&lt;td&gt;</TT> and
<TT>&lt;/td&gt;</TT> tags. The loops in our script build up
HTML to declare five rows of four columns each, by printing the
appropriate tags, with the current row and column number as column
values. For instance, here is part of the script's output,
defining the first two rows:
</P>

<PRE>&lt;table border=1&gt;
&lt;tr&gt;
&lt;td&gt;0.0&lt;/td&gt;
&lt;td&gt;0.1&lt;/td&gt;
&lt;td&gt;0.2&lt;/td&gt;
&lt;td&gt;0.3&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;1.0&lt;/td&gt;
&lt;td&gt;1.1&lt;/td&gt;
&lt;td&gt;1.2&lt;/td&gt;
&lt;td&gt;1.3&lt;/td&gt;
&lt;/tr&gt;
. . .
&lt;/table&gt;</PRE>

<P class="docText">Other table tags and options let us specify a row title
(<TT>&lt;th&gt;</TT>), layout borders, and so on.
We'll see more table syntax put to use to lay out forms in a
later section.<A NAME="IXTR3-296"></A> <A NAME="IXTR3-297"></A> <A NAME="IXTR3-298"></A><A NAME="IXTR3-299"></A> <A NAME="IXTR3-300"></A> <A NAME="IXTR3-301"></A>
</P>



<A NAME="python2-CHP-12-SECT-3.4"></A>
<H4 class="docSection2Title">12.3.4 Adding User Interaction</H4>

<P class="docText"><A NAME="python2-IDXTERM-1147"></A> <A NAME="python2-IDXTERM-1148"></A> <A NAME="python2-IDXTERM-1149"></A><A NAME="python2-IDXTERM-1150"></A>CGI scripts are great at generating HTML on
the fly like this, but they are also commonly used to implement
interaction with a user typing at a web browser. As described earlier
in this chapter, web interactions usually involve a two-step process
and two distinct web pages: you fill out a form page and press
submit, and a reply page eventually comes back. In between, a CGI
script processes the form input.
</P>

<A NAME="python2-CHP-12-SECT-3.4.1"></A>
<H5 class="docSection3Title">12.3.4.1 Submission</H5>

<P class="docText">That description sounds simple enough, but the process of collecting
user inputs requires an understanding of a special HTML tag,
<TT>&lt;form&gt;</TT>. Let's look at the
implementation of a simple web interaction to see forms at work.
First off, we need to define a form page for the user to fill out, as
shown in <A class="docLink" HREF="#python2-CHP-12-EX-7">Example 12-7</A>.
</P>


<H5 class="docExampleTitle"><A NAME="python2-CHP-12-EX-7"></A>Example 12-7. PP2E\Internet\Cgi-Web\Basics\test3.html </H5>
<PRE>&lt;html&gt;&lt;body&gt;
&lt;title&gt;CGI 101&lt;/title&gt;
&lt;H1&gt;A first user interaction: forms&lt;/H1&gt;
&lt;hr&gt;
<B>&lt;form method=POST action="http://starship.python.net/~lutz/Basics/test3.cgi"&gt;</B>
    &lt;P&gt;&lt;B&gt;Enter your name:&lt;/B&gt;
    &lt;P&gt;&lt;input type=text name=user&gt;
    &lt;P&gt;&lt;input type=submit&gt;
&lt;/form&gt;
&lt;/BODY&gt;&lt;/HTML&gt;</PRE>


<P class="docText"><I>test3.html </I>is a simple HTML file, not a CGI
script (though its contents could be printed from a script as well).
When this file is accessed, all the text between its
<TT>&lt;form&gt;</TT> and <TT>&lt;/form&gt;</TT>
tags generate the input fields and Submit button shown in <A class="docLink" HREF="#python2-CHP-12-FIG-6">Figure 12-6</A>.
</P>

<CENTER>
<H5 class="docFigureTitle"><A NAME="python2-CHP-12-FIG-6"></A>Figure 12-6. A simple form page generated by test3.html</H5>
<IMG BORDER="0" WIDTH="296" HEIGHT="210" src="FILES/ppy2_1206.gif" ALT="figs/ppy2_1206.gif"></CENTER>



<A NAME="python2-CHP-12-SECT-3.4.2"></A>
<H5 class="docSection3Title">12.3.4.2 More on form tags</H5>

<P class="docText"><A NAME="IXT-12-337529"></A>
<A NAME="IXT-12-337530"></A>
<A NAME="IXT-12-337531"></A>We
won't go into all the details behind coding HTML forms, but a
few highlights are worth underscoring. Within a form's HTML
code:
</P>

<UL>
<LI><P class="docList">The form's <TT>action</TT> option gives the URL of a
CGI script that will be invoked to process submitted form data. This
is the link from a form to its handler
program <span class="docEmphasis">--</span> in this case, a program called
<I>test3.cgi</I> in my web home directory, on a server
machine called <span class="docEmphasis">starship.python.net</span>. The
<TT>action</TT> option is the moral equivalent to
<TT>command</TT> options in Tkinter
buttons -- it's where a callback handler (here, a remote
handler) is registered to the browser.
</P></LI>
<LI><P class="docList">Input controls are specified with nested
<TT>&lt;input&gt;</TT> tags. In this example, input tags
have two key options. The <TT><I>type</I></TT> option
accepts values such as <TT>text</TT> for text fields and
<TT>submit</TT> for a Submit button (which sends data to
the server and is labeled "Submit Query" by default). The
<TT><I>name</I></TT> option is the hook used to identify
the entered value by key, once all the form data reaches the server.
For instance, the server-side CGI script we'll see in a moment
uses the string <TT>user</TT> as a key to get the data
typed into this form's text field. As we'll see in later
examples, other input tag options can specify initial values
(<TT>value=X</TT>), display-only mode
(<TT>readonly</TT>), and so on. Other input
<TT><I>type</I></TT> option values may transmit hidden
data (<TT>type=hidden</TT>), reinitialize fields
(<TT>type=reset</TT>), or make multiple-choice buttons
(<TT>type=checkbox)</TT>.
</P></LI>
<LI><P class="docList">Forms also include a <TT>method</TT> option to specify the
encoding style to be used to send data over a socket to the target
server machine. Here, we use the <TT>post</TT> style, which
contacts the server and then ships it a stream of user input data in
a separate transmission. An alternative <TT>get</TT> style
ships input information to the server in a single transmission step,
by adding user inputs to the end of the URL used to invoke the
script, usually after a <TT>?</TT> character (more on this
soon). With <TT>get</TT>, inputs typically show up on the
server in environment variables or as arguments in the command line
used to start the script. With <TT>post</TT>, they must be
read from standard input and decoded. Luckily, Python's
<TT>cgi</TT> module transparently handles either encoding
style, so our CGI scripts don't need to know or care which is
used.
</P></LI>
</UL>
<P class="docText">Notice that the action URL in this example's form spells out
the full address for illustration. Because the browser remembers
where the enclosing HTML page came from, it works the same with just
the script's filename, as shown in <A class="docLink" HREF="#python2-CHP-12-EX-8">Example 12-8</A>.
</P>


<H5 class="docExampleTitle"><A NAME="python2-CHP-12-EX-8"></A>Example 12-8. PP2E\Internet\Cgi-Web\Basics\test3-minimal.html </H5>
<PRE>&lt;html&gt;&lt;body&gt;
&lt;title&gt;CGI 101&lt;/title&gt;
&lt;H1&gt;A first user interaction: forms&lt;/H1&gt;
&lt;hr&gt;
<B>&lt;form method=POST action="test3.cgi"&gt;</B>
    &lt;P&gt;&lt;B&gt;Enter your name:&lt;/B&gt;
    &lt;P&gt;&lt;input type=text name=user&gt;
    &lt;P&gt;&lt;input type=submit&gt;
&lt;/form&gt;
&lt;/BODY&gt;&lt;/HTML&gt;</PRE>


<P class="docText"><A NAME="IXT-12-337532"></A>
<A NAME="IXT-12-337533"></A> <A NAME="IXT-12-337534"></A>It may help to remember that URLs
embedded in form action tags and hyperlinks are directions to the
browser first, not the script. The <I>test3.cgi</I>
script itself doesn't care which URL form is used to trigger
it -- minimal or complete. In fact, all parts of a URL through the
script filename (and up to URL query parameters) is used in the
conversation between browser and HTTP server, before a CGI script is
ever spawned. As long as the browser knows which server to contact,
the URL will work, but URLs outside of a page (e.g., typed into a
browser's address field or sent to Python's
<TT>urllib</TT> module) usually must be completely
specified, because there is no notion of a prior page.
</P>



<A NAME="python2-CHP-12-SECT-3.4.3"></A>
<H5 class="docSection3Title">12.3.4.3 Response</H5>

<P class="docText">So far, we've created only a static page with an input field.
But the Submit button on this page is loaded to work magic. When
pressed, it triggers the remote program whose URL is listed in the
form's <TT>action</TT> option, and passes this
program the input data typed by the user, according to the
form's <TT>method</TT> encoding style option. On the
server, a Python script is started to handle the form's input
data while the user waits for a reply on the client, as shown in
<A class="docLink" HREF="#python2-CHP-12-EX-9">Example 12-9</A>.
</P>


<H5 class="docExampleTitle"><A NAME="python2-CHP-12-EX-9"></A>Example 12-9. PP2E\Internet\Cgi-Web\Basics\test3.cgi </H5>
<PRE>#!/usr/bin/python
#######################################################
# runs on the server, reads form input, prints html;
# url=http://server-name/root-dir/Basics/test3.cgi
#######################################################

import cgi
form = cgi.FieldStorage(  )            # parse form data
print "Content-type: text/html"      # plus blank line

html = """
&lt;TITLE&gt;test3.cgi&lt;/TITLE&gt;
&lt;H1&gt;Greetings&lt;/H1&gt;
&lt;HR&gt;
&lt;P&gt;%s&lt;/P&gt;
&lt;HR&gt;"""

if not form.has_key('user'):
    print html % "Who are you?"
else:
    print html % ("Hello, %s." % form['user'].value)</PRE>


<P class="docText"><A NAME="IXT-12-337535"></A> <A NAME="IXT-12-337536"></A>As before, this Python CGI script prints
HTML to generate a response page in the client's browser. But
this script does a bit more: it also uses the standard
<TT>cgi</TT> module to parse the input data entered by the
user on the prior web page (see <A class="docLink" HREF="#python2-CHP-12-FIG-6">Figure 12-6</A>).
Luckily, this is all automatic in Python: a call to the
<TT>cgi</TT> module's <TT>FieldStorage</TT>
class automatically does all the work of extracting form data from
the input stream and environment variables, regardless of how that
data was passed -- in a <TT>post</TT> style stream or in
<TT>get</TT> style parameters appended to the URL. Inputs
sent in both styles look the same to Python scripts.
</P>

<P class="docText"><A NAME="IXT-12-337537"></A>Scripts
should call <TT>cgi.FieldStoreage</TT> only once and before
accessing any field values. When called, we get back an object that
looks like a dictionary <span class="docEmphasis">--</span> user input fields
from the form (or URL) show up as values of keys in this object. For
example, in the script, <TT>form['user']</TT> is an object
whose <TT>value</TT> attribute is a string containing the
text typed into the form's text field. If you flip back to the
form page's HTML, you'll notice that the input
field's <TT>name</TT> option was
<TT>user</TT> -- the name in the form's HTML has
become a key we use to fetch the input's value from a
dictionary. The object returned by <TT>FieldStorage</TT>
supports other dictionary operations, too -- for instance, the
<TT>has_key</TT> method may be used to check if a field is
present in the input data.
</P>

<P class="docText">Before exiting, this script prints HTML to produce a result page that
echoes back what the user typed into the form. Two string-formatting
expressions (<TT>%</TT>) are used to insert the input text
into a reply string, and the reply string into the triple-quoted HTML
string block. The body of the script's output looks like this:
</P>

<PRE>&lt;TITLE&gt;test3.cgi&lt;/TITLE&gt;
&lt;H1&gt;Greetings&lt;/H1&gt;
&lt;HR&gt;
&lt;P&gt;Hello, King Arthur.&lt;/P&gt;
&lt;HR&gt;</PRE>

<P class="docText">In a browser, the output is rendered into a page like the one in
<A class="docLink" HREF="#python2-CHP-12-FIG-7">Figure 12-7</A>.
</P>

<CENTER>
<H5 class="docFigureTitle"><A NAME="python2-CHP-12-FIG-7"></A>Figure 12-7. test3.cgi result for parameters in a form</H5>
<IMG BORDER="0" WIDTH="270" HEIGHT="160" src="FILES/ppy2_1207.gif" ALT="figs/ppy2_1207.gif"></CENTER>



<A NAME="python2-CHP-12-SECT-3.4.4"></A>
<H5 class="docSection3Title">12.3.4.4 Passing parameters in URLs</H5>

<P class="docText"><A NAME="python2-IDXTERM-1160"></A>Notice
that the URL address of the script that generated this page shows up
at the top of the browser. We didn't type this URL
itself -- it came from the <TT>action</TT> tag of the
prior page's <TT>form</TT> HTML. However, there is
nothing stopping us from typing the script's URL explicitly in
our browser's address field to invoke the script, just as we
did for our earlier CGI script and HTML file examples.
</P>

<P class="docText">But there's a catch here: where does the input field's
value come from if there is no form page? That is, if we type the CGI
script's URL ourselves, how does the input field get filled in?
Earlier, when we talked about URL formats, I mentioned that the
<TT>get</TT> encoding scheme tacks input parameters onto
the end of URLs. When we type script addresses explicitly, we can
also append input values on the end of URLs, where they serve the
same purpose as <TT>&lt;input&gt;</TT> fields in forms.
Moreover, the Python <TT>cgi</TT> module makes URL and form
inputs look identical to scripts.
</P>

<P class="docText">For instance, we can skip filling out the input form page completely,
and directly invoke our <I>test3.cgi </I>script by
visiting a URL of the form:
</P>

<PRE>http://starship.python.net/~lutz/Basics/test3.cgi?user=Brian</PRE>

<P class="docText">In this URL, a value for the input named <TT>user</TT> is
specified explicitly, as if the user had filled out the input page.
When called this way, the only constraint is that the parameter name
<TT>user</TT> must match the name expected by the script
(and hardcoded in the form's HTML). We use just one parameter
here, but in general, URL parameters are typically introduced with a
<TT>?</TT> and followed by one or more
<TT>name=value</TT> assignments, separated by
<TT>&amp;</TT> characters if there is more than one. <A class="docLink" HREF="#python2-CHP-12-FIG-8">Figure 12-8</A> shows the response page we get after typing a
URL with explicit inputs.
</P>

<CENTER>
<H5 class="docFigureTitle"><A NAME="python2-CHP-12-FIG-8"></A>Figure 12-8. test3.cgi result for parameters in a URL</H5>
<IMG BORDER="0" WIDTH="270" HEIGHT="160" src="FILES/ppy2_1208.gif" ALT="figs/ppy2_1208.gif"></CENTER>

<P class="docText">In general, any CGI script can be invoked either by filling out and
submitting a form page or by passing inputs at the end of a URL. When
CGI scripts are invoked with explicit input parameters this way,
it's difficult to not see their similarity to
<span class="docEmphasis">functions</span>, albeit ones that live remotely on the
Net. Passing data to scripts in URLs is similar to keyword arguments
in Python functions, both operationally and syntactically. In fact,
in <A class="docLink" HREF="0596000855_python2-CHP-15.html#python2-CHP-15">Chapter 15</A>we will meet a system called Zope that
makes the relationship between URLs and Python function calls even
more literal (URLs become more direct function calls).
</P>

<P class="docText">Incidentally, if you clear out the name input field in the form input
page (i.e., make it empty) and press submit, the
<TT>user</TT> name field becomes empty. More accurately,
the browser may not send this field along with the form data at all,
even though it is listed in the form layout HTML. The CGI script
detects such a missing field with the dictionary
<TT>has_key</TT> method and produces the page captured in
<A class="docLink" HREF="#python2-CHP-12-FIG-9">Figure 12-9</A> in response.
</P>

<CENTER>
<H5 class="docFigureTitle"><A NAME="python2-CHP-12-FIG-9"></A>Figure 12-9. An empty name field produces an error page</H5>
<IMG BORDER="0" WIDTH="270" HEIGHT="160" src="FILES/ppy2_1209.gif" ALT="figs/ppy2_1209.gif"></CENTER>

<P class="docText">In general, CGI scripts must check to see if any inputs are missing,
partly because they might not be typed by a user in the form, but
also because there may be no form at all -- input fields might not
be tacked on to the end of an explicitly typed URL. For instance, if
we type the script's URL without any parameters at all (i.e.,
omit the text <TT>?</TT> and beyond), we get this same
error response page. Since we can invoke any CGI through a form or
URL, scripts must anticipate both scenarios.<A NAME="IXTR3-302"></A><A NAME="IXTR3-303"></A> <A NAME="IXTR3-304"></A> <A NAME="IXTR3-305"></A><A NAME="IXTR3-306"></A>
</P>



<A NAME="python2-CHP-12-SECT-3.5"></A>
<H4 class="docSection2Title">12.3.5 Using Tables to Lay Out Forms</H4>

<P class="docText"><A NAME="python2-IDXTERM-1166"></A>
<A NAME="python2-IDXTERM-1167"></A> <A NAME="python2-IDXTERM-1168"></A>Now let's move on to
something a bit more realistic. In most CGI applications, input pages
are composed of multiple fields. When there is more than one, input
labels and fields are typically laid out in a table, to give the form
a well-structured appearance. The HTML file in <A class="docLink" HREF="#python2-CHP-12-EX-10">Example 12-10</A> defines a form with two input fields.
</P>


<H5 class="docExampleTitle"><A NAME="python2-CHP-12-EX-10"></A>Example 12-10. PP2E\Internet\Cgi-Web\Basics\test4.html </H5>
<PRE>&lt;html&gt;&lt;body&gt;
&lt;title&gt;CGI 101&lt;/title&gt;
&lt;H1&gt;A second user interaction: tables&lt;/H1&gt;
&lt;hr&gt;
&lt;form method=POST action="test4.cgi"&gt;
  &lt;table&gt;
    &lt;TR&gt;
      &lt;TH align=right&gt;Enter your name:
      &lt;TD&gt;&lt;input type=text name=user&gt;
    &lt;TR&gt;
      &lt;TH align=right&gt;Enter your age:
      &lt;TD&gt;&lt;input type=text name=age&gt;
    &lt;TR&gt;
      &lt;TD colspan=2 align=center&gt;
      &lt;input type=submit value="Send"&gt;
  &lt;/table&gt;
&lt;/form&gt;
&lt;/body&gt;&lt;/html&gt;</PRE>


<P class="docText"><A NAME="IXT-12-337538"></A>
<A NAME="IXT-12-337539"></A>
<A NAME="IXT-12-337540"></A>The
<TT>&lt;TH&gt;</TT> tag defines a column like
<TT>&lt;TD&gt;</TT>, but also tags it as a header column,
which generally means it is rendered in a bold font. By placing the
input fields and labels in a table like this, we get an input page
like that shown in <A class="docLink" HREF="#python2-CHP-12-FIG-10">Figure 12-10</A>. Labels and inputs
are automatically lined up vertically in columns much as they were by
the Tkinter GUI geometry managers we met earlier in this book.
</P>

<CENTER>
<H5 class="docFigureTitle"><A NAME="python2-CHP-12-FIG-10"></A>Figure 12-10. A form laid out with table tags</H5>
<IMG BORDER="0" WIDTH="280" HEIGHT="181" src="FILES/ppy2_1210.gif" ALT="figs/ppy2_1210.gif"></CENTER>

<P class="docText">When this form's Submit button (labeled "Send" by
the page's HTML) is pressed, it causes the script in <A class="docLink" HREF="#python2-CHP-12-EX-11">Example 12-11</A> to be executed on the server machine, with the
inputs typed by the user.
</P>


<H5 class="docExampleTitle"><A NAME="python2-CHP-12-EX-11"></A>Example 12-11. PP2E\Internet\Cgi-Web\Basics\test4.cgi </H5>
<PRE>#!/usr/bin/python
#######################################################
# runs on the server, reads form input, prints html;
# url http://server-name/root-dir/Basics/test4.cgi
#######################################################

import cgi, sys
<B>sys.stderr = sys.stdout</B>              # errors to browser
form = cgi.FieldStorage(  )            # parse form data
print "Content-type: text/html\n"    # plus blank line

<B># class dummy:</B>
<B>#     def __init__(self, s): self.value = s</B>
<B># form = {'user': dummy('bob'), 'age':dummy('10')}</B>

html = """
&lt;TITLE&gt;test4.cgi&lt;/TITLE&gt;
&lt;H1&gt;Greetings&lt;/H1&gt;
&lt;HR&gt;
&lt;H4&gt;%s&lt;/H4&gt;
&lt;H4&gt;%s&lt;/H4&gt;
&lt;H4&gt;%s&lt;/H4&gt;
&lt;HR&gt;"""

if not form.has_key('user'):
    line1 = "Who are you?"
else:
    line1 = "Hello, %s." % form['user'].value

line2 = "You're talking to a %s server." % sys.platform

line3 = ""
if form.has_key('age'):
    try:
<B>        line3 = "Your age squared is %d!" % (int(form['age'].value) ** 2)</B>
    except:
        line3 = "Sorry, I can't compute %s ** 2." % form['age'].value

print html % (line1, line2, line3)</PRE>


<P class="docText">The table layout comes from the HTML file, not this Python CGI
script. In fact, this script doesn't do much new -- it uses
string formatting to plug input values into the response page's
HTML triple-quoted template string as before, this time with one line
per input field. There are, however, a few new tricks here worth
noting, especially regarding CGI script debugging and security.
We'll talk about them in the next two sections.
</P>

<A NAME="python2-CHP-12-SECT-3.5.1"></A>
<H5 class="docSection3Title">12.3.5.1 Converting strings in CGI scripts</H5>

<P class="docText"><A NAME="IXT-12-337541"></A>
<A NAME="IXT-12-337542"></A>
<A NAME="IXT-12-337543"></A>Just for
fun, the script echoes back the name of the server platform by
fetching <TT>sys.platform</TT> along with the square of the
<TT>age</TT> input field. Notice that the
<TT>age</TT> input's value must be converted to an
integer with the built-in <TT>int</TT> function; in the CGI
world, all inputs arrive as strings. We could also convert to an
integer with the built-in <TT>string.atoi</TT> or
<TT>eval</TT> function. Conversion (and other) errors are
trapped gracefully in a <TT>try</TT> statement to yield an
error line, rather than letting our script die.
</P>

<P><table border="0" bgcolor="black" cellspacing="0" cellpadding="1" width="90%" align="center"><tr><td>
<table bgcolor="white" width="100%" border="0" cellspacing="0" cellpadding="6"><tr>
<td width="60" valign="top"><img src="FILES/warning_yellow.gif" width="51" height="36"></td>
<td valign="top">
<P class="docText"><A NAME="IXT-12-337544"></A>You should never use
<TT>eval</TT> to convert strings that were sent over the
Internet like the <TT>age</TT> field in this example,
unless you can be absolutely sure that the string is not even
potentially malicious code. For instance, if this example were
available on the general Internet, it's not impossible that
someone could type a value into the <TT>age</TT> field (or
append an <TT>age</TT> parameter to the URL) with a value
like: <TT>os.system('rm *')</TT>. When passed to
<TT>eval</TT>, such a string might delete all the files in
your server script directory!</P>
<P class="docText">We talk about ways to minimize this
risk with Python's restricted execution mode (module
<TT>rexec</TT>) in <A class="docLink" HREF="0596000855_python2-CHP-15.html#python2-CHP-15">Chapter 15</A>. But by
default, strings read off the Net can be very bad things to say in
CGI scripting. You should never pass them to dynamic coding tools
like <TT>eval</TT> and <TT>exec</TT>, or to tools
that run arbitrary shell commands such as <TT>os.popen</TT>
and <TT>os.system</TT>, unless you can be sure that they
are safe, or unless you enable Python's restricted execution
mode in your scripts.
</P>
</td>
</tr></table></td></tr></table></P>



<A NAME="python2-CHP-12-SECT-3.5.2"></A>
<H5 class="docSection3Title">12.3.5.2 Debugging CGI scripts</H5>

<P class="docText"><A NAME="python2-IDXTERM-1176"></A>
<A NAME="python2-IDXTERM-1177"></A>Errors happen, even in the brave new
world of the Internet. Generally speaking, debugging CGI scripts can
be much more difficult than debugging programs that run on your local
machine. Not only do errors occur on a remote machine, but scripts
generally won't run without the context implied by the CGI
model. The script in <A class="docLink" HREF="#python2-CHP-12-EX-11">Example 12-11</A> demonstrates the
following two common debugging tricks.
</P>

<A NAME="IXT-12-337545"></A><A NAME="IXT-12-337546"></A><A NAME="IXT-12-337547"></A><DL class="docList">
<DT><I><span class="docPubcolor">Error message trapping</span></I></DT>
<DD>
<P class="docList"><A NAME="IXT-12-337545"></A> <A NAME="IXT-12-337546"></A>
<A NAME="IXT-12-337547"></A>This script assigns
<TT>sys.stderr</TT> to <TT>sys.stdout</TT> so
that Python error messages wind up being displayed in the response
page in the browser. Normally, Python error messages are written to
<TT>stderr</TT>. To route them to the browser, we must make
<TT>stderr</TT> reference the same file object as
<TT>stdout</TT> (which is connected to the browser in CGI
scripts). If we don't do this assignment, Python errors,
including program errors in our script, never show up in the browser.
</P>
</DD><DT><I><span class="docPubcolor">Test case mock-up</span></I></DT>
<DD>
<P class="docList">The <TT>dummy</TT> class definition, commented out in this
final version, was used to debug the script before it was installed
on the Net. Besides not seeing <TT>stderr</TT> messages by
default, CGI scripts also assume an enclosing context that does not
exist if they are tested outside the CGI environment. For instance,
if run from the system command line, this script has no form input
data. Uncomment this code to test from the system command line. The
<TT>dummy</TT> class masquerades as a parsed form field
object, and <TT>form</TT> is assigned a dictionary
containing two form field objects. The net effect is that
<TT>form</TT> will be plug-and-play compatible with the
result of a <TT>cgi.FieldStorage</TT> call. As usual in
Python, object interfaces (not datatypes) are all we must adhere to.
</P>
</DD>
</DL>

<P class="docText">Here are a few general tips for debugging your server-side CGI
scripts:
</P>

<A NAME="IXT-12-337548"></A><A NAME="IXT-12-337549"></A><A NAME="IXT-12-337550"></A><DL class="docList">
<DT><span class="docPubcolor"><span class="docEmphasis">Run the script from the command line.</span></span></DT>
<DD>
<P class="docList">It probably won't generate HTML as is, but running it
standalone will detect any syntax errors in your code. Recall that a
Python command line can run source code files regardless of their
extension: e.g., <TT>python somescript.cgi</TT> works fine.
</P>
</DD><DT><span class="docPubcolor"><span class="docEmphasis">Assign sys.stderr to sys.stdout as early as possible in your script</span>. </span></DT>
<DD>
<P class="docList">This will make the text of Python error messages and stack dumps
appear in your client browser when accessing the script. In fact,
short of wading through server logs, this may be the only way to see
the text of error messages after your script aborts.
</P>
</DD><DT><span class="docPubcolor"><span class="docEmphasis">Mock up inputs to simulate the enclosing CGI context</span>. </span></DT>
<DD>
<P class="docList">For instance, define classes that mimic the CGI inputs interface (as
done with the <TT>dummy</TT> class in this script), so that
you can view the script's output for various test cases by
running it from the system command line.<sup class="docFootnote"><A class="docLink" HREF="#">[6]</A></sup>
Setting environment variables to mimic form or URL inputs sometimes
helps, too (we'll see how later in this chapter).
</P> <blockquote><p class="docFootnote"><sup><A NAME="">[6]</A></sup> This
technique isn't unique to CGI scripts, by the way. In <A class="docLink" HREF="0596000855_python2-CHP-15.html#python2-CHP-15">Chapter 15</A>, we'll meet systems that embed Python
code inside HTML. There is no good way to test such code outside the
context of the enclosing system, without extracting the embedded
Python code (perhaps by using the <TT>htmllib</TT> HTML
parser that comes with Python) and running it with a passed-in
mock-up of the API that it will eventually use.</p></blockquote> 
</DD><DT><span class="docPubcolor"><span class="docEmphasis">Call utilities to display CGI context in the browser</span>. </span></DT>
<DD>
<P class="docList">The CGI module includes utility functions that send a formatted dump
of CGI environment variables and input values to the browser (e.g.,
<TT>cgi.test</TT>, <TT>cgi.print_form</TT>).
Sometimes, this is enough to resolve connection problems. We'll
use some of these in the mailer case study in the next
chapter.<A NAME="IXT-12-337548"></A> <A NAME="IXT-12-337549"></A>
</P>
</DD><DT><span class="docPubcolor"><span class="docEmphasis">Show exceptions you catch</span>. </span></DT>
<DD>
<P class="docList">If you catch an exception that Python raises, the Python error
message won't be printed to <TT>stderr</TT> (that is
simply the default behavior). In such cases, it's up to your
script to display the exception's name and value in the
response page; exception details are available in the built-in
<TT>sys</TT> module. We'll use this in a later
example, too.<A NAME="IXT-12-337550"></A>
</P>
</DD><DT><span class="docPubcolor"><span class="docEmphasis">Run it live</span>. </span></DT>
<DD>
<P class="docList">Of course, once your script is at least half working, your best bet
is likely to start running it live on the server, with real inputs
coming from a browser.
</P>
</DD>
</DL>

<P class="docText">When this script is run by submitting the input form page, its output
produces the new reply page shown in <A class="docLink" HREF="#python2-CHP-12-FIG-11">Figure 12-11</A>.
</P>

<CENTER>
<H5 class="docFigureTitle"><A NAME="python2-CHP-12-FIG-11"></A>Figure 12-11. Reply page generated by test4.cgi</H5>
<IMG BORDER="0" WIDTH="299" HEIGHT="210" src="FILES/ppy2_1211.gif" ALT="figs/ppy2_1211.gif"></CENTER>

<P class="docText">As usual, we can pass parameters to this CGI script at the end of a
URL, too. <A class="docLink" HREF="#python2-CHP-12-FIG-12">Figure 12-12</A> shows the page we get when
passing a <TT>user</TT> and <TT>age</TT>
explicitly in the URL. Notice that we have two parameters after the
<TT>?</TT> this time; we separate them with
<TT>&amp;</TT>. Also note that we've specified a
blank space in the <TT>user</TT> value with
<TT>+</TT>. This is a common URL encoding convention. On
the server side, the <TT>+</TT> is automatically replaced
with a space again. It's also part of the standard escape rule
for URL strings, which we'll revisit later.<A NAME="IXTR3-307"></A> <A NAME="IXTR3-308"></A> <A NAME="IXTR3-309"></A><A NAME="IXTR3-310"></A> <A NAME="IXTR3-311"></A>
</P>

<CENTER>
<H5 class="docFigureTitle"><A NAME="python2-CHP-12-FIG-12"></A>Figure 12-12. Reply page generated by test4.cgi for parameters in URL</H5>
<IMG BORDER="0" WIDTH="307" HEIGHT="210" src="FILES/ppy2_1212.gif" ALT="figs/ppy2_1212.gif"></CENTER>



<A NAME="python2-CHP-12-SECT-3.6"></A>
<H4 class="docSection2Title">12.3.6 Adding Common Input Devices</H4>

<P class="docText"><A NAME="python2-IDXTERM-1189"></A> <A NAME="python2-IDXTERM-1190"></A> <A NAME="python2-IDXTERM-1191"></A>So far, we've been
typing inputs into text fields. HTML forms support a handful of input
controls (what we'd call widgets in the traditional GUI world)
for collecting user inputs. Let's look at a CGI program that
shows all the common input controls at once. As usual, we define both
an HTML file to lay out the form page and a Python CGI script to
process its inputs and generate a response. The HTML file is
presented in <A class="docLink" HREF="#python2-CHP-12-EX-12">Example 12-12</A>.
</P>


<H5 class="docExampleTitle"><A NAME="python2-CHP-12-EX-12"></A>Example 12-12. PP2E\Internet\Cgi-Web\Basics\test5a.html </H5>
<PRE>&lt;HTML&gt;&lt;BODY&gt;
&lt;TITLE&gt;CGI 101&lt;/TITLE&gt;
&lt;H1&gt;Common input devices&lt;/H1&gt;
&lt;HR&gt;
&lt;FORM method=POST action="test5.cgi"&gt;
  &lt;H3&gt;Please complete the following form and click Send&lt;/H3&gt;
  &lt;P&gt;&lt;TABLE&gt;
    &lt;TR&gt;
      &lt;TH align=right&gt;Name:
      &lt;TD&gt;&lt;input type=text name=name&gt;
    &lt;TR&gt;
      &lt;TH align=right&gt;Shoe size:
      &lt;TD&gt;&lt;table&gt;
      &lt;td&gt;&lt;input type=radio name=shoesize value=small&gt;Small
      &lt;td&gt;&lt;input type=radio name=shoesize value=medium&gt;Medium
      &lt;td&gt;&lt;input type=radio name=shoesize value=large&gt;Large
      &lt;/table&gt;
    &lt;TR&gt;
      &lt;TH align=right&gt;Occupation:
      &lt;TD&gt;&lt;select name=job&gt;
        &lt;option&gt;Developer
        &lt;option&gt;Manager
        &lt;option&gt;Student
        &lt;option&gt;Evangelist
        &lt;option&gt;Other
      &lt;/select&gt;
    &lt;TR&gt;
      &lt;TH align=right&gt;Political affiliations:
      &lt;TD&gt;&lt;table&gt;
      &lt;td&gt;&lt;input type=checkbox name=language value=Python&gt;Pythonista
      &lt;td&gt;&lt;input type=checkbox name=language value=Perl&gt;Perlmonger
      &lt;td&gt;&lt;input type=checkbox name=language value=Tcl&gt;Tcler 
      &lt;/table&gt;
    &lt;TR&gt;
      &lt;TH align=right&gt;Comments:
      &lt;TD&gt;&lt;textarea name=comment cols=30 rows=2&gt;Enter text here&lt;/textarea&gt;
    &lt;TR&gt;
      &lt;TD colspan=2 align=center&gt;
      &lt;input type=submit value="Send"&gt;
  &lt;/TABLE&gt;
&lt;/FORM&gt;
&lt;HR&gt;
&lt;/BODY&gt;&lt;/HTML&gt;</PRE>


<P class="docText">When rendered by a browser, the page in <A class="docLink" HREF="#python2-CHP-12-FIG-13">Figure 12-13</A>
appears.
</P>

<CENTER>
<H5 class="docFigureTitle"><A NAME="python2-CHP-12-FIG-13"></A>Figure 12-13. Form page generated by test5a.html</H5>
<IMG BORDER="0" WIDTH="346" HEIGHT="320" src="FILES/ppy2_1213.gif" ALT="figs/ppy2_1213.gif"></CENTER>

<P class="docText"><A NAME="IXT-12-337551"></A> <A NAME="IXT-12-337552"></A>
<A NAME="IXT-12-337553"></A>
<A NAME="IXT-12-337554"></A>
<A NAME="IXT-12-337555"></A>This page contains a simple text
field as before, but it also has radiobuttons, a pull-down selection
list, a set of multiple-choice checkbuttons, and a multiple-line text
input area. All have a <TT>name</TT> option in the HTML
file, which identifies their selected value in the data sent from
client to server. When we fill out this form and click the Send
submit button, the script in <A class="docLink" HREF="#python2-CHP-12-EX-13">Example 12-13</A> runs on the
server to process all the input data typed or selected in the
form.<A NAME="IXT-12-337556"></A> <A NAME="IXT-12-337557"></A>
</P>


<H5 class="docExampleTitle"><A NAME="python2-CHP-12-EX-13"></A>Example 12-13. PP2E\Internet\Cgi-Web\Basics\test5.cgi </H5>
<PRE>#!/usr/bin/python
#######################################################
# runs on the server, reads form input, prints html;
# url=http://server-name/root-dir/Basics/test5.cgi
#######################################################

import cgi, sys, string
form = cgi.FieldStorage(  )            # parse form data
print "Content-type: text/html"      # plus blank line

html = """
&lt;TITLE&gt;test5.cgi&lt;/TITLE&gt;
&lt;H1&gt;Greetings&lt;/H1&gt;
&lt;HR&gt;
&lt;H4&gt;Your name is %(name)s&lt;/H4&gt;
&lt;H4&gt;You wear rather %(shoesize)s shoes&lt;/H4&gt;
&lt;H4&gt;Your current job: %(job)s&lt;/H4&gt;
&lt;H4&gt;You program in %(language)s&lt;/H4&gt;
&lt;H4&gt;You also said:&lt;/H4&gt;
&lt;P&gt;%(comment)s&lt;/P&gt;
&lt;HR&gt;"""

data = {}
for field in ['name', 'shoesize', 'job', 'language', 'comment']:
    if not form.has_key(field):
        data[field] = '(unknown)'
    else:
        if type(form[field]) != type([]):
            data[field] = form[field].value
        else:
            values = map(lambda x: x.value, form[field])
            data[field] = string.join(values, ' and ')
print html % data</PRE>


<P class="docText">This Python script doesn't do much; it mostly just copies form
field information into a dictionary called <TT>data</TT>,
so that it can be easily plugged into the triple-quoted response
string. A few of its tricks merit explanation:
</P>

<DL class="docList">
<DT><I><span class="docPubcolor">Field validation</span></I></DT>
<DD>
<P class="docList">As usual, we need to check all expected fields to see if they really
are present in the input data, using the dictionary
<TT>has_key</TT> method. Any or all of the input fields may
be missing if they weren't entered on the form or appended to
an explicit URL.
</P>
</DD><DT><I><span class="docPubcolor">String formatting</span></I></DT>
<DD>
<P class="docList">We're using dictionary key references in the format string this
time -- recall that <TT>%(name)s</TT> means pull out the
value for key <TT>name</TT> in the data dictionary and
perform a to-string conversion on its value.
</P>
</DD><DT><I><span class="docPubcolor">Multiple-choice fields</span></I></DT>
<DD>
<P class="docList">We're also testing the type of all the expected fields'
values to see if they arrive as a list instead of the usual string.
Values of multiple-choice input controls, like the
<TT>language</TT> choice field in this input page, are
returned from <TT>cgi.FieldStorage</TT> as a list of
objects with <TT>value</TT> attributes, rather than a
simple single object with a <TT>value</TT>. This script
copies simple field values to the dictionary verbatim, but uses
<TT>map</TT> to collect the value fields of multiple-choice
selections, and <TT>string.join</TT> to construct a single
string with an <TT>and</TT> inserted between each selection
value (e.g., <TT>Python and Tcl</TT>).<sup class="docFootnote"><A class="docLink" HREF="#">[7]</A></sup>
</P> <blockquote><p class="docFootnote"><sup><A NAME="">[7]</A></sup> Two
forward references are worth noting here. Besides simple strings and
lists, later we'll see a third type of form input object,
returned for fields that specify file uploads. The script in this
example should really also escape the echoed text inserted into the
HTML reply to be robust, lest it contain HTML operators. We will
discuss escapes in detail later. </p></blockquote> 
</DD>
</DL>

<P class="docText">When the form page is filled out and submitted, the script creates
the response shown in <A class="docLink" HREF="#python2-CHP-12-FIG-14">Figure 12-14</A> -- essentially
just a formatted echo of what was sent.
</P>

<CENTER>
<H5 class="docFigureTitle"><A NAME="python2-CHP-12-FIG-14"></A>Figure 12-14. Response page created by test5.cgi (1)</H5>
<IMG BORDER="0" WIDTH="313" HEIGHT="281" src="FILES/ppy2_1214.gif" ALT="figs/ppy2_1214.gif"></CENTER>

<A NAME="python2-CHP-12-SECT-3.6.1"></A>
<H5 class="docSection3Title">12.3.6.1 Changing input layouts</H5>

<P class="docText"><A NAME="python2-IDXTERM-1199"></A>
<A NAME="python2-IDXTERM-1200"></A>Suppose that
you've written a system like this, and your users, clients, and
significant other start complaining that the input form is difficult
to read. Don't worry. Because the CGI model naturally separates
the <span class="docEmphasis">user interface</span> (the HTML page definition)
from the <span class="docEmphasis">processing logic</span> (the CGI script),
it's completely painless to change the form's layout.
Simply modify the HTML file; there's no need to change the CGI
code at all. For instance, <A class="docLink" HREF="#python2-CHP-12-EX-14">Example 12-14</A> contains a
new definition of the input that uses tables a bit differently to
provide a nicer layout with borders.
</P>


<H5 class="docExampleTitle"><A NAME="python2-CHP-12-EX-14"></A>Example 12-14. PP2E\Internet\Cgi-Web\Basics\test5b.html </H5>
<PRE>&lt;HTML&gt;&lt;BODY&gt;
&lt;TITLE&gt;CGI 101&lt;/TITLE&gt;
&lt;H1&gt;Common input devices: alternative layout&lt;/H1&gt;
&lt;P&gt;Use the same test5.cgi server side script, but change the 
layout of the form itself.  Notice the separation of user interface
and processing logic here; the CGI script is independent of the
HTML used to interact with the user/client.&lt;/P&gt;&lt;HR&gt;

&lt;FORM method=POST action="test5.cgi"&gt;
  &lt;H3&gt;Please complete the following form and click Submit&lt;/H3&gt;
  &lt;P&gt;&lt;TABLE border cellpadding=3&gt;
    &lt;TR&gt;
      &lt;TH align=right&gt;Name:
      &lt;TD&gt;&lt;input type=text name=name&gt;
    &lt;TR&gt;
      &lt;TH align=right&gt;Shoe size:
      &lt;TD&gt;&lt;input type=radio name=shoesize value=small&gt;Small
          &lt;input type=radio name=shoesize value=medium&gt;Medium
          &lt;input type=radio name=shoesize value=large&gt;Large
    &lt;TR&gt;
      &lt;TH align=right&gt;Occupation:
      &lt;TD&gt;&lt;select name=job&gt;
        &lt;option&gt;Developer
        &lt;option&gt;Manager
        &lt;option&gt;Student
        &lt;option&gt;Evangelist
        &lt;option&gt;Other
      &lt;/select&gt;
    &lt;TR&gt;
      &lt;TH align=right&gt;Political affiliations:
      &lt;TD&gt;&lt;P&gt;&lt;input type=checkbox name=language value=Python&gt;Pythonista
          &lt;P&gt;&lt;input type=checkbox name=language value=Perl&gt;Perlmonger
          &lt;P&gt;&lt;input type=checkbox name=language value=Tcl&gt;Tcler 
    &lt;TR&gt;
      &lt;TH align=right&gt;Comments:
      &lt;TD&gt;&lt;textarea name=comment cols=30 rows=2&gt;Enter spam here&lt;/textarea&gt;
    &lt;TR&gt;
      &lt;TD colspan=2 align=center&gt;
      &lt;input type=submit value="Submit"&gt;
      &lt;input type=reset  value="Reset"&gt;
  &lt;/TABLE&gt;
&lt;/FORM&gt;
&lt;/BODY&gt;&lt;/HTML&gt;</PRE>


<P class="docText">When we visit this alternative page with a browser, we get the
interface shown in <A class="docLink" HREF="#python2-CHP-12-FIG-15">Figure 12-15</A>.
</P>

<CENTER>
<H5 class="docFigureTitle"><A NAME="python2-CHP-12-FIG-15"></A>Figure 12-15. Form page created by test5b.html</H5>
<IMG BORDER="0" WIDTH="381" HEIGHT="423" src="FILES/ppy2_1215.gif" ALT="figs/ppy2_1215.gif"></CENTER>

<P class="docText">Now, before you go blind trying to detect the differences in this and
the prior HTML file, I should note that the HTML differences that
produce this page are much less important than the fact that the
<TT>action</TT> fields in these two pages' forms
reference identical URLs. Pressing this version's Submit button
triggers the exact same and totally unchanged Python CGI script
again, <I>test5.cgi</I> (<A class="docLink" HREF="#python2-CHP-12-EX-13">Example 12-13</A>).
</P>

<P class="docText">That is, scripts are completely independent of the layout of the
user-interface used to send them information. Changes in the response
page require changing the script, of course; but we can change the
input page's HTML as much as we like, without impacting the
server-side Python code. <A class="docLink" HREF="#python2-CHP-12-FIG-16">Figure 12-16</A> shows the
response page produced by the script this time around.<A NAME="IXTR3-312"></A> <A NAME="IXTR3-313"></A> <A NAME="IXTR3-314"></A><A NAME="IXTR3-315"></A> <A NAME="IXTR3-316"></A>
</P>

<CENTER>
<H5 class="docFigureTitle"><A NAME="python2-CHP-12-FIG-16"></A>Figure 12-16. Response page created by test5.cgi (2)</H5>
<IMG BORDER="0" WIDTH="346" HEIGHT="281" src="FILES/ppy2_1216.gif" ALT="figs/ppy2_1216.gif"></CENTER>



<A NAME="python2-CHP-12-SECT-3.7"></A>
<H4 class="docSection2Title">12.3.7 Passing Parameters in Hardcoded URLs</H4>

<P class="docText"><A NAME="python2-IDXTERM-1206"></A> <A NAME="python2-IDXTERM-1207"></A>Earlier,
we passed parameters to CGI scripts by listing them at the end of a
URL typed into the browser's address field (after a
<TT>?</TT>). But there's nothing sacred about the
browser's address field. In particular, there's nothing
stopping us from using the same URL syntax in hyperlinks that we
hardcode in web page definitions. For example, the web page from
<A class="docLink" HREF="#python2-CHP-12-EX-15">Example 12-15</A> defines three hyperlinks (the text
between <TT>&lt;A&gt;</TT> and
<TT>&lt;/A&gt;</TT> tags), which all trigger our original
<I>test5.cgi</I> script again, but with three different
precoded sets of parameters.
</P>


<H5 class="docExampleTitle"><A NAME="python2-CHP-12-EX-15"></A>Example 12-15. PP2E\Internet\Cgi-Web\Basics\test5c.html </H5>
<PRE>&lt;HTML&gt;&lt;BODY&gt;
&lt;TITLE&gt;CGI 101&lt;/TITLE&gt;
&lt;H1&gt;Common input devices: URL parameters&lt;/H1&gt;

&lt;P&gt;This demo invokes the test5.cgi server-side script again,
but hardcodes input data to the end of the script's URL, 
within a simple hyperlink (instead of packaging up a form's
inputs).  Click your browser's "show page source" button 
to view the links associated with each list item below.

&lt;P&gt;This is really more about CGI than Python, but notice that 
Python's cgi module handles both this form of input (which is
also produced by GET form actions), as well as POST-ed forms; 
they look the same to the Python CGI script.  In other words, 
cgi module users are independent of the method used to submit 
data.

&lt;P&gt;Also notice that URLs with appended input values like this
can be generated as part of the page output by another CGI script, 
to direct a next user click to the right place and context; together 
with type 'hidden' input fields, they provide one way to 
save state between clicks.
&lt;/P&gt;&lt;HR&gt;

&lt;UL&gt;
&lt;LI&gt;&lt;A href="test5.cgi?name=Bob&amp;shoesize=small"&gt;Send Bob, small&lt;/A&gt;
&lt;LI&gt;&lt;A href="test5.cgi?name=Tom&amp;language=Python"&gt;Send Tom, Python&lt;/A&gt;
&lt;LI&gt;&lt;A href=
"http://starship.python.net/~lutz/Basics/test5.cgi?job=Evangelist&amp;comment=spam"&gt;
Send Evangelist, spam&lt;/A&gt;
&lt;/UL&gt;

&lt;HR&gt;&lt;/BODY&gt;&lt;/HTML&gt;</PRE>


<P class="docText">This static HTML file defines three hyperlinks -- the first two
are minimal and the third is fully specified, but all work similarly
(again, the target script doesn't care). When we visit this
file's URL, we see the page shown in <A class="docLink" HREF="#python2-CHP-12-FIG-17">Figure 12-17</A>. It's mostly just a page for launching
canned calls to the CGI script.
</P>

<CENTER>
<H5 class="docFigureTitle"><A NAME="python2-CHP-12-FIG-17"></A>Figure 12-17. Hyperlinks page created by test5c.html</H5>
<IMG BORDER="0" WIDTH="361" HEIGHT="320" src="FILES/ppy2_1217.gif" ALT="figs/ppy2_1217.gif"></CENTER>

<P class="docText">Clicking on this page's second link creates the response page
in <A class="docLink" HREF="#python2-CHP-12-FIG-18">Figure 12-18</A>. This link invokes the CGI script,
with the <TT>name</TT> parameter set to "Tom"
and the <TT>language</TT> parameter set to
"Python," simply because those parameters and values are
hardcoded in the URL listed in the HTML for the second hyperlink.
It's exactly as if we had manually typed the line shown at the
top of the browser in <A class="docLink" HREF="#python2-CHP-12-FIG-18">Figure 12-18</A>.
</P>

<CENTER>
<H5 class="docFigureTitle"><A NAME="python2-CHP-12-FIG-18"></A>Figure 12-18. Response page created by test5.cgi (3)</H5>
<IMG BORDER="0" WIDTH="328" HEIGHT="281" src="FILES/ppy2_1218.gif" ALT="figs/ppy2_1218.gif"></CENTER>

<P class="docText">Notice that lots of fields are missing here; the
<I>test5.cgi</I> script is smart enough to detect and
handle missing fields and generate an <TT>unknown</TT>
message in the reply page. It's also worth pointing out that
we're reusing the Python CGI script again here. The script
itself is completely independent of both the user-interface format of
the submission page, as well as the technique used to invoke it (from
a submitted form or a hardcoded URL). By separating user interface
from processing logic, CGI scripts become reusable software
components, at least within the context of the CGI environment.
</P>

<A NAME="python2-CHP-12-SECT-3.7.1"></A>
<H5 class="docSection3Title">12.3.7.1 Saving CGI script state information</H5>

<P class="docText"><A NAME="IXT-12-337558"></A>But the real reason for
showing this technique is that we're going to use it
extensively in the larger case studies in the next two chapters to
implement lists of dynamically generated selections that
"know" what to do when clicked. Precoded parameters in
URLs are a way to retain state information between pages -- they
can be used to direct the action of the next script to be run. As
such, hyperlinks with such parameters are sometimes known as
"smart
links."<A NAME="IXT-12-337559"></A> <A NAME="IXT-12-337560"></A>
</P>

<P class="docText"><A NAME="IXT-12-337561"></A>Normally, CGI scripts run
autonomously, with no knowledge of any other scripts that may have
run before. That hasn't mattered in our examples so far, but
larger systems are usually composed of multiple user interaction
steps and many scripts, and we need a way to keep track of
information gathered along the way. Generating hardcoded URLs with
parameters is one way for a CGI script to pass data to the next
script in the application. When clicked, such URL parameters send
pre-programmed selection information back to another server-side
handler script.
</P>

<P class="docText">For example, a site that lets you read your email may present you
with a list of viewable email messages, implemented in HTML as a list
of hyperlinks generated by another script. Each hyperlink might
include the name of the message viewer script, along with parameters
identifying the selected message number, email server name, and so
on -- as much data as is needed to fetch the message associated
with a particular link. A retail site may instead serve up a
generated list of product links, each of which triggers a hardcoded
hyperlink containing the product number, its price, and so on.
</P>

<P class="docText">In general, there are a variety of ways to pass or retain state
information between CGI script executions:
</P>

<UL>
<LI><P class="docList"><span class="docEmphasis">Hardcoded URL parameters</span> in dynamically
generated hyperlinks and embedded in web pages (as discussed here)
</P></LI>
<LI><P class="docList"><span class="docEmphasis">Hidden form input
fields</span><A NAME="IXT-12-337562"></A> <A NAME="IXT-12-337563"></A> that are attached to form data and embedded
in web pages, but not displayed on web pages
</P></LI>
<LI><P class="docList"><span class="docEmphasis">HTTP
"cookies"</span><A NAME="IXT-12-337564"></A>
<A NAME="IXT-12-337565"></A> that
are stored on the client machine and transferred between client and
server in HTTP message
headers<A NAME="IXT-12-337566"></A>
</P></LI>
<LI><P class="docList"><span class="docEmphasis">General server-side data stores</span> that include
databases, persistent object shelves, flat files, and so on
</P></LI>
</UL>
<P class="docText">We'll meet most of these mediums in later examples in this
chapter and in the two chapters that follow.<A NAME="IXTR3-317"></A>
</P>




<a href="0596000855_"><img src="FILES/pixel.gif" width="1" height="1" border="0"></a><ul></ul>
</td>
</tr>
</table>
<td></td>
<table width="100%" border="0" cellspacing="0" cellpadding="0" bgcolor="#CCCCCC">
<td><font color="black" size=1>I l<font color="#FF0000">@</font>ve RuBoard</td>
<td valign="top" class="v2" align="right">
          <a href="0596000855_python2-CHP-12-SECT-2.html"><img src="FILES/previous.gif" width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a>
          <a href="0596000855_python2-CHP-12-SECT-4.html"><img src="FILES/next.gif" width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a>
</td></table>
</body></html>
