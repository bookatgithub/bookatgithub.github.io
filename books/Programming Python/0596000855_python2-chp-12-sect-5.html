<html><head>
<META http-equiv="Content-Type" content="text/html">
<!--SafClassName="docSection1Title"--><!--SafTocEntry="12.5 Coding for Maintainability"-->
<link rel="STYLESHEET" type="text/css" href="FILES/style.css">
<link rel="STYLESHEET" type="text/css" href="FILES/docsafari.css">
</head>
<body>
<table width="100%" border="0" cellspacing="0" cellpadding="0" bgcolor="#CCCCCC">
<td><font color="black" size=1>I l<font color="#FF0000">@</font>ve RuBoard</td>
<td valign="top" class="v2" align="right">
	<a href="0596000855_python2-CHP-12-SECT-4.html"><img src="FILES/previous.gif" width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a>
	<a href="0596000855_python2-CHP-12-SECT-6.html"><img src="FILES/next.gif" width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a>
</td></table>
<br>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<tr>
<td valign="top"><A NAME="python2-CHP-12-SECT-5"></A>
<H3 class="docSection1Title">12.5 Coding for Maintainability</H3>

<P class="docText"><A NAME="python2-IDXTERM-1233"></A>
<A NAME="python2-IDXTERM-1234"></A>Let's step back from
coding details for just a moment to gain some design perspective. As
we've seen, Python code, by and large, automatically lends
itself to systems that are easy to read and maintain; it has a simple
syntax that cuts much of the clutter of other tools. On the other
hand, coding styles and program design can often impact
maintainability as much as syntax. For example, the "Hello
World" selector pages earlier in this chapter work as
advertised, and were very easy and fast to throw together. But as
currently coded, the languages selector suffers from substantial
maintainability flaws.
</P>

<P class="docText">Imagine, for instance, that you actually take me up on that challenge
posed at the end of the last section, and you attempt to add another
entry for COBOL. If you add COBOL to the CGI script's table,
you're only half done: the list of supported languages lives
redundantly in two places -- in the HTML for the main page as well
as the script's syntax dictionary. Changing one does not change
the other. More generally, there are a handful of ways that this
program might fail the scrutiny of a rigorous code review:
</P>

<DL class="docList">
<DT><span class="docPubcolor"><span class="docEmphasis">Selection list</span></span></DT>
<DD>
<P class="docList">As just mentioned, the list of languages supported by this program
lives in two places: the HTML file and the CGI script's table.
</P>
</DD><DT><span class="docPubcolor"><span class="docEmphasis">Field name</span></span></DT>
<DD>
<P class="docList">The field name of the input parameter, "language," is
hardcoded into both files, as well. You might remember to change it
in the other if you change it in one, but you might not.
</P>
</DD><DT><span class="docPubcolor"><span class="docEmphasis">Form mock ups</span></span></DT>
<DD>
<P class="docList">We've redundantly coded classes to mock-up form field inputs
twice in this chapter already; the "dummy" class here is
clearly a mechanism worth reusing.
</P>
</DD><DT><span class="docPubcolor"><span class="docEmphasis">HTML Code</span></span></DT>
<DD>
<P class="docList">HTML embedded in and generated by the script is sprinkled throughout
the program in <TT>print</TT> statements, making it
difficult to implement broad web page layout changes.
</P>
</DD>
</DL>

<P class="docText">This is a short example, of course, but issues of redundancy and
reuse become more acute as your scripts grow larger. As a rule of
thumb, if you find yourself changing multiple source files to modify
a single behavior, or if you notice that you've taken to
writing programs by cut-and-paste copying of existing code, then
it's probably time to think about more rational program
structures. To illustrate coding styles and practices that are more
friendly to maintainers, let's rewrite this example to fix all
of these weaknesses in a single mutation.
</P>

<A NAME="python2-CHP-12-SECT-5.1"></A>
<H4 class="docSection2Title">12.5.1 Step 1: Sharing Objects Between Pages</H4>

<P class="docText"><A NAME="python2-IDXTERM-1235"></A> <A NAME="python2-IDXTERM-1236"></A> <A NAME="python2-IDXTERM-1237"></A>We can remove the
first two maintenance problems listed above with a simple
transformation; the trick is to generate the main page dynamically,
from an executablescript, rather than from a
precoded HTML file. Within a script, we can import the input field
name and selection list values from a common Python module file,
shared by the main and reply page generation scripts. Changing the
selection list or field name in the common module changes both
clients automatically. First, we move shared objects to a common
module file, as shown in <A class="docLink" HREF="#python2-CHP-12-EX-18">Example 12-18</A>.
</P>


<H5 class="docExampleTitle"><A NAME="python2-CHP-12-EX-18"></A>Example 12-18. PP2E\Internet\Cgi-Web\Basics\languages2common.py </H5>
<PRE>########################################################
# common objects shared by main and reply page scripts;
# need change only this file to add a new language.
########################################################

inputkey = 'language'                            # input parameter name 

hellos = {
    'Python':    r" print 'Hello World'               ",
    'Perl':      r' print "Hello World\n";            ',
    'Tcl':       r' puts "Hello World"                ',
    'Scheme':    r' (display "Hello World") (newline) ',
    'SmallTalk': r" 'Hello World' print.              ",
    'Java':      r' System.out.println("Hello World"); ',
    'C':         r' printf("Hello World\n");          ',
    'C++':       r' cout &lt;&lt; "Hello World" &lt;&lt; endl;    ',
    'Basic':     r' 10 PRINT "Hello World"            ',
    'Fortran':   r" print *, 'Hello World'             ",
    'Pascal':    r" WriteLn('Hello World');            "
}</PRE>


<P class="docText">Module <TT>languages2common</TT> contains all the data that
needs to agree between pages: the field name, as well as the syntax
dictionary. The <TT>hellos</TT> syntax dictionary
isn't quite HTML code, but its keys list can be used to
generate HTML for the selection list on the main page dynamically.
Next, in <A class="docLink" HREF="#python2-CHP-12-EX-19">Example 12-19</A>, we recode the main page as an
executable script, and populate the response HTML with values
imported from the common module file in the previous example.
</P>


<H5 class="docExampleTitle"><A NAME="python2-CHP-12-EX-19"></A>Example 12-19. PP2E\Internet\Cgi-Web\Basics\languages2.cgi </H5>
<PRE>#!/usr/bin/python
#################################################################
# generate html for main page dynamically from an executable
# Python script, not a pre-coded HTML file; this lets us 
# import the expected input field name and the selection table 
# values from a common Python module file; changes in either 
# now only have to be made in one place, the Python module file;
#################################################################

REPLY = """Content-type: text/html

&lt;html&gt;&lt;body&gt;
&lt;title&gt;Languages2&lt;/title&gt;
&lt;h1&gt;Hello World selector&lt;/h1&gt;
&lt;P&gt;Similar to file &lt;a href="languages.html"&gt;languages.html&lt;/a&gt;, but 
this page is dynamically generated by a Python CGI script, using 
selection list and input field names imported from a common Python 
module on the server. Only the common module must be maintained as 
new languages are added, because it is shared with the reply script.

To see the code that generates this page and the reply, click
&lt;a href="getfile.cgi?filename=languages2.cgi"&gt;here&lt;/a&gt;, 
&lt;a href="getfile.cgi?filename=languages2reply.cgi"&gt;here&lt;/a&gt;, 
&lt;a href="getfile.cgi?filename=languages2common.py"&gt;here&lt;/a&gt;, and
&lt;a href="getfile.cgi?filename=formMockup.py"&gt;here&lt;/a&gt;.&lt;/P&gt;
&lt;hr&gt;
&lt;form method=POST action="languages2reply.cgi"&gt;
    &lt;P&gt;&lt;B&gt;Select a programming language:&lt;/B&gt;
    &lt;P&gt;&lt;select name=%s&gt;
        &lt;option&gt;All
        %s
        &lt;option&gt;Other
    &lt;/select&gt;
    &lt;P&gt;&lt;input type=Submit&gt;
&lt;/form&gt;
&lt;/body&gt;&lt;/html&gt;
"""

import string
from languages2common import hellos, inputkey

options = []
for lang in hellos.keys(  ):
    options.append('&lt;option&gt;' + lang)      # wrap table keys in html code
options = string.join(options, '\n\t')
print REPLY % (inputkey, options)          # field name and values from module</PRE>


<P class="docText">Here again, ignore the <TT>getfile</TT> hyperlinks in this
file for now; we'll learn what they mean in the next section.
You should notice, though, that the HTML page definition becomes a
printed Python string here (named <TT>REPLY</TT>), with
<TT>%s</TT> format targets where we plug in values imported
from the common module.<sup class="docFootnote"><A class="docLink" HREF="#">[11]</A></sup> It's otherwise similar to the
original HTML file's code; when we visit this script's
URL, we get a similar page, shown in <A class="docLink" HREF="#python2-CHP-12-FIG-23">Figure 12-23</A>.
But this time, the page is generated by running a script on the
server that populates the pull-down selection list from the keys list
of the common syntax table.<A NAME="IXTR3-320"></A> <A NAME="IXTR3-321"></A> <A NAME="IXTR3-322"></A>
</P>
<blockquote><p class="docFootnote"><sup><A NAME="">[11]</A></sup> The HTML code template could
be loaded from an external text file, too, but external text files
are no more easily changed than Python scripts. In fact, Python
scripts <span class="docEmphasis">are</span> text files, and this is a major
feature of the language: it's usually easy to change the Python
scripts of an installed system onsite, without re-compile or re-link
steps.</p></blockquote>

<CENTER>
<H5 class="docFigureTitle"><A NAME="python2-CHP-12-FIG-23"></A>Figure 12-23. Alternative main page made by languages2.cgi </H5>
<IMG BORDER="0" WIDTH="332" HEIGHT="241" src="FILES/ppy2_1223.gif" ALT="figs/ppy2_1223.gif"></CENTER>


<A NAME="python2-CHP-12-SECT-5.2"></A>
<H4 class="docSection2Title">12.5.2 Step 2: A Reusable Form Mock-up Utility</H4>

<P class="docText"><A NAME="python2-IDXTERM-1241"></A>
<A NAME="python2-IDXTERM-1242"></A>
<A NAME="python2-IDXTERM-1243"></A>Moving the
languages table and input field name to a module file solves the
first two maintenance problems we noted. But if we want to avoid
writing a dummy field mock-up class in every CGI script we write, we
need to do something more. Again, it's merely a matter of
exploiting the Python module's affinity for code reuse:
let's move the dummy class to a utility module, as in <A class="docLink" HREF="#python2-CHP-12-EX-20">Example 12-20</A>.
</P>


<H5 class="docExampleTitle"><A NAME="python2-CHP-12-EX-20"></A>Example 12-20. PP2E\Internet\Cgi-Web\Basics\formMockup.py </H5>
<PRE>##############################################################
# Tools for simulating the result of a cgi.FieldStorage(  ) 
# call; useful for testing CGI scripts outside the web
##############################################################

import types

class FieldMockup:                                   # mocked-up input object
    def __init__(self, str): 
        self.value = str

def formMockup(**kwargs):                            # pass field=value args
    mockup = {}                                      # multi-choice: [value,...]
    for (key, value) in kwargs.items(  ):
        if type(value) is not types.ListType:        # simple fields have .value
            mockup[key] = FieldMockup(str(value))
        else:                                        # multi-choice have list
            mockup[key] = []                         # to do: file upload fields
            for pick in value:
                mockup[key].append(FieldMockup(pick))
    return mockup

def selftest(  ):
    # use this form if fields can be hard-coded
    form = formMockup(name='Bob', job='hacker', food=['Spam', 'eggs', 'ham'])
    print form['name'].value
    print form['job'].value
    for item in form['food']:
        print item.value,
    # use real dict if keys are in variables or computed
    print
    form = {'name':FieldMockup('Brian'), 'age':FieldMockup(38)}
    for key in form.keys(  ):
        print form[key].value

if __name__ == '__main__': selftest(  )</PRE>


<P class="docText">By placing our mock-up class in this module,
<I>formMockup.py</I>, it automatically becomes a
reusable tool, and may be imported by any script we care to
write.<sup class="docFootnote"><A class="docLink" HREF="#">[12]</A></sup> For
readability, the <TT>dummy</TT> field simulation class has
been renamed <TT>FieldMockup</TT> here. For convenience,
we've also added a <TT>formMockup</TT> utility
function that builds up an entire form dictionary from passed-in
keyword arguments. Assuming you can hardcode the names of the form to
be faked, the mock-up can be created in a single call. This module
includes a self-test function invoked when the file is run from the
command line, which demonstrates how its exports are used. Here is
its test output, generated by making and querying two form mock-up
objects:
</P>
<blockquote><p class="docFootnote"><sup><A NAME="">[12]</A></sup> This assumes, of course, that this module can
be found on the Python module search path when those scripts are run.
See the search path discussion earlier in this chapter. Since Python
searches the current directory for imported modules by default, this
always works without <TT>sys.path</TT> changes if all of
our files are in our main web directory.</p></blockquote>

<PRE>C:\...\PP2E\Internet\Cgi-Web\Basics&gt;<B>python formMockup.py</B>
Bob
hacker
Spam eggs ham
38
Brian</PRE>

<P class="docText">Since the mock-up now lives in a module, we can reuse it any time we
want to test a CGI script offline. To illustrate, the script in <A class="docLink" HREF="#python2-CHP-12-EX-21">Example 12-21</A> is a rewrite of the
<I>test5.cgi</I> example we saw earlier, using the form
mock-up utility to simulate field inputs. If we had planned ahead, we
could have tested this script like this without even needing to
connect to the Net.
</P>


<H5 class="docExampleTitle"><A NAME="python2-CHP-12-EX-21"></A>Example 12-21. PP2E\Internet\Cgi-Web\Basics\test5_mockup.cgi </H5>
<PRE>#!/usr/bin/python
##################################################################
# run test5 logic with formMockup instead of cgi.FieldStorage(  )
# to test: python test5_mockup.cgi &gt; temp.html, and open temp.html
##################################################################

from formMockup import formMockup
form = formMockup(name='Bob',
                  shoesize='Small',
                  language=['Python', 'C++', 'HTML'], 
                  comment='ni, Ni, NI')

# rest same as original, less form assignment</PRE>


<P class="docText">Running this script from a simple command line shows us what the HTML
response stream will look like:
</P>

<PRE>C:\...\PP2E\Internet\Cgi-Web\Basics&gt;<B>python test5_mockup.cgi</B>
Content-type: text/html

&lt;TITLE&gt;test5.cgi&lt;/TITLE&gt;
&lt;H1&gt;Greetings&lt;/H1&gt;
&lt;HR&gt;
&lt;H4&gt;Your name is Bob&lt;/H4&gt;
&lt;H4&gt;You wear rather Small shoes&lt;/H4&gt;
&lt;H4&gt;Your current job: (unknown)&lt;/H4&gt;
&lt;H4&gt;You program in Python and C++ and HTML&lt;/H4&gt;
&lt;H4&gt;You also said:&lt;/H4&gt;
&lt;P&gt;ni, Ni, NI&lt;/P&gt;
&lt;HR&gt;</PRE>

<P class="docText">Running it live yields the page in <A class="docLink" HREF="#python2-CHP-12-FIG-24">Figure 12-24</A>.
Field inputs here are hardcoded, similar in spirit to the
<span class="docEmphasis">test5</span> extension that embedded input parameters
at the end of hyperlink URLs. Here, they come from form mock-up
objects created in the reply script that cannot be changed without
editing the script. Because Python code runs immediately, though,
modifying a Python script during the debug cycle goes as quickly as
you can type. <A NAME="IXTR3-323"></A> <A NAME="IXTR3-324"></A> <A NAME="IXTR3-325"></A>
</P>

<CENTER>
<H5 class="docFigureTitle"><A NAME="python2-CHP-12-FIG-24"></A>Figure 12-24. A response page with simulated inputs</H5>
<IMG BORDER="0" WIDTH="285" HEIGHT="291" src="FILES/ppy2_1224.gif" ALT="figs/ppy2_1224.gif"></CENTER>


<A NAME="python2-CHP-12-SECT-5.3"></A>
<H4 class="docSection2Title">12.5.3 Step 3: Putting It All Together -- A New Reply Script</H4>

<P class="docText">There's one last step on our path to software maintenance
nirvana: we still must recode the reply page script itself, to import
data that was factored out to the common module and import the
reusable form mock-up module's tools. While we're at it,
we move code into functions (in case we ever put things in this file
that we'd like to import in another script), and all HTML code
to triple-quoted string blocks (see <A class="docLink" HREF="#python2-CHP-12-EX-22">Example 12-22</A>).
Changing HTML is generally easier when it has been isolated in single
strings like this, rather than being sprinkled throughout a program.
</P>


<H5 class="docExampleTitle"><A NAME="python2-CHP-12-EX-22"></A>Example 12-22. PP2E\Internet\Cgi-Web\Basics\languages2reply.cgi </H5>
<PRE>#!/usr/bin/python
#########################################################
# for easier maintenance, use html template strings, get
# the language table and input key from common mdule file,
# and get reusable form field mockup utilities module.
#########################################################

import cgi, sys
from formMockup import FieldMockup                   # input field simulator
from languages2common import hellos, inputkey        # get common table, name
debugme = 0

hdrhtml = """Content-type: text/html\n
&lt;TITLE&gt;Languages&lt;/TITLE&gt;
&lt;H1&gt;Syntax&lt;/H1&gt;&lt;HR&gt;"""
 
langhtml = """
&lt;H3&gt;%s&lt;/H3&gt;&lt;P&gt;&lt;PRE&gt;
%s
&lt;/PRE&gt;&lt;/P&gt;&lt;BR&gt;"""

def showHello(form):                                 # html for one language
    choice = form[inputkey].value                    # escape lang name too
    try:
        print langhtml % (cgi.escape(choice),
                          cgi.escape(hellos[choice]))
    except KeyError:
        print langhtml % (cgi.escape(choice), 
                         "Sorry--I don't know that language")

def main(  ):
    if debugme:
        form = {inputkey: FieldMockup(sys.argv[1])}  # name on cmd line
    else:
        form = cgi.FieldStorage(  )                    # parse real inputs
    
    print hdrhtml
    if not form.has_key(inputkey) or form[inputkey].value == 'All':
        for lang in hellos.keys(  ):
            mock = {inputkey: FieldMockup(lang)}
            showHello(mock)
    else:
        showHello(form)
    print '&lt;HR&gt;' 

if __name__ == '__main__': main(  )</PRE>


<P class="docText">When global <TT>debugme</TT> is set to 1, the script can be
tested offline from a simple command line as before:
</P>

<PRE>C:\...\PP2E\Internet\Cgi-Web\Basics&gt;<B>python languages2reply.cgi Python</B>
Content-type: text/html

&lt;TITLE&gt;Languages&lt;/TITLE&gt;
&lt;H1&gt;Syntax&lt;/H1&gt;&lt;HR&gt;

&lt;H3&gt;Python&lt;/H3&gt;&lt;P&gt;&lt;PRE&gt;
 print 'Hello World'
&lt;/PRE&gt;&lt;/P&gt;&lt;BR&gt;
&lt;HR&gt;</PRE>

<P class="docText">When run online, we get the same reply pages we saw for the original
version of this example (we won't repeat them here again). This
transformation changed the program's architecture, not its user
interface.
</P>

<P class="docText">Most of the code changes in this version of the reply script are
straightforward. If you test-drive these pages, the only differences
you'll find are the URLs at the top of your browser
(they're different files, after all), extra blank lines in the
generated HTML (ignored by the browser), and a potentially different
ordering of language names in the main page's pull-down
selection list.
</P>

<P class="docText">This selection list ordering difference arises because this version
relies on the order of the Python dictionary's keys list, not
on a hardcoded list in an HTML file. Dictionaries, you'll
recall, arbitrarily order entries for fast fetches; if you want the
selection list to be more predictable, simply sort the keys list
before iterating over it using the list <TT>sort</TT>
method.<A NAME="IXTR3-326"></A> <A NAME="IXTR3-327"></A>
</P>

<P><A NAME="python2-CHP-12-SIDEBAR-2"></A><TABLE CELLSPACING="0" WIDTH="90%" BORDER="1"><TR><TD>
<H2 class="docSidebarTitle">Faking Inputs with Shell Variables</H2>

<P class="docText"><A NAME="IXT-12-337578"></A> <A NAME="IXT-12-337579"></A>If you know what you're doing, you
can sometimes also test CGI scripts from the command line by setting
the same environment variables that HTTP servers set, and then
launching your script. For example, we can pretend to be a web server
by storing input parameters in the QUERY_STRING environment variable,
using the same syntax we employ at the end of a URL string after the
<TT>?</TT>:
</P>

<PRE>$ <B>setenv QUERY_STRING "name=Mel&amp;job=trainer,+writer"</B>
$ <B>python test5.cgi</B>
Content-type: text/html

&lt;TITLE&gt;test5.cgi&lt;?TITLE&gt;
&lt;H1&gt;Greetings&lt;/H1&gt;
&lt;HR&gt;
&lt;H4&gt;Your name is Mel&lt;/H4&gt;
&lt;H4&gt;You wear rather (unknown) shoes&lt;/H4&gt;
&lt;H4&gt;Your current job: trainer, writer&lt;/H4&gt;
&lt;H4&gt;You program in (unknown)&lt;/H4&gt;
&lt;H4&gt;You also said:&lt;/H4&gt;
&lt;P&gt;(unknown)&lt;/P&gt;
&lt;HR&gt;</PRE>

<P class="docText">Here, we mimic the effects of a GET style form submission or explicit
URL. HTTP servers place the query string (parameters) in the shell
variable QUERY_STRING. Python's <TT>cgi</TT> module
finds them there as though they were sent by a browser. POST-style
inputs can be simulated with shell variables, too, but it's
more complex -- so much so that you're likely best off not
learning how. In fact, it may be more robust in general to mock-up
inputs with Python objects (e.g., as in
<I>formMockup.py</I>). But some CGI scripts may have
additional environment or testing constraints that merit unique
treatment.
</P>
</TD></TR></TABLE></P>



<a href="0596000855_"><img src="FILES/pixel.gif" width="1" height="1" border="0"></a><ul></ul>
</td>
</tr>
</table>
<td></td>
<table width="100%" border="0" cellspacing="0" cellpadding="0" bgcolor="#CCCCCC">
<td><font color="black" size=1>I l<font color="#FF0000">@</font>ve RuBoard</td>
<td valign="top" class="v2" align="right">
          <a href="0596000855_python2-CHP-12-SECT-4.html"><img src="FILES/previous.gif" width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a>
          <a href="0596000855_python2-CHP-12-SECT-6.html"><img src="FILES/next.gif" width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a>
</td></table>
</body></html>
