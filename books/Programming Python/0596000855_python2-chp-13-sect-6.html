<html><head>
<META http-equiv="Content-Type" content="text/html">
<!--SafClassName="docSection1Title"--><!--SafTocEntry="13.6 Utility Modules"-->
<link rel="STYLESHEET" type="text/css" href="FILES/style.css">
<link rel="STYLESHEET" type="text/css" href="FILES/docsafari.css">
</head>
<body>
<table width="100%" border="0" cellspacing="0" cellpadding="0" bgcolor="#CCCCCC">
<td><font color="black" size=1>I l<font color="#FF0000">@</font>ve RuBoard</td>
<td valign="top" class="v2" align="right">
	<a href="0596000855_python2-CHP-13-SECT-5.html"><img src="FILES/previous.gif" width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a>
	<a href="0596000855_python2-CHP-13-SECT-7.html"><img src="FILES/next.gif" width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a>
</td></table>
<br>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<tr>
<td valign="top"><A NAME="python2-CHP-13-SECT-6"></A>
<H3 class="docSection1Title">13.6 Utility Modules</H3>

<P class="docText"><A NAME="python2-IDXTERM-1397"></A>
<A NAME="python2-IDXTERM-1398"></A>
<A NAME="python2-IDXTERM-1399"></A>This section presents the source code
of the utility modules imported and used by the page scripts shown
above. There aren't any new screen shots to see here, because
these are utilities, not CGI scripts (notice their
<I>.py</I> extensions). Moreover, these modules
aren't all that useful to study in isolation, and are included
here primarily to be referenced as you go through the CGI
scripts' code. See earlier in this chapter for additional
details not repeated here.
</P>

<A NAME="python2-CHP-13-SECT-6.1"></A>
<H4 class="docSection2Title">13.6.1 External Components</H4>

<P class="docText"><A NAME="python2-IDXTERM-1400"></A>When I install PyMailCgi and other
server-side programs shown in this book, I simply upload the contents
of the <I>Cgi-Web</I> examples directory on my laptop
to the top-level web directory on my server account
(<I>public_html </I>). The <I>Cgi-Web</I>
directory also lives on this book's CD (see <A class="docLink" target="_blank" HREF="http://examples.oreilly.com/python2">http://examples.oreilly.com/python2</A>), a mirror of the one on
my PC. I don't copy the entire book examples distribution to my
web server, because code outside the <I>Cgi-Web
</I>directory isn't designed to run on a web server.
</P>

<P class="docText"><A NAME="IXT-13-337655"></A>When I first
installed PyMailCgi, however, I ran into a problem: it's
written to reuse modules coded in other parts of the book, and hence
in other directories outside <I>Cgi-Web</I>. For
example, it reuses the <TT>mailconfig</TT> and
<TT>pymail</TT> modules we wrote in <A class="docLink" HREF="0596000855_python2-CHP-11.html#python2-CHP-11">Chapter 11</A>, but neither lives in the CGI examples
directory. Such external dependencies are usually okay, provided we
use package imports or configure <TT>sys.path</TT>
appropriately on startup. In the context of CGI scripts, though, what
lives on my development machine may not be what is available on the
web server machine where the scripts are installed.
</P>

<P class="docText">To work around this (and avoid uploading the full book examples
distribution to my web server), I define a directory at the top-level
of <I>Cgi-Web</I> called <I>Extern</I>,
to which any required external modules are copied as needed. For this
system, <I>Extern</I> includes a subdirectory called
<I>Email</I>, where the <TT>mailconfig</TT>
and <TT>pymail</TT> modules are copied for upload to the
server.
</P>

<P class="docText">Redundant copies of files are less than ideal, but this can all be
automated with install scripts that automatically copy to
<I>Extern</I> and then upload
<I>Cgi-Web</I> contents via FTP using Python's
<TT>ftplib</TT> module (discussed in <A class="docLink" HREF="0596000855_python2-CHP-11.html#python2-CHP-11">Chapter 11</A>). Just in case I change this structure,
though, I've encapsulated all external name accesses in the
utility module in <A class="docLink" HREF="#python2-CHP-13-EX-10">Example 13-10</A>.
</P>


<H5 class="docExampleTitle"><A NAME="python2-CHP-13-EX-10"></A>Example 13-10. PP2E\Internet\Cgi-Web\PyMailCgi\externs.py </H5>
<PRE>##############################################################
# Isolate all imports of modules that live outside of the
# PyMailCgi PyMailCgi directory.  Normally, these would come
# from PP2E.Internet.Email, but when I install PyMailCgi, 
# I copy just the Cgi-Web directory's contents to public_html
# on the server, so there is no PP2E directory on the server.
# Instead, I either copy the imports referenced in this file to 
# the PyMailCgi parent directory, or tweak the dir appended to
# the sys.path module search path here.  Because all other 
# modules get the externals from here, there is only one place
# to change when they are relocated.  This may be arguably
# gross, but I only put Internet code on the server machine.
##############################################################

import sys
sys.path.append('..')                 # see dir where Email installed on server
from  Extern import Email             # assumes a ../Extern dir with Email dir
from  Extern.Email import pymail      # can use names Email.pymail or pymail
from  Extern.Email import mailconfig</PRE>


<P class="docText">This module appends the parent directory of PyMailCgi to
<TT>sys.path</TT> to make the <I>Extern</I>
directory visible (remember, PYTHONPATH might be anything when CGI
scripts are run as user "nobody") and preimports all
external names needed by PyMailCgi into its own namespace. It also
supports future changes; because all external references in PyMailCgi
are made through this module, I have to change only this one file if
externals are later installed differently.
</P>

<P class="docText">As a reference, <A class="docLink" HREF="#python2-CHP-13-EX-11">Example 13-11</A> lists part of the
external <TT>mailconfig</TT> module again. For PyMailCgi,
it's copied to <I>Extern</I>, and may be tweaked
as desired on the server (for example, the signature string differs
slightly in this context). See the <I>pymail.py</I>
file in <A class="docLink" HREF="0596000855_python2-CHP-11.html#python2-CHP-11">Chapter 11</A>, and consider writing an
automatic copy-and-upload script for the
<I>Cgi-Web\Extern</I> directory a suggested exercise;
it's not proved painful enough to compel me to write one of my
own.
</P>


<H5 class="docExampleTitle"><A NAME="python2-CHP-13-EX-11"></A>Example 13-11. PP2E\Internet\Cgi-Web\Extern\Email\mailconfig.py </H5>
<A NAME="IXTR3-364"></A><PRE>############################################
# email scripts get server names from here:
# change to reflect your machine/user names;
# could get these in command line instead
############################################

# SMTP email server machine (send)
smtpservername = 'smtp.rmi.net'          # or starship.python.net, 'localhost'

# POP3 email server machine, user (retrieve)
popservername  = 'pop.rmi.net'           # or starship.python.net, 'localhost'
popusername    = 'lutz'                  # password is requested when run

...rest omitted

# personal info used by PyMailGui to fill in forms;
# sig-- can be a triple-quoted block, ignored if empty string;
# addr--used for initial value of "From" field if not empty,

myaddress   = 'lutz@rmi.net'
mysignature = '--Mark Lutz  (http://rmi.net/~lutz)  [PyMailCgi 1.0]'</PRE>



<A NAME="python2-CHP-13-SECT-6.2"></A>
<H4 class="docSection2Title">13.6.2 POP Mail Interface</H4>

<P class="docText"><A NAME="IXT-13-337656"></A>
<A NAME="IXT-13-337657"></A> <A NAME="IXT-13-337658"></A>The <TT>loadmail</TT>
utility module in <A class="docLink" HREF="#python2-CHP-13-EX-12">Example 13-12</A> depends on external
files and encapsulates access to mail on the remote POP server
machine. It currently exports one function,
<TT>loadnewmail</TT>, which returns a list of all mail in
the specified POP account; callers are unaware of whether this mail
is fetched over the Net, lives in memory, or is loaded from a
persistent storage medium on the CGI server machine. That is by
design -- <TT>loadmail</TT> changes won't impact
its clients.
</P>


<H5 class="docExampleTitle"><A NAME="python2-CHP-13-EX-12"></A>Example 13-12. PP2E\Internet\Cgi-Web\PyMailCgi\loadmail.py </H5>
<PRE>###################################################################
# mail list loader; future--change me to save mail list between
# cgi script runs, to avoid reloading all mail each time; this
# won't impact clients that use the interfaces here if done well;
# for now, to keep this simple, reloads all mail on each operation
###################################################################

from commonhtml import runsilent         # suppress print's (no verbose flag)
from externs    import Email

# load all mail from number 1 up
# this may trigger an exception

def loadnewmail(mailserver, mailuser, mailpswd):
    return runsilent(Email.pymail.loadmessages,
                                  (mailserver, mailuser, mailpswd))</PRE>


<P class="docText">It's not much to look at -- just an interface and calls to
other modules. The <TT>Email.pymail.loadmessages</TT>
function (reused here from <A class="docLink" HREF="0596000855_python2-CHP-11.html#python2-CHP-11">Chapter 11</A>) uses the
Python <TT>poplib</TT> module to fetch mail over sockets.
All this activity is wrapped in a
<TT>commonhtml.runsilent</TT> function call to prevent
<TT>pymail</TT> print statements from going to the HTML
reply stream (although any <TT>pymail</TT> exceptions are
allowed to propagate normally).
</P>

<P class="docText">As it is, though, <TT>loadmail</TT> loads all incoming
email to generate the selection list page, and reloads all email
again every time you fetch a message from the list. This scheme can
be horribly inefficient if you have lots of email sitting on your
server; I've noticed delays on the order of a dozen seconds
when my mailbox is full. On the other hand, servers can be slow in
general, so the extra time taken to reload mail isn't always
significant; I've witnessed similar delays on the server for
empty mailboxes and simple HTML pages too.
</P>

<P class="docText">More importantly, <TT>loadmail</TT> is intended only as a
first-cut mail interface -- something of a usable prototype. If I
work on this system further, it would be straightforward to cache
loaded mail in a file, shelve, or database on the server, for
example. Because the interface exported by
<TT>loadmail</TT> would not need to change to introduce a
caching mechanism, clients of this module would still work.
We'll explore server storage options in the next chapter.
</P>


<A NAME="python2-CHP-13-SECT-6.3"></A>
<H4 class="docSection2Title">13.6.3 POP Password Encryption</H4>

<P class="docText"><A NAME="python2-IDXTERM-1405"></A> <A NAME="python2-IDXTERM-1406"></A>
<A NAME="python2-IDXTERM-1407"></A> <A NAME="python2-IDXTERM-1408"></A>Time
to call the cops. We discussed the approach to password security
adopted by PyMailCgi earlier. In brief, it works hard to avoid ever
passing the POP account username and password across the Net together
in a single transaction, unless the password is encrypted according
to module <I>secret.py</I> on the server. This module
can be different everywhere PyMailCgi is installed and can be
uploaded anew at any time -- encrypted passwords aren't
persistent and live only for the duration of one mail-processing
interaction session.<sup class="docFootnote"><A class="docLink" HREF="#">[4]</A></sup> <A class="docLink" HREF="#python2-CHP-13-EX-13">Example 13-13</A>
is the encryptor module I installed on my server while developing
this book.
</P>
<blockquote><p class="docFootnote"><sup><A NAME="">[4]</A></sup> Note that there are other ways
to handle password security, beyond the custom encryption schemes
described in this section. For instance, Python's socket module
now supports the server-side portion of the OpenSSL secure sockets
protocol. With it, scripts may delegate the security task to web
browsers and servers. On the other hand, such schemes do not afford
as good an excuse to introduce Python's standard encryption
tools in this book.</p></blockquote>


<H5 class="docExampleTitle"><A NAME="python2-CHP-13-EX-13"></A>Example 13-13. PP2E\Internet\Cgi-Web\PyMailCgi\secret.py </H5>
<PRE>###############################################################################
# PyMailCgi encodes the pop password whenever it is sent to/from client over
# the net with a user name as hidden text fields or explicit url params; uses 
# encode/decode functions in this module to encrypt the pswd--upload your own
# version of this module to use a different encryption mechanism; pymail also 
# doesn't save the password on the server, and doesn't echo pswd as typed, but
# this isn't 100% safe--this module file itself might be vulnerable to some
# malicious users; Note: in Python 1.6, the socket module will include standard
# (but optional) support for openSSL sockets on the server, for programming 
# secure Internet transactions in Python; see 1.6 socket module docs;
###############################################################################

forceReadablePassword = 0 
forceRotorEncryption  = 1

import time, string
dayofweek = time.localtime(time.time(  ))[6]

###############################################################################
# string encoding schemes
###############################################################################

if not forceReadablePassword:
    # don't do anything by default: the urllib.quote or
    # cgi.escape calls in commonhtml.py will escape the 
    # password as needed to embed in in URL or HTML; the 
    # cgi module undoes escapes automatically for us;

    def stringify(old):   return old
    def unstringify(old): return old

else:
    # convert encoded string to/from a string of digit chars,
    # to avoid problems with some special/nonprintable chars,
    # but still leave the result semi-readable (but encrypted);
    # some browser had problems with escaped ampersands, etc.;

    separator = '-'

    def stringify(old):
        new = ''
        for char in old:
            ascii = str(ord(char)) 
            new   = new + separator + ascii       # '-ascii-ascii-ascii'
        return new

    def unstringify(old):
        new = ''
        for ascii in string.split(old, separator)[1:]:
            new = new + chr(int(ascii))
        return new 

###############################################################################
# encryption schemes
###############################################################################

if (not forceRotorEncryption) and (dayofweek % 2 == 0):
    # use our own scheme on evenly-numbered days (0=monday)
    # caveat: may fail if encode/decode over midnite boundary
 
    def do_encode(pswd):
        res = ''
        for char in pswd:
            res = res + chr(ord(char) + 1)        # add 1 to each ascii code
        return str(res)

    def do_decode(pswd):
        res = ''
        for char in pswd:
            res = res + chr(ord(char) - 1)
        return res

else:
    # use the standard lib's rotor module to encode pswd
    # this does a better job of encryption than code above

    import rotor
    mykey = 'pymailcgi'

    def do_encode(pswd):
        robj = rotor.newrotor(mykey)              # use enigma encryption
        return robj.encrypt(pswd)        
    
    def do_decode(pswd):
        robj = rotor.newrotor(mykey)
        return robj.decrypt(pswd)        

###############################################################################
# top-level entry points
###############################################################################

def encode(pswd):
    return stringify(do_encode(pswd))             # encrypt plus string encode

def decode(pswd):
    return do_decode(unstringify(pswd))</PRE>


<P class="docText">This encryptor module implements two alternative encryption schemes:
a simple ASCII character code mapping, and Enigma-style encryption
using the standard <TT>rotor</TT> module. The
<TT>rotor</TT> module implements a sophisticated encryption
strategy, based on the "Enigma" encryption machine used
by the Nazis to encode messages during World War II. Don't
panic, though; Python's <TT>rotor</TT> module is much
less prone to cracking than the Nazis'!
</P>

<P class="docText">In addition to encryption, this module also implements an
<span class="docEmphasis">encoding</span> method for already-encrypted strings.
By default, the encoding functions do nothing, and the system relies
on straight URL encoding. An optional encoding scheme translates the
encrypted string to a string of ASCII code digits separated by
dashes. Either encoding method makes non-printable characters in the
encrypted string printable.
</P>

<A NAME="python2-CHP-13-SECT-6.3.1"></A>
<H5 class="docSection3Title">13.6.3.1 Default encryption scheme: rotor</H5>

<P class="docText">To illustrate, let's test this module's tools
interactively. First off, we'll experiment with Python's
standard <TT>rotor</TT> module, since it's at the
heart of the default encoding scheme. We import the module, make a
new rotor object with a key (and optionally, a rotor count), and call
methods to encrypt and decrypt:<A NAME="IXT-13-337659"></A> <A NAME="IXT-13-337660"></A>
</P>

<PRE>C:\...\PP2E\Internet\Cgi-Web\PyMailCgi&gt;<B>python</B>
&gt;&gt;&gt; <B>import rotor</B>
&gt;&gt;&gt; <B>r = rotor.newrotor('pymailcgi')</B>        # (key, [,numrotors])
&gt;&gt;&gt; <B>r.encrypt('abc123')  </B>                  # may return non-printable chars
' \323an\021\224'

&gt;&gt;&gt; <B>x = r.encrypt('spam123')</B>               # result is same len as input
&gt;&gt;&gt; <B>x</B>
'* _\344\011pY'
&gt;&gt;&gt; <B>len(x)</B>
7
&gt;&gt;&gt; <B>r.decrypt(x)</B>
'spam123'</PRE>

<P class="docText">Notice that the same rotor object can encrypt multiple strings, that
the result may contain non-printable characters (printed as
<TT>\ascii</TT> escape codes when displayed, possibly in
octal form), and that the result is always the same length as the
original string. Most importantly, a string encrypted with
<TT>rotor</TT> can be decrypted in a different process
(e.g., in a later CGI script) if we recreate the rotor object:
</P>

<PRE>C:\...\PP2E\Internet\Cgi-Web\PyMailCgi&gt;<B>python</B>
&gt;&gt;&gt; <B>import rotor</B>
&gt;&gt;&gt; <B>r = rotor.newrotor('pymailcgi')</B>        # can be decrypted in new process
&gt;&gt;&gt; <B>r.decrypt('* _\344\011pY')</B>             # use "\ascii" escapes for two chars
'spam123'</PRE>

<P class="docText">Our <TT>secret</TT> module by default simply uses
<TT>rotor</TT> to encrypt, and does no additional encoding
of its own. It relies on URL encoding when the password is embedded
in a URL parameter, and HTML escaping when the password is embedded
in hidden form fields. For URLs, the following sorts of calls occur:
</P>

<PRE>&gt;&gt;&gt; <B>from secret import encode, decode</B>
&gt;&gt;&gt; <B>x = encode('abc$#&lt;&gt;&amp;+')</B>                 # CGI scripts do this (rotor)
&gt;&gt;&gt; <B>x</B>
' \323a\016\317\326\023\0163'

&gt;&gt;&gt; <B>import urllib</B>                           # urllib.urlencode does this
&gt;&gt;&gt; <B>y = urllib.quote_plus(x)</B>
&gt;&gt;&gt; <B>y</B>
'+%d3a%0e%cf%d6%13%0e3'

&gt;&gt;&gt; <B>a = urllib.unquote_plus(y)</B>              # cgi.FieldStorage does this
&gt;&gt;&gt; <B>a</B>
' \323a\016\317\326\023\0163'

&gt;&gt;&gt; <B>decode(a)</B>                               # CGI scripts do this (rotor)
'abc$#&lt;&gt;&amp;+' </PRE>



<A NAME="python2-CHP-13-SECT-6.3.2"></A>
<H5 class="docSection3Title">13.6.3.2 Alternative encryption schemes</H5>

<P class="docText">To show how to write alternative encryptors and encoders,
<TT>secret</TT> also includes a digits-string encoder and a
character-code shuffling encryptor; both are enabled with global flag
variables at the top of the module:
<A NAME="IXT-13-337661"></A>
</P>

<DL class="docList">
<DT><span class="docPubcolor"><span class="docEmphasis">forceReadablePassword</span></span></DT>
<DD>
<P class="docList">If set to <span class="docEmphasis">true</span>, the encrypted password is
encoded into a string of ASCII code digits separated by dashes.
Defaults to <span class="docEmphasis">false</span> to fall back on URL and HTML
escape encoding.
</P>
</DD><DT><span class="docPubcolor"><span class="docEmphasis">forceRotorEncryption</span></span></DT>
<DD>
<P class="docList">If set to <span class="docEmphasis">false</span> and the encryptor is used on an
even-numbered day of the week, the simple character-code encryptor is
used instead of <TT>rotor</TT>. Defaults to
<span class="docEmphasis">true</span> to force rotor encryption.
</P>
</DD>
</DL>

<P class="docText">To show how these alternatives work, lets's set
<TT>forceReadablePassword</TT> to 1 and
<TT>forceRotorEncryption</TT> to 0, and reimport. Note that
these are global variables that must be set
<span class="docEmphasis">before</span> the module is imported (or reloaded),
because they control the selection of alternative
<TT>def</TT> statements. Only one version of each kind of
function is ever made by the module:
</P>

<PRE>C:\...\PP2E\Internet\Cgi-Web\PyMailCgi&gt;<B>python</B>
&gt;&gt;&gt; <B>from secret import *</B>
&gt;&gt;&gt; <B>x = encode('abc$#&lt;&gt;&amp;+')</B>
&gt;&gt;&gt; <B>x</B>
'-98-99-100-37-36-61-63-39-44'

&gt;&gt;&gt; <B>y = decode(x)</B>
&gt;&gt;&gt; <B>y</B>
'abc$#&lt;&gt;&amp;+'</PRE>

<P class="docText">This really happens in two steps, though -- encryption and then
encoding (the top-level <TT>encode</TT> and
<TT>decode</TT> functions orchestrate the two steps).
Here's what the steps look like when run separately:
</P>

<PRE>&gt;&gt;&gt; <B>t = do_encode('abc$#&lt;&gt;&amp;+')</B>               # just our encryption
&gt;&gt;&gt; <B>t</B>
"bcd%$=?',"
&gt;&gt;&gt; <B>stringify(t)</B>                             # add our own encoding
'-98-99-100-37-36-61-63-39-44'

&gt;&gt;&gt; <B>unstringify(x)</B>                           # undo encoding
"bcd%$=?',"
&gt;&gt;&gt; <B>do_decode(unstringify(x))</B>                # undo both steps
'abc$#&lt;&gt;&amp;+'</PRE>

<P class="docText">This alternative encryption scheme merely adds 1 to the each
character's ASCII code value, and the encoder inserts the ASCII
code integers of the result. It's also possible to combine
<TT>rotor</TT> encryption and our custom encoding (set both
<TT>forceReadablePassword</TT> and
<TT>forceRotorEncryption</TT> to 1), but URL encoding
provided by <TT>urllib</TT> works just as well. Here are a
variety of schemes in action; <I>secret.py</I> is
edited and saved before each reload:
</P>

<PRE>&gt;&gt;&gt; <B>import secret</B>
&gt;&gt;&gt; <B>secret.encode('spam123')</B>          # default: rotor, no extra encoding
'* _\344\011pY'

&gt;&gt;&gt; <B>reload(secret)</B>                    # forcereadable=1, forcerotor=0
&lt;module 'secret' from 'secret.py'&gt;
&gt;&gt;&gt; <B>secret.encode('spam123')</B>
'-116-113-98-110-50-51-52'

&gt;&gt;&gt; <B>reload(secret)</B>                    # forcereadable=1, forcerotor=1
&lt;module 'secret' from 'secret.py'&gt;
&gt;&gt;&gt; <B>secret.encode('spam123')</B>
'-42-32-95-228-9-112-89'
&gt;&gt;&gt; <B>ord('Y')</B>                          # the last one is really a 'Y'
89

&gt;&gt;&gt; <B>reload(secret)</B>                    # back to default rotor, no stringify
&lt;module 'secret' from 'secret.pyc'&gt;
&gt;&gt;&gt; <B>import urllib</B>
&gt;&gt;&gt; <B>urllib.quote_plus(secret.encode('spam123'))</B>
'%2a+_%e4%09pY'
&gt;&gt;&gt; <B>0x2a</B>                              # the first is really 42, '*'
42
&gt;&gt;&gt; <B>chr(42)</B>
'*'</PRE>

<P class="docText">You can provide any kind of encryption and encoding logic you like in
a custom <I>secret.py,</I> as long as it adheres to the
expected protocol -- encoders and decoders must receive and return
a string. You can also alternate schemes by days of the week as done
here (but note that this can fail if your system is being used when
the clock turns over at midnight!), and so on. A few final pointers:
</P>

<A NAME="IXT-13-337662"></A><A NAME="IXT-13-337663"></A><A NAME="IXT-13-337664"></A><A NAME="IXT-13-337665"></A><DL class="docList">
<DT><I><span class="docPubcolor">Other Python encryption tools</span></I></DT>
<DD>
<P class="docList"><A NAME="IXT-13-337662"></A>
<A NAME="IXT-13-337663"></A>There are additional encryption tools that
come with Python or are available for Python on the Web; see
<A class="docLink" target="_blank" HREF="http://www.python.org/default.htm">http://www.python.org</A> and the
library manual for details. Some encryption schemes are considered
serious business and may be protected by law from export, but these
rules change over time.
</P>
</DD><DT><I><span class="docPubcolor">Secure sockets support</span></I></DT>
<DD>
<P class="docList"><A NAME="IXT-13-337664"></A>
<A NAME="IXT-13-337665"></A>As
mentioned, Python 1.6 (not yet out as I wrote this) will have
standard support for OpenSSL secure sockets in the Python
<TT>socket</TT> module. OpenSSL is an open source
implementation of the secure sockets protocol (you must fetch and
install it separately from Python -- see <A class="docLink" target="_blank" HREF="http://www.openssl.org/default.htm">http://www.openssl.org</A>). Where it can be
used, this will provide a better and less limiting solution for
securing information like passwords than the manual scheme
we've adopted here.
</P>

<P class="docList">For instance, secure sockets allow usernames and passwords to be
entered into and submitted from a single web page, thereby supporting
arbitrary mail readers. The best we can do without secure sockets is
to either avoid mixing unencrypted user and password values and
assume that some account data and encryptors live on the server (as
done here), or to have two distinct input pages or URLs (one for each
value). Neither scheme is as user-friendly as a secure sockets
approach. Most browsers already support SSL; to add it to Python on
your server, see the Python 1.6 (and beyond) library manual.
</P>
</DD>
</DL>

<P class="docText">Internet security is a much bigger topic than can be addressed fully
here, and we've really only scratched its surface. For
additional information on security issues, consult books geared
exclusively towards web programming techniques.<A NAME="IXTR3-365"></A> <A NAME="IXTR3-366"></A> <A NAME="IXTR3-367"></A> <A NAME="IXTR3-368"></A>
</P>

<P><table border="0" bgcolor="black" cellspacing="0" cellpadding="1" width="90%" align="center"><tr><td>
<table bgcolor="white" width="100%" border="0" cellspacing="0" cellpadding="6"><tr>
<td width="60" valign="top"><img src="FILES/tip_yellow.gif" width="50" height="54"></td>
<td valign="top">
<P class="docText"><A NAME="IXT-13-337666"></A> <A NAME="IXT-13-337667"></A>On my
server, the <I>secret.py</I> file will be changed over
time, in case snoopers watch the book's web site. Moreover, its
source code cannot be viewed with the <TT>getfile</TT> CGI
script coded in <A class="docLink" HREF="0596000855_python2-CHP-12.html#python2-CHP-12">Chapter 12</A>. That means that if you
run this system live, passwords in URLs and hidden form fields may
look very different than seen in this book. My password will have
changed by the time you read these words too, or else it would be
possible to know my password from this book alone!
</P>
</td>
</tr></table></td></tr></table></P>



<A NAME="python2-CHP-13-SECT-6.4"></A>
<H4 class="docSection2Title">13.6.4 Common Utilities Module</H4>

<P class="docText">The file <I>commonhtml.py</I>, shown in <A class="docLink" HREF="#python2-CHP-13-EX-14">Example 13-14</A>, is the Grand Central Station of this
application -- its code is used and reused by just about every
other file in the system. Most of it is self-explanatory, and
I've already said most of what I wanted to say about it
earlier, in conjunction with the CGI scripts that use it.
</P>

<P class="docText">I haven't talked about its <span class="docEmphasis">debugging</span>
support, though. Notice that this module assigns
<TT>sys.stderr</TT> to <TT>sys.stdout</TT>, in an
attempt to force the text of Python error messages to show up in the
client's browser (remember, uncaught exceptions print details
to <TT>sys.stderr</TT>). That works sometimes in PyMailCgi,
but not always -- the error text shows up in a web page only if a
<TT>page_header</TT> call has already printed a response
preamble. If you want to see all error messages, make sure you call
<TT>page_header</TT> (or print
<TT>Content-type:</TT> lines manually) before any other
processing. This module also defines functions that dump lots of raw
CGI environment information to the browser
(<TT>dumpstatepage</TT>), and that wrap calls to functions
that print status messages so their output isn't added to the
HTML stream (<TT>runsilent</TT>).
</P>

<P class="docText">I'll leave the discovery of any remaining magic in this code up
to you, the reader. You are hereby admonished to go forth and read,
refer, and reuse.
</P>


<H5 class="docExampleTitle"><A NAME="python2-CHP-13-EX-14"></A>Example 13-14. PP2E\Internet\Cgi-Web\PyMailCgi\commonhtml.py </H5>
<A NAME="IXTR3-369"></A><A NAME="IXTR3-370"></A><A NAME="IXTR3-371"></A><PRE>#!/usr/bin/python
#########################################################
# generate standard page header, list, and footer HTML;
# isolates html generation-related details in this file;
# text printed here goes over a socket to the client,
# to create parts of a new web page in the web browser;
# uses one print per line, instead of string blocks;
# uses urllib to escape parms in url links auto from a
# dict, but cgi.escape to put them in html hidden fields;
# some of the tools here are useful outside pymailcgi;
# could also return html generated here instead of 
# printing it, so it could be included in other pages;
# could also structure as a single cgi script that gets
# and tests a next action name as a hidden form field;
# caveat: this system works, but was largely written 
# during a 2-hour layover at the Chicago O'Hare airport:
# some components could probably use a bit of polishing;
# to run standalone on starship via a commandline, type
# "python commonhtml.py"; to run standalone via a remote
# web brower, rename file with .cgi and run fixcgi.py.
#########################################################

import cgi, urllib, string, sys
sys.stderr = sys.stdout           # show error messages in browser
from externs import mailconfig    # from a package somewhere on server

# my address root
urlroot = 'http://starship.python.net/~lutz/PyMailCgi'

def pageheader(app='PyMailCgi', color='#FFFFFF', kind='main', info=''):
    print 'Content-type: text/html\n'
    print '&lt;html&gt;&lt;head&gt;&lt;title&gt;%s: %s page (PP2E)&lt;/title&gt;&lt;/head&gt;' % (app, kind)
    print '&lt;body bgcolor="%s"&gt;&lt;h1&gt;%s %s&lt;/h1&gt;&lt;hr&gt;' % (color, app, (info or kind))

def pagefooter(root='pymailcgi.html'):
    print '&lt;/p&gt;&lt;hr&gt;&lt;a href="http://www.python.org"&gt;'
    print '&lt;img src="../PyErrata/PythonPoweredSmall.gif" '
    print 'align=left alt="[Python Logo]" border=0 hspace=15&gt;&lt;/a&gt;' 
    print '&lt;a href="%s"&gt;Back to root page&lt;/a&gt;' % root
    print '&lt;/body&gt;&lt;/html&gt;'

def formatlink(cgiurl, parmdict):
    """
    make "%url?key=val&amp;key=val" query link from a dictionary;
    escapes str(  ) of all key and val with %xx, changes ' ' to +
    note that url escapes are different from html (cgi.escape)
    """ 
    parmtext = urllib.urlencode(parmdict)           # calls urllib.quote_plus
    return '%s?%s' % (cgiurl, parmtext)             # urllib does all the work

def pagelistsimple(linklist):                       # show simple ordered list
    print '&lt;ol&gt;'
    for (text, cgiurl, parmdict) in linklist:
        link = formatlink(cgiurl, parmdict)
        text = cgi.escape(text)
        print '&lt;li&gt;&lt;a href="%s"&gt;\n    %s&lt;/a&gt;' % (link, text)
    print '&lt;/ol&gt;'
 
def pagelisttable(linklist):                        # show list in a table
    print '&lt;p&gt;&lt;table border&gt;'                       # escape text to be safe
    count = 1
    for (text, cgiurl, parmdict) in linklist:
        link = formatlink(cgiurl, parmdict)
        text = cgi.escape(text)
        print '&lt;tr&gt;&lt;th&gt;&lt;a href="%s"&gt;View&lt;/a&gt; %d&lt;td&gt;\n %s' % (link, count, text)
        count = count+1
    print '&lt;/table&gt;'

def listpage(linkslist, kind='selection list'):
    pageheader(kind=kind)
    pagelisttable(linkslist)         # [('text', 'cgiurl', {'parm':'value'})]
    pagefooter(  )

def messagearea(headers, text, extra=''):
    print '&lt;table border cellpadding=3&gt;'
    for hdr in ('From', 'To', 'Cc', 'Subject'):
        val = headers.get(hdr, '?')
        val = cgi.escape(val, quote=1)
        print '&lt;tr&gt;&lt;th align=right&gt;%s:' % hdr
        print '    &lt;td&gt;&lt;input type=text '
        print '    name=%s value="%s" %s size=60&gt;' % (hdr, val, extra)
    print '&lt;tr&gt;&lt;th align=right&gt;Text:'
    print '&lt;td&gt;&lt;textarea name=text cols=80 rows=10 %s&gt;' % extra
    print '%s\n&lt;/textarea&gt;&lt;/table&gt;' % (cgi.escape(text) or '?')   # if has &lt;/&gt;s

def viewpage(msgnum, headers, text, form):
    """
    on View + select (generated link click)
    very subtle thing: at this point, pswd was url encoded in the
    link, and then unencoded by cgi input parser; it's being embedded
    in html here, so we use cgi.escape; this usually sends nonprintable
    chars in the hidden field's html, but works on ie and ns anyhow:
    in url:  ?user=lutz&amp;mnum=3&amp;pswd=%8cg%c2P%1e%f0%5b%c5J%1c%f3&amp;...
    in html: &lt;input type=hidden name=pswd value="...nonprintables.."&gt;
    could urllib.quote the html field here too, but must urllib.unquote
    in next script (which precludes passing the inputs in a URL instead 
    of the form); can also fall back on numeric string fmt in secret.py
    """ 
    pageheader(kind='View')
    user, pswd, site = map(cgi.escape, getstandardpopfields(form))
    print '&lt;form method=post action="%s/onViewSubmit.cgi"&gt;' % urlroot
    print '&lt;input type=hidden name=mnum value="%s"&gt;' % msgnum
    print '&lt;input type=hidden name=user value="%s"&gt;' % user     # from page|url
    print '&lt;input type=hidden name=site value="%s"&gt;' % site     # for deletes
    print '&lt;input type=hidden name=pswd value="%s"&gt;' % pswd     # pswd encoded
    messagearea(headers, text, 'readonly')

    # onViewSubmit.quotetext needs date passed in page
    print '&lt;input type=hidden name=Date value="%s"&gt;' % headers.get('Date','?')
    print '&lt;table&gt;&lt;tr&gt;&lt;th align=right&gt;Action:'
    print '&lt;td&gt;&lt;select name=action&gt;'
    print '    &lt;option&gt;Reply&lt;option&gt;Forward&lt;option&gt;Delete&lt;/select&gt;'
    print '&lt;input type=submit value="Next"&gt;'
    print '&lt;/table&gt;&lt;/form&gt;'                      # no 'reset' needed here
    pagefooter(  )

def editpage(kind, headers={}, text=''):     
    # on Send, View+select+Reply, View+select+Fwd
    pageheader(kind=kind)
    print '&lt;form method=post action="%s/onSendSubmit.cgi"&gt;' % urlroot
    if mailconfig.mysignature:
        text = '\n%s\n%s' % (mailconfig.mysignature, text)
    messagearea(headers, text)
    print '&lt;input type=submit value="Send"&gt;'
    print '&lt;input type=reset  value="Reset"&gt;'
    print '&lt;/form&gt;'
    pagefooter(  )

def errorpage(message):
    pageheader(kind='Error')                        # or sys.exc_type/exc_value
    exc_type, exc_value = sys.exc_info(  )[:2]        # but safer,thread-specific
    print '&lt;h2&gt;Error Description&lt;/h2&gt;&lt;p&gt;', message  
    print '&lt;h2&gt;Python Exception&lt;/h2&gt;&lt;p&gt;',  cgi.escape(str(exc_type))
    print '&lt;h2&gt;Exception details&lt;/h2&gt;&lt;p&gt;', cgi.escape(str(exc_value))
    pagefooter(  )

def confirmationpage(kind):
    pageheader(kind='Confirmation')
    print '&lt;h2&gt;%s operation was successful&lt;/h2&gt;' % kind
    print '&lt;p&gt;Press the link below to return to the main page.&lt;/p&gt;'
    pagefooter(  )

def getfield(form, field, default=''):
    # emulate dictionary get method
    return (form.has_key(field) and form[field].value) or default

def getstandardpopfields(form):
    """
    fields can arrive missing or '' or with a real value
    hard-coded in a url; default to mailconfig settings
    """
    return (getfield(form, 'user', mailconfig.popusername),
            getfield(form, 'pswd', '?'),
            getfield(form, 'site', mailconfig.popservername))

def getstandardsmtpfields(form):
    return  getfield(form, 'site', mailconfig.smtpservername)

def runsilent(func, args):
    """
    run a function without writing stdout
    ex: suppress print's in imported tools
    else they go to the client/browser
    """
    class Silent:
        def write(self, line): pass 
    save_stdout = sys.stdout
    sys.stdout  = Silent(  )                         # send print to dummy object
    try:                                           # which has a write method
        result = apply(func, args)                 # try to return func result
    finally:                                       # but always restore stdout
        sys.stdout = save_stdout
    return result

def dumpstatepage(exhaustive=0):
    """
    for debugging: call me at top of a cgi to
    generate a new page with cgi state details 
    """
    if exhaustive:
        cgi.test(  )                       # show page with form, environ, etc.
    else:                                
        pageheader(kind='state dump')
        form = cgi.FieldStorage(  )        # show just form fields names/values
        cgi.print_form(form)
        pagefooter(  )
    sys.exit(  )
                              
def selftest(showastable=0):                        # make phony web page
    links = [                                       # [(text, url, {parms})]
        ('text1', urlroot + '/page1.cgi', {'a':1}),         
        ('text2', urlroot + '/page1.cgi', {'a':2, 'b':'3'}),
        ('text3', urlroot + '/page2.cgi', {'x':'a b', 'y':'a&lt;b&amp;c', 'z':'?'}),
        ('te&lt;&gt;4', urlroot + '/page2.cgi', {'&lt;x&gt;':'', 'y':'&lt;a&gt;', 'z':None})]
    pageheader(kind='View')
    if showastable:
        pagelisttable(links)
    else:
        pagelistsimple(links)
    pagefooter(  )

if __name__ == '__main__':                          # when run, not imported
    selftest(len(sys.argv) &gt; 1)                     # html goes to stdout

</PRE>




<a href="0596000855_"><img src="FILES/pixel.gif" width="1" height="1" border="0"></a><ul></ul>
</td>
</tr>
</table>
<td></td>
<table width="100%" border="0" cellspacing="0" cellpadding="0" bgcolor="#CCCCCC">
<td><font color="black" size=1>I l<font color="#FF0000">@</font>ve RuBoard</td>
<td valign="top" class="v2" align="right">
          <a href="0596000855_python2-CHP-13-SECT-5.html"><img src="FILES/previous.gif" width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a>
          <a href="0596000855_python2-CHP-13-SECT-7.html"><img src="FILES/next.gif" width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a>
</td></table>
</body></html>
