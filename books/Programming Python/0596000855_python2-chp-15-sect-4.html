<html><head>
<META http-equiv="Content-Type" content="text/html">
<!--SafClassName="docSection1Title"--><!--SafTocEntry="15.4 JPython ( Jython): Python for Java"-->
<link rel="STYLESHEET" type="text/css" href="FILES/style.css">
<link rel="STYLESHEET" type="text/css" href="FILES/docsafari.css">
</head>
<body>
<table width="100%" border="0" cellspacing="0" cellpadding="0" bgcolor="#CCCCCC">
<td><font color="black" size=1>I l<font color="#FF0000">@</font>ve RuBoard</td>
<td valign="top" class="v2" align="right">
	<a href="0596000855_python2-CHP-15-SECT-3.html"><img src="FILES/previous.gif" width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a>
	<a href="0596000855_python2-CHP-15-SECT-5.html"><img src="FILES/next.gif" width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a>
</td></table>
<br>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<tr>
<td valign="top"><A NAME="python2-CHP-15-SECT-4"></A>
<H3 class="docSection1Title">15.4 JPython (  Jython): Python for Java</H3>

<P class="docText"><A NAME="python2-IDXTERM-1650"></A>
<A NAME="python2-IDXTERM-1651"></A>
<A NAME="python2-IDXTERM-1652"></A> <A NAME="python2-IDXTERM-1653"></A>JPython (recently renamed
"Jython") is an entirely distinct implementation of the
Python programming language that allows programmers to use Python as
a scripting component in Java-based applications. In short, JPython
makes Python code look like Java, and consequently offers a variety
of technology options inherited from the Java world. With JPython,
Python code may be run as client-side applets in web browsers, as
server-side scripts, and in a variety of other roles. JPython is
distinct from other systems mentioned in this section in terms of its
scope: while it is based on the core Python language we've seen
in this book, it actually replaces the underlying implementation of
that language rather than augmenting it.<sup class="docFootnote"><A class="docLink" HREF="#">[2]</A></sup>
</P>
<blockquote><p class="docFootnote"><sup><A NAME="">[2]</A></sup> At this
writing, JPython is the second implementation of the Python language.
By contrast, the standard, original implementation of Python is
sometimes now referred to as "CPython," because it is
implemented in ANSI C. Among other things, the JPython implementation
is driving a clearer definition of the Python language itself,
independent of a particular implementation's effects. A new
Python implementation for Microsoft's C#/.NET environment is
also on the way (see later in this chapter) and may further drive a
definition of what it means to be Python.</p></blockquote>

<P class="docText">This section briefly explores JPython and highlights some of the
reasons you may or may not want to use it instead of the standard
Python implementation. Although JPython is primarily of interest to
programmers writing Java-based applications, it underscores
integration possibilities and language definition issues that merit
the attention of all Python users. Because JPython is Java-centric,
you need to know something about Java development to make the most
sense of JPython, and this book doesn't pretend to teach that
in the next few pages. For more details, interested readers should
consult other materials, including JPython documentation at
<A class="docLink" target="_blank" HREF="http://www.jython.org/default.htm">http://www.jython.org</A>.
</P>

<P><table border="0" bgcolor="black" cellspacing="0" cellpadding="1" width="90%" align="center"><tr><td>
<table bgcolor="white" width="100%" border="0" cellspacing="0" cellpadding="6"><tr>
<td width="60" valign="top"><img src="FILES/tip_yellow.gif" width="50" height="54"></td>
<td valign="top">
<P class="docText">The JPython port is now called "Jython." Although you are
likely to still see it called by its original JPython name on the Net
(and in this book) for some time, the new Jython title will become
more common as time goes by.
</P>
</td>
</tr></table></td></tr></table></P>

<A NAME="python2-CHP-15-SECT-4.1"></A>
<H4 class="docSection2Title">15.4.1 A Quick Introduction to JPython</H4>

<P class="docText"><A NAME="python2-IDXTERM-1654"></A>Functionally
speaking, JPython is a collection of Java classes that run Python
code. It consists of a Python compiler, written in Java, that
translates Python scripts to Java bytecodes so they can be executed
by a <span class="docEmphasis">Java virtual machine</span>  -- the runtime
component that executes Java programs and is used by major web
browsers. Moreover, JPython automatically exposes all Java class
libraries for use in Python scripts. In a nutshell, here's what
comes with the JPython system:<A NAME="IXT-15-337798"></A> <A NAME="IXT-15-337799"></A>
</P>

<A NAME="IXT-15-337800"></A><A NAME="IXT-15-337801"></A><A NAME="IXT-15-337802"></A><A NAME="IXT-15-337803"></A><A NAME="IXT-15-337804"></A><A NAME="IXT-15-337805"></A><A NAME="IXT-15-337806"></A><A NAME="IXT-15-337807"></A><A NAME="IXT-15-337808"></A><A NAME="IXT-15-337809"></A><A NAME="IXT-15-337810"></A><A NAME="IXT-15-337811"></A><A NAME="IXT-15-337812"></A><A NAME="IXT-15-337813"></A><A NAME="IXT-15-337814"></A><A NAME="IXT-15-337815"></A><A NAME="IXT-15-337816"></A><A NAME="IXT-15-337817"></A><DL class="docList">
<DT><I><span class="docPubcolor">Python-to-Java-bytecode compiler</span></I></DT>
<DD>
<P class="docList"><A NAME="IXT-15-337800"></A>
<A NAME="IXT-15-337801"></A>JPython always compiles Python source
code into Java bytecode and passes it to a Java virtual machine (JVM)
runtime engine to be executed. A command-line compiler program,
<TT>jpythonc</TT>, is also able to translate Python source
code files into Java <I>.class </I>and
<I>.jar</I> files, which can then be used as Java
applets, beans, servlets, and so on. To the JVM, Python code run
through JPython looks the same as Java code. Besides making Python
code work on a JVM, JPython code also inherits all aspects of the
Java runtime system, including Java's garbage collection and
security models. <TT>jpythonc</TT> also imposes Java source
file class rules.
</P>
</DD><DT><I><span class="docPubcolor">Access to Java class libraries (extending )</span></I></DT>
<DD>
<P class="docList"><A NAME="IXT-15-337802"></A>
<A NAME="IXT-15-337803"></A>JPython uses Java's
<span class="docEmphasis">reflection API</span> (runtime type information) to
expose all available Java class libraries to Python scripts. That is,
Python programs written for the JPython system can call out to any
resident Java class automatically simply by importing it. The
Python-to-Java interface is completely automatic and remarkably
seamless -- Java class libraries appear as though they are coded
in Python. Import statements in JPython scripts may refer to either
JPython modules or Java class libraries. For instance, when a JPython
script imports <TT>java.awt</TT>, it gains access to all
the tools available in the <TT>awt</TT> library. JPython
internally creates a "dummy" Python module object to
serve as an interface to <TT>awt</TT> at import time. This
dummy module consists of hooks for dispatching calls from JPython
code to Java class methods and automatically converting datatypes
between Java and Python representations as needed. To JPython
scripts, Java class libraries look and feel exactly like normal
Python modules (albeit with interfaces defined by the Java world).
</P>
</DD><DT><I><span class="docPubcolor">Unified object model</span></I></DT>
<DD>
<P class="docList"><A NAME="IXT-15-337804"></A>
<A NAME="IXT-15-337805"></A>JPython
objects are actually Java objects internally. In fact, JPython
implements Python types as instances of a Java
<TT>PyObject</TT> class. By contrast, C Python classes and
types are still distinct in the current release. For instance, in
JPython, the number 123 is an instance of the
<TT>PyInteger</TT> Java class, and you can specify things
like <TT>[].__class__</TT> since all objects are class
instances. That makes data mapping between languages simple: Java can
process Python objects automatically, because they are Java objects.
JPython automatically converts types between languages according to a
standard type map as needed to call out to Java libraries, and
selects among overloaded Java method signatures.
</P>
</DD><DT><I><span class="docPubcolor">API for running Python from Java (embedding )</span></I></DT>
<DD>
<P class="docList"><A NAME="IXT-15-337806"></A>
<A NAME="IXT-15-337807"></A>
<A NAME="IXT-15-337808"></A>JPython also provides interfaces that
allow Java programs to execute JPython code. As for embedding in C
and C++, this allows Java applications to be customized by bits of
dynamically written JPython code. For instance, JPython ships with a
Java <TT>PythonInterpreter</TT> class, which allows Java
programs to create objects that function as Python namespaces for
running Python code. Each <TT>PythonInterpreter</TT> object
is roughly a Python module, with methods such as
<TT>exec(</TT>a string of Python code<TT>)</TT>,
<TT>execfile(</TT>a Python filename<TT>)</TT>,
and <TT>get</TT> and <TT>set</TT> methods for
assigning Python global variables. Because Python objects are really
instances of a Java <TT>PyObject</TT> class, an enclosing
Java layer can access and process data created by Python code
naturally.<A NAME="IXT-15-337809"></A>
<A NAME="IXT-15-337810"></A>
<A NAME="IXT-15-337811"></A>
</P>
</DD><DT><I><span class="docPubcolor">Interactive Python command line</span></I></DT>
<DD>
<P class="docList"><A NAME="IXT-15-337812"></A>
<A NAME="IXT-15-337813"></A> <A NAME="IXT-15-337814"></A>Like the standard Python implementation,
JPython comes with an interactive command line that runs code
immediately after it is typed. JPython's
<TT>jpython</TT> program is equivalent to the
<TT>python</TT> executable we've been using in this
book; without arguments, it starts an interactive session. Among
other things, this allows JPython programmers to import and test
class components actually written in Java. This ability alone is
compelling enough to interest many Java programmers.
</P>
</DD><DT><I><span class="docPubcolor">Interface automations</span></I></DT>
<DD>
<P class="docList"><A NAME="IXT-15-337815"></A>
<A NAME="IXT-15-337816"></A>
<A NAME="IXT-15-337817"></A>Java libraries are somewhat easier
to use in JPython code than in Java. That's because JPython
automates some of the coding steps Java implies. For instance,
<span class="docEmphasis">callback handlers</span> for Java GUI libraries may be
simple Python functions, even though Java coders need to provide
methods in fully specified classes (Java does not have first-class
function objects). JPython also makes Java class <span class="docEmphasis">data
members</span> accessible as both Python attribute names
(<TT><I>object.name</I></TT>) and object constructor
keyword arguments (<TT><I>name=value</I></TT>); such
Python syntax is translated into calls to <TT>getName</TT>
and <TT>setName</TT> accessor methods in Java classes.
We'll see these automation tricks in action in the following
examples. You don't have to use any of these (and they may
confuse Java programmers at first glance), but they further simplify
coding in JPython, and give Java class libraries a more Python-like
flavor.
</P>
</DD>
</DL>

<P class="docText"><A NAME="IXT-15-337818"></A>
<A NAME="IXT-15-337819"></A>The net effect of all this is that JPython
allows us to write Python programs that can run on any Java-aware
machine -- in particular, in the context of most web browsers.
More importantly, because Python programs are translated into Java
bytecodes, JPython provides an incredibly seamless and natural
integration between the two languages. Both walk and talk in terms of
the Java model, so calls across language boundaries are trivial. With
JPython's approach, it's even possible to subclass a Java
class in Python and vice versa.
</P>

<P class="docText"><A NAME="IXT-15-337820"></A>
<A NAME="IXT-15-337821"></A>So why go to all this trouble to mix
Python into Java environments? The most obvious answer is that
JPython makes Java components easier to use: JPython scripts are
typically a fraction of the size of their Java equivalents, and much
less complex. More generally, the answer is really the same as it is
for C and C++ environments: Python, as an easy-to-use,
object-oriented scripting language, naturally complements the Java
programming language.
</P>

<P class="docText"><A NAME="IXT-15-337822"></A>
<A NAME="IXT-15-337823"></A>
<A NAME="IXT-15-337824"></A>By now, it is clear to most
people that Java is too complex to serve as a scripting or
rapid-development tool. But this is exactly where Python excels; by
adding Python to the mix with JPython, we add a scripting component
to Java systems, exactly as we do when integrating Python with C or
C++. For instance, we can use JPython to quickly prototype Java
systems, test Java classes interactively, and open up Java systems
for end-user customization. In general, adding Python to Java
development can significantly boost programmer productivity, just as
it does for C and C++ systems.<A NAME="IXTR3-423"></A>
</P>

<P><A NAME="python2-CHP-15-SIDEBAR-1"></A><TABLE CELLSPACING="0" WIDTH="90%" BORDER="1"><TR><TD>
<H2 class="docSidebarTitle">JPython Versus the Python C API</H2>

<P class="docText"><A NAME="IXT-15-337825"></A>
<A NAME="IXT-15-337826"></A>
<A NAME="IXT-15-337827"></A>Functionally, JPython is primarily an
integration system: it allows us to mix Python with Java components.
We also study ways to integrate Python with C and C++ components in
the next part of this book. It's worth noting that we need
different techniques to integrate Python with Java (such as the
JPython compiler), because Java is a somewhat closed system: it
prefers an all-Java mix. The C and C++ integration tools are
generally less restrictive in terms of language assumptions, and any
C-compatible language components will do. Java's strictness is
partly due to its security goals, but the net effect is to foster
integration techniques that are specific to Java alone.
</P>

<P class="docText">On the other hand, because Java exposes runtime type information
through its reflection API, JPython can largely automate the
conversions and dispatching needed to access Java components from
Python scripts; Python code simply imports and calls Java components.
When mixing Python with C or C++, we must provide a
"glue" code layer that integrates the two languages
explicitly. Some of this can be automated (with the SWIG system
we'll meet later in this text). No glue code is required in
JPython, however, because JPython's (and Java's)
developers have done all the linkage work already, in a generic
fashion. It is also possible to mix in C/C++ components with Java via
its native call interface ( JNI), but this can be cumbersome and may
cancel out Java's reported portability and security
benefits.<A NAME="IXT-15-337828"></A>
<A NAME="IXT-15-337829"></A>
</P>
</TD></TR></TABLE></P>


<A NAME="python2-CHP-15-SECT-4.2"></A>
<H4 class="docSection2Title">15.4.2 A Simple JPython Example</H4>

<P class="docText"><A NAME="IXT-15-337830"></A>
<A NAME="IXT-15-337831"></A>Once
a Python program is compiled with JPython, it is all Java: the
program is translated to Java bytecodes, it uses Java classes to do
its work, and there is no Python left except for the original source
code. Because the compiler tool itself is also written in Java,
JPython is sometimes called "100% pure Java." That label
may be more profound to marketeers than programmers, though, because
JPython scripts are still written using standard Python syntax. For
instance, <A class="docLink" HREF="#python2-CHP-15-EX-4">Example 15-4</A> is a legal JPython program,
derived from an example originally written by Guido van Rossum.
</P>


<H5 class="docExampleTitle"><A NAME="python2-CHP-15-EX-4"></A>Example 15-4. PP2E\Internet\Other\jpython.py </H5>
<PRE>############################################
# implement a simple calculator in JPython;
# evaluation runs a full expression all at 
# once using the Python eval(  ) built-in-- 
# JPython's compiler is present at run-time
############################################
 
from java import awt                   # get access to Java class libraries
from pawt import swing                 # they look like Python modules here 

labels = ['0', '1', '2', '+',          # labels for calculator buttons
          '3', '4', '5', '-',          # will be used for a 4x4 grid
          '6', '7', '8', '*',
          '9', '.', '=', '/' ]

keys = swing.JPanel(awt.GridLayout(4, 4))     # do Java class library magic
display = swing.JTextField(  )                  # Python data auto-mapped to Java

def push(event):                              # callback for regular keys
    display.replaceSelection(event.actionCommand)

def enter(event):                             # callback for the '=' key
    display.text = str(eval(display.text))    # use Python eval(  ) to run expr
    display.selectAll(  )

for label in labels:                          # build up button widget grid
    key = swing.JButton(label)                # on press, invoke Python funcs
    if label == '=':
        key.actionPerformed = enter
    else:
        key.actionPerformed = push
    keys.add(key)

panel = swing.JPanel(awt.BorderLayout(  ))      # make a swing panel
panel.add("North", display)                   # text plus key grid in middle
panel.add("Center", keys)
swing.test(panel)                             # start in a GUI viewer</PRE>


<P class="docText">The first thing you should notice is that this is genuine Python
code -- JPython scripts use the same core language that
we've been using all along in this book. That's good
news, both because Python is such an easy language to use and because
you don't need to learn a new, proprietary scripting language
to use JPython. It also means that all of Python's high-level
language syntax and tools are available. For example, in this script,
the Python <TT>eval</TT> built-in function is used to parse
and evaluate constructed expressions all at once, saving us from
having to write an expression evaluator from scratch.
</P>


<A NAME="python2-CHP-15-SECT-4.3"></A>
<H4 class="docSection2Title">15.4.3 Interface Automation Tricks</H4>

<P class="docText"><A NAME="python2-IDXTERM-1690"></A> <A NAME="python2-IDXTERM-1691"></A> <A NAME="python2-IDXTERM-1692"></A>The
previous calculator example also illustrates two interface
automations performed by JPython: function callback and attribute
mappings. Java programmers may have already noticed that this example
doesn't use classes. Like standard Python and unlike Java,
JPython supports but does not impose OOP. Simple Python functions
work fine as <span class="docEmphasis">callback handlers</span>. In <A class="docLink" HREF="#python2-CHP-15-EX-4">Example 15-4</A>, assigning
<TT>key.actionPerformed</TT> to a Python function object
has the same effect as registering an instance of a class that
defines a callback handler method:
</P>

<PRE>def push(event):
    ...
key = swing.JButton(label)
key.actionPerformed = push</PRE>

<P class="docText">This is noticeably simpler than the more Java-like:</P>

<PRE>class handler(awt.event.ActionListener):
    def actionPerformed(self, event):
        ...
key = swing.JButton(label)
key.addActionListener(handler(  ))</PRE>

<P class="docText">JPython automatically maps Python functions to the Java class method
callback model. Java programmers may now be wondering why we can
assign to something named <TT>key.actionPerformed</TT> in
the first place. JPython's second magic feat is to make Java
data members look like simple <span class="docEmphasis">object attributes</span>
in Python code. In abstract terms, JPython code of the form:
</P>

<PRE>X = Object(argument)
X.property = value + X.property</PRE>

<P class="docText">is equivalent to the more traditional and complex Java style:</P>

<PRE>X = Object(argument)
X.setProperty(value + X.getProperty(  ))</PRE>

<P class="docText">That is, JPython automatically maps attribute assignments and
references to Java accessor method calls by inspecting Java class
signatures (and possibly Java BeanInfo files if used). Moreover,
properties can be assigned with <span class="docEmphasis">keyword
arguments</span> in object constructor calls, such that:
</P>

<PRE>X = Object(argument, property=value)</PRE>

<P class="docText">is equivalent to both this more traditional form:</P>

<PRE>X = Object(argument)
X.setProperty(value)</PRE>

<P class="docText">as well as the following, which relies on attribute name mapping:</P>

<PRE>X = Object(argument)
X.property = value</PRE>

<P class="docText">We can combine both callback and property automation for an even
simpler version of the callback code
snippet:<A NAME="IXT-15-337832"></A>
</P>

<PRE>def push(event):
    ...
key = swing.JButton(label, actionPerformed=push)</PRE>

<P class="docText">You don't need to use these automation tricks, but again, they
make JPython scripts simpler, and that's most of the point
behind mixing Python with Java.<A NAME="IXTR3-424"></A> <A NAME="IXTR3-425"></A>
</P>


<A NAME="python2-CHP-15-SECT-4.4"></A>
<H4 class="docSection2Title">15.4.4 Writing Java Applets in JPython</H4>

<P class="docText"><A NAME="IXT-15-337833"></A>
<A NAME="IXT-15-337834"></A>I would be remiss if I didn't
include a brief example of JPython code that more directly
masquerades as a Java <span class="docEmphasis">applet</span>: code that lives on
a server machine but is downloaded to and run on the client machine
when its Internet address is referenced. Most of the magic behind
this is subclassing the appropriate Java class in a JPython script,
demonstrated in <A class="docLink" HREF="#python2-CHP-15-EX-5">Example 15-5</A>.
</P>


<H5 class="docExampleTitle"><A NAME="python2-CHP-15-EX-5"></A>Example 15-5. PP2E\Internet\Other\jpython-applet.py </H5>
<PRE>#######################################
# a simple java applet coded in Python
#######################################

from java.applet import Applet                            # get java superclass

class Hello(Applet):
    def paint(self, gc):                                  # on paint callback
        gc.drawString("Hello applet world", 20, 30)       # draw text message

if __name__ == '__main__':                                # if run standalone
    import pawt                                           # get java awt lib
    pawt.test(Hello(  ))                                    # run under awt loop</PRE>


<P class="docText">The Python class in this code inherits all the necessary applet
protocol from the standard Java <TT>Applet</TT> superclass,
so there is not much new to see here. Under JPython, Python classes
can always subclass Java classes, because Python objects really are
Java objects when compiled and run. The Python-coded
<TT>paint</TT> method in this script will be automatically
run from the Java AWT event loop as needed; it simply uses the
passed-in <TT>gc</TT> user-interface handle object to draw
a text message.
</P>

<P class="docText">If we use JPython's <TT>jpythonc</TT> command-line
tool to compile this into a Java <I>.class</I> file and
properly store that file on a web server, it can then be used exactly
like applets written in Java. Because most web browsers include a
JVM, this means that such Python scripts may be used as client-side
programs that create sophisticated user-interface devices within the
browser, and so on.
</P>


<A NAME="python2-CHP-15-SECT-4.5"></A>
<H4 class="docSection2Title">15.4.5 JPython Trade-offs</H4>

<P class="docText">Depending on your background, though, the somewhat less good news
about JPython is that even though the calculator and applet scripts
discussed here are straight Python code, the libraries they use are
different than what we've seen so far. In fact, the library
calls employed are radically different. The calculator, for example,
relies primarily on imported Java class libraries, not standard
Python libraries. You really need to understand Java's
<TT>awt</TT> and <TT>swing</TT> libraries to make
sense of its code, and this <span class="docEmphasis">library skew</span> between
language implementations becomes more acute as programs grow larger.
The applet example is even more Java-bound: it depends both on Java
user-interface libraries and Java applet protocols.
</P>

<P class="docText"><A NAME="IXT-15-337835"></A>
<A NAME="IXT-15-337836"></A>
<A NAME="IXT-15-337837"></A>
<A NAME="IXT-15-337838"></A>If you are already familiar with Java
libraries, this isn't an issue at all, of course. But because
most of the work performed by realistic programs is done by using
libraries, the fact that most JPython code relies on very different
libraries makes compatibility with standard Python less potent than
it may seem at first glance. To put that more strongly, apart from
very trivial core language examples, many JPython programs
won't run on the standard Python interpreter, and many standard
Python programs won't work under JPython.
</P>

<P class="docText"><A NAME="python2-IDXTERM-1702"></A>Generally, JPython presents a number
of trade-offs, partly due to its relative immaturity as of this
writing. I want to point out up front that JPython is indeed an
excellent Java scripting tool -- arguably the best one available,
and most of its trade-offs are probably of little or no concern to
Java developers. For instance, if you are coming to JPython from the
Java world, the fact that Java libraries are at the heart of JPython
scripts may be more asset than downside. But if you are presented
with a choice between the standard and Java-based Python language
implementations, some of JPython's implications are worth
knowing about:
</P>

<A NAME="IXT-15-337839"></A><A NAME="IXT-15-337840"></A><A NAME="IXT-15-337841"></A><A NAME="IXT-15-337842"></A><A NAME="IXT-15-337843"></A><A NAME="IXT-15-337844"></A><A NAME="IXT-15-337845"></A><A NAME="IXT-15-337846"></A><DL class="docList">
<DT><I><span class="docPubcolor">JPython is not yet fully compatible with the standard Python language</span></I></DT>
<DD>
<P class="docList"><A NAME="IXT-15-337839"></A>
<A NAME="IXT-15-337840"></A>At this writing, JPython is not yet
totally compatible with the standard Python language, as defined by
the original C implementation. In subtle ways, the core Python
language itself works differently in JPython. For example, until very
recently, assigning file-like objects to the standard input
<TT>sys.stdin</TT> failed, and exceptions were still
strings, not class objects. The list of incompatibilities (viewable
at <A class="docLink" target="_blank" HREF="http://www.jython.org/default.htm">http://www.jython.org</A>) will
likely shrink over time, but will probably never go away completely.
Moreover, new language features are likely to show up later in
JPython than in the standard C-based implementation.
</P>
</DD><DT><I><span class="docPubcolor">JPython requires programmers to learn Java development too</span></I></DT>
<DD>
<P class="docList">Language syntax is only one aspect of programming. The library skew
mentioned previously is just one example of JPython's
dependence on the Java system. Not only do you need to learn Java
libraries to get real work done in JPython, but you also must come to
grips with the Java programming environment in general. Many standard
Python libraries have been ported to JPython, and others are being
adopted regularly. But major Python tools such as Tkinter GUIs may
show up late or never in JPython (and instead are replaced with Java
tools).<sup class="docFootnote"><A class="docLink" HREF="#">[3]</A></sup> In addition, many core
Python library features cannot be supported in JPython, because they
would violate Java's security constraints. For example, the
<TT>os.system</TT> call for running shell commands may
never become available in JPython.
</P> <blockquote><p class="docFootnote"><sup><A NAME="">[3]</A></sup> But see the note at the end of the later
section on Grail; an early port of Tkinter for JPython is already
available on the Net.</p></blockquote> 
</DD><DT><I><span class="docPubcolor">JPython applies only where a JVM is installed or shipped</span></I></DT>
<DD>
<P class="docList"><A NAME="IXT-15-337841"></A>You
need the Java runtime to run JPython code. This may sound like a
non-issue given the pervasiveness of the Internet, but I have very
recently worked in more than one company for which delivering
applications to be run on JVMs was not an option. Simply put, there
was no JVM to be found at the customer's site. In such
scenarios, JPython is either not an option, or will require you to
ship a JVM with your application just to run your compiled JPython
code. Shipping the standard Python system with your products is
completely free; shipping a JVM may require licensing and fees. This
may become less of a concern as robust open source JVMs appear. But
if you wish to use JPython today and can't be sure that your
clients will be able to run your systems in Java-aware browsers (or
other JVM components), you should consider the potential costs of
shipping a Java runtime system with your products.<sup class="docFootnote"><A class="docLink" HREF="#">[4]</A></sup>
</P> <blockquote><p class="docFootnote"><sup><A NAME="">[4]</A></sup> Be
sure you can get a JVM to develop those products too! Installing
JPython on Windows 98 while writing this book proved painful, not
because of JPython, but because I also had to come to grips with Java
commands to run during installation, and track down and install a JVM
other than the one provided by Microsoft. Depending on your platform,
you may be faced with JPython's Java-dependence even before you
type your first line of code.</p></blockquote> 
</DD><DT><I><span class="docPubcolor">JPython doesn't support Python extension modules written in C or C++</span></I></DT>
<DD>
<P class="docList"><A NAME="IXT-15-337842"></A>
<A NAME="IXT-15-337843"></A>At
present, no C or C++ extension modules written to work with the C
Python implementation will work with JPython. This is a major
impediment to deploying JPython outside the scope of applications run
in a browser. To date, the half-million-strong Python user community
has developed thousands of extensions written for C Python, and these
constitute much of the substance of the Python development world.
JPython's current alternative is to instead expose Java class
libraries and ask programmers to write new extensions in Java. But
this dismisses a vast library of prior and future Python art. In
principle, C extensions could be supported by Java's native
call interface, but it's complex, has not been done, and can
negate Java portability and security.
</P>
</DD><DT><I><span class="docPubcolor">JPython is noticeably slower than C Python</span></I></DT>
<DD>
<P class="docList"><A NAME="IXT-15-337844"></A>
<A NAME="IXT-15-337845"></A>Today, Python code generally runs
slower under the JPython implementation. How much slower depends on
what you test, which JVM you use to run your test, whether a
just-in-time ( JIT) compiler is available, and which tester you cite.
Posted benchmarks have run the gamut from 1.7 times slower than C
Python, to 10 times slower, and up to 100 times slower. Regardless of
the exact number, the extra layer of logic JPython requires to map
Python to the Java execution model adds speed overheads to an already
slow JVM and makes it unlikely that JPython will ever be as fast as
the C Python implementation. Given that C Python is already slower
than compiled languages like C, the additional slowness of JPython
makes it less useful outside the realm of Java scripting.
Furthermore, the <TT>Swing</TT> GUI library used by JPython
scripts is powerful, but generally considered to be the slowest and
largest of all Python GUI options. Given that Python's Tkinter
library is a portable and standard GUI solution, Java's
proprietary user-interface tools by themselves are probably not
reason enough to use the JPython implementation.
</P>
</DD><DT><I><span class="docPubcolor">JPython is less robust than C Python</span></I></DT>
<DD>
<P class="docList">At this writing, JPython is substantially more buggy than the
standard C implementation of the language. This is certainly due to
its younger age and smaller user base and varies from JVM to JVM, but
you are more likely to hit snags in JPython. In contrast, C Python
has been amazingly bug-free since its introduction in 1990.
</P>
</DD><DT><I><span class="docPubcolor">JPython may be less portable than C Python</span></I></DT>
<DD>
<P class="docList"><A NAME="IXT-15-337846"></A>It's
also worth noting that as of this writing, the core Python language
is far more portable than Java (despite marketing statements to the
contrary). Because of that, deploying standard Python code with the
Java-based JPython implementation may actually
<span class="docEmphasis">lessen</span> its portability. Naturally, this depends
on the set of extensions you use, but standard Python runs today on
everything from handheld PDAs and PCs to Cray supercomputers and IBM
mainframes.
</P>
</DD>
</DL>

<P class="docText"><A NAME="IXT-15-337847"></A>
<A NAME="IXT-15-337848"></A>Some incompatibilities between JPython
and standard Python can be very subtle. For instance, JPython
inherits all of the Java runtime engine's behavior, including
Java security constraints and garbage collection. Java garbage
collection is not based on standard Python's reference count
scheme, and therefore can automatically collect cyclic
objects.<sup class="docFootnote"><A class="docLink" HREF="#">[5]</A></sup> It also means that some
common Python programming idioms won't work. For example,
it's typical in Python to code file-processing loops in this
form:
</P>
<blockquote><p class="docFootnote"><sup><A NAME="">[5]</A></sup> But Python 2.0's garbage collector can
now collect cyclic objects too. See the 2.0 release notes and <A class="docLink" HREF="0596000855_python2-APP-A.html#python2-APP-A">Appendix A</A>.</p></blockquote>

<PRE>for filename in bigfilenamelist:
    text = open(filename).read(  )
    dostuffwith(text)  </PRE>

<P class="docText">That works because files are automatically closed when
garbage-collected in standard Python, and we can be sure that the
file object returned by the <TT>open</TT> call will be
immediately garbage collected (it's a temporary, so there are
no more references as soon as we call <TT>read</TT>). It
won't work in JPython, though, because we can't be sure
when the temporary file object will be reclaimed. To avoid running
out of file descriptors, we usually need to code this differently for
JPython:
</P>

<PRE>for filename in bigfilenamelist:
    file = open(filename)
    text = file.read(  )
    dostuffwith(text)
    file.close(  )  </PRE>

<P class="docText">You may face a similar implementation mismatch if you assume that
output files are immediately closed:
<TT>open(name,'w').write(bytes)</TT> collects and closes
the temporary file object and hence flushes the bytes out to the file
under the standard C implementation of Python only, while JPython
instead collects the file object at some arbitrary time in the
future. In addition to such file-closing concerns, Python
<TT>__del__</TT> class destructors are never called in
JPython, due to complications associated with object
termination.<A NAME="IXTR3-426"></A>
</P>


<A NAME="python2-CHP-15-SECT-4.6"></A>
<H4 class="docSection2Title">15.4.6 Picking Your Python</H4>

<P class="docText"><A NAME="IXT-15-337849"></A>Because of concerns such as those just
mentioned, the JPython implementation of the Python language is
probably best used only in contexts where Java integration or web
browser interoperability are crucial design concerns. You should
always be the judge, of course, but the standard C implementation
seems better suited to most other Python applications. Still, that
leaves a very substantial domain to JPython -- almost all Java
systems and programmers can benefit from adding JPython to their tool
sets.
</P>

<P class="docText"><A NAME="IXT-15-337850"></A>JPython allows programmers to write
programs that use Java class libraries in a fraction of the code and
complexity required by Java-coded equivalents. Hence, JPython excels
as an extension language for Java-based systems, especially those
that will run in the context of web browsers. Because Java is a
standard component of most web browsers, JPython scripts will often
run automatically without extra install steps on client machines.
Furthermore, even Java-coded applications that have nothing to do
with the Web can benefit from JPython's ease of use; its
seamless integration with Java class libraries makes JPython simply
the best Java scripting and testing tool available today.
</P>

<P class="docText">For most other applications, though, the standard Python
implementation, possibly integrated with C and C++ components, is
probably a better design choice. The resulting system will likely run
faster, cost less to ship, have access to all Python extension
modules, be more robust and portable, and be more easily maintained
by people familiar with standard Python.
</P>

<P class="docText">On the other hand, I want to point out again that the trade-offs
listed here are mostly written from the Python perspective; if you
are a Java developer looking for a scripting tool for Java-based
systems, many of these detriments may be of minor concern. And to be
fair, some of JPython's problems may be addressed in future
releases; for instance, its speed will probably improve over time.
Yet even as it exists today, JPython clearly makes an ideal
extension-language solution for Java-based applications, and offers a
much more complete Java scripting solution than those currently
available for other scripting languages.<sup class="docFootnote"><A class="docLink" HREF="#">[6]</A></sup>
</P>
<blockquote><p class="docFootnote"><sup><A NAME="">[6]</A></sup> Other
scripting languages have addressed Java integration by reimplementing
a Java virtual machine in the underlying scripting language or by
integrating their original C implementations with Java using the Java
native call interface. Neither approach is anywhere near as seamless
and powerful as generating real Java bytecode.</p></blockquote>

<P class="docText">For more details, see the JPython package included on this
book's CD (see <A class="docLink" target="_blank" HREF="http://examples.oreilly.com/python2">http://examples.oreilly.com/python2</A>), and consult the JPython home page, currently
maintained at <A class="docLink" target="_blank" HREF="http://www.jython.org/default.htm">http://www.jython.org</A>. At least one rumor
has leaked concerning an upcoming JPython book as well, so check
<A class="docLink" target="_blank" HREF="http://www.python.org/default.htm">http://www.python.org</A> for
developments on this front.<A NAME="IXTR3-427"></A> See also the sidebar later in this
chapter about the new Python implementation for the C#/.NET
environment on Windows. It seems likely that there will be three
Pythons to choose from very soon (not just two), and perhaps more in
the future. All will likely implement the same core Python language
we've used in this text, but may emphasize alternative
integration schemes, application domains, development environments,
and so on.
</P>



<a href="0596000855_"><img src="FILES/pixel.gif" width="1" height="1" border="0"></a><ul></ul>
</td>
</tr>
</table>
<td></td>
<table width="100%" border="0" cellspacing="0" cellpadding="0" bgcolor="#CCCCCC">
<td><font color="black" size=1>I l<font color="#FF0000">@</font>ve RuBoard</td>
<td valign="top" class="v2" align="right">
          <a href="0596000855_python2-CHP-15-SECT-3.html"><img src="FILES/previous.gif" width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a>
          <a href="0596000855_python2-CHP-15-SECT-5.html"><img src="FILES/next.gif" width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a>
</td></table>
</body></html>
