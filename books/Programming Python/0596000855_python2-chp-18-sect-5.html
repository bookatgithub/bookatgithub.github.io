<html><head>
<META http-equiv="Content-Type" content="text/html">
<!--SafClassName="docSection1Title"--><!--SafTocEntry="18.5 Parser Generators"-->
<link rel="STYLESHEET" type="text/css" href="FILES/style.css">
<link rel="STYLESHEET" type="text/css" href="FILES/docsafari.css">
</head>
<body>
<table width="100%" border="0" cellspacing="0" cellpadding="0" bgcolor="#CCCCCC">
<td><font color="black" size=1>I l<font color="#FF0000">@</font>ve RuBoard</td>
<td valign="top" class="v2" align="right">
	<a href="0596000855_python2-CHP-18-SECT-4.html"><img src="FILES/previous.gif" width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a>
	<a href="0596000855_python2-CHP-18-SECT-6.html"><img src="FILES/next.gif" width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a>
</td></table>
<br>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<tr>
<td valign="top"><A NAME="python2-CHP-18-SECT-5"></A>
<H3 class="docSection1Title">18.5 Parser Generators</H3>

<P class="docText"><A NAME="python2-IDXTERM-2155"></A> <A NAME="python2-IDXTERM-2156"></A>If you have any background in
parsing theory, you may know that neither regular expressions nor
string splitting is powerful enough to handle more complex language
grammars (roughly, they don't have the "memory"
required by true grammars). For more sophisticated language analysis
tasks, we sometimes need a full-blown parser. Since Python is built
for integrating C tools, we can write integrations to traditional
parser generator systems such as <span class="docEmphasis">yacc</span> and
<span class="docEmphasis">bison</span>. Better yet, we could use an integration
that already exists.<A NAME="IXT-18-338129"></A> <A NAME="IXT-18-338130"></A>
</P>

<P class="docText"><A NAME="IXT-18-338131"></A>There are
also Python-specific parsing systems accessible from Python's
web site. Among them, the <span class="docEmphasis">kwParsing</span> system,
developed by Aaron Watters, is a parser generator written in Python,
and the <span class="docEmphasis">SPARK</span> toolkit, developed by John Aycock,
is a lightweight system that employs the Earley algorithm to work
around technical problems with LALR parser generation (if you
don't know what that means, you probably don't need to
care). Since these are all complex tools, though, we'll skip
their details in this text. Consult <A class="docLink" target="_blank" HREF="http://www.python.org/default.htm">http://www.python.org</A> for information on
parser generator tools available for use in Python programs.
</P>

<P><A NAME="python2-CHP-18-SIDEBAR-2"></A><TABLE CELLSPACING="0" WIDTH="90%" BORDER="1"><TR><TD>
<H2 class="docSidebarTitle">Lesson 2: Don't Reinvent the Wheel</H2>

<P class="docText">Speaking of parser generators: to use some of these tools in Python
programs, you'll need an extension module that integrates them.
The first step in such scenarios should always be to see if the
extension already exists in the public domain. Especially for common
tools like these, chances are that someone else has already written
an integration that you can use off-the-shelf instead of writing one
from scratch.
</P>

<P class="docText">Of course, not everyone can donate all their extension modules to the
public domain, but there's a growing library of available
components that you can pick up for free and a community of experts
to query. Visit <A class="docLink" target="_blank" HREF="http://www.python.org/default.htm">http://www.python.org</A> for links to Python
software resources. With some half a million Python users out there
as I write this book, there is much that can be found in the
prior-art department.
</P>
</TD></TR></TABLE></P>

<P class="docText"><A NAME="IXT-18-338132"></A>Of special interest to this chapter,
also see YAPPS -- Yet Another Python Parser System. YAPPS is a
parser generator written in Python. It uses supplied rules to
generate human-readable Python code that implements a recursive
descent parser. The parsers generated by YAPPS look much like (and
are inspired by) the hand-coded expression parsers shown in the next
section. YAPPS creates LL(1) parsers, which are not as powerful as
LALR parsers, but sufficient for many language tasks. For more on
YAPPS, see <A class="docLink" target="_blank" HREF="http://theory.stanford.edu/~amitp/Yapps">http://theory.stanford.edu/~amitp/Yapps</A>.
</P>


<ul></ul>
</td>
</tr>
</table>
<td></td>
<table width="100%" border="0" cellspacing="0" cellpadding="0" bgcolor="#CCCCCC">
<td><font color="black" size=1>I l<font color="#FF0000">@</font>ve RuBoard</td>
<td valign="top" class="v2" align="right">
          <a href="0596000855_python2-CHP-18-SECT-4.html"><img src="FILES/previous.gif" width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a>
          <a href="0596000855_python2-CHP-18-SECT-6.html"><img src="FILES/next.gif" width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a>
</td></table>
</body></html>
