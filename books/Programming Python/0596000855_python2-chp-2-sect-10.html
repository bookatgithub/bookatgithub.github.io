<html><head>
<META http-equiv="Content-Type" content="text/html">
<!--SafClassName="docSection1Title"--><!--SafTocEntry="2.10 Standard Streams"-->
<link rel="STYLESHEET" type="text/css" href="FILES/style.css">
<link rel="STYLESHEET" type="text/css" href="FILES/docsafari.css">
</head>
<body>
<table width="100%" border="0" cellspacing="0" cellpadding="0" bgcolor="#CCCCCC">
<td><font color="black" size=1>I l<font color="#FF0000">@</font>ve RuBoard</td>
<td valign="top" class="v2" align="right">
	<a href="0596000855_python2-CHP-2-SECT-9.html"><img src="FILES/previous.gif" width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a>
	<a href="0596000855_python2-CHP-2-SECT-11.html"><img src="FILES/next.gif" width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a>
</td></table>
<br>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<tr>
<td valign="top"><A NAME="python2-CHP-2-SECT-10"></A>
<H3 class="docSection1Title">2.10 Standard Streams</H3>

<P class="docText">Module <TT>sys</TT> is also the place where the standard
input, output, and error streams of your Python programs live:
</P>

<PRE>&gt;&gt;&gt; <B>for f in (sys.stdin, sys.stdout, sys.stderr): print f</B>
...
&lt;open file '&lt;stdin&gt;', mode 'r' at 762210&gt;
&lt;open file '&lt;stdout&gt;', mode 'w' at 762270&gt;
&lt;open file '&lt;stderr&gt;', mode 'w' at 7622d0&gt;</PRE>

<P class="docText">The standard streams are simply pre-opened Python file objects that
are automatically connected to your program's standard streams
when Python starts up. By default, they are all tied to the console
window where Python (or a Python program) was started. Because the
<TT>print</TT> statement and <TT>raw_input</TT>
functions are really nothing more than user-friendly interfaces to
the standard output and input streams, they are similar to using
<TT>stdout</TT> and <TT>stdin</TT> in
<TT>sys</TT> directly:
</P>

<PRE>&gt;&gt;&gt; <B>print 'hello stdout world'</B>
hello stdout world

&gt;&gt;&gt; <B>sys.stdout.write('hello stdout world' + '\n')</B>
hello stdout world

&gt;&gt;&gt; <B>raw_input('hello stdin world&gt;')</B>
hello stdin world&gt;<B>spam</B>
'spam'

&gt;&gt;&gt; <B>print 'hello stdin world&gt;',; sys.stdin.readline(  )[:-1]</B>
hello stdin world&gt;<B>eggs</B>

'eggs'</PRE>

<P><A NAME="python2-CHP-2-SIDEBAR-4"></A><TABLE CELLSPACING="0" WIDTH="90%" BORDER="1"><TR><TD>
<H2 class="docSidebarTitle">Standard Streams on Windows</H2>

<P class="docText">Windows users: if you click a <I>.py</I> Python
program's filename in a Windows file explorer to start it (or
launch it with <TT>os.system</TT>), a DOS console box
automatically pops up to serve as the program's standard
stream. If your program makes windows of its own, you can avoid this
console pop-up window by naming your program's source-code file
with a <I>.pyw</I> extension, not
<I>.py</I>. The .<I>pyw</I> extension
simply means a <I>.py</I> source file without a DOS
pop-up on Windows.
</P>

<P class="docText">One caveat: in the Python 1.5.2 release, <I>.pyw</I>
files can only be run, not imported -- the
<I>.pyw</I> is not recognized as a module name. If you
want a program to <span class="docEmphasis">both</span> be run without a DOS
console pop-up and be importable elsewhere, you need both
<I>.py</I> and <I>.pyw</I> files; the
<I>.pyw</I> may simply serve as top-level script logic
that imports and calls the core logic in the
<I>.py.</I> See <A class="docLink" HREF="0596000855_python2-CHP-9-SECT-4.html#python2-CHP-9-SECT-4">Section 9.4</A> in
<A class="docLink" HREF="0596000855_python2-CHP-9.html#python2-CHP-9">Chapter 9</A>, for an example.
</P>

<P class="docText">Also note that because printed output goes to this DOS pop-up when a
program is clicked, scripts that simply print text and exit will
generate an odd "flash" -- the DOS console box pops
up, output is printed into it, and the pop-up goes immediately away
(not the most user-friendly of features!). To keep the DOS pop-up box
around so you can read printed output, simply add a
<TT>raw_input( )</TT> call at the bottom of your script to
pause for an Enter key press before exiting.
</P>
</TD></TR></TABLE></P>

<A NAME="python2-CHP-2-SECT-10.1"></A>
<H4 class="docSection2Title">2.10.1 Redirecting Streams to Files and Programs</H4>

<P class="docText">Technically, standard output (and <TT>print</TT>) text
appears in the console window where a program was started, standard
input (and <TT>raw_input</TT>) text comes from the
keyboard, and standard error is used to print Python error messages
to the console window. At least that's the default. It's
also possible to <span class="docEmphasis">redirect</span> these streams both to
files and other programs at the system shell, and to arbitrary
objects within a Python script. On most systems, such redirections
make it easy to reuse and combine general-purpose command-line
utilities.
</P>

<A NAME="python2-CHP-2-SECT-10.1.1"></A>
<H5 class="docSection3Title">2.10.1.1 Redirecting streams to files</H5>

<P class="docText">Redirection is useful for things like canned (precoded) test inputs:
we can apply a single test script to any set of inputs by simply
redirecting the standard input stream to a different file each time
the script is run. Similarly, redirecting the standard output stream
lets us save and later analyze a program's output; for example,
testing systems might compare the saved standard output of a script
with a file of expected output, to detect failures.
</P>

<P class="docText">Although it's a powerful paradigm, redirection turns out to be
straightforward to use. For instance, consider the simple
read-evaluate-print loop program in <A class="docLink" HREF="#python2-CHP-2-EX-6">Example 2-6</A>.
</P>


<H5 class="docExampleTitle"><A NAME="python2-CHP-2-EX-6"></A>Example 2-6. PP2E\System\Streams\teststreams.py </H5>
<PRE># read numbers till eof and show squares

def interact(  ):
    print 'Hello stream world'                      # print sends to sys.stdout
    while 1:
        try:
            reply  = raw_input('Enter a number&gt;')   # raw_input reads sys.stdin
        except EOFError:
            break                                   # raises an except on eof
        else:                                       # input given as a string
            num = int(reply)
            print "%d squared is %d" % (num, num ** 2)
    print 'Bye'

if __name__ == '__main__': 
    interact(  )                                      # when run, not imported</PRE>


<P class="docText">As usual, the <TT>interact</TT> function here is
automatically executed when this file is run, not when it is
imported. By default, running this file from a system command line
makes that standard stream appear where you typed the Python command.
The script simply reads numbers until it reaches end-of-file in the
standard input stream (on Windows, end-of-file is usually the two-key
combination Ctrl+Z; on Unix, type Ctrl+D instead<sup class="docFootnote"><A class="docLink" HREF="#">[8]</A></sup>):
</P>
<blockquote><p class="docFootnote"><sup><A NAME="">[8]</A></sup> Notice that <TT>raw_input</TT> raises an exception to
signal end-of-file, but file read methods simply return an empty
string for this condition. Because <TT>raw_input</TT> also
strips the end-of-line character at the end of lines, an empty string
result means an empty line, so an exception is necessary to specify
the end-of-file condition. File read methods retain the end-of-line
character, and denote an empty line as <TT>\n</TT> instead
of <TT>""</TT>. This is one way in which reading
<TT>sys.stdin</TT> directly differs from
<TT>raw_input</TT>. The latter also accepts a prompt string
that is automatically printed before input is accepted.</p></blockquote>

<PRE>C:\...\PP2E\System\Streams&gt;<B>python teststreams.py</B>
Hello stream world
Enter a number&gt;<B>12</B>
12 squared is 144
Enter a number&gt;<B>10</B>
10 squared is 100
Enter a number&gt;</PRE>

<P class="docText">But on both Windows and Unix-like platforms, we can redirect the
standard input stream to come from a file with the
<TT>&lt;</TT> <TT><I>filename</I></TT> shell
syntax. Here is a command session in a DOS console box on Windows
that forces the script to read its input from a text file,
<I>input.txt</I>. It's the same on Linux, but
replace the DOS <I>type</I> command with a Unix
<I>cat</I> command:
</P>

<PRE>C:\...\PP2E\System\Streams&gt;<B>type input.txt</B>
8
6

C:\...\PP2E\System\Streams&gt;<B>python teststreams.py &lt; input.txt</B>
Hello stream world
Enter a number&gt;8 squared is 64
Enter a number&gt;6 squared is 36
Enter a number&gt;Bye</PRE>

<P class="docText">Here, the <I>input.txt</I> file automates the input we
would normally type interactively -- the script reads from this
file instead of the keyboard. Standard output can be similarly
redirected to go to a file, with the <TT>&gt;</TT>
<TT><I>filename</I></TT> shell syntax. In fact, we can
combine input and output redirection in a single command:
</P>

<PRE>C:\...\PP2E\System\Streams&gt;<B>python teststreams.py &lt; input.txt &gt; output.txt</B>

C:\...\PP2E\System\Streams&gt;<B>type output.txt</B>
Hello stream world
Enter a number&gt;8 squared is 64
Enter a number&gt;6 squared is 36
Enter a number&gt;Bye</PRE>

<P class="docText">This time, the Python script's input and output are both mapped
to text files, not the interactive console session.
</P>



<A NAME="python2-CHP-2-SECT-10.1.2"></A>
<H5 class="docSection3Title">2.10.1.2 Chaining programs with pipes</H5>

<P class="docText">On Windows and Unix-like platforms, it's also possible to send
the standard output of one program to the standard input of another,
using the | shell character between two commands. This is usually
called a "pipe" operation -- the shell creates a
pipeline that connects the output and input of two commands.
Let's send the output of the Python script to the standard
"more" command-line program's input to see how this
works:
</P>

<PRE>C:\...\PP2E\System\Streams&gt;<B>python teststreams.py &lt; input.txt | more</B>

Hello stream world
Enter a number&gt;8 squared is 64
Enter a number&gt;6 squared is 36
Enter a number&gt;Bye</PRE>

<P class="docText">Here, <TT>teststreams</TT>'s standard input comes
from a file again, but its output (written by
<TT>print</TT> statements) is sent to another program, not
a file or window. The receiving program is
<TT>more</TT> -- a standard command-line paging program
available on Windows and Unix-like platforms. Because Python ties
scripts into the standard stream model, though, Python scripts can be
used on both ends -- one Python script's output can always
be piped into another Python script's input:
</P>

<PRE>C:\...\PP2E\System\Streams&gt;<B>type writer.py</B>
print "Help! Help! I'm being repressed!"
print 42

C:\...\PP2E\System\Streams&gt;<B>type reader.py</B>
print 'Got this" "%s"' % raw_input(  )
import sys
data = sys.stdin.readline(  )[:-1]
print 'The meaning of life is', data, int(data) * 2

C:\...\PP2E\System\Streams&gt;<B>python writer.py | python reader.py</B>
Got this" "Help! Help! I'm being repressed!"
The meaning of life is 42 84</PRE>

<P class="docText">This time, two Python programs are connected. Script
<TT>reader</TT> gets input from script
<TT>writer</TT>; both scripts simply read and write,
oblivious to stream mechanics. In practice, such chaining of programs
is a simple form of cross-program communications. It makes it easy to
<span class="docEmphasis">reuse</span> utilities written to communicate via
<TT>stdin</TT> and <TT>stdout</TT> in ways we
never anticipated. For instance, a Python program that sorts
<TT>stdin</TT> text could be applied to any data source we
like, including the output of other scripts. Consider the Python
command-line utility scripts in Examples <A class="docLink" HREF="#python2-CHP-2-EX-7">Example 2-7</A>
and <A class="docLink" HREF="#python2-CHP-2-EX-8">Example 2-8</A> that sort and sum lines in the
standard input stream.
</P>


<H5 class="docExampleTitle"><A NAME="python2-CHP-2-EX-7"></A>Example 2-7. PP2E\System\Streams\sorter.py </H5>
<PRE>import sys
lines = sys.stdin.readlines(  )           # sort stdin input lines,
lines.sort(  )                            # send result to stdout
for line in lines: print line,            # for further processing</PRE>



<H5 class="docExampleTitle"><A NAME="python2-CHP-2-EX-8"></A>Example 2-8. PP2E\System\Streams\adder.py </H5>
<PRE>import sys, string
sum = 0
while 1:
    try:
        line = raw_input(  )               # or call sys.stdin.readlines(  ):
    except EOFError:                      # or sys.stdin.readline(  ) loop
        break
    else:
        sum = sum + string.atoi(line)     # int(line[:-1]) treats 042 as octal
print sum</PRE>


<P class="docText">We can apply such general-purpose tools in a variety of ways at the
shell command line, to sort and sum arbitrary files and program
outputs:
</P>

<PRE>C:\...\PP2E\System\Streams&gt;<B>type data.txt </B>
123
000
999
042

C:\...\PP2E\System\Streams&gt;<B>python sorter.py &lt; data.txt     </B>        <I> sort a file</I>
000
042
123
999

C:\...\PP2E\System\Streams&gt;<B>type data.txt | python adder.py   </B>      <I> sum program output</I>
1164

C:\...\PP2E\System\Streams&gt;<B>type writer2.py </B>
for data in (123, 0, 999, 42):
    print '%03d' % data

C:\...\PP2E\System\Streams&gt;<B>python writer2.py | python sorter.py  </B>   <I> sort py output</I>
000
042
123
999

C:\...\PP2E\System\Streams&gt;<B>python writer2.py | python sorter.py | python adder.py </B>
1164</PRE>

<P class="docText">The last command here connects three Python scripts by standard
streams -- the output of each prior script is fed to the input of
the next via pipeline shell syntax.
</P>

<P class="docText">If you look closely, you'll notice that
<TT>sorter</TT> reads all of <TT>stdin</TT> at
once with the <TT>readlines</TT> method, but
<TT>adder</TT> reads one line at a time. If the input
source is another program, some platforms run programs connected by
pipes in <span class="docEmphasis">parallel</span>. On such systems, reading
line-by-line works better if the data streams being passed about are
large -- readers need not wait until writers are completely
finished to get busy processing data. Because
<TT>raw_input</TT> just reads <TT>stdin</TT>, the
line-by-line scheme used by <TT>adder</TT> can always be
coded with <TT>sys.stdin</TT> too:
</P>

<PRE>C:\...\PP2E\System\Streams&gt;<B>type adder2.py</B>
import sys, string
sum = 0
while 1:
    line = sys.stdin.readline(  )
    if not line: break
    sum = sum + string.atoi(line[:-1])
print sum</PRE>

<P class="docText">Changing <TT>sorter</TT> to read line-by-line may not be a
big performance boost, though, because the list
<TT>sort</TT> method requires the list to already be
complete. As we'll see in <A class="docLink" HREF="0596000855_python2-CHP-17.html#python2-CHP-17">Chapter 17</A>,
manually coded sort algorithms are likely to be much slower than the
Python list sorting method.
</P>



<A NAME="python2-CHP-2-SECT-10.1.3"></A>
<H5 class="docSection3Title">2.10.1.3 Redirected streams and user interaction</H5>

<P class="docText">At the start of the last section, we piped
<I>teststreams.py</I> output into the standard
<TT>more</TT> command-line program with a command like
this:
</P>

<PRE>C:\...\PP2E\System\Streams&gt;<B>python teststreams.py &lt; input.txt | more</B></PRE>

<P class="docText">But since we already wrote our own "more" paging utility
in Python near the start of this chapter, why not set it up to accept
input from <TT>stdin</TT> too? For example, if we change
the last three lines of file <I>more.py</I> listed
earlier in this chapter to this:
</P>

<PRE>if __name__ == '__main__':                       # when run, not when imported
    if len(sys.argv) == 1:                       # page stdin if no cmd args
        more(sys.stdin.read(  ))
    else:
        more(open(sys.argv[1]).read(  ))</PRE>

<P class="docText">Then it almost seems as if we should be able to redirect the standard
output of <I>teststreams.py</I> into the standard input
of <I>more.py </I>:
</P>

<PRE>C:\...\PP2E\System\Streams&gt;<B>python teststreams.py &lt; input.txt | python ..\more.py</B>
Hello stream world
Enter a number&gt;8 squared is 64
Enter a number&gt;6 squared is 36
Enter a number&gt;Bye</PRE>

<P class="docText">This technique works in general for Python scripts. Here,
<I>teststreams.py</I> takes input from a file again.
And, as in the last section, one Python program's output is
piped to another's input -- the <I>more.py</I>
script in the parent ("..") directory.
</P>

<A NAME="python2-CHP-2-SECT-10.1.3.1"></A>
<H5 class="docSection4Title">2.10.1.3.1 Reading keyboard input</H5>

<P class="docText">But there's a subtle problem lurking in the preceding
<I>more.py</I> command. Really, chaining only worked
there by sheer luck: if the first script's output is long
enough for <TT>more</TT> to have to ask the user if it
should continue, the script will utterly fail. The problem is that
the augmented <I>more.py</I> uses
<TT>stdin</TT> for two disjoint purposes. It reads a reply
from an interactive user on <TT>stdin</TT> by calling
<TT>raw_input</TT>, but now <span class="docEmphasis">also</span>
accepts the main input text on <TT>stdin</TT>. When the
<TT>stdin</TT> stream is really redirected to an input file
or pipe, we can't use it to input a reply from an interactive
user; it contains only the text of the input source. Moreover,
because <TT>stdin</TT> is redirected before the program
even starts up, there is no way to know what it meant prior to being
redirected in the command line.
</P>

<P class="docText">If we intend to accept input on <TT>stdin</TT>
<span class="docEmphasis">and</span> use the console for user interaction, we
have to do a bit more. <A class="docLink" HREF="#python2-CHP-2-EX-9">Example 2-9</A> shows a modified
version of the <TT>more</TT> script that pages the standard
input stream if called with no arguments, but also makes use of
lower-level and platform-specific tools to converse with a user at a
keyboard if needed.
</P>


<H5 class="docExampleTitle"><A NAME="python2-CHP-2-EX-9"></A>Example 2-9. PP2E\System\moreplus.py </H5>
<PRE>#############################################################
# split and interactively page a string, file, or stream of
# text to stdout; when run as a script, page stdin or file 
# whose name is passed on cmdline; if input is stdin, can't
# use it for user reply--use platform-specific tools or gui;
#############################################################

import sys, string

def getreply(  ):
    """ 
    read a reply key from an interactive user
    even if stdin redirected to a file or pipe
    """
    if sys.stdin.isatty(  ):                       # if stdin is console
        return raw_input('?')                    # read reply line from stdin 
    else:
        if sys.platform[:3] == 'win':            # if stdin was redirected
            import msvcrt                        # can't use to ask a user 
            msvcrt.putch('?')
            key = msvcrt.getche(  )                # use windows console tools
            msvcrt.putch('\n')                   # getch(  ) does not echo key
            return key
        elif sys.platform[:5] == 'linux':        # use linux console device 
            print '?',                           # strip eoln at line end
            console = open('/dev/tty')
            line = console.readline(  )[:-1]
            return line
        else:
            print '[pause]'                      # else just pause--improve me
            import time                          # see also modules curses, tty
            time.sleep(5)                        # or copy to temp file, rerun
            return 'y'                           # or gui popup, tk key bind

def more(text, numlines=10):
    """
    split multi-line string to stdout
    """
    lines = string.split(text, '\n')
    while lines:
        chunk = lines[:numlines]
        lines = lines[numlines:]
        for line in chunk: print line
        if lines and getreply(  ) not in ['y', 'Y']: break 

if __name__ == '__main__':                       # when run, not when imported
    if len(sys.argv) == 1:                       # if no command-line arguments
        more(sys.stdin.read(  ))                   # page stdin, no raw_inputs
    else:
        more(open(sys.argv[1]).read(  ))           # else page filename argument</PRE>


<P class="docText">Most of the new code in this version shows up in its
<TT>getreply</TT> function. The file
<TT>isatty</TT> method tells us if <TT>stdin</TT>
is connected to the console; if it is, we simply read replies on
<TT>stdin</TT> as before. Unfortunately, there is no
portable way to input a string from a console user independent of
<TT>stdin</TT>, so we must wrap the
non-<TT>stdin</TT> input logic of this script in a
<TT>sys.platform</TT> test:
</P>

<UL>
<LI><P class="docList">On Windows, the built-in <TT>msvcrt</TT> module supplies
low-level console input and output calls (e.g.,
<TT>msvcrt.getch( )</TT> reads a single key press).
</P></LI>
<LI><P class="docList">On Linux, the system device file named <I>/dev/tty</I>
gives access to keyboard input (we can read it as though it were a
simple file).
</P></LI>
<LI><P class="docList">On other platforms, we simply run a built-in
<TT>time.sleep</TT> call to pause for five seconds between
displays (this is not at all ideal, but is better than not stopping
at all, and serves until a better nonportable solution can be found).
</P></LI>
</UL>
<P class="docText">Of course, we only have to add such extra logic to scripts that
intend to interact with console users <span class="docEmphasis">and</span> take
input on <TT>stdin</TT>. In a GUI application, for example,
we could instead pop up dialogs, bind keyboard-press event to run
callbacks, and so on (we'll meet GUIs in <A class="docLink" HREF="0596000855_python2-CHP-6.html#python2-CHP-6">Chapter 6</A>).
</P>

<P class="docText">Armed with the reusable <TT>getreply</TT> function, though,
we can safely run our <TT>moreplus</TT> utility in a
variety of ways. As before, we can import and call this
module's function directly, passing in whatever string we wish
to page:
</P>

<PRE>&gt;&gt;&gt; <B>from moreplus import more</B>
&gt;&gt;&gt; <B>more(open('System.txt').read(  ))</B>
This directory contains operating system interface examples.

Many of the examples in this unit appear elsewhere in the examples
distribution tree, because they are actually used to manage other
programs.  See the README.txt files in the subdirectories here
for pointers.</PRE>

<P class="docText">Also as before, when run with a command-line
<span class="docEmphasis">argument</span>, this script interactively pages
through the named file's text:
</P>

<PRE>C:\...\PP2E\System&gt;<B>python moreplus.py System.txt</B>
This directory contains operating system interface examples.

Many of the examples in this unit appear elsewhere in the examples
distribution tree, because they are actually used to manage other
programs.  See the README.txt files in the subdirectories here
for pointers.

C:\...\PP2E\System&gt;<B>python moreplus.py moreplus.py</B>
#############################################################
# split and interactively page a string, file, or stream of
# text to stdout; when run as a script, page stdin or file
# whose name is passed on cmdline; if input is stdin, can't
# use it for user reply--use platform-specific tools or gui;
#############################################################

import sys, string

def getreply(  ):
?<B>n</B></PRE>

<P class="docText">But now the script also correctly pages text redirected in to
<TT>stdin</TT> from either a <span class="docEmphasis">file</span> or
command <span class="docEmphasis">pipe</span>, even if that text is too long to
fit in a single display chunk. On most shells, we send such input via
redirection or pipe operators like these:
</P>

<PRE>C:\...\PP2E\System&gt;<B>python moreplus.py &lt; moreplus.py</B>
#############################################################
# split and interactively page a string, file, or stream of
# text to stdout; when run as a script, page stdin or file
# whose name is passed on cmdline; if input is stdin, can't
# use it for user reply--use platform-specific tools or gui;
#############################################################

import sys, string

def getreply(  ):
?<B>n</B>

C:\...\PP2E\System&gt;<B>type moreplus.py | python moreplus.py</B>
#############################################################
# split and interactively page a string, file, or stream of
# text to stdout; when run as a script, page stdin or file
# whose name is passed on cmdline; if input is stdin, can't
# use it for user reply--use platform-specific tools or gui;
#############################################################

import sys, string

def getreply(  ):
?<B>n</B></PRE>

<P class="docText">This works the same on Linux, but again use the
<I>cat</I> command instead of <I>type</I>.
Finally, piping one Python script's output into this
script's input now works as expected, without botching user
interaction (and not just because we got lucky):
</P>

<PRE>C:\......\System\Streams&gt;<B>python teststreams.py &lt; input.txt | python ..\moreplus.py</B>
Hello stream world
Enter a number&gt;8 squared is 64
Enter a number&gt;6 squared is 36
Enter a number&gt;Bye</PRE>

<P class="docText">Here, the standard <span class="docEmphasis">output</span> of one Python script
is fed to the standard <span class="docEmphasis">input</span> of another Python
script located in the parent directory:
<I>moreplus.py</I> reads the output of
<I>teststreams.py</I>.
</P>

<P class="docText">All of the redirections in such command lines work only because
scripts don't care what standard input and output really
are -- interactive users, files, or pipes between programs. For
example, when run as a script, <I>moreplus.py</I>
simply reads stream <TT>sys.stdin</TT>; the command-line
shell (e.g., DOS on Windows, <TT>csh</TT> on Linux)
attaches such streams to the source implied by the command line
before the script is started. Scripts use the preopened
<TT>stdin</TT> and <TT>stdout</TT> file objects
to access those sources, regardless of their true nature.
</P>

<P class="docText">And for readers keeping count, we have run this single
<TT>more</TT> pager script in four different ways: by
importing and calling its function, by passing a filename
command-line argument, by redirecting <TT>stdin</TT> to a
file, and by piping a command's output to
<TT>stdin</TT>. By supporting importable functions,
command-line arguments, and standard streams, Python system tools
code can be reused in a wide variety of modes.
</P>




<A NAME="python2-CHP-2-SECT-10.2"></A>
<H4 class="docSection2Title">2.10.2 Redirecting Streams to Python Objects</H4>

<P class="docText">All of the above standard stream redirections work for programs
written in any language that hooks into the standard streams, and
rely more on the shell's command-line processor than on Python
itself. Command-line redirection syntax like <TT>&lt;</TT>
<TT><I>filename</I></TT> and <TT>|</TT>
<TT><I>program</I></TT> is evaluated by the shell, not
Python. A more Pythonesque form of redirection can be done within
scripts themselves, by resetting <TT>sys.stdin</TT> and
<TT>sys.stdout</TT> to file-like objects.
</P>

<P class="docText">The main trick behind this mode is that anything that looks like a
file in terms of methods will work as a standard stream in Python.
The object's protocol, not the object's specific
datatype, is all that matters. That is:
</P>

<UL>
<LI><P class="docList">Any object that provides file-like <span class="docEmphasis">read</span> methods
can be assigned to <TT>sys.stdin</TT> to make input come
from that object's read methods.
</P></LI>
<LI><P class="docList">Any object that defines file-like <span class="docEmphasis">write</span> methods
can be assigned to <TT>sys.stdout</TT>; all standard output
will be sent to that object's methods.
</P></LI>
</UL>
<P class="docText">Because <TT>print</TT> and <TT>raw_input</TT>
simply call the <TT>write</TT> and
<TT>readline</TT> methods of whatever objects
<TT>sys.stdout</TT> and <TT>sys.stdin</TT> happen
to reference, we can use this trick to both provide and intercept
standard stream text with objects implemented as classes. <A class="docLink" HREF="#python2-CHP-2-EX-10">Example 2-10</A> shows a utility module that demonstrates this
concept.
</P>


<H5 class="docExampleTitle"><A NAME="python2-CHP-2-EX-10"></A>Example 2-10. PP2E\System\Streams\redirect.py </H5>
<PRE>##########################################################
# file-like objects that save all standard output text in 
# a string, and provide standard input text from a string;
# redirect runs a passed-in function with its output and
# input streams reset to these file-like class objects;
##########################################################

import sys, string                              # get built-in modules

class Output:                                   # simulated output file
    def __init__(self):                                 
        self.text = ''                          # empty string when created
    def write(self, string):                    # add a string of bytes
        self.text = self.text + string            
    def writelines(self, lines):                # add each line in a list
        for line in lines: self.write(line)

class Input:                                    # simulated input file
    def __init__(self, input=''):               # default argument        
        self.text = input                       # save string when created
    def read(self, *size):                      # optional argument
        if not size:                            # read N bytes, or all
            res, self.text = self.text, ''
        else:
            res, self.text = self.text[:size[0]], self.text[size[0]:]
        return res
    def readline(self):
        eoln = string.find(self.text, '\n')     # find offset of next eoln
        if eoln == -1:                          # slice off through eoln
            res, self.text = self.text, ''
        else:
            res, self.text = self.text[:eoln+1], self.text[eoln+1:]
        return res

def redirect(function, args, input):            # redirect stdin/out
    savestreams = sys.stdin, sys.stdout         # run a function object 
    sys.stdin   = Input(input)                  # return stdout text
    sys.stdout  = Output(  )
    try:
        apply(function, args)
    except:
        sys.stderr.write('error in function! ')
        sys.stderr.write("%s, %s\n" % (sys.exc_type, sys.exc_value))
    result = sys.stdout.text
    sys.stdin, sys.stdout = savestreams
    return result</PRE>


<P class="docText">This module defines two classes that masquerade as real files:</P>

<UL>
<LI><P class="docList"><TT>Output</TT> provides the write method protocol expected
of output files, but saves all output as it is written, in an
in-memory string.
</P></LI>
<LI><P class="docList"><TT>Input</TT> provides the protocol expected of input
files, but provides input on demand from an in-memory string, passed
in at object construction time.
</P></LI>
</UL>
<P class="docText">The <TT>redirect</TT> function at the bottom of this file
combines these two objects to run a single function with input and
output redirected entirely to Python class objects. The passed-in
function so run need not know or care that its
<TT>print</TT> statements, <TT>raw_input</TT>
calls, and <TT>stdin</TT> and <TT>stdout</TT>
method calls are talking to a class instead of a real file, pipe, or
user.
</P>

<P class="docText">To demonstrate, import and run the <TT>interact</TT>
function at the heart of the <TT>teststreams</TT> script
we've been running from the shell (to use the redirection
utility function, we need to deal in terms of functions, not files).
When run directly, the function reads from the keyboard and writes to
the screen, just as if it were run as a program without redirection:
</P>

<PRE>C:\...\PP2E\System\Streams&gt;<B>python</B>
&gt;&gt;&gt; <B>from teststreams import interact</B>
&gt;&gt;&gt; <B>interact(  )</B>
Hello stream world
Enter a number&gt;<B>2</B>
2 squared is 4
Enter a number&gt;<B>3</B>
3 squared is 9
Enter a number
&gt;&gt;&gt;</PRE>

<P class="docText">Now, let's run this function under the control of the
redirection function in <I>redirect.py</I>, and pass in
some canned input text. In this mode, the <TT>interact</TT>
function takes its input from the string we pass in
(<TT>'4\n5\n6\n'</TT> -- three lines with explicit
end-of-line characters), and the result of running the function is a
string containing all the text written to the standard output stream:
</P>

<PRE>&gt;&gt;&gt; <B>from redirect import redirect</B>
&gt;&gt;&gt; <B>output = redirect(interact, (  ), '4\n5\n6\n')</B>
&gt;&gt;&gt; <B>output</B>
'Hello stream world\012Enter a number&gt;4 squared is 16\012Enter a number&gt;
5 squared is 25\012Enter a number&gt;6 squared is 36\012Enter a number&gt;Bye\012'</PRE>

<P class="docText">The result is a single, long string, containing the concatenation of
all text written to standard output. To make this look better, we can
split it up with the standard <TT>string</TT> module:
</P>

<PRE>&gt;&gt;&gt; <B>from string import split</B>
&gt;&gt;&gt; <B>for line in split(output, '\n'): print line</B>
...
Hello stream world
Enter a number&gt;4 squared is 16
Enter a number&gt;5 squared is 25
Enter a number&gt;6 squared is 36
Enter a number&gt;Bye</PRE>

<P class="docText">Better still, we can reuse the <I>more.py</I> module we
saw earlier in this chapter; it's less to type and remember,
and is already known to work well:
</P>

<PRE>&gt;&gt;&gt; <B>from PP2E.System.more import more</B>
&gt;&gt;&gt; <B>more(output)</B>
Hello stream world
Enter a number&gt;4 squared is 16
Enter a number&gt;5 squared is 25
Enter a number&gt;6 squared is 36
Enter a number&gt;Bye</PRE>

<P class="docText">This is an artificial example, of course, but the techniques
illustrated are widely applicable. For example, it's
straightforward to add a GUI interface to a program written to
interact with a command-line user. Simply intercept standard output
with an object like the <TT>Output</TT> class shown
earlier, and throw the text string up in a window. Similarly,
standard input can be reset to an object that fetches text from a
graphical interface (e.g., a popped-up dialog box). Because classes
are plug-and-play compatible with real files, we can use them in any
tool that expects a file. Watch for a GUI stream-redirection module
named <TT>guiStreams</TT> in <A class="docLink" HREF="0596000855_python2-CHP-9.html#python2-CHP-9">Chapter 9</A>.
</P>


<A NAME="python2-CHP-2-SECT-10.3"></A>
<H4 class="docSection2Title">2.10.3 Other Redirection Options</H4>

<P class="docText"><A NAME="python2-IDXTERM-13"></A>Earlier
in this chapter, we also studied the built-in
<TT>os.popen</TT> function, which provides a way to
redirect another command's streams from within a Python
program. As we saw, this function runs a shell command line (e.g., a
string we would normally type at a DOS or <TT>csh</TT>
prompt), but returns a Python file-like object connected to the
command's input or output stream. Because of that, the
<TT>os.popen</TT> tool can be considered another way to
redirect streams of spawned programs, and a cousin to the techniques
we just met: Its effect is much like the shell | command-line pipe
syntax for redirecting streams to programs (in fact its name means
"pipe open"), but it is run within a script and provides
a file-like interface to piped streams. It's similar in spirit
to the <TT>redirect</TT> function, but is based on running
programs (not calling functions), and the command's streams are
processed in the spawning script as files (not tied to class
objects).
</P>

<P class="docText">By passing in the desired mode flag, we redirect a spawned
program's input or output streams to a file in the calling
scripts:
</P>

<PRE>C:\...\PP2E\System\Streams&gt;<B>type hello-out.py</B>
print 'Hello shell world'

C:\...\PP2E\System\Streams&gt;<B>type hello-in.py</B>
input = raw_input(  )
open('hello-in.txt', 'w').write('Hello ' + input + '\n')

C:\...\PP2E\System\Streams&gt;<B>python</B>
&gt;&gt;&gt; <B>import os</B>
&gt;&gt;&gt; <B>pipe = os.popen('python hello-out.py')</B>         # 'r' is default--read stdout
&gt;&gt;&gt; <B>pipe.read(  )</B>
'Hello shell world\012'

&gt;&gt;&gt; <B>pipe = os.popen('python hello-in.py', 'w')</B>
&gt;&gt;&gt; <B>pipe.write('Gumby\n')</B>                          # 'w'--write to program stdin
&gt;&gt;&gt; <B>pipe.close(  )</B>                                   # \n at end is optional
&gt;&gt;&gt; <B>open('hello-in.txt').read(  )</B>
'Hello Gumby\012'</PRE>

<P class="docText">The <TT>popen</TT> call is also smart enough to run the
command string as an independent process on Unix and Linux. There are
additional <TT>popen</TT>-like tools in the Python library
that allow scripts to connect to more than one of the commands'
streams. For instance, the <TT>popen2</TT> module includes
functions for hooking into <span class="docEmphasis">both</span> a
command's input and output streams
(<TT>popen2.popen2</TT>), and another for connecting to
standard error as well (<TT>popen2.popen3</TT>):
</P>

<PRE>import popen2
<B>childStdout, childStdin = popen2.popen2('python hello-in-out.py')</B>
childStdin.write(input)
output = childStdout.read(  )

<B>childStdout, childStdin, childStderr = popen2.popen3('python hello-in-out.py')</B></PRE>

<P class="docText">These two calls work much like <TT>os.popen</TT>, but
connect additional streams. When I originally wrote this, these calls
only worked on Unix-like platforms, not on Windows, because they
relied on a <TT>fork</TT> call in Python 1.5.2. As of the
Python 2.0 release, they now work well on Windows too.
</P>

<P class="docText">Speaking of which: on Unix-like platforms, the combination of the
calls <TT>os.fork</TT>, <TT>os.pipe</TT>,
<TT>os.dup</TT>, and some <TT>os.exec</TT>
variants can be used to start a new independent program with streams
connected to the parent program's streams (that's how
<TT>popen2</TT> works its magic). As such, it's
another way to redirect streams, and a low-level equivalent to tools
like <TT>os.popen</TT>. See <A class="docLink" HREF="0596000855_python2-CHP-3.html#python2-CHP-3">Chapter 3</A>
for more on all these calls, especially its section on pipes.
</P>

<P><table border="0" bgcolor="black" cellspacing="0" cellpadding="1" width="90%" align="center"><tr><td>
<table bgcolor="white" width="100%" border="0" cellspacing="0" cellpadding="6"><tr>
<td width="60" valign="top"><img src="FILES/tip_yellow.gif" width="50" height="54"></td>
<td valign="top">
<P class="docText"><A NAME="IXT-2-336951"></A>
<A NAME="IXT-2-336952"></A>Python 2.0 now
also makes the <TT>popen2</TT> and
<TT>popen3</TT> calls available in the
<TT>os</TT> module. (For example,
<TT>os.popen2</TT> is the same as
<TT>popen2.popen2</TT>, except that the order of
<TT>stdin</TT> and <TT>stdout</TT> in the
call's result tuple is swapped.) In addition, the 2.0 release
extends the <TT>print</TT> statement to include an explicit
file to which output is to be sent. A statement of the form
<TT>print</TT> <TT>&gt;&gt;file</TT>
<TT>stuff</TT> prints <TT>stuff</TT> to
<TT>file</TT>, instead of <TT>stdout</TT>. The
net effect is similar to simply assigning
<TT>sys.stdout</TT> to an object.
</P>
</td>
</tr></table></td></tr></table></P>

<P><A NAME="python2-CHP-2-SIDEBAR-5"></A><TABLE CELLSPACING="0" WIDTH="90%" BORDER="1"><TR><TD>
<H2 class="docSidebarTitle">Capturing the stderr Stream</H2>

<P class="docText">We've been focusing on <TT>stdin</TT> and
<TT>stdout</TT> redirection, but <TT>stderr</TT>
can be similarly reset to files, pipes, and objects. This is
straightforward within a Python script. For instance, assigning
<TT>sys.stderr</TT> to another instance of a class like
<TT>Output</TT> in the preceding example allows your script
to intercept text written to standard error too. The
<TT>popen3</TT> call mentioned previously also allows
<TT>stderr</TT> to be intercepted within a script.
</P>

<P class="docText">Redirecting standard error from a shell command line is a bit more
complex, and less portable. On most Unix-like systems, we can usually
capture <TT>stderr</TT> output by using shell-redirection
syntax of the form <TT>command 2&gt;&amp;1</TT>. This
won't work on Windows 9x platforms, though, and can even vary
per Unix shell; see your shell's manpages for more
details.<A NAME="IXTR3-54"></A>
</P>
</TD></TR></TABLE></P>



<a href="0596000855_"><img src="FILES/pixel.gif" width="1" height="1" border="0"></a><ul></ul>
</td>
</tr>
</table>
<td></td>
<table width="100%" border="0" cellspacing="0" cellpadding="0" bgcolor="#CCCCCC">
<td><font color="black" size=1>I l<font color="#FF0000">@</font>ve RuBoard</td>
<td valign="top" class="v2" align="right">
          <a href="0596000855_python2-CHP-2-SECT-9.html"><img src="FILES/previous.gif" width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a>
          <a href="0596000855_python2-CHP-2-SECT-11.html"><img src="FILES/next.gif" width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a>
</td></table>
</body></html>
