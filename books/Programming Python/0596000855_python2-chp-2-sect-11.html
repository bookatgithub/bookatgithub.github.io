<html><head>
<META http-equiv="Content-Type" content="text/html">
<!--SafClassName="docSection1Title"--><!--SafTocEntry="2.11 File Tools"-->
<link rel="STYLESHEET" type="text/css" href="FILES/style.css">
<link rel="STYLESHEET" type="text/css" href="FILES/docsafari.css">
</head>
<body>
<table width="100%" border="0" cellspacing="0" cellpadding="0" bgcolor="#CCCCCC">
<td><font color="black" size=1>I l<font color="#FF0000">@</font>ve RuBoard</td>
<td valign="top" class="v2" align="right">
	<a href="0596000855_python2-CHP-2-SECT-10.html"><img src="FILES/previous.gif" width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a>
	<a href="0596000855_python2-CHP-2-SECT-12.html"><img src="FILES/next.gif" width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a>
</td></table>
<br>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<tr>
<td valign="top"><A NAME="python2-CHP-2-SECT-11"></A>
<H3 class="docSection1Title">2.11 File Tools</H3>

<P class="docText">External files are at the heart of much of what we do with shell
utilities. For instance, a testing system may read its inputs from
one file, store program results in another file, and check expected
results by loading yet another file. Even user interface and
Internet-oriented programs may load binary images and audio clips
from files on the underlying computer. It's a core programming
concept.
</P>

<P class="docText">In Python, the built-in <TT>open</TT> function is the
primary tool scripts use to access the files on the underlying
computer system. Since this function is an inherent part of the
Python language, you may already be familiar with its basic workings.
Technically, <TT>open</TT> gives direct access to the
<TT>stdio</TT> filesystem calls in the system's C
library -- it returns a new file object that is connected to the
external file, and has methods that map more or less directly to file
calls on your machine. The open function also provides a portable
interface to the underlying filesystem -- it works the same on
every platform Python runs on.
</P>

<P class="docText">Other file-related interfaces in Python allow us to do things such as
manipulate lower-level descriptor-based files (module
<TT>os</TT>), store objects away in files by key (modules
<TT>anydbm</TT> and <TT>shelve</TT>), and access
SQL databases. Most of these are larger topics addressed in <A class="docLink" HREF="0596000855_python2-CHP-16.html#python2-CHP-16">Chapter 16</A>. In this section, we take a brief tutorial
look at the built-in file object, and explore a handful of more
advanced file-related topics. As usual, you should consult the
library manual's file object entry for further details and
methods we don't have space to cover here.
</P>

<A NAME="python2-CHP-2-SECT-11.1"></A>
<H4 class="docSection2Title">2.11.1 Built-in File Objects</H4>

<P class="docText">For most purposes, the <TT>open</TT> function is all you
need to remember to process files in your scripts. The file object
returned by <TT>open</TT> has methods for reading data
(<TT>read</TT>, <TT>readline</TT>,
<TT>readlines</TT>), writing data
(<TT>write</TT>, <TT>writelines</TT>), freeing
system resources (<TT>close</TT>), moving about in the file
(<TT>seek</TT>), forcing data to be transferred out of
buffers (<TT>flush</TT>), fetching the underlying file
handle (<TT>fileno</TT>), and more. Since the built-in file
object is so easy to use, though, let's jump right in to a few
interactive examples.
</P>

<A NAME="python2-CHP-2-SECT-11.1.1"></A>
<H5 class="docSection3Title">2.11.1.1 Output files</H5>

<P class="docText">To make a new file, call <TT>open</TT> with two arguments:
the external <span class="docEmphasis">name</span> of the file to be created, and
a <span class="docEmphasis">mode</span> string "w" (short for
"write"). To store data on the file, call the file
object's <TT>write</TT> method with a string
containing the data to store, and then call the
<TT>close</TT> method to close the file if you wish to open
it again within the same program or session:
</P>

<PRE>C:\temp&gt;<B>python</B>
&gt;&gt;&gt; <B>file = open('data.txt', 'w')</B>           # open output file object: creates
&gt;&gt;&gt; <B>file.write('Hello file world!\n')</B>      # writes strings verbatim
&gt;&gt;&gt; <B>file.write('Bye   file world.\n')</B>
&gt;&gt;&gt; <B>file.close(  )</B>                           # closed on gc and exit too</PRE>

<P class="docText">And that's it -- you've just generated a brand new
text file on your computer, no matter which computer you type this
code on:
</P>

<PRE>C:\temp&gt;<B>dir data.txt /B</B>
data.txt

C:\temp&gt;<B>type data.txt</B>
Hello file world!
Bye   file world.</PRE>

<P class="docText">There is nothing unusual about the new file at all; here, I use the
DOS <I>dir</I> and <I>type</I> commands to
list and display the new file, but it shows up in a file explorer GUI
too.
</P>

<A NAME="python2-CHP-2-SECT-11.1.1.1"></A>
<H5 class="docSection4Title">2.11.1.1.1 Opening</H5>

<P class="docText">In the <TT>open</TT> function call shown in the preceding
example, the first argument can optionally specify a complete
directory path as part of the filename string; if we pass just a
simple filename without a path, the file will appear in
Python's current working directory. That is, it shows up in the
place where the code is run -- here, directory
<I>C:\temp</I> on my machine is implied by the bare
filename <I>data.txt</I>, so this really creates a file
at <I>C:\temp\data.txt</I>. See <A class="docLink" HREF="0596000855_python2-CHP-2-SECT-7.html#python2-CHP-2-SECT-7">Section 2.7</A> earlier in this chapter for a refresher
on this topic.
</P>

<P class="docText">Also note that when opening in "w" mode, Python either
creates the external file if it does not yet exist, or erases the
file's current contents if it is already present on your
machine (so be careful out there).
</P>



<A NAME="python2-CHP-2-SECT-11.1.1.2"></A>
<H5 class="docSection4Title">2.11.1.1.2 Writing</H5>

<P class="docText">Notice that we added an explicit <TT>\n</TT> end-of-line
character to lines written to the file; unlike the
<TT>print</TT> statement, file <TT>write</TT>
methods write exactly what they are passed, without any extra
formatting. The string passed to <TT>write</TT> shows up
byte-for-byte on the external file.
</P>

<P class="docText">Output files also sport a <TT>writelines</TT> method, which
simply writes all the strings in a list one at a time, without any
extra formatting added. For example, here is a
<TT>writelines</TT> equivalent to the two
<TT>write</TT> calls shown earlier:
</P>

<PRE><B>file.writelines(['Hello file world!\n', 'Bye   file world.\n'])</B></PRE>

<P class="docText">This call isn't as commonly used (and can be emulated with a
simple <TT>for</TT> loop), but is convenient in scripts
that save output in a list to be written later.
</P>



<A NAME="python2-CHP-2-SECT-11.1.1.3"></A>
<H5 class="docSection4Title">2.11.1.1.3 Closing</H5>

<P class="docText">The file <TT>close</TT> method used earlier finalizes file
contents and frees up system resources. For instance, closing forces
buffered output data to be flushed out to disk. Normally, files are
automatically closed when the file object is garbage collected by the
interpreter (i.e., when it is no longer referenced), and when the
Python session or program exits. Because of that,
<TT>close</TT> calls are often optional. In fact,
it's common to see file-processing code in Python like this:
</P>

<PRE>open('somefile.txt').write("G'day Bruce\n")</PRE>

<P class="docText">Since this expression makes a temporary file object, writes to it
immediately, and does not save a reference to it, the file object is
reclaimed and closed right away without ever having called the
<TT>close</TT> method explicitly.
</P>

<P><table border="0" bgcolor="black" cellspacing="0" cellpadding="1" width="90%" align="center"><tr><td>
<table bgcolor="white" width="100%" border="0" cellspacing="0" cellpadding="6"><tr>
<td width="60" valign="top"><img src="FILES/tip_yellow.gif" width="50" height="54"></td>
<td valign="top">
<P class="docText">But note that it's not impossible that this
<span class="docEmphasis">auto-close on reclaim</span> file feature may change in
future Python releases. Moreover, the JPython Java-based Python
implementation discussed later does not reclaim files as immediately
as the standard Python system (it uses Java's garbage
collector). If your script makes many files and your platform limits
the number of open files per program, explicit
<TT>close</TT> calls are a robust habit to form.
</P>
</td>
</tr></table></td></tr></table></P>





<A NAME="python2-CHP-2-SECT-11.1.2"></A>
<H5 class="docSection3Title">2.11.1.2 Input files</H5>

<P class="docText">Reading data from external files is just as easy as writing, but
there are more methods that let us load data in a variety of modes.
Input text files are opened with either a mode flag of
"r" (for "read") or no mode flag at all (it
defaults to "r" if omitted). Once opened, we can read the
lines of a text file with the <TT>readlines</TT> method:
</P>

<PRE>&gt;&gt;&gt; <B>file = open('data.txt', 'r')</B>           # open input file object
&gt;&gt;&gt; <B>for line in file.readlines(  ):</B>          # read into line string list
...     <B>print line,</B>                        # lines have '\n' at end
...
Hello file world!
Bye   file world.</PRE>

<P class="docText">The <TT>readlines</TT> method loads the entire contents of
the file into memory, and gives it to our scripts as a list of line
strings that we can step through in a loop. In fact, there are many
ways to read an input file:
</P>

<UL>
<LI><P class="docList"><TT>file.read( )</TT> returns a string containing all the
bytes stored in the file.
</P></LI>
<LI><P class="docList"><TT>file.read(N)</TT> returns a string containing the next
N bytes from the file.
</P></LI>
<LI><P class="docList"><TT>file.readline( )</TT> reads through the next
<TT>\n</TT> and returns a line string.
</P></LI>
<LI><P class="docList"><TT>file.readlines( )</TT> reads the entire file and
returns a list of line strings.
</P></LI>
</UL>
<P class="docText">Let's run these method calls to read files, lines, and bytes:</P>

<PRE>&gt;&gt;&gt; <B>file.seek(0)</B>                               # go back to the front of file
&gt;&gt;&gt; <B>file.read(  )                             </B>   # read entire file into string
'Hello file world!\012Bye   file world.\012'

&gt;&gt;&gt; <B>file.seek(0)</B>
&gt;&gt;&gt; <B>file.readlines(  )</B>
['Hello file world!\012', 'Bye   file world.\012']

&gt;&gt;&gt; <B>file.seek(0)</B>
&gt;&gt;&gt; <B>file.readline(  )</B>
'Hello file world!\012'
&gt;&gt;&gt; <B>file.readline(  )</B>
'Bye   file world.\012'

&gt;&gt;&gt; <B>file.seek(0)</B>
&gt;&gt;&gt; <B>file.read(1), file.read(8)</B>
('H', 'ello fil')</PRE>

<P class="docText">All these input methods let us be specific about how much to fetch.
Here are a few rules of thumb about which to choose:
</P>

<UL>
<LI><P class="docList"><TT>read( )</TT> and <TT>readlines( )</TT> load
the <span class="docEmphasis">entire file</span> into memory all at once. That
makes them handy for grabbing a file's contents with as little
code as possible. It also makes them very fast, but costly for huge
files -- loading a multi-gigabyte file into memory is not
generally a good thing to do.
</P></LI>
<LI><P class="docList">On the other hand, because the <TT>readline( )</TT> and
<TT>read(N)</TT> calls fetch just <span class="docEmphasis">part of the
file</span> (the next line, or N-byte block), they are safer for
potentially big files, but a bit less convenient, and usually much
slower. If speed matters and your files aren't huge,
<TT>read</TT> or <TT>readlines</TT> may be better
choices.
</P></LI>
</UL>
<P class="docText">By the way, the <TT>seek(0)</TT> call used repeatedly here
means "go back to the start of the file." In files, all
read and write operations take place at the current position; files
normally start at offset
when opened and advance as data is transferred. The
<TT>seek</TT> call simply lets us move to a new position
for the next transfer operation. Python's
<TT>seek</TT> method also accepts an optional second
argument having one of three values -- 0 for absolute file
positioning (the default), 1 to seek relative to the the current
position, and 2 to seek relative to the file's end. When
<TT>seek</TT> is passed only an offset argument
as above, it's roughly a file <span class="docEmphasis">rewind</span>
operation.
</P>



<A NAME="python2-CHP-2-SECT-11.1.3"></A>
<H5 class="docSection3Title">2.11.1.3 Other file object modes</H5>

<P class="docText">Besides "w" and "r", most platforms support
an "a" open mode string, meaning "append." In
this output mode, <TT>write</TT> methods add data to the
end of the file, and the <TT>open</TT> call will not erase
the current contents of the file:
</P>

<PRE>&gt;&gt;&gt; <B>file = open('data.txt', 'a')</B>          # open in append mode: doesn't erase
&gt;&gt;&gt; <B>file.write('The Life of Brian')</B>       # added at end of existing data
&gt;&gt;&gt; <B>file.close(  )</B>
&gt;&gt;&gt;
&gt;&gt;&gt; <B>open('data.txt').read(  )</B>               # open and read entire file
'Hello file world!\012Bye   file world.\012The Life of Brian'</PRE>

<P class="docText">Most files are opened using the sorts of calls we just ran, but
<TT>open</TT> actually allows up to three arguments for
more specific processing needs -- the filename, the open mode, and
a buffer size. All but the first of these are optional: if omitted,
the open mode argument defaults to "r" (input), and the
buffer size policy is to enable buffering on most platforms. Here are
a few things you should know about all three <TT>open</TT>
arguments:
</P>

<DL class="docList">
<DT><I><span class="docPubcolor">Filename</span></I></DT>
<DD>
<P class="docList">As mentioned, filenames can include an explicit directory path to
refer to files in arbitrary places on your computer; if they do not,
they are taken to be names relative to the current working directory
(described earlier). In general, any filename form you can type in
your system shell will work in an <TT>open</TT> call. For
instance, a filename argument <TT>r'..\temp\spam.txt'</TT>
on Windows means <I>spam.txt</I> in the
<I>temp</I> subdirectory of the current working
directory's parent -- up one, and down to directory
<I>temp</I>.
</P>
</DD><DT><I><span class="docPubcolor">Open mode</span></I></DT>
<DD>
<P class="docList">The <TT>open</TT> function accepts other modes too, some of
which are not demonstrated in this book (e.g., <TT>r+</TT>,
<TT>w+</TT>, and <TT>a+</TT> to open for
updating, and any mode string with a "b" to designate
binary mode). For instance, mode <TT>r+</TT> means both
reads and writes are allowed on the file, and <TT>wb</TT>
writes data in binary mode (more on this in the next section).
Generally, whatever you could use as a mode string in the C
language's <TT>fopen</TT> call on your platform will
work in the Python <TT>open</TT> function, since it really
just calls <TT>fopen</TT> internally. (If you don't
know C, don't sweat this point.) Notice that the contents of
files are always strings in Python programs regardless of mode: read
methods return a string, and we pass a string to write methods.
</P>
</DD><DT><I><span class="docPubcolor">Buffer size</span></I></DT>
<DD>
<P class="docList">The <TT>open</TT> call also takes an optional third
<span class="docEmphasis">buffer size</span> argument, which lets you control
<TT>stdio</TT> buffering for the file -- the way that
data is queued up before being transferred to boost performance. If
passed,
means file operations are unbuffered (data is transferred
immediately), 1 means they are line buffered, any other positive
value means use a buffer of approximately that size, and a negative
value means to use the system default (which you get if no third
argument is passed, and generally means buffering is enabled). The
buffer size argument works on most platforms, but is currently
ignored on platforms that don't provide the
<TT>sevbuf</TT> system call.
</P>
</DD>
</DL>



<A NAME="python2-CHP-2-SECT-11.1.4"></A>
<H5 class="docSection3Title">2.11.1.4 Binary data files</H5>

<P class="docText">The preceding examples all process simple text files. On most
platforms, Python scripts can also open and process files containing
<span class="docEmphasis">binary</span> data -- JPEG images, audio clips, and
anything else that can be stored in files. The primary difference in
terms of code is the <span class="docEmphasis">mode</span> argument passed to the
built-in open function:
</P>

<PRE>&gt;&gt;&gt; <B>file = open('data.txt', 'wb')</B>      # open binary output file
&gt;&gt;&gt; <B>file = open('data.txt', 'rb')</B>      # open binary input file</PRE>

<P class="docText">Once you've opened binary files in this way, you may read and
write their contents using the same methods just illustrated:
<TT>read</TT>, <TT>write</TT>, and so on.
(<TT>readline</TT> and <TT>readlines</TT>
don't make sense here, though: binary data isn't
line-oriented.)
</P>

<P class="docText">In all cases, data transferred between files and your programs is
represented as Python <span class="docEmphasis">strings</span> within scripts,
even if it is binary data. This works because Python string objects
can always contain character bytes of any value (though some may look
odd if printed). Interestingly, even a byte of value zero can be
embedded in a Python string; it's called <TT>\0</TT>
in escape-code notation, and does not terminate strings in Python as
it does in C. For instance:
</P>

<PRE>&gt;&gt;&gt; <B>data = "a\0b\0c"</B>
&gt;&gt;&gt; <B>data</B>
'a\000b\000c'
&gt;&gt;&gt; <B>len(data)</B>
5</PRE>

<P class="docText">Instead of relying on a terminator character, Python keeps track of a
string's length explicitly. Here, <TT>data</TT>
references a string of length 5, that happens to contain two
zero-value bytes; they print in octal escape form as
<TT>\000</TT>. Because no character codes are reserved,
it's okay to read binary data with zero bytes (and other
values) into a string in Python.
</P>



<A NAME="python2-CHP-2-SECT-11.1.5"></A>
<H5 class="docSection3Title">2.11.1.5 End-of-line translations on Windows</H5>

<P class="docText">Strictly speaking, on some platforms you may not need the
"b" at the end of the open mode argument to process
binary files; the "b" is simply ignored, so modes
"r" and "w" work just as well. In fact, the
"b" in mode flag strings is usually only required for
binary files on Windows. To understand why, though, you need to know
how lines are terminated in text files.
</P>

<P class="docText">For historical reasons, the end of a line of text in a file is
represented by different characters on different platforms:
it's a single <TT>\n</TT> character on Unix and
Linux, but the two-character sequence <TT>\r\n</TT> on
Windows.<sup class="docFootnote"><A class="docLink" HREF="#">[9]</A></sup>
That's why files moved between Linux and Windows may look odd
in your text editor after transfer -- they may still be stored
using the original platform's end-of-line convention. For
example, most Windows editors handle text in Unix format, but Notepad
is a notable exception -- text files copied from Unix or Linux
usually look like one long line when viewed in Notepad, with strange
characters inside (<TT>\n</TT>)<span class="docEmphasis">.</span>
</P>
<blockquote><p class="docFootnote"><sup><A NAME="">[9]</A></sup> Actually, it gets worse: on the Mac, lines
in text files are terminated with a single <TT>\r</TT> (not
<TT>\n</TT> or <TT>\r\n</TT>). Whoever said
proprietary software was good for the consumer probably wasn't
speaking about users of multiple platforms, and certainly
wasn't talking about programmers.</p></blockquote>

<P class="docText">Python scripts don't normally need to care, because the Windows
port (really, the underlying C compiler on Windows) automatically
maps the DOS <TT>\r\n</TT> sequence to a single
<TT>\n</TT>. It works like this -- when scripts are run
on Windows:
</P>

<UL>
<LI><P class="docList">For files opened in text mode, <TT>\r\n</TT> is translated
to <TT>\n</TT> when input.
</P></LI>
<LI><P class="docList">For files opened in text mode, <TT>\n</TT> is translated to
<TT>\r\n</TT> when output.
</P></LI>
<LI><P class="docList">For files opened in binary mode, no translation occurs on input or
output.
</P></LI>
<LI><P class="docList">On Unix-like platforms, no translations occur, regardless of open
modes.
</P></LI>
</UL>
<P class="docText">There are two important consequences of all these rules to keep in
mind. First, the end of line character is almost always represented
as a single <TT>\n</TT> in all Python scripts, regardless
of how it is stored in external files on the underlying platform. By
mapping to and from <TT>\n</TT> on input and output, the
Windows port hides the platform-specific difference.
</P>

<P class="docText">The second consequence of the mapping is more subtle: if you mean to
process <span class="docEmphasis">binary data files</span> on Windows, you
generally must be careful to open those files in binary mode
("rb", "wb"), not text mode ("r",
"w"). Otherwise, the translations listed previously could
very well corrupt data as it is input or output. It's not
impossible that binary data would by chance contain bytes with values
the same as the DOS end-line characters, <TT>\r</TT> and
<TT>\n</TT>. If you process such binary files in
<span class="docEmphasis">text</span> mode on Windows, <TT>\r</TT>
bytes may be incorrectly discarded when read, and
<TT>\n</TT> bytes may be erroneously expanded to
<TT>\r\n</TT> when written. The net effect is that your
binary data will be trashed when read and written -- probably not
quite what you want! For example, on Windows:
</P>

<PRE>&gt;&gt;&gt; <B>len('a\0b\rc\r\nd')                           </B># 4 escape code bytes
8
&gt;&gt;&gt; <B>open('temp.bin', 'wb').write('a\0b\rc\r\nd') </B> # write binary data to file

&gt;&gt;&gt; <B>open('temp.bin', 'rb').read(  )</B>                 # intact if read as binary
'a\000b\015c\015\012d'

&gt;&gt;&gt; <B>open('temp.bin', 'r').read(  )</B>                  # loses a \r in text mode!
'a\000b\015c\012d'

&gt;&gt;&gt; <B>open('temp.bin', 'w').write('a\0b\rc\r\nd')  </B> # adds a \r in text mode!
&gt;&gt;&gt; <B>open('temp.bin', 'rb').read(  )</B>
'a\000b\015c\015\015\012d'</PRE>

<P class="docText">This is only an issue when running on Windows, but using binary open
modes "rb" and "wb" for binary files
everywhere won't hurt on other platforms, and will help make
your scripts more portable (you never know when a Unix utility may
wind up seeing action on your PC).
</P>

<P class="docText">There are other times you may want to use binary file open modes too.
For instance, in <A class="docLink" HREF="0596000855_python2-CHP-5.html#python2-CHP-5">Chapter 5</A>, we'll meet a
script called <TT>fixeoln_one</TT> that translates between
DOS and Unix end-of-line character conventions in text files. Such a
script also has to open <span class="docEmphasis">text</span> files in
<span class="docEmphasis">binary</span> mode to see what end-of-line characters
are truly present on the file; in text mode, they would already be
translated to <TT>\n</TT> by the time they reached the
script.
</P>



<A NAME="python2-CHP-2-SECT-11.2"></A>
<H4 class="docSection2Title">2.11.2 File Tools in the os Module</H4>

<P class="docText">The <TT>os</TT> module contains an additional set of
file-processing functions that are distinct from the built-in file
<span class="docEmphasis">object</span> tools demonstrated in previous examples.
For instance, here is a very partial list of <TT>os</TT>
file-related calls:
</P>

<DL class="docList">
<DT><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">os.open(</span></span> <TT><I>path,</I></TT> <TT><I>flags,</I></TT> <TT><I>mode</I></TT><span class="docPubcolor"><span class="docMonofont">)</span></span>  </span></DT>
<DD>
<P class="docList">Opens a file, returns its descriptor</P>
</DD><DT><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">os.read(</span></span> <TT><I>descriptor,</I></TT> <TT><I>N</I></TT><span class="docPubcolor"><span class="docMonofont">)</span></span>  </span></DT>
<DD>
<P class="docList">Reads at most <TT><I>N</I></TT> bytes, returns a string</P>
</DD><DT><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">os.write(</span></span> <TT><I>descriptor,</I></TT> <TT><I>string</I></TT><span class="docPubcolor"><span class="docMonofont">)</span></span>  </span></DT>
<DD>
<P class="docList">Writes bytes in <TT><I>string</I></TT> to the file</P>
</DD><DT><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">os.lseek(</span></span> <TT><I>descriptor,</I></TT> <TT><I>position</I></TT><span class="docPubcolor"><span class="docMonofont">)</span></span>  </span></DT>
<DD>
<P class="docList">Moves to <TT><I>position</I></TT> in the file</P>
</DD>
</DL>

<P class="docText">Technically, <TT>os</TT> calls process files by their
<span class="docEmphasis">descriptors  --</span> integer codes or
"handles" that identify files in the operating system.
Because the descriptor-based file tools in <TT>os</TT> are
lower-level and more complex than the built-in file objects created
with the built-in <TT>open</TT> function, you should
generally use the latter for all but very special file-processing
needs.<sup class="docFootnote"><A class="docLink" HREF="#">[10]</A></sup>
</P>
<blockquote><p class="docFootnote"><sup><A NAME="">[10]</A></sup> For instance, to process
<span class="docEmphasis">pipes</span>, described in <A class="docLink" HREF="0596000855_python2-CHP-3.html#python2-CHP-3">Chapter 3</A>. The Python pipe call returns two file
descriptors, which can be processed with <TT>os</TT> module
tools or wrapped in a file object with
<TT>os.fdopen</TT>.</p></blockquote>

<P class="docText">To give you the general flavor of this tool-set, though, let's
run a few interactive experiments. Although built-in file objects and
<TT>os</TT> module descriptor files are processed with
distinct toolsets, they are in fact related -- the
<TT>stdio</TT> filesystem used by file objects simply adds
a layer of logic on top of descriptor-based files.
</P>

<P class="docText">In fact, the <TT>fileno</TT> file object method returns the
integer descriptor associated with a built-in file object. For
instance, the standard stream file objects have descriptors 0, 1, and
2; calling the <TT>os.write</TT> function to send data to
<TT>stdout</TT> by descriptor has the same effect as
calling the <TT>sys.stdout.write</TT> method:
</P>

<PRE>&gt;&gt;&gt; <B>import sys</B>
&gt;&gt;&gt; <B>for stream in (sys.stdin, sys.stdout, sys.stderr):</B>
...     <B>print stream.fileno(  ),</B>
...
0 1 2

&gt;&gt;&gt; <B>sys.stdout.write('Hello stdio world\n')        </B># write via file method
Hello stdio world

&gt;&gt;&gt; <B>import os</B>
&gt;&gt;&gt; <B>os.write(1, 'Hello descriptor world\n')    </B>    # write via os module
Hello descriptor world
23</PRE>

<P class="docText">Because file objects we open explicitly behave the same way,
it's also possible to process a given real external file on the
underlying computer, through the built-in <TT>open</TT>
function, tools in module <TT>os</TT>, or both:
</P>

<PRE>&gt;&gt;&gt; <B>file = open(r'C:\temp\spam.txt', 'w')        </B>  # create external file
&gt;&gt;&gt; <B>file.write('Hello stdio file\n')              </B> # write via file method
&gt;&gt;&gt;
&gt;&gt;&gt; <B>fd = file.fileno(  )</B>
&gt;&gt;&gt; <B>print fd</B>
3
&gt;&gt;&gt; <B>os.write(fd, 'Hello descriptor file\n')       </B> # write via os module
22
&gt;&gt;&gt; <B>file.close(  )</B>
&gt;&gt;&gt;
C:\WINDOWS&gt;<B>type c:\temp\spam.txt                </B>   # both writes show up
Hello descriptor file
Hello stdio file</PRE>

<A NAME="python2-CHP-2-SECT-11.2.1"></A>
<H5 class="docSection3Title">2.11.2.1 Open mode flags</H5>

<P class="docText">So why the extra file tools in <TT>os</TT>? In short, they
give more low-level control over file processing. The built-in
<TT>open</TT> function is easy to use, but is limited by
the underlying <TT>stdio</TT> filesystem that it
wraps -- buffering, open modes, and so on, are all per
<TT>stdio</TT> defaults.<sup class="docFootnote"><A class="docLink" HREF="#">[11]</A></sup> Module
<TT>os</TT> lets scripts be more specific; for example, the
following opens a descriptor-based file in read-write and binary
modes, by performing a binary "or" on two mode flags
exported by <TT>os</TT>:
</P>
<blockquote><p class="docFootnote"><sup><A NAME="">[11]</A></sup> To be fair to the
built-in file object, the <TT>open</TT> function accepts a
mode "rb+", which is equivalent to the combined mode
flags used here, and can also be made nonbuffered with a
buffer size argument. Whenever possible, use <TT>open</TT>,
not <TT>os.open</TT>.</p></blockquote>

<PRE>&gt;&gt;&gt; <B>fdfile = os.open(r'C:\temp\spam.txt', (os.O_RDWR | os.O_BINARY))</B>
&gt;&gt;&gt; <B>os.read(fdfile, 20)</B>
'Hello descriptor fil'
&gt;&gt;&gt; <B>os.lseek(fdfile, 0, 0)                      </B>  # go back to start of file
0
&gt;&gt;&gt; <B>os.read(fdfile, 100)                       </B>   # binary mode retains "\r\n"
'Hello descriptor file\015\012Hello stdio file\015\012'

&gt;&gt;&gt; <B>os.lseek(fdfile, 0, 0)</B>
0
&gt;&gt;&gt; <B>os.write(fdfile, 'HELLO')               </B>      # overwrite first 5 bytes
5</PRE>

<P class="docText">On some systems, such open flags let us specify more advanced things
like <span class="docEmphasis">exclusive access</span>
(<TT>O_EXCL</TT>) and <span class="docEmphasis">nonblocking</span>
modes (<TT>O_NONBLOCK</TT>) when a file is opened. Some of
these flags are not portable across platforms (another reason to use
built-in file objects most of the time); see the library manual or
run a <TT>dir(os)</TT> call on your machine for an
exhaustive list of other open flags available.
</P>

<P class="docText">We saw earlier how to go from file object to field descriptor with
the <TT>fileno</TT> file method; we can also go the other
way -- the <TT>os.fdopen</TT> call wraps a file
descriptor in a file object. Because conversions work both ways, we
can generally use either tool set -- file object, or
<TT>os</TT> module:
</P>

<PRE>&gt;&gt;&gt; <B>objfile = os.fdopen(fdfile)</B>
&gt;&gt;&gt; <B>objfile.seek(0)</B>
&gt;&gt;&gt; <B>objfile.read(  )</B>
'HELLO descriptor file\015\012Hello stdio file\015\012'</PRE>



<A NAME="python2-CHP-2-SECT-11.2.2"></A>
<H5 class="docSection3Title">2.11.2.2 Other os file tools</H5>

<P class="docText">The <TT>os</TT> module also includes an assortment of file
tools that accept a file pathname string, and accomplish file-related
tasks such as renaming (<TT>os.rename</TT>), deleting
(<TT>os.remove</TT>), and changing the file's owner
and permission settings (<TT>os.chown</TT>,
<TT>os.chmod</TT>). Let's step through a few examples
of these tools in action:
</P>

<PRE>&gt;&gt;&gt; <B>os.chmod('spam.txt', 0777)       </B>    # enabled all accesses</PRE>

<P class="docText">This <TT>os.chmod</TT> file permissions call passes a
nine-bit bitstring, composed of three sets of three bits each. From
left to right, the three sets represent the file's owning user,
the file's group, and all others. Within each set, the three
bits reflect read, write, and execute access permissions. When a bit
is "1" in this string, it means that the corresponding
operation is allowed for the assessor. For instance, octal 0777 is a
string of nine "1" bits in binary, so it enables all
three kinds of accesses, for all three user groups; octal 0600 means
that the file can be only read and written by the user that owns it
(when written in binary, 0600 octal is really bits 110 000 000).
</P>

<P class="docText">This scheme stems from Unix file permission settings, but works on
Windows as well. If it's puzzling, either check a Unix manpage
for <I>chmod</I>, or see the
<TT>fixreadonly</TT> example in <A class="docLink" HREF="0596000855_python2-CHP-5.html#python2-CHP-5">Chapter 5</A>, for a practical application (it makes
read-only files copied off a CD-ROM writable).
</P>

<PRE>&gt;&gt;&gt; <B>os.rename(r'C:\temp\spam.txt', r'C:\temp\eggs.txt')      </B># (from, to)
&gt;&gt;&gt;
&gt;&gt;&gt; <B>os.remove(r'C:\temp\spam.txt')                           </B># delete file
Traceback (innermost last):
  File "&lt;stdin&gt;", line 1, in ?
OSError: [Errno 2] No such file or directory: 'C:\\temp\\spam.txt'
&gt;&gt;&gt;
&gt;&gt;&gt; <B>os.remove(r'C:\temp\eggs.txt')</B></PRE>

<P class="docText">The <TT>os.rename</TT> call used here changes a
file's name; the <TT>os.remove</TT> file deletion
call deletes a file from your system, and is synonymous with
<TT>os.unlink</TT>; the latter reflects the call's
name on Unix, but was obscure to users of other platforms. The
<TT>os</TT> module also exports the <TT>stat</TT>
system call:
</P>

<PRE>&gt;&gt;&gt; <B>import os</B>
&gt;&gt;&gt; <B>info = os.stat(r'C:\temp\spam.txt')</B>
&gt;&gt;&gt; <B>info</B>
(33206, 0, 2, 1, 0, 0, 41, 968133600, 968176258, 968176193)

&gt;&gt;&gt; <B>import stat</B>
&gt;&gt;&gt; <B>info[stat.ST_MODE], info[stat.ST_SIZE]</B>
(33206, 41)

&gt;&gt;&gt; <B>mode = info[stat.ST_MODE]</B>
&gt;&gt;&gt; <B>stat.S_ISDIR(mode), stat.S_ISREG(mode)</B>
(0, 1)</PRE>

<P class="docText">The <TT>os.stat</TT> call returns a tuple of values giving
low-level information about the named file, and the
<TT>stat</TT> module exports constants and functions for
querying this information in a portable way. For instance, indexing
an <TT>os.stat</TT> result on offset
<TT>stat.ST_SIZE</TT> returns the file's size, and
calling <TT>stat.S_ISDIR</TT> with the mode item from an
<TT>os.stat</TT> result checks whether the file is a
directory. As shown earlier, though, both of these operations are
available in the <TT>os.path</TT> module too, so it's
rarely necessary to use <TT>os.stat</TT> except for
low-level file queries:
</P>

<PRE>&gt;&gt;&gt; <B>path = r'C:\temp\spam.txt'</B>
&gt;&gt;&gt; <B>os.path.isdir(path), os.path.isfile(path), os.path.getsize(path)</B>
(0, 1, 41)</PRE>



<A NAME="python2-CHP-2-SECT-11.3"></A>
<H4 class="docSection2Title">2.11.3 File Scanners</H4>

<P class="docText">Unlike some shell-tool languages, Python doesn't have an
implicit file-scanning loop procedure, but it's simple to write
a general one that we can reuse for all time. The module in <A class="docLink" HREF="#python2-CHP-2-EX-11">Example 2-11</A> defines a general file-scanning routine, which
simply applies a passed-in Python function to each line in an
external file.
</P>


<H5 class="docExampleTitle"><A NAME="python2-CHP-2-EX-11"></A>Example 2-11. PP2E\System\Filetools\scanfile.py </H5>
<PRE>def scanner(name, function): 
    file = open(name, 'r')              # create a file object
    while 1:
        line = file.readline(  )        # call file methods
        if not line: break              # until end-of-file
        function(line)                  # call a function object
    file.close(  ) </PRE>


<P class="docText">The <TT>scanner</TT> function doesn't care what
line-processing function is passed in, and that accounts for most of
its generality -- it is happy to apply <span class="docEmphasis">any</span>
single-argument function that exists now or in the future to all the
lines in a text file. If we code this module and put it in a
directory on PYTHONPATH, we can use it any time we need to step
through a file line-by-line. <A class="docLink" HREF="#python2-CHP-2-EX-12">Example 2-12</A> is a client
script that does simple line translations.
</P>


<H5 class="docExampleTitle"><A NAME="python2-CHP-2-EX-12"></A>Example 2-12. PP2E\System\Filetools\commands.py </H5>
<PRE>#!/usr/local/bin/python
from sys import argv
from scanfile import scanner

def processLine(line):                      # define a function
    if line[0] == '*':                      # applied to each line
        print "Ms.", line[1:-1]
    elif line[0] == '+': 
        print "Mr.", line[1:-1]             # strip 1st and last char
    else:
        raise 'unknown command', line       # raise an exception

filename = 'data.txt'
if len(argv) == 2: filename = argv[1]       # allow file name cmd arg
scanner(filename, processLine)              # start the scanner</PRE>


<P class="docText">If, for no readily obvious reason, the text file
<I>hillbillies.txt</I> contains the following lines:
</P>

<PRE>*Granny
+Jethro
*Elly-Mae
+"Uncle Jed"</PRE>

<P class="docText">then our commands script could be run as follows:</P>

<PRE>C:\...\PP2E\System\Filetools&gt;<B>python commands.py hillbillies.txt</B>
Ms. Granny
Mr. Jethro
Ms. Elly-Mae
Mr. "Uncle Jed"</PRE>

<P class="docText"><A NAME="IXT-2-336953"></A>
<A NAME="IXT-2-336954"></A><A NAME="IXT-2-336955"></A>As a rule of thumb, though, we can
usually speed things up by shifting processing from Python code to
built-in tools. For instance, if we're concerned with speed
(and memory space isn't tight), we can make our file scanner
faster by using the <TT>readlines</TT> method to load the
file into a list all at once, instead of the manual
<TT>readline</TT> loop in <A class="docLink" HREF="#python2-CHP-2-EX-11">Example 2-11</A>:
</P>

<PRE>def scanner(name, function): 
    file = open(name, 'r')              # create a file object
    for line in file.readlines(  ):       # get all lines at once    
        function(line)                  # call a function object
    file.close(  ) </PRE>

<P class="docText"><A NAME="IXT-2-336956"></A>And if we have
a list of lines, we can work more magic with the
<TT>map</TT> built-in function. Here's a
minimalist's version; the <TT>for</TT> loop is
replaced by <TT>map</TT>, and we let Python close the file
for us when it is garbage-collected (or the script exits):
</P>

<PRE>def scanner(name, function): 
    map(function, open(name, 'r').readlines(  ))</PRE>

<P class="docText">But what if we also want to <span class="docEmphasis">change</span> a file while
scanning it? <A class="docLink" HREF="#python2-CHP-2-EX-13">Example 2-13</A> shows two approaches: one
uses explicit files, and the other uses the standard input/output
streams to allow for redirection on the command line.
</P>


<H5 class="docExampleTitle"><A NAME="python2-CHP-2-EX-13"></A>Example 2-13. PP2E\System\Filetools\filters.py </H5>
<PRE>def filter_files(name, function):         # filter file through function
    input  = open(name, 'r')              # create file objects
    output = open(name + '.out', 'w')     # explicit output file too
    for line in input.readlines(  ):
        output.write(function(line))      # write the modified line
    input.close(  ) 
    output.close(  )                      # output has a '.out' suffix

def filter_stream(function):
    import sys                            # no explicit files
    while 1:                              # use standard streams
        line = sys.stdin.readline(  )     # or: raw_input(  )
        if not line: break
        print function(line),             # or: sys.stdout.write(  )

if __name__ == '__main__': 
    filter_stream(lambda line: line)      # copy stdin to stdout if run</PRE>


<P class="docText">Since the standard streams are preopened for us, they're often
easier to use. This module is more useful when imported as a library
(clients provide the line-processing function); when run standalone
it simply parrots <TT>stdin</TT> to
<TT>stdout</TT>:
</P>

<PRE>C:\...\PP2E\System\Filetools&gt;<B>python filters.py &lt; ..\System.txt</B>
This directory contains operating system interface examples.

Many of the examples in this unit appear elsewhere in the examples
distribution tree, because they are actually used to manage other
programs.  See the README.txt files in the subdirectories here
for pointers.</PRE>

<P><table border="0" bgcolor="black" cellspacing="0" cellpadding="1" width="90%" align="center"><tr><td>
<table bgcolor="white" width="100%" border="0" cellspacing="0" cellpadding="6"><tr>
<td width="60" valign="top"><img src="FILES/tip_yellow.gif" width="50" height="54"></td>
<td valign="top">
<P class="docText">Brutally observant readers may notice that this last file is named
<I>filters.py</I> (with an "s"), not
<I>filter.py</I>. I originally named it the latter, but
changed its name when I realized that a simple import of the filename
(e.g., "import filter") assigns the module to a local
name "filter," thereby hiding the built-in
<TT>filter</TT> function. This is a built-in functional
programming tool, not used very often in typical scripts; but be
careful to avoid picking built-in names for module files. I will if
you will.
</P>
</td>
</tr></table></td></tr></table></P>


<A NAME="python2-CHP-2-SECT-11.4"></A>
<H4 class="docSection2Title">2.11.4 Making Files Look Like Lists</H4>

<P class="docText">One last file-related trick has proven popular enough to merit an
introduction here. Although file objects only export method calls
(e.g., <TT>file.read( )</TT>), it is easy to use classes to
make them look more like data structures, and hide some of the
underlying file call details. The module in <A class="docLink" HREF="#python2-CHP-2-EX-14">Example 2-14</A> defines a <TT>FileList</TT> object
that "wraps" a real file to add sequential indexing
support.
</P>


<H5 class="docExampleTitle"><A NAME="python2-CHP-2-EX-14"></A>Example 2-14. PP2E\System\Filetools\filelist.py </H5>
<PRE>class FileList:
    def __init__(self, filename):
        self.file = open(filename, 'r')     # open and save file
    def __getitem__(self, i):               # overload indexing
        line = self.file.readline(  )
        if line:
            return line                     # return the next line
        else:
            raise IndexError                # end 'for' loops, 'in'
    def __getattr__(self, name):
        return getattr(self.file, name)     # other attrs from real file</PRE>


<P class="docText">This class defines three specially named methods:</P>

<UL>
<LI><P class="docList">The <TT>__init__</TT> method is called whenever a new
object is created.
</P></LI>
<LI><P class="docList">The <TT>__getitem__</TT> method intercepts indexing
operations.
</P></LI>
<LI><P class="docList">The <TT>__getattr__</TT> method handles undefined
attribute references.
</P></LI>
</UL>
<P class="docText">This class mostly just extends the built-in file object to add
indexing. Most standard file method calls are simply delegated
(passed off) to the wrapped file by <TT>__getattr__</TT>.
Each time a <TT>FileList</TT> object is indexed, though,
its <TT>__getitem__</TT> method returns the next line in
the actual file. Since <TT>for</TT> loops work by
repeatedly indexing objects, this class lets us iterate over a
wrapped file as though it were an in-memory list:
</P>

<PRE>&gt;&gt;&gt; <B>from filelist import FileList</B>
&gt;&gt;&gt; <B>for line in FileList('hillbillies.txt'):</B>
...     <B>print '&gt;', line,</B>
...
&gt; *Granny
&gt; +Jethro
&gt; *Elly-Mae
&gt; +"Uncle Jed"</PRE>

<P class="docText">This class could be made much more sophisticated and list-like too.
For instance, we might overload the <TT>+</TT> operation to
concatenate a file onto the end of an output file, allow random
indexing operations that seek among the file's lines to resolve
the specified offset, and so on. But since coding all such extensions
takes more space than I have available here, I'll leave them as
suggested exercises.
</P>



<ul></ul>
</td>
</tr>
</table>
<td></td>
<table width="100%" border="0" cellspacing="0" cellpadding="0" bgcolor="#CCCCCC">
<td><font color="black" size=1>I l<font color="#FF0000">@</font>ve RuBoard</td>
<td valign="top" class="v2" align="right">
          <a href="0596000855_python2-CHP-2-SECT-10.html"><img src="FILES/previous.gif" width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a>
          <a href="0596000855_python2-CHP-2-SECT-12.html"><img src="FILES/next.gif" width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a>
</td></table>
</body></html>
