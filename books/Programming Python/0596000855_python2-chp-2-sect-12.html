<html><head>
<META http-equiv="Content-Type" content="text/html">
<!--SafClassName="docSection1Title"--><!--SafTocEntry="2.12 Directory Tools"-->
<link rel="STYLESHEET" type="text/css" href="FILES/style.css">
<link rel="STYLESHEET" type="text/css" href="FILES/docsafari.css">
</head>
<body>
<table width="100%" border="0" cellspacing="0" cellpadding="0" bgcolor="#CCCCCC">
<td><font color="black" size=1>I l<font color="#FF0000">@</font>ve RuBoard</td>
<td valign="top" class="v2" align="right">
	<a href="0596000855_python2-CHP-2-SECT-11.html"><img src="FILES/previous.gif" width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a>
	<a href="0596000855_python2-CHP-3.html"><img src="FILES/next.gif" width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a>
</td></table>
<br>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<tr>
<td valign="top"><A NAME="python2-CHP-2-SECT-12"></A>
<H3 class="docSection1Title">2.12 Directory Tools</H3>

<P class="docText"><A NAME="python2-IDXTERM-21"></A>One
of the more common tasks in the shell utilities domain is applying an
operation to a set of files in a <span class="docEmphasis">directory
 --</span> a "folder" in Windows-speak. By running
a script on a batch of files, we can automate (that is,
<span class="docEmphasis">script</span>) tasks we might have to otherwise run
repeatedly by hand.
</P>

<P class="docText">For instance, suppose you need to search all of your Python files in
a development directory for a global variable name (perhaps
you've forgotten where it is used). There are many
platform-specific ways to do this (e.g., the <I>grep</I>
command in Unix), but Python scripts that accomplish such tasks will
work on every platform where Python works -- Windows, Unix, Linux,
Macintosh, and just about any other in common use today. Simply copy
your script to any machine you wish to use it on, and it will work,
regardless of which other tools are available there.
</P>

<A NAME="python2-CHP-2-SECT-12.1"></A>
<H4 class="docSection2Title">2.12.1 Walking One Directory</H4>

<P class="docText"><A NAME="python2-IDXTERM-22"></A>The most common way to go about
writing such tools is to first grab hold of a list of the names of
the files you wish to process, and then step through that list with a
Python <TT>for</TT> loop, processing each file in turn. The
trick we need to learn here, then, is how to get such a directory
list within our scripts. There are at least three options: running
shell listing commands with <TT>os.popen</TT>, matching
filename patterns with <TT>glob.glob</TT>, and getting
directory listings with <TT>os.listdir</TT>. They vary in
interface, result format, and portability.
</P>

<A NAME="python2-CHP-2-SECT-12.1.1"></A>
<H5 class="docSection3Title">2.12.1.1 Running shell listing commands with os.popen</H5>

<P class="docText"><A NAME="IXT-2-336957"></A>Quick: How did you go about getting
directory file listings before you heard of Python? If you're
new to shell tools programming, the answer may be: "Well, I
started a Windows file explorer and clicked on stuff," but
I'm thinking in terms of less GUI-oriented command-line
mechanisms here (and answers submitted in Perl and Tcl only get
partial credit).
</P>

<P class="docText">On Unix, directory listings are usually obtained by typing
<I>ls</I> in a shell; on Windows, they can be generated
with a <span class="docEmphasis">dir</span> command typed in an MS-DOS console
box. Because Python scripts may use <TT>os.popen</TT> to
run any command line we can type in a shell, they also are the most
general way to grab a directory listing inside a Python program. We
met <TT>os.popen</TT> earlier in this chapter; it runs a
shell command string and gives us a file object from which we can
read the command's output. To illustrate, let's first
assume the following directory structures (yes, I have both
<span class="docEmphasis">dir</span> and <I>ls</I> commands on my
Windows laptop; old habits die hard):
</P>

<PRE>C:\temp&gt;<B>dir /B</B>
about-pp.html
python1.5.tar.gz
about-pp2e.html
about-ppr2e.html
newdir

C:\temp&gt;<B>ls</B>
about-pp.html     about-ppr2e.html  python1.5.tar.gz
about-pp2e.html   newdir

C:\temp&gt;<B>ls newdir</B>
more   temp1  temp2  temp3</PRE>

<P class="docText">The <I>newdir</I> name is a nested subdirectory in
<I>C:\temp</I> here. Now, scripts can grab a listing of
file and directory names at this level by simply spawning the
appropriate platform-specific command line, and reading its output
(the text normally thrown up on the console window):
</P>

<PRE>C:\temp&gt;<B>python</B>
&gt;&gt;&gt; <B>import os</B>
&gt;&gt;&gt; <B>os.popen('dir /B').readlines(  )</B>
['about-pp.html\012', 'python1.5.tar.gz\012', 'about-pp2e.html\012', 
'about-ppr2e.html\012', 'newdir\012']</PRE>

<P class="docText">Lines read from a shell command come back with a trailing end-line
character, but it's easy enough to slice off:
</P>

<PRE>&gt;&gt;&gt; <B>for line in os.popen('dir /B').readlines(  ): </B>
...     <B>print line[:-1]</B>
...
about-pp.html
python1.5.tar.gz
about-pp2e.html
about-ppr2e.html
newdir</PRE>

<P class="docText">Both <span class="docEmphasis">dir</span> and <I>ls</I> commands
let us be specific about filename patterns to be matched and
directory names to be listed; again, we're just running shell
commands here, so anything you can type at a shell prompt goes:
</P>

<PRE>&gt;&gt;&gt; <B>os.popen('dir *.html /B').readlines(  )</B>
['about-pp.html\012', 'about-pp2e.html\012', 'about-ppr2e.html\012']

&gt;&gt;&gt; <B>os.popen('ls *.html').readlines(  )</B>
['about-pp.html\012', 'about-pp2e.html\012', 'about-ppr2e.html\012']

&gt;&gt;&gt; <B>os.popen('dir newdir /B').readlines(  )</B>
['temp1\012', 'temp2\012', 'temp3\012', 'more\012']

&gt;&gt;&gt; <B>os.popen('ls newdir').readlines(  )</B>
['more\012', 'temp1\012', 'temp2\012', 'temp3\012']</PRE>

<P class="docText">These calls use general tools and all work as advertised. As we noted
earlier, though, the downsides of <TT>os.popen</TT> are
that it is nonportable (it doesn't work well in a Windows GUI
application in Python 1.5.2 and earlier, and requires using a
platform-specific shell command), and it incurs a performance hit to
start up an independent program. The following two alternative
techniques do better on both counts.
</P>



<A NAME="python2-CHP-2-SECT-12.1.2"></A>
<H5 class="docSection3Title">2.12.1.2 The glob module</H5>

<P class="docText">The term "globbing" comes from the <TT>*</TT>
wildcard character in filename patterns -- per computing folklore,
a <TT>*</TT> matches a "glob" of characters. In
less poetic terms, globbing simply means collecting the names of all
entries in a directory -- files and subdirectories -- whose
names match a given filename pattern. In Unix shells, globbing
expands filename patterns within a command line into all matching
file- names before the command is ever run. In Python, we can do
something similar by calling the <TT>glob.glob</TT>
built-in with a pattern to expand:
</P>

<PRE>&gt;&gt;&gt; <B>import glob</B>
&gt;&gt;&gt; <B>glob.glob('*')</B>
['about-pp.html', 'python1.5.tar.gz', 'about-pp2e.html', 'about-ppr2e.html',
'newdir']

&gt;&gt;&gt; <B>glob.glob('*.html')</B>
['about-pp.html', 'about-pp2e.html', 'about-ppr2e.html']

&gt;&gt;&gt; <B>glob.glob('newdir/*')</B>
['newdir\\temp1', 'newdir\\temp2', 'newdir\\temp3', 'newdir\\more']</PRE>

<P class="docText">The <TT>glob</TT> call accepts the usual filename pattern
syntax used in shells (e.g., <TT>?</TT> means any one
character, <TT>*</TT> means any number of characters, and
<TT>[]</TT> is a character selection set).<sup class="docFootnote"><A class="docLink" HREF="#">[12]</A></sup> The pattern should include a directory
path if you wish to glob in something other than the current working
directory, and the module accepts either Unix or DOS-style directory
separators (/ or \). This call also is implemented without spawning a
shell command, and so is likely to be faster and more portable across
all Python platforms than the <TT>os.popen</TT> schemes
shown earlier.
</P>
<blockquote><p class="docFootnote"><sup><A NAME="">[12]</A></sup> In fact, <TT>glob</TT> just uses the standard
<TT>fnmatch</TT> module to match name patterns; see the
<TT>fnmatch</TT> description later in this chapter in <A class="docLink" HREF="#python2-CHP-2-SECT-12.3">Section 2.12.3</A> for more
details.</p></blockquote>

<P class="docText">Technically speaking, <TT>glob</TT> is a bit more powerful
than described so far. In fact, using it to list files in one
directory is just one use of its pattern-matching skills. For
instance, it can also be used to collect matching names across
multiple directories, simply because each level in a passed-in
directory path can be a pattern too:
</P>

<PRE>C:\temp&gt;<B>python</B>
&gt;&gt;&gt; <B>import glob</B>
&gt;&gt;&gt; <B>for name in glob.glob('*examples/L*.py'): print name</B>
...
cpexamples\Launcher.py
cpexamples\Launch_PyGadgets.py
cpexamples\LaunchBrowser.py
cpexamples\launchmodes.py
examples\Launcher.py
examples\Launch_PyGadgets.py
examples\LaunchBrowser.py
examples\launchmodes.py

&gt;&gt;&gt; <B>for name in glob.glob(r'*\*\visitor_find*.py'): print name</B>
...
cpexamples\PyTools\visitor_find.py
cpexamples\PyTools\visitor_find_quiet2.py
cpexamples\PyTools\visitor_find_quiet1.py
examples\PyTools\visitor_find.py
examples\PyTools\visitor_find_quiet2.py
examples\PyTools\visitor_find_quiet1.py</PRE>

<P class="docText">In the first call here, we get back filenames from two different
directories that matched the <TT>*examples</TT> pattern; in
the second, both of the first directory levels are wildcards, so
Python collects all possible ways to reach the base filenames. Using
<TT>os.popen</TT> to spawn shell commands only achieves the
same effect if the underlying shell or listing command does too.
</P>



<A NAME="python2-CHP-2-SECT-12.1.3"></A>
<H5 class="docSection3Title">2.12.1.3 The os.listdir call</H5>

<P class="docText">The <TT>os</TT> module's <TT>listdir</TT>
call provides yet another way to collect filenames in a Python list.
It takes a simple directory name string, not a filename pattern, and
returns a list containing the names of all entries in that
directory -- both simple files and nested directories -- for
use in the calling script:
</P>

<PRE>&gt;&gt;&gt; <B>os.listdir('.')</B>
['about-pp.html', 'python1.5.tar.gz', 'about-pp2e.html', 'about-ppr2e.html',
'newdir']

&gt;&gt;&gt; <B>os.listdir(os.curdir)</B>
['about-pp.html', 'python1.5.tar.gz', 'about-pp2e.html', 'about-ppr2e.html',
'newdir']

&gt;&gt;&gt; <B>os.listdir('newdir')</B>
['temp1', 'temp2', 'temp3', 'more']</PRE>

<P class="docText">This too is done without resorting to shell commands, and so is
portable to all major Python platforms. The result is not in any
particular order (but can be sorted with the list
<TT>sort</TT> method), returns base filenames without their
directory path prefixes, and includes names of both files and
directories at the listed level.
</P>

<P class="docText"><A NAME="IXT-2-336958"></A>To compare all three listing techniques,
let's run them side by side on an explicit directory here. They
differ in some ways but are mostly just variations on a
theme -- <TT>os.popen</TT> sorts names and returns
end-of-lines, <TT>glob.glob</TT> accepts a pattern and
returns filenames with directory prefixes, and
<TT>os.listdir</TT> takes a simple directory name and
returns names without directory prefixes:
</P>

<PRE>&gt;&gt;&gt; <B>os.popen('ls C:\PP2ndEd').readlines(  )</B>
['README.txt\012', 'cdrom\012', 'chapters\012', 'etc\012', 'examples\012',
'examples.tar.gz\012', 'figures\012', 'shots\012']

&gt;&gt;&gt; <B>glob.glob('C:\PP2ndEd\*')</B>
['C:\\PP2ndEd\\examples.tar.gz', 'C:\\PP2ndEd\\README.txt', 
'C:\\PP2ndEd\\shots', 'C:\\PP2ndEd\\figures', 'C:\\PP2ndEd\\examples',
'C:\\PP2ndEd\\etc', 'C:\\PP2ndEd\\chapters', 'C:\\PP2ndEd\\cdrom']

&gt;&gt;&gt; <B>os.listdir('C:\PP2ndEd')</B>
['examples.tar.gz', 'README.txt', 'shots', 'figures', 'examples', 'etc',
'chapters', 'cdrom']</PRE>

<P class="docText">Of these three, <TT>glob</TT> and
<TT>listdir</TT> are generally better options if you care
about script portability, and <TT>listdir</TT> seems
fastest in recent Python releases (but gauge its performance
yourself -- implementations may change over time).
</P>



<A NAME="python2-CHP-2-SECT-12.1.4"></A>
<H5 class="docSection3Title">2.12.1.4 Splitting and joining listing results</H5>

<P class="docText">In the last example, I pointed out that <TT>glob</TT>
returns names with directory paths, but <TT>listdir</TT>
gives raw base filenames. For convenient processing, scripts often
need to split <TT>glob</TT> results into base files, or
expand <TT>listdir</TT> results into full paths. Such
translations are easy if we let the <TT>os.path</TT> module
do all the work for us. For example, a script that intends to copy
all files elsewhere will typically need to first split off the base
filenames from <TT>glob</TT> results so it can add
different directory names on the front:
</P>

<PRE>&gt;&gt;&gt; <B>dirname = r'C:\PP2ndEd'</B>
&gt;&gt;&gt; <B>for file in glob.glob(dirname + '/*'):</B>
...     <B>head, tail = os.path.split(file)</B>
...     <B>print head, tail, '=&gt;', ('C:\\Other\\' + tail)</B>
...
C:\PP2ndEd examples.tar.gz =&gt; C:\Other\examples.tar.gz
C:\PP2ndEd README.txt =&gt; C:\Other\README.txt
C:\PP2ndEd shots =&gt; C:\Other\shots
C:\PP2ndEd figures =&gt; C:\Other\figures
C:\PP2ndEd examples =&gt; C:\Other\examples
C:\PP2ndEd etc =&gt; C:\Other\etc
C:\PP2ndEd chapters =&gt; C:\Other\chapters
C:\PP2ndEd cdrom =&gt; C:\Other\cdrom</PRE>

<P class="docText">Here, the names after the <TT>=&gt;</TT> represent names
that files might be moved to. Conversely, a script that means to
process all files in a different directory than the one it runs in
will probably need to prepend <TT>listdir</TT> results with
the target directory name, before passing filenames on to other
tools:
</P>

<A NAME="IXTR3-55"></A><PRE>&gt;&gt;&gt; <B>for file in os.listdir(dirname):</B>
...     <B>print os.path.join(dirname, file)</B>
...
C:\PP2ndEd\examples.tar.gz
C:\PP2ndEd\README.txt
C:\PP2ndEd\shots
C:\PP2ndEd\figures
C:\PP2ndEd\examples
C:\PP2ndEd\etc
C:\PP2ndEd\chapters
C:\PP2ndEd\cdrom</PRE>



<A NAME="python2-CHP-2-SECT-12.2"></A>
<H4 class="docSection2Title">2.12.2 Walking Directory Trees</H4>

<P class="docText"><A NAME="python2-IDXTERM-25"></A>Notice,
though, that all of the preceding techniques only return the names of
files in a <span class="docEmphasis">single</span> directory. What if you want to
apply an operation to every file in every directory and subdirectory
in a directory tree?
</P>

<P class="docText">For instance, suppose again that we need to find every occurrence of
a global name in our Python scripts. This time, though, our scripts
are arranged into a module <span class="docEmphasis">package</span> : a directory
with nested subdirectories, which may have subdirectories of their
own. We could rerun our hypothetical single-directory searcher in
every directory in the tree manually, but that's tedious,
error-prone, and just plain no fun.
</P>

<P class="docText">Luckily, in Python it's almost as easy to process a directory
tree as it is to inspect a single directory. We can either collect
names ahead of time with the <TT>find</TT> module, write a
recursive routine to traverse the tree, or use a tree-walker utility
built-in to the <TT>os</TT> module. Such tools can be used
to search, copy, compare, and otherwise process arbitrary directory
trees on any platform that Python runs on (and that's just
about everywhere).
</P>

<A NAME="python2-CHP-2-SECT-12.2.1"></A>
<H5 class="docSection3Title">2.12.2.1 The find module</H5>

<P class="docText">The first way to go hierarchical is to collect a list of all names in
a directory tree ahead of time, and step through that list in a loop.
Like the single-directory tools we just met, a call to the
<TT>find.find</TT> built-in returns a list of both file and
directory names. Unlike the tools described earlier,
<TT>find.find</TT> also returns pathnames of matching files
nested in subdirectories, all the way to the bottom of a tree:
</P>

<PRE>C:\temp&gt;<B>python</B>
&gt;&gt;&gt; <B>import find</B>
&gt;&gt;&gt; <B>find.find('*')</B>
['.\\about-pp.html', '.\\about-pp2e.html', '.\\about-ppr2e.html', 
'.\\newdir', '.\\newdir\\more', '.\\newdir\\more\\xxx.txt',
'.\\newdir\\more\\yyy.txt', '.\\newdir\\temp1', '.\\newdir\\temp2',
'.\\newdir\\temp3', '.\\python1.5.tar.gz']

&gt;&gt;&gt; <B>for line in find.find('*'): print line</B>
...
.\about-pp.html
.\about-pp2e.html
.\about-ppr2e.html
.\newdir
.\newdir\more
.\newdir\more\xxx.txt
.\newdir\more\yyy.txt
.\newdir\temp1
.\newdir\temp2
.\newdir\temp3
.\python1.5.tar.gz</PRE>

<P class="docText">We get back a list of full pathnames, that each include the top-level
directory's path. By default, find collects names matching the
passed-in pattern in the tree rooted at the current working
directory, known as ".". If we want a more specific list,
we can pass in both a filename pattern and a directory tree root to
start at; here's how to collect HTML filenames at
"." and below:
</P>

<PRE>&gt;&gt;&gt; <B>find.find('*.html', '.')</B>
['.\\about-pp.html', '.\\about-pp2e.html', '.\\about-ppr2e.html']</PRE>

<P class="docText"><A NAME="IXT-2-336959"></A>Incidentally,
<TT>find.find</TT> is also the Python library's
equivalent to platform-specific shell commands such as a
<I>find -print</I> on Unix and Linux, and <I>dir /B
/S</I> on DOS and Windows. Since we can usually run such shell
commands in a Python script with <TT>os.popen</TT>, the
following does the same work as <TT>find.find</TT>, but is
inherently nonportable, and must start up a separate program along
the way:
</P>

<PRE>&gt;&gt;&gt; <B>import os</B>
&gt;&gt;&gt; <B>for line in os.popen('dir /B /S').readlines(  ): print line,</B>
...
C:\temp\about-pp.html
C:\temp\python1.5.tar.gz
C:\temp\about-pp2e.html
C:\temp\about-ppr2e.html
C:\temp\newdir
C:\temp\newdir\temp1
C:\temp\newdir\temp2
C:\temp\newdir\temp3
C:\temp\newdir\more
C:\temp\newdir\more\xxx.txt
C:\temp\newdir\more\yyy.txt</PRE>

<P><table border="0" bgcolor="black" cellspacing="0" cellpadding="1" width="90%" align="center"><tr><td>
<table bgcolor="white" width="100%" border="0" cellspacing="0" cellpadding="6"><tr>
<td width="60" valign="top"><img src="FILES/tip_yellow.gif" width="50" height="54"></td>
<td valign="top">
<P class="docText">If the <TT>find</TT> calls don't seem to work in your
Python, try changing the import statement used to load the module
from <TT>import</TT> <TT>find</TT> to
<TT>from</TT> <TT>PP2E.PyTools</TT>
<TT>import</TT> <TT>find</TT>. Alas, the Python
standard library's <TT>find</TT> module has been
marked as "deprecated" as of Python 1.6. That means it
may be deleted from the standard Python distribution in the future,
so pay attention to the next section; we'll use its topic later
to write our own <TT>find</TT> module -- one that is
also shipped on this book's CD (see <A class="docLink" target="_blank" HREF="http://examples.oreilly.com/python2">http://examples.oreilly.com/python2</A>).
</P>
</td>
</tr></table></td></tr></table></P>



<A NAME="python2-CHP-2-SECT-12.2.2"></A>
<H5 class="docSection3Title">2.12.2.2 The os.path.walk visitor</H5>

<P class="docText"><A NAME="python2-IDXTERM-27"></A>To make it easy to apply an operation to
all files in a tree, Python also comes with a utility that scans
trees for us, and runs a provided function at every directory along
the way. The <TT>os.path.walk</TT> function is called with
a directory root, function object, and optional data item, and walks
the tree at the directory root and below. At each directory, the
function object passed in is called with the optional data item, the
name of the current directory, and a list of filenames in that
directory (obtained from <TT>os.listdir</TT>). Typically,
the function we provide scans the filenames list to process files at
each directory level in the tree.
</P>

<P class="docText">That description might sound horribly complex the first time you hear
it, but <TT>os.path.walk</TT> is fairly straightforward
once you get the hang of it. In the following code, for example, the
<TT>lister</TT> function is called from
<TT>os.path.walk</TT> at each directory in the tree rooted
at ".". Along the way, <TT>lister</TT> simply
prints the directory name, and all the files at the current level
(after prepending the directory name). It's simpler in Python
than in English:
</P>

<PRE>&gt;&gt;&gt; <B>import os</B>
&gt;&gt;&gt; <B>def lister(dummy, dirname, filesindir):</B>
...     <B>print '[' + dirname + ']'</B>
...     <B>for fname in filesindir:</B>
...         <B>print os.path.join(dirname, fname)       </B>  # handle one file
...
&gt;&gt;&gt; <B>os.path.walk('.', lister, None)</B>
[.]
.\about-pp.html
.\python1.5.tar.gz
.\about-pp2e.html
.\about-ppr2e.html
.\newdir
[.\newdir]
.\newdir\temp1
.\newdir\temp2
.\newdir\temp3
.\newdir\more
[.\newdir\more]
.\newdir\more\xxx.txt
.\newdir\more\yyy.txt</PRE>

<P class="docText">In other words, we've coded our own custom and easily changed
recursive directory listing tool in Python. Because this may be
something we would like to tweak and reuse elsewhere, let's
make it permanently available in a module file, shown in <A class="docLink" HREF="#python2-CHP-2-EX-15">Example 2-15</A>, now that we've worked out the details
interactively.
</P>


<H5 class="docExampleTitle"><A NAME="python2-CHP-2-EX-15"></A>Example 2-15. PP2E\System\Filetools\lister_walk.py </H5>
<PRE># list file tree with os.path.walk
import sys, os

def lister(dummy, dirName, filesInDir):              # called at each dir
    print '[' + dirName + ']'
    for fname in filesInDir:                         # includes subdir names
        path = os.path.join(dirName, fname)          # add dir name prefix
        if not os.path.isdir(path):                  # print simple files only
            print path

if __name__ == '__main__':
    os.path.walk(sys.argv[1], lister, None)          # dir name in cmdline</PRE>


<P class="docText">This is the same code, except that directory names are filtered out
of the filenames list by consulting the
<TT>os.path.isdir</TT> test, to avoid listing them twice
(see -- it's been tweaked already). When packaged this way,
the code can also be run from a shell command line. Here it is being
launched from a different directory, with the directory to be listed
passed in as a command-line argument:
</P>

<PRE>C:\...\PP2E\System\Filetools&gt;<B>python lister_walk.py C:\Temp</B>
[C:\Temp]
C:\Temp\about-pp.html
C:\Temp\python1.5.tar.gz
C:\Temp\about-pp2e.html
C:\Temp\about-ppr2e.html
[C:\Temp\newdir]
C:\Temp\newdir\temp1
C:\Temp\newdir\temp2
C:\Temp\newdir\temp3
[C:\Temp\newdir\more]
C:\Temp\newdir\more\xxx.txt
C:\Temp\newdir\more\yyy.txt</PRE>

<P class="docText">The <TT>walk</TT> paradigm also allows functions to tailor
the set of directories visited by changing the file list argument in
place. The library manual documents this further, but it's
probably more instructive to simply know what <TT>walk</TT>
truly looks like. Here is its actual Python-coded implementation for
Windows platforms, with comments added to help demystify its
operation:
</P>

<PRE>def walk(top, func, arg):                  # top is the current dirname
    try:
        names = os.listdir(top)            # get all file/dir names here
    except os.error:                       # they have no path prefix
        return
    func(arg, top, names)                  # run func with names list here
    exceptions = ('.', '..')
    for name in names:                     # step over the very same list
        if name not in exceptions:         # but skip self/parent names
            name = join(top, name)         # add path prefix to name
            if isdir(name):
                walk(name, func, arg)      # descend into subdirs here</PRE>

<P class="docText">Notice that <TT>walk</TT> generates filename lists at each
level with <TT>os.listdir</TT>, a call that collects both
file and directory names in no particular order, and returns them
without their directory paths. Also note that <TT>walk</TT>
uses the very same list returned by <TT>os.listdir</TT> and
passed to the function you provide, to later descend into
subdirectories (variable <TT>names</TT>). Because lists are
mutable objects that can be changed in place, if your function
modifies the passed-in filenames list, it will impact what
<TT>walk</TT> does next. For example, deleting directory
names will prune traversal branches, and sorting the list will order
the walk. <A NAME="IXTR3-56"></A>
</P>



<A NAME="python2-CHP-2-SECT-12.2.3"></A>
<H5 class="docSection3Title">2.12.2.3 Recursive os.listdir traversals</H5>

<P class="docText">The <TT>os.path.walk</TT> tool does tree traversals for us,
but it's sometimes more flexible, and hardly any more work, to
do it ourself. The following script recodes the directory listing
script with a manual recursive traversal function. The
<TT>mylister</TT> function in <A class="docLink" HREF="#python2-CHP-2-EX-16">Example 2-16</A>
is almost the same as <TT>lister</TT> in the prior script,
but calls <TT>os.listdir</TT> to generate file paths
manually, and calls itself recursively to descend into
subdirectories.
</P>


<H5 class="docExampleTitle"><A NAME="python2-CHP-2-EX-16"></A>Example 2-16. PP2E\System\Filetools\lister_recur.py </H5>
<PRE># list files in dir tree by recursion
import sys, os

def mylister(currdir):
    print '[' + currdir + ']'
    for file in os.listdir(currdir):              # list files here
        path = os.path.join(currdir, file)        # add dir path back
        if not os.path.isdir(path):
            print path
        else:
            mylister(path)                        # recur into subdirs

if __name__ == '__main__': 
    mylister(sys.argv[1])                         # dir name in cmdline</PRE>


<P class="docText">This version is packaged as a script too (this is definitely too much
code to type at the interactive prompt); its output is identical when
run as a script:
</P>

<PRE>C:\...\PP2E\System\Filetools&gt;<B>python lister_recur.py C:\Temp</B>
[C:\Temp]
C:\Temp\about-pp.html
C:\Temp\python1.5.tar.gz
C:\Temp\about-pp2e.html
C:\Temp\about-ppr2e.html
[C:\Temp\newdir]
C:\Temp\newdir\temp1
C:\Temp\newdir\temp2
C:\Temp\newdir\temp3
[C:\Temp\newdir\more]
C:\Temp\newdir\more\xxx.txt
C:\Temp\newdir\more\yyy.txt</PRE>

<P class="docText">But this file is just as useful when imported and called elsewhere:</P>

<PRE>C:\temp&gt;<B>python</B>
&gt;&gt;&gt; <B>from PP2E.System.Filetools.lister_recur import mylister</B>
&gt;&gt;&gt; <B>mylister('.')</B>
[.]
.\about-pp.html
.\python1.5.tar.gz
.\about-pp2e.html
.\about-ppr2e.html
[.\newdir]
.\newdir\temp1
.\newdir\temp2
.\newdir\temp3
[.\newdir\more]
.\newdir\more\xxx.txt
.\newdir\more\yyy.txt</PRE>

<P class="docText">We will make better use of most of this section's techniques in
later examples in <A class="docLink" HREF="0596000855_python2-CHP-5.html#python2-CHP-5">Chapter 5</A>, and this book at
large. For example, scripts for copying and comparing directory trees
use the tree-walker techniques listed previously. Watch for these
tools in action along the way. If you are interested in directory
processing, also see the coverage of Python's old
<TT>grep</TT> module in <A class="docLink" HREF="0596000855_python2-CHP-5.html#python2-CHP-5">Chapter 5</A>; it
searches files, and can be applied to all files in a directory when
combined with the <TT>glob</TT> module, but simply prints
results and does not traverse directory trees by itself.<A NAME="IXTR3-57"></A>
</P>



<A NAME="python2-CHP-2-SECT-12.3"></A>
<H4 class="docSection2Title">2.12.3 Rolling Your Own find Module</H4>

<P class="docText">Over the last eight years, I've learned to trust Python's
Benevolent Dictator. Guido generally does the right thing, and if you
don't think so, it's usually only because you
haven't yet realized how your own position is flawed. Trust me
on this. On the other hand, it's not completely clear why the
standard <TT>find</TT> module I showed you seems to have
fallen into deprecation; it's a useful tool. In fact, I use it
a lot -- it is often nice to be able to grab a list of files to
process in a single function call, and step through it in a
<TT>for</TT> loop. The
alternatives -- <TT>os.path.walk</TT>, and recursive
functions -- are more code-y, and tougher for beginners to digest.
</P>

<P class="docText">I suppose the <TT>find</TT> module's followers (if
there be any) could have defended it in long, drawn-out debates on
the Internet, that would have spanned days or weeks, been joined by a
large cast of heroic combatants, and gone just about nowhere. I
decided to spend ten minutes whipping up a custom alternative
instead. The module in <A class="docLink" HREF="#python2-CHP-2-EX-17">Example 2-17</A> uses the standard
<TT>os.path.walk</TT> call described earlier to reimplement
a find operation for Python.<A NAME="python2-IDXTERM-30"></A>
</P>


<H5 class="docExampleTitle"><A NAME="python2-CHP-2-EX-17"></A>Example 2-17. PP2E\PyTools\find.py </H5>
<PRE>#!/usr/bin/python
########################################################
# custom version of the now deprecated find module 
# in the standard library--import as "PyTools.find";
# equivalent to the original, but uses os.path.walk,
# has no support for pruning subdirs in the tree, and
# is instrumented to be runnable as a top-level script;
# results list sort differs slightly for some trees;
# exploits tuple unpacking in function argument lists;
########################################################

import fnmatch, os

def find(pattern, startdir=os.curdir):
    matches = []
    os.path.walk(startdir, findvisitor, (matches, pattern))
    matches.sort(  )
    return matches

def findvisitor((matches, pattern), thisdir, nameshere):
    for name in nameshere:
        if fnmatch.fnmatch(name, pattern):
            fullpath = os.path.join(thisdir, name)
            matches.append(fullpath)

if __name__ == '__main__':
    import sys
    namepattern, startdir = sys.argv[1], sys.argv[2]
    for name in find(namepattern, startdir): print name</PRE>


<P class="docText">There's not much to this file; but calling its
<TT>find</TT> function provides the same utility as the
deprecated <TT>find</TT> standard module, and is noticeably
easier than rewriting all of this file's code every time you
need to perform a find-type search. To process every Python file in a
tree, for instance, I simply type:
</P>

<PRE>from PP2E.PyTools import find
for name in find.find('*.py'):
    ...do something with name...</PRE>

<P class="docText">As a more concrete example, I use the following simple script to
clean out any old output text files located anywhere in the book
examples tree:
</P>

<PRE>C:\...\PP2E&gt;<B>type PyTools\cleanoutput.py</B>
import os                                  # delete old output files in tree
from PP2E.PyTools.find import find         # only need full path if I'm moved
for filename in find('*.out.txt'):         # use cat instead of type in Linux
    print filename
    if raw_input('View?') == 'y':
        os.system('type ' + filename)
    if raw_input('Delete?') == 'y':
        os.remove(filename)

C:\temp\examples&gt;<B>python %X%\PyTools\cleanoutput.py</B>
.\Internet\Cgi-Web\Basics\languages.out.txt
View?
Delete?
.\Internet\Cgi-Web\PyErrata\AdminTools\dbaseindexed.out.txt
View?
Delete?<B>y</B></PRE>

<P class="docText">To achieve such code economy, the custom <TT>find</TT>
module calls <TT>os.path.walk</TT> to register a function
to be called per directory in the tree, and simply adds matching
filenames to the result list along the way.
</P>

<P class="docText">New here, though, is the <TT>fnmatch</TT> module -- a
standard Python module that performs Unix-like pattern matching
against filenames, and was also used by the original
<TT>find</TT>. This module supports common operators in
name pattern strings: <TT>*</TT> (to match any number of
characters), <TT>?</TT> (to match any single character),
and <TT>[...]</TT> and <TT>[!...]</TT> (to match
any character inside the bracket pairs, or not); other characters
match themselves.<sup class="docFootnote"><A class="docLink" HREF="#">[13]</A></sup> To make sure that this
alternative's results are similar, I also wrote the test module
shown in <A class="docLink" HREF="#python2-CHP-2-EX-18">Example 2-18</A>.
</P>
<blockquote><p class="docFootnote"><sup><A NAME="">[13]</A></sup> Unlike the <TT>re</TT>
module, <TT>fnmatch</TT> supports only common Unix shell
matching operators, not full-blown regular expression patterns; to
understand why this matters, see <A class="docLink" HREF="0596000855_python2-CHP-18.html#python2-CHP-18">Chapter 18</A> for
more details.</p></blockquote>


<H5 class="docExampleTitle"><A NAME="python2-CHP-2-EX-18"></A>Example 2-18. PP2E\PyTools\find-test.py </H5>
<PRE>############################################################
# test custom find; the builtin find module is deprecated:
# if it ever goes away completely, replace all "import find"
# with "from PP2E.PyTools import find" (or add PP2E\PyTools
# to your path setting and just "import find"); this script 
# takes 4 seconds total time on my 650mhz Win98 notebook to
# run 10 finds over a directory tree of roughly 1500 names; 
############################################################

import sys, os, string
for dir in sys.path:
    if string.find(os.path.abspath(dir), 'PyTools') != -1:
        print 'removing', repr(dir)
        sys.path.remove(dir)   # else may import both finds from PyTools, '.'!

import find                    # get deprecated builtin (for now)
import PP2E.PyTools.find       # later use: from PP2E.PyTools import find
print  find
print  PP2E.PyTools.find

assert find.find != PP2E.PyTools.find.find        # really different?
assert string.find(str(find), 'Lib') != -1        # should be after path remove
assert string.find(str(PP2E.PyTools.find), 'PyTools') != -1 

startdir = r'C:\PP2ndEd\examples\PP2E'
for pattern in ('*.py', '*.html', '*.c', '*.cgi', '*'):
    print pattern, '=&gt;'
    list1 = find.find(pattern, startdir)
    list2 = PP2E.PyTools.find.find(pattern, startdir)
    print len(list1), list1[-1]
    print len(list2), list2[-1]
    print list1 == list2,; list1.sort(  ); print list1 == list2</PRE>


<P class="docText">There is some magic at the top of this script that I need to explain.
To make sure that it can load both the standard library's find
module <span class="docEmphasis">and</span> the custom one in
<I>PP2E\PyTools</I>, it must delete the entry (or
entries) on the module search path that point to the
<I>PP2E\PyTools</I> directory, and import the custom
version with a full package
directory -- <TT>PP2E.PyTools.find</TT>. If not,
we'd always get the same find module, the one in
<I>PyTools</I>, no matter where this script is run
from.
</P>

<P class="docText">Here's why. Recall that Python always adds the directory
containing a script being run to the <span class="docEmphasis">front</span> of
<TT>sys.path</TT>. If we didn't delete that entry
here, the <TT>import</TT> <TT>find</TT> statement
would always load the custom find in <TT>PyTools</TT>,
because the custom <I>find.py</I> module is in the same
directory as the <I>find-test.py</I> script. The
script's home directory would effectively hide the standard
library's find. If that doesn't make sense, go back and
reread <A class="docLink" HREF="0596000855_python2-CHP-2-SECT-7.html#python2-CHP-2-SECT-7">Section 2.7</A> earlier in
this chapter.
</P>

<P class="docText">Below is the output of this tester, along with a few command-line
invocations; unlike the original find, the custom version in <A class="docLink" HREF="#python2-CHP-2-EX-18">Example 2-18</A> can be run as a command-line tool too. If you
study the test output closely, you'll notice that the custom
find differs only in an occasional sort order that I won't go
into further here (the original find module used a recursive
function, not <TT>os.path.walk</TT>); the "0 1"
lines mean that results differ in order, but not content. Since find
callers don't generally depend on precise filename result
ordering, this is trivial:<A NAME="IXTR3-58"></A>
</P>

<PRE>C:\temp&gt;<B>python %X%\PyTools\find-test.py</B>
removing 'C:\\PP2ndEd\\examples\\PP2E\\PyTools'
&lt;module 'find' from 'C:\Program Files\Python\Lib\find.pyc'&gt;
&lt;module 'PP2E.PyTools.find' from 'C:\PP2ndEd\examples\PP2E\PyTools\find.pyc'&gt;
<B>*.py</B> =&gt;
657 C:\PP2ndEd\examples\PP2E\tounix.py
657 C:\PP2ndEd\examples\PP2E\tounix.py
0 1
<B>*.html =&gt;</B>
37 C:\PP2ndEd\examples\PP2E\System\Filetools\template.html
37 C:\PP2ndEd\examples\PP2E\System\Filetools\template.html
1 1
<B>*.c =&gt;</B>
46 C:\PP2ndEd\examples\PP2E\Other\old-Integ\embed.c
46 C:\PP2ndEd\examples\PP2E\Other\old-Integ\embed.c
0 1
<B>*.cgi =&gt;</B>
24 C:\PP2ndEd\examples\PP2E\Internet\Cgi-Web\PyMailCgi\onViewSubmit.cgi
24 C:\PP2ndEd\examples\PP2E\Internet\Cgi-Web\PyMailCgi\onViewSubmit.cgi
1 1
<B>* =&gt;</B>
1519 C:\PP2ndEd\examples\PP2E\xferall.linux.csh
1519 C:\PP2ndEd\examples\PP2E\xferall.linux.csh
0 1

C:\temp&gt;<B>python %X%\PyTools\find.py *.cxx C:\PP2ndEd\examples\PP2E</B>
C:\PP2ndEd\examples\PP2E\Extend\Swig\Shadow\main.cxx
C:\PP2ndEd\examples\PP2E\Extend\Swig\Shadow\number.cxx

C:\temp&gt;<B>python %X%\PyTools\find.py *.asp C:\PP2ndEd\examples\PP2E</B>
C:\PP2ndEd\examples\PP2E\Internet\Other\asp-py.asp

C:\temp&gt;<B>python %X%\PyTools\find.py *.i C:\PP2ndEd\examples\PP2E</B>
C:\PP2ndEd\examples\PP2E\Extend\Swig\Environ\environ.i
C:\PP2ndEd\examples\PP2E\Extend\Swig\Shadow\number.i
C:\PP2ndEd\examples\PP2E\Extend\Swig\hellolib.i

C:\temp&gt;<B>python %X%\PyTools\find.py setup*.csh C:\PP2ndEd\examples\PP2E</B>
C:\PP2ndEd\examples\PP2E\Config\setup-pp-embed.csh
C:\PP2ndEd\examples\PP2E\Config\setup-pp.csh
C:\PP2ndEd\examples\PP2E\EmbExt\Exports\ClassAndMod\setup-class.csh
C:\PP2ndEd\examples\PP2E\Extend\Swig\setup-swig.csh

[filename sort scheme]
C:\temp&gt; <B>python</B>
&gt;&gt;&gt; l = ['ccc', 'bbb', 'aaa', 'aaa.xxx', 'aaa.yyy', 'aaa.xxx.nnn']
&gt;&gt;&gt; l.sort(  )
&gt;&gt;&gt; l
['aaa', 'aaa.xxx', 'aaa.xxx.nnn', 'aaa.yyy', 'bbb', 'ccc']</PRE>

<P class="docText">Finally, if an example in this book fails in a future Python release
because there is no <TT>find</TT> to be found, simply
change find-module imports in the source code to say
<TT>from</TT> <TT>PP2E.PyTools</TT>
<TT>import</TT> <TT>find</TT> instead of
<TT>import</TT> <TT>find</TT>. The former form
will find the custom <TT>find</TT> module in the
book's example package directory tree; the old module in the
standard Python library is ignored (if it is still there at all). And
if you are brave enough to add the <I>PP2E\PyTools</I>
directory itself to your PYTHONPATH setting, all original
<TT>import</TT> <TT>find</TT> statements will
continue to work unchanged.
</P>

<P class="docText">Better still, do nothing at all -- most find-based examples in
this book automatically pick the alternative by catching import
exceptions, just in case they aren't located in the
<I>PyTools</I> directory:
</P>

<PRE>try:
    import find
except ImportError:
    from PP2E.PyTools import find</PRE>

<P class="docText">The <TT>find</TT> module may be gone, but it need not be
forgotten.
</P>

<P><A NAME="python2-CHP-2-SIDEBAR-6"></A><TABLE CELLSPACING="0" WIDTH="90%" BORDER="1"><TR><TD>
<H2 class="docSidebarTitle">Python Versus csh</H2>

<P class="docText">If you are familiar with other common shell script languages, it
might be useful to see how Python compares. Here is a simple script
in a Unix shell language called <TT>csh</TT> that mails all
the files in the current working directory having a suffix of
<I>.py</I> (i.e., all Python source files) to a
hopefully fictitious address:<A NAME="IXT-2-336960"></A>
</P>

<PRE>#!/bin/csh
foreach x (*.py)
    echo $x
    mail eric@halfabee.com -s $x &lt; $x
end</PRE>

<P class="docText">The equivalent Python script looks similar:</P>

<PRE>#!/usr/bin/python
import os, glob
for x in glob.glob('*.py'):
    print x
    os.system('mail eric@halfabee.com -s %s &lt; %s' % (x, x))</PRE>

<P class="docText">but is slightly more verbose. Since Python, unlike
<TT>csh</TT>, isn't meant just for shell scripts,
system interfaces must be imported, and called explicitly. And since
Python isn't just a string-processing language, character
strings must be enclosed in quotes as in C.
</P>

<P class="docText">Although this can add a few extra keystrokes in simple scripts like
this, being a general-purpose language makes Python a better tool,
once we leave the realm of trivial programs. We could, for example,
extend the preceding script to do things like transfer files by FTP,
pop up a GUI message selector and status bar, fetch messages from an
SQL database, and employ COM objects on Windows -- all using
standard Python tools.
</P>

<P class="docText">Python scripts also tend to be more portable to other platforms than
<TT>csh</TT>. For instance, if we used the Python SMTP
interface to send mail rather than relying on a Unix command-line
mail tool, the script would run on any machine with Python and an
Internet link (as we'll see in <A class="docLink" HREF="0596000855_python2-CHP-11.html#python2-CHP-11">Chapter 11</A>,
SMTP only requires sockets). And like C, we don't need
<TT>$</TT> to evaluate variables; what else would you
expect in a free
language?<A NAME="IXT-2-336961"></A><A NAME="IXT-2-336962"></A><A NAME="IXT-2-336963"></A><A NAME="IXT-2-336964"></A><A NAME="IXTR3-59"></A>
</P>
</TD></TR></TABLE></P>



<a href="0596000855_"><img src="FILES/pixel.gif" width="1" height="1" border="0"></a><ul></ul>
</td>
</tr>
</table>
<td></td>
<table width="100%" border="0" cellspacing="0" cellpadding="0" bgcolor="#CCCCCC">
<td><font color="black" size=1>I l<font color="#FF0000">@</font>ve RuBoard</td>
<td valign="top" class="v2" align="right">
          <a href="0596000855_python2-CHP-2-SECT-11.html"><img src="FILES/previous.gif" width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a>
          <a href="0596000855_python2-CHP-3.html"><img src="FILES/next.gif" width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a>
</td></table>
</body></html>
