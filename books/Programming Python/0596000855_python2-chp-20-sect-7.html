<html><head>
<META http-equiv="Content-Type" content="text/html">
<!--SafClassName="docSection1Title"--><!--SafTocEntry="20.7 Other Integration Topics"-->
<link rel="STYLESHEET" type="text/css" href="FILES/style.css">
<link rel="STYLESHEET" type="text/css" href="FILES/docsafari.css">
</head>
<body>
<table width="100%" border="0" cellspacing="0" cellpadding="0" bgcolor="#CCCCCC">
<td><font color="black" size=1>I l<font color="#FF0000">@</font>ve RuBoard</td>
<td valign="top" class="v2" align="right">
	<a href="0596000855_python2-CHP-20-SECT-6.html"><img src="FILES/previous.gif" width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a>
	<a href="0596000855_python2-PART-VI.html"><img src="FILES/next.gif" width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a>
</td></table>
<br>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<tr>
<td valign="top"><A NAME="python2-CHP-20-SECT-7"></A>
<H3 class="docSection1Title">20.7 Other Integration Topics</H3>

<P class="docText">In this book, the term <span class="docEmphasis">integration</span> has largely
meant mixing Python with components written in C or C++ (or other
C-compatible languages) in extending and embedding modes. But from a
broader perspective, integration also includes any other technology
that lets us mix Python components into larger systems. This last
section briefly looks at a handful of integration technologies beyond
the C API tools we've seen in this part of the book.
</P>

<A NAME="python2-CHP-20-SECT-7.1"></A>
<H4 class="docSection2Title">20.7.1 JPython (a.k.a. Jython) Integration</H4>

<P class="docText"><A NAME="IXT-20-338250"></A>
<A NAME="IXT-20-338251"></A>We met JPython in <A class="docLink" HREF="0596000855_python2-CHP-15.html#python2-CHP-15">Chapter 15</A>but it is worth another mention in the context
of integration at large. As we saw earlier, JPython supports two
kinds of integration:
</P>

<UL>
<LI><P class="docList">JPython uses Java's <span class="docEmphasis">reflection API</span> to
allow Python programs to call out to Java class libraries
automatically (extending). The Java reflection API provides Java type
information at runtime, and serves the same purpose as the glue code
we've generated to plug C libraries into Python in this part of
the book. In JPython, however, this runtime type information allows
largely automated resolution of Java calls in Python scripts -- no
glue code has to be written or generated.
</P></LI>
<LI><P class="docList"><A NAME="IXT-20-338252"></A>
<A NAME="IXT-20-338253"></A>JPython also provides a Java
<TT>PythonInterpreter</TT> class API that allows Java
programs to run Python code in a namespace (embedding), much like the
C API tools we've used to run Python code strings from C
programs. In addition, because JPython implements all Python objects
as instances of a Java <TT>PyObject</TT> class, it is
straightforward for the Java layer that encloses embedded Python code
to process Python objects.
</P></LI>
</UL>
<P class="docText">In other words, JPython allows Python to be both extended and
embedded in Java, much like the C integration strategies we've
seen in this part of the book. With the addition of the JPython
system, Python may be integrated with any C-compatible program by
using C API tools, as well as any Java-compatible program by using
JPython.
</P>

<P class="docText">Although JPython provides a remarkably seamless integration model,
Python code runs slower in the JPython implementation, and its
reliance on Java class libraries and execution environments
introduces Java dependencies that may be a concern in some
development scenarios. See <A class="docLink" HREF="0596000855_python2-CHP-15.html#python2-CHP-15">Chapter 15</A> for more
JPython details; for the full story, read the documentation available
online at <A class="docLink" target="_blank" HREF="http://www.jython.org/default.htm">http://www.jython.org</A>
(also available in the JPython package at <A class="docLink" target="_blank" HREF="http://examples.oreilly.com/python2">http://examples.oreilly.com/python2</A>).
</P>


<A NAME="python2-CHP-20-SECT-7.2"></A>
<H4 class="docSection2Title">20.7.2 COM Integration on Windows</H4>

<P class="docText"><A NAME="IXT-20-338254"></A> <A NAME="IXT-20-338255"></A>
<A NAME="IXT-20-338256"></A>We briefly discussed Python's
support for the COM object model on Windows when we explored Active
Scripting in <A class="docLink" HREF="0596000855_python2-CHP-15.html#python2-CHP-15">Chapter 15</A>, but it's really a
general integration tool that is useful apart from the Internet too.
</P>

<P class="docText">Recall that COM defines a standard and language-neutral object model
with which components written in a variety of programming languages
may integrate and communicate. Python's
<TT>win32all</TT> Windows extension package tools allow
Python programs to implement both server and client in the COM
interface model.
</P>

<P class="docText">As such, it provides a powerful way to integrate Python programs with
programs written in other COM-aware languages such as Visual Basic,
Delphi, Visual C++, PowerBuilder, and even other Python programs.
Python scripts can also use COM calls to script popular Microsoft
applications such as Word and Excel, since these systems register COM
object interfaces of their own. Moreover, the newcomer Python
implementation (tentatively called Python.NET) for Microsoft's
C#/.NET technology mentioned in <A class="docLink" HREF="0596000855_python2-CHP-15.html#python2-CHP-15">Chapter 15</A> provides
another way to mix Python with other Windows components.
</P>

<P class="docText">On the downside, COM implies a level of dispatch indirection and is a
Windows-only solution at this writing. Because of that, it is not as
fast or as portable as some of the lower-level integration schemes
we've studied in this part of the book (linked-in, in-process,
and direct calls between Python and C-compatible language
components). For nontrivial use, COM is also considered to be a large
system, and further details about it are well beyond the scope of
this book.
</P>

<P class="docText">For more information on COM support and other Windows extensions,
refer to <A class="docLink" HREF="0596000855_python2-CHP-15.html#python2-CHP-15">Chapter 15</A> in this book, and to
O'Reilly's <span class="docEmphasis">Python Programming on
Win32</span>. That book also describes how to use Windows
compilers to do Python/C integration in much more detail than is
possible here; for instance, it shows how to use Visual C++ tools to
compile and link Python C/C++ integration layer code. The basic C
code behind low-level extending and embedding on Windows is the same
as shown in this book, but compiling and linking details
vary.<A NAME="IXT-20-338257"></A>
</P>


<A NAME="python2-CHP-20-SECT-7.3"></A>
<H4 class="docSection2Title">20.7.3 CORBA Integration</H4>

<P class="docText"><A NAME="IXT-20-338258"></A>
<A NAME="IXT-20-338259"></A> <A NAME="IXT-20-338260"></A>
<A NAME="IXT-20-338261"></A>There is also much support, some of it
open source, for using Python in the context of a CORBA-based
application. <span class="docEmphasis">CORBA</span> stands for the Common Object
Request Broker; it's a language-neutral way to distribute
systems among communicating components, which speak through an object
model architecture. As such, it represents another way to integrate
Python components into a larger system.
</P>

<P class="docText">Python's CORBA support includes the public domain systems
<span class="docEmphasis">ILU</span> (from Xerox) and <span class="docEmphasis">fnorb</span>
(see <A class="docLink" target="_blank" HREF="http://www.python.org/default.htm">http://www.python.org</A>). At
this writing, the <span class="docEmphasis">OMG</span> (Object Management Group,
responsible for directing CORBA growth) is also playing host to an
effort to elect Python as the standard scripting language for
CORBA-based systems. Whether that ultimately transpires or not,
Python is an ideal language for programming distributed objects, and
is being used in such a role by many companies around the world.
</P>

<P class="docText">Like COM, CORBA is a large system -- too large for us to even
scratch the surface in this text. For more details, search
Python's web site for CORBA-related materials.
</P>


<A NAME="python2-CHP-20-SECT-7.4"></A>
<H4 class="docSection2Title">20.7.4 Integration Versus Optimization</H4>

<P class="docText"><A NAME="python2-IDXTERM-2402"></A>
<A NAME="python2-IDXTERM-2403"></A>Given so
many integration options, choosing between them can be puzzling. When
should you choose something like COM over writing C extension
modules, for instance? As usual, it depends on why you're
interested in mixing external components into your Python programs in
the first place.
</P>

<P class="docText">Basically, frameworks such as JPython, COM, and CORBA allow Python
scripts to leverage existing libraries of software components, and do
a great job of addressing goals like code reuse and integration.
However, they say almost nothing about optimization: integrated
components are not necessarily faster than the Python equivalents.
</P>

<P class="docText">On the other hand, Python extension modules and types coded in a
compiled language like C serve two roles: they too can be used to
integrate existing components, but also tend to be a better approach
when it comes to boosting system performance.
</P>

<A NAME="python2-CHP-20-SECT-7.4.1"></A>
<H5 class="docSection3Title">20.7.4.1 Framework roles</H5>

<P class="docText">Let's consider the big picture here. Frameworks such as COM and
CORBA can perhaps be understood as alternatives to the Python/C
integration techniques we met in this part of the book. For example,
packaging Python logic as a COM <span class="docEmphasis">server</span> makes it
available for something akin to <span class="docEmphasis">embedding</span>
 -- many languages (including C) can access it using
the COM client-side interfaces we met in <A class="docLink" HREF="0596000855_python2-CHP-15.html#python2-CHP-15">Chapter 15</A>. And as we saw earlier, JPython allows Java to
embed and run Python code and objects through a Java class interface.
</P>

<P class="docText">Furthermore, frameworks allow Python scripts to use existing
component libraries: standard Java class libraries in JPython, COM
server libraries on Windows, and so on. In such a role, the external
libraries exposed by such frameworks are more or less analogous to
Python <span class="docEmphasis">extension</span> modules. For instance, Python
scripts that use COM <span class="docEmphasis">client</span> interfaces to access
an external object are acting much like importers of C extension
modules (albeit through the COM indirection layer).
</P>



<A NAME="python2-CHP-20-SECT-7.4.2"></A>
<H5 class="docSection3Title">20.7.4.2 Extension module roles</H5>

<P class="docText"><A NAME="IXT-20-338262"></A>
<A NAME="IXT-20-338263"></A>Python's C API is designed
to serve in many of the same roles. As we've seen, C extension
modules can serve as code <span class="docEmphasis">reuse</span> and
<span class="docEmphasis">integration</span> tools too -- it's
straightforward to plug existing C and C++ libraries into Python with
SWIG. In most cases, we simply generate and import the glue code
created with SWIG to make almost any existing compiled library
available for use in Python scripts<sup class="docFootnote"><A class="docLink" HREF="#">[9]</A></sup>. Moreover,
Python's embedding API allows other languages to run Python
code, much like client-side interfaces in COM.
</P>
<blockquote><p class="docFootnote"><sup><A NAME="">[9]</A></sup> In fact,
it's <span class="docEmphasis">so</span> easy to plug in libraries with
SWIG that extensions are usually best coded first as simple C/C++
libraries, and later wrapped for use in Python with SWIG. Adding a
COM layer to an existing C library may or may not be as
straightforward, but will clearly be less portable -- COM is
currently a Windows-only technology. </p></blockquote>

<P class="docText">One of the primary reasons for writing C extension modules in the
first place, though, is <span class="docEmphasis">optimization</span>: key parts
of Python applications may be implemented or recoded as C or C++
extension modules to speed up the system at large (as in the last
chapter's stack examples). Moving such components to compiled
extension modules not only improves system performance, but is
completely seamless -- module interfaces in Python look the same
no matter what programming language implements the module.
</P>



<A NAME="python2-CHP-20-SECT-7.4.3"></A>
<H5 class="docSection3Title">20.7.4.3 Picking an integration technology</H5>

<P class="docText">By contrast, JPython, COM, and CORBA do not deal directly with
optimization goals at all; they serve only to integrate. For
instance, JPython allows Python scripts to automatically access Java
libraries, but generally mandates that non-Python extensions be coded
in Java,a language that is itself usually
interpreted and no speed demon. COM and CORBA focus on the interfaces
between components and leave the component implementation language
ambiguous by design. Exporting a Python class as a COM server, for
instance, can make its tools widely reusable on Windows, but has
little to do with performance improvement.
</P>

<P class="docText">Because of their different focus, frameworks are not quite
replacements for the more direct Python/C extension modules and types
we've studied in these last two chapters, and are less direct
(and hence likely slower) than Python's C embedding API.
It's possible to mix-and-match approaches, but the combinations
are rarely any better than their parts. For example, although C
libraries can be added to Java with its native call interface,
it's neither a secure nor straightforward undertaking. And
while C libraries can also be wrapped as COM servers to make them
visible to Python scripts on Windows, the end result will probably be
slower and no less complex than a more directly linked-in Python
extension module.
</P>

<P class="docText">As you can see, there are a lot of options in the integration domain.
Perhaps the best parting advice I can give you is simply that
different tools are meant for different tasks. C extension modules
and types are ideal at optimizing systems and integrating libraries,
but frameworks offer other ways to integrate components -- JPython
for mixing in Java tools, COM for reusing and publishing objects on
Windows, and so on. As ever, your mileage may vary.<A NAME="IXTR3-566"></A> <A NAME="IXTR3-567"></A><A NAME="IXTR3-568"></A> <A NAME="IXTR3-569"></A>
</P>




<ul></ul>
</td>
</tr>
</table>
<td></td>
<table width="100%" border="0" cellspacing="0" cellpadding="0" bgcolor="#CCCCCC">
<td><font color="black" size=1>I l<font color="#FF0000">@</font>ve RuBoard</td>
<td valign="top" class="v2" align="right">
          <a href="0596000855_python2-CHP-20-SECT-6.html"><img src="FILES/previous.gif" width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a>
          <a href="0596000855_python2-PART-VI.html"><img src="FILES/next.gif" width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a>
</td></table>
</body></html>
