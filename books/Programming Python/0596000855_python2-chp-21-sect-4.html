<html><head>
<META http-equiv="Content-Type" content="text/html">
<!--SafClassName="docSection1Title"--><!--SafTocEntry="21.4 Doing the Right Thing"-->
<link rel="STYLESHEET" type="text/css" href="FILES/style.css">
<link rel="STYLESHEET" type="text/css" href="FILES/docsafari.css">
</head>
<body>
<table width="100%" border="0" cellspacing="0" cellpadding="0" bgcolor="#CCCCCC">
<td><font color="black" size=1>I l<font color="#FF0000">@</font>ve RuBoard</td>
<td valign="top" class="v2" align="right">
	<a href="0596000855_python2-CHP-21-SECT-3.html"><img src="FILES/previous.gif" width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a>
	<a href="0596000855_python2-CHP-21-SECT-5.html"><img src="FILES/next.gif" width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a>
</td></table>
<br>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<tr>
<td valign="top"><A NAME="python2-CHP-21-SECT-4"></A>
<H3 class="docSection1Title">21.4 Doing the Right Thing</H3>

<P class="docText">Of course, the Gilligan factor is a exaggeration, added for comic
effect. But few would argue that the bottleneck between ideas and
working systems has disappeared completely. Even today, the cost of
developing software far exceeds the cost of computer hardware. Why
must programming be so complex?
</P>

<P class="docText">Let's consider the situation carefully. By and large, the root
of the complexity in developing software isn't related to the
role it's supposed to perform -- usually this is a
well-defined real-world process. Rather, it stems from the mapping of
real-world tasks onto computer-executable models. And this mapping is
performed in the context of programming languages and tools.
</P>

<P class="docText">The path toward easing the software bottleneck must therefore lie, at
least partially, in optimizing the act of programming itself by
deploying the right tools. Given this realistic scope, there's
much that can be done now -- there are a number of purely
artificial overheads inherent in our current tools.
</P>

<A NAME="python2-CHP-21-SECT-4.1"></A>
<H4 class="docSection2Title">21.4.1 The Static Language Build Cycle</H4>

<P class="docText">Using traditional static languages, there is an unavoidable overhead
in moving from coded programs to working systems: compile and link
steps add a built-in delay to the development process. In some
environments, it's common to spend many hours each week just
waiting for a static language application's build cycle to
finish. Given that modern development practice involves an iterative
process of building, testing, and rebuilding, such delays can be
expensive and demoralizing (if not physically painful).
</P>

<P class="docText">Of course, this varies from shop to shop, and in some domains the
demand for performance justifies build-cycle delays. But I've
worked in C++ environments where programmers joked about having to go
to lunch whenever they recompiled their systems. Except they
weren't really joking.
</P>


<A NAME="python2-CHP-21-SECT-4.2"></A>
<H4 class="docSection2Title">21.4.2 Artificial Complexities</H4>

<P class="docText">With many traditional programming tools, you can easily lose the
forest for the trees: the act of programming becomes so complex that
the real-world goal of the program is obscured. Traditional languages
divert valuable attention to syntactic issues and development of
bookkeeping code. Obviously, complexity isn't an end in itself;
it must be clearly warranted. Yet some of our current tools are so
complex that the language itself makes the task harder and lengthens
the development process.
</P>


<A NAME="python2-CHP-21-SECT-4.3"></A>
<H4 class="docSection2Title">21.4.3 One Language Does Not Fit All</H4>

<P class="docText">Many traditional languages implicitly encourage homogeneous,
single-language systems. By making integration complex, they impede
the use of multiple-language tools; therefore, instead of being able
to select the right tool for the task at hand, developers are often
compelled to use the same language for every component of an
application. Since no language is good at everything, this constraint
inevitably sacrifices both product functionality and programmer
productivity.
</P>

<P class="docText">Until our machines are as clever at taking directions as we are
(arguably, not the most rational of goals), the task of programming
won't go away. But for the time being, we can make substantial
progress by making the mechanics of that task easier. And this topic
is what I want to talk about now.
</P>



<a href="0596000855_"><img src="FILES/pixel.gif" width="1" height="1" border="0"></a><ul></ul>
</td>
</tr>
</table>
<td></td>
<table width="100%" border="0" cellspacing="0" cellpadding="0" bgcolor="#CCCCCC">
<td><font color="black" size=1>I l<font color="#FF0000">@</font>ve RuBoard</td>
<td valign="top" class="v2" align="right">
          <a href="0596000855_python2-CHP-21-SECT-3.html"><img src="FILES/previous.gif" width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a>
          <a href="0596000855_python2-CHP-21-SECT-5.html"><img src="FILES/next.gif" width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a>
</td></table>
</body></html>
