<html><head>
<META http-equiv="Content-Type" content="text/html">
<!--SafClassName="docSection1Title"--><!--SafTocEntry="4.6 User-Friendly Program Launchers"-->
<link rel="STYLESHEET" type="text/css" href="FILES/style.css">
<link rel="STYLESHEET" type="text/css" href="FILES/docsafari.css">
</head>
<body>
<table width="100%" border="0" cellspacing="0" cellpadding="0" bgcolor="#CCCCCC">
<td><font color="black" size=1>I l<font color="#FF0000">@</font>ve RuBoard</td>
<td valign="top" class="v2" align="right">
	<a href="0596000855_python2-CHP-4-SECT-5.html"><img src="FILES/previous.gif" width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a>
	<a href="0596000855_python2-CHP-5.html"><img src="FILES/next.gif" width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a>
</td></table>
<br>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<tr>
<td valign="top"><A NAME="python2-CHP-4-SECT-6"></A>
<H3 class="docSection1Title">4.6 User-Friendly Program Launchers</H3>

<P class="docText">Suppose, for just a moment, that you wish to ship Python programs to
an audience that may be in the very early stages of evolving from
computer user to computer programmer. Maybe you are shipping a Python
application to nontechnical users; or perhaps you're interested
in shipping a set of cool Python demo programs on a Python
book's CD-ROM (see <A class="docLink" target="_blank" HREF="http://examples.oreilly.com/python2">http://examples.oreilly.com/python2</A>). Whatever the reason, some of the people who will
use your software can't be expected to do any more than click a
mouse -- much less edit their system configuration files to set
things like PATH and PYTHONPATH per your programs' assumptions.
Your software will have to configure itself.
</P>

<P class="docText">Luckily, Python scripts can do that too. In the next two sections,
we're going to see two modules that aim to automatically launch
programs with minimal assumptions about the environment on the host
machine:
</P>

<UL>
<LI><P class="docList"><I>Launcher.py</I> is a library of tools for
automatically configuring the shell environment in preparation for
launching a Python script. It can be used to set required shell
variables -- both the PATH system program search path (used to
find the "python" executable), and the PYTHONPATH module
search path (used to resolve imports within scripts). Because such
variable settings made in a parent program are
<span class="docEmphasis">inherited</span> by spawned child programs, this
interface lets scripts preconfigure search paths for other scripts.
</P></LI>
<LI><P class="docList"><I>LaunchBrowser.py</I> aims to portably locate and
start an Internet browser program on the host machine to view a local
file or remote web page. It uses tools in
<I>Launcher.py</I> to search for a reasonable browser
to run.
</P></LI>
</UL>
<P class="docText">Both of these modules are designed to be reusable in any context
where you want your software to be user-friendly. By searching for
files and configuring environments automatically, your users can
avoid (or at least postpone) having to learn the intricacies of
environment configuration.
</P>

<A NAME="python2-CHP-4-SECT-6.1"></A>
<H4 class="docSection2Title">4.6.1 Launcher Module Clients</H4>

<P class="docText">The two modules in this section see action in many of this
book's examples. In fact, we've already used some of
these tools. The <TT>launchmodes</TT> script we met at the
end of the prior chapter imported <TT>Launcher</TT>
functions to hunt for the local <I>python.exe</I>
interpreter's path, needed by <TT>os.spawnv</TT>
calls. That script could have assumed that everyone who installs it
on their machine will edit its source code to add their own Python
location; but the technical know-how required for even that task is
already light-years beyond many potential users.<sup class="docFootnote"><A class="docLink" HREF="#">[4]</A></sup> It's much nicer to invest a negligible amount of
startup time to locate Python automatically.
</P>
<blockquote><p class="docFootnote"><sup><A NAME="">[4]</A></sup> You
gurus and wizards out there will just have to take my word for it.
One of the very first things you learn from flying around the world
teaching Python to beginners is just how much knowledge developers
take for granted. In the book <span class="docEmphasis">Learning Python</span>,
for example, my co-author and I directed readers to do things like
"open a file in your favorite text editor" and
"start up a DOS command console." We had no shortage of
email from beginners wondering what in the world we meant.</p></blockquote>

<P class="docText">The two modules listed in Examples <A class="docLink" HREF="#python2-CHP-4-EX-14">Example 4-14</A> and
<A class="docLink" HREF="#python2-CHP-4-EX-15">Example 4-15</A>, together with
<TT>launchmodes</TT>, also form the core of the
<span class="docEmphasis">demo-launcher programs</span> at the top of the
examples distribution on this book's CD (see <A class="docLink" target="_blank" HREF="http://examples.oreilly.com/python2">http://examples.oreilly.com/python2</A>). There's nothing
quite like being able to witness programs in action first-hand, so I
wanted to make it as easy as possible to launch Python examples in
the book. Ideally, they should run straight off the CD when clicked,
and not require readers to wade through a complex environment
installation procedure.
</P>

<P class="docText">However, many demos perform cross-directory imports, and so require
the book's module package directories to be installed in
PYTHONPATH; it is not enough just to click on some programs'
icons at random. Moreover, when first starting out, users can't
be assumed to have added the Python executable to their system search
path either; the name "python" might not mean anything in
the shell.
</P>

<P class="docText">At least on platforms tested thus far, the following modules solve
such configuration problems. For example, script
<I>Launch_PyDemos.pyw</I> in the root directory
automatically configures the system and Python execution environments
using <I>Launcher.py</I> tools, and then spawns
<I>PyDemos.py</I>, a Tkinter GUI Demo interface
we'll meet later in this book. PyDemos in turn uses
<TT>launchmodes</TT> to spawn other programs, that also
inherit the environment settings made at the top. The net effect is
that clicking any of the <TT>Launch_*</TT> scripts starts
Python programs even if you haven't touched your environment
settings at all.
</P>

<P class="docText">You still need to install Python if it's not present, of
course, but the Python Windows self-installer is a simple
point-and-click affair too. Because searches and configuration take
extra time, it's still to your advantage to
<span class="docEmphasis">eventually</span> configure your environment settings
and run programs like PyDemos directly, instead of through the
launcher scripts. But there's much to be said for instant
gratification when it comes to software.
</P>

<P class="docText">These tools will show up in other contexts later in this text, too.
For instance, the PyMail email interface we'll meet in <A class="docLink" HREF="0596000855_python2-CHP-11.html#python2-CHP-11">Chapter 11</A> uses <TT>Launcher</TT> to locate its
own source code file; since it's impossible to know what
directory it will be run from, the best it can do is search. Another
GUI example, <TT>big_gui</TT>, will use a similar
<TT>Launcher</TT> tool to locate canned Python
source-distribution demo programs in arbitrary and unpredictable
places on the underlying computer.
</P>

<P class="docText">The <TT>LaunchBrowser</TT> script in <A class="docLink" HREF="#python2-CHP-4-EX-15">Example 4-15</A> also uses <TT>Launcher</TT> to
locate suitable web browsers, and is itself used to start Internet
demos in the PyDemos and PyGadgets launcher GUIs -- that is,
<TT>Launcher</TT> starts PyDemos, which starts
<TT>LaunchBrowser</TT>, which uses
<TT>Launcher</TT>. By optimizing generality, these modules
also optimize reusability.
</P>


<A NAME="python2-CHP-4-SECT-6.2"></A>
<H4 class="docSection2Title">4.6.2 Launching Programs Without Environment Settings</H4>

<P class="docText">Because the <I>Launcher.py</I> file is heavily
documented, I won't go over its fine points in narrative here.
Instead, I'll just point out that all of its functions are
useful by themselves, but the main entry point is the
<TT>launchBookExamples</TT> function near the end; you need
to work your way from the bottom of this file up to glimpse its
larger picture.
</P>

<P class="docText">The <TT>launchBookExamples</TT> function uses all the
others, to configure the environment and then spawn one or more
programs to run in that environment. In fact, the top-level demo
launcher scripts shown in Examples <A class="docLink" HREF="#python2-CHP-4-EX-12">Example 4-12</A> and
<A class="docLink" HREF="#python2-CHP-4-EX-13">Example 4-13</A> do nothing more than ask this function
to spawn GUI demo interface programs we'll meet later (e.g.,
<I>PyDemos.pyw</I>,
<I>PyGadgets_bar.pyw</I>). Because the GUIs are spawned
indirectly through this interface, all programs they spawn inherit
the environment configurations too.
</P>


<H5 class="docExampleTitle"><A NAME="python2-CHP-4-EX-12"></A>Example 4-12. PP2E\Launch_PyDemos.pyw </H5>
<PRE>#!/bin/env python
###############################################
# PyDemos + environment search/config first
# run this if you haven't setup your paths yet
# you still must install Python first, though
###############################################

import Launcher
Launcher.launchBookExamples(['PyDemos.pyw'], 0)</PRE>



<H5 class="docExampleTitle"><A NAME="python2-CHP-4-EX-13"></A>Example 4-13. PP2E\Launch_PyGadgets_bar.pyw </H5>
<PRE>#!/bin/env python
##################################################
# PyGadgets_bar + environment search/config first
# run this if you haven't setup your paths yet
# you still must install Python first, though
##################################################

import Launcher
Launcher.launchBookExamples(['PyGadgets_bar.pyw'], 0)</PRE>


<P class="docText">When run directly, <I>PyDemos.pyw</I> and
<I>PyGadgets_bar.pyw</I> instead rely on the
configuration settings on the underlying machine. In other words,
<TT>Launcher</TT> effectively <span class="docEmphasis">hides</span>
configuration details from the GUI interfaces, by enclosing them in a
configuration program layer. To understand how, study <A class="docLink" HREF="#python2-CHP-4-EX-14">Example 4-14</A>.
</P>


<H5 class="docExampleTitle"><A NAME="python2-CHP-4-EX-14"></A>Example 4-14. PP2E\Launcher.py </H5>
<PRE>#!/usr/bin/env python
"""
----------------------------------------------------------------------------
Tools to find files, and run Python demos even if your environment has
not been manually configured yet.  For instance, provided you have already
installed Python, you can launch Tk demos directly off the book's CD by 
double-clicking this file's icon, without first changing your environment
config files.  Assumes Python has been installed first (double-click on the
python self-install exe on the CD), and tries to guess where Python and the 
examples distribution live on your machine.  Sets Python module and system
search paths before running scripts: this only works because env settings 
are inherited by spawned programs on both windows and linux.  You may want
to tweak the list of directories searched for speed, and probably want to 
run one of the Config/setup-pp files at startup time to avoid this search.
This script is friendly to already-configured path settings, and serves to 
demo platform-independent directory path processing.  Python programs can 
always be started under the Windows port by clicking (or spawning a 'start'
DOS command), but many book examples require the module search path too.
----------------------------------------------------------------------------
"""

import sys, os, string


def which(program, trace=1):
    """
    Look for program in all dirs in the system's search 
    path var, PATH; return full path to program if found, 
    else None. Doesn't handle aliases on Unix (where we 
    could also just run a 'which' shell cmd with os.popen),
    and it might help to also check if the file is really 
    an executable with os.stat and the stat module, using
    code like this: os.stat(filename)[stat.ST_MODE] &amp; 0111
    """
    try:
        ospath = os.environ['PATH']
    except:
        ospath = '' # okay if not set
    systempath = string.split(ospath, os.pathsep)
    if trace: print 'Looking for', program, 'on', systempath
    for sysdir in systempath:
        filename = os.path.join(sysdir, program)      # adds os.sep between
        if os.path.isfile(filename):                  # exists and is a file?
            if trace: print 'Found', filename
            return filename
        else:
            if trace: print 'Not at', filename
    if trace: print program, 'not on system path'
    return None


def findFirst(thisDir, targetFile, trace=0):    
    """
    Search directories at and below thisDir for a file
    or dir named targetFile.  Like find.find in standard
    lib, but no name patterns, follows unix links, and
    stops at the first file found with a matching name.
    targetFile must be a simple base name, not dir path.
    """
    if trace: print 'Scanning', thisDir
    for filename in os.listdir(thisDir):                    # skip . and ..
        if filename in [os.curdir, os.pardir]:              # just in case
            continue
        elif filename == targetFile:                        # check name match
            return os.path.join(thisDir, targetFile)        # stop at this one
        else: 
            pathname = os.path.join(thisDir, filename)      # recur in subdirs
            if os.path.isdir(pathname):                     # stop at 1st match
                below = findFirst(pathname, targetFile, trace)  
                if below: return below

       
def guessLocation(file, isOnWindows=(sys.platform[:3]=='win'), trace=1):
    """
    Try to find directory where file is installed
    by looking in standard places for the platform.
    Change tries lists as needed for your machine.
    """
    cwd = os.getcwd(  )                             # directory where py started
    tryhere = cwd + os.sep + file                 # or os.path.join(cwd, file)
    if os.path.exists(tryhere):                   # don't search if it is here
        return tryhere                            # findFirst(cwd,file) descends
    if isOnWindows:
        tries = []
        for pydir in [r'C:\Python20', r'C:\Program Files\Python']:
            if os.path.exists(pydir):
                tries.append(pydir)
        tries = tries + [cwd, r'C:\Program Files']
        for drive in 'CGDEF':
            tries.append(drive + ':\\')
    else:
        tries = [cwd, os.environ['HOME'], '/usr/bin', '/usr/local/bin']
    for dir in tries:
        if trace: print 'Searching for %s in %s' % (file, dir)
        try:
            match = findFirst(dir, file)
        except OSError: 
            if trace: print 'Error while searching', dir     # skip bad drives
        else:
            if match: return match
    if trace: print file, 'not found! - configure your environment manually'
    return None


PP2EpackageRoots = [                               # python module search path
   #'%sPP2E' % os.sep,                             # pass in your own elsewhere
    '']                                            # '' adds examplesDir root


def configPythonPath(examplesDir, packageRoots=PP2EpackageRoots, trace=1):
    """
    Setup the Python module import search-path directory 
    list as necessary to run programs in the book examples 
    distribution, in case it hasn't been configured already.
    Add examples package root, plus nested package roots.
    This corresponds to the setup-pp* config file settings.
    os.environ assignments call os.putenv internally in 1.5,
    so these settings will be inherited by spawned programs.
    Python source lib dir and '.' are automatically searched;
    unix|win os.sep is '/' | '\\', os.pathsep is ':' | ';'.
    sys.path is for this process only--must set os.environ.
    adds new dirs to front, in case there are two installs.
    could also try to run platform's setup-pp* file in this
    process, but that's non-portable, slow, and error-prone.
    """
    try:
        ospythonpath = os.environ['PYTHONPATH']
    except:
        ospythonpath = '' # okay if not set 
    if trace: print 'PYTHONPATH start:\n', ospythonpath
    addList = []
    for root in packageRoots:
        importDir = examplesDir + root
        if importDir in sys.path:
            if trace: print 'Exists', importDir
        else:
            if trace: print 'Adding', importDir
            sys.path.append(importDir)
            addList.append(importDir)
    if addList:
        addString = string.join(addList, os.pathsep) + os.pathsep
        os.environ['PYTHONPATH'] = addString + ospythonpath
        if trace: print 'PYTHONPATH updated:\n', os.environ['PYTHONPATH']
    else:
        if trace: print 'PYTHONPATH unchanged'


def configSystemPath(pythonDir, trace=1):
    """ 
    Add python executable dir to system search path if needed
    """
    try:
        ospath = os.environ['PATH']
    except:
        ospath = '' # okay if not set  
    if trace: print 'PATH start', ospath
    if (string.find(ospath, pythonDir) == -1 and                # not found?
        string.find(ospath, string.upper(pythonDir)) == -1):    # case diff?
        os.environ['PATH'] = ospath + os.pathsep + pythonDir
        if trace: print 'PATH updated:', os.environ['PATH']
    else:
        if trace: print 'PATH unchanged'


def runCommandLine(pypath, exdir, command, isOnWindows=0, trace=1):
    """
    Run python command as an independent program/process on 
    this platform, using pypath as the Python executable,
    and exdir as the installed examples root directory.
    Need full path to python on windows, but not on unix.
    On windows, a os.system('start ' + command) is similar,
    except that .py files pop up a dos console box for i/o.
    Could use launchmodes.py too but pypath is already known. 
    """
    command = exdir + os.sep + command          # rooted in examples tree
    os.environ['PP2E_PYTHON_FILE'] = pypath     # export directories for
    os.environ['PP2E_EXAMPLE_DIR'] = exdir      # use in spawned programs

    if trace: print 'Spawning:', command
    if isOnWindows:
        os.spawnv(os.P_DETACH, pypath, ('python', command))
    else:
        cmdargs = [pypath] + string.split(command)
        if os.fork(  ) == 0:
            os.execv(pypath, cmdargs)           # run prog in child process


def launchBookExamples(commandsToStart, trace=1):
    """
    Toplevel entry point: find python exe and 
    examples dir, config env, spawn programs
    """
    isOnWindows  = (sys.platform[:3] == 'win')
    pythonFile   = (isOnWindows and 'python.exe') or 'python'
    examplesFile = 'README-PP2E.txt'
    if trace: 
        print os.getcwd(  ), os.curdir, os.sep, os.pathsep
        print 'starting on %s...' % sys.platform

    # find python executable: check system path, then guess
    pypath = which(pythonFile) or guessLocation(pythonFile, isOnWindows) 
    assert pypath
    pydir, pyfile = os.path.split(pypath)               # up 1 from file
    if trace:
        print 'Using this Python executable:', pypath
        raw_input('Press &lt;enter&gt; key')
 
    # find examples root dir: check cwd and others
    expath = guessLocation(examplesFile, isOnWindows)
    assert expath
    updir  = string.split(expath, os.sep)[:-2]          # up 2 from file
    exdir  = string.join(updir,   os.sep)               # to PP2E pkg parent
    if trace:
        print 'Using this examples root directory:', exdir
        raw_input('Press &lt;enter&gt; key')
 
    # export python and system paths if needed
    configSystemPath(pydir)
    configPythonPath(exdir)
    if trace:
        print 'Environment configured'
        raw_input('Press &lt;enter&gt; key')

    # spawn programs
    for command in commandsToStart:
        runCommandLine(pypath, os.path.dirname(expath), command, isOnWindows)


if __name__ == '__main__':
    #
    # if no args, spawn all in the list of programs below
    # else rest of cmd line args give single cmd to be spawned
    #
    if len(sys.argv) == 1:
        commandsToStart = [
            'Gui/TextEditor/textEditor.pyw',        # either slash works
            'Lang/Calculator/calculator.py',        # os normalizes path
            'PyDemos.pyw',
           #'PyGadgets.py',
            'echoEnvironment.pyw'
        ]
    else:
        commandsToStart = [ string.join(sys.argv[1:], ' ') ]
    launchBookExamples(commandsToStart)
    import time
    if sys.platform[:3] == 'win': time.sleep(10)   # to read msgs if clicked</PRE>


<P class="docText">One way to understand the <TT>Launcher</TT> script is to
trace the messages it prints along the way. When run by itself
without a PYTHONPATH setting, the script finds a suitable Python and
the examples root directory (by hunting for its README file), uses
those results to configure PATH and PYTHONPATH settings if needed,
and spawns a precoded list of program examples. To illustrate, here
is a launch on Windows with an empty PYTHONPATH:
</P>

<PRE>C:\temp\examples&gt;<B>set PYTHONPATH=</B>

C:\temp\examples&gt;<B>python Launcher.py</B>
C:\temp\examples . \ ;
starting on win32...
Looking for python.exe on ['C:\\WINDOWS', 'C:\\WINDOWS', 
'C:\\WINDOWS\\COMMAND', 'C:\\STUFF\\BIN.MKS', 'C:\\PROGRAM FILES\\PYTHON']
Not at C:\WINDOWS\python.exe
Not at C:\WINDOWS\python.exe
Not at C:\WINDOWS\COMMAND\python.exe
Not at C:\STUFF\BIN.MKS\python.exe
Found C:\PROGRAM FILES\PYTHON\python.exe
Using this Python executable: C:\PROGRAM FILES\PYTHON\python.exe
<B>Press &lt;enter&gt; key</B>
Using this examples root directory: C:\temp\examples
<B>Press &lt;enter&gt; key</B>
PATH start C:\WINDOWS;C:\WINDOWS;C:\WINDOWS\COMMAND;C:\STUFF\BIN.MKS;
C:\PROGRAM FILES\PYTHON
PATH unchanged
PYTHONPATH start:

Adding C:\temp\examples\Part3
Adding C:\temp\examples\Part2
Adding C:\temp\examples\Part2\Gui
Adding C:\temp\examples
PYTHONPATH updated:
C:\temp\examples\Part3;C:\temp\examples\Part2;C:\temp\examples\Part2\Gui;
C:\temp\examples;
Environment configured
<B>Press &lt;enter&gt; key</B>
Spawning: C:\temp\examples\Part2/Gui/TextEditor/textEditor.pyw
Spawning: C:\temp\examples\Part2/Lang/Calculator/calculator.py
Spawning: C:\temp\examples\PyDemos.pyw
Spawning: C:\temp\examples\echoEnvironment.pyw</PRE>

<P class="docText">Four programs are spawned with PATH and PYTHONPATH preconfigured
according to the location of your Python interpreter program, the
location of your examples distribution tree, and the list of required
PYTHONPATH entries in script variable
<TT>PP2EpackageRoots</TT>.
</P>

<P><table border="0" bgcolor="black" cellspacing="0" cellpadding="1" width="90%" align="center"><tr><td>
<table bgcolor="white" width="100%" border="0" cellspacing="0" cellpadding="6"><tr>
<td width="60" valign="top"><img src="FILES/tip_yellow.gif" width="50" height="54"></td>
<td valign="top">
<P class="docText">The PYTHONPATH directories that are added by preconfiguration steps
may be different when you run this script, because the
<TT>PP2EpackageRoots</TT> variable may have an arbitrarily
different setting by the time this book's CD is burned. In
fact, to make this example more interesting, the outputs listed were
generated at a time when the book's PYTHONPATH requirements
were much more complex than they are now:</P>
<PRE>PP2EpackageRoots = [
 '%sPart3' % os.sep, # python module search
path 
 '%sPart2' % os.sep, # required
by book demos 
 '%sPart2%sGui' %
((os.sep,)*2), 
 ''] # '' adds
examplesDir root</PRE> 
<P class="docText">Since then, the tree has been
reorganized so that only one directory needs to be added to the
module search path -- the one containing the
<I>PP2E</I> root directory. That makes it easier to
configure (only one entry is added to PYTHONPATH now), but the code
still supports a list of entries for generality. Like most
developers, I can't resist playing with the directories.
</P>
</td>
</tr></table></td></tr></table></P>

<P class="docText">When used by the PyDemos launcher script, <TT>Launcher</TT>
does not pause for key presses along the way (the
<TT>trace</TT> argument is passed in false). Here is the
output generated when using the module to launch PyDemos with
PYTHONPATH already set to include all the required directories; the
script both avoids adding settings redundantly, and retains any
exiting settings already in your environment:
</P>

<PRE>C:\PP2ndEd\examples&gt;<B>python Launch_PyDemos.pyw</B>
Looking for python.exe on ['C:\\WINDOWS', 'C:\\WINDOWS', 
'C:\\WINDOWS\\COMMAND', 'C:\\STUFF\\BIN.MKS', 'C:\\PROGRAM FILES\\PYTHON']
Not at C:\WINDOWS\python.exe
Not at C:\WINDOWS\python.exe
Not at C:\WINDOWS\COMMAND\python.exe
Not at C:\STUFF\BIN.MKS\python.exe
Found C:\PROGRAM FILES\PYTHON\python.exe
PATH start C:\WINDOWS;C:\WINDOWS;C:\WINDOWS\COMMAND;C:\STUFF\BIN.MKS;
C:\PROGRAM FILES\PYTHON
PATH unchanged
PYTHONPATH start:
C:\PP2ndEd\examples\Part3;C:\PP2ndEd\examples\Part2;C:\PP2ndEd\examples\
Part2\Gui;C:\PP2ndEd\examples
Exists C:\PP2ndEd\examples\Part3
Exists C:\PP2ndEd\examples\Part2
Exists C:\PP2ndEd\examples\Part2\Gui
Exists C:\PP2ndEd\examples
PYTHONPATH unchanged
Spawning: C:\PP2ndEd\examples\PyDemos.pyw</PRE>

<P class="docText">And finally, here is the trace output of a launch on my Linux system;
because <TT>Launcher</TT> is written with portable Python
code and library calls, environment configuration and directory
searches work just as well there:
</P>

<PRE>[mark@toy ~/PP2ndEd/examples]$ <B>unsetenv PYTHONPATH</B>
[mark@toy ~/PP2ndEd/examples]$ <B>python Launcher.py</B>
/home/mark/PP2ndEd/examples . / :
starting on linux2...
Looking for python on ['/home/mark/bin', '.', '/usr/bin', '/usr/bin', '/usr/local/
bin', '/usr/X11R6/bin', '/bin', '/usr/X11R6/bin', '/home/mark/
bin', '/usr/X11R6/bin', '/home/mark/bin', '/usr/X11R6/bin']
Not at /home/mark/bin/python
Not at ./python
Found /usr/bin/python
Using this Python executable: /usr/bin/python
<B>Press &lt;enter&gt; key</B>
Using this examples root directory: /home/mark/PP2ndEd/examples
<B>Press &lt;enter&gt; key</B>
PATH start /home/mark/bin:.:/usr/bin:/usr/bin:/usr/local/bin:/usr/X11R6/bin:/bin:/
usr
/X11R6/bin:/home/mark/bin:/usr/X11R6/bin:/home/mark/bin:/usr/X11R6/bin
PATH unchanged
PYTHONPATH start:

Adding /home/mark/PP2ndEd/examples/Part3
Adding /home/mark/PP2ndEd/examples/Part2
Adding /home/mark/PP2ndEd/examples/Part2/Gui
Adding /home/mark/PP2ndEd/examples
PYTHONPATH updated:
/home/mark/PP2ndEd/examples/Part3:/home/mark/PP2ndEd/examples/Part2:/home/
mark/PP2ndEd/examples/Part2/Gui:/home/mark/PP2ndEd/examples:
Environment configured
<B>Press &lt;enter&gt; key</B>
Spawning: /home/mark/PP2ndEd/examples/Part2/Gui/TextEditor/textEditor.py
Spawning: /home/mark/PP2ndEd/examples/Part2/Lang/Calculator/calculator.py
Spawning: /home/mark/PP2ndEd/examples/PyDemos.pyw
Spawning: /home/mark/PP2ndEd/examples/echoEnvironment.pyw</PRE>

<P class="docText">In all of these launches, the Python interpreter was found on the
system search-path, so no real searches were performed (the
"Not at" lines near the top represent the module's
<TT>which</TT> function). In a moment, we'll also use
the <TT>Launcher</TT>'s <TT>which</TT> and
<TT>guessLocation</TT> functions to look for web browsers
in a way that kicks off searches in standard install directory trees.
Later in the book, we'll use this module in other
ways -- for instance, to search for demo programs and source code
files somewhere on the machine, with calls of this form:
</P>

<PRE>C:\temp&gt;<B>python</B>
&gt;&gt;&gt; <B>from PP2E.Launcher import guessLocation</B>
&gt;&gt;&gt; <B>guessLocation('hanoi.py')</B>
Searching for hanoi.py in C:\Program Files\Python
Searching for hanoi.py in C:\temp\examples
Searching for hanoi.py in C:\Program Files
Searching for hanoi.py in C:\
'C:\\PP2ndEd\\cdrom\\Python1.5.2\\SourceDistribution\\Unpacked\\Python-1.5.2
\\Demo\\tkinter\\guido\\hanoi.py'

&gt;&gt;&gt; <B>from PP2E.Launcher import findFirst</B>
&gt;&gt;&gt; <B>findFirst('.', 'PyMailGui.py')</B>
'.\\examples\\Internet\\Email\\PyMailGui.py'</PRE>

<P class="docText">Such searches aren't necessary if you can rely on an
environment variable to give at least part of the path to a file; for
instance, paths scripts within the <I>PP2E</I> examples
tree can be named by joining the <TT>PP2EHOME</TT> shell
variable, with the rest of the script's path (assuming the rest
of the script's path won't change, and we can rely on
that shell variable being set everywhere).
</P>

<P class="docText">Some scripts may also be able to compose relative paths to other
scripts using the <TT>sys.path[0]</TT> home-directory
indicator added for imports (see <A class="docLink" HREF="0596000855_python2-CHP-2-SECT-7.html#python2-CHP-2-SECT-7">Section 2.7</A>). But in cases where a file can appear at
arbitrary places, searches like those shown previously are sometimes
the best scripts can do. The earlier <I>hanoi.py</I>
program file, for example, can be anywhere on the underlying machine
(if present at all); searching is a more user-friendly final
alternative than simply giving up.
</P>

<P><A NAME="python2-CHP-4-SIDEBAR-2"></A><TABLE CELLSPACING="0" WIDTH="90%" BORDER="1"><TR><TD>
<H2 class="docSidebarTitle">Finding Programs on Windows</H2>

<P class="docText">Per a tip from a Python Windows guru, it may also be possible to
determine the location of the installed Python interpreter on Windows
with platform-specific code like this:
</P>

<PRE>import _winreg
try:
   keyname = "SOFTWARE\\Microsoft\\Windows\\"
             +
             "CurrentVersion\\AppPaths\\python.exe"
   pyexe   =_winreg.QueryValue(
            _winreg.HKEY_LOCAL_MACHINE, keyname)
except _winreg.error:
    # not found</PRE>

<P class="docText">This code uses the <TT>_winreg</TT> module (new as of
Python 1.6) to find Python if it has been installed correctly. The
same sort of code will work for most other well-installed
applications (e.g., web browsers), but not for some other kinds of
files (e.g., Python scripts). It's also too Windows-specific to
cover better in this text; see Windows resources for more details.
</P>
</TD></TR></TABLE></P>


<A NAME="python2-CHP-4-SECT-6.3"></A>
<H4 class="docSection2Title">4.6.3 Launching Web Browsers Portably</H4>

<P class="docText">Web browsers can do amazing things these days. They can serve as
document viewers, remote program launchers, database interfaces,
media players, and more. Being able to open a browser on a local or
remote page file <span class="docEmphasis">from within a script</span> opens up
all kinds of interesting user-interface possibilities. For instance,
a Python system might automatically display its HTML-coded
documentation when needed, by launching the local web browser on the
appropriate page file.<sup class="docFootnote"><A class="docLink" HREF="#">[5]</A></sup> Because most browsers know how to present
pictures, audio files, and movie clips, opening a browser on such a
file is also a simple way for scripts to deal with multimedia.
</P>
<blockquote><p class="docFootnote"><sup><A NAME="">[5]</A></sup> For example, the
PyDemosdemo bar GUI we'll meet in <A class="docLink" HREF="0596000855_python2-CHP-8.html#python2-CHP-8">Chapter 8</A>, has buttons that automatically open a
browser on web pages related to this book when pressed -- the
publisher's site, the Python home page, my update files, and so
on. </p></blockquote>

<P class="docText">The last script listed in this chapter is less ambitious than
<I>Launcher.py</I>, but equally reusable:
<I>LaunchBrowser.py</I> attempts to provide a
<span class="docEmphasis">portable</span> interface for starting a web browser.
Because techniques for launching browsers vary per platform, this
script provides an interface that aims to hide the differences from
callers. Once launched, the browser runs as an independent program,
and may be opened to view either a local file or a remote page on the
Web.
</P>

<P class="docText">Here's how it works. Because most web browsers can be started
with shell command lines, this script simply builds and launches one
as appropriate. For instance, to run a Netscape browser on Linux, a
shell command of the form <TT>netscape</TT><TT><I>
url</I></TT> is run, where <TT><I>url</I></TT> begins
with "file://" for local files, and "http://"
for live remote-page accesses (this is per URL conventions
we'll meet in more detail later, in <A class="docLink" HREF="0596000855_python2-CHP-12.html#python2-CHP-12">Chapter 12</A>). On Windows, a shell command like
<TT>start</TT> <TT><I>url</I></TT> achieves the
same goal. Here are some platform-specific highlights:
</P>

<DL class="docList">
<DT><I><span class="docPubcolor">Windows platforms</span></I></DT>
<DD>
<P class="docList">On Windows, the script either opens browsers with DOS
<I>start</I> commands, or searches for and runs browsers
with the <TT>os.spawnv</TT> call. On this platform,
browsers can usually be opened with simple <I>start</I>
commands (e.g., <TT>os.system("start</TT>
<TT>xxx.html")</TT>). Unfortunately,
<I>start</I> relies on the underlying filename
associations for web page files on your machine, picks a browser for
you per those associations, and has a command-line length limit that
this script might exceed for long local file paths or remote page
addresses.
</P>

<P class="docList">Because of that, this script falls back on running an explicitly
named browser with <TT>os.spawnv</TT>, if requested or
required. To do so, though, it must find the full path to a browser
executable. Since it can't assume that users will add it to the
PATH system search path (or this script's source code), the
script searches for a suitable browser with
<TT>Launcher</TT> module tools in both directories on PATH
and in common places where executables are installed on Windows.
</P>
</DD><DT><I><span class="docPubcolor">Unix-like platforms</span></I></DT>
<DD>
<P class="docList">On other platforms, the script relies on <TT>os.system</TT>
and the system PATH setting on the underlying machine. It simply runs
a command line naming the first browser on a candidates list that it
can find on your PATH setting. Because it's much more likely
that browsers are in standard search directories on platforms like
Unix and Linux (e.g., <I>/usr/bin</I>), the script
doesn't look for a browser elsewhere on the machine. Notice the
<TT>&amp;</TT> at the end of the browser command-line run;
without it, <TT>os.system</TT> calls block on Unix-like
platforms.
</P>
</DD>
</DL>

<P class="docText">All of this is easily customized (this is Python code, after all),
and you may need to add additional logic for other platforms. But on
all of my machines, the script makes reasonable assumptions that
allow me to largely forget most of the platform-specific bits
previously discussed; I just call the same
<TT>launchBrowser</TT> function everywhere. For more
details, let's look at <A class="docLink" HREF="#python2-CHP-4-EX-15">Example 4-15</A>.
</P>


<H5 class="docExampleTitle"><A NAME="python2-CHP-4-EX-15"></A>Example 4-15. PP2E\LaunchBrowser.py </H5>
<PRE>#!/bin/env python
#################################################################
# Launch a web browser to view a web page, portably.  If run 
# in '-live' mode, assumes you have a Internet feed and opens
# a page at a remote site.  Otherwise, assumes the page is a 
# full file path name on your machine, and opens the page file
# locally.  On Unix/Linux, finds first browser on your $PATH.
# On Windows, tries DOS "start" command first, or searches for
# the location of a browser on your machine for os.spawnv by 
# checking PATH and common Windows executable directories. You 
# may need to tweak browser executable name/dirs if this fails.
# This has only been tested in Win98 and Linux, so you may need 
# to add more code for other machines (mac: ic.launcurl(url)?).
#################################################################

import os, sys
from Launcher import which, guessLocation     # file search utilities
useWinStart = 1                               # 0=ignore name associations
onWindows   = sys.platform[:3] == 'win'
helptext    = "Usage: LaunchBrowser.py [ -file path | -live path site ]"
#browser    = r'c:\"Program Files"\Netscape\Communicator\Program\netscape.exe'

# defaults
Mode = '-file'
Page = os.getcwd(  ) + '/Internet/Cgi-Web/PyInternetDemos.html'
Site = 'starship.python.net/~lutz'

def launchUnixBrowser(url, verbose=1):            # add your platform if unique
    tries = ['netscape', 'mosaic', 'lynx']        # order your preferences here
    for program in tries:
        if which(program): break                  # find one that is on $path
    else:
        assert 0, 'Sorry - no browser found'
    if verbose: print 'Running', program
    os.system('%s %s &amp;' % (program, url))         # or fork+exec; assumes $path

def launchWindowsBrowser(url, verbose=1):
    if useWinStart and len(url) &lt;= 400:           # on windows: start or spawnv
        try:                                      # spawnv works if cmd too long
            if verbose: print 'Starting'       
            os.system('start ' + url)             # try name associations first
            return                                # fails if cmdline too long
        except: pass
    browser = None                                # search for a browser exe
    tries   = ['IEXPLORE.EXE', 'netscape.exe']    # try explorer, then netscape
    for program in tries:
        browser = which(program) or guessLocation(program, 1)
        if browser: break
    assert browser != None, 'Sorry - no browser found'
    if verbose: print 'Spawning', browser
    os.spawnv(os.P_DETACH, browser, (browser, url))

def launchBrowser(Mode='-file', Page=Page, Site=None, verbose=1):
    if Mode == '-live':
        url = 'http://%s/%s' % (Site, Page)       # open page at remote site
    else:
        url = 'file://%s' % Page                  # open page on this machine
    if verbose: print 'Opening', url
    if onWindows:
        launchWindowsBrowser(url, verbose)        # use windows start, spawnv
    else:
        launchUnixBrowser(url, verbose)           # assume $path on unix, linux

if __name__ == '__main__':
    # get command-line args
    argc = len(sys.argv)
    if argc &gt; 1:  Mode = sys.argv[1]
    if argc &gt; 2:  Page = sys.argv[2]
    if argc &gt; 3:  Site = sys.argv[3]
    if Mode not in ['-live', '-file']:
        print helptext
        sys.exit(1)
    else:
        launchBrowser(Mode, Page, Site)</PRE>


<A NAME="python2-CHP-4-SECT-6.3.1"></A>
<H5 class="docSection3Title">4.6.3.1 Launching browsers with command lines</H5>

<P class="docText">This module is designed to be both run and imported. When run by
itself on my Windows machine, Internet Explorer starts up. The
requested page file is always displayed in a new browser window when
<TT>os.spawnv</TT> is applied, but in the currently open
browser window (if any) when running a <I>start</I>
command:
</P>

<PRE>C:\...\PP2E&gt;<B>python LaunchBrowser.py</B>
Opening file://C:\PP2ndEd\examples\PP2E/Internet/Cgi-Web/PyInternetDemos.html
Starting</PRE>

<P class="docText">The seemingly odd mix of forward and backward slashes in the URL here
works fine within the browser; it pops up the window shown in <A class="docLink" HREF="#python2-CHP-4-FIG-2">Figure 4-2</A>.
</P>

<CENTER>
<H5 class="docFigureTitle"><A NAME="python2-CHP-4-FIG-2"></A>Figure 4-2. Launching a Windows browser on a local file</H5>
<IMG BORDER="0" WIDTH="330" HEIGHT="231" src="FILES/ppy2_0402.gif" ALT="figs/ppy2_0402.gif"></CENTER>

<P class="docText">By default, a <I>start</I> command is spawned; to see the
browser search procedure in action on Windows, set the script's
<TT>useWinStart</TT> variable to 0. The script will search
for a browser on your PATH settings, and then in common Windows
install directories hardcoded in <I>Launcher.py </I>:
</P>

<PRE>C:\...\PP2E&gt;<B>python LaunchBrowser.py </B>
<B>                       -file C:\Stuff\Website\public_html\about-pp.html</B>
Opening file://C:\Stuff\Website\public_html\about-pp.html
Looking for IEXPLORE.EXE on ['C:\\WINDOWS', 'C:\\WINDOWS', 
'C:\\WINDOWS\\COMMAND', 'C:\\STUFF\\BIN.MKS', 'C:\\PROGRAM FILES\\PYTHON']
Not at C:\WINDOWS\IEXPLORE.EXE
Not at C:\WINDOWS\IEXPLORE.EXE
Not at C:\WINDOWS\COMMAND\IEXPLORE.EXE
Not at C:\STUFF\BIN.MKS\IEXPLORE.EXE
Not at C:\PROGRAM FILES\PYTHON\IEXPLORE.EXE
IEXPLORE.EXE not on system path
Searching for IEXPLORE.EXE in C:\Program Files\Python
Searching for IEXPLORE.EXE in C:\PP2ndEd\examples\PP2E
Searching for IEXPLORE.EXE in C:\Program Files
Spawning C:\Program Files\Internet Explorer\IEXPLORE.EXE</PRE>

<P class="docText">If you study these trace message you'll notice that the browser
wasn't on the system search path, but was eventually located in
a local <I>C:\Program Files</I> subdirectory -- this
is just the <TT>Launcher</TT> module's
<TT>which</TT> and <TT>guessLocation</TT>
functions at work. As coded, the script searches for Internet
Explorer first; if that's not to your liking, try changing the
script's <TT>tries</TT> list to make Netscape first:
</P>

<PRE>C:\...\PP2E&gt;<B>python LaunchBrowser.py</B>
Opening file://C:\PP2ndEd\examples\PP2E/Internet/Cgi-Web/PyInternetDemos.html
Looking for netscape.exe on ['C:\\WINDOWS', 'C:\\WINDOWS', 
'C:\\WINDOWS\\COMMAND', 'C:\\STUFF\\BIN.MKS', 'C:\\PROGRAM FILES\\PYTHON']
Not at C:\WINDOWS\netscape.exe
Not at C:\WINDOWS\netscape.exe
Not at C:\WINDOWS\COMMAND\netscape.exe
Not at C:\STUFF\BIN.MKS\netscape.exe
Not at C:\PROGRAM FILES\PYTHON\netscape.exe
netscape.exe not on system path
Searching for netscape.exe in C:\Program Files\Python
Searching for netscape.exe in C:\PP2ndEd\examples\PP2E
Searching for netscape.exe in C:\Program Files
Spawning C:\Program Files\Netscape\Communicator\Program\netscape.exe</PRE>

<P class="docText">Here, the script eventually found Netscape in a different install
directory on the local machine. Besides automatically finding a
user's browser for them, this script also aims to be portable.
When running this file unchanged on Linux, the local Netscape browser
starts, if it lives on your PATH; otherwise, others are tried:
</P>

<PRE>[mark@toy ~/PP2ndEd/examples/PP2E]$ <B>python LaunchBrowser.py</B>
Opening file:///home/mark/PP2ndEd/examples/PP2E/Internet/Cgi-
Web/PyInternetDemos.html
Looking for netscape on ['/home/mark/bin', '.', '/usr/bin', '/usr/bin',
'/usr/local/bin', '/usr/X11R6/bin', '/bin', '/usr/X11R6/bin', '/home/mark/
bin', '/usr/X11R6/bin', '/home/mark/bin', '/usr/X11R6/bin']
Not at /home/mark/bin/netscape
Not at ./netscape
Found /usr/bin/netscape
Running netscape
[mark@toy ~/PP2ndEd/examples/PP2E]$</PRE>

<P class="docText">I have Netscape installed, so running the script this way on my
machine generates the window shown in <A class="docLink" HREF="#python2-CHP-4-FIG-3">Figure 4-3</A>,
seen under the KDE window manager.
</P>

<CENTER>
<H5 class="docFigureTitle"><A NAME="python2-CHP-4-FIG-3"></A>Figure 4-3. Launching a browser on Linux</H5>
<IMG BORDER="0" WIDTH="378" HEIGHT="300" src="FILES/ppy2_0403.gif" ALT="figs/ppy2_0403.gif"></CENTER>

<P class="docText">If you have an Internet connection, you can open pages at
<span class="docEmphasis">remote</span> servers too -- the next command opens
the root page at my site on the <span class="docEmphasis">starship.python.net</span>server, located somewhere
on the East Coast the last time I checked:
</P>

<PRE>C:\...\PP2E&gt;<B>python LaunchBrowser.py -live ~lutz starship.python.net</B>
Opening http://starship.python.net/~lutz
Starting</PRE>

<P class="docText">In <A class="docLink" HREF="0596000855_python2-CHP-8.html#python2-CHP-8">Chapter 8</A>, we'll see that this script is
also run to start Internet examples in the top-level demo launcher
system: the PyDemos script presented in that chapter portably opens
local or remote web page files with this button-press callback:
</P>

<PRE>[File mode]
    pagepath = os.getcwd(  ) + '/Internet/Cgi-Web'
    demoButton('PyErrata',  
               'Internet-based errata report system',
               'LaunchBrowser.py -file %s/PyErrata/pyerrata.html' % pagepath)

[Live mode]
    site = 'starship.python.net/~lutz'
    demoButton('PyErrata',  
               'Internet-based errata report system',
               'LaunchBrowser.py -live PyErrata/pyerrata.html ' + site)</PRE>



<A NAME="python2-CHP-4-SECT-6.3.2"></A>
<H5 class="docSection3Title">4.6.3.2 Launching browsers with function calls</H5>

<P class="docText">Other programs can spawn <I>LaunchBrowser.py</I>
command lines like those shown previously with tools like
<TT>os.system</TT>, as usual; but since the script's
core logic is coded in a function, it can just as easily be imported
and called:
</P>

<PRE>&gt;&gt;&gt; <B>from PP2E.LaunchBrowser import launchBrowser</B>
&gt;&gt;&gt; <B>launchBrowser(Page=r'C:\Stuff\Website\Public_html\about-pp.html')</B>
Opening file://C:\Stuff\Website\Public_html\about-pp.html
Starting
&gt;&gt;&gt;</PRE>

<P class="docText">When called like this, <TT>launchBrowser</TT> isn't
much different from spawning a <I>start</I> command on
DOS or a <I>netscape</I> command on Linux, but the Python
<TT>launchBrowser</TT> function is designed to be a
portable interface for browser startup across platforms. Python
scripts can use this interface to pop up local HTML documents in web
browsers; on machines with live Internet links, this call even lets
scripts open browsers on remote pages on the Web:
</P>

<PRE>&gt;&gt;&gt; <B>launchBrowser(Mode='-live', Page='index.html', Site='www.python.org')</B>
Opening http://www.python.org/index.html
Starting

&gt;&gt;&gt; <B>launchBrowser(Mode='-live', Page='~lutz/PyInternetDemos.html',</B>
...                             <B>Site='starship.python.net')</B>
Opening http://starship.python.net/~lutz/PyInternetDemos.html
Starting</PRE>

<P class="docText">On my computer, the first call here opens a new Internet Explorer GUI
window if needed, dials out through my modem, and fetches the Python
home page from <A class="docLink" target="_blank" HREF="http://www.python.org/default.htm">http://www.python.org</A> on both Windows and
Linux -- not bad for a single function call. The second call does
the same, but with a web demos page we'll explore later.
</P>



<A NAME="python2-CHP-4-SECT-6.3.3"></A>
<H5 class="docSection3Title">4.6.3.3 A Python "multimedia extravaganza"</H5>

<P class="docText">I mentioned earlier that browsers are a cheap way to present
multimedia. Alas, this sort of thing is best viewed live, so the best
I can do is show startup commands here. The next command line and
function call, for example, display two GIF images in Internet
Explorer on my machine (be sure to use full local pathnames). The
result of the first of these is captured in <A class="docLink" HREF="#python2-CHP-4-FIG-4">Figure 4-4</A>.
</P>

<PRE>C:\...\PP2E&gt;<B>python LaunchBrowser.py </B>
<B>                         -file C:\PP2ndEd\examples\PP2E\Gui\gifs\hills.gif</B>
Opening file://C:\PP2ndEd\examples\PP2E\Gui\gifs\hills.gif
Starting

C:\temp&gt;<B>python</B>
&gt;&gt;&gt; <B>from LaunchBrowser import launchBrowser</B>
&gt;&gt;&gt; <B>launchBrowser(Page=r'C:\PP2ndEd\examples\PP2E\Gui\gifs\mp_lumberjack.gif')</B>
Opening file://C:\PP2ndEd\examples\PP2E\Gui\gifs\mp_lumberjack.gif
Starting</PRE>

<CENTER>
<H5 class="docFigureTitle"><A NAME="python2-CHP-4-FIG-4"></A>Figure 4-4. Launching a browser on an image file</H5>
<IMG BORDER="0" WIDTH="189" HEIGHT="200" src="FILES/ppy2_0404.gif" ALT="figs/ppy2_0404.gif"></CENTER>

<P class="docText">The next command line and call open the <I>sousa.au</I>
audio file on my machine too; the second of these downloads the file
from <A class="docLink" target="_blank" HREF="http://www.python.org/default.htm">http://www.python.org</A> first.
If all goes as planned, they'll make the Monty Python theme
song play on your computer too:
</P>

<PRE>C:\PP2ndEd\examples&gt;<B>python LaunchBrowser.py</B>
<B>                         -file C:\PP2ndEd\examples\PP2E\Internet\Ftp\sousa.au</B>
Opening file://C:\PP2ndEd\examples\PP2E\Internet\Ftp\sousa.au
Starting

&gt;&gt;&gt; <B>launchBrowser(Mode='-live',</B>
...               <B>Site='www.python.org',</B>
...               <B>Page='ftp/python/misc/sousa.au',</B>
...               <B>verbose=0)</B>
&gt;&gt;&gt;</PRE>

<P class="docText">Of course, you could just pass these filenames to a spawned
<I>start</I> command on Windows, or run the appropriate
handler program directly with something like
<TT>os.system</TT>. But opening these files in a browser is
a more portable approach -- you don't need to keep track of
a set of file-handler programs per platform. Provided your scripts
use a portable browser launcher like
<TT>LaunchBrowser</TT>, you don't even need to keep
track of a browser per platform.
</P>

<P class="docText">In closing, I want to point out that <TT>LaunchBrowser</TT>
reflects browsers that I tend to use. For instance, it tries to find
Internet Explorer before Netscape on Windows, and prefers Netscape
over Mosaic and Lynx on Linux, but you should feel free to change
these choices in your copy of the script. In fact, both
<TT>LaunchBrowser</TT> and <TT>Launcher</TT> make
a few heuristic guesses when searching for files that may not make
sense on every computer. As always, hack on; this is Python, after
all.
</P>

<P><A NAME="python2-CHP-4-SIDEBAR-3"></A><TABLE CELLSPACING="0" WIDTH="90%" BORDER="1"><TR><TD>
<H2 class="docSidebarTitle">Reptilian Minds Think Alike</H2>

<P class="docText">A postscript: roughly one year after I wrote the
<TT>LaunchBrowser</TT> script, Python release 2.0 sprouted
a new standard library module that serves a similar purpose:
<TT>webbrowser.open(url)</TT> also attempts to provide a
portable interface for launching browsers from scripts. This module
is more complex, but likely to support more options than the
<TT>LaunchBrowser</TT> script presented here (e.g.,
Macintosh browsers are directly supported with the Mac
<TT>ic.launcurl(url)</TT> call -- a call I'd add
to <TT>LaunchBrowser</TT> too, if I had a Mac lying around
the office). See the library manual in releases 2.0 and later for
details.
</P>

<P class="docText">Just before publication, I stumbled onto another script called
<I>FixTk.py</I> in the <I>lib-tk</I>
subdirectory of the Python source library; at least in Python 1.5.2,
this script tries to locate the Tcl/Tk 8.0 DLLs on Windows by
checking common install directories, in order to allow Python/Tkinter
programs to work without Tcl/Tk PATH settings. It doesn't
recursively search directory trees like the
<TT>Launcher</TT> module presented in this chapter, and may
be defunct by the time you read this (Tk is copied into
Python's own install directory as of Python 2.0), but it is
similar in spirit to some of the tools in this chapter's last
section.
</P>
</TD></TR></TABLE></P>




<a href="0596000855_"><img src="FILES/pixel.gif" width="1" height="1" border="0"></a><ul></ul>
</td>
</tr>
</table>
<td></td>
<table width="100%" border="0" cellspacing="0" cellpadding="0" bgcolor="#CCCCCC">
<td><font color="black" size=1>I l<font color="#FF0000">@</font>ve RuBoard</td>
<td valign="top" class="v2" align="right">
          <a href="0596000855_python2-CHP-4-SECT-5.html"><img src="FILES/previous.gif" width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a>
          <a href="0596000855_python2-CHP-5.html"><img src="FILES/next.gif" width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a>
</td></table>
</body></html>
