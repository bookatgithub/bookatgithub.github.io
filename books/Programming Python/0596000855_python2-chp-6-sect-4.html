<html><head>
<META http-equiv="Content-Type" content="text/html">
<!--SafClassName="docSection1Title"--><!--SafTocEntry="6.4 Climbing the GUI Learning Curve"-->
<link rel="STYLESHEET" type="text/css" href="FILES/style.css">
<link rel="STYLESHEET" type="text/css" href="FILES/docsafari.css">
</head>
<body>
<table width="100%" border="0" cellspacing="0" cellpadding="0" bgcolor="#CCCCCC">
<td><font color="black" size=1>I l<font color="#FF0000">@</font>ve RuBoard</td>
<td valign="top" class="v2" align="right">
	<a href="0596000855_python2-CHP-6-SECT-3.html"><img src="FILES/previous.gif" width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a>
	<a href="0596000855_python2-CHP-6-SECT-5.html"><img src="FILES/next.gif" width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a>
</td></table>
<br>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<tr>
<td valign="top"><A NAME="python2-CHP-6-SECT-4"></A>
<H3 class="docSection1Title">6.4 Climbing the GUI Learning Curve</H3>

<P class="docText">On to the details. Let's start out by quickly stepping through
a few small examples that illustrate basic concepts, and show the
windows they create on the screen. The examples will become more
sophisticated as we move along.
</P>

<A NAME="python2-CHP-6-SECT-4.1"></A>
<H4 class="docSection2Title">6.4.1 "Hello World" in Four Lines (or Less)</H4>

<P class="docText">The usual first example for GUI systems is to show how to display a
"Hello World" message in a window. As coded in <A class="docLink" HREF="#python2-CHP-6-EX-1">Example 6-1</A>, it's just four lines in Python.
</P>


<H5 class="docExampleTitle"><A NAME="python2-CHP-6-EX-1"></A>Example 6-1. PP2E\Gui\Intro\gui1.py </H5>
<PRE>from Tkinter import Label                               # get a widget object
widget = Label(None, text='Hello GUI world!')           # make one
widget.pack()                                           # arrange it
widget.mainloop()                                       # start event loop</PRE>


<P class="docText">This is a complete Python Tkinter GUI program. When this script is
run, we get a simple window with a label in the middle; it looks like
<A class="docLink" HREF="#python2-CHP-6-FIG-1">Figure 6-1</A> on Windows.
</P>

<CENTER>
<H5 class="docFigureTitle"><A NAME="python2-CHP-6-FIG-1"></A>Figure 6-1. "Hello World" (gui1) on Windows</H5>
<IMG BORDER="0" WIDTH="111" HEIGHT="38" src="FILES/ppy2_0601.gif" ALT="figs/ppy2_0601.gif"></CENTER>

<P class="docText">This isn't much to write home about yet; but notice that this
is a completely functional, independent window on the
computer's display. It can be maximized to take up the entire
screen, minimized to hide it in the system bar, and resized. Click on
the window's "X" box in the top right to kill the
window and exit the program.
</P>

<P class="docText">The script that builds this window is also fully portable -- when
this same file is run on Linux it produces a similar window, but it
behaves according to the underlying Linux window manager. For
instance, Figures <A class="docLink" HREF="#python2-CHP-6-FIG-2">Figure 6-2</A> and <A class="docLink" HREF="#python2-CHP-6-FIG-3">Figure 6-3</A> show this simple script in action on the Linux
X Windows system, under the KDE and Gnome window managers,
respectively. Even on the same operating system, the same Python code
yields a different look and feel for different window systems.
</P>

<CENTER>
<H5 class="docFigureTitle"><A NAME="python2-CHP-6-FIG-2"></A>Figure 6-2. "Hello World" on Linux with KDE</H5>
<IMG BORDER="0" WIDTH="153" HEIGHT="39" src="FILES/ppy2_0602.gif" ALT="figs/ppy2_0602.gif"></CENTER>

<CENTER>
<H5 class="docFigureTitle"><A NAME="python2-CHP-6-FIG-3"></A>Figure 6-3. "Hello World" on Linux with Gnome</H5>
<IMG BORDER="0" WIDTH="124" HEIGHT="39" src="FILES/ppy2_0603.gif" ALT="figs/ppy2_0603.gif"></CENTER>

<P class="docText">The same script file would look different still when run on Macintosh
and other Unix-like window managers. On all platforms, though, its
basic functional behavior will be the same.
</P>


<A NAME="python2-CHP-6-SECT-4.2"></A>
<H4 class="docSection2Title">6.4.2 Tkinter Coding Basics</H4>

<P class="docText">The <TT>gui1</TT> script is a trivial example, but it
illustrates steps common to most Tkinter programs. This Python code:
</P>

<span style="font-weight:bold"><OL class="docList" TYPE="1">
<LI><span style="font-weight:normal"><P class="docList">Loads a widget class from the <TT>Tkinter</TT> module</P></span></LI>
<LI><span style="font-weight:normal"><P class="docList">Makes an instance of the imported <TT>Label</TT> class</P></span></LI>
<LI><span style="font-weight:normal"><P class="docList">Packs (arranges) the new <TT>Label</TT> in its parent widget</P></span></LI>
<LI><span style="font-weight:normal"><P class="docList">Calls <TT>mainloop</TT> to bring up the window and start
the Tkinter event loop
</P></span></LI>
</OL></span>
<P class="docText"><A NAME="IXT-6-336990"></A>The
<TT>mainloop</TT> method called last puts the label on the
screen and enters a Tkinter wait state, which watches for
user-generated GUI events. Within the <TT>mainloop</TT>
function, Tkinter internally monitors things like the keyboard and
mouse, to detect user-generated events. Because of this model, the
<TT>mainloop</TT> call here never returns to our script
while the GUI is displayed on-screen.<sup class="docFootnote"><A class="docLink" HREF="#">[6]</A></sup> As
we'll see when we reach larger scripts, the only way we can get
anything done after calling <TT>mainloop</TT> is to
register callback handlers to respond to events.
</P>
<blockquote><p class="docFootnote"><sup><A NAME="">[6]</A></sup> Technically,
the <TT>mainloop</TT> call returns to your script only
after the Tkinter event loop exits. This normally happens when the
GUI's main window is closed, but may also occur in response to
explicit <TT>quit</TT> method calls that terminate nested
event loops but leave the GUI at large open. You'll see why
this matters in <A class="docLink" HREF="0596000855_python2-CHP-7.html#python2-CHP-7">Chapter 7</A>.</p></blockquote>

<P class="docText">Note that you really need both steps 3 and 4 to open this
script's GUI. To display a GUI's window at all, you need
to call <TT>mainloop</TT>; to display widgets within the
window they must be packed (or otherwise arranged) so that the
Tkinter geometry manager knows about them. In fact, if you call
either <TT>mainloop</TT> or <TT>pack</TT> without
calling the other, your window won't show up as expected: a
<TT>mainloop</TT> without a <TT>pack</TT> shows
an empty window, and a <TT>pack</TT> without a
<TT>mainloop</TT> in a script shows nothing since the
script never enters an event wait state (try it). Since the concepts
illustrated by this simple script are at the core of most Tkinter
programs, let's take a deeper look a some of them before moving
on.
</P>

<A NAME="python2-CHP-6-SECT-4.2.1"></A>
<H5 class="docSection3Title">6.4.2.1 Making widgets</H5>

<P class="docText">When widgets are constructed in Tkinter, we can specify how they
should be configured. The <TT>gui1</TT> script passes two
arguments to the <TT>Label</TT> class constructor:
</P>

<UL>
<LI><P class="docList">The first is a parent-widget object, which we want the new label to
be attached to. Here, <TT>None</TT> means: "attach
the new <TT>Label</TT> to the default top-level window of
this program." Later, we'll pass real widgets in this
position, to attach our labels to other container objects.
</P></LI>
<LI><P class="docList">The second is a configuration option for the
<TT>Label</TT>, passed as a keyword argument: the
<TT>text</TT> option specifies a text string to appear as
the label's message. Most widget constructors accept multiple
keyword arguments for specifying a variety of options (color, size,
callback handlers, and so on). Most widget configuration options have
reasonable defaults per platform, though, and this accounts for much
of Tkinter's simplicity -- you only need to set most options
if you wish to do something custom.
</P></LI>
</UL>
<P class="docText">As we'll see, the parent-widget argument is the hook we use to
build-up complex GUIs as widget trees. Tkinter works on a
"what-you-build-is-what-you-get" principle: we construct
widget object trees as models of what we want to see on the screen,
and then ask the tree to display itself by calling
<TT>mainloop</TT>.
</P>



<A NAME="python2-CHP-6-SECT-4.2.2"></A>
<H5 class="docSection3Title">6.4.2.2 Geometry managers</H5>

<P class="docText"><A NAME="IXT-6-336991"></A>
<A NAME="IXT-6-336992"></A>
<A NAME="IXT-6-336993"></A>The
<TT>pack</TT> widget method called by the
<TT>gui1</TT> script invokes the packer geometry
manager -- one of three ways to control how widgets are arranged
in a window. Tkinter geometry managers simply arrange one or more
widgets within a container (sometimes called a parent, or master).
Both top-level windows and frames (a special kind of widget
we'll meet later) can serve as containers, and containers may
be nested inside other containers to build hierarchical displays.
</P>

<P class="docText">The packer geometry manager uses constraint option settings to
automatically position widgets in a window. Scripts supply
higher-level instructions (e.g., "attach this widget to the top
of its container, and stretch it to fill its space
vertically"), not absolute pixel coordinates. Because such
constraints are so abstract, the packer provides a powerful and
easy-to-use layout system. In fact, you don't even have to
specify constraints -- if you don't pass any arguments to
<TT>pack</TT>, you get default packing, which attaches the
widget to side top.
</P>

<P class="docText">We'll visit the packer repeatedly in this chapter, and use it
in many of the examples in this book. In <A class="docLink" HREF="0596000855_python2-CHP-8.html#python2-CHP-8">Chapter 8</A>
we will also meet an alternative <TT>grid</TT> geometry
manager and layout system that arranges widgets within a container in
tabular form (i.e., by rows and columns). A third alternative, the
<span class="docEmphasis">placer</span> geometry manager system, is described in
Tk documentation, but not in this book; it's less popular than
the <TT>pack</TT> and <TT>grid</TT> managers, and
can be difficult to use for larger GUIs.
</P>



<A NAME="python2-CHP-6-SECT-4.2.3"></A>
<H5 class="docSection3Title">6.4.2.3 Running GUI programs</H5>

<P class="docText">Like all Python code, the module in <A class="docLink" HREF="#python2-CHP-6-EX-1">Example 6-1</A> can
be started in a number of ways: by running it as a top-level program
file:<A NAME="IXT-6-336994"></A>
</P>

<PRE>C:\...\PP2E\Gui\Intro&gt;<B>python gui1.py</B></PRE>

<P class="docText">by importing it from a Python session or another module file:</P>

<PRE>&gt;&gt;&gt; <B>import gui1</B></PRE>

<P class="docText">by running it as a Unix executable, if we add the special
<TT>#!</TT> line at the top:
</P>

<PRE>% <B>gui1.py &amp;</B></PRE>

<P class="docText">and in any other way that Python programs can be launched on your
platform. For instance, the script can also be run by clicking on the
file's name in a Windows file explorer, and its code can be
typed interactively at the <TT>&gt;&gt;&gt;</TT> prompt. It
can even be run from a C program, by calling the appropriate
embedding API function (see <A class="docLink" HREF="0596000855_python2-CHP-20.html#python2-CHP-20">Chapter 20</A>, for
details).<A NAME="IXT-6-336995"></A><A NAME="IXT-6-336996"></A>
</P>

<P class="docText">In other words, there really are no special rules to follow when
running GUI Python code. The Tkinter interface (and Tk itself) are
linked into the Python interpreter. When a Python program calls GUI
functions, they're simply passed to the embedded GUI system
behind the scenes. That makes it easy to write command-line tools
that pop up windows; they are run the same way as the purely
text-based scripts we studied in the prior part of this book.
</P>



<A NAME="python2-CHP-6-SECT-4.2.4"></A>
<H5 class="docSection3Title">6.4.2.4 Avoiding DOS consoles on Windows</H5>

<P class="docText">Earlier in this book we learned that if a program's name ends
in a <span class="docEmphasis">.pyw</span> extension instead of
<span class="docEmphasis">.py</span>, the Windows Python port does not pop up a
DOS console box to serve as its standard streams when the file is
launched by clicking its filename icon. Now that we've finally
started making windows of our own, that filename trick will start to
become even more useful.
</P>

<P class="docText">If you just want to see the windows that your script makes no matter
how it is launched, be sure to name your GUI scripts with a
<A class="docLink" target="_blank" HREF=".pyw">.pyw</A> if they might be run on
Windows. For instance, clicking on the file in <A class="docLink" HREF="#python2-CHP-6-EX-2">Example 6-2</A> in a Windows explorer creates just the window
in <A class="docLink" HREF="#python2-CHP-6-FIG-1">Figure 6-1</A>.
</P>


<H5 class="docExampleTitle"><A NAME="python2-CHP-6-EX-2"></A>Example 6-2. PP2E\Gui\Intro\gui1.pyw </H5>
<PRE><I>...same as gui1.py...</I></PRE>


<P class="docText">You can also avoid the DOS popup on Windows by running the program
with the <span class="docEmphasis">pythonw.exe</span> executable, not
<span class="docEmphasis">python.exe</span> (in fact, <span class="docEmphasis">.pyw</span>
files are simply registered to be opened by
<span class="docEmphasis">pythonw</span>). On Linux, the
<span class="docEmphasis">.pyw</span> doesn't hurt, but isn't
necessary -- there is no notion of a streams popup on Unix-like
machines. On the other hand, if your GUI scripts might run on Windows
in the future, adding an extra "w" at the end of their
names now might save porting effort later. In this book,
<span class="docEmphasis">.py</span> filenames are still sometimes used to pop up
console windows for viewing printed messages on Windows.
</P>



<A NAME="python2-CHP-6-SECT-4.3"></A>
<H4 class="docSection2Title">6.4.3 Tkinter Coding Alternatives</H4>

<P class="docText">As you might expect, there are a variety of ways to code the
<TT>gui1</TT> example. For instance, if you want to make
all your Tkinter imports more explicit in your script, grab the whole
module and prefix all its names with the module's name, as in
<A class="docLink" HREF="#python2-CHP-6-EX-3">Example 6-3</A>.
</P>


<H5 class="docExampleTitle"><A NAME="python2-CHP-6-EX-3"></A>Example 6-3. PP2E\Gui\Intro\gui1b.py - import versus from </H5>
<PRE>import Tkinter
widget = Tkinter.Label(None, text='Hello GUI world!') 
widget.pack()
widget.mainloop()</PRE>


<P class="docText">That will probably get tedious in realistic examples,
though -- Tkinter exports dozens of widget classes and constants
that show up all over Python GUI scripts. In fact, it is usually
easier to use a <TT>*</TT> to import everything from the
Tkinter module by name in one shot. This is demonstrated in <A class="docLink" HREF="#python2-CHP-6-EX-4">Example 6-4</A>.
</P>


<H5 class="docExampleTitle"><A NAME="python2-CHP-6-EX-4"></A>Example 6-4. PP2E\Gui\Intro\gui1c.py - roots, sides, pack in-place </H5>
<PRE>from Tkinter import *
root = Tk() 
Label(root, text='Hello GUI world!').pack(side=TOP) 
root.mainloop()</PRE>


<P class="docText">The Tkinter module goes out of its way to only export things that we
really need, so it's one of the few for which the
<TT>*</TT> import form is relatively safe to
apply.<sup class="docFootnote"><A class="docLink" HREF="#">[7]</A></sup> The
<TT>TOP</TT> constant in the <TT>pack</TT> call
here, for instance, is one of those many names exported by the
<TT>Tkinter</TT> module. It's simply a variable name
(<TT>TOP="top"</TT>) preassigned in
<TT>Tkconstants</TT>, a module automatically loaded by
<TT>Tkinter</TT>.
</P>
<blockquote><p class="docFootnote"><sup><A NAME="">[7]</A></sup> If you study file
<I>Tkinter.py</I> in the Python source library,
you'll notice that top-level module names not meant for export
start with a single underscore. Python never copies over such names
when a module is accessed with the <TT>*</TT> form of the
<TT>from</TT> statement. </p></blockquote>

<P class="docText">When widgets are packed, we can specify which side of their parent
they should be attached to -- <TT>TOP</TT>,
<TT>BOTTOM</TT>, <TT>LEFT</TT>, or
<TT>RIGHT</TT>. If no <TT>side</TT> option is
sent to <TT>pack</TT> (as in prior examples), a widget is
attached to its parent's <TT>TOP</TT> by default. In
general, larger Tkinter GUIs can be constructed as sets of
rectangles, attached to the appropriate sides of other, enclosing
rectangles. As we'll see later, Tkinter arranges widgets in a
rectangle according to both their packing order and their
<TT>side</TT> attachment options. When widgets are gridded,
they are assigned row and column numbers instead. None of this will
become very meaningful, though, until we have more than one widget in
a window, so let's move on.
</P>

<P class="docText">Notice that this version calls the <TT>pack</TT> method
right away after creating the label, without assigning it a variable.
If we don't need to save a widget, we can pack it in place like
this to eliminate a statement. We'll use this form when a
widget is attached to a larger structure and never again referenced.
This can be tricky if you assign the <TT>pack</TT> result,
though, but I'll postpone an explanation of why until
we've covered a few more basics.
</P>

<P class="docText">We also use a <TT>Tk</TT> widget class instance as the
parent here, instead of <TT>None</TT>.
<TT>Tk</TT> represents the main ("root") window
of the program -- the one that starts when the program does.
<TT>Tk</TT> is also used as the default parent widget, both
when we don't pass any parent to other widget calls, and when
we pass the parent as <TT>None</TT>. In other words,
widgets are simply attached to the main program window by default.
This script just makes this default behavior explicit, by making and
passing the <TT>Tk</TT> object itself. In <A class="docLink" HREF="0596000855_python2-CHP-7.html#python2-CHP-7">Chapter 7</A>, we'll see that
<TT>Toplevel</TT> widgets are typically used to generate
new pop-up windows that operate independently of the program's
main window.
</P>

<P class="docText">In Tkinter, some widget methods are exported as functions too, and
this lets us shave <A class="docLink" HREF="#python2-CHP-6-EX-5">Example 6-5</A> to just three lines
of code.
</P>


<H5 class="docExampleTitle"><A NAME="python2-CHP-6-EX-5"></A>Example 6-5. PP2E\Gui\Intro\gui1d.py - a minimal version </H5>
<PRE>from Tkinter import *
Label(text='Hello GUI world!').pack()
mainloop() </PRE>


<P class="docText">The Tkinter <TT>mainloop</TT> can be called with or without
a widget (i.e., as a function or method). We didn't pass
<TT>Label</TT> a parent argument in this version either: it
simply defaults to <TT>None</TT> when omitted (which in
turn defaults to <TT>Tk</TT>). But relying on that default
is less useful once we start building larger displays -- things
like labels are more typically attached to other widget containers.
</P>

<A NAME="python2-CHP-6-SECT-4.3.1"></A>
<H5 class="docSection3Title">6.4.3.1 Widget resizing basics</H5>

<P class="docText">Top-level windows, like the one all of the coding variants seen thus
far build, can normally be resized by the user -- simply drag out
the window with your mouse. <A class="docLink" HREF="#python2-CHP-6-FIG-4">Figure 6-4</A> shows how
our window looks when it is expanded.
</P>

<CENTER>
<H5 class="docFigureTitle"><A NAME="python2-CHP-6-FIG-4"></A>Figure 6-4. Expanding gui1</H5>
<IMG BORDER="0" WIDTH="170" HEIGHT="84" src="FILES/ppy2_0604.gif" ALT="figs/ppy2_0604.gif"></CENTER>

<P class="docText">This isn't very good -- the label stays attached to the top
of the parent window instead of staying in the middle on
expansion -- but it's easy to improve on this with a pair of
<TT>pack</TT> options, demonstrated in <A class="docLink" HREF="#python2-CHP-6-EX-6">Example 6-6</A>.
</P>


<H5 class="docExampleTitle"><A NAME="python2-CHP-6-EX-6"></A>Example 6-6. PP2E\Gui\Intro\gui1e.py - expansion </H5>
<PRE>from Tkinter import *
Label(text='Hello GUI world!').pack(expand=YES, fill=BOTH)
mainloop() </PRE>


<P class="docText">When widgets are packed, we can specify whether a widget should
expand to take up all available space, and if so, how it should
stretch to fill that space. By default, widget are not expanded when
their parent is. But in this script, names <TT>YES</TT> and
<TT>BOTH</TT> (imported from the Tkinter module) specify
that the label should grow along with its parent, the main window. It
does, in <A class="docLink" HREF="#python2-CHP-6-FIG-5">Figure 6-5</A>.
</P>

<CENTER>
<H5 class="docFigureTitle"><A NAME="python2-CHP-6-FIG-5"></A>Figure 6-5. gui1e with widget resizing </H5>
<IMG BORDER="0" WIDTH="139" HEIGHT="117" src="FILES/ppy2_0605.gif" ALT="figs/ppy2_0605.gif"></CENTER>

<P class="docText"><A NAME="IXT-6-336997"></A>
<A NAME="IXT-6-336998"></A>
<A NAME="IXT-6-336999"></A>Technically, the packer geometry
manager assigns a size to each widget in a display, based on what it
contains (text string lengths, etc.). By default, a widget only can
occupy its allocated space, and is no bigger than its assigned size.
The <TT>expand</TT> and <TT>fill</TT> options let
us be more specific about such things:
</P>

<UL>
<LI><P class="docList">The <TT>expand=YES</TT> option asks the packer to expand
the allocated space for the widget in general, into any unclaimed
space in the widget's parent.
</P></LI>
<LI><P class="docList">The <TT>fill</TT> option can be used to stretch the widget
to occupy all of its allocated space.
</P></LI>
</UL>
<P class="docText">Combinations of these two options produce different layout and
resizing effects, some of which only become meaningful when there are
multiple widgets in a window. For example, using
<TT>expand</TT> without <TT>fill</TT> centers the
widget in the expanded space, and the <TT>fill</TT> option
can specify vertical stretching only (<TT>fill=Y</TT>),
horizontal stretching only (<TT>fill=X</TT>), or both
(<TT>fill=BOTH</TT>). By providing these constraints and
attachment sides for all widgets in a GUI, we can control the layout
in fairly precise terms. In later chapters, we'll find that the
<TT>grid</TT> geometry manager uses a different resizing
protocol entirely.
</P>

<P class="docText">This all can be confusing the first time you hear it, and we'll
return to this later. But if you're not sure what an
<TT>expand</TT> and <TT>fill</TT> combination
will do, simply try it out -- this is Python after all. For now,
remember that the combination of <TT>expand=YES</TT> and
<TT>fill=BOTH</TT> is perhaps the most common setting; it
means "expand my space allocation to occupy all available
space, and stretch me to fill the expanded space in both
directions." For our "Hello World" example, the net
result is that label grows as the window is expanded, and so is
always centered.
</P>



<A NAME="python2-CHP-6-SECT-4.3.2"></A>
<H5 class="docSection3Title">6.4.3.2 Configuring widget options and window titles</H5>

<P class="docText">So far, we've been telling Tkinter what to display on our label
by passing its text as a keyword argument in label constructor calls.
It turns out that there are two other ways to specify widget
configuration options. In <A class="docLink" HREF="#python2-CHP-6-EX-7">Example 6-7</A>, the
<TT>text</TT> option of the label is set after it is
constructed, by assigning to the widget's
<TT>text</TT> key -- widget objects overload index
operations such that options are also available as mapping keys, much
like a dictionary.
</P>


<H5 class="docExampleTitle"><A NAME="python2-CHP-6-EX-7"></A>Example 6-7. PP2E\Gui\Intro\guif.py - option keys </H5>
<PRE>from Tkinter import *
widget = Label()
widget['text'] = 'Hello GUI world!' 
widget.pack(side=TOP)
mainloop()</PRE>


<P class="docText">More commonly, widget options can be set after construction by
calling the widget <TT>config</TT> method, as in <A class="docLink" HREF="#python2-CHP-6-EX-8">Example 6-8</A>.
</P>


<H5 class="docExampleTitle"><A NAME="python2-CHP-6-EX-8"></A>Example 6-8. PP2E\Gui\Intro\gui1g.py - config and titles </H5>
<PRE>from Tkinter import *
root = Tk()
widget = Label(root)
widget.config(text='Hello GUI world!') 
widget.pack(side=TOP, expand=YES, fill=BOTH)
root.title('gui1g.py')
root.mainloop()</PRE>


<P class="docText">The <TT>config</TT> method (which can also be called by its
synonym, <TT>configure</TT>) can be called at any time
after construction to change the appearance of a widget on the fly.
For instance, we could call this label's
<TT>config</TT> method again later in the script to change
the text that it displays; watch for such dynamic reconfigurations in
later examples in this part of the book.
</P>

<P class="docText">Notice that this version also calls a <TT>root.title</TT>
method -- this call sets the label that appears at the top of the
window, as pictured in <A class="docLink" HREF="#python2-CHP-6-FIG-6">Figure 6-6</A>. In general
terms, top-level windows like the <TT>Tk</TT>
<TT>root</TT> here export window-manager interfaces: things
that have to do with the border around the window, not its contents.
</P>

<CENTER>
<H5 class="docFigureTitle"><A NAME="python2-CHP-6-FIG-6"></A>Figure 6-6. gui1g with expansion and a window title</H5>
<IMG BORDER="0" WIDTH="130" HEIGHT="106" src="FILES/ppy2_0606.gif" ALT="figs/ppy2_0606.gif"></CENTER>

<P class="docText">Just for fun, this version also centers the label on resizes by
setting the <TT>expand</TT> and <TT>fill</TT>
pack options too. In fact, this version makes just about everything
explicit, and is more representative of how labels are often coded in
full-blown interfaces -- their parents, expansion policies, and
attachments are usually all spelled out, rather than defaulted.
</P>



<A NAME="python2-CHP-6-SECT-4.3.3"></A>
<H5 class="docSection3Title">6.4.3.3 One more for old times' sake</H5>

<P class="docText">Finally, if you are both a minimalist and nostalgic for old Python
code, you can also program this "Hello World" example as
in <A class="docLink" HREF="#python2-CHP-6-EX-9">Example 6-9</A>.
</P>


<H5 class="docExampleTitle"><A NAME="python2-CHP-6-EX-9"></A>Example 6-9. PP2E\Gui\Intro\gui1-old.py - dictionary calls </H5>
<PRE>from Tkinter import *
Label(None, {'text': 'Hello GUI world!', Pack: {'side': 'top'}}).mainloop()</PRE>


<P class="docText">This makes the window in just two lines -- albeit gruesome ones!
This scheme relies on an old coding style that was widely used until
Python 1.3 that passed configuration options in a dictionary instead
of keyword arguments.<sup class="docFootnote"><A class="docLink" HREF="#">[8]</A></sup> In this scheme, packer options can be sent as
values of the key <TT>Pack</TT> (a class in the Tkinter
module).
</P>
<blockquote><p class="docFootnote"><sup><A NAME="">[8]</A></sup> In fact, Python's
pass-by-name keyword arguments were first introduced to help clean up
Tkinter calls like this. Internally, keyword arguments really are
passed as a dictionary (which can be collected with the
<TT>**name</TT> argument form in a <TT>def</TT>
header), so the two schemes are similar in implementation. But they
vary widely in the amount of characters you need to type and debug.
</p></blockquote>

<P class="docText">The dictionary call scheme still works, and you may see it in old
Python code, but please don't do this -- use keywords to
pass options, and explicit <TT>pack</TT> method calls in
your Tkinter scripts instead. In fact, the only reason I didn't
cut this example completely is that dictionaries can still be useful
if you want to compute and pass a set of options dynamically. On the
other hand, the built-in <TT>apply</TT> function now also
allows you to pass an explicit dictionary of keyword arguments in its
third argument slot, so there's no compelling reason to ever
use the pre-1.3 Tkinter dictionary call form at all.
</P>



<A NAME="python2-CHP-6-SECT-4.3.4"></A>
<H5 class="docSection3Title">6.4.3.4 Packing widgets without saving them</H5>

<P class="docText">In <I>gui1c.py</I> (shown in <A class="docLink" HREF="#python2-CHP-6-EX-4">Example 6-4</A>), I started packing labels without assigning
them to names. This works, and is an entirely valid coding style; but
because it tends to confuse beginners at first glance, I need to
explain why it works in more detail here.
</P>

<P class="docText">In Tkinter, Python class objects correspond to real objects displayed
on a screen; we make the Python object to make a screen object, and
call the Python object's methods to configure that screen
object. Because of this correspondence, the lifetime of the Python
object must generally correspond to the lifetime of the corresponding
object on the screen.
</P>

<P class="docText">Luckily, Python scripts don't usually need to care about
managing object lifetimes. In fact, they do not normally need to
maintain a reference to widget objects created along the way at all,
unless they plan to reconfigure those objects later. For instance,
it's common in Tkinter programming to pack a widget immediately
after creating it, if no further reference to the widget is required:
</P>

<PRE>Label(text='hi').pack()                        # okay</PRE>

<P class="docText">This expression is evaluated left to right as usual -- it creates
a new label, and then immediately calls the new object's
<TT>pack</TT> method, to arrange it in the display. Notice,
though, that the Python <TT>Label</TT> object is temporary
in this expression; because it is not assigned to a name, it would
normally be garbage collected (destroyed and reclaimed) by Python
immediately after running its <TT>pack</TT> method.
</P>

<P class="docText">However, because Tkinter emits Tk calls when objects are constructed,
the label will be drawn on the display as expected, even though we
haven't held on to the corresponding Python object in our
script. In fact, Tkinter internally cross-links widget objects into a
long-lived tree used to represent the display, so the
<TT>Label</TT> object made during this statement really is
retained, even if not by our code.<sup class="docFootnote"><A class="docLink" HREF="#">[9]</A></sup>
</P>
<blockquote><p class="docFootnote"><sup><A NAME="">[9]</A></sup> Ex-Tcl programmers
in the audience may be interested to know that Python not only builds
the widget tree internally, but uses it to automatically generate
widget pathname strings coded manually in Tcl/Tk (e.g.,
<TT>.panel.row.cmd</TT>). Python uses the addresses of
widget class objects to fill in the path components, and records path
names in the widget tree. A label attached to a container, for
instance, might have an assigned name like
<TT>.8220096.8219408</TT> inside Tkinter. You don't
need to care, though -- simply make and link widget objects by
passing parents, and let Python manage pathname details based on the
object tree. See the end of this chapter for more on Tk/Tkinter
mappings.</p></blockquote>

<P class="docText">In other words, your scripts don't generally need to care about
widget object lifetimes, and it's okay to make widgets and pack
them right away in the same statement. But that does not mean that
it's okay to say something like this:
</P>

<PRE>widget = Label(text='hi').pack()               # wrong!
<I>...use widget...</I></PRE>

<P class="docText">This statement almost seems like it should assign a newly packed
label to name <TT>widget</TT>, but it does not. In fact,
it's really a notorious Tkinter beginner's mistake. The
widget <TT>pack</TT> method packs the widget but does not
return the widget thus packed. Really, <TT>pack</TT>
returns the Python object <TT>None</TT>; after such a
statement, <TT>widget</TT> will be a reference to
<TT>None</TT>, and any further widget operations through
that name will fail. For instance, the following fails too, for the
same reason:
</P>

<PRE>Label(text='hi').pack().mainloop()             # wrong!</PRE>

<P class="docText">Since <TT>pack</TT> returns <TT>None</TT>, asking
for its <TT>mainloop</TT> attribute generates an exception
(as it should). If you really want to both pack a widget and retain a
reference to it, say this instead:
</P>

<PRE>widget = Label(text='hi')                      # okay too
widget.pack()
<I>...use widget...</I></PRE>

<P class="docText">This form is a bit more verbose, but is less tricky than packing a
widget in the same statement that creates it, and allows you to hold
onto the widget for later processing. On the other hand, scripts that
compose layouts often add widgets once and for all when they are
created, and never need to reconfigure them later; assigning to
long-lived names in such program is pointless and
unnecessary.<sup class="docFootnote"><A class="docLink" HREF="#">[10]</A></sup>
</P>
<blockquote><p class="docFootnote"><sup><A NAME="">[10]</A></sup> In <A class="docLink" HREF="0596000855_python2-CHP-7.html#python2-CHP-7">Chapter 7</A>,
we'll meet two exceptions to this rule. Scripts must manually
retain a reference to image objects because the underlying image data
is discarded if the Python image object is garbage-collected. Tkinter
variable class objects temporarily unset an associated Tk variable if
reclaimed, but this is uncommon and less harmful.</p></blockquote>



<A NAME="python2-CHP-6-SECT-4.4"></A>
<H4 class="docSection2Title">6.4.4 Adding Buttons and Callbacks</H4>

<P class="docText"><A NAME="IXT-6-337000"></A>So far, we've
learned how to display messages in labels, and met Tkinter core
concepts along the way. Labels are nice for teaching the basics, but
user interfaces usually need to do a bit more -- like actually
responding to users. The program in <A class="docLink" HREF="#python2-CHP-6-EX-10">Example 6-10</A>
creates the window in <A class="docLink" HREF="#python2-CHP-6-FIG-7">Figure 6-7</A>.
</P>


<H5 class="docExampleTitle"><A NAME="python2-CHP-6-EX-10"></A>Example 6-10. PP2E\Gui\Intro\gui2.py</H5>
<PRE>import sys
from Tkinter import *
widget = Button(None, text='Hello widget world', command=sys.exit)
widget.pack()
widget.mainloop()</PRE>


<P class="docText"><A NAME="IXT-6-337001"></A></P>

<CENTER>
<H5 class="docFigureTitle"><A NAME="python2-CHP-6-FIG-7"></A>Figure 6-7. A button on the top</H5>
<IMG BORDER="0" WIDTH="91" HEIGHT="45" src="FILES/ppy2_0607.gif" ALT="figs/ppy2_0607.gif"></CENTER>

<P class="docText">Here, instead of making a label, we create an instance of the Tkinter
<TT>Button</TT> class. It's attached to the default
top-level as before, on the default <TT>TOP</TT> packing
side. But the main thing to notice here is the button's
configuration arguments: we set an option called
<TT>command</TT> to the <TT>sys.exit</TT>
function.
</P>

<P class="docText">For buttons, the <TT>command</TT> option is the place where
we specify a callback handler function to be run when the button is
later pressed. In effect, we use <TT>command</TT> to
register an action for Tkinter to call when a widget's event
occurs. <A NAME="IXT-6-337002"></A>The callback handler used here
isn't very interesting: as we learned in an earlier chapter,
the built-in <TT>sys.exit</TT> function simply shuts down
the calling program. Here, that means pressing this button makes the
window go away.
</P>

<P class="docText">Just as for labels, there are other ways to code buttons. <A class="docLink" HREF="#python2-CHP-6-EX-11">Example 6-11</A> is a version that packs the button in place
without assigning it to a name, attaches it to the
<TT>LEFT</TT> side of its parent window explicitly, and
specifies <TT>root.quit</TT> as the callback
handler -- a standard <TT>Tk</TT> object method that
shuts down the GUI, and so ends the program (really, it ends the
current <TT>mainloop</TT> event loop call).
</P>


<H5 class="docExampleTitle"><A NAME="python2-CHP-6-EX-11"></A>Example 6-11. PP2E\Gui\Intro\gui2b.py </H5>
<PRE>from Tkinter import *
root = Tk()
Button(root, text='press', command=root.quit).pack(side=LEFT)
root.mainloop()</PRE>


<P class="docText">This version produces the window in <A class="docLink" HREF="#python2-CHP-6-FIG-8">Figure 6-8</A>.
Because we didn't tell the button to expand into all available
space, it does not.
</P>

<CENTER>
<H5 class="docFigureTitle"><A NAME="python2-CHP-6-FIG-8"></A>Figure 6-8. A button on the left</H5>
<IMG BORDER="0" WIDTH="91" HEIGHT="45" src="FILES/ppy2_0608.gif" ALT="figs/ppy2_0608.gif"></CENTER>

<P class="docText">In both of the last two examples, pressing the button makes the GUI
program exit. In older Tkinter code, you may sometimes see the string
"exit" assigned to the <TT>command</TT> option
to make the GUI go away when pressed. This exploits a tool in the
underlying Tk library, and is less Pythonic than
<TT>sys.exit</TT> or <TT>root.quit</TT>.
</P>

<A NAME="python2-CHP-6-SECT-4.4.1"></A>
<H5 class="docSection3Title">6.4.4.1 Widget resizing revisited: expansion</H5>

<P class="docText"><A NAME="IXT-6-337003"></A>
<A NAME="IXT-6-337004"></A>
<A NAME="IXT-6-337005"></A>Even with a GUI this simple, there are
many ways to lay out its appearance with Tkinter's
constraint-based <TT>pack</TT> geometry manager. For
example, to center the button in its window, add an
<TT>expand=YES</TT> option to the button's
<TT>pack</TT> method call, and generate a window like <A class="docLink" HREF="#python2-CHP-6-FIG-9">Figure 6-9</A>. This makes the packer allocate all available
space to the button, but does not stretch the button to fill that
space.
</P>

<CENTER>
<H5 class="docFigureTitle"><A NAME="python2-CHP-6-FIG-9"></A>Figure 6-9. side=LEFT, expand=YES</H5>
<IMG BORDER="0" WIDTH="91" HEIGHT="45" src="FILES/ppy2_0609.gif" ALT="figs/ppy2_0609.gif"></CENTER>

<P class="docText">If you want the button to be given all available space, and to
stretch to fill all of its assigned space horizontally, add
<TT>expand=YES</TT> and <TT>fill=X</TT> keyword
arguments to the <TT>pack</TT> call, and create the scene
in <A class="docLink" HREF="#python2-CHP-6-FIG-10">Figure 6-10</A>.
</P>

<CENTER>
<H5 class="docFigureTitle"><A NAME="python2-CHP-6-FIG-10"></A>Figure 6-10. side=LEFT, expand=YES, fill=X</H5>
<IMG BORDER="0" WIDTH="91" HEIGHT="45" src="FILES/ppy2_0610.gif" ALT="figs/ppy2_0610.gif"></CENTER>

<P class="docText">This makes the button fill the whole window initially (its allocation
is expanded, and it is stretched to fill that allocation). It also
makes the button grow as the parent window is resized. As shown in
<A class="docLink" HREF="#python2-CHP-6-FIG-11">Figure 6-11</A>, the button in this window does expand
when its parent expands, but only along the X horizontal axis.
</P>

<CENTER>
<H5 class="docFigureTitle"><A NAME="python2-CHP-6-FIG-11"></A>Figure 6-11. Resizing with expand=YES, fill=X</H5>
<IMG BORDER="0" WIDTH="213" HEIGHT="109" src="FILES/ppy2_0611.gif" ALT="figs/ppy2_0611.gif"></CENTER>

<P class="docText">To make the button grow in both directions, specify both
<TT>expand=YES</TT> and <TT>fill=BOTH</TT> in the
<TT>pack</TT> call; now, resizing the window makes the
button grow in general, as shown in <A class="docLink" HREF="#python2-CHP-6-FIG-12">Figure 6-12</A>. In
fact, for a good time, maximize this window to fill the entire
screen; you'll get one very big Tkinter button indeed.
</P>

<CENTER>
<H5 class="docFigureTitle"><A NAME="python2-CHP-6-FIG-12"></A>Figure 6-12. Resizing with expand=YES, fill=BOTH</H5>
<IMG BORDER="0" WIDTH="128" HEIGHT="118" src="FILES/ppy2_0612.gif" ALT="figs/ppy2_0612.gif"></CENTER>

<P class="docText">In more complex displays, such a button will only expand if all of
the widgets it is contained by are set to expand too. Here, the
button's only parent is the <TT>Tk</TT> root window
of the program, so parent expandability isn't yet an issue. We
will revisit the packer geometry manager when we meet multiple-widget
displays later in this tutorial, and again when we study the
alternative <TT>grid</TT> call in <A class="docLink" HREF="0596000855_python2-CHP-8.html#python2-CHP-8">Chapter 8</A>.
</P>



<A NAME="python2-CHP-6-SECT-4.5"></A>
<H4 class="docSection2Title">6.4.5 Adding User-Defined Callback Handlers</H4>

<P class="docText">In the simple button examples in the previous section, the callback
handler was simply an existing function that killed the GUI program.
It's not much more work to register callback handlers that do
something a bit more useful. <A class="docLink" HREF="#python2-CHP-6-EX-12">Example 6-12</A> defines a
callback handler of its own in Python.
</P>


<H5 class="docExampleTitle"><A NAME="python2-CHP-6-EX-12"></A>Example 6-12. PP2E\Gui\Intro\gui3.py </H5>
<PRE>from Tkinter import *

def quit():                                  # a custom callback handler
    print 'Hello, I must be going...'        # kill windows and process
    import sys; sys.exit() 

widget = Button(None, text='Hello event world', command=quit)
widget.pack()
widget.mainloop()</PRE>


<P class="docText">The window created by this script is shown in <A class="docLink" HREF="#python2-CHP-6-FIG-13">Figure 6-13</A>. This script and its GUI are almost identical
to the last example. But here, the <TT>command</TT> option
specifies a function we've defined locally. When the button is
pressed, Tkinter calls the <TT>quit</TT> function in this
file to handle the event. Inside <TT>quit</TT>, the
<TT>print</TT> statement types a message on the
program's <TT>stdout</TT> stream, and the GUI process
exits as before.
</P>

<CENTER>
<H5 class="docFigureTitle"><A NAME="python2-CHP-6-FIG-13"></A>Figure 6-13. A button that runs a Python function</H5>
<IMG BORDER="0" WIDTH="91" HEIGHT="45" src="FILES/ppy2_0613.gif" ALT="figs/ppy2_0613.gif"></CENTER>

<P class="docText">As usual, <TT>stdout</TT> is normally the window that the
program was started from, unless it's been redirected to a
file. It's a pop-up DOS console if you run this program by
clicking it on Windows -- add a <TT>raw_input</TT> call
before <TT>sys.exit</TT> if you have trouble seeing the
message before the pop-up disappears. Here's what the printed
output looks like back in standard stream world when the button is
pressed; it is generated by a Python function called automatically by
Tkinter:
</P>

<PRE>C:\...\PP2E\Gui\Intro&gt;python gui3.py
Hello, I must be going...

C:\...\PP2E\Gui\Intro&gt;</PRE>

<P class="docText">Normally, such messages would be displayed in another window, but we
haven't gotten far enough to know how just yet. Callback
functions usually do more, of course (and may even pop up new windows
altogether), but this example illustrates the basics.
</P>

<P class="docText">In general, callback handlers can be any callable object: functions,
anonymous functions generated with lambda expressions, bound methods
of class or type instances, or class instances that inherit a
<TT>__call__</TT> operator overload method. For
<TT>Button</TT> press callbacks, callback handlers always
receive no arguments (other than a <TT>self</TT>, for
bound-methods).
</P>

<A NAME="python2-CHP-6-SECT-4.5.1"></A>
<H5 class="docSection3Title">6.4.5.1 Lambda callback handlers</H5>

<P class="docText">To make the last paragraph a bit more concrete, let's take a
quick look at some other ways to code the callback handler in this
example. Recall that the Python lambda expression generates a new,
unnamed function object when run. If we need extra data passed in to
the handler function, we can register lambda expressions with default
argument values to specify the extra data needed. We'll see how
this can be useful later in this part of the book, but to illustrate
the basic idea, <A class="docLink" HREF="#python2-CHP-6-EX-13">Example 6-13</A> shows what this example
looks like when recoded to use a lambda instead of a
<TT>def</TT>.
</P>


<H5 class="docExampleTitle"><A NAME="python2-CHP-6-EX-13"></A>Example 6-13. PP2E\Gui\Intro\gui3b.py</H5>
<PRE>from Tkinter import *
from sys import stdout, exit                 # lambda generates a function
widget = Button(None,                        # but contains just an expression
             text='Hello event world', 
             command=(lambda: stdout.write('Hello lambda world\n') or exit()) )
widget.pack()
widget.mainloop()</PRE>


<P class="docText">This code is a bit tricky because lambdas can only contain an
expression; to emulate the original script, this version uses an
<TT>or</TT> operator to force two expressions to be run,
and writes to <TT>stdout</TT> to mimic a
<TT>print</TT>. More typically, lambdas are used to pass
along extra data to a callback handler using defaults:
</P>

<PRE>def handler(X, Y):              # would normallly be called with no args
<I>     use original X and Y here...</I>
X = <I> something here...</I>
Y = <I> something else
here...</I>
Button(text='ni', <B>command=(lambda save1=X, save2=Y: handler(save1, save2)) </B>)</PRE>

<P class="docText">Although Tkinter invokes <TT>command</TT> callbacks with no
arguments, such a lambda can be used to provide an indirect anonymous
function that wraps the real handler call, and passes along
information that existed when the GUI was first constructed. Since
default arguments are evaluated and saved when the lambda runs (not
when its result is later called), they are a way to remember objects
that must be accessed again later, during event processing.
We'll see this put to more concrete use later. If its syntax
confuses you, remember that a lambda expression like the one in the
preceding code can usually be coded as a simple nested
<TT>def</TT> statement instead:
</P>

<PRE>X = <I>something here...</I></PRE>

<PRE>Y = <I>something else here...</I></PRE>

<PRE><B>def func(save1=X, save2=Y): handler(save1, save2)</B>
Button(text='ni', command=func)</PRE>



<A NAME="python2-CHP-6-SECT-4.5.2"></A>
<H5 class="docSection3Title">6.4.5.2 Bound method callback handlers</H5>

<P class="docText">Class bound methods work particularly well as callback handlers too:
they record both an instance to send the event to, and an associated
method to call. As a preview, <A class="docLink" HREF="#python2-CHP-6-EX-14">Example 6-14</A> shows
<A class="docLink" HREF="#python2-CHP-6-EX-12">Example 6-12</A> rewritten to register a bound class
method, instead of a function or lambda result.
</P>


<H5 class="docExampleTitle"><A NAME="python2-CHP-6-EX-14"></A>Example 6-14. PP2E\Gui\Intro\gui3c.py </H5>
<PRE>from Tkinter import *

class HelloClass:
    def __init__(self):
        widget = Button(None, text='Hello event world', command=self.quit)
        widget.pack()
    def quit(self):
        print 'Hello class method world'    # self.quit is a bound method
        import sys; sys.exit()              # retains the self+quit pair

HelloClass()
mainloop()</PRE>


<P class="docText">On a button press, Tkinter calls this class's
<TT>quit</TT> method with no arguments as usual. But
really, is does receive one argument -- the original
<TT>self</TT> object -- even though Tkinter
doesn't pass it explicitly. Because the
<TT>self.quit</TT> bound method retains both
<TT>self</TT> and <TT>quit</TT>, it's
compatible with a simple function call; Python automatically passes
the <TT>self</TT> argument along to the method function.
Conversely, registering an unbound method like
<TT>HelloClass.quit</TT> won't work, because there is
no <TT>self</TT> object to pass along when the event later
occurs.
</P>

<P class="docText">Later, we'll see that class callback handler coding schemes
provide a natural place to remember information for use on events
too: simply assign it to <TT>self</TT> instance attributes:
</P>

<PRE>class someGuiClass:
    def __init__(self):
<I>                self.X = something here...</I>
<I>                self.Y = something else here...</I>
        Button(text='Hi', <B>command=self.handler </B>)
    def handler(self):
<I>                use self.X, self.Y here...</I></PRE>

<P class="docText">Because the event will be dispatched to this class's method
with a reference to the original instance object,
<TT>self</TT> gives access to attributes that retain
original data.
</P>



<A NAME="python2-CHP-6-SECT-4.5.3"></A>
<H5 class="docSection3Title">6.4.5.3 Callable class object callback handlers</H5>

<P class="docText">Because Python class instance objects can also be called if they
inherit a <TT>__call__</TT> method to intercept the
operation, we can pass one of these to serve as a callback handler
too, as in <A class="docLink" HREF="#python2-CHP-6-EX-15">Example 6-15</A>.
</P>


<H5 class="docExampleTitle"><A NAME="python2-CHP-6-EX-15"></A>Example 6-15. PP2E\Gui\Intro\gui3d.py </H5>
<PRE>from Tkinter import *

class HelloCallable:
    def __init__(self):                      # __init__ run on object creation
        self.msg = 'Hello __call__ world' 
    def __call__(self):
        print self.msg                       # __call__ run later when called 
        import sys; sys.exit()               # class object looks like a function

widget = Button(None, text='Hello event world', command=HelloCallable())
widget.pack()
widget.mainloop()</PRE>


<P class="docText">Here, the <TT>HelloCallable</TT> instance registered with
command can be called like a normal function too -- Python invokes
its <TT>__call__</TT> method to handle the call operation
made in Tkinter on the button press. Notice that
<TT>self.msg</TT> is used to retain information for use on
events here; <TT>self</TT> is the original instance when
the special <TT>__call__</TT> method is automatically
invoked.
</P>

<P class="docText">All four <TT>gui3</TT> variants create the same GUI window,
but print different messages to <TT>stdout</TT> when their
button is pressed:
</P>

<PRE>C:\...\PP2E\Gui\Intro&gt;python gui3.py
Hello, I must be going...

C:\...\PP2E\Gui\Intro&gt;python gui3b.py
Hello lambda world

C:\...\PP2E\Gui\Intro&gt;python gui3c.py
Hello class method world

C:\...\PP2E\Gui\Intro&gt;python gui3d.py
Hello __call__ world</PRE>

<P class="docText">There are good reasons for each callback coding scheme (function,
lambda, class method, callable class), but we need to move on to
larger examples to uncover them in less theoretical terms.
</P>



<A NAME="python2-CHP-6-SECT-4.5.4"></A>
<H5 class="docSection3Title">6.4.5.4 Other Tkinter callback protocols</H5>

<P class="docText">For future reference, also keep in mind that using
<TT>command</TT> options to intercept user-generated button
press events is just one way to register callbacks in Tkinter. In
fact, there are a variety of ways for Tkinter scripts to catch
events:
</P>

<DL class="docList">
<DT><I><span class="docPubcolor">Button command options</span></I></DT>
<DD>
<P class="docList">As we've just seen, button press events are intercepted by
providing a callable object in widget <TT>command</TT>
options. This is true of other kinds of button-like widgets
we'll meet in <A class="docLink" HREF="0596000855_python2-CHP-7.html#python2-CHP-7">Chapter 7</A> (e.g., radio and
check buttons, scales).
</P>
</DD><DT><I><span class="docPubcolor">Menu command options</span></I></DT>
<DD>
<P class="docList">In the upcoming Tkinter tour chapters, we'll also find that a
<TT>command</TT> option is used to specify callback
handlers for menu selections.
</P>
</DD><DT><I><span class="docPubcolor">Scrollbar protocols</span></I></DT>
<DD>
<P class="docList">Scrollbar widgets register handlers with <TT>command</TT>
options too, but they have a unique event protocol that allows them
to be cross-linked with the widget they are meant to scroll (e.g.,
listboxes, text displays, and canvases): moving the scrollbar
automatically moves the widget, and vice versa.
</P>
</DD><DT><I><span class="docPubcolor">General widget bind methods</span></I></DT>
<DD>
<P class="docList">A more general Tkinter event <TT>bind</TT> method mechanism
can be used to register callback handlers for lower-level interface
events -- key presses, mouse movement and clicks, and so on.
Unlike <TT>command</TT> callbacks, <TT>bind</TT>
callbacks receive an event object argument (an instance of the
Tkinter <TT>Event</TT> class), that gives context about the
event -- subject widget, screen coordinates, etc.
</P>
</DD><DT><I><span class="docPubcolor">Window manager protocols</span></I></DT>
<DD>
<P class="docList">In addition, scripts can also intercept window manager events (e.g.,
window close requests) by tapping into the window manager
<TT>protocol</TT> method mechanism available on top-level
window objects: setting a handler for
<TT>WM_DELETE_WINDOW</TT>, for instance, takes over window
close buttons.
</P>
</DD><DT><I><span class="docPubcolor">Scheduled event callbacks</span></I></DT>
<DD>
<P class="docList">Finally, Tkinter scripts can also register callback handlers to be
called in special contexts, such as timer expirations, input data
arrival, and event-loop idle states. Scripts can also pause for
state-change events related to windows and special variables.
We'll meet these event interfaces in more detail near the end
of <A class="docLink" HREF="0596000855_python2-CHP-8.html#python2-CHP-8">Chapter 8</A>.
</P>
</DD>
</DL>



<A NAME="python2-CHP-6-SECT-4.5.5"></A>
<H5 class="docSection3Title">6.4.5.5 Binding events</H5>

<P class="docText">Of all these, <TT>bind</TT> is the most general, but also
perhaps the most complex. We'll study it in more detail later,
but to let you sample its flavor now, <A class="docLink" HREF="#python2-CHP-6-EX-16">Example 6-16</A>
uses <TT>bind</TT>,not command, to
catch button presses.
</P>


<H5 class="docExampleTitle"><A NAME="python2-CHP-6-EX-16"></A>Example 6-16. PP2E\Gui\Intro\gui3e.py</H5>
<PRE>from Tkinter import *

def hello(event):
    print 'Press twice to exit'              # on single-left click

def quit(event):                             # on double-left click
    print 'Hello, I must be going...'        # event gives widget, x/y, etc.
    import sys; sys.exit() 

widget = Button(None, text='Hello event world')
widget.pack()
widget.bind('&lt;Button-1&gt;', hello)             # bind left mouse clicks
widget.bind('&lt;Double-1&gt;', quit)              # bind double-left clicks
widget.mainloop()</PRE>


<P class="docText">In fact, this version doesn't specify a
<TT>command</TT> option for the button at all. Instead, it
binds lower-level callback handlers for both left mouseclicks
(<TT>&lt;Button-1&gt;</TT>) and double-left mouseclicks
(<TT>&lt;Double-1&gt;</TT>) within the button's
display area. The <TT>bind</TT> method accepts a large set
of such event identifiers in a variety of formats, which we'll
meet in <A class="docLink" HREF="0596000855_python2-CHP-7.html#python2-CHP-7">Chapter 7</A>.
</P>

<P class="docText">When run, this script makes the same window again (see <A class="docLink" HREF="#python2-CHP-6-FIG-13">Figure 6-13</A>). Clicking on the button once prints a message
but doesn't exit; you need to double-click on the button now to
exit as before. Here is the output after clicking twice and
double-clicking once (a double-click fires the single-click callback
first):
</P>

<PRE>C:\...\PP2E\Gui\Intro&gt;python gui3e.py
Press twice to exit
Press twice to exit
Press twice to exit
Hello, I must be going...</PRE>

<P class="docText">Although this script intercepts button clicks manually, the end
result is roughly the same; widget-specific protocols like button
<TT>command</TT> options are really just higher-level
interfaces to events you can also catch with <TT>bind</TT>.
</P>

<P class="docText">We'll meet <TT>bind</TT> and all of the other Tkinter
event callback handler hooks again in more detail later in this book.
First, though, let's focus on building GUIs larger than a
single button, and other ways to use classes in GUI work.
</P>



<A NAME="python2-CHP-6-SECT-4.6"></A>
<H4 class="docSection2Title">6.4.6 Adding Multiple Widgets</H4>

<P class="docText"><A NAME="IXT-6-337006"></A><A NAME="IXT-6-337007"></A>It's time to start building user
interfaces with more than one widget. <A class="docLink" HREF="#python2-CHP-6-EX-17">Example 6-17</A>
makes the window shown in <A class="docLink" HREF="#python2-CHP-6-FIG-14">Figure 6-14</A>.
</P>


<H5 class="docExampleTitle"><A NAME="python2-CHP-6-EX-17"></A>Example 6-17. PP2E\Gui\Intro\gui4.py </H5>
<PRE>from Tkinter import *

def greeting():
    print 'Hello stdout world!...'

win = Frame()	
win.pack()
Label(win,  text='Hello container world').pack(side=TOP)          
Button(win, text='Hello', command=greeting).pack(side=LEFT)
Button(win, text='Quit',  command=win.quit).pack(side=RIGHT)

win.mainloop()</PRE>


<CENTER>
<H5 class="docFigureTitle"><A NAME="python2-CHP-6-FIG-14"></A>Figure 6-14. A multiple-widget window</H5>
<IMG BORDER="0" WIDTH="92" HEIGHT="60" src="FILES/ppy2_0614.gif" ALT="figs/ppy2_0614.gif"></CENTER>

<P class="docText">This example makes a <TT>Frame</TT> widget (another Tkinter
class), and attaches three other widget objects to it, a
<TT>Label</TT> and two <TT>Buttons</TT>, by
passing the <TT>Frame</TT> as their first argument. In
Tkinter terms, we say that the <TT>Frame</TT> becomes a
parent to the other three widgets. Both buttons on this display
trigger callbacks:
</P>

<UL>
<LI><P class="docList">Pressing the Hello button triggers the <TT>greeting</TT>
function defined within this file, which prints to
<TT>stdout</TT> again.
</P></LI>
<LI><P class="docList">Pressing the Quit button calls the standard Tkinter
<TT>quit</TT> method, inherited by <TT>win</TT>
from the <TT>Frame</TT> class
(<TT>Frame.quit</TT> has the same effect as the
<TT>Tk.quit</TT> we used earlier).
</P></LI>
</UL>
<P class="docText">Here is the <TT>stdout</TT> text that shows up on Hello
button presses, wherever this script's standard streams may be:
</P>

<PRE>C:\...\PP2E\Gui\Intro&gt;python gui4.py
Hello stdout world!...
Hello stdout world!...
Hello stdout world!...
Hello stdout world!...</PRE>

<P class="docText">The notion of attaching widgets to containers turns out to be at the
core of layouts in Tkinter. Before we go into more detail on that
topic, though, let's get small.
</P>

<A NAME="python2-CHP-6-SECT-4.6.1"></A>
<H5 class="docSection3Title">6.4.6.1 Widget resizing revisited: clipping</H5>

<P class="docText"><A NAME="IXT-6-337008"></A>
<A NAME="IXT-6-337009"></A>
<A NAME="IXT-6-337010"></A>Earlier, we saw how to make widgets
expand along with their parent window, by passing
<TT>expand</TT> and <TT>fill</TT> options to the
<TT>pack</TT> geometry manager. Now that we have a window
with more than one widget, I can let you in on one of the more useful
secrets in the packer. As a rule, widgets packed first are clipped
last, when a window is shrunk. That is, the order in which you pack
items determines which will be cut out of the display if it is made
too small -- widgets packed later are cut out first. For example,
<A class="docLink" HREF="#python2-CHP-6-FIG-15">Figure 6-15</A> shows what happens when the
<TT>gui4</TT> window is shrunk interactively.
</P>

<CENTER>
<H5 class="docFigureTitle"><A NAME="python2-CHP-6-FIG-15"></A>Figure 6-15. gui4 gets small</H5>
<IMG BORDER="0" WIDTH="91" HEIGHT="43" src="FILES/ppy2_0615.gif" ALT="figs/ppy2_0615.gif"></CENTER>

<P class="docText">Try reordering the label and button lines in the script and see what
happens when the window shrinks; the first packed is always the last
to go away. For instance, if the label is packed last, <A class="docLink" HREF="#python2-CHP-6-FIG-16">Figure 6-16</A> shows that it is clipped first even though it
is attached to the top: <TT>side</TT> attachments and
packing order both impact the overall layout, but only packing order
matters when windows shrink.
</P>

<CENTER>
<H5 class="docFigureTitle"><A NAME="python2-CHP-6-FIG-16"></A>Figure 6-16. Label packed last, clipped first</H5>
<IMG BORDER="0" WIDTH="91" HEIGHT="43" src="FILES/ppy2_0616.gif" ALT="figs/ppy2_0616.gif"></CENTER>

<P class="docText">Tkinter keeps track of the packing order internally to make this
work. Scripts can plan ahead for shrinkage by calling
<TT>pack</TT> methods of more important widgets first. For
instance, on the upcoming Tkinter tour we'll meet code that
builds menus and toolbars at the top and bottom of the window; to
make sure these are lost last as a window is shrunk, they are packed
first, before the application components in the middle. Similarly,
displays that include scrollbars normally pack them before the items
they scroll (e.g., text, lists), so that the scrollbars remain as the
window shrinks.
</P>



<A NAME="python2-CHP-6-SECT-4.6.2"></A>
<H5 class="docSection3Title">6.4.6.2 Attaching widgets to frames</H5>

<P class="docText">In larger terms, the critical innovation in this example is its use
of frames: <TT>Frame</TT> widgets are just containers for
other widgets, and so give rise to the notion of GUIs as widget
hierarchies, or trees. Here, <TT>win</TT> serves as an
enclosing window for the other three widgets. In general, though, by
attaching widgets to frames, and frames to other frames, we can build
up arbitrary GUI layouts. Simply divide the user interface into a set
of increasingly smaller rectangles, implement each as a Tkinter
<TT>Frame</TT>, and attach basic widgets to the frame in
the desired screen position.
</P>

<P class="docText">In this script, by specifying <TT>win</TT> in the first
argument to the <TT>Label</TT> and
<TT>Button</TT> constructors, they are attached to the
<TT>Frame</TT> by Tkinter (they become children of the
<TT>win</TT> parent). <TT>win</TT> itself is
attached to the default top-level window, since we didn't pass
a parent to the Frame constructor. When we ask <TT>win</TT>
to run itself (by calling <TT>mainloop</TT>), Tkinter draws
all the widgets in the tree we've built.
</P>

<P class="docText"><A NAME="IXT-6-337011"></A><A NAME="IXT-6-337012"></A>The three child widgets also provide
<TT>pack</TT> options now: the <TT>side</TT>
arguments tell which part of the containing frame (i.e.,
<TT>win</TT>) to attach the new widget to. The label hooks
onto the top, and the buttons attach to the sides.
<TT>TOP</TT>, <TT>LEFT</TT>, and
<TT>RIGHT</TT> are all preassigned string variables
imported from Tkinter. Arranging widgets is a bit more subtle than
simply giving a side, though, but we need to take a quick detour into
packer geometry management details to see why.
</P>



<A NAME="python2-CHP-6-SECT-4.6.3"></A>
<H5 class="docSection3Title">6.4.6.3 Packing order and side attachments</H5>

<P class="docText"><A NAME="IXT-6-337013"></A>
<A NAME="IXT-6-337014"></A>When a widget tree is displayed, child
widgets appear inside their parents, and are arranged according to
their order of packing and their packing options. Because of this,
the order in which widgets are packed not only gives their clipping
order, it also determines how their <TT>side</TT> settings
play out in the generated display.
</P>

<P class="docText">Here's how the packer's layout system works:</P>

<span style="font-weight:bold"><OL class="docList" TYPE="1">
<LI><span style="font-weight:normal"><P class="docList"><A NAME="IXT-6-337015"></A> <A NAME="IXT-6-337016"></A>The packer starts out with an available
space cavity that includes the entire parent container (e.g., the
whole <TT>Frame</TT> or top-level window).
</P></span></LI>
<LI><span style="font-weight:normal"><P class="docList">As each widget is packed on a side, that widget is given the entire
requested side in the remaining space cavity, and the space cavity is
shrunk.
</P></span></LI>
<LI><span style="font-weight:normal"><P class="docList">Later pack requests are given an entire side of what is left, after
earlier pack requests have shrunk the cavity.
</P></span></LI>
<LI><span style="font-weight:normal"><P class="docList">After widgets are given cavity space, <TT>expand</TT>
divides up any space left, and <TT>fill</TT> and
<TT>anchor</TT> stretch and position widgets within their
assigned space.
</P></span></LI>
</OL></span>
<P class="docText">For instance, if you recode the <TT>gui4</TT> child widget
creation logic like this:
</P>

<PRE>Button(win, text='Hello', command=greeting).pack(side=LEFT)
Label(win,  text='Hello container world').pack(side=TOP)
Button(win, text='Quit',  command=win.quit).pack(side=RIGHT)</PRE>

<P class="docText">You will wind up with the very different display in <A class="docLink" HREF="#python2-CHP-6-FIG-17">Figure 6-17</A>, even though you've only moved the label
code one line down in the source file (contrast with <A class="docLink" HREF="#python2-CHP-6-FIG-14">Figure 6-14</A>).
</P>

<CENTER>
<H5 class="docFigureTitle"><A NAME="python2-CHP-6-FIG-17"></A>Figure 6-17. Packing the label second</H5>
<IMG BORDER="0" WIDTH="123" HEIGHT="60" src="FILES/ppy2_0617.gif" ALT="figs/ppy2_0617.gif"></CENTER>

<P class="docText">Despite its <TT>side</TT> setting, the label does not get
the entire top of the window now, and you have to think in terms of
shrinking cavities to understand why. Because the Hello button is
packed first, it is given the entire <TT>LEFT</TT> side of
the <TT>Frame</TT>. Next, the label is given the entire
<TT>TOP</TT> side of what is left. Finally, the Quit button
gets the <TT>RIGHT</TT> side of the remainder -- a
rectangle to the right of the Hello button and under the label. When
this window shrinks, widgets are clipped in reverse order of their
packing: the Quit button disappears first, followed by the
label.<sup class="docFootnote"><A class="docLink" HREF="#">[11]</A></sup> In the original version of this
example, the label spans the entire top side just because it is the
first packed, not because of its <TT>side</TT> option.
</P>
<blockquote><p class="docFootnote"><sup><A NAME="">[11]</A></sup> Technically, the packing steps are just rerun
again after a window resize. But since this means that there
won't be enough space left for widgets packed last when the
window shrinks, it works the same as saying that widgets packed first
are clipped last.</p></blockquote>



<A NAME="python2-CHP-6-SECT-4.6.4"></A>
<H5 class="docSection3Title">6.4.6.4 The packer's expand and fill revisited</H5>

<P class="docText"><A NAME="IXT-6-337017"></A>
<A NAME="IXT-6-337018"></A>Beyond all this, the
<TT>fill</TT> option we met earlier can be used to stretch
the widget to occupy all the space in the cavity side it has been
given, and any cavity space left after all packing is evenly
allocated among widgets with the <TT>expand=YES</TT> we saw
before. For example, coding this way makes the window in <A class="docLink" HREF="#python2-CHP-6-FIG-18">Figure 6-18</A>:
</P>

<PRE>Button(win, text='Hello', command=greeting).pack(side=LEFT, <B>fill=Y</B>)
Label(win,  text='Hello container world').pack(side=TOP)
Button(win, text='Quit', command=win.quit).pack(side=RIGHT, <B>expand=YES, fill=X</B>)</PRE>

<CENTER>
<H5 class="docFigureTitle"><A NAME="python2-CHP-6-FIG-18"></A>Figure 6-18. Packing with expand and fill options</H5>
<IMG BORDER="0" WIDTH="123" HEIGHT="60" src="FILES/ppy2_0618.gif" ALT="figs/ppy2_0618.gif"></CENTER>

<P class="docText">To make these all grow along with their window, though, we also need
to make the container frame expandable -- widgets only expand
beyond their initial packer arrangement if all of their parents
expand too:
</P>

<PRE>win = Frame()
win.pack(side=TOP, <B>expand=YES, fill=BOTH</B>)
Button(win, text='Hello', command=greeting).pack(side=LEFT, fill=Y)
Label(win,  text='Hello container world').pack(side=TOP)
Button(win, text='Quit', command=win.quit).pack(side=RIGHT, expand=YES,fill=X)</PRE>

<P class="docText">When this code runs, the <TT>Frame</TT> is assigned the
entire top side of its parent as before (that is, the top parcel of
the root window); but because it is now marked to expand into unused
space in its parent and fill that space both ways, it and all its
attached children expand along with the window. <A class="docLink" HREF="#python2-CHP-6-FIG-19">Figure 6-19</A> shows how.
</P>

<CENTER>
<H5 class="docFigureTitle"><A NAME="python2-CHP-6-FIG-19"></A>Figure 6-19. gui4 gets big with an expandable frame</H5>
<IMG BORDER="0" WIDTH="199" HEIGHT="113" src="FILES/ppy2_0619.gif" ALT="figs/ppy2_0619.gif"></CENTER>



<A NAME="python2-CHP-6-SECT-4.6.5"></A>
<H5 class="docSection3Title">6.4.6.5 Using anchor to position instead of stretch</H5>

<P class="docText"><A NAME="IXT-6-337019"></A>
<A NAME="IXT-6-337020"></A> <A NAME="IXT-6-337021"></A> <A NAME="IXT-6-337022"></A>And as if that isn't flexible
enough, packer also allows widgets to be positioned within their
allocated space with an <TT>anchor</TT> option, instead of
filling that space with a <TT>fill</TT>. The
<TT>anchor</TT> option accepts Tkinter constants
identifying all eight points of the compass (<TT>N</TT>,
<TT>NE</TT>, <TT>NW</TT>, <TT>S</TT>,
etc.) and <TT>CENTER</TT> as its value (e.g.,
<TT>anchor=NW</TT>). It instructs the packer to position
the widget at the desired position within its allocated space, if the
space allocated for the widget is larger than the space needed to
display the widget.
</P>

<P class="docText">The default anchor is <TT>CENTER</TT>, so widgets show up
in the middle of their space (the cavity side they were given) unless
they are positioned with <TT>anchor</TT>, or stretched with
<TT>fill</TT>. To demonstrate, change
<TT>gui4</TT> to use this sort of code:
</P>

<PRE>Button(win, text='Hello', command=greeting).pack(side=LEFT, <B>anchor=N</B>)
Label(win,  text='Hello container world').pack(side=TOP)
Button(win, text='Quit',  command=win.quit).pack(side=RIGHT)</PRE>

<P class="docText">The only thing new here is that the Hello button is anchored to the
north side of its space allocation. Because this button was packed
first, it got the entire left side of the parent frame -- more
space than needed to show the button, so it shows up in the middle of
that side by default as in <A class="docLink" HREF="#python2-CHP-6-FIG-17">Figure 6-17</A> (i.e.,
anchored to the center). Setting the anchor to <TT>N</TT>
moves it to the top of its side, as shown in <A class="docLink" HREF="#python2-CHP-6-FIG-20">Figure 6-20</A>.
</P>

<CENTER>
<H5 class="docFigureTitle"><A NAME="python2-CHP-6-FIG-20"></A>Figure 6-20. Anchoring a button to the north</H5>
<IMG BORDER="0" WIDTH="123" HEIGHT="60" src="FILES/ppy2_0620.gif" ALT="figs/ppy2_0620.gif"></CENTER>

<P class="docText">Keep in mind that <TT>fill</TT> and
<TT>anchor</TT> are applied after a widget has been
allocated cavity side space by its <TT>side</TT>, packing
order, and <TT>expand</TT> extra space request. By playing
with packing orders, sides, fills, and anchors, you can generate lots
of layout and clipping effects, and you should take a few moments to
experiment with alternatives if you haven't already. In the
original version of this example, for instance, the label spans the
entire top side just because it is the first packed.
</P>

<P class="docText">As we'll see later, frames can be nested in other frames too,
to make more complex layouts. In fact, because each parent container
is a distinct space cavity, this provides a sort of escape mechanism
for the packer cavity algorithm: to better control where a set of
widgets show up, simply pack them within a nested subframe, and
attach the frame as a package to a larger container. A row of
pushbuttons, for example, might be easier laid out in a frame of its
own than mixed with other widgets in the display directly.
</P>

<P class="docText">Finally, also keep in mind that the widget tree created by these
examples is really an implicit one; Tkinter internally records the
relationships implied by passed parent widget arguments. In OOP
terms, this is a composition relationship -- the
<TT>Frame</TT> contains a <TT>Label</TT> and
<TT>Buttons</TT>; let's look at inheritance
relationships next.
</P>



<A NAME="python2-CHP-6-SECT-4.7"></A>
<H4 class="docSection2Title">6.4.7 Customizing Widgets with Classes</H4>

<P class="docText"><A NAME="IXT-6-337023"></A><A NAME="IXT-6-337024"></A><A NAME="IXT-6-337025"></A>You
don't have to use OOP in Tkinter scripts, but it can definitely
help. As we just saw, Tkinter GUIs are built up as class-instance
object trees. Here's another way Python's OOP features
can be applied to GUI models: specializing widgets by inheritance.
<A class="docLink" HREF="#python2-CHP-6-EX-18">Example 6-18</A> builds the window in <A class="docLink" HREF="#python2-CHP-6-FIG-21">Figure 6-21</A>.
</P>


<H5 class="docExampleTitle"><A NAME="python2-CHP-6-EX-18"></A>Example 6-18. PP2E\Gui\Intro\gui5.py </H5>
<PRE>from Tkinter import *

class HelloButton(Button):
    def __init__(self, parent=None, **config):         # add callback method
        Button.__init__(self, parent, config)          # and pack myself
        self.pack()
        self.config(command=self.callback)
    def callback(self):                                # default press action
        print 'Goodbye world...'                       # replace in subclasses
        self.quit()
 
if __name__ == '__main__':
    HelloButton(text='Hello subclass world').mainloop()</PRE>


<CENTER>
<H5 class="docFigureTitle"><A NAME="python2-CHP-6-FIG-21"></A>Figure 6-21. A button subclass in action</H5>
<IMG BORDER="0" WIDTH="96" HEIGHT="45" src="FILES/ppy2_0621.gif" ALT="figs/ppy2_0621.gif"></CENTER>

<P class="docText">This example isn't anything special to look at: it just
displays a single button that prints a message and exits when
pressed. But this time, it is a button widget we created on our own.
The <TT>HelloButton</TT> class inherits everything from the
Tkinter <TT>Button</TT> class, but adds a
<TT>callback</TT> method and constructor logic to set the
<TT>command</TT> option to
<TT>self.callback</TT>, a bound method of the instance.
When the button is pressed this time, the new widget class's
<TT>callback</TT> method is invoked, not a simple function.
</P>

<P class="docText">The <TT>**config</TT> argument here is assigned unmatched
keyword arguments; they're passed along to the
<TT>Button</TT> constructor. We met the
<TT>config</TT> widget method called in
<TT>HelloButton</TT>'s constructor earlier; it is
just an alternative way to pass configuration options after the fact
(instead of passing constructor arguments).
</P>

<P class="docText">So what's the point of subclassing widgets like this? It allows
widgets to be configured by subclassing, instead of passing in
options. <TT>HelloButton</TT> is a true button; we pass in
configuration options as usual when one is made. But we can also
specify callback handlers by overriding the
<TT>callback</TT> method in subclasses, as shown in <A class="docLink" HREF="#python2-CHP-6-EX-19">Example 6-19</A>.
</P>


<H5 class="docExampleTitle"><A NAME="python2-CHP-6-EX-19"></A>Example 6-19. PP2E\Gui\Intro\gui5b.py </H5>
<PRE>from gui5 import HelloButton

class MyButton(HelloButton):        # subclass HelloButton
    def callback(self):             # redefine press-handler method
        print "Ignoring press!..."

if __name__ == '__main__':
    MyButton(None, text='Hello subclass world').mainloop()</PRE>


<P class="docText">Instead of exiting, this <TT>MyButton</TT> button prints to
<TT>stdout</TT> and stays up when pressed. Here is its
standard output after being pressed a few times:
</P>

<PRE>C:\PP2ndEd\examples\PP2E\Gui\Intro&gt;<B>python gui5b.py</B>
Ignoring press!...
Ignoring press!...
Ignoring press!...
Ignoring press!...</PRE>

<P class="docText">Whether it's simpler to customize widgets by subclassing or
passing in options is probably a matter of taste. But the point to
notice is that Tk becomes truly object-oriented in Python, just
because Python is object-oriented: we can specialize widget classes
using normal class-based OO techniques. The next example provides yet
another way to arrange for specialization.
</P>


<A NAME="python2-CHP-6-SECT-4.8"></A>
<H4 class="docSection2Title">6.4.8 Reusable GUI Components with Classes</H4>

<P class="docText"><A NAME="IXT-6-337026"></A><A NAME="IXT-6-337027"></A>Larger GUI interfaces are often built up
as subclasses of <TT>Frame</TT>, with callback handlers
implemented as methods. This structure gives us a natural place to
store information between events: instance attributes record state.
It also allows us to both specialize GUIs by overriding their methods
in new subclasses, and attach them to larger GUI structures to reuse
them as general components. For instance, a GUI text editor
implemented as a <TT>Frame</TT> subclass can be attached to
and configured by any number of other GUIs; if done well, we can plug
such a text editor into any user interface that needs text editing
tools.
</P>

<P class="docText">We'll meet such a text editor component in <A class="docLink" HREF="0596000855_python2-CHP-9.html#python2-CHP-9">Chapter 9</A>. For now, <A class="docLink" HREF="#python2-CHP-6-EX-20">Example 6-20</A> is a
simple example to illustrate the concept. Script
<I>gui6.py</I> produces the window in <A class="docLink" HREF="#python2-CHP-6-FIG-22">Figure 6-22</A>.
</P>


<H5 class="docExampleTitle"><A NAME="python2-CHP-6-EX-20"></A>Example 6-20. PP2E\Gui\Intro\gui6.py </H5>
<PRE>from Tkinter import *

class Hello(Frame):                            # an extended Frame
    def __init__(self, parent=None):
        Frame.__init__(self, parent)           # do superclass init
        self.pack()
        self.data = 42
        self.make_widgets()                    # attach widgets to self
    def make_widgets(self):
        widget = Button(self, text='Hello frame world!', command=self.message)
        widget.pack(side=LEFT)
    def message(self):
        self.data = self.data + 1
        print 'Hello frame world %s!' % self.data

if __name__ == '__main__': Hello().mainloop()</PRE>


<CENTER>
<H5 class="docFigureTitle"><A NAME="python2-CHP-6-FIG-22"></A>Figure 6-22. A custom Frame in action</H5>
<IMG BORDER="0" WIDTH="91" HEIGHT="45" src="FILES/ppy2_0622.gif" ALT="figs/ppy2_0622.gif"></CENTER>

<P class="docText">This example pops up a single button window. When pressed, the button
triggers the <TT>self.message</TT> bound method to print to
<TT>stdout</TT> again. Here is the output after pressing
this button four times; notice how <TT>self.data</TT> (a
simple counter here) retains its state between presses:
</P>

<PRE>C:\...\PP2E\Gui\Intro&gt;python gui6.py
Hello frame world 43!
Hello frame world 44!
Hello frame world 45!
Hello frame world 46!</PRE>

<P class="docText">This may seem like a roundabout way to show a
<TT>Button</TT> (we did it in fewer lines in Examples <A class="docLink" HREF="#python2-CHP-6-EX-10">Example 6-10</A>, <A class="docLink" HREF="#python2-CHP-6-EX-11">Example 6-11</A>, and <A class="docLink" HREF="#python2-CHP-6-EX-12">Example 6-12</A>). But the <TT>Hello</TT> class
provides an enclosing organizational structure for building GUIs. In
the examples prior to the last section, we made GUIs using a
function-like approach: we called widget constructors as though they
were functions and hooked widgets together manually by passing in
parents to widget construction calls. There was no notion of an
enclosing context, apart from the global scope of the module file
containing the widget calls. This works for simple GUIs, but can make
for brittle code when building up larger GUI structures.
</P>

<P class="docText">But by subclassing <TT>Frame</TT> as we've done here,
the class becomes an enclosing context for the GUI:
</P>

<UL>
<LI><P class="docList">Widgets are added by attaching objects to <TT>self</TT>, an
instance of a <TT>Frame</TT> container subclass (e.g.,
<TT>Button</TT>).
</P></LI>
<LI><P class="docList">Callback handlers are registered as bound methods of
<TT>self</TT>, and so are routed back to code in the class
(e.g., <TT>self.message</TT>).
</P></LI>
<LI><P class="docList">State information is retained between events by assigning to
attributes of <TT>self</TT>, visible to all callback
methods in the class (e.g., <TT>self.data</TT>).
</P></LI>
<LI><P class="docList">It's easy to make multiple copies of such a GUI component,
because each class instance is a distinct namespace.
</P></LI>
</UL>
<P class="docText">In a sense, entire GUIs become specialized <TT>Frame</TT>
objects, with extensions for an application. Classes can also provide
protocols for building widgets (e.g., the
<TT>make_widgets</TT> method here), handle standard
configuration chores (like setting window manager options), and so
on. In short, <TT>Frame</TT> subclasses provide a simple
way to organize collections of other widget-class objects.
</P>

<A NAME="python2-CHP-6-SECT-4.8.1"></A>
<H5 class="docSection3Title">6.4.8.1 Attaching class components</H5>

<P class="docText">Perhaps more important, subclasses of <TT>Frame</TT> are
true widgets: they can be further extended and customized by
subclassing, and can be attached to enclosing widgets. For instance,
to attach the entire package of widgets that a class builds to
something else, simply create an instance of the class with a real
parent widget passed in. To illustrate, running the script in <A class="docLink" HREF="#python2-CHP-6-EX-21">Example 6-21</A> creates the window shown in <A class="docLink" HREF="#python2-CHP-6-FIG-23">Figure 6-23</A>.
</P>


<H5 class="docExampleTitle"><A NAME="python2-CHP-6-EX-21"></A>Example 6-21. PP2E\Gui\Intro\gui6b.py </H5>
<PRE>from sys import exit
from Tkinter import *                    # get Tk widget classes
from gui6 import Hello                   # get the subframe class
 
parent = Frame(None)                     # make a container widget
parent.pack()
Hello(parent).pack(side=RIGHT)           # attach Hello instead of running it

Button(parent, text='Attach', command=exit).pack(side=LEFT)
parent.mainloop()</PRE>


<CENTER>
<H5 class="docFigureTitle"><A NAME="python2-CHP-6-FIG-23"></A>Figure 6-23. An attached class component on the right</H5>
<IMG BORDER="0" WIDTH="124" HEIGHT="45" src="FILES/ppy2_0623.gif" ALT="figs/ppy2_0623.gif"></CENTER>

<P class="docText">This script just adds <TT>Hello</TT>'s button to the
right side of <TT>parent</TT> -- a container
<TT>Frame</TT>. In fact, the button on the right in this
window represents an embedded component: its button really represents
an attached Python class object. Pressing the embedded class's
button on the right prints a message as before; pressing the new
button exits the GUI by a <TT>sys.exit</TT> call:
</P>

<PRE>C:\...\PP2E\Gui\Intro&gt;python gui6b.py
Hello frame world 43!
Hello frame world 44!
Hello frame world 45!
Hello frame world 46!</PRE>

<P class="docText">In more complex GUIs, we might instead attach large
<TT>Frame</TT> subclasses to other container components and
develop each independently. For instance, <A class="docLink" HREF="#python2-CHP-6-EX-22">Example 6-22</A> is yet another specialized
<TT>Frame</TT> itself, but attaches an instance of the
original <TT>Hello</TT> class in a more OO fashion. When
run as a top-level program, it creates a window identical to the one
shown in <A class="docLink" HREF="#python2-CHP-6-FIG-23">Figure 6-23</A>.
</P>


<H5 class="docExampleTitle"><A NAME="python2-CHP-6-EX-22"></A>Example 6-22. PP2E\Gui\Intro\gui6c.py </H5>
<PRE>from Tkinter import *                    # get Tk widget classes
from gui6 import Hello                   # get the subframe class

class HelloContainer(Frame):
    def __init__(self, parent=None):
        Frame.__init__(self, parent)
        self.pack()
        self.makeWidgets()
    def makeWidgets(self):
        Hello(self).pack(side=RIGHT)     # attach a Hello to me
        Button(self, text='Attach', command=self.quit).pack(side=LEFT)

if __name__ == '__main__': HelloContainer().mainloop()</PRE>


<P class="docText">This looks and works exactly like <TT>gui6b</TT>, but
registers the added button's callback handler as
<TT>self.quit</TT>, which is just the standard
<TT>quit</TT> widget method this class inherits from
<TT>Frame</TT>. The window this time represents two Python
classes at work -- the embedded component's widgets on the
right (the original Hello button), and the container's widgets
on the left.
</P>

<P class="docText">Naturally, this is a simple example (we only attached a single button
here, after all). But in more practical user interfaces, the set of
widget class objects attached in this way can be much larger. Imagine
replacing the <TT>Hello</TT> call in this script with a
call to attach an already-coded and fully debugged calculator object,
and you'll begin to better understand the power of this
paradigm. If we code all of our GUI components as classes, they
automatically become a library of reusable widgets, which we can
combine in other applications as often as we like.
</P>



<A NAME="python2-CHP-6-SECT-4.8.2"></A>
<H5 class="docSection3Title">6.4.8.2 Extending class components</H5>

<P class="docText">When GUIs are built with classes, there are a variety of ways to
reuse their code in other displays. To extend
<TT>Hello</TT> instead of attaching it, we just override
some of its methods in a new subclass (which itself becomes a
specialized <TT>Frame</TT> widget). This technique is shown
in <A class="docLink" HREF="#python2-CHP-6-EX-23">Example 6-23</A>.
</P>


<H5 class="docExampleTitle"><A NAME="python2-CHP-6-EX-23"></A>Example 6-23. PP2E\Gui\Intro\gui6d.py </H5>
<PRE>from Tkinter import *
from gui6 import Hello

class HelloExtender(Hello):
    def make_widgets(self):                       # extend method here
        Hello.make_widgets(self) 
        Button(self, text='Extend', command=self.quit).pack(side=RIGHT)
    def message(self):
        print 'hello', self.data                  # redefine method here

if __name__ == '__main__': HelloExtender().mainloop()</PRE>


<P class="docText">This subclass's <TT>make_widgets</TT> method here
first builds the superclass's widgets, then adds a second
Extend button on the right, as shown in <A class="docLink" HREF="#python2-CHP-6-FIG-24">Figure 6-24</A>.
</P>

<CENTER>
<H5 class="docFigureTitle"><A NAME="python2-CHP-6-FIG-24"></A>Figure 6-24. A customized class's widgets, on the left</H5>
<IMG BORDER="0" WIDTH="125" HEIGHT="45" src="FILES/ppy2_0624.gif" ALT="figs/ppy2_0624.gif"></CENTER>

<P class="docText">Because it redefines the <TT>message</TT> method, pressing
the original superclass's button on the left now prints a
different string to <TT>stdout</TT> (when searching up from
<TT>self</TT>, the <TT>message</TT> attribute is
found first in this subclass, not the superclass):
</P>

<PRE>C:\...\PP2E\Gui\Intro&gt;<B>python gui6d.py</B>
hello 42
hello 42
hello 42
hello 42</PRE>

<P class="docText">But pressing the new Extend button on the right, added by this
subclass, exits immediately, since the <TT>quit</TT> method
(inherited from <TT>Hello</TT>, which inherits it from
<TT>Frame</TT>) is the added button's callback
handler. The net effect is that this class customizes the original,
to add a new button and change <TT>message</TT>'s
behavior.
</P>

<P class="docText">Although this example is simple, it demonstrates a technique that can
be powerful in practice -- to change a GUI's behavior, we
can write a new class that customizes its parts, rather than changing
the existing GUI code in place. The main code need be debugged only
once, and customized with subclasses as unique needs arise.
</P>

<P class="docText">The moral of this story is that Tkinter GUIs can be coded without
ever writing a single new class, but using classes to structure your
GUI code makes it much more reusable in the long run. If done well,
you can both attach already-debugged components to new interfaces,
and specialize their behavior in new external subclasses as needed
for custom requirements. Either way, the initial up-front investment
to use classes is bound to save coding time in the end.
</P>



<A NAME="python2-CHP-6-SECT-4.8.3"></A>
<H5 class="docSection3Title">6.4.8.3 Standalone container classes</H5>

<P class="docText">Before we move on, I want to point out that it's possible to
reap most of the benefits previously mentioned by creating standalone
classes not derived from Tkinter <TT>Frames</TT> or other
widgets. For instance, the class in <A class="docLink" HREF="#python2-CHP-6-EX-24">Example 6-24</A>
generates the window shown in <A class="docLink" HREF="#python2-CHP-6-FIG-25">Figure 6-25</A>.
</P>


<H5 class="docExampleTitle"><A NAME="python2-CHP-6-EX-24"></A>Example 6-24. PP2E\Gui\Intro\gui7.py </H5>
<PRE>from Tkinter import *

class HelloPackage:                            # not a widget subbclass
    def __init__(self, parent=None):
        self.top = Frame(parent)               # embed a Frame
        self.top.pack()
        self.data = 0
        self.make_widgets()                    # attach widgets to self.top
    def make_widgets(self):
        Button(self.top, text='Bye', command=self.top.quit).pack(side=LEFT)
        Button(self.top, text='Hye', command=self.message).pack(side=RIGHT)
    def message(self)):
        self.data = self.data + 1
        print 'Hello number', self.data

if __name__ == '__main__': HelloPackage().top.mainloop()</PRE>


<CENTER>
<H5 class="docFigureTitle"><A NAME="python2-CHP-6-FIG-25"></A>Figure 6-25. A standalone class package in action</H5>
<IMG BORDER="0" WIDTH="91" HEIGHT="45" src="FILES/ppy2_0625.gif" ALT="figs/ppy2_0625.gif"></CENTER>

<P class="docText">When run, the Hye button here prints to <TT>stdout</TT>,
and Bye closes and exits the GUI, much as before:
</P>

<PRE>C:\...\PP2E\Gui\Intro&gt;python gui7.py
Hello number 1
Hello number 2
Hello number 3
Hello number 4</PRE>

<P class="docText">Also as before, <TT>self.data</TT> retains state between
events, and callbacks are routed to the
<TT>self.message</TT> method within this class. Unlike
before, the <TT>HelloPackage</TT> class is not itself a
kind of <TT>Frame</TT> widget. In fact, it's not a
kind of anything -- it only serves as a generator of namespaces
for storing away real widget objects and state. Because of that,
widgets are attached to a <TT>self.top</TT> (an embedded
<TT>Frame</TT>), not <TT>self</TT>. Moreover, all
references to the object as widget must descend to the embedded
frame -- as in the <TT>top.mainloop</TT> call to start
the GUI.
</P>

<P class="docText">This makes for a bit more coding within the class, but avoids
potential name clashes with both attributes added to
<TT>self</TT> by the Tkinter framework, and existing
Tkinter widget methods. For instance, if you define a
<TT>config</TT> method in your class, it will hide the
config call exported by Tkinter. With the standalone class package in
this example, you only get the methods and instance attributes that
your class defines.
</P>

<P class="docText">In practice, Tkinter doesn't use very many names, so this is
not generally a big concern.<sup class="docFootnote"><A class="docLink" HREF="#">[12]</A></sup> It can happen, of course; but frankly,
I've never seen a real Tkinter name clash in widget subclasses
in some eight years of Python coding. Moreover, using standalone
classes is not without other downsides. Although they can generally
be attached and subclassed as before, they are not quite
plug-and-play compatible with real widget objects. For instance, the
configuration calls made in <A class="docLink" HREF="#python2-CHP-6-EX-21">Example 6-21</A>for the <TT>Frame</TT> subclass fail in <A class="docLink" HREF="#python2-CHP-6-EX-25">Example 6-25</A>.
</P>
<blockquote><p class="docFootnote"><sup><A NAME="">[12]</A></sup> If you study the
<span class="docEmphasis">Tkinter.py</span> module's source code,
you'll notice that many of the attribute names it creates start
with a single underscore to make them unique; others do not because
they are potentially useful outside of the Tkinter implementation
(e.g., <TT>self.master</TT>,
<TT>self.children</TT>). Oddly, most of Tkinter still does
not use the new Python "pseudo-private attributes" trick
of prefixing attribute names with two leading underscores to
automatically add the enclosing class's name, and thus localize
them to the creating class. If Tkinter is ever rewritten to employ
this feature, name clashes will be much less common in widget
subclasses.</p></blockquote>


<H5 class="docExampleTitle"><A NAME="python2-CHP-6-EX-25"></A>Example 6-25. PP2E\Gui\Intro\gui7b.py </H5>
<PRE>from Tkinter import *
from gui7 import HelloPackage      # or get from gui7c--__getattr__ added

frm = Frame()
frm.pack()
Label(frm, text='hello').pack()

part = HelloPackage(frm)
part.pack(side=RIGHT)              # fails!--need part.top.pack(side=RIGHT) 
frm.mainloop()</PRE>


<P class="docText">This won't quite work, because <TT>part</TT>
isn't really a widget. To treat it as such, you must descend to
<TT>part.top</TT> before making GUI configurations, and
hope that the name <TT>top</TT> never changes. The class
could make this better by defining a method that always routes
unknown attribute fetches to the embedded <TT>Frame</TT>,
as in <A class="docLink" HREF="#python2-CHP-6-EX-26">Example 6-26</A>.
</P>


<H5 class="docExampleTitle"><A NAME="python2-CHP-6-EX-26"></A>Example 6-26. PP2E\Gui\Intro\gui7c.py </H5>
<PRE>import gui7
from Tkinter import *

class HelloPackage(gui7.HelloPackage): 
    def __getattr__(self, name):
        return getattr(self.top, name)      # pass off to a real widget

if __name__ == '__main__': HelloPackage().top.mainloop()</PRE>


<P class="docText">But that then requires even more extra coding in standalone package
classes. As usual, though, the significance of all these trade-offs
varies per application.
</P>




<a href="0596000855_"><img src="FILES/pixel.gif" width="1" height="1" border="0"></a><ul></ul>
</td>
</tr>
</table>
<td></td>
<table width="100%" border="0" cellspacing="0" cellpadding="0" bgcolor="#CCCCCC">
<td><font color="black" size=1>I l<font color="#FF0000">@</font>ve RuBoard</td>
<td valign="top" class="v2" align="right">
          <a href="0596000855_python2-CHP-6-SECT-3.html"><img src="FILES/previous.gif" width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a>
          <a href="0596000855_python2-CHP-6-SECT-5.html"><img src="FILES/next.gif" width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a>
</td></table>
</body></html>
