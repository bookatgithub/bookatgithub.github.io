<html><head>
<META http-equiv="Content-Type" content="text/html">
<!--SafClassName="docSection1Title"--><!--SafTocEntry="7.4 Dialogs"-->
<link rel="STYLESHEET" type="text/css" href="FILES/style.css">
<link rel="STYLESHEET" type="text/css" href="FILES/docsafari.css">
</head>
<body>
<table width="100%" border="0" cellspacing="0" cellpadding="0" bgcolor="#CCCCCC">
<td><font color="black" size=1>I l<font color="#FF0000">@</font>ve RuBoard</td>
<td valign="top" class="v2" align="right">
	<a href="0596000855_python2-CHP-7-SECT-3.html"><img src="FILES/previous.gif" width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a>
	<a href="0596000855_python2-CHP-7-SECT-5.html"><img src="FILES/next.gif" width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a>
</td></table>
<br>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<tr>
<td valign="top"><A NAME="python2-CHP-7-SECT-4"></A>
<H3 class="docSection1Title">7.4 Dialogs</H3>

<P class="docText"><A NAME="python2-IDXTERM-159"></A>
<A NAME="python2-IDXTERM-160"></A>
<A NAME="python2-IDXTERM-161"></A>
<A NAME="python2-IDXTERM-162"></A><A NAME="python2-IDXTERM-163"></A>
<A NAME="python2-IDXTERM-164"></A>Dialogs
are windows popped up by a script to provide or request additional
information. They come in two flavors, modal and nonmodal:
</P>

<UL>
<LI><P class="docList"><span class="docEmphasis">Modal</span> dialogs block the rest of the interface until the dialog window
is dismissed; users must reply to the dialog before the program
continues.
</P></LI>
<LI><P class="docList"><span class="docEmphasis">Nonmodal</span> dialogs can remain on screen indefinitely without
interfering with other windows in the interface; they can usually
accept inputs at any time.
</P></LI>
</UL>
<P class="docText">Regardless of their modality, dialogs are generally implemented with
the <TT>Toplevel</TT> window object we met in the prior
section, whether you make the <TT>Toplevel</TT> or not.
There are essentially three ways to present pop-up dialogs to users
with Tkinter: by using common dialog calls, by using the now-dated
<TT>Dialog</TT> object, and by creating custom dialog
windows with <TT>Toplevel</TT>s and other kinds of widgets.
Let's explore the basics of all three schemes.
</P>

<A NAME="python2-CHP-7-SECT-4.1"></A>
<H4 class="docSection2Title">7.4.1 Standard (Common) Dialogs</H4>

<P class="docText">Because standard dialog calls are simpler, let's start here
first. Tkinter comes with a collection of precoded dialog windows
that implement many of the most common pop-ups programs
generate -- file selection dialogs, error and warning pop-ups, and
question and answer prompts. They are called standard dialogs (and
sometimes "common" dialogs), because they are part of the
Tkinter library, and use platform-specific library calls to look like
they should on each platform. A Tkinter file open dialog, for
instance, looks like any other on Windows.
</P>

<P class="docText">All standard dialog calls are modal (they don't return until
the dialog box is dismissed by the user), and block the
program's main window while displayed. Scripts can customize
these dialogs' windows by passing message text, titles, and the
like. Since they are so simple to use, let's jump right into
<A class="docLink" HREF="#python2-CHP-7-EX-6">Example 7-6</A>.
</P>


<H5 class="docExampleTitle"><A NAME="python2-CHP-7-EX-6"></A>Example 7-6. PP2E\Gui\Tour\dlg1.pyw </H5>
<PRE>from Tkinter import *
from tkMessageBox import *

def callback():
    if askyesno('Verify', 'Do you really want to quit?'):
        showwarning('Yes', 'Quit not yet implemented')
    else:
        showinfo('No', 'Quit has been cancelled')

errmsg = 'Sorry, no Spam allowed!'
Button(text='Quit', command=callback).pack(fill=X)
Button(text='Spam', command=(lambda: showerror('Spam', errmsg))).pack(fill=X)
mainloop()</PRE>


<P class="docText">A lambda anonymous function is used here to wrap the call to
<TT>showerror</TT>, so that it is passed two hardcoded
arguments (remember, button press callbacks get no arguments from
Tkinter itself). When run, this script creates the main window in
<A class="docLink" HREF="#python2-CHP-7-FIG-5">Figure 7-5</A>.
</P>

<CENTER>
<H5 class="docFigureTitle"><A NAME="python2-CHP-7-FIG-5"></A>Figure 7-5. dlg1 main window: buttons to trigger pop-ups</H5>
<IMG BORDER="0" WIDTH="91" HEIGHT="67" src="FILES/ppy2_0705.gif" ALT="figs/ppy2_0705.gif"></CENTER>

<P class="docText">Pressing this window's Quit button pops up the dialog in <A class="docLink" HREF="#python2-CHP-7-FIG-6">Figure 7-6</A>, by calling the standard
<TT>askyesno</TT> function in the
<TT>tkmessagebox</TT> module. This looks different on Unix
and Macintosh, but looks like you'd expect when run on Windows.
This dialog blocks the program until the user clicks one of its
buttons; if the dialog's Yes button is clicked (or the Enter
key is pressed), the dialog call returns with a true value and the
script pops up the standard dialog in <A class="docLink" HREF="#python2-CHP-7-FIG-7">Figure 7-7</A> by
calling <TT>showwarning</TT>.
</P>

<CENTER>
<H5 class="docFigureTitle"><A NAME="python2-CHP-7-FIG-6"></A>Figure 7-6. dlg1 askyesno dialog (Windows)</H5>
<IMG BORDER="0" WIDTH="161" HEIGHT="96" src="FILES/ppy2_0706.gif" ALT="figs/ppy2_0706.gif"></CENTER>

<CENTER>
<H5 class="docFigureTitle"><A NAME="python2-CHP-7-FIG-7"></A>Figure 7-7. dlg1 showwarning dialog</H5>
<IMG BORDER="0" WIDTH="155" HEIGHT="96" src="FILES/ppy2_0707.gif" ALT="figs/ppy2_0707.gif"></CENTER>

<P class="docText">There is nothing the user can do with <A class="docLink" HREF="#python2-CHP-7-FIG-7">Figure 7-7</A>'s dialog but press OK. If No is clicked
in <A class="docLink" HREF="#python2-CHP-7-FIG-6">Figure 7-6</A>'s quit verification dialog, a
<TT>showinfo</TT> call makes the pop-up in <A class="docLink" HREF="#python2-CHP-7-FIG-8">Figure 7-8</A> instead. Finally, if the Spam button is
clicked in the main window, the standard dialog captured in <A class="docLink" HREF="#python2-CHP-7-FIG-9">Figure 7-9</A> is generated with the standard
<TT>showerror</TT> call.
</P>

<CENTER>
<H5 class="docFigureTitle"><A NAME="python2-CHP-7-FIG-8"></A>Figure 7-8. dlg1 showinfo dialog</H5>
<IMG BORDER="0" WIDTH="155" HEIGHT="96" src="FILES/ppy2_0708.gif" ALT="figs/ppy2_0708.gif"></CENTER>

<CENTER>
<H5 class="docFigureTitle"><A NAME="python2-CHP-7-FIG-9"></A>Figure 7-9. dlg1 showerror dialog</H5>
<IMG BORDER="0" WIDTH="153" HEIGHT="96" src="FILES/ppy2_0709.gif" ALT="figs/ppy2_0709.gif"></CENTER>

<P class="docText">This all makes for a lot of window pop-ups, of course, and you need
to be careful not to rely on these dialogs too much (it's
generally better to use input fields in long-lived windows, than to
distract the user with pop-ups). But where appropriate, such pop-ups
save coding time and provide a nice native look-and-feel.
</P>

<A NAME="python2-CHP-7-SECT-4.1.1"></A>
<H5 class="docSection3Title">7.4.1.1 A "smart" and reusable quit button</H5>

<P class="docText">Let's put some of these canned dialogs to better use. <A class="docLink" HREF="#python2-CHP-7-EX-7">Example 7-7</A> implements an attachable Quit button that uses
standard dialogs to verify the quit request. Because it's a
class, it can be attached and reused in any application that needs a
verifying Quit button. Because it uses standard dialogs, it looks as
it should on each GUI platform.
</P>


<H5 class="docExampleTitle"><A NAME="python2-CHP-7-EX-7"></A>Example 7-7. PP2E\Gui\Tour\quitter.py </H5>
<PRE>#############################################
# a quit button that verifies exit requests;
# to reuse, attach an instance to other guis
#############################################

from Tkinter import *                          # get widget classes
from tkMessageBox import askokcancel           # get canned std dialog

class Quitter(Frame):                          # subclass our GUI
    def __init__(self, parent=None):           # constructor method
        Frame.__init__(self, parent)
        self.pack()
        widget = Button(self, text='Quit', command=self.quit)
        widget.pack(side=LEFT)
    def quit(self):
        ans = askokcancel('Verify exit', "Really quit?")
        if ans: Frame.quit(self)

if __name__ == '__main__':  Quitter().mainloop()</PRE>


<P class="docText">This module is mostly meant to be used elsewhere, but puts up the
button it implements when run standalone. <A class="docLink" HREF="#python2-CHP-7-FIG-10">Figure 7-10</A> shows the Quit button itself in the upper
left, and the <TT>askokcancel</TT> verification dialog
popped up when Quit is pressed.
</P>

<CENTER>
<H5 class="docFigureTitle"><A NAME="python2-CHP-7-FIG-10"></A>Figure 7-10. Quitter, with askokcancel dialog</H5>
<IMG BORDER="0" WIDTH="209" HEIGHT="149" src="FILES/ppy2_0710.gif" ALT="figs/ppy2_0710.gif"></CENTER>

<P class="docText">If you press OK here, <TT>Quitter</TT> runs the
<TT>Frame</TT> quit method to end the GUI to which this
button is attached (really, the <TT>mainloop</TT> call).
But to really understand how such a spring-loaded button can be
useful, we need to move on to study a client GUI in the next section.
</P>



<A NAME="python2-CHP-7-SECT-4.1.2"></A>
<H5 class="docSection3Title">7.4.1.2 A dialog demo launcher bar</H5>

<P class="docText">So far, we've seen a handful of standard dialogs, but there
quite a few more. But rather than just throwing these up in dull
screen shots, let's write a Python demo script to generate them
on demand. Here's one way to do it. First of all, in <A class="docLink" HREF="#python2-CHP-7-EX-8">Example 7-8</A> we write a module to define a table that maps
a demo name to a standard dialog call (and use lambda to wrap the
call if we need to pass extra arguments to the dialog function).
</P>


<H5 class="docExampleTitle"><A NAME="python2-CHP-7-EX-8"></A>Example 7-8. PP2E\Gui\Tour\dialogTable.py </H5>
<PRE># define a name:callback demos table

from tkFileDialog   import askopenfilename        # get standard dialogs
from tkColorChooser import askcolor               # they live in Lib/lib-tk
from tkMessageBox   import askquestion, showerror
from tkSimpleDialog import askfloat

demos = {
    'Open':  askopenfilename, 
    'Color': askcolor,
    'Query': lambda: askquestion('Warning', 'You typed "rm *"\nConfirm?'),
    'Error': lambda: showerror('Error!', "He's dead, Jim"),
    'Input': lambda: askfloat('Entry', 'Enter credit card number')
}</PRE>


<P class="docText">I put this table in a module so that it might be reused as the basis
of other demo scripts later (dialogs are more fun than printing to
<TT>stdout</TT>). Next, we'll write a Python script,
<A class="docLink" HREF="#python2-CHP-7-EX-9">Example 7-9</A>, that simply generates buttons for all
of this table's entries -- use its keys as button labels,
and its values as button callback handlers.
</P>


<H5 class="docExampleTitle"><A NAME="python2-CHP-7-EX-9"></A>Example 7-9. PP2E\Gui\Tour\demoDlg.py </H5>
<PRE>from Tkinter import *              # get base widget set
from dialogTable import demos      # button callback handlers
from quitter import Quitter        # attach a quit object to me

class Demo(Frame):
    def __init__(self, parent=None):
        Frame.__init__(self, parent)
        self.pack()
        Label(self, text="Basic demos").pack()
        for (key, value) in demos.items():
            Button(self, text=key, command=value).pack(side=TOP, fill=BOTH)
        Quitter(self).pack(side=TOP, fill=BOTH) 

if __name__ == '__main__': Demo().mainloop()</PRE>


<P class="docText">This script creates the window shown in <A class="docLink" HREF="#python2-CHP-7-FIG-11">Figure 7-11</A>
when run as a standalone program; it's a bar of demo buttons,
that simply route control back to the values of the table in module
<TT>dialogTable</TT> when pressed.
</P>

<CENTER>
<H5 class="docFigureTitle"><A NAME="python2-CHP-7-FIG-11"></A>Figure 7-11. demoDlg main window</H5>
<IMG BORDER="0" WIDTH="91" HEIGHT="173" src="FILES/ppy2_0711.gif" ALT="figs/ppy2_0711.gif"></CENTER>

<P class="docText">Notice that because this script is driven by the contents of the
<TT>dialogTable</TT> module's dictionary, we can
change the set of demo buttons displayed by changing just
<TT>dialogTable</TT> (we don't need to change any
executable code in <TT>demoDlg</TT>). Also note that the
Quit button here is an attached instance of the
<TT>Quitter</TT> class of the prior
section -- it's at least one bit of code that you never have
to write again.
</P>

<P class="docText">We've already seen some of the dialogs triggered by this demo
bar window's other buttons, so I'll just step through the
new ones here. Pressing the main window's Query button, for
example, generates the standard pop-up in <A class="docLink" HREF="#python2-CHP-7-FIG-12">Figure 7-12</A>.
</P>

<CENTER>
<H5 class="docFigureTitle"><A NAME="python2-CHP-7-FIG-12"></A>Figure 7-12. demoDlg query, askquestion dialog</H5>
<IMG BORDER="0" WIDTH="149" HEIGHT="96" src="FILES/ppy2_0712.gif" ALT="figs/ppy2_0712.gif"></CENTER>

<P class="docText">This <TT>askquestion</TT> dialog looks like the
<TT>askyesno</TT> we saw earlier, but actually returns
either string "yes" or "no"
(<TT>askyesno</TT> and <TT>askokcancel</TT>
return 1 or 0, true or false). Pressing the demo bar's Input
button generates the standard askfloat dialog box shown in <A class="docLink" HREF="#python2-CHP-7-FIG-13">Figure 7-13</A>.
</P>

<CENTER>
<H5 class="docFigureTitle"><A NAME="python2-CHP-7-FIG-13"></A>Figure 7-13. demoDlg input, askfloat dialog</H5>
<IMG BORDER="0" WIDTH="143" HEIGHT="89" src="FILES/ppy2_0713.gif" ALT="figs/ppy2_0713.gif"></CENTER>

<P class="docText">This dialog automatically checks the input for valid floating-point
syntax before it returns, and is representative of a collection of
single-value input dialogs (<TT>askinteger</TT> and
<TT>askstring</TT> prompt for integer and string inputs
too). It returns the input as a floating-point number object (not a
string) on the OK button and enter key presses, or the Python
<TT>None</TT> object if the user clicks Cancel. Its two
relatives return the input as integer and string objects instead.
</P>

<P class="docText">When the demo bar's Open button is pressed, we get the standard
file open dialog made by calling <TT>askopenfilename</TT>,
and captured in <A class="docLink" HREF="#python2-CHP-7-FIG-14">Figure 7-14</A>. This is Windows
look-and-feel; it looks radically different on Linux, but
appropriately so.
</P>

<CENTER>
<H5 class="docFigureTitle"><A NAME="python2-CHP-7-FIG-14"></A>Figure 7-14. demoDlg open, askopenfilename dialog</H5>
<IMG BORDER="0" WIDTH="346" HEIGHT="214" src="FILES/ppy2_0714.gif" ALT="figs/ppy2_0714.gif"></CENTER>

<P class="docText">A similar dialog for selecting a save-as filename is produced by
calling <TT>asksaveasfilename</TT> (see the
<TT>Text</TT> widget section under <A class="docLink" HREF="0596000855_python2-CHP-8-SECT-4.html#python2-CHP-8-SECT-4">Section 8.4</A> in <A class="docLink" HREF="0596000855_python2-CHP-8.html#python2-CHP-8">Chapter 8</A> for an
example). Both file dialogs let the user navigate through the
filesystem to select a subject filename, returned with its full
directory pathname when Open is pressed; an empty string comes back
if Cancel is pressed instead. Both also have additional protocols not
demonstrated by this example:
</P>

<UL>
<LI><P class="docList">They can be passed a <TT>filetypes</TT> keyword
argument -- a set of name patterns used to select files, that
appear in the "Files of type" pulldown at the bottom of
the dialog.
</P></LI>
<LI><P class="docList">They can be passed an <TT>initialdir</TT> (start
directory), <TT>initialfile</TT> (for "File
name"), <TT>title</TT> (for the dialog window),
<TT>defaultextension</TT> (appended if the selection has
none), and <TT>parent</TT> (to appear as an embedded child,
instead of a pop-up dialog).
</P></LI>
<LI><P class="docList">They can be made to remember the last directory selected, by using
exported objects instead of these function calls.
</P></LI>
</UL>
<P class="docText">We'll use most of these interfaces later in the book,
especially for the file dialogs in the PyEdit example in <A class="docLink" HREF="0596000855_python2-CHP-9.html#python2-CHP-9">Chapter 9</A> (but feel free to flip ahead for more details
now). Finally, the demo bar's Color button triggers a standard
<TT>askcolor</TT> call, which generates the standard color
selection dialog shown in <A class="docLink" HREF="#python2-CHP-7-FIG-15">Figure 7-15</A>.
</P>

<CENTER>
<H5 class="docFigureTitle"><A NAME="python2-CHP-7-FIG-15"></A>Figure 7-15. demoDlg color, askcolor dialog</H5>
<IMG BORDER="0" WIDTH="366" HEIGHT="261" src="FILES/ppy2_0715.gif" ALT="figs/ppy2_0715.gif"></CENTER>

<P class="docText">If you press its OK button it returns a data structure the identifies
the selected color, which can be used in all color contexts in
Tkinter. It includes RGB values and a hexadecimal color string (e.g.,
<TT>((160,</TT> <TT>160,</TT>
<TT>160),</TT> <TT>'#a0a0a0')</TT>). More on how
this tuple can be useful in a moment. If you press Cancel, the script
gets back a tuple containing two nones (<TT>None</TT>s of
the Python variety, that is).
</P>



<A NAME="python2-CHP-7-SECT-4.1.3"></A>
<H5 class="docSection3Title">7.4.1.3 Printing dialog results (and passing callback data with lambdas)</H5>

<P class="docText">The dialog demo launcher bar displays standard dialogs, and can be
made to display others by simply changing the
<TT>dialogTable</TT> module it imports. As coded, though,
it really only shows dialogs; it would also be nice to see their
return values so we know how to use them in scripts. <A class="docLink" HREF="#python2-CHP-7-EX-10">Example 7-10</A> adds printing of standard dialog results to
the <TT>stdout</TT> standard output stream.
</P>


<H5 class="docExampleTitle"><A NAME="python2-CHP-7-EX-10"></A>Example 7-10. PP2E\Gui\Tour\demoDlg-print.py </H5>
<PRE>####################################################
# same, but show returns values of dialog calls;
# the lambda saves data from the local scope to be 
# passed to the handler (button handlers normally 
# get no args) and works like this def statement:
# def func(self=self, name=key): self.printit(name)
####################################################

from Tkinter import *              # get base widget set
from dialogTable import demos      # button callback handlers
from quitter import Quitter        # attach a quit object to me

class Demo(Frame):
    def __init__(self, parent=None):
        Frame.__init__(self, parent)
        self.pack()
        Label(self, text="Basic demos").pack()
        for (key, value) in demos.items():
            func = (lambda self=self, name=key: self.printit(name))      
            Button(self, text=key, command=func).pack(side=TOP, fill=BOTH)
        Quitter(self).pack(side=TOP, fill=BOTH)
    def printit(self, name): 
        print name, 'returns =&gt;', demos[name]()      # fetch, call, print

if __name__ == '__main__': Demo().mainloop()</PRE>


<P class="docText">This script builds the same main button-bar window, but notice that
the callback handler is an anonymous function made with a lambda now,
not a direct reference to dialog calls in the imported
<TT>dialogTable</TT> dictionary:
</P>

<PRE> func = (lambda self=self, name=key: self.printit(name))</PRE>

<P class="docText">This is the first time we've actually used lambda like this, so
let's get the facts straight. Because button press callbacks
are run with no arguments, if we need to pass extra data to the
handler it must be wrapped in an object that remembers that extra
data and passes it along. Here, a button press runs the function
generated by the lambda -- an indirect call layer that retains
information from the enclosing scope by assigning it to default
arguments. The net effect is that the real handler,
<TT>printit</TT>, receives an extra <TT>name</TT>
argument giving the demo associated with the button pressed, even
though this argument wasn't passed back from Tkinter itself.
</P>

<P class="docText">Notice, though, that this lambda assigns both <TT>self</TT>
and <TT>key</TT> to defaults, to retain them for use on
callbacks. Like all functions, lambda results only have access to
their local scope, the enclosing global module scope, and the
built-in names scope -- not the local scope of the method function
that created them, and that is where name <TT>self</TT>
really lives. Because bound methods remember both a
<TT>self</TT> object and a method function, this lambda
could also be written like this:
</P>

<PRE>func = (lambda handler=self.printit, name=key: handler(name))  </PRE>

<P class="docText">You can also use a callable class object here that retains state as
instance attributes (see the tutorial's
<TT>__call__</TT> example in <A class="docLink" HREF="0596000855_python2-CHP-6.html#python2-CHP-6">Chapter 6</A>
for hints). But as a rule of thumb, if you want a lambda's
result to use any names from the enclosing scope when later called,
simply pass them in as defaults.
</P>

<P class="docText">When run, this script prints dialog return values; here is the output
after clicking all the demos buttons in the main window, and picking
both Cancel/No and OK/Yes buttons in each dialog:
</P>

<PRE>C:\...\PP2E\Gui\Tour&gt;<B>python demoDlg-print.py</B>
Error returns =&gt; ok
Input returns =&gt; None
Input returns =&gt; 3.14159
Open returns =&gt;
Open returns =&gt; C:/PP2ndEd/examples/PP2E/Gui/Tour/demoDlg-print.py
Query returns =&gt; no
Query returns =&gt; yes
Color returns =&gt; (None, None)
Color returns =&gt; ((160, 160, 160), '#a0a0a0')</PRE>

<P class="docText">Now that I've shown you these dialog results, I want to next
show you how one of them can actually be useful.
</P>



<A NAME="python2-CHP-7-SECT-4.1.4"></A>
<H5 class="docSection3Title">7.4.1.4 Letting users select colors on the fly</H5>

<P class="docText">The standard color selection dialog isn't just another pretty
face -- scripts can pass the hexadecimal color string it returns
to the <TT>bg</TT> and <TT>fg</TT> widget color
configuration options we met earlier. That is, <TT>bg</TT>
and <TT>fg</TT> accept both a color name (e.g.,
"blue") and an <TT>askcolor</TT> result strings
that starts with a <TT>#</TT> (e.g., the
<TT>#a0a0a0</TT> in the last output line of the prior
section).
</P>

<P class="docText">This adds another dimension of customization to Tkinter GUIs: Rather
than hard-coding colors in your GUI products, you can provide a
button that pops up color selectors that let users choose color
preferences on the fly. Simply pass the color string to widget
<TT>config</TT> methods in callback handlers, as in <A class="docLink" HREF="#python2-CHP-7-EX-11">Example 7-11</A>.
</P>


<H5 class="docExampleTitle"><A NAME="python2-CHP-7-EX-11"></A>Example 7-11. PP2E\Gui\Tour\setcolor.py </H5>
<PRE>from Tkinter import *
from tkColorChooser import askcolor

def setBgColor():
    (triple, hexstr) = askcolor()
    if hexstr:
        print hexstr
        push.config(bg=hexstr)

root = Tk()
push = Button(root, text='Set Background Color', command=setBgColor)
push.config(height=3, font=('times', 20, 'bold'))
push.pack(expand=YES, fill=BOTH)
root.mainloop()</PRE>


<P class="docText">This script makes the window in <A class="docLink" HREF="#python2-CHP-7-FIG-16">Figure 7-16</A> when
launched (its button's background is a sort of green, but
you'll have to trust me on this). Pressing the button pops up
the color selection dialog shown earlier; the color you pick in that
dialog becomes the background color of this button after you press
OK.
</P>

<CENTER>
<H5 class="docFigureTitle"><A NAME="python2-CHP-7-FIG-16"></A>Figure 7-16. setcolor main window</H5>
<IMG BORDER="0" WIDTH="100" HEIGHT="48" src="FILES/ppy2_0716.gif" ALT="figs/ppy2_0716.gif"></CENTER>

<P class="docText">Color strings are also printed to the <TT>stdout</TT>
stream (the console window); run this on your computer to experiment
with available color settings:
</P>

<PRE>C:\...\PP2E\Gui\Tour&gt;python setcolor.py
#c27cc5
#5fe28c
#69d8cd</PRE>



<A NAME="python2-CHP-7-SECT-4.1.5"></A>
<H5 class="docSection3Title">7.4.1.5 Other standard dialog calls</H5>

<P class="docText">We've seen most of the standard dialogs and will use these
pop-ups in examples throughout the rest of this book. But for more
details on other calls and options available, either consult other
Tkinter documentation, or browse the source code of the modules used
at the top of the <TT>dialogTable</TT> module; all are
simple Python files installed in the <I>lib-tk</I>
subdirectory of the Python source library on your machine. And keep
this demo bar example filed away for future reference; we'll
reuse it later in the tour when we meet other button-like widgets.
</P>



<A NAME="python2-CHP-7-SECT-4.2"></A>
<H4 class="docSection2Title">7.4.2 The Old-Style Dialog Module</H4>

<P class="docText">In older Python code, you may see dialogs occasionally coded with the
standard Dialog module. This is a bit dated now, and uses an X
Windows look-and-feel; but just in case you run across such code in
your Python maintenance excursions, <A class="docLink" HREF="#python2-CHP-7-EX-12">Example 7-12</A>
gives you a feel for the interface.
</P>


<H5 class="docExampleTitle"><A NAME="python2-CHP-7-EX-12"></A>Example 7-12. PP2E\Gui\Tour\dlg-old.py </H5>
<PRE>from Tkinter import *
from Dialog import Dialog

class OldDialogDemo(Frame):
    def __init__(self, master=None):
        Frame.__init__(self, master)
        Pack.config(self)  # same as self.pack()
        Button(self, text='Pop1', command=self.dialog1).pack()
        Button(self, text='Pop2', command=self.dialog2).pack()
    def dialog1(self):
        ans = Dialog(self,
                     title   = 'Popup Fun!',
                     text    = 'An example of a popup-dialog '
                               'box, using older "Dialog.py".',
                     bitmap  = 'questhead',
                     default = 0, strings = ('Yes', 'No', 'Cancel'))
        if ans.num == 0: self.dialog2()
    def dialog2(self):
        Dialog(self, title   = 'HAL-9000',
                     text    = "I'm afraid I can't let you do that, Dave...",
                     bitmap  = 'hourglass',
                     default = 0, strings = ('spam', 'SPAM'))

if __name__ == '__main__': OldDialogDemo().mainloop()</PRE>


<P class="docText"><A NAME="IXT-7-336937"></A>You supply
<TT>Dialog</TT> a tuple of button labels and a message, and
get back the index of the button pressed (the leftmost is index
zero). <TT>Dialog</TT> windows are modal: the rest of the
application's windows are disabled until the
<TT>Dialog</TT> receives a response from the user. When you
press the Pop2 button in the main window created by this script, the
second dialog pops up, as shown in <A class="docLink" HREF="#python2-CHP-7-FIG-17">Figure 7-17</A>.
</P>

<CENTER>
<H5 class="docFigureTitle"><A NAME="python2-CHP-7-FIG-17"></A>Figure 7-17. Old-style dialog</H5>
<IMG BORDER="0" WIDTH="274" HEIGHT="109" src="FILES/ppy2_0717.gif" ALT="figs/ppy2_0717.gif"></CENTER>

<P class="docText">This is running on Windows, and as you can see, is nothing like what
you would expect on that platform for a question dialog. In fact,
this dialog generates an X Windows look-and-feel, regardless of the
underlying platform. Because of both
<TT>Dialog</TT>'s appearance and the extra complexity
required to program it, you are probably better off using the
standard dialog calls of the prior section instead.
</P>


<A NAME="python2-CHP-7-SECT-4.3"></A>
<H4 class="docSection2Title">7.4.3 Custom Dialogs</H4>

<P class="docText">The dialogs we've seen so far all have a standard appearance
and interaction. They are fine for many purposes, but often we need
something a bit more custom. For example, forms that request multiple
field inputs (e.g., name, age, shoe size) aren't directly
addressed by the common dialog library. We could pop-up one
single-input dialog in turn for each requested field, but that
isn't exactly user-friendly.
</P>

<P class="docText">Custom dialogs support arbitrary interfaces, but they are also the
most complicated to program. Even so, there's not much to
it -- simply create a pop-up window as a
<TT>Toplevel</TT> with attached widgets, and arrange a
callback handler to fetch user inputs entered in the dialog (if any)
and destroy the window. To make such a custom dialog modal, we also
need to wait for a reply, by giving the window input focus, making
other windows inactive, and waiting for an event. <A class="docLink" HREF="#python2-CHP-7-EX-13">Example 7-13</A> illustrates the basics.
</P>


<H5 class="docExampleTitle"><A NAME="python2-CHP-7-EX-13"></A>Example 7-13. PP2E\Gui\Tour\dlg-custom.py </H5>
<PRE>import sys
from Tkinter import *
makemodal = (len(sys.argv) &gt; 1)

def dialog():
    win = Toplevel()                                     # make a new window
    Label(win,  text='Hard drive reformatted!').pack()   # add a few widgets
    Button(win, text='OK', command=win.destroy).pack()   # set destroy callback
    if makemodal:
        win.focus_set()          # take over input focus,
        win.grab_set()           # disable other windows while I'm open,
        win.wait_window()        # and wait here until win destroyed
    print 'dialog exit'          # else returns right away

root = Tk()
Button(root, text='popup', command=dialog).pack()
root.mainloop()</PRE>


<P class="docText">This script is set up to create a pop-up dialog window in either
modal or nonmodal mode, depending on its <TT>makemodal</TT>
global variable. If it is run with no command-line arguments, it
picks nonmodal style, captured in <A class="docLink" HREF="#python2-CHP-7-FIG-18">Figure 7-18</A>.
</P>

<CENTER>
<H5 class="docFigureTitle"><A NAME="python2-CHP-7-FIG-18"></A>Figure 7-18. Nonmodal custom dialogs at work</H5>
<IMG BORDER="0" WIDTH="243" HEIGHT="155" src="FILES/ppy2_0718.gif" ALT="figs/ppy2_0718.gif"></CENTER>

<P class="docText">The window in the upper right is the root window here; pressing its
"popup" button creates a new pop-up dialog window.
Because dialogs are nonmodal in this mode, the root window remains
active after a dialog is popped up. In fact, nonmodal dialogs never
block other windows, so you can keep pressing the root's button
to generate as many copies of the pop-up window as will fit on your
screen. Any or all of the pop-ups can be killed by pressing their OK
buttons, without killing other windows in this display.
</P>

<A NAME="python2-CHP-7-SECT-4.3.1"></A>
<H5 class="docSection3Title">7.4.3.1 Making custom dialogs modal</H5>

<P class="docText">Now, when the script is run with a command-line argument (e.g.,
python dlg-custom.py 1), it makes its pop-ups modal instead. Because
modal dialogs grab all of the interface's attention, the main
window becomes inactive in this mode until the pop-up is killed; you
can't even click on it to reactivate it while the dialog is
open. Because of that, you can never make more than one copy of the
pop-up on screen at once, as shown in <A class="docLink" HREF="#python2-CHP-7-FIG-19">Figure 7-19</A>.
</P>

<CENTER>
<H5 class="docFigureTitle"><A NAME="python2-CHP-7-FIG-19"></A>Figure 7-19. A modal custom dialog at work</H5>
<IMG BORDER="0" WIDTH="200" HEIGHT="78" src="FILES/ppy2_0719.gif" ALT="figs/ppy2_0719.gif"></CENTER>

<P class="docText">In fact, the call to the <TT>dialog</TT> function in this
script doesn't return until the dialog window on the left is
dismissed by pressing its OK button. The net effect is that modal
dialogs impose a function call-like model on an otherwise
event-driven programming model -- user inputs can be processed
right away, not in a callback handler triggered at some arbitrary
point in the future.
</P>

<P class="docText">Forcing such a linear control flow on a GUI takes a bit of extra
work, though. The secret to locking other windows and waiting for a
reply boils down to three lines of code, which are a general pattern
repeated in most custom modal dialogs:
</P>

<DL class="docList">
<DT><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">win.focus_set()</span></span></span></DT>
<DD>
<P class="docList">Makes the window take over the application's input focus, as if
it had been clicked with the mouse to make it the active window. This
method is also known by synonym <TT>focus</TT>, and
it's also common to set the focus on an input widget within the
dialog (e.g., an <TT>Entry</TT>) rather than the entire
window.
</P>
</DD><DT><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">win.grab_set()</span></span></span></DT>
<DD>
<P class="docList">Disables all other windows in the application until this one is
destroyed. The user cannot interact with other windows in the program
while a grab is set.
</P>
</DD><DT><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">win.wait_window()</span></span></span></DT>
<DD>
<P class="docList">Pauses the caller until the <TT>win</TT> widget is
destroyed, but keeps the main event-processing loop
(<TT>mainloop</TT>) active during the pause. That means
that the GUI at large remains active during the wait; its windows
redraw themselves if covered and uncovered, for example. When the
window is destroyed with the <TT>destroy</TT> method, it is
erased from the screen, the application grab is automatically
released, and this method call finally returns.
</P>
</DD>
</DL>

<P class="docText">Because the script waits for a window destroy event, it must also
arrange for a callback handler to destroy the window in response to
interaction with widgets in the dialog window (the only window
active). This example's dialog is simply informational, so its
OK button calls the window's <TT>destroy</TT> method.
In user-input dialogs, we might instead install an Enter key-press
callback handler that fetches data typed into an
<TT>Entry</TT> widget, and then calls
<TT>destroy</TT> (see later in this chapter).
</P>



<A NAME="python2-CHP-7-SECT-4.3.2"></A>
<H5 class="docSection3Title">7.4.3.2 Other ways to be modal</H5>

<P class="docText"><A NAME="IXT-7-336938"></A>Modal dialogs are typically implemented
by waiting for a newly created pop-up window's
<TT>destroy</TT> event, as in this example. But other
schemes are viable too. For example, it's possible to create
dialog windows ahead of time, and show and hide them as needed with
the top-level window's <TT>deiconify</TT> and
<TT>withdraw</TT> methods (see the alarm scripts in <A class="docLink" HREF="0596000855_python2-CHP-8.html#python2-CHP-8">Chapter 8</A> under <A class="docLink" HREF="0596000855_python2-CHP-8-SECT-7.html#python2-CHP-8-SECT-7">Section 8.7</A> for
details). Given that window creation speed is generally fast enough
as to appear instantaneous today, this is much less common than
making and destroying a window from scratch on each interaction.
</P>

<P class="docText">It's also possible to implement a modal state by waiting for a
Tkinter variable to change its value, instead of waiting for a window
to be destroyed. See this chapter's discussion of Tkinter
variables (which are class objects, not normal Python variables) and
the <TT>wait_variable</TT> method discussed near the end of
<A class="docLink" HREF="0596000855_python2-CHP-8.html#python2-CHP-8">Chapter 8</A> for more details. This scheme allows a
long-lived dialog box's callback handler to signal a state
change to a waiting main program, without having to destroy the
dialog box.
</P>

<P class="docText">Finally, if you call the <TT>mainloop</TT> method
recursively, the call won't return until the widget
<TT>quit</TT> method has been invoked. The
<TT>quit</TT> method terminates a
<TT>mainloop</TT> call, and so normally ends a GUI program.
But it will simply exit a recursive <TT>mainloop</TT> level
if one is active. Because of this, modal dialogs can also be written
without wait method calls if you are careful. For instance, <A class="docLink" HREF="#python2-CHP-7-EX-14">Example 7-14</A> works the same as
<TT>dlg-custom</TT>.
</P>


<H5 class="docExampleTitle"><A NAME="python2-CHP-7-EX-14"></A>Example 7-14. PP2E\Gui\Tour\dlg-recursive.py </H5>
<PRE>from Tkinter import *

def dialog():
    win = Toplevel()                                    # make a new window
    Label(win,  text='Hard drive reformatted!').pack()  # add a few widgets
    <B>Button(win, text='OK', command=win.quit).pack() </B>    # set quit callback
    <B>win.protocol('WM_DELETE_WINDOW', win.quit) </B>         # quit on wm close too! 

    win.focus_set()          # take over input focus,
    win.grab_set()           # disable other windows while I'm open,
    <B>win.mainloop()  </B>         # and start a nested event loop to wait 
<B>    win.destroy()</B>
    print 'dialog exit' 

root = Tk()
Button(root, text='popup', command=dialog).pack()
root.mainloop()</PRE>


<P class="docText">If you go this route, be sure to call <TT>quit</TT> instead
of <TT>destroy</TT> in dialog callback handlers
(<TT>destroy</TT> doesn't terminate the
<TT>mainloop</TT> level), and be sure to use
<TT>protocol</TT> to make the window border close button
call <TT>quit</TT> too (or else it doesn't end the
recursive <TT>mainloop</TT> level call, and will generate
odd error messages when your program finally exits). Because of this
extra complexity, you're probably better off using
<TT>wait_window</TT> or <TT>wait_variable</TT>,
not recursive <TT>mainloop</TT> calls.
</P>

<P class="docText">We'll see how to build form-like dialogs with labels and input
fields later in this chapter when we meet <TT>Entry</TT>,
and again when we study the <TT>grid</TT> manager in <A class="docLink" HREF="0596000855_python2-CHP-8.html#python2-CHP-8">Chapter 8</A>. For more custom dialog examples, see ShellGui
(<A class="docLink" HREF="0596000855_python2-CHP-9.html#python2-CHP-9">Chapter 9</A>), PyMailGui (<A class="docLink" HREF="0596000855_python2-CHP-11.html#python2-CHP-11">Chapter 11</A>), PyCalc (<A class="docLink" HREF="0596000855_python2-CHP-18.html#python2-CHP-18">Chapter 18</A>), and
the nonmodal <I>form.py</I> (<A class="docLink" HREF="0596000855_python2-CHP-10.html#python2-CHP-10">Chapter 10</A>). Here, we're moving on to learn more
about events that will prove to be useful currency at later tour
destinations.<A NAME="IXTR3-26"></A> <A NAME="IXTR3-27"></A><A NAME="IXTR3-28"></A> <A NAME="IXTR3-29"></A> <A NAME="IXTR3-30"></A> <A NAME="IXTR3-31"></A>
</P>




<ul></ul>
</td>
</tr>
</table>
<td></td>
<table width="100%" border="0" cellspacing="0" cellpadding="0" bgcolor="#CCCCCC">
<td><font color="black" size=1>I l<font color="#FF0000">@</font>ve RuBoard</td>
<td valign="top" class="v2" align="right">
          <a href="0596000855_python2-CHP-7-SECT-3.html"><img src="FILES/previous.gif" width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a>
          <a href="0596000855_python2-CHP-7-SECT-5.html"><img src="FILES/next.gif" width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a>
</td></table>
</body></html>
