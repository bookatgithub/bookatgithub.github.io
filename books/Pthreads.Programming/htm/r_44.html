
<HTML>
<HEAD>
<TITLE> Pthreads ProgrammingChapter 5 - Pthreads and UNIX</TITLE>
<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=iso-8859-1">

</HEAD>
<BODY  LINK="#122EB2"  LEFTMARGIN=0 TOPMARGIN=5 >






<A NAME="toppage"></A><TABLE BORDER="0" CELLSPACING="1" CELLPADDING="1"><TR ALIGN="right"><TD  HEIGHT="44"><A HREF="../toc.html"  BORDER="0"><IMG SRC="../img/vb_toc.gif" WIDTH="114" HEIGHT="17" BORDER="0"></A><A HREF="bookmark.html+bkid=232&chnkid=44.html"  BORDER="0"><IMG SRC="../img/bookmark_create.gif" WIDTH="115" HEIGHT="17" BORDER="0"></A><A HREF="bookshelf.html+bkid=232&chnkid=44&addbk=1.html"  BORDER="0"><IMG SRC="../img/vblue_add_book.gif" WIDTH="106" HEIGHT="17" ALT="Add Book to My Bookshelf" TITLE="Add Book to My Bookshelf" BORDER="0"></A><A HREF="buybook.html+bkid=232.html" TARGET="_top" BORDER="0"><IMG SRC="../img/vb_purchase.gif" WIDTH="108" HEIGHT="17" ALT="Purchase This Book Online" TITLE="Purchase This Book Online" BORDER="0"></A></TD></TR><TR VALIGN="top"><TD><TABLE BORDER="0" CELLSPACING="0" CELLPADDING="1"><TR VALIGN="top" HEIGHT=5><TD ROWSPAN="3"  VALIGN=top ALIGN=left WIDTH="100" HEIGHT="110"><IMG SRC="../img/1565921151.gif" WIDTH="79" HEIGHT="103" ALIGN=Left BORDER="0"></TD><TD><FONT FACE="Arial, Helvetica, sans-serif" SIZE="3"><H3>Chapter 5 - Pthreads and UNIX</H3></FONT></TD></TR><TR><TD><FONT FACE="Arial, Helvetica" SIZE="2">Pthreads Programming</FONT></TD></TR><TR VALIGN=top><TD HEIGHT="30"><FONT FACE="Arial, Helvetica" SIZE="2">Bradford Nichols, Dick Buttlar and Jacqueline Proulx Farrell</FONT></TD></TR></TABLE></TD></TR><TR><TD><TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" WIDTH="100%"><TR><TD WIDTH="176" VALIGN="top"></TD><TD WIDTH="120" VALIGN="top"><FONT FACE="Arial, Helvetica" SIZE="1" COLOR="#122EB2">&nbsp;</FONT></TD><TD WIDTH="249" ALIGN="right" VALIGN="top"><FONT FACE="Arial, Helvetica" SIZE="2">Copyright © 1996 O'Reilly & Associates, Inc.</FONT></TD></TR></TABLE></TD></TR><TR VALIGN="middle"><TD HEIGHT="32" WIDTH="470"><TABLE WIDTH="545" BORDER="0" CELLPADDING="0" CELLSPACING="0"><TR><TD WIDTH="545" COLSPAN=2><HR WIDTH="100%" ALIGN="left" SIZE="1" NOSHADE></TD><TD WIDTH="0" ALIGN="right"></TD></TR></TABLE></TD></TR></TABLE><A HREF="r_946960881.html" BORDER="0"></A><TABLE border=0 cellspacing=0 cellpadding=0 WIDTH=550><TR><A NAME=1137568></A><TD WIDTH=98% VALIGN=TOP>
<TABLE border=0 cellspacing=0 cellpadding=0 WIDTH=100%><TR><TD><IMG HEIGHT=12 WIDTH=1 SRC=_.gif></TD></TR><TR><TD WIDTH=2%></TD><TD WIDTH=96% VALIGN=TOP ALIGN=left><FONT SIZE="4" FACE="Arial" COLOR="000080"><B>Threads and Process Management </B></FONT></TD><TD WIDTH=2%></TD></TR></TABLE></TD></TR></TABLE><TABLE border=0 cellspacing=0 cellpadding=0 WIDTH=550><TR><A NAME=1137724></A><TD WIDTH=98% VALIGN=TOP>
<TABLE border=0 cellspacing=0 cellpadding=0 WIDTH=100%><TR><TD><IMG HEIGHT=6 WIDTH=1 SRC=_.gif></TD></TR><TR><TD WIDTH=2%></TD><TD WIDTH=96% VALIGN=TOP ALIGN=left><FONT SIZE="2" FACE="Arial" COLOR="010100">On a Pthreads-compliant system, calls that manipulate processes, like </FONT><FONT SIZE="2" FACE="Arial" COLOR="010100"><I>fork</I></FONT><FONT SIZE="2" FACE="Arial" COLOR="010100"> and </FONT><FONT SIZE="2" FACE="Arial" COLOR="010100"><I>exec</I></FONT><FONT SIZE="2" FACE="Arial" COLOR="010100">, still behave in the way they always have for nonthreaded programs. Let's see what happens when we make these calls from a multithreaded process.&nbsp; </FONT></TD><TD WIDTH=2%></TD></TR></TABLE></TD></TR></TABLE><TABLE border=0 cellspacing=0 cellpadding=0 WIDTH=550><TR><A NAME=1137916></A><TD WIDTH=98% VALIGN=TOP>
<TABLE border=0 cellspacing=0 cellpadding=0 WIDTH=100%><TR><TD><IMG HEIGHT=12 WIDTH=1 SRC=_.gif></TD></TR><TR><TD WIDTH=2%></TD><TD WIDTH=96% VALIGN=TOP ALIGN=left><FONT SIZE="4" FACE="Arial" COLOR="800000"><B>Calling fork from a Thread </B></FONT></TD><TD WIDTH=2%></TD></TR></TABLE></TD></TR></TABLE><TABLE border=0 cellspacing=0 cellpadding=0 WIDTH=550><TR><A NAME=1138056></A><TD WIDTH=98% VALIGN=TOP>
<TABLE border=0 cellspacing=0 cellpadding=0 WIDTH=100%><TR><TD><IMG HEIGHT=6 WIDTH=1 SRC=_.gif></TD></TR><TR><TD WIDTH=2%></TD><TD WIDTH=96% VALIGN=TOP ALIGN=left><FONT SIZE="2" FACE="Arial" COLOR="010100">A process creates another process by issuing a </FONT><FONT SIZE="2" FACE="Arial" COLOR="010100"><I>fork</I></FONT><FONT SIZE="2" FACE="Arial" COLOR="010100"> call. The newly created child process has a new process ID but starts with the same memory image and state as its parent. At its birth it's an exact clone of its parent, starting execution at the point of its parent's </FONT><FONT SIZE="2" FACE="Arial" COLOR="010100"><I>fork</I></FONT><FONT SIZE="2" FACE="Arial" COLOR="010100"> call in the same program. Often, the new process immediately calls </FONT><FONT SIZE="2" FACE="Arial" COLOR="010100"><I>exec</I></FONT><FONT SIZE="2" FACE="Arial" COLOR="010100"> to replace its parent's program with a new program. It then sets out on its own business.&nbsp; </FONT></TD><TD WIDTH=2%></TD></TR></TABLE></TD></TR></TABLE><TABLE border=0 cellspacing=0 cellpadding=0 WIDTH=550><TR><A NAME=1147074></A><TD WIDTH=98% VALIGN=TOP>
<TABLE border=0 cellspacing=0 cellpadding=0 WIDTH=100%><TR><TD><IMG HEIGHT=6 WIDTH=1 SRC=_.gif></TD></TR><TR><TD WIDTH=2%></TD><TD WIDTH=96% VALIGN=TOP ALIGN=left><FONT SIZE="2" FACE="Arial" COLOR="010100">In a Pthreads-compliant implementation, the </FONT><FONT SIZE="2" FACE="Arial" COLOR="010100"><I>fork</I></FONT><FONT SIZE="2" FACE="Arial" COLOR="010100"> call always creates a new child process with a single thread, regardless of how many threads its parent may have had at the time of the call. Furthermore, the child's thread is a replica of the thread in the parent that called </FONT><FONT SIZE="2" FACE="Arial" COLOR="010100"><I>fork</I></FONT><FONT SIZE="2" FACE="Arial" COLOR="010100">—including a process address space shared by </FONT><FONT SIZE="2" FACE="Arial" COLOR="010100"><I>all</I></FONT><FONT SIZE="2" FACE="Arial" COLOR="010100"> of its parent's threads and its parent thread's per-thread stack.&nbsp; </FONT></TD><TD WIDTH=2%></TD></TR></TABLE></TD></TR></TABLE><TABLE border=0 cellspacing=0 cellpadding=0 WIDTH=550><TR><A NAME=1147322></A><TD WIDTH=98% VALIGN=TOP>
<TABLE border=0 cellspacing=0 cellpadding=0 WIDTH=100%><TR><TD><IMG HEIGHT=6 WIDTH=1 SRC=_.gif></TD></TR><TR><TD WIDTH=2%></TD><TD WIDTH=96% VALIGN=TOP ALIGN=left><FONT SIZE="2" FACE="Arial" COLOR="010100">Consider the headaches:&nbsp; </FONT></TD><TD WIDTH=2%></TD></TR></TABLE></TD></TR></TABLE><TABLE border=0 cellspacing=0 cellpadding=0 WIDTH=550><TR><A NAME=1147399></A><TD WIDTH=98% VALIGN=TOP>
<TABLE border=0 cellspacing=0 cellpadding=0 WIDTH=100%><TR><TD><IMG HEIGHT=6 WIDTH=1 SRC=_.gif></TD></TR><TR><TD WIDTH=2%>&nbsp;</TD><TD WIDTH=2% VALIGN=TOP><FONT SIZE="2" FACE="Arial" COLOR="010100">•</FONT></TD><TD WIDTH=1%></TD><TD WIDTH=93% VALIGN=TOP ALIGN=left><FONT SIZE="2" FACE="Arial" COLOR="010100">The new single-threaded child process could inherit held locks from threads in the parent that don't exist in the child. It may have no idea what these locks mean, let alone realize that it holds one of them. Confusion and deadlock are in the forecast.&nbsp; </FONT></TD><TD WIDTH=2%></TD></TR></TABLE></TD></TR></TABLE><TABLE border=0 cellspacing=0 cellpadding=0 WIDTH=550><TR><A NAME=1147624></A><TD WIDTH=98% VALIGN=TOP>
<TABLE border=0 cellspacing=0 cellpadding=0 WIDTH=100%><TR><TD><IMG HEIGHT=6 WIDTH=1 SRC=_.gif></TD></TR><TR><TD WIDTH=2%>&nbsp;</TD><TD WIDTH=2% VALIGN=TOP><FONT SIZE="2" FACE="Arial" COLOR="010100">•</FONT></TD><TD WIDTH=1%></TD><TD WIDTH=93% VALIGN=TOP ALIGN=left><FONT SIZE="2" FACE="Arial" COLOR="010100">The child process could inherit heap areas that were allocated by threads in the parent that don't exist in the child. Here we see memory leaks, data loss, and bug reports.&nbsp; </FONT></TD><TD WIDTH=2%></TD></TR></TABLE></TD></TR></TABLE><TABLE border=0 cellspacing=0 cellpadding=0 WIDTH=550><TR><A NAME=1147797></A><TD WIDTH=98% VALIGN=TOP>
<TABLE border=0 cellspacing=0 cellpadding=0 WIDTH=100%><TR><TD><IMG HEIGHT=6 WIDTH=1 SRC=_.gif></TD></TR><TR><TD WIDTH=2%></TD><TD WIDTH=96% VALIGN=TOP ALIGN=left><FONT SIZE="2" FACE="Arial" COLOR="010100">The Pthreads standard defines the </FONT><FONT SIZE="2" FACE="Arial" COLOR="010100"><I>pthread_atfork</I></FONT><FONT SIZE="2" FACE="Arial" COLOR="010100"> call to help you manage these problems. The </FONT><FONT SIZE="2" FACE="Arial" COLOR="010100"><I>pthread_atfork</I></FONT><FONT SIZE="2" FACE="Arial" COLOR="010100"> function allows a parent process to specify preparation and cleanup routines that parent and child processes run as part of the </FONT><FONT SIZE="2" FACE="Arial" COLOR="010100"><I>fork</I></FONT><FONT SIZE="2" FACE="Arial" COLOR="010100"> operation. Using these routines a parent or child process can manage the release and reacquisition of locks and resources before and after the </FONT><FONT SIZE="2" FACE="Arial" COLOR="010100"><I>fork</I></FONT><FONT SIZE="2" FACE="Arial" COLOR="010100">.&nbsp; </FONT></TD><TD WIDTH=2%></TD></TR></TABLE></TD></TR></TABLE><TABLE border=0 cellspacing=0 cellpadding=0 WIDTH=550><TR><A NAME=1148074></A><TD WIDTH=98% VALIGN=TOP>
<TABLE border=0 cellspacing=0 cellpadding=0 WIDTH=100%><TR><TD><IMG HEIGHT=6 WIDTH=1 SRC=_.gif></TD></TR><TR><TD WIDTH=2%></TD><TD WIDTH=96% VALIGN=TOP ALIGN=left><FONT SIZE="2" FACE="Arial" COLOR="010100">This is pretty complex stuff, so please bear with us.&nbsp; </FONT></TD><TD WIDTH=2%></TD></TR></TABLE></TD></TR></TABLE><TABLE border=0 cellspacing=0 cellpadding=0 WIDTH=550><TR><A NAME=1148175></A><TD WIDTH=98% VALIGN=TOP>
<TABLE border=0 cellspacing=0 cellpadding=0 WIDTH=100%><TR><TD><IMG HEIGHT=12 WIDTH=1 SRC=_.gif></TD></TR><TR><TD WIDTH=2%></TD><TD WIDTH=96% VALIGN=TOP ALIGN=left><FONT SIZE="3" FACE="Arial" COLOR="010100"><B>Fork-handling stacks </B></FONT></TD><TD WIDTH=2%></TD></TR></TABLE></TD></TR></TABLE><TABLE border=0 cellspacing=0 cellpadding=0 WIDTH=550><TR><A NAME=1148314></A><TD WIDTH=98% VALIGN=TOP>
<TABLE border=0 cellspacing=0 cellpadding=0 WIDTH=100%><TR><TD><IMG HEIGHT=6 WIDTH=1 SRC=_.gif></TD></TR><TR><TD WIDTH=2%></TD><TD WIDTH=96% VALIGN=TOP ALIGN=left><FONT SIZE="2" FACE="Arial" COLOR="010100">To perform its magic, the </FONT><FONT SIZE="2" FACE="Arial" COLOR="010100"><I>pthread_atfork</I></FONT><FONT SIZE="2" FACE="Arial" COLOR="010100"> call pushes addresses of preparation and cleanup routines on any of three fork-handling stacks:&nbsp; </FONT></TD><TD WIDTH=2%></TD></TR></TABLE></TD></TR></TABLE><TABLE border=0 cellspacing=0 cellpadding=0 WIDTH=550><TR><A NAME=1148474></A><TD WIDTH=98% VALIGN=TOP>
<TABLE border=0 cellspacing=0 cellpadding=0 WIDTH=100%><TR><TD><IMG HEIGHT=6 WIDTH=1 SRC=_.gif></TD></TR><TR><TD WIDTH=2%>&nbsp;</TD><TD WIDTH=2% VALIGN=TOP><FONT SIZE="2" FACE="Arial" COLOR="010100">•</FONT><FONT SIZE="2" FACE="Arial" COLOR="010100"><I></I></FONT><FONT SIZE="2" FACE="Arial" COLOR="010100"></FONT><FONT SIZE="2" FACE="Arial" COLOR="010100"><I></I></FONT><FONT SIZE="2" FACE="Arial" COLOR="010100"></FONT></TD><TD WIDTH=1%></TD><TD WIDTH=93% VALIGN=TOP ALIGN=left><FONT SIZE="2" FACE="Arial" COLOR="010100">Routines placed on the </FONT><FONT SIZE="2" FACE="Arial" COLOR="010100"><I>prepare stack</I></FONT><FONT SIZE="2" FACE="Arial" COLOR="010100"> are run in the parent before the </FONT><FONT SIZE="2" FACE="Arial" COLOR="010100"><I>fork</I></FONT><FONT SIZE="2" FACE="Arial" COLOR="010100">.&nbsp; </FONT></TD><TD WIDTH=2%></TD></TR></TABLE></TD></TR></TABLE><TABLE border=0 cellspacing=0 cellpadding=0 WIDTH=550><TR><A NAME=1148606></A><TD WIDTH=98% VALIGN=TOP>
<TABLE border=0 cellspacing=0 cellpadding=0 WIDTH=100%><TR><TD><IMG HEIGHT=6 WIDTH=1 SRC=_.gif></TD></TR><TR><TD WIDTH=2%>&nbsp;</TD><TD WIDTH=2% VALIGN=TOP><FONT SIZE="2" FACE="Arial" COLOR="010100">•</FONT><FONT SIZE="2" FACE="Arial" COLOR="010100"><I></I></FONT><FONT SIZE="2" FACE="Arial" COLOR="010100"></FONT><FONT SIZE="2" FACE="Arial" COLOR="010100"><I></I></FONT><FONT SIZE="2" FACE="Arial" COLOR="010100"></FONT></TD><TD WIDTH=1%></TD><TD WIDTH=93% VALIGN=TOP ALIGN=left><FONT SIZE="2" FACE="Arial" COLOR="010100">Routines placed on the </FONT><FONT SIZE="2" FACE="Arial" COLOR="010100"><I>parent stack</I></FONT><FONT SIZE="2" FACE="Arial" COLOR="010100"> are run in the parent after the </FONT><FONT SIZE="2" FACE="Arial" COLOR="010100"><I>fork</I></FONT><FONT SIZE="2" FACE="Arial" COLOR="010100">.&nbsp; </FONT></TD><TD WIDTH=2%></TD></TR></TABLE></TD></TR></TABLE><TABLE border=0 cellspacing=0 cellpadding=0 WIDTH=550><TR><A NAME=1148719></A><TD WIDTH=98% VALIGN=TOP>
<TABLE border=0 cellspacing=0 cellpadding=0 WIDTH=100%><TR><TD><IMG HEIGHT=6 WIDTH=1 SRC=_.gif></TD></TR><TR><TD WIDTH=2%>&nbsp;</TD><TD WIDTH=2% VALIGN=TOP><FONT SIZE="2" FACE="Arial" COLOR="010100">•</FONT><FONT SIZE="2" FACE="Arial" COLOR="010100"><I></I></FONT><FONT SIZE="2" FACE="Arial" COLOR="010100"></FONT><FONT SIZE="2" FACE="Arial" COLOR="010100"><I></I></FONT><FONT SIZE="2" FACE="Arial" COLOR="010100"></FONT></TD><TD WIDTH=1%></TD><TD WIDTH=93% VALIGN=TOP ALIGN=left><FONT SIZE="2" FACE="Arial" COLOR="010100">Routines placed on the </FONT><FONT SIZE="2" FACE="Arial" COLOR="010100"><I>child stack</I></FONT><FONT SIZE="2" FACE="Arial" COLOR="010100"> are run in the child after the </FONT><FONT SIZE="2" FACE="Arial" COLOR="010100"><I>fork</I></FONT><FONT SIZE="2" FACE="Arial" COLOR="010100">.&nbsp; </FONT></TD><TD WIDTH=2%></TD></TR></TABLE></TD></TR></TABLE><TABLE border=0 cellspacing=0 cellpadding=0 WIDTH=550><TR><A NAME=1148837></A><TD WIDTH=98% VALIGN=TOP>
<TABLE border=0 cellspacing=0 cellpadding=0 WIDTH=100%><TR><TD><IMG HEIGHT=6 WIDTH=1 SRC=_.gif></TD></TR><TR><TD WIDTH=2%></TD><TD WIDTH=96% VALIGN=TOP ALIGN=left><FONT SIZE="2" FACE="Arial" COLOR="010100">A single call to </FONT><FONT SIZE="2" FACE="Arial" COLOR="010100"><I>pthread_atfork</I></FONT><FONT SIZE="2" FACE="Arial" COLOR="010100"> places a routine on one or more of these stacks. With multiple calls you can place routines on any given stack in a first-in last-out order. Because the fork-handling stacks are a processwide resource, any thread—not just the one that will call </FONT><FONT SIZE="2" FACE="Arial" COLOR="010100"><I>fork</I></FONT><FONT SIZE="2" FACE="Arial" COLOR="010100">—can push routines on them.&nbsp; </FONT></TD><TD WIDTH=2%></TD></TR></TABLE></TD></TR></TABLE><TABLE border=0 cellspacing=0 cellpadding=0 WIDTH=550><TR><A NAME=1149083></A><TD WIDTH=98% VALIGN=TOP>
<TABLE border=0 cellspacing=0 cellpadding=0 WIDTH=100%><TR><TD><IMG HEIGHT=6 WIDTH=1 SRC=_.gif></TD></TR><TR><TD WIDTH=2%></TD><TD WIDTH=96% VALIGN=TOP ALIGN=left><FONT SIZE="2" FACE="Arial" COLOR="010100">In those carefree times when we throw caution to the winds and decide to </FONT><FONT SIZE="2" FACE="Arial" COLOR="010100"><I>fork</I></FONT><FONT SIZE="2" FACE="Arial" COLOR="010100"> from the middle of a multithread program, we typically use </FONT><FONT SIZE="2" FACE="Arial" COLOR="010100"><I>pthread_atfork</I></FONT><FONT SIZE="2" FACE="Arial" COLOR="010100"> to push mutex-locking calls on the prepare fork-handling stack and mutex-unlocking calls on the parent and child stacks. We might also place routines that release resources and reset variables on the child stack.&nbsp; </FONT></TD><TD WIDTH=2%></TD></TR></TABLE></TD></TR></TABLE><TABLE border=0 cellspacing=0 cellpadding=0 WIDTH=550><TR><A NAME=1149331></A><TD WIDTH=98% VALIGN=TOP>
<TABLE border=0 cellspacing=0 cellpadding=0 WIDTH=100%><TR><TD><IMG HEIGHT=6 WIDTH=1 SRC=_.gif></TD></TR><TR><TD WIDTH=2%></TD><TD WIDTH=96% VALIGN=TOP ALIGN=left><FONT SIZE="2" FACE="Arial" COLOR="010100">Let's demonstrate what would happen if we did not use </FONT><FONT SIZE="2" FACE="Arial" COLOR="010100"><I>pthread_atfork</I></FONT><FONT SIZE="2" FACE="Arial" COLOR="010100">'s capabilities in one of those </FONT><FONT SIZE="2" FACE="Arial" COLOR="010100"><I>fork</I></FONT><FONT SIZE="2" FACE="Arial" COLOR="010100">-crazy programs of ours. In Figure 5-1, we have two threads: a mutex (Lock L) and the data the mutex protects. Thread A acquires Lock L and starts to modify the data. Meanwhile, Thread B decides to </FONT><FONT SIZE="2" FACE="Arial" COLOR="010100"><I>fork</I></FONT><FONT SIZE="2" FACE="Arial" COLOR="010100">. Now, the </FONT><FONT SIZE="2" FACE="Arial" COLOR="010100"><I>fork</I></FONT><FONT SIZE="2" FACE="Arial" COLOR="010100"> creates a child process that's a clone of its parent process, and this child shows a locked Lock L. The child process has a single thread, a replica of Thread B (the thread in the parent process that called </FONT><FONT SIZE="2" FACE="Arial" COLOR="010100"><I>fork</I></FONT><FONT SIZE="2" FACE="Arial" COLOR="010100">). The assortment of clones and replicas that result from the </FONT><FONT SIZE="2" FACE="Arial" COLOR="010100"><I>fork</I></FONT><FONT SIZE="2" FACE="Arial" COLOR="010100"> has little effect on the threads in the parent process. However, things are not okay in the child. The locked Lock L is an utter mystery to the new Thread B in the child. If it tries to acquire Lock L, it will deadlock. (There's no Thread A in the child that will ever release Lock L in the child process's context.) If it tries to access the data without first obtaining Lock L, it may see the data in an inconsistent form. Life's never easy for our kids.&nbsp; </FONT></TD><TD WIDTH=2%></TD></TR></TABLE></TD></TR></TABLE><TABLE border=0 cellspacing=0 cellpadding=0 WIDTH=550><TR><A NAME=1150029></A><TD WIDTH=98% VALIGN=TOP>
<TABLE border=0 cellspacing=0 cellpadding=0 WIDTH=100%><TR><TD><IMG HEIGHT=12 WIDTH=1 SRC=_.gif></TD></TR><TR><TD WIDTH=11%></TD><TD WIDTH=87% VALIGN=TOP ALIGN=left><FONT SIZE="2" FACE="Arial" COLOR="800000"><B>
     <A HREF=../img/05FIG01_0.gif><IMG SRC=../img/05FIG01_65.gif WIDTH=325 HEIGHT=195 BORDER=NO></A></B></FONT></TD><TD WIDTH=2%></TD></TR></TABLE></TD></TR></TABLE><TABLE border=0 cellspacing=0 cellpadding=0 WIDTH=550><TR><A NAME=1150158></A><TD WIDTH=98% VALIGN=TOP>
<TABLE border=0 cellspacing=0 cellpadding=0 WIDTH=100%><TR><TD><IMG HEIGHT=6 WIDTH=1 SRC=_.gif></TD></TR><TR><TD WIDTH=11%></TD><TD WIDTH=87% VALIGN=TOP ALIGN=left><FONT SIZE="2" FACE="Arial" COLOR="010100"><B>Figure 5-1: </B></FONT><FONT SIZE="2" FACE="Arial" COLOR="010100">Results of a fork when pthread_atfork is not used </FONT></TD><TD WIDTH=2%></TD></TR><TR><TD><IMG HEIGHT=6 WIDTH=1 SRC=_.gif></TD></TR></TABLE></TD></TR></TABLE><TABLE border=0 cellspacing=0 cellpadding=0 WIDTH=550><TR><A NAME=1150278></A><TD WIDTH=98% VALIGN=TOP>
<TABLE border=0 cellspacing=0 cellpadding=0 WIDTH=100%><TR><TD><IMG HEIGHT=6 WIDTH=1 SRC=_.gif></TD></TR><TR><TD WIDTH=2%></TD><TD WIDTH=96% VALIGN=TOP ALIGN=left><FONT SIZE="2" FACE="Arial" COLOR="010100">Now, let's use </FONT><FONT SIZE="2" FACE="Arial" COLOR="010100"><I>pthread_atfork</I></FONT><FONT SIZE="2" FACE="Arial" COLOR="010100"> to control Lock L's state at the time of the </FONT><FONT SIZE="2" FACE="Arial" COLOR="010100"><I>fork</I></FONT><FONT SIZE="2" FACE="Arial" COLOR="010100">. The program we show in Figure 5-2 also has Threads A and B, Lock L, and scrupulously guarded data. However, we've added an initialization routine that pushes a routine that locks L on the prepare fork-handling stack, and a routine that unlocks L on the child and parent fork-handling stacks. We've taken care to do this in a routine that executes before any thread actually uses the lock.&nbsp; </FONT></TD><TD WIDTH=2%></TD></TR></TABLE></TD></TR></TABLE><TABLE border=0 cellspacing=0 cellpadding=0 WIDTH=550><TR><A NAME=1150613></A><TD WIDTH=98% VALIGN=TOP>
<TABLE border=0 cellspacing=0 cellpadding=0 WIDTH=100%><TR><TD><IMG HEIGHT=12 WIDTH=1 SRC=_.gif></TD></TR><TR><TD WIDTH=11%></TD><TD WIDTH=87% VALIGN=TOP ALIGN=left><FONT SIZE="2" FACE="Arial" COLOR="800000"><B>
     <A HREF=../img/05FIG02_0.gif><IMG SRC=../img/05FIG02_54.gif WIDTH=270 HEIGHT=243 BORDER=NO></A></B></FONT></TD><TD WIDTH=2%></TD></TR></TABLE></TD></TR></TABLE><TABLE border=0 cellspacing=0 cellpadding=0 WIDTH=550><TR><A NAME=1150742></A><TD WIDTH=98% VALIGN=TOP>
<TABLE border=0 cellspacing=0 cellpadding=0 WIDTH=100%><TR><TD><IMG HEIGHT=6 WIDTH=1 SRC=_.gif></TD></TR><TR><TD WIDTH=11%></TD><TD WIDTH=87% VALIGN=TOP ALIGN=left><FONT SIZE="2" FACE="Arial" COLOR="010100"><B>Figure 5-2: </B></FONT><FONT SIZE="2" FACE="Arial" COLOR="010100">Results of a fork when pthread_atfork is used </FONT></TD><TD WIDTH=2%></TD></TR><TR><TD><IMG HEIGHT=6 WIDTH=1 SRC=_.gif></TD></TR></TABLE></TD></TR></TABLE><TABLE border=0 cellspacing=0 cellpadding=0 WIDTH=550><TR><A NAME=1150860></A><TD WIDTH=98% VALIGN=TOP>
<TABLE border=0 cellspacing=0 cellpadding=0 WIDTH=100%><TR><TD><IMG HEIGHT=6 WIDTH=1 SRC=_.gif></TD></TR><TR><TD WIDTH=2%></TD><TD WIDTH=96% VALIGN=TOP ALIGN=left><FONT SIZE="2" FACE="Arial" COLOR="010100">Sometime later, Thread A acquires the lock and starts to modify the data. When Thread B calls </FONT><FONT SIZE="2" FACE="Arial" COLOR="010100"><I>fork</I></FONT><FONT SIZE="2" FACE="Arial" COLOR="010100">, the routine on the prepare stack runs in Thread B's context. This routine tries to obtain Lock L and will block; Lock L is still held by Thread A. Ultimately, the </FONT><FONT SIZE="2" FACE="Arial" COLOR="010100"><I>fork</I></FONT><FONT SIZE="2" FACE="Arial" COLOR="010100"> is delayed until Thread A releases Lock L. When this happens, the prepare routine succeeds, Thread B will become the owner of the lock, and the </FONT><FONT SIZE="2" FACE="Arial" COLOR="010100"><I>fork</I></FONT><FONT SIZE="2" FACE="Arial" COLOR="010100"> proceeds. As expected, a child process is created that's a replica of its parent. However, inthis case, the newly cloned Thread B in the child knows about the locked lock it finds in the child's context. At this point, the routine we placed on the child fork-handling stack runs and releases Lock L. The same routine runs from the parent fork-handling stack and releases the lock in the parent process. When the dust settles, the lock is unowned in both parent and child, and the data it protects is in a consistent state. Who could ask for more?&nbsp; </FONT></TD><TD WIDTH=2%></TD></TR></TABLE></TD></TR></TABLE><TABLE border=0 cellspacing=0 cellpadding=0 WIDTH=550><TR><A NAME=1151464></A><TD WIDTH=98% VALIGN=TOP>
<TABLE border=0 cellspacing=0 cellpadding=0 WIDTH=100%><TR><TD><IMG HEIGHT=6 WIDTH=1 SRC=_.gif></TD></TR><TR><TD WIDTH=2%></TD><TD WIDTH=96% VALIGN=TOP ALIGN=left><FONT SIZE="2" FACE="Arial" COLOR="010100">Even given the capabilities of </FONT><FONT SIZE="2" FACE="Arial" COLOR="010100"><I>pthread_atfork</I></FONT><FONT SIZE="2" FACE="Arial" COLOR="010100">, forking from a multithreaded program is no picnic. We kept our example simple. Imagine having to track every lock and every resource that may be held by every thread in your program and in every library call it makes! Before pursuing this course, you should consider a less complex alternative:&nbsp; </FONT></TD><TD WIDTH=2%></TD></TR></TABLE></TD></TR></TABLE><TABLE border=0 cellspacing=0 cellpadding=0 WIDTH=550><TR><A NAME=1151704></A><TD WIDTH=98% VALIGN=TOP>
<TABLE border=0 cellspacing=0 cellpadding=0 WIDTH=100%><TR><TD><IMG HEIGHT=6 WIDTH=1 SRC=_.gif></TD></TR><TR><TD WIDTH=2%>&nbsp;</TD><TD WIDTH=2% VALIGN=TOP><FONT SIZE="2" FACE="Arial" COLOR="010100">•</FONT></TD><TD WIDTH=1%></TD><TD WIDTH=93% VALIGN=TOP ALIGN=left><FONT SIZE="2" FACE="Arial" COLOR="010100">If possible, fork before you've created any threads.&nbsp; </FONT></TD><TD WIDTH=2%></TD></TR></TABLE></TD></TR></TABLE><TABLE border=0 cellspacing=0 cellpadding=0 WIDTH=550><TR><A NAME=1151814></A><TD WIDTH=98% VALIGN=TOP>
<TABLE border=0 cellspacing=0 cellpadding=0 WIDTH=100%><TR><TD><IMG HEIGHT=6 WIDTH=1 SRC=_.gif></TD></TR><TR><TD WIDTH=5%></TD><TD WIDTH=93% VALIGN=TOP ALIGN=left><FONT SIZE="2" FACE="Arial" COLOR="010100">Instead of forking, create a new thread. If you are forking to </FONT><FONT SIZE="2" FACE="Arial" COLOR="010100"><I>exec</I></FONT><FONT SIZE="2" FACE="Arial" COLOR="010100"> a binary image, can you convert the image to a callable shared library to which you could simply link?&nbsp; </FONT></TD><TD WIDTH=2%></TD></TR></TABLE></TD></TR></TABLE><TABLE border=0 cellspacing=0 cellpadding=0 WIDTH=550><TR><A NAME=1152020></A><TD WIDTH=98% VALIGN=TOP>
<TABLE border=0 cellspacing=0 cellpadding=0 WIDTH=100%><TR><TD><IMG HEIGHT=6 WIDTH=1 SRC=_.gif></TD></TR><TR><TD WIDTH=2%>&nbsp;</TD><TD WIDTH=2% VALIGN=TOP><FONT SIZE="2" FACE="Arial" COLOR="010100">•</FONT></TD><TD WIDTH=1%></TD><TD WIDTH=93% VALIGN=TOP ALIGN=left><FONT SIZE="2" FACE="Arial" COLOR="010100">Consider the surrogate parent model.&nbsp; </FONT></TD><TD WIDTH=2%></TD></TR></TABLE></TD></TR></TABLE><TABLE border=0 cellspacing=0 cellpadding=0 WIDTH=550><TR><A NAME=1152130></A><TD WIDTH=98% VALIGN=TOP>
<TABLE border=0 cellspacing=0 cellpadding=0 WIDTH=100%><TR><TD><IMG HEIGHT=6 WIDTH=1 SRC=_.gif></TD></TR><TR><TD WIDTH=5%></TD><TD WIDTH=93% VALIGN=TOP ALIGN=left><FONT SIZE="2" FACE="Arial" COLOR="010100">In the surrogate parent model, a program forks a child process at initialization time. The sole purpose of the child is to serve as a sort of "surrogate parent" for the original process should it ever need to fork another child. After initialization, the original parent can proceed to create its additional threads. When it wants to </FONT><FONT SIZE="2" FACE="Arial" COLOR="010100"><I>exec</I></FONT><FONT SIZE="2" FACE="Arial" COLOR="010100"> an image, it communicates this to its child (which has remained single-threaded). The child then performs the </FONT><FONT SIZE="2" FACE="Arial" COLOR="010100"><I>fork</I></FONT><FONT SIZE="2" FACE="Arial" COLOR="010100"> and </FONT><FONT SIZE="2" FACE="Arial" COLOR="010100"><I>exec</I></FONT><FONT SIZE="2" FACE="Arial" COLOR="010100"> on behalf of the original process.&nbsp; </FONT></TD><TD WIDTH=2%></TD></TR></TABLE></TD></TR></TABLE><TABLE border=0 cellspacing=0 cellpadding=0 WIDTH=550><TR><A NAME=1152490></A><TD WIDTH=98% VALIGN=TOP>
<TABLE border=0 cellspacing=0 cellpadding=0 WIDTH=100%><TR><TD><IMG HEIGHT=12 WIDTH=1 SRC=_.gif></TD></TR><TR><TD WIDTH=2%></TD><TD WIDTH=96% VALIGN=TOP ALIGN=left><FONT SIZE="4" FACE="Arial" COLOR="800000"><B>Calling exec from a Thread </B></FONT></TD><TD WIDTH=2%></TD></TR></TABLE></TD></TR></TABLE><TABLE border=0 cellspacing=0 cellpadding=0 WIDTH=550><TR><A NAME=1152633></A><TD WIDTH=98% VALIGN=TOP>
<TABLE border=0 cellspacing=0 cellpadding=0 WIDTH=100%><TR><TD><IMG HEIGHT=6 WIDTH=1 SRC=_.gif></TD></TR><TR><TD WIDTH=2%></TD><TD WIDTH=96% VALIGN=TOP ALIGN=left><FONT SIZE="2" FACE="Arial" COLOR="010100">An </FONT><FONT SIZE="2" FACE="Arial" COLOR="010100"><I>exec</I></FONT><FONT SIZE="2" FACE="Arial" COLOR="010100"> call changes the program image of a process. For instance, using an </FONT><FONT SIZE="2" FACE="Arial" COLOR="010100"><I>exec</I></FONT><FONT SIZE="2" FACE="Arial" COLOR="010100">, a process running the shell program can switch to the </FONT><FONT SIZE="2" FACE="Arial" COLOR="010100"><I>vi</I></FONT><FONT SIZE="2" FACE="Arial" COLOR="010100"> editor program. After the </FONT><FONT SIZE="2" FACE="Arial" COLOR="010100"><I>exec</I></FONT><FONT SIZE="2" FACE="Arial" COLOR="010100"> the identity of the process remains the same (that is, it has the same process ID, user ID, etc.), but its virtual memory image is completely new and based on the program it has been asked to run.&nbsp; </FONT></TD><TD WIDTH=2%></TD></TR></TABLE></TD></TR></TABLE><TABLE border=0 cellspacing=0 cellpadding=0 WIDTH=550><TR><A NAME=1152948></A><TD WIDTH=98% VALIGN=TOP>
<TABLE border=0 cellspacing=0 cellpadding=0 WIDTH=100%><TR><TD><IMG HEIGHT=6 WIDTH=1 SRC=_.gif></TD></TR><TR><TD WIDTH=2%></TD><TD WIDTH=96% VALIGN=TOP ALIGN=left><FONT SIZE="2" FACE="Arial" COLOR="010100">If a thread in a multithreaded process issues an </FONT><FONT SIZE="2" FACE="Arial" COLOR="010100"><I>exec</I></FONT><FONT SIZE="2" FACE="Arial" COLOR="010100">, we'd expect that thread to start in the </FONT><FONT SIZE="2" FACE="Arial" COLOR="010100"><I>main</I></FONT><FONT SIZE="2" FACE="Arial" COLOR="010100"> routine of the new image. And this is essentially what happens. But what of the other threads? It wouldn't be of much use if the system loader picked some random routine entry points for them to start in. With this in mind, the Pthreads standard specifies that an </FONT><FONT SIZE="2" FACE="Arial" COLOR="010100"><I>exec</I></FONT><FONT SIZE="2" FACE="Arial" COLOR="010100"> call from any thread must terminate all threads in the process and start a single new thread at </FONT><FONT SIZE="2" FACE="Arial" COLOR="010100"><I>main</I></FONT><FONT SIZE="2" FACE="Arial" COLOR="010100"> in the new image.&nbsp; </FONT></TD><TD WIDTH=2%></TD></TR></TABLE></TD></TR></TABLE><TABLE border=0 cellspacing=0 cellpadding=0 WIDTH=550><TR><A NAME=1163461></A><TD WIDTH=98% VALIGN=TOP>
<TABLE border=0 cellspacing=0 cellpadding=0 WIDTH=100%><TR><TD><IMG HEIGHT=12 WIDTH=1 SRC=_.gif></TD></TR><TR><TD WIDTH=2%></TD><TD WIDTH=96% VALIGN=TOP ALIGN=left><FONT SIZE="4" FACE="Arial" COLOR="800000"><B>Process Exit and Threads </B></FONT></TD><TD WIDTH=2%></TD></TR></TABLE></TD></TR></TABLE><TABLE border=0 cellspacing=0 cellpadding=0 WIDTH=550><TR><A NAME=1163596></A><TD WIDTH=98% VALIGN=TOP>
<TABLE border=0 cellspacing=0 cellpadding=0 WIDTH=100%><TR><TD><IMG HEIGHT=6 WIDTH=1 SRC=_.gif></TD></TR><TR><TD WIDTH=2%></TD><TD WIDTH=96% VALIGN=TOP ALIGN=left><FONT SIZE="2" FACE="Arial" COLOR="010100">Regardless of whether or not a process contains multiple threads, it can be terminated when:&nbsp; </FONT></TD><TD WIDTH=2%></TD></TR></TABLE></TD></TR></TABLE><TABLE border=0 cellspacing=0 cellpadding=0 WIDTH=550><TR><A NAME=1163731></A><TD WIDTH=98% VALIGN=TOP>
<TABLE border=0 cellspacing=0 cellpadding=0 WIDTH=100%><TR><TD><IMG HEIGHT=6 WIDTH=1 SRC=_.gif></TD></TR><TR><TD WIDTH=2%>&nbsp;</TD><TD WIDTH=2% VALIGN=TOP><FONT SIZE="2" FACE="Arial" COLOR="010100">•</FONT><FONT SIZE="2" FACE="Arial" COLOR="010100"><I></I></FONT><FONT SIZE="2" FACE="Arial" COLOR="010100"></FONT></TD><TD WIDTH=1%></TD><TD WIDTH=93% VALIGN=TOP ALIGN=left><FONT SIZE="2" FACE="Arial" COLOR="010100">Any thread in it makes an </FONT><FONT SIZE="2" FACE="Arial" COLOR="010100"><I>exit</I></FONT><FONT SIZE="2" FACE="Arial" COLOR="010100"> system call.&nbsp; </FONT></TD><TD WIDTH=2%></TD></TR></TABLE></TD></TR></TABLE><TABLE border=0 cellspacing=0 cellpadding=0 WIDTH=550><TR><A NAME=1163856></A><TD WIDTH=98% VALIGN=TOP>
<TABLE border=0 cellspacing=0 cellpadding=0 WIDTH=100%><TR><TD><IMG HEIGHT=6 WIDTH=1 SRC=_.gif></TD></TR><TR><TD WIDTH=2%>&nbsp;</TD><TD WIDTH=2% VALIGN=TOP><FONT SIZE="2" FACE="Arial" COLOR="010100">•</FONT><FONT SIZE="2" FACE="Arial" COLOR="010100"><I></I></FONT><FONT SIZE="2" FACE="Arial" COLOR="010100"></FONT></TD><TD WIDTH=1%></TD><TD WIDTH=93% VALIGN=TOP ALIGN=left><FONT SIZE="2" FACE="Arial" COLOR="010100">The thread running the </FONT><FONT SIZE="2" FACE="Arial" COLOR="010100"><I>main</I></FONT><FONT SIZE="2" FACE="Arial" COLOR="010100"> routine completes its execution.&nbsp; </FONT></TD><TD WIDTH=2%></TD></TR></TABLE></TD></TR></TABLE><TABLE border=0 cellspacing=0 cellpadding=0 WIDTH=550><TR><A NAME=1163953></A><TD WIDTH=98% VALIGN=TOP>
<TABLE border=0 cellspacing=0 cellpadding=0 WIDTH=100%><TR><TD><IMG HEIGHT=6 WIDTH=1 SRC=_.gif></TD></TR><TR><TD WIDTH=2%>&nbsp;</TD><TD WIDTH=2% VALIGN=TOP><FONT SIZE="2" FACE="Arial" COLOR="010100">•</FONT></TD><TD WIDTH=1%></TD><TD WIDTH=93% VALIGN=TOP ALIGN=left><FONT SIZE="2" FACE="Arial" COLOR="010100">A fatal signal is delivered.&nbsp; </FONT></TD><TD WIDTH=2%></TD></TR></TABLE></TD></TR></TABLE><TABLE border=0 cellspacing=0 cellpadding=0 WIDTH=550><TR><A NAME=1164040></A><TD WIDTH=98% VALIGN=TOP>
<TABLE border=0 cellspacing=0 cellpadding=0 WIDTH=100%><TR><TD><IMG HEIGHT=6 WIDTH=1 SRC=_.gif></TD></TR><TR><TD WIDTH=2%></TD><TD WIDTH=96% VALIGN=TOP ALIGN=left><FONT SIZE="2" FACE="Arial" COLOR="010100">When a process exits, all threads in it die immediately, and their resources are released. (If you call </FONT><FONT SIZE="2" FACE="Arial" COLOR="010100"><I>_exit</I></FONT><FONT SIZE="2" FACE="Arial" COLOR="010100"> directly, the system doesn't guarantee the cleanup.)&nbsp; </FONT></TD><TD WIDTH=2%></TD></TR></TABLE></TD></TR></TABLE><A NAME="{B4AC29EB-8775-11D4-A9C0-0008C791A32F}"></A><TABLE WIDTH="545" BORDER="0" CELLPADDING="0" CELLSPACING="0"><TR><TD WIDTH="509" COLSPAN="3"><HR WIDTH="100%" ALIGN="left" SIZE="1" NOSHADE></TD><TD WIDTH="36" ALIGN="right"><A HREF="#toppage" BORDER="0"><IMG SRC="../img/to_top.gif" WIDTH="25" HEIGHT="11" BORDER="0"></A></TD></TR><TR><TD WIDTH="36"></TD><TD WIDTH="236" HEIGHT="25" VALIGN="top" ALIGN="left"><A HREF="r_43.html" BORDER="0"><IMG SRC="../img/vb_prev.gif" WIDTH="65" HEIGHT="17" ALT="Previous Section" TITLE="Previous Section" BORDER="0"></A></TD><TD WIDTH="236" HEIGHT="25" VALIGN="top" ALIGN="right"><A HREF="r_45.html" BORDER="0"><IMG SRC="../img/vb_next.gif" WIDTH="65" HEIGHT="17" ALT="Next Section" TITLE="Next Section" BORDER="0"></A></TD><TD WIDTH="36"></TD></TR></TABLE><TABLE BORDER="0" WIDTH="550" CELLSPACING="0" CELLPADDING="0"><TR><TD COLSPAN="2" ALIGN="Left" VALIGN="Bottom" HEIGHT="20"><IMG SRC="../img/blackdot.gif" WIDTH="550" HEIGHT="1"></TD></TR><TR><TD HEIGHT="11" WIDTH="100%"><FONT FACE="Arial, Helvetica, sans-serif" SIZE="1">Books24x7.com, Inc © 2000&nbsp;–&nbsp;&nbsp;<A HREF="feedback.html+fb=1&bkid=232&chnkid=44.html"  BORDER="0"><FONT COLOR="#333333">Feedback</FONT></A></FONT></TD></TR></TABLE>

</BODY>
</HTML>
