
<HTML>
<HEAD>
<TITLE> Pthreads ProgrammingChapter 6 - Practical Considerations</TITLE>
<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=iso-8859-1">

</HEAD>
<BODY  LINK="#122EB2"  LEFTMARGIN=0 TOPMARGIN=5 >






<A NAME="toppage"></A><TABLE BORDER="0" CELLSPACING="1" CELLPADDING="1"><TR ALIGN="right"><TD  HEIGHT="44"><A HREF="../toc.html"  BORDER="0"><IMG SRC="../img/vb_toc.gif" WIDTH="114" HEIGHT="17" BORDER="0"></A><A HREF="bookmark.html+bkid=232&chnkid=47.html"  BORDER="0"><IMG SRC="../img/bookmark_create.gif" WIDTH="115" HEIGHT="17" BORDER="0"></A><A HREF="bookshelf.html+bkid=232&chnkid=47&addbk=1.html"  BORDER="0"><IMG SRC="../img/vblue_add_book.gif" WIDTH="106" HEIGHT="17" ALT="Add Book to My Bookshelf" TITLE="Add Book to My Bookshelf" BORDER="0"></A><A HREF="buybook.html+bkid=232.html" TARGET="_top" BORDER="0"><IMG SRC="../img/vb_purchase.gif" WIDTH="108" HEIGHT="17" ALT="Purchase This Book Online" TITLE="Purchase This Book Online" BORDER="0"></A></TD></TR><TR VALIGN="top"><TD><TABLE BORDER="0" CELLSPACING="0" CELLPADDING="1"><TR VALIGN="top" HEIGHT=5><TD ROWSPAN="3"  VALIGN=top ALIGN=left WIDTH="100" HEIGHT="110"><IMG SRC="../img/1565921151.gif" WIDTH="79" HEIGHT="103" ALIGN=Left BORDER="0"></TD><TD><FONT FACE="Arial, Helvetica, sans-serif" SIZE="3"><H3>Chapter 6 - Practical Considerations</H3></FONT></TD></TR><TR><TD><FONT FACE="Arial, Helvetica" SIZE="2">Pthreads Programming</FONT></TD></TR><TR VALIGN=top><TD HEIGHT="30"><FONT FACE="Arial, Helvetica" SIZE="2">Bradford Nichols, Dick Buttlar and Jacqueline Proulx Farrell</FONT></TD></TR></TABLE></TD></TR><TR><TD><TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" WIDTH="100%"><TR><TD WIDTH="176" VALIGN="top"></TD><TD WIDTH="120" VALIGN="top"><FONT FACE="Arial, Helvetica" SIZE="1" COLOR="#122EB2">&nbsp;</FONT></TD><TD WIDTH="249" ALIGN="right" VALIGN="top"><FONT FACE="Arial, Helvetica" SIZE="2">Copyright © 1996 O'Reilly & Associates, Inc.</FONT></TD></TR></TABLE></TD></TR><TR VALIGN="middle"><TD HEIGHT="32" WIDTH="470"><TABLE WIDTH="545" BORDER="0" CELLPADDING="0" CELLSPACING="0"><TR><TD WIDTH="545" COLSPAN=2><HR WIDTH="100%" ALIGN="left" SIZE="1" NOSHADE></TD><TD WIDTH="0" ALIGN="right"></TD></TR></TABLE></TD></TR></TABLE><A HREF="r_772158984.html" BORDER="0"></A><TABLE border=0 cellspacing=0 cellpadding=0 WIDTH=550><TR><A NAME=1168217></A><TD WIDTH=98% VALIGN=TOP>
<TABLE border=0 cellspacing=0 cellpadding=0 WIDTH=100%><TR><TD><IMG HEIGHT=12 WIDTH=1 SRC=_.gif></TD></TR><TR><TD WIDTH=2%></TD><TD WIDTH=96% VALIGN=TOP ALIGN=left><FONT SIZE="4" FACE="Arial" COLOR="000080"><B>Understanding Pthreads Implementation </B></FONT></TD><TD WIDTH=2%></TD></TR></TABLE></TD></TR></TABLE><TABLE border=0 cellspacing=0 cellpadding=0 WIDTH=550><TR><A NAME=1168372></A><TD WIDTH=98% VALIGN=TOP>
<TABLE border=0 cellspacing=0 cellpadding=0 WIDTH=100%><TR><TD><IMG HEIGHT=6 WIDTH=1 SRC=_.gif></TD></TR><TR><TD WIDTH=2%></TD><TD WIDTH=96% VALIGN=TOP ALIGN=left><FONT SIZE="2" FACE="Arial" COLOR="010100">Pthreads implementations fall into three basic categories:&nbsp; </FONT></TD><TD WIDTH=2%></TD></TR></TABLE></TD></TR></TABLE><TABLE border=0 cellspacing=0 cellpadding=0 WIDTH=550><TR><A NAME=1168482></A><TD WIDTH=98% VALIGN=TOP>
<TABLE border=0 cellspacing=0 cellpadding=0 WIDTH=100%><TR><TD><IMG HEIGHT=6 WIDTH=1 SRC=_.gif></TD></TR><TR><TD WIDTH=2%>&nbsp;</TD><TD WIDTH=2% VALIGN=TOP><FONT SIZE="2" FACE="Arial" COLOR="010100">•</FONT></TD><TD WIDTH=1%></TD><TD WIDTH=93% VALIGN=TOP ALIGN=left><FONT SIZE="2" FACE="Arial" COLOR="010100">Based on pure user space.&nbsp; </FONT></TD><TD WIDTH=2%></TD></TR></TABLE></TD></TR></TABLE><TABLE border=0 cellspacing=0 cellpadding=0 WIDTH=550><TR><A NAME=1168593></A><TD WIDTH=98% VALIGN=TOP>
<TABLE border=0 cellspacing=0 cellpadding=0 WIDTH=100%><TR><TD><IMG HEIGHT=6 WIDTH=1 SRC=_.gif></TD></TR><TR><TD WIDTH=2%>&nbsp;</TD><TD WIDTH=2% VALIGN=TOP><FONT SIZE="2" FACE="Arial" COLOR="010100">•</FONT></TD><TD WIDTH=1%></TD><TD WIDTH=93% VALIGN=TOP ALIGN=left><FONT SIZE="2" FACE="Arial" COLOR="010100">Based on pure kernel thread.&nbsp; </FONT></TD><TD WIDTH=2%></TD></TR></TABLE></TD></TR></TABLE><TABLE border=0 cellspacing=0 cellpadding=0 WIDTH=550><TR><A NAME=1168681></A><TD WIDTH=98% VALIGN=TOP>
<TABLE border=0 cellspacing=0 cellpadding=0 WIDTH=100%><TR><TD><IMG HEIGHT=6 WIDTH=1 SRC=_.gif></TD></TR><TR><TD WIDTH=2%>&nbsp;</TD><TD WIDTH=2% VALIGN=TOP><FONT SIZE="2" FACE="Arial" COLOR="010100">•</FONT><FONT SIZE="2" FACE="Arial" COLOR="010100"><I></I></FONT><FONT SIZE="2" FACE="Arial" COLOR="010100"></FONT><FONT SIZE="2" FACE="Arial" COLOR="010100"><I></I></FONT><FONT SIZE="2" FACE="Arial" COLOR="010100"></FONT><FONT SIZE="2" FACE="Arial" COLOR="010100"><I></I></FONT><FONT SIZE="2" FACE="Arial" COLOR="010100"></FONT></TD><TD WIDTH=1%></TD><TD WIDTH=93% VALIGN=TOP ALIGN=left><FONT SIZE="2" FACE="Arial" COLOR="010100">Implementations somewhere between the two. These hybrid implementations are referred to variously as </FONT><FONT SIZE="2" FACE="Arial" COLOR="010100"><I>two-level schedulers</I></FONT><FONT SIZE="2" FACE="Arial" COLOR="010100">, </FONT><FONT SIZE="2" FACE="Arial" COLOR="010100"><I>lightweight processes</I></FONT><FONT SIZE="2" FACE="Arial" COLOR="010100"> (LWPs), or </FONT><FONT SIZE="2" FACE="Arial" COLOR="010100"><I>activations</I></FONT><FONT SIZE="2" FACE="Arial" COLOR="010100">.&nbsp; </FONT></TD><TD WIDTH=2%></TD></TR></TABLE></TD></TR></TABLE><TABLE border=0 cellspacing=0 cellpadding=0 WIDTH=550><TR><A NAME=1168879></A><TD WIDTH=98% VALIGN=TOP>
<TABLE border=0 cellspacing=0 cellpadding=0 WIDTH=100%><TR><TD><IMG HEIGHT=6 WIDTH=1 SRC=_.gif></TD></TR><TR><TD WIDTH=2%></TD><TD WIDTH=96% VALIGN=TOP ALIGN=left><FONT SIZE="2" FACE="Arial" COLOR="010100">All implementations in these categories conform to the Pthreads standard and provide concurrency (the basic goal of threads). However, your platform's choice of implementation has a radical effect on the scheduling and performance of the threads in your program. Just look for a moment at the extremes! Pure user-space thread implementations don't provide global scheduling scope and don't actually allow multiple threads from the same process to execute in parallel on different CPUs. At the other extreme, pure kernel-thread implementations don't scale well when a process has 10, 20, 30, or more threads.&nbsp; </FONT></TD><TD WIDTH=2%></TD></TR></TABLE></TD></TR></TABLE><TABLE border=0 cellspacing=0 cellpadding=0 WIDTH=550><TR><A NAME=1169269></A><TD WIDTH=98% VALIGN=TOP>
<TABLE border=0 cellspacing=0 cellpadding=0 WIDTH=100%><TR><TD><IMG HEIGHT=6 WIDTH=1 SRC=_.gif></TD></TR><TR><TD WIDTH=2%></TD><TD WIDTH=96% VALIGN=TOP ALIGN=left><FONT SIZE="2" FACE="Arial" COLOR="010100">Because Pthreads implementations are varied and complex and because implementations are evolving and improving at a swift rate, we can't do justice to them in the brief space we have in this book. The goal of this section is to introduce you to those differences in architectures that impact the way your program performs on various implementations.&nbsp; </FONT></TD><TD WIDTH=2%></TD></TR></TABLE></TD></TR></TABLE><TABLE border=0 cellspacing=0 cellpadding=0 WIDTH=550><TR><A NAME=1179660></A><TD WIDTH=98% VALIGN=TOP>
<TABLE border=0 cellspacing=0 cellpadding=0 WIDTH=100%><TR><TD><IMG HEIGHT=6 WIDTH=1 SRC=_.gif></TD></TR><TR><TD WIDTH=2%></TD><TD WIDTH=96% VALIGN=TOP ALIGN=left><FONT SIZE="2" FACE="Arial" COLOR="010100">We'll set the stage for later discussions by reviewing some basic vocabulary.&nbsp; </FONT></TD><TD WIDTH=2%></TD></TR></TABLE></TD></TR></TABLE><TABLE border=0 cellspacing=0 cellpadding=0 WIDTH=550><TR><A NAME=1179773></A><TD WIDTH=98% VALIGN=TOP>
<TABLE border=0 cellspacing=0 cellpadding=0 WIDTH=100%><TR><TD><IMG HEIGHT=12 WIDTH=1 SRC=_.gif></TD></TR><TR><TD WIDTH=2%></TD><TD WIDTH=96% VALIGN=TOP ALIGN=left><FONT SIZE="4" FACE="Arial" COLOR="800000"><B>Two Worlds </B></FONT></TD><TD WIDTH=2%></TD></TR></TABLE></TD></TR></TABLE><TABLE border=0 cellspacing=0 cellpadding=0 WIDTH=550><TR><A NAME=1179908></A><TD WIDTH=98% VALIGN=TOP>
<TABLE border=0 cellspacing=0 cellpadding=0 WIDTH=100%><TR><TD><IMG HEIGHT=6 WIDTH=1 SRC=_.gif></TD></TR><TR><TD WIDTH=2%></TD><TD WIDTH=96% VALIGN=TOP ALIGN=left><FONT SIZE="2" FACE="Arial" COLOR="010100"><I>User mode</I></FONT><FONT SIZE="2" FACE="Arial" COLOR="010100"> commonly refers to the times when a process (or, by extension, a thread) is executing the instructions in its program or a library (to which the program is linked). The program or library knows about the various objects upon which it operates (such as code, data, and other abstractions) because they are defined in </FONT><FONT SIZE="2" FACE="Arial" COLOR="010100"><I>user space</I></FONT><FONT SIZE="2" FACE="Arial" COLOR="010100"> and not in the underlying operating system kernel.&nbsp; </FONT></TD><TD WIDTH=2%></TD></TR></TABLE></TD></TR></TABLE><TABLE border=0 cellspacing=0 cellpadding=0 WIDTH=550><TR><A NAME=1180187></A><TD WIDTH=98% VALIGN=TOP>
<TABLE border=0 cellspacing=0 cellpadding=0 WIDTH=100%><TR><TD><IMG HEIGHT=6 WIDTH=1 SRC=_.gif></TD></TR><TR><TD WIDTH=2%></TD><TD WIDTH=96% VALIGN=TOP ALIGN=left><FONT SIZE="2" FACE="Arial" COLOR="010100"><I>Kernel mode</I></FONT><FONT SIZE="2" FACE="Arial" COLOR="010100"> refers to a process's (or a thread's) operational mode when it's executing within the operating system's kernel—usually as a result of a system call or an exception. In kernel mode, a process runs the instructions of the core operating system to access resources and services on a program's behalf. While it's running in kernel mode, the process can access objects that are defined in </FONT><FONT SIZE="2" FACE="Arial" COLOR="010100"><I>kernel space</I></FONT><FONT SIZE="2" FACE="Arial" COLOR="010100"> and, thereby, known only to the kernel.&nbsp; </FONT></TD><TD WIDTH=2%></TD></TR></TABLE></TD></TR></TABLE><TABLE border=0 cellspacing=0 cellpadding=0 WIDTH=550><TR><A NAME=1180472></A><TD WIDTH=98% VALIGN=TOP>
<TABLE border=0 cellspacing=0 cellpadding=0 WIDTH=100%><TR><TD><IMG HEIGHT=12 WIDTH=1 SRC=_.gif></TD></TR><TR><TD WIDTH=2%></TD><TD WIDTH=96% VALIGN=TOP ALIGN=left><FONT SIZE="4" FACE="Arial" COLOR="800000"><B>Two Kinds of Threads </B></FONT></TD><TD WIDTH=2%></TD></TR></TABLE></TD></TR></TABLE><TABLE border=0 cellspacing=0 cellpadding=0 WIDTH=550><TR><A NAME=1180616></A><TD WIDTH=98% VALIGN=TOP>
<TABLE border=0 cellspacing=0 cellpadding=0 WIDTH=100%><TR><TD><IMG HEIGHT=6 WIDTH=1 SRC=_.gif></TD></TR><TR><TD WIDTH=2%></TD><TD WIDTH=96% VALIGN=TOP ALIGN=left><FONT SIZE="2" FACE="Arial" COLOR="010100">The threads we've discussed in this book are </FONT><FONT SIZE="2" FACE="Arial" COLOR="010100"><I>user threads</I></FONT><FONT SIZE="2" FACE="Arial" COLOR="010100">. They are programming abstractions that exist to be accessed by calls from within your program. In fact, the Pthreads standard doesn't require the operating system kernel to know anything at all about them. Whether a Pthread has any meaning inside the kernel or within kernel mode is up to the implementation.&nbsp; </FONT></TD><TD WIDTH=2%></TD></TR></TABLE></TD></TR></TABLE><TABLE border=0 cellspacing=0 cellpadding=0 WIDTH=550><TR><A NAME=1180870></A><TD WIDTH=98% VALIGN=TOP>
<TABLE border=0 cellspacing=0 cellpadding=0 WIDTH=100%><TR><TD><IMG HEIGHT=6 WIDTH=1 SRC=_.gif></TD></TR><TR><TD WIDTH=2%></TD><TD WIDTH=96% VALIGN=TOP ALIGN=left><FONT SIZE="2" FACE="Arial" COLOR="010100">A </FONT><FONT SIZE="2" FACE="Arial" COLOR="010100"><I>kernel thread</I></FONT><SUP>*</SUP><FONT SIZE="2" FACE="Arial" COLOR="000000">can be something quite different. It's an abstraction for an operating system execution point within a process. To support the Pthreads standard, an implementor doesn't need to use kernel threads. As we'll see, the standard allows for great flexibility in the underlying implementation.&nbsp; </FONT></TD><TD WIDTH=2%></TD></TR></TABLE></TD></TR></TABLE><TABLE border=0 cellspacing=0 cellpadding=0 WIDTH=550><TR><A NAME=1181073></A><TD WIDTH=98% VALIGN=TOP>
<TABLE border=0 cellspacing=0 cellpadding=0 WIDTH=100%><TR><TD><IMG HEIGHT=6 WIDTH=1 SRC=_.gif></TD></TR><TR><TD WIDTH=2%>&nbsp;</TD><TD WIDTH=1% VALIGN=TOP><SUP>*</SUP><FONT SIZE="2" FACE="Arial" COLOR="000000"></FONT><FONT SIZE="2" FACE="Arial" COLOR="000000"><I></I></FONT><FONT SIZE="2" FACE="Arial" COLOR="000000"></FONT><FONT SIZE="2" FACE="Arial" COLOR="000000"><I></I></FONT><FONT SIZE="2" FACE="Arial" COLOR="000000"></FONT><FONT SIZE="2" FACE="Arial" COLOR="000000"><I></I></FONT><FONT SIZE="2" FACE="Arial" COLOR="000000"></FONT><FONT SIZE="2" FACE="Arial" COLOR="000000"><I></I></FONT><FONT SIZE="2" FACE="Arial" COLOR="000000"></FONT></TD><TD WIDTH=1%></TD><TD WIDTH=94% VALIGN=TOP ALIGN=left><SUP></SUP><FONT SIZE="2" FACE="Arial" COLOR="000000">The various UNIX operating systems use different terms for kernel thread. Digital UNIX, which was derived from Mach 2.5, uses the term </FONT><FONT SIZE="2" FACE="Arial" COLOR="000000"><I>kernel thread</I></FONT><FONT SIZE="2" FACE="Arial" COLOR="000000">; Sun's Solaris uses the term </FONT><FONT SIZE="2" FACE="Arial" COLOR="000000"><I>lightweight process (LWP)</I></FONT><FONT SIZE="2" FACE="Arial" COLOR="000000">; others use the term </FONT><FONT SIZE="2" FACE="Arial" COLOR="000000"><I>activation</I></FONT><FONT SIZE="2" FACE="Arial" COLOR="000000"> or </FONT><FONT SIZE="2" FACE="Arial" COLOR="000000"><I>two-level scheduler</I></FONT><FONT SIZE="2" FACE="Arial" COLOR="000000">.</FONT></TD><TD WIDTH=2%></TD></TR></TABLE></TD></TR></TABLE><TABLE border=0 cellspacing=0 cellpadding=0 WIDTH=550><TR><A NAME=1181340></A><TD WIDTH=98% VALIGN=TOP>
<TABLE border=0 cellspacing=0 cellpadding=0 WIDTH=100%><TR><TD><IMG HEIGHT=6 WIDTH=1 SRC=_.gif></TD></TR><TR><TD WIDTH=2%></TD><TD WIDTH=96% VALIGN=TOP ALIGN=left><FONT SIZE="2" FACE="Arial" COLOR="010100">Some platforms have native, nonstandard user-space thread implementations that predate the Pthreads standard. (The proliferation of these nonstandard interfaces was actually the motivating force behind the effort to define the Pthreads standard.) These native thread interfaces often have very similar semantics to those of the Pthreads interfaces, but they don't fully comply with the syntax and functionality the standard requires. On these platforms, an additional layer—sometimes only an include file—exists to turn the native user-space threads into Pthreads that conform to the portable Pthread interface.&nbsp; </FONT></TD><TD WIDTH=2%></TD></TR></TABLE></TD></TR></TABLE><TABLE border=0 cellspacing=0 cellpadding=0 WIDTH=550><TR><A NAME=1181783></A><TD WIDTH=98% VALIGN=TOP>
<TABLE border=0 cellspacing=0 cellpadding=0 WIDTH=100%><TR><TD><IMG HEIGHT=12 WIDTH=1 SRC=_.gif></TD></TR><TR><TD WIDTH=2%></TD><TD WIDTH=96% VALIGN=TOP ALIGN=left><FONT SIZE="4" FACE="Arial" COLOR="800000"><B>Who's Providing the Thread? </B></FONT></TD><TD WIDTH=2%></TD></TR></TABLE></TD></TR></TABLE><TABLE border=0 cellspacing=0 cellpadding=0 WIDTH=550><TR><A NAME=1181929></A><TD WIDTH=98% VALIGN=TOP>
<TABLE border=0 cellspacing=0 cellpadding=0 WIDTH=100%><TR><TD><IMG HEIGHT=6 WIDTH=1 SRC=_.gif></TD></TR><TR><TD WIDTH=2%></TD><TD WIDTH=96% VALIGN=TOP ALIGN=left><FONT SIZE="2" FACE="Arial" COLOR="010100">A Pthreads implementation supports user threads by a Pthreads-compliant library and, optionally, by changes to the operating system kernel. So, when we issue a </FONT><FONT SIZE="2" FACE="Arial" COLOR="010100"><I>pthread_create</I></FONT><FONT SIZE="2" FACE="Arial" COLOR="010100"> call on a given implementation, what is involved in creating the thread—the Pthreads library alone, the kernel itself, or some combination of the two? We'll look at the various possibilities.&nbsp; </FONT></TD><TD WIDTH=2%></TD></TR></TABLE></TD></TR></TABLE><TABLE border=0 cellspacing=0 cellpadding=0 WIDTH=550><TR><A NAME=1182181></A><TD WIDTH=98% VALIGN=TOP>
<TABLE border=0 cellspacing=0 cellpadding=0 WIDTH=100%><TR><TD><IMG HEIGHT=12 WIDTH=1 SRC=_.gif></TD></TR><TR><TD WIDTH=2%></TD><TD WIDTH=96% VALIGN=TOP ALIGN=left><FONT SIZE="3" FACE="Arial" COLOR="010100"><B>User-space Pthreads implementations </B></FONT></TD><TD WIDTH=2%></TD></TR></TABLE></TD></TR></TABLE><TABLE border=0 cellspacing=0 cellpadding=0 WIDTH=550><TR><A NAME=1182320></A><TD WIDTH=98% VALIGN=TOP>
<TABLE border=0 cellspacing=0 cellpadding=0 WIDTH=100%><TR><TD><IMG HEIGHT=6 WIDTH=1 SRC=_.gif></TD></TR><TR><TD WIDTH=2%></TD><TD WIDTH=96% VALIGN=TOP ALIGN=left><FONT SIZE="2" FACE="Arial" COLOR="010100">In pure user-space implementations, the kernel isn't involved at all in providing a user thread. As shown in Figure 6-1, the Pthreads library itself schedules threads, multiplexing all of a process's threads onto its single execution context. The kernel has no notion of threads; it continues to schedule processes as it usually does.&nbsp; </FONT></TD><TD WIDTH=2%></TD></TR></TABLE></TD></TR></TABLE><TABLE border=0 cellspacing=0 cellpadding=0 WIDTH=550><TR><A NAME=1182567></A><TD WIDTH=98% VALIGN=TOP>
<TABLE border=0 cellspacing=0 cellpadding=0 WIDTH=100%><TR><TD><IMG HEIGHT=6 WIDTH=1 SRC=_.gif></TD></TR><TR><TD WIDTH=2%></TD><TD WIDTH=96% VALIGN=TOP ALIGN=left><FONT SIZE="2" FACE="Arial" COLOR="010100">This design is known as an </FONT><FONT SIZE="2" FACE="Arial" COLOR="010100"><I>all-to-one mapping</I></FONT><FONT SIZE="2" FACE="Arial" COLOR="010100">. Out of all of a process's threads that are able to run at a given time, the Pthreads library selects just one to run in its process's context when that process is next scheduled by the kernel.&nbsp; </FONT></TD><TD WIDTH=2%></TD></TR></TABLE></TD></TR></TABLE><TABLE border=0 cellspacing=0 cellpadding=0 WIDTH=550><TR><A NAME=1182751></A><TD WIDTH=98% VALIGN=TOP>
<TABLE border=0 cellspacing=0 cellpadding=0 WIDTH=100%><TR><TD><IMG HEIGHT=12 WIDTH=1 SRC=_.gif></TD></TR><TR><TD WIDTH=11%></TD><TD WIDTH=87% VALIGN=TOP ALIGN=left><FONT SIZE="2" FACE="Arial" COLOR="800000"><B>
     <A HREF=../img/06FIG01_0.gif><IMG SRC=../img/06FIG01_65.gif WIDTH=325 HEIGHT=214 BORDER=NO></A></B></FONT></TD><TD WIDTH=2%></TD></TR></TABLE></TD></TR></TABLE><TABLE border=0 cellspacing=0 cellpadding=0 WIDTH=550><TR><A NAME=1182880></A><TD WIDTH=98% VALIGN=TOP>
<TABLE border=0 cellspacing=0 cellpadding=0 WIDTH=100%><TR><TD><IMG HEIGHT=6 WIDTH=1 SRC=_.gif></TD></TR><TR><TD WIDTH=11%></TD><TD WIDTH=87% VALIGN=TOP ALIGN=left><FONT SIZE="2" FACE="Arial" COLOR="010100"><B>Figure 6-1: </B></FONT><FONT SIZE="2" FACE="Arial" COLOR="010100">User-space thread implementations </FONT></TD><TD WIDTH=2%></TD></TR><TR><TD><IMG HEIGHT=6 WIDTH=1 SRC=_.gif></TD></TR></TABLE></TD></TR></TABLE><TABLE border=0 cellspacing=0 cellpadding=0 WIDTH=550><TR><A NAME=1183003></A><TD WIDTH=98% VALIGN=TOP>
<TABLE border=0 cellspacing=0 cellpadding=0 WIDTH=100%><TR><TD><IMG HEIGHT=6 WIDTH=1 SRC=_.gif></TD></TR><TR><TD WIDTH=2%></TD><TD WIDTH=96% VALIGN=TOP ALIGN=left><FONT SIZE="2" FACE="Arial" COLOR="010100">A pure user-space implementation can be based quite simply on tools that </FONT><FONT SIZE="2" FACE="Arial" COLOR="010100"><I>UNIX</I></FONT><FONT SIZE="2" FACE="Arial" COLOR="010100"> programmers have traditionally used to manage multiple contexts within a single process: namely, </FONT><FONT SIZE="2" FACE="Arial" COLOR="010100"><I>setjmp</I></FONT><FONT SIZE="2" FACE="Arial" COLOR="010100">, </FONT><FONT SIZE="2" FACE="Arial" COLOR="010100"><I>longjmp</I></FONT><FONT SIZE="2" FACE="Arial" COLOR="010100">, and signals. The Pthreads library may define a user thread as a data structure that stores an execution point in the form of a </FONT><FONT SIZE="2" FACE="Arial" COLOR="010100"><I>jmp_buf</I></FONT><FONT SIZE="2" FACE="Arial" COLOR="010100"> structure saved by a </FONT><FONT SIZE="2" FACE="Arial" COLOR="010100"><I>setjmp</I></FONT><FONT SIZE="2" FACE="Arial" COLOR="010100"> call. When the current thread is rescheduled, it resumes the new thread that has been selected to run by performing a </FONT><FONT SIZE="2" FACE="Arial" COLOR="010100"><I>longjmp</I></FONT><FONT SIZE="2" FACE="Arial" COLOR="010100"> to the new thread's stored </FONT><FONT SIZE="2" FACE="Arial" COLOR="010100"><I>jmp_buf</I></FONT><FONT SIZE="2" FACE="Arial" COLOR="010100"> execution point.&nbsp; </FONT></TD><TD WIDTH=2%></TD></TR></TABLE></TD></TR></TABLE><TABLE border=0 cellspacing=0 cellpadding=0 WIDTH=550><TR><A NAME=1183384></A><TD WIDTH=98% VALIGN=TOP>
<TABLE border=0 cellspacing=0 cellpadding=0 WIDTH=100%><TR><TD><IMG HEIGHT=6 WIDTH=1 SRC=_.gif></TD></TR><TR><TD WIDTH=2%></TD><TD WIDTH=96% VALIGN=TOP ALIGN=left><FONT SIZE="2" FACE="Arial" COLOR="010100">There are several advantages to a pure user-space implementation:&nbsp; </FONT></TD><TD WIDTH=2%></TD></TR></TABLE></TD></TR></TABLE><TABLE border=0 cellspacing=0 cellpadding=0 WIDTH=550><TR><A NAME=1183468></A><TD WIDTH=98% VALIGN=TOP>
<TABLE border=0 cellspacing=0 cellpadding=0 WIDTH=100%><TR><TD><IMG HEIGHT=6 WIDTH=1 SRC=_.gif></TD></TR><TR><TD WIDTH=2%>&nbsp;</TD><TD WIDTH=2% VALIGN=TOP><FONT SIZE="2" FACE="Arial" COLOR="010100">•</FONT></TD><TD WIDTH=1%></TD><TD WIDTH=93% VALIGN=TOP ALIGN=left><FONT SIZE="2" FACE="Arial" COLOR="010100">Because it doesn't require changes to the operating system itself, it allows many UNIX vendors, and vendors of other operating systems, to quickly provide a Pthreads-compliant library without having to invent kernel threads. For instance, Digital implemented its Pthreads library in this way on versions of OpenVMS prior to Version 7.0. (Version 7.0 uses kernel threads.) Additionally, DCE includes a user-space implementation, thus encouraging its vendors to provide support for DCE threads by relieving them of wholescale changes to their operating systems.&nbsp; </FONT></TD><TD WIDTH=2%></TD></TR></TABLE></TD></TR></TABLE><TABLE border=0 cellspacing=0 cellpadding=0 WIDTH=550><TR><A NAME=1183837></A><TD WIDTH=98% VALIGN=TOP>
<TABLE border=0 cellspacing=0 cellpadding=0 WIDTH=100%><TR><TD><IMG HEIGHT=6 WIDTH=1 SRC=_.gif></TD></TR><TR><TD WIDTH=2%>&nbsp;</TD><TD WIDTH=2% VALIGN=TOP><FONT SIZE="2" FACE="Arial" COLOR="010100">•</FONT></TD><TD WIDTH=1%></TD><TD WIDTH=93% VALIGN=TOP ALIGN=left><FONT SIZE="2" FACE="Arial" COLOR="010100">Because user-space implementation doesn't use expensive system calls to create threads and doesn't require the operating system to perform a context switch between threads, certain types of multithreaded applications can run faster than they would in a kernel-thread implementation. Among these applications are those that run exclusively on uniprocessing systems and those that don't have enough CPU-bound work to effectively use multiple CPUs.&nbsp; </FONT></TD><TD WIDTH=2%></TD></TR></TABLE></TD></TR></TABLE><TABLE border=0 cellspacing=0 cellpadding=0 WIDTH=550><TR><A NAME=1184105></A><TD WIDTH=98% VALIGN=TOP>
<TABLE border=0 cellspacing=0 cellpadding=0 WIDTH=100%><TR><TD><IMG HEIGHT=6 WIDTH=1 SRC=_.gif></TD></TR><TR><TD WIDTH=2%>&nbsp;</TD><TD WIDTH=2% VALIGN=TOP><FONT SIZE="2" FACE="Arial" COLOR="010100">•</FONT></TD><TD WIDTH=1%></TD><TD WIDTH=93% VALIGN=TOP ALIGN=left><FONT SIZE="2" FACE="Arial" COLOR="010100">Because user-space threads aren't known to the operating system, they can be created quickly and without impact to the kernel. This scales well: you can create more and more threads without overloading the system. Each thread is just another timeslice from the set of resources originally assigned to your process.&nbsp; </FONT></TD><TD WIDTH=2%></TD></TR></TABLE></TD></TR></TABLE><TABLE border=0 cellspacing=0 cellpadding=0 WIDTH=550><TR><A NAME=1184317></A><TD WIDTH=98% VALIGN=TOP>
<TABLE border=0 cellspacing=0 cellpadding=0 WIDTH=100%><TR><TD><IMG HEIGHT=6 WIDTH=1 SRC=_.gif></TD></TR><TR><TD WIDTH=2%></TD><TD WIDTH=96% VALIGN=TOP ALIGN=left><FONT SIZE="2" FACE="Arial" COLOR="010100">There are also two considerable disadvantages:&nbsp; </FONT></TD><TD WIDTH=2%></TD></TR></TABLE></TD></TR></TABLE><TABLE border=0 cellspacing=0 cellpadding=0 WIDTH=550><TR><A NAME=1184423></A><TD WIDTH=98% VALIGN=TOP>
<TABLE border=0 cellspacing=0 cellpadding=0 WIDTH=100%><TR><TD><IMG HEIGHT=6 WIDTH=1 SRC=_.gif></TD></TR><TR><TD WIDTH=2%>&nbsp;</TD><TD WIDTH=2% VALIGN=TOP><FONT SIZE="2" FACE="Arial" COLOR="010100">•</FONT></TD><TD WIDTH=1%></TD><TD WIDTH=93% VALIGN=TOP ALIGN=left><FONT SIZE="2" FACE="Arial" COLOR="010100">The Pthreads library manages the scheduling of user threads using an all-to-one mapping of threads to a single process's execution context. As a result, threads within the same process compete against each other for CPU cycles. The operating system never sees an individual thread, only the process. If you raise the priority of a thread, it'll run more often and longer than other threads of lower priority in the same process. If it was your intention to give it a scheduling advantage over threads from other processes on the system, you'll be disappointed. To get the responsiveness you expect for a real-time thread from this type of implementation, you must either throw everybody else off the system or always run your entire process and all of its threads at a higher priority than everyone else. Either approach is likely to bring a system administrator to your office.&nbsp; </FONT></TD><TD WIDTH=2%></TD></TR></TABLE></TD></TR></TABLE><TABLE border=0 cellspacing=0 cellpadding=0 WIDTH=550><TR><A NAME=1184941></A><TD WIDTH=98% VALIGN=TOP>
<TABLE border=0 cellspacing=0 cellpadding=0 WIDTH=100%><TR><TD><IMG HEIGHT=6 WIDTH=1 SRC=_.gif></TD></TR><TR><TD WIDTH=2%>&nbsp;</TD><TD WIDTH=2% VALIGN=TOP><FONT SIZE="2" FACE="Arial" COLOR="010100">•</FONT></TD><TD WIDTH=1%></TD><TD WIDTH=93% VALIGN=TOP ALIGN=left><FONT SIZE="2" FACE="Arial" COLOR="010100">Because the Pthreads library's thread-scheduling ability is limited to threads within a process, it restricts your multithreaded program from taking advantage of multiple CPUs. Because the operating system is utterly unaware that many streams of processing are beneath a given process, it allocates available CPUs to processes, not threads. All threads in a process must share the CPU on which the process was scheduled (and do so in the timeslice given to the process). The threads can never run in parallel across the available CPUs, even if another CPU happens to be idle!&nbsp; </FONT></TD><TD WIDTH=2%></TD></TR></TABLE></TD></TR></TABLE><TABLE border=0 cellspacing=0 cellpadding=0 WIDTH=550><TR><A NAME=1185287></A><TD WIDTH=98% VALIGN=TOP>
<TABLE border=0 cellspacing=0 cellpadding=0 WIDTH=100%><TR><TD><IMG HEIGHT=12 WIDTH=1 SRC=_.gif></TD></TR><TR><TD WIDTH=2%></TD><TD WIDTH=96% VALIGN=TOP ALIGN=left><FONT SIZE="3" FACE="Arial" COLOR="010100"><B>Kernel thread-based Pthreads implementations </B></FONT></TD><TD WIDTH=2%></TD></TR></TABLE></TD></TR></TABLE><TABLE border=0 cellspacing=0 cellpadding=0 WIDTH=550><TR><A NAME=1185439></A><TD WIDTH=98% VALIGN=TOP>
<TABLE border=0 cellspacing=0 cellpadding=0 WIDTH=100%><TR><TD><IMG HEIGHT=6 WIDTH=1 SRC=_.gif></TD></TR><TR><TD WIDTH=2%></TD><TD WIDTH=96% VALIGN=TOP ALIGN=left><FONT SIZE="2" FACE="Arial" COLOR="010100">In pure kernel thread-based implementations, the Pthreads library creates a kernel thread for each user thread. Because each kernel thread represents the execution context of a single user thread, this design is known as a </FONT><FONT SIZE="2" FACE="Arial" COLOR="010100"><I>one-to-one mapping</I></FONT><FONT SIZE="2" FACE="Arial" COLOR="010100">. As we show in Figure 6-2, when a CPU becomes available, the kernel chooses a kernel thread to run from among all the kernel threads available on the system, regardless of which processes they represent.&nbsp; </FONT></TD><TD WIDTH=2%></TD></TR></TABLE></TD></TR></TABLE><TABLE border=0 cellspacing=0 cellpadding=0 WIDTH=550><TR><A NAME=1196171></A><TD WIDTH=98% VALIGN=TOP>
<TABLE border=0 cellspacing=0 cellpadding=0 WIDTH=100%><TR><TD><IMG HEIGHT=12 WIDTH=1 SRC=_.gif></TD></TR><TR><TD WIDTH=11%></TD><TD WIDTH=87% VALIGN=TOP ALIGN=left><FONT SIZE="2" FACE="Arial" COLOR="800000"><B>
     <A HREF=../img/06FIG02_0.gif><IMG SRC=../img/06FIG02_65.gif WIDTH=325 HEIGHT=214 BORDER=NO></A></B></FONT></TD><TD WIDTH=2%></TD></TR></TABLE></TD></TR></TABLE><TABLE border=0 cellspacing=0 cellpadding=0 WIDTH=550><TR><A NAME=1196300></A><TD WIDTH=98% VALIGN=TOP>
<TABLE border=0 cellspacing=0 cellpadding=0 WIDTH=100%><TR><TD><IMG HEIGHT=6 WIDTH=1 SRC=_.gif></TD></TR><TR><TD WIDTH=11%></TD><TD WIDTH=87% VALIGN=TOP ALIGN=left><FONT SIZE="2" FACE="Arial" COLOR="010100"><B>Figure 6-2: </B></FONT><FONT SIZE="2" FACE="Arial" COLOR="010100">Kernel thread-based implementations </FONT></TD><TD WIDTH=2%></TD></TR><TR><TD><IMG HEIGHT=6 WIDTH=1 SRC=_.gif></TD></TR></TABLE></TD></TR></TABLE><TABLE border=0 cellspacing=0 cellpadding=0 WIDTH=550><TR><A NAME=1196406></A><TD WIDTH=98% VALIGN=TOP>
<TABLE border=0 cellspacing=0 cellpadding=0 WIDTH=100%><TR><TD><IMG HEIGHT=6 WIDTH=1 SRC=_.gif></TD></TR><TR><TD WIDTH=2%></TD><TD WIDTH=96% VALIGN=TOP ALIGN=left><FONT SIZE="2" FACE="Arial" COLOR="010100">A pure kernel thread-based implementation depends upon the operating system to define, store, and reload the execution states of individual threads. The operating system must now manage on a per-thread basis some of the information it's traditionally maintained for an individual process. For instance, each thread must have its own scheduling priority, its own set of saved registers, and its own CPU assignment. Other types of information, such as the file table, remain associated with the process.&nbsp; </FONT></TD><TD WIDTH=2%></TD></TR></TABLE></TD></TR></TABLE><TABLE border=0 cellspacing=0 cellpadding=0 WIDTH=550><TR><A NAME=1196727></A><TD WIDTH=98% VALIGN=TOP>
<TABLE border=0 cellspacing=0 cellpadding=0 WIDTH=100%><TR><TD><IMG HEIGHT=6 WIDTH=1 SRC=_.gif></TD></TR><TR><TD WIDTH=2%></TD><TD WIDTH=96% VALIGN=TOP ALIGN=left><FONT SIZE="2" FACE="Arial" COLOR="010100">A good example of a pure kernel thread-based implementation is the pre-Version 4.0 Digital UNIX, which was known as DEC OSF/1 at the time. Digital UNIX, based in part on the Mach operating system developed at Carnegie-Mellon University (CMU), adopted Mach's kernel thread design. Mach threads operate at a much lower level than Pthreads and provide minimal functionality. Prior to Version 4.0, the Digital UNIX Pthreads library requested a new Mach kernel thread from the system for each </FONT><FONT SIZE="2" FACE="Arial" COLOR="010100"><I>pthread_create</I></FONT><FONT SIZE="2" FACE="Arial" COLOR="010100"> call. Because the Mach kernel thread design provides few synchronization primitives, it's the role of the Pthreads library to implement such features as mutexes and thread joins atop the Mach kernel thread functionality.&nbsp; </FONT></TD><TD WIDTH=2%></TD></TR></TABLE></TD></TR></TABLE><TABLE border=0 cellspacing=0 cellpadding=0 WIDTH=550><TR><A NAME=1197155></A><TD WIDTH=98% VALIGN=TOP>
<TABLE border=0 cellspacing=0 cellpadding=0 WIDTH=100%><TR><TD><IMG HEIGHT=6 WIDTH=1 SRC=_.gif></TD></TR><TR><TD WIDTH=2%></TD><TD WIDTH=96% VALIGN=TOP ALIGN=left><FONT SIZE="2" FACE="Arial" COLOR="010100">The advantages of a pure kernel thread-based implementation set to right the disadvantages of the pure user-space implementation:&nbsp; </FONT></TD><TD WIDTH=2%></TD></TR></TABLE></TD></TR></TABLE><TABLE border=0 cellspacing=0 cellpadding=0 WIDTH=550><TR><A NAME=1197266></A><TD WIDTH=98% VALIGN=TOP>
<TABLE border=0 cellspacing=0 cellpadding=0 WIDTH=100%><TR><TD><IMG HEIGHT=6 WIDTH=1 SRC=_.gif></TD></TR><TR><TD WIDTH=2%>&nbsp;</TD><TD WIDTH=2% VALIGN=TOP><FONT SIZE="2" FACE="Arial" COLOR="010100">•</FONT></TD><TD WIDTH=1%></TD><TD WIDTH=93% VALIGN=TOP ALIGN=left><FONT SIZE="2" FACE="Arial" COLOR="010100">The Pthreads library schedules user threads on a one-to-one basis to kernel threads. As a result, threads compete against all other threads on the system for CPU cycles, not just against other threads in the same process. The kernel is aware of threads. If you raise the priority of a thread, it'll run more often and longer than other threads of lower priority throughout the system.&nbsp; </FONT></TD><TD WIDTH=2%></TD></TR></TABLE></TD></TR></TABLE><TABLE border=0 cellspacing=0 cellpadding=0 WIDTH=550><TR><A NAME=1197519></A><TD WIDTH=98% VALIGN=TOP>
<TABLE border=0 cellspacing=0 cellpadding=0 WIDTH=100%><TR><TD><IMG HEIGHT=6 WIDTH=1 SRC=_.gif></TD></TR><TR><TD WIDTH=2%>&nbsp;</TD><TD WIDTH=2% VALIGN=TOP><FONT SIZE="2" FACE="Arial" COLOR="010100">•</FONT></TD><TD WIDTH=1%></TD><TD WIDTH=93% VALIGN=TOP ALIGN=left><FONT SIZE="2" FACE="Arial" COLOR="010100">Because the kernel schedules threads globally across the entire system, multiple threads in your program can run on different CPUs simultaneously, as long as their relative priorities are higher than those of other threads on the system. Unlike a pure user-space implementation, a pure kernel thread-based implementation doesn't limit your program to a single executing thread.&nbsp; </FONT></TD><TD WIDTH=2%></TD></TR></TABLE></TD></TR></TABLE><TABLE border=0 cellspacing=0 cellpadding=0 WIDTH=550><TR><A NAME=1197725></A><TD WIDTH=98% VALIGN=TOP>
<TABLE border=0 cellspacing=0 cellpadding=0 WIDTH=100%><TR><TD><IMG HEIGHT=6 WIDTH=1 SRC=_.gif></TD></TR><TR><TD WIDTH=2%></TD><TD WIDTH=96% VALIGN=TOP ALIGN=left><FONT SIZE="2" FACE="Arial" COLOR="010100">The disadvantages of a kernel thread-based implementation are as follows:&nbsp; </FONT></TD><TD WIDTH=2%></TD></TR></TABLE></TD></TR></TABLE><TABLE border=0 cellspacing=0 cellpadding=0 WIDTH=550><TR><A NAME=1197848></A><TD WIDTH=98% VALIGN=TOP>
<TABLE border=0 cellspacing=0 cellpadding=0 WIDTH=100%><TR><TD><IMG HEIGHT=6 WIDTH=1 SRC=_.gif></TD></TR><TR><TD WIDTH=2%>&nbsp;</TD><TD WIDTH=2% VALIGN=TOP><FONT SIZE="2" FACE="Arial" COLOR="010100">•</FONT></TD><TD WIDTH=1%></TD><TD WIDTH=93% VALIGN=TOP ALIGN=left><FONT SIZE="2" FACE="Arial" COLOR="010100">Although less expensive than creating a new process, the creation of a new kernel thread does require some kernel overhead—the processing of a system call and the maintenance of kernel data structures. If your application will never run on a multiprocessor, or if its threads are not CPU bound, this overhead is unnecessary. A user-space implementation would probably provide better performance.&nbsp; </FONT></TD><TD WIDTH=2%></TD></TR></TABLE></TD></TR></TABLE><TABLE border=0 cellspacing=0 cellpadding=0 WIDTH=550><TR><A NAME=1198106></A><TD WIDTH=98% VALIGN=TOP>
<TABLE border=0 cellspacing=0 cellpadding=0 WIDTH=100%><TR><TD><IMG HEIGHT=6 WIDTH=1 SRC=_.gif></TD></TR><TR><TD WIDTH=2%>&nbsp;</TD><TD WIDTH=2% VALIGN=TOP><FONT SIZE="2" FACE="Arial" COLOR="010100">•</FONT></TD><TD WIDTH=1%></TD><TD WIDTH=93% VALIGN=TOP ALIGN=left><FONT SIZE="2" FACE="Arial" COLOR="010100">Because some cost is associated with creating and maintaining kernel threads, applications that use a lot of threads ("a lot" meaning 10 or more on some systems, hundreds on others) can significantly load a system and degrade its overall performance, thus affecting all running applications.&nbsp; </FONT></TD><TD WIDTH=2%></TD></TR></TABLE></TD></TR></TABLE><TABLE border=0 cellspacing=0 cellpadding=0 WIDTH=550><TR><A NAME=1198338></A><TD WIDTH=98% VALIGN=TOP>
<TABLE border=0 cellspacing=0 cellpadding=0 WIDTH=100%><TR><TD><IMG HEIGHT=12 WIDTH=1 SRC=_.gif></TD></TR><TR><TD WIDTH=2%></TD><TD WIDTH=96% VALIGN=TOP ALIGN=left><FONT SIZE="3" FACE="Arial" COLOR="010100"><B>Two-level scheduler Pthreads implementations: the best of both worlds </B></FONT></TD><TD WIDTH=2%></TD></TR></TABLE></TD></TR></TABLE><TABLE border=0 cellspacing=0 cellpadding=0 WIDTH=550><TR><A NAME=1198513></A><TD WIDTH=98% VALIGN=TOP>
<TABLE border=0 cellspacing=0 cellpadding=0 WIDTH=100%><TR><TD><IMG HEIGHT=6 WIDTH=1 SRC=_.gif></TD></TR><TR><TD WIDTH=2%></TD><TD WIDTH=96% VALIGN=TOP ALIGN=left><FONT SIZE="2" FACE="Arial" COLOR="010100">In a two-level scheduler implementation, the Pthreads library and the operating system kernel cooperate to schedule user threads. Like a pure kernel thread-based implementation, a two-level scheduler implementation maps user threads to kernel threads, but instead of mapping each user thread to a kernel thread, it may map many user threads to any of a pool of kernel threads (see Figure 6-3). This is known as a </FONT><FONT SIZE="2" FACE="Arial" COLOR="010100"><I>some-to-one-mapping</I></FONT><FONT SIZE="2" FACE="Arial" COLOR="010100">. A user thread may not have a unique relationship to a specific kernel thread; rather, it may be mapped to different kernel threads at different times.&nbsp; </FONT></TD><TD WIDTH=2%></TD></TR></TABLE></TD></TR></TABLE><TABLE border=0 cellspacing=0 cellpadding=0 WIDTH=550><TR><A NAME=1198870></A><TD WIDTH=98% VALIGN=TOP>
<TABLE border=0 cellspacing=0 cellpadding=0 WIDTH=100%><TR><TD><IMG HEIGHT=12 WIDTH=1 SRC=_.gif></TD></TR><TR><TD WIDTH=11%></TD><TD WIDTH=87% VALIGN=TOP ALIGN=left><FONT SIZE="2" FACE="Arial" COLOR="800000"><B>
     <A HREF=../img/06FIG03_0.gif><IMG SRC=../img/06FIG03_65.gif WIDTH=325 HEIGHT=214 BORDER=NO></A></B></FONT></TD><TD WIDTH=2%></TD></TR></TABLE></TD></TR></TABLE><TABLE border=0 cellspacing=0 cellpadding=0 WIDTH=550><TR><A NAME=1198999></A><TD WIDTH=98% VALIGN=TOP>
<TABLE border=0 cellspacing=0 cellpadding=0 WIDTH=100%><TR><TD><IMG HEIGHT=6 WIDTH=1 SRC=_.gif></TD></TR><TR><TD WIDTH=11%></TD><TD WIDTH=87% VALIGN=TOP ALIGN=left><FONT SIZE="2" FACE="Arial" COLOR="010100"><B>Figure 6-3: </B></FONT><FONT SIZE="2" FACE="Arial" COLOR="010100">Two-level scheduler implementations </FONT></TD><TD WIDTH=2%></TD></TR><TR><TD><IMG HEIGHT=6 WIDTH=1 SRC=_.gif></TD></TR></TABLE></TD></TR></TABLE><TABLE border=0 cellspacing=0 cellpadding=0 WIDTH=550><TR><A NAME=1199108></A><TD WIDTH=98% VALIGN=TOP>
<TABLE border=0 cellspacing=0 cellpadding=0 WIDTH=100%><TR><TD><IMG HEIGHT=6 WIDTH=1 SRC=_.gif></TD></TR><TR><TD WIDTH=2%></TD><TD WIDTH=96% VALIGN=TOP ALIGN=left><FONT SIZE="2" FACE="Arial" COLOR="010100">Both the Pthreads library and the kernel maintain data structures that represent threads (user threads and kernel threads, respectively). The Pthreads library assigns user threads to run in a process's available kernel threads;</FONT><SUP>*</SUP><FONT SIZE="2" FACE="Arial" COLOR="000000"> the kernel schedules kernel threads from the collection of all processes' runnable kernel threads. The two levels of scheduling allow better customized fits of actual execution contexts (kernel threads) to user-specified concurrency (user threads).&nbsp; </FONT></TD><TD WIDTH=2%></TD></TR></TABLE></TD></TR></TABLE><TABLE border=0 cellspacing=0 cellpadding=0 WIDTH=550><TR><A NAME=1199416></A><TD WIDTH=98% VALIGN=TOP>
<TABLE border=0 cellspacing=0 cellpadding=0 WIDTH=100%><TR><TD><IMG HEIGHT=6 WIDTH=1 SRC=_.gif></TD></TR><TR><TD WIDTH=2%>&nbsp;</TD><TD WIDTH=1% VALIGN=TOP><SUP>*</SUP><FONT SIZE="2" FACE="Arial" COLOR="000000"></FONT></TD><TD WIDTH=1%></TD><TD WIDTH=94% VALIGN=TOP ALIGN=left><SUP></SUP><FONT SIZE="2" FACE="Arial" COLOR="000000">The Solaris Pthreads library maps user threads to LWPs. Digital UNIX Version 4.0 and OpenVMS Version 7.0 map user threads to kernel threads.</FONT></TD><TD WIDTH=2%></TD></TR></TABLE></TD></TR></TABLE><TABLE border=0 cellspacing=0 cellpadding=0 WIDTH=550><TR><A NAME=1199580></A><TD WIDTH=98% VALIGN=TOP>
<TABLE border=0 cellspacing=0 cellpadding=0 WIDTH=100%><TR><TD><IMG HEIGHT=6 WIDTH=1 SRC=_.gif></TD></TR><TR><TD WIDTH=2%></TD><TD WIDTH=96% VALIGN=TOP ALIGN=left><FONT SIZE="2" FACE="Arial" COLOR="010100">For example, if a program's user threads frequently sleep on timers, events, or I/O completion, it makes little sense to dedicate a kernel thread to each of them. The kernel threads will see little CPU activity. It's much more efficient to allow the Pthreads library in a two-level scheduler implementation to accommodate some of its user threads' spare and sporadic execution behavior by allotting them a single kernel thread altogether. For this type of program, the two-level scheduler effectively provides the benefits of a pure user-space implementation—less kernel overhead and better performance.&nbsp; </FONT></TD><TD WIDTH=2%></TD></TR></TABLE></TD></TR></TABLE><TABLE border=0 cellspacing=0 cellpadding=0 WIDTH=550><TR><A NAME=1199942></A><TD WIDTH=98% VALIGN=TOP>
<TABLE border=0 cellspacing=0 cellpadding=0 WIDTH=100%><TR><TD><IMG HEIGHT=6 WIDTH=1 SRC=_.gif></TD></TR><TR><TD WIDTH=2%></TD><TD WIDTH=96% VALIGN=TOP ALIGN=left><FONT SIZE="2" FACE="Arial" COLOR="010100">At the other extreme, another program's user threads might be completely CPU-bound and runnable. Here, the two-level scheduler might assign a kernel thread to each user thread up to the number of CPUs on the system, acting like a pure kernel thread-based implementation. Whenever a CPU becomes available, the kernel may thereby select any of these user threads for scheduling.</FONT><SUP>*</SUP></TD><TD WIDTH=2%></TD></TR></TABLE></TD></TR></TABLE><TABLE border=0 cellspacing=0 cellpadding=0 WIDTH=550><TR><A NAME=1200154></A><TD WIDTH=98% VALIGN=TOP>
<TABLE border=0 cellspacing=0 cellpadding=0 WIDTH=100%><TR><TD><IMG HEIGHT=6 WIDTH=1 SRC=_.gif></TD></TR><TR><TD WIDTH=2%>&nbsp;</TD><TD WIDTH=1% VALIGN=TOP><SUP>*</SUP><FONT SIZE="2" FACE="Arial" COLOR="000000"></FONT></TD><TD WIDTH=1%></TD><TD WIDTH=94% VALIGN=TOP ALIGN=left><SUP></SUP><FONT SIZE="2" FACE="Arial" COLOR="000000">The policies by which two-level scheduler implementations apportion their kernel threads to deserving user-space threads vary considerably. Some sophisticated implementations, such as Digital UNIX, may actually detect a change in a thread's execution behavior (for instance, as it becomes more or less CPU-bound) and adjust their kernel-thread assignments accordingly. Discussing the full range of implementation possibilities is beyond the scope of this book. However, if you are interested in reading more about two-level scheduler designs, we encourage you to look at the following publications: </FONT></TD><TD WIDTH=2%></TD></TR></TABLE></TD></TR></TABLE><TABLE border=0 cellspacing=0 cellpadding=0 WIDTH=550><TR><A NAME=1200579></A><TD WIDTH=98% VALIGN=TOP>
<TABLE border=0 cellspacing=0 cellpadding=0 WIDTH=100%><TR><TD><IMG HEIGHT=6 WIDTH=1 SRC=_.gif></TD></TR><TR><TD WIDTH=2%>&nbsp;</TD><TD WIDTH=1% VALIGN=TOP><FONT SIZE="2" FACE="Arial" COLOR="010100"><I></I></FONT><FONT SIZE="2" FACE="Arial" COLOR="010100"></FONT></TD><TD WIDTH=1%></TD><TD WIDTH=94% VALIGN=TOP ALIGN=left><FONT SIZE="2" FACE="Arial" COLOR="010100"><I>UNIX Internals: The New Frontiers</I></FONT><FONT SIZE="2" FACE="Arial" COLOR="010100"> by Uresh Vahala, Prentice Hall, 1996. Discusses recent technological developments in UNIX operating systems, including Solaris, SVR4, Digital UNIX, and Mach. </FONT></TD><TD WIDTH=2%></TD></TR></TABLE></TD></TR></TABLE><TABLE border=0 cellspacing=0 cellpadding=0 WIDTH=550><TR><A NAME=1200801></A><TD WIDTH=98% VALIGN=TOP>
<TABLE border=0 cellspacing=0 cellpadding=0 WIDTH=100%><TR><TD><IMG HEIGHT=6 WIDTH=1 SRC=_.gif></TD></TR><TR><TD WIDTH=2%>&nbsp;</TD><TD WIDTH=1% VALIGN=TOP><FONT SIZE="2" FACE="Arial" COLOR="010100"></FONT></TD><TD WIDTH=1%></TD><TD WIDTH=94% VALIGN=TOP ALIGN=left><FONT SIZE="2" FACE="Arial" COLOR="010100">"Scheduler Activations: Effective Kernel Support for the User-Level Management of Parallelism" by Anderson, Bershad, Lazowaska, and Levy, Department of Computer Science and Engineering, University of Washington, Seattle. Describes activations in their research operating system. This technology bears some resemblance to the Digital UNIX Version 4.0 two-level scheduler implementation. </FONT></TD><TD WIDTH=2%></TD></TR></TABLE></TD></TR></TABLE><TABLE border=0 cellspacing=0 cellpadding=0 WIDTH=550><TR><A NAME=1201169></A><TD WIDTH=98% VALIGN=TOP>
<TABLE border=0 cellspacing=0 cellpadding=0 WIDTH=100%><TR><TD><IMG HEIGHT=6 WIDTH=1 SRC=_.gif></TD></TR><TR><TD WIDTH=2%>&nbsp;</TD><TD WIDTH=1% VALIGN=TOP><FONT SIZE="2" FACE="Arial" COLOR="010100"></FONT><FONT SIZE="2" FACE="Arial" COLOR="010100"><I></I></FONT><FONT SIZE="2" FACE="Arial" COLOR="010100"></FONT></TD><TD WIDTH=1%></TD><TD WIDTH=94% VALIGN=TOP ALIGN=left><FONT SIZE="2" FACE="Arial" COLOR="010100">"SunOS Multi-Threaded Architecture," </FONT><FONT SIZE="2" FACE="Arial" COLOR="010100"><I>USENIX Winter Conference Proceedings</I></FONT><FONT SIZE="2" FACE="Arial" COLOR="010100">, Dallas, Texas, 1991. Describes Solaris's lightweight process implementation. </FONT></TD><TD WIDTH=2%></TD></TR></TABLE></TD></TR></TABLE><TABLE border=0 cellspacing=0 cellpadding=0 WIDTH=550><TR><A NAME=1201380></A><TD WIDTH=98% VALIGN=TOP>
<TABLE border=0 cellspacing=0 cellpadding=0 WIDTH=100%><TR><TD><IMG HEIGHT=6 WIDTH=1 SRC=_.gif></TD></TR><TR><TD WIDTH=2%></TD><TD WIDTH=96% VALIGN=TOP ALIGN=left><FONT SIZE="2" FACE="Arial" COLOR="010100">Of course, most multithreaded programs are at neither extreme. In fact, a single program may encounter periods of high I/O activity and intense CPU use over time as it executes. Its resource demands may change based on the input assigned to it on a given run. It may be subject to different constraints, such as processor speed and I/O responsiveness, depending upon the platform on which it's run. The ability to tailor its kernel thread allocation policies to an individual program is the greatest advantage of a two-level scheduler implementation. It can adapt automatically (or respond to customizations) to be more responsive to different programs, or maintain an optimal execution environment as a program's execution behavior changes.&nbsp; </FONT></TD><TD WIDTH=2%></TD></TR></TABLE></TD></TR></TABLE><TABLE border=0 cellspacing=0 cellpadding=0 WIDTH=550><TR><A NAME=1212457></A><TD WIDTH=98% VALIGN=TOP>
<TABLE border=0 cellspacing=0 cellpadding=0 WIDTH=100%><TR><TD><IMG HEIGHT=6 WIDTH=1 SRC=_.gif></TD></TR><TR><TD WIDTH=2%></TD><TD WIDTH=96% VALIGN=TOP ALIGN=left><FONT SIZE="2" FACE="Arial" COLOR="010100">Unlike a pure user-space implementation, a two-level scheduler implementation doesn't bind all user threads in a process to a single kernel execution context. Instead, it allows multiple threads in a process to run in parallel on multiple CPUs. Unlike a pure kernel thread-based implementation, a two-level scheduler implementation doesn't create a kernel thread for every user thread. By not doing so, it avoids needless overhead if a kernel thread is not used enough to justify its creation. All in all, when you design tasks for a multithreaded program that will run under a two-level scheduler, you can be less finicky about segregating CPU-bound from I/O-bound work. The two-level scheduler will adopt user-to-kernel thread mappings that are suitable to the program's actual execution behavior.&nbsp; </FONT></TD><TD WIDTH=2%></TD></TR></TABLE></TD></TR></TABLE><TABLE border=0 cellspacing=0 cellpadding=0 WIDTH=550><TR><A NAME=1212873></A><TD WIDTH=98% VALIGN=TOP>
<TABLE border=0 cellspacing=0 cellpadding=0 WIDTH=100%><TR><TD><IMG HEIGHT=6 WIDTH=1 SRC=_.gif></TD></TR><TR><TD WIDTH=2%></TD><TD WIDTH=96% VALIGN=TOP ALIGN=left><FONT SIZE="2" FACE="Arial" COLOR="010100">Perhaps the only disadvantage of a two-level scheduler is in its level of internal complexity and the effort a system developer must muster to implement one. That, fortunately, is not a problem for you, the application developer. Nevertheless, you may share in some of this complexity when you attempt to debug a multithreaded program on a two-level scheduler implementation and discover that it's difficult to keep track of how your user threads relate to the kernel threads that get placed into execution.&nbsp; </FONT></TD><TD WIDTH=2%></TD></TR></TABLE></TD></TR></TABLE><TABLE border=0 cellspacing=0 cellpadding=0 WIDTH=550><TR><A NAME=1213159></A><TD WIDTH=98% VALIGN=TOP>
<TABLE border=0 cellspacing=0 cellpadding=0 WIDTH=100%><TR><TD><IMG HEIGHT=6 WIDTH=1 SRC=_.gif></TD></TR><TR><TD WIDTH=2%></TD><TD WIDTH=96% VALIGN=TOP ALIGN=left><FONT SIZE="2" FACE="Arial" COLOR="010100">What a great way to get into our next topic!&nbsp; </FONT></TD><TD WIDTH=2%></TD></TR></TABLE></TD></TR></TABLE><A NAME="{B4AC29EB-8775-11D4-A9C0-0008C791A32F}"></A><TABLE WIDTH="545" BORDER="0" CELLPADDING="0" CELLSPACING="0"><TR><TD WIDTH="509" COLSPAN="3"><HR WIDTH="100%" ALIGN="left" SIZE="1" NOSHADE></TD><TD WIDTH="36" ALIGN="right"><A HREF="#toppage" BORDER="0"><IMG SRC="../img/to_top.gif" WIDTH="25" HEIGHT="11" BORDER="0"></A></TD></TR><TR><TD WIDTH="36"></TD><TD WIDTH="236" HEIGHT="25" VALIGN="top" ALIGN="left"><A HREF="r_46.html" BORDER="0"><IMG SRC="../img/vb_prev.gif" WIDTH="65" HEIGHT="17" ALT="Previous Section" TITLE="Previous Section" BORDER="0"></A></TD><TD WIDTH="236" HEIGHT="25" VALIGN="top" ALIGN="right"><A HREF="r_48.html" BORDER="0"><IMG SRC="../img/vb_next.gif" WIDTH="65" HEIGHT="17" ALT="Next Section" TITLE="Next Section" BORDER="0"></A></TD><TD WIDTH="36"></TD></TR></TABLE><TABLE BORDER="0" WIDTH="550" CELLSPACING="0" CELLPADDING="0"><TR><TD COLSPAN="2" ALIGN="Left" VALIGN="Bottom" HEIGHT="20"><IMG SRC="../img/blackdot.gif" WIDTH="550" HEIGHT="1"></TD></TR><TR><TD HEIGHT="11" WIDTH="100%"><FONT FACE="Arial, Helvetica, sans-serif" SIZE="1">Books24x7.com, Inc © 2000&nbsp;–&nbsp;&nbsp;<A HREF="feedback.html+fb=1&bkid=232&chnkid=47.html"  BORDER="0"><FONT COLOR="#333333">Feedback</FONT></A></FONT></TD></TR></TABLE>

</BODY>
</HTML>
