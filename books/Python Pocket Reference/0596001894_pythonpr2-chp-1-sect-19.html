<html><head>
<META http-equiv="Content-Type" content="text/html">
<!--SafClassName="docSection1Title"--><!--SafTocEntry="1.19 The re Pattern-Matching Module"-->
<link rel="STYLESHEET" type="text/css" href="FILES/style.css">
<link rel="STYLESHEET" type="text/css" href="FILES/docsafari.css">
</head>
<body>
<table width="100%" border="0" cellspacing="0" cellpadding="0" bgcolor="#CCCCCC">
<td><font color="black" size=1>I l<font color="#FF0000">@</font>ve RuBoard</td>
<td valign="top" class="v2" align="right">
	<a href="0596001894_pythonpr2-CHP-1-SECT-18.html"><img src="FILES/previous.gif" width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a>
	<a href="0596001894_pythonpr2-CHP-1-SECT-20.html"><img src="FILES/next.gif" width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a>
</td></table>
<br>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<tr>
<td valign="top"><A NAME="pythonpr2-CHP-1-SECT-19"></A>
<H3 class="docSection1Title">1.19 The re Pattern-Matching Module</H3>

<P class="docText">The <TT>re</TT> module is the standard regular
expression-matching interface (new in 1.5). Regular expression (RE)
patterns are specified as strings. This module must be
imported.<sup class="docFootnote"><A class="docLink" HREF="#">[23]</A></sup>
</P>
<blockquote><p class="docFootnote"><sup><A NAME="">[23]</A></sup> A section on the prior
<TT>regex</TT> module has been removed from the book;
<TT>regex</TT> is now considered deprecated, and all new
development should use the <TT>re</TT> module documented
here for pattern matching.</p></blockquote>

<A NAME="pythonpr2-CHP-1-SECT-19.1"></A>
<H4 class="docSection2Title">1.19.1 Module Functions</H4>

<DL class="docList">
<DT><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">compile(pattern [, flags])</span></span></span></DT>
<DD>
<P class="docList">Compile an RE <TT>pattern</TT> string into a regular
expression object, for later matching. <TT>flags</TT>
(combinable by bitwise | operator):
</P>

<DL class="docList">
<DT><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">I</span></span> or <span class="docPubcolor"><span class="docMonofont">IGNORECASE</span></span> or <span class="docPubcolor"><span class="docMonofont">(?i)</span></span></span></DT>
<DD>
<P class="docList">Case-insensitive matching.</P>
</DD>
<DT><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">L</span></span> or <span class="docPubcolor"><span class="docMonofont">LOCALE</span></span> or <span class="docPubcolor"><span class="docMonofont">(?L)</span></span></span></DT>
<DD>
<P class="docList">Makes <TT>\w</TT>, <TT>\W</TT>,
<TT>\b</TT>, <TT>\B</TT>, <TT>\s</TT>,
<TT>\S</TT>, <TT>\d</TT>, and
<TT>\D</TT> dependent on the current 8-bit locale (default
is 7-bit U.S. ASCII).
</P>
</DD>
<DT><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">M</span></span> or <span class="docPubcolor"><span class="docMonofont">MULTILINE</span></span> or <span class="docPubcolor"><span class="docMonofont">(?m)</span></span></span></DT>
<DD>
<P class="docList">Matches to each new line, not whole string.</P>
</DD>
<DT><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">S</span></span> or <span class="docPubcolor"><span class="docMonofont">DOTALL</span></span> or <span class="docPubcolor"><span class="docMonofont">(?s)</span></span></span></DT>
<DD>
<P class="docList">"." matches <span class="docEmphasis">all</span> characters,
including newline.
</P>
</DD>
<DT><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">U</span></span> or <span class="docPubcolor"><span class="docMonofont">UNICODE</span></span> or <span class="docPubcolor"><span class="docMonofont">(?u)</span></span></span></DT>
<DD>
<P class="docList">Makes <TT>\w</TT>, <TT>\W</TT>,
<TT>\b</TT>, <TT>\B</TT>, <TT>\s</TT>,
<TT>\S</TT>, <TT>\d</TT>, and
<TT>\D</TT> dependent on Unicode character properties (new
in 2.0).
</P>
</DD>
<DT><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">X</span></span> or <span class="docPubcolor"><span class="docMonofont">VERBOSE</span></span> or <span class="docPubcolor"><span class="docMonofont">(?x)</span></span></span></DT>
<DD>
<P class="docList">Ignore whitespace in the pattern, outside character sets.</P>
</DD>
</DL>

</DD>

<DT><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">match(pattern, string [, flags])</span></span></span></DT>
<DD>
<P class="docList">If zero or more characters at start of <TT>string</TT>
match the <TT>pattern</TT> string, returns a corresponding
MatchObject instance, or <TT>None</TT> if no match.
<TT>flags</TT> as in <TT>compile</TT>.
</P>
</DD>
<DT><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">search(pattern, string [, flags])</span></span></span></DT>
<DD>
<P class="docList">Scans through <TT>string</TT> for a location matching
<TT>pattern</TT>; returns a corresponding MatchObject
instance, or <TT>None</TT> if no match.
<TT>flags</TT> as in <TT>compile</TT>.
</P>
</DD>
<DT><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">split(pattern, string [, maxsplit=0])</span></span></span></DT>
<DD>
<P class="docList">Splits <TT>string</TT> by occurrences of
<TT>pattern</TT>. If capturing <TT>( )</TT> are
used in <TT>pattern</TT>, occurrences of patterns or
subpatterns are also returned.
</P>
</DD>
<DT><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">sub(pattern, repl, string [, count=0])</span></span></span></DT>
<DD>
<P class="docList">Returns string obtained by replacing the (first count) leftmost
nonoverlapping occurrences of <TT>pattern</TT> (a string or
an RE object) in <TT>string</TT> by
<TT>repl</TT>. <TT>repl</TT> can be a string or a
function called with a single MatchObject argument, which must return
the replacement string. <TT>repl</TT> may also include
sequence escapes <TT>\1</TT>, <TT>\2</TT>, etc.
to use substrings that matched groups, or <TT>\0</TT> for
all.
</P>
</DD>
<DT><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">subn(pattern, repl, string [, count=0])</span></span></span></DT>
<DD>
<P class="docList">Same as <TT>sub</TT>, but returns a tuple:
<TT>(new-string,</TT>
<TT>number-of-subs-made)</TT>.
</P>
</DD>
<DT><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">findall(pattern, string)</span></span></span></DT>
<DD>
<P class="docList">Returns a list of strings giving all nonoverlapping matches of
<TT>pattern</TT> in <TT>string</TT>. If one or
more groups are present in the pattern, returns a list of groups. New
in 1.5.2.
</P>
</DD>
<DT><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">escape(string)</span></span></span></DT>
<DD>
<P class="docList">Returns <TT>string</TT> with all nonalphanumerics
backslashed, such that it can be compiled as a string literal.
</P>
</DD>
</DL>


<A NAME="pythonpr2-CHP-1-SECT-19.2"></A>
<H4 class="docSection2Title">1.19.2 Regular Expression Objects</H4>

<P class="docText">RE objects are returned by the <TT>re.compile</TT> function
and have the following attributes:<sup class="docFootnote"><A class="docLink" HREF="#">[24]</A></sup>
</P>
<blockquote><p class="docFootnote"><sup><A NAME="">[24]</A></sup> In 1.6 and later,
pattern and match objects are internal types, not PatternObject or
MatchObject instances.</p></blockquote>

<DL class="docList">
<DT><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">flags</span></span></span></DT>
<DD>
<P class="docList">The <TT>flags</TT> argument used when the RE object was
compiled.
</P>
</DD>
<DT><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">groupindex</span></span></span></DT>
<DD>
<P class="docList">Dictionary of <TT>{group-name:</TT>
<TT>group-number}</TT> in the pattern.
</P>
</DD>
<DT><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">pattern</span></span></span></DT>
<DD>
<P class="docList">The pattern string from which the RE object was compiled.</P>
</DD>
<DT><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">match(string [, pos [, endpos]])</span></span></span></DT><DT><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">search(string [, pos [, endpos]])</span></span></span></DT><DT><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">split(string [, maxsplit=0])</span></span></span></DT><DT><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">sub(repl, string [, count=0])</span></span></span></DT><DT><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">subn(repl, string [, count=0])</span></span></span></DT><DT><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">findall( string)</span></span></span></DT>
<DD>
<P class="docList">Same as earlier <TT>re</TT> module functions, but
<TT>pattern</TT> is implied, and <TT>pos</TT> and
<TT>endpos</TT> give start/end string indexes for the
match.
</P>
</DD>
</DL>


<A NAME="pythonpr2-CHP-1-SECT-19.3"></A>
<H4 class="docSection2Title">1.19.3 Match Objects</H4>

<P class="docText">Match objects are returned by successful <TT>match</TT> and
<TT>search</TT> operations, and have the following
attributes. See the Python Library Reference for additional
attributes omitted here.
</P>

<DL class="docList">
<DT><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">pos, endpos</span></span></span></DT>
<DD>
<P class="docList">Values of <TT>pos</TT> and <TT>endpos</TT> passed
to <TT>search</TT> or <TT>match</TT>.
</P>
</DD>
<DT><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">re</span></span></span></DT>
<DD>
<P class="docList">RE object whose <TT>match</TT> or <TT>search</TT>
produced this.
</P>
</DD>
<DT><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">string</span></span></span></DT>
<DD>
<P class="docList">String passed to <TT>match</TT> or
<TT>search</TT>.
</P>
</DD>
<DT><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">group([g1, g2,...])</span></span></span></DT>
<DD>
<P class="docList">Returns substrings that were matched by parenthesized groups in the
pattern. Accepts zero or more group numbers. If one argument, result
is the substring that matched the group whose number is passed. If
multiple arguments, result is a tuple with one matched substring per
argument. If no arguments, returns entire matching substring. If any
group number is 0, return value is entire matching string; else,
returns string matching corresponding parenthesized group number in
pattern (1...N, from left to right). Group number arguments may also
be group names.
</P>
</DD>
<DT><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">groups(  )</span></span></span></DT>
<DD>
<P class="docList">Returns a tuple of all groups of the match; groups not participating
in the match have a value of <TT>None</TT>.
</P>
</DD>
<DT><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">start([group]), end([group])</span></span></span></DT>
<DD>
<P class="docList">Indices of start and end of substring matched by
<TT>group</TT> (or entire matched string, if no
<TT>group</TT>). If match object <TT>M</TT>,
<TT>M.string[M.start(g):M.end(g)]==M.group(g)</TT>.
</P>
</DD>
<DT><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">span([group])</span></span></span></DT>
<DD>
<P class="docList">Returns the tuple <TT>(start(group),</TT>
<TT>end(group))</TT>.
</P>
</DD>
<DT><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">expand(template)</span></span></span></DT>
<DD>
<P class="docList">Returns the string obtained by doing backslash substitution on the
template string <TT>template</TT>, as done by the
<TT>sub</TT> method. Escapes such as <TT>\n</TT>
are converted to the appropriate characters, and numeric
backreferences (<TT>\1</TT>, <TT>\2</TT>) and
named backreferences (<TT>\g&lt;1&gt;</TT>,
<TT>\g&lt;name&gt;</TT>) are replaced by the corresponding
group.
</P>
</DD>
</DL>


<A NAME="pythonpr2-CHP-1-SECT-19.4"></A>
<H4 class="docSection2Title">1.19.4 Pattern Syntax</H4>

<P class="docText">Pattern strings are specified by concatenating forms (see <A class="docLink" HREF="#pythonpr2-CHP-1-TABLE-18">Table 1-18</A>) as well as by character class escapes (see
<A class="docLink" HREF="#pythonpr2-CHP-1-TABLE-19">Table 1-19</A>). Python character escapes (e.g.,
<TT>\t</TT> for tab) may also appear. Pattern strings are
matched against text strings, yielding a Boolean match result, as
well as grouped substrings matched by subpatterns in parentheses.
</P>

<A NAME="pythonpr2-CHP-1-SECT-19.4.1"></A>
<H5 class="docSection3Title">1.19.4.1 Example</H5>

<PRE>&gt;&gt;&gt; import re
&gt;&gt;&gt; patt = re.compile('hello[ \t]*(.*)')
&gt;&gt;&gt; mobj = patt.match('hello  world!')
&gt;&gt;&gt; mobj.group(1)
'world!'</PRE>

<P class="docText">In <A class="docLink" HREF="#pythonpr2-CHP-1-TABLE-18">Table 1-18</A>, "C" is any character,
"R" is any regular expression form in the left column of
the table, and "m" and "n" are integers. Each
form usually consumes as much of the string being matched as
possible, except for the nongreedy forms (which consume as little as
possible, as long as the entire pattern still matches the target
string).
</P>

<A NAME="pythonpr2-CHP-1-TABLE-18"></A><P><TABLE BORDER="1" CELLSPACING="0" CELLPADDING="1" WIDTH="100%">
<CAPTION><h5 class="docTableTitle">Table 1-18. Regular expression pattern syntax </h5></CAPTION><COLGROUP span="2">
<TR>
<TH class="docTableHeader">
<P class="docText">Form</P>
</TH>
<TH class="docTableHeader">
<P class="docText">Description</P>
</TH>
</TR>
<TR>
<TD class="docTableCell">
<PRE>.</PRE>
</TD>
<TD class="docTableCell">
<P class="docText">Matches any character (including newline if <TT>DOTALL</TT>
flag is specified).
</P>
</TD>
</TR>
<TR>
<TD class="docTableCell">
<PRE>^</PRE>
</TD>
<TD class="docTableCell">
<P class="docText">Matches start of string (of every line in
<TT>MULTILINE</TT> mode).
</P>
</TD>
</TR>
<TR>
<TD class="docTableCell">
<PRE>$</PRE>
</TD>
<TD class="docTableCell">
<P class="docText">Matches end of string (of every line in <TT>MULTILINE</TT>
mode).
</P>
</TD>
</TR>
<TR>
<TD class="docTableCell">
<PRE>C</PRE>
</TD>
<TD class="docTableCell">
<P class="docText">Any nonspecial character matches itself.</P>
</TD>
</TR>
<TR>
<TD class="docTableCell">
<PRE>R*</PRE>
</TD>
<TD class="docTableCell">
<P class="docText">Zero or more occurrences of preceding regular expression
<TT>R</TT> (as many as possible).
</P>
</TD>
</TR>
<TR>
<TD class="docTableCell">
<PRE>R+</PRE>
</TD>
<TD class="docTableCell">
<P class="docText">One or more occurrences of preceding regular expression
<TT>R</TT> (as many as possible).
</P>
</TD>
</TR>
<TR>
<TD class="docTableCell">
<PRE>R?</PRE>
</TD>
<TD class="docTableCell">
<P class="docText">Zero or one occurrence of preceding regular expression
<TT>R</TT>.
</P>
</TD>
</TR>
<TR>
<TD class="docTableCell">
<PRE>R{m,n}</PRE>
</TD>
<TD class="docTableCell">
<P class="docText">Matches from <TT>m</TT> to <TT>n</TT> repetitions
of preceding regular expression <TT>R</TT>.
</P>
</TD>
</TR>
<TR>
<TD class="docTableCell">
<PRE>R*?, R+?, R??, R{m,n}?</PRE>
</TD>
<TD class="docTableCell">
<P class="docText">Same as <TT>*</TT>, <TT>+</TT>, and
<TT>?</TT> but matches as few characters/times as possible;
<span class="docEmphasis">nongreedy</span>.
</P>
</TD>
</TR>
<TR>
<TD class="docTableCell">
<PRE>[...]</PRE>
</TD>
<TD class="docTableCell">
<P class="docText">Defines character set; e.g., <TT>[a-zA-Z]</TT> matches all
letters (also see <A class="docLink" HREF="#pythonpr2-CHP-1-TABLE-19">Table 1-19</A>).
</P>
</TD>
</TR>
<TR>
<TD class="docTableCell">
<PRE>[^...]</PRE>
</TD>
<TD class="docTableCell">
<P class="docText">Defines complemented character set: matches if character is not in
set.
</P>
</TD>
</TR>
<TR>
<TD class="docTableCell">
<PRE>\</PRE>
</TD>
<TD class="docTableCell">
<P class="docText">Escapes special characters (e.g., <TT>*?+|( )</TT>) and
introduces special sequences (see <A class="docLink" HREF="#pythonpr2-CHP-1-TABLE-19">Table 1-19</A>). Due
to Python rules, write as <TT>\\</TT> or
<TT>r'\\'</TT>.
</P>
</TD>
</TR>
<TR>
<TD class="docTableCell">
<PRE>\\</PRE>
</TD>
<TD class="docTableCell">
<P class="docText">Matches a literal <TT>\</TT>; due to Python string rules,
write as <TT>\\\\</TT> in pattern, or
<TT>r'\\'</TT>.
</P>
</TD>
</TR>
<TR>
<TD class="docTableCell">
<PRE>R|R</PRE>
</TD>
<TD class="docTableCell">
<P class="docText">Alternative: matches left or right <TT>R</TT>.</P>
</TD>
</TR>
<TR>
<TD class="docTableCell">
<PRE>RR</PRE>
</TD>
<TD class="docTableCell">
<P class="docText">Concatenation: matches both <TT>R</TT>s.</P>
</TD>
</TR>
<TR>
<TD class="docTableCell">
<PRE>(R)</PRE>
</TD>
<TD class="docTableCell">
<P class="docText">Matches any RE inside ( ), and delimits a group (retains matched
substring).
</P>
</TD>
</TR>
<TR>
<TD class="docTableCell">
<PRE>(?: R)</PRE>
</TD>
<TD class="docTableCell">
<P class="docText">Same as <TT>(R)</TT> but doesn't delimit a group.</P>
</TD>
</TR>
<TR>
<TD class="docTableCell">
<PRE>(?= R)</PRE>
</TD>
<TD class="docTableCell">
<P class="docText">Look-ahead assertion: matches if <TT>R</TT> matches next,
but doesn't consume any of the string (e.g.,
<TT>X</TT> <TT>(?=Y</TT>) matches
<TT>X</TT> if followed by <TT>Y</TT>.
</P>
</TD>
</TR>
<TR>
<TD class="docTableCell">
<PRE>(?! R)</PRE>
</TD>
<TD class="docTableCell">
<P class="docText">Negative look-ahead assertion: matches if <TT>R</TT>
doesn't match next. Negative of <TT>(?=R)</TT>.
</P>
</TD>
</TR>
<TR>
<TD class="docTableCell">
<PRE>(?P&lt;name&gt; R)</PRE>
</TD>
<TD class="docTableCell">
<P class="docText">Matches any RE inside ( ) and delimits a named group (e.g.,
<TT>r'(?P&lt;id&gt;[a-zA-Z_]\</TT> <TT>w*)'</TT>
defines a group named <TT>id</TT>).
</P>
</TD>
</TR>
<TR>
<TD class="docTableCell">
<PRE>(?P=name)</PRE>
</TD>
<TD class="docTableCell">
<P class="docText">Matches whatever text was matched by the earlier group named
<TT>name</TT>.
</P>
</TD>
</TR>
<TR>
<TD class="docTableCell">
<PRE>(?&lt;= R)</PRE>
</TD>
<TD class="docTableCell">
<P class="docText">Positive look-behind assertion: matches if preceded by a match of
fixed-width <TT>R</TT>.
</P>
</TD>
</TR>
<TR>
<TD class="docTableCell">
<PRE>(?&lt;! R)</PRE>
</TD>
<TD class="docTableCell">
<P class="docText">Negative look-behind assertion: matches if not preceded by a match of
fixed-width <TT>R</TT>.
</P>
</TD>
</TR>
<TR>
<TD class="docTableCell">
<PRE>(?#...)</PRE>
</TD>
<TD class="docTableCell">
<P class="docText"> A comment; ignored.</P>
</TD>
</TR>
<TR>
<TD class="docTableCell">
<PRE>(?letter)</PRE>
</TD>
<TD class="docTableCell">
<P class="docText"><TT>letter</TT> is one of "i", "L",
"m", "s", "x", or
"u". Set flag (<TT>re.I</TT>,
<TT>re.L</TT>, etc.) for entire RE.
</P>
</TD>
</TR>
</COLGROUP>
</TABLE></P>

<P class="docText">In <A class="docLink" HREF="#pythonpr2-CHP-1-TABLE-19">Table 1-19</A>, <TT>\b</TT>,
<TT>\B</TT>, <TT>\d</TT>, <TT>\D</TT>,
<TT>\s</TT>, <TT>\S</TT>, <TT>\w</TT>,
and <TT>\W</TT> behave differently depending on flags: if
<TT>LOCALE</TT> (<TT>?L</TT>) is used, they
depend on the current 8-bit locale; if <TT>UNICODE</TT>
(<TT>?u</TT>) is used, they depend on the Unicode character
properties; if neither flag is used, they assume 7-bit U.S. ASCII.
Tip: use raw strings (<TT>r'\n'</TT>) to literalize
backslashes in <A class="docLink" HREF="#pythonpr2-CHP-1-TABLE-19">Table 1-19</A> class escapes.
</P>

<A NAME="pythonpr2-CHP-1-TABLE-19"></A><P><TABLE BORDER="1" CELLSPACING="0" CELLPADDING="1" WIDTH="100%">
<CAPTION><h5 class="docTableTitle">Table 1-19. Regular expression pattern special sequences </h5></CAPTION><COLGROUP span="2">
<TR>
<TH class="docTableHeader">
<P class="docText">Sequence</P>
</TH>
<TH class="docTableHeader">
<P class="docText">Description</P>
</TH>
</TR>
<TR>
<TD class="docTableCell">
<PRE>\num</PRE>
</TD>
<TD class="docTableCell">
<P class="docText">Matches text of the group <TT><I>num</I></TT> (numbered
from 1)
</P>
</TD>
</TR>
<TR>
<TD class="docTableCell">
<PRE>\A</PRE>
</TD>
<TD class="docTableCell">
<P class="docText">Matches only at the start of the string</P>
</TD>
</TR>
<TR>
<TD class="docTableCell">
<PRE>\b</PRE>
</TD>
<TD class="docTableCell">
<P class="docText">Empty string at word boundaries</P>
</TD>
</TR>
<TR>
<TD class="docTableCell">
<PRE>\B</PRE>
</TD>
<TD class="docTableCell">
<P class="docText">Empty string not at word boundary</P>
</TD>
</TR>
<TR>
<TD class="docTableCell">
<PRE>\d</PRE>
</TD>
<TD class="docTableCell">
<P class="docText">Any decimal digit (like <TT>[0-9]</TT>)</P>
</TD>
</TR>
<TR>
<TD class="docTableCell">
<PRE>\D</PRE>
</TD>
<TD class="docTableCell">
<P class="docText">Any non-decimal digit character (like <TT>[^0-9]</TT>)</P>
</TD>
</TR>
<TR>
<TD class="docTableCell">
<PRE>\s</PRE>
</TD>
<TD class="docTableCell">
<P class="docText">Any whitespace character (like <TT>[</TT>
<TT>\t\n\r\f\v]</TT>)
</P>
</TD>
</TR>
<TR>
<TD class="docTableCell">
<PRE>\S</PRE>
</TD>
<TD class="docTableCell">
<P class="docText">Any non-whitespace character (like <TT>[^</TT>
<TT>\t\n\r\f\v]</TT>)
</P>
</TD>
</TR>
<TR>
<TD class="docTableCell">
<PRE>\w</PRE>
</TD>
<TD class="docTableCell">
<P class="docText">Any alphanumeric character</P>
</TD>
</TR>
<TR>
<TD class="docTableCell">
<PRE>\W</PRE>
</TD>
<TD class="docTableCell">
<P class="docText">Any non-alphanumeric character</P>
</TD>
</TR>
<TR>
<TD class="docTableCell">
<PRE>\Z</PRE>
</TD>
<TD class="docTableCell">
<P class="docText">Matches only at the end of the string</P>
</TD>
</TR>
</COLGROUP>
</TABLE></P>




<ul></ul>
</td>
</tr>
</table>
<td></td>
<table width="100%" border="0" cellspacing="0" cellpadding="0" bgcolor="#CCCCCC">
<td><font color="black" size=1>I l<font color="#FF0000">@</font>ve RuBoard</td>
<td valign="top" class="v2" align="right">
          <a href="0596001894_pythonpr2-CHP-1-SECT-18.html"><img src="FILES/previous.gif" width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a>
          <a href="0596001894_pythonpr2-CHP-1-SECT-20.html"><img src="FILES/next.gif" width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a>
</td></table>
</body></html>
