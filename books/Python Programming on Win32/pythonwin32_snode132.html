<HTML><HEAD><META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=iso-8859-1">
<!--SafClassName="docSection1Title"--><!--SafTocEntry="17.1 Portable File Manipulation"-->
<LINK REL="stylesheet" href="FILES/sbolM.css">
</HEAD>
<BODY link="#354278" vlink="#000066" alink="#000080" topmargin="0">
<table width="100%" border="0" cellspacing="0" cellpadding="0" bgcolor="#CCCCCC">
<td><font color="black" size=1>I l<font color="#FF0000">@</font>ve RuBoard</td>
<td valign="top" class="v2" align="right"><a href="pythonwin32_cnode130.html"><img src="FILES/previous.gif" width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a> <a href="pythonwin32_snode133.html"><img src="FILES/next.gif" width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a></td></table>
<FONT>
<h3>17.1
Portable File Manipulation</h3>


<p>
<a NAME="idx1648"></a>Python has excellent built-in file
support that works on all platforms supported by Python.</p>




<h4>17.1.1
Working with Files on Disk</h4>


<P>
<A NAme="idx1649"></a>Most of the key file-manipulation
functions live in the <tT CLAss="monofont">os</tt>
<a name="idx1650"></a> module and an associated module called
<tt class="monofont">os.path</tt>
<a nAME="idx1651"></A>. To provide a degree of platform
independence, <TT cLAsS="monofont">os</Tt> loads in the right module for
your platform. <TT CLASs="monofont">os</tt> provides basic file-handling
functions, and <tT CLAss="monofont">os.path</tt> handles operations on paths
and filenames. On Windows, these modules are called
<TT CLass="monofont">nt</tT>
<A NAme="idx1652"></a>
<a name="idx1653"></a> and
<tt class="monofont">ntpath</tt> respectively, although they should always
be referred to as <tt cLASS="monofont">os</TT> and
<tT ClASs="monofont">os.path</TT>. The functions in the
<TT CLass="monofont">os</tT> module generally accept the same arguments as
their corresponding MS-DOS commands. <A href="pythonwin32_snode132.html#4">Table 17.1</a>
depicts the <tT CLAss="monofont">os</tt> module's file and directory
functions.</P>



<A NAme="4"></a><p><table border="1" cellspACING="0" CeLLpADdING="1" WIDth="100%">
<caPTIOn><h5>Table 17.1. File and Directory Functions</h5></cAPTIon><coLGROup span="2">
<tr>
<th>
<font size="2">
<p><b>Module and Function</b></P>
</FONT></Th>
<TH>
<fONt SIZE="2">
<P>Description</P>
</font></TH>
</TR>
<tr>
<td>
<FONT size="2">
<PRE Class="monofont">os.getcwd()</pre></font></td>
<td>
<font siZE="2">
<P>Gets the current working directory.</P>
</FOnT></Td>
</TR>
<tR>
<TD>
<FONt sizE="2">
<PRE clasS="monofont">
os.chdir(<TT Class="monofont"><I>newdir</I></TT>)</pre></font></td>
<td>
<font size="2">
<p>Changes the current working directory.</p>
</FONT></TD>
</tR>
<Tr>
<TD>
<fONT SIZe="2">
<pre CLASs="monofont">os.rmdir(<tt cLASS="monofont"><i>dir</i></tt>)</PRE></Font></td>
<td>
<font size="2">
<p>Removes a directory, if allowed.</p>
</font></TD>
</TR>
<TR>
<tD>
<FoNT sIZE="2">
<PRE clasS="monofont">os.mkdir(<TT Class="monofont"><I>newdir</I></TT>)</pre></fONT></Td>
<td>
<font size="2">
<p>Creates a directory, supplies either an absolute path or a
subdirectory name to go under the current directory.</p>
</font></td>
</tr>
<TR>
<TD>
<FOnT SiZE="2">
<pRE CLASs="monofont">os.exists(<tt cLASS="monofont"><i>name</i></tt>)</PRE></Font></tD>
<TD>
<Font size="2">
<p>Says if something exists, but doesn't say if it's a file
or directory.</p>
</font></td>
</tr>
<tr>
<td>
<FONT SIzE="2">
<PrE ClASS="monofont">os.isdir(<TT Class="monofont"><I>dirname</I></TT>)</pre></fONT></Td>
<td>
<fONT Size="2">
<p>Says that a directory exists.</p>
</font></td>
</tr>
<tr>
<td>
<font SIZE="2">
<PRe CLaSS="monofont">os.isfile(<tT CLASS="monofont"><i>filename</i></tt>)</PRE></Font></tD>
<TD>
<Font sIZE="2">
<P>Says that a file exists. <tt class="monofont"><i>filename</i></tt> may
include a path; if not, it looks in the current directory.</p>
</font></td>
</tr>
<tR>
<TD>
<FONt SIzE="2">
<PrE CLASS="monofont">os.listdir(<tt clASS="monofont"><I>dirname</i></tt>)</pRE></FOnt></td>
<TD>
<FOnt size="2">
<p>Returns a list of the files and directories within the given
directory.</p>
</font></td>
</tr>
<tr>
<td>
<fONT SIZe="2">
<PRe CLaSS="monofont">glob.glob(<TT CLass="monofont"><i>pattern</I></TT>)</Pre></foNT></TD>
<td>
<foNT SIze="2">
<p>Returns a list of files matching the given pattern (using expressions
such as <tt class="monofont">dir</tt> <tt class="monofont">*.doc</tt> is known as
<I>file</I> <I>globbing</I> on Unix,
hence the name). Just like the command prompt and most other Windows
tools, the pattern accepts the ? character to match a single
character or the * character to match any number of characters. If
you need to use true regular expressions <FOnT SiZE="1"><sUP><A HREf="#FOOTNOTE-1">[1]</a></suP></FONt>
 to
match filenames, use <tt cLASS="monofont">os.listdir()</tt> and the
<tt CLASs="monofont">re</tt> module.</p>
</font></td>
</tr>
</colgroup>
</tABLE></P>


<BlOCkQUoTE><FONT size="1">
<P CLAss="footnote">
<suP><A NAme="FOOTNOTE-1">[1]</a></sUP>
A regular
expression uses patterns to match strings. The filename-matching
capabilities described are similar in concept to regular expressions,
although the regular expressions provided by the Python
<TT class="monofont">re</tt> module provide a syntax similar to Perl and
offer far more matching capabilities than the simple
filename-matching patterns described here.</p>
</font></blockquotE>





<P>Here are some quick examples:</P>



<PRE cLAsS="monofont">&gt;&gt;&gt; import os
&gt;&gt;&gt; os.getcwd()
'C:\\Program Files\\Python'
&gt;&gt;&gt; os.chdir('C:\\temp')
&gt;&gt;&gt; os.mkdir('subdirectory1')
&gt;&gt;&gt; os.rmdir('subdirectory1')
&gt;&gt;&gt;</PrE>


<P>What's with the <TT CLass="monofont">\\</tT>? This is Python's
<A NAme="idx1656"></a> <a NAME="idx1657"></a>literal string syntax. Python
lets you directly enter special characters at the interactive prompt
or in strings embedded in your code. For example,
<tt cLASS="monofont">\n</tt> means a newline, <tt class="monofont">\t</tt> is a
tab, and <tt class="monofont">\123</tt> is the octal number 123. If you just
want a plain old slash, you have to type <tT CLASS="monofont">\\</tT>. The
only place where this feels slightly weird is in manipulating
filenames. Remember to double all your slashes. An alternative is to
use a forward slash (like <I>c:/temp</i>); but Python
always gives backslashes when you ask for directory lists on Windows:</P>



<PrE CLASS="monofont">&gt;&gt;&gt; mydir = 'c:\\data\\project\\oreilly\\text'
&gt;&gt;&gt; os.path.exists(mydir)
1
&gt;&gt;&gt; os.path.isdir(mydir)
1
&gt;&gt;&gt; os.path.isfile(mydir)   #hope not
0
&gt;&gt;&gt; os.listdir(mydir)
['ChapterXX.doc', '00index.txt', ...]

&gt;&gt;&gt; import glob
&gt;&gt;&gt; glob.glob(mydir + '\\' + '*files*.doc')
['c:\\data\\project\\oreilly\\text\\Chapter_-_Processes_and_Files1.doc', 'c:\\
data\\project\\oreilly\\text\\files.doc', 'c:\\data\\project\\oreilly\\text\\
Chapter_-_PythonFiles.doc']
&gt;&gt;&gt;</pre>


<p>Note that if you don't want full paths from
<TT CLass="monofont">glob</tT>, <TT Class="monofont">chdir</TT> into the directory
first.</P>




<H5>17.1.1.1
Working with paths and filenames</h5>


<p>The <tt class="monofont">os.path</tt>
<a name="idx1658"></a>
<a namE="idx1659"></A> module provides
platform-independent routines for chopping up and putting together
filenames.
<TT CLaSS="monofont">os.path.split(path)</tT>
<A nAME="idx1660"></A>
<A Name="idx1661"></a> separates a full path
into the directory and filename components;
<TT CLass="monofont">os.path.splitext(filename)</tT> separates the filename
(and path, if present) from the extension.</P>



<P>As discussed, DOS and Windows use a backslash to separate
directories. We shouldn't have used the line
<Tt claSS="monofont">glob.glob(mydir</TT> <tt class="monofont">+</tt>
<tt class="monofont">'\\'</tt> <tt cLASS="monofont">+</TT>
<tT ClASs="monofont">'*files*.doc')</TT> in the previous example; use the
variable <TT CLass="monofont">os.sep</tT> instead. On a Unix platform, this
is a forward slash:</P>



<PRe claSS="monofont">&gt;&gt;&gt; os.path.split('c:\\windows\\system\\gdi.exe')
('c:\\windows\\system', 'gdi.exe')
&gt;&gt;&gt; os.path.splitext('gdi.exe')
('gdi', '.exe')
&gt;&gt;&gt; os.path.splitext('c:\\windows\\system\\gdi.exe')
('c:\\windows\\system\\gdi', '.exe')
&gt;&gt;&gt; (root, ext) = os.path.splitext('c:\\mydata\\myfile.txt')
&gt;&gt;&gt; newname = root + '.out'
&gt;&gt;&gt; newname
'c:\\mydata\\myfile.out'
&gt;&gt;&gt;</PRe>





<h5>17.1.1.2
Names for temporary files</h5>


<p>The function
<TT CLass="monofont">tempfile.mktemp()</tt>
<a name="idx1662"></a> <a name="idx1663"></a> returns a
filename suitable for temporary use; this function is available on
every platform, but it's smart enough to know where your
<i>\temp</i> directory is on Windows:</p>



<pRE CLASs="monofont">&gt;&gt;&gt; import tempfile
&gt;&gt;&gt; tempfile.mktemp()
'C:\\WINDOWS\\TEMP\\~-304621-1'
&gt;&gt;&gt;</PRe>


<P>When the file is closed, it's automatically deleted, assisting
in the housekeeping that often goes with working with temporary
files.</P>






<h5>17.1.1.3
Getting information about files</H5>


<P>The function <TT CLass="monofont">os.stat(</tT>
<A NAme="idx1664"></a>
<a NAME="idx1665"></a>
<a naME="idx1666"></A><Tt class="monofont"><i>filename</i></tt><tt class="monofont">)</tt>
returns information about files or directories without opening them.
It returns a tuple of ten items. With a tuple of this size, it can be
hard to recall what each element is for, so the standard Python
module <tt CLASS="monofont">stat</Tt> contains a number of constants and
functions to assist in working with these entries. <A href="pythonwin32_snode132.html#8">Table 17.2</a> lists the entries returned by
<TT CLASs="monofont">os.stat()</tt>.</p>



<A NAMe="8"></a><p><tABLE bordER="1" CEllspacing="0" cellpadding="1" wIDTH="100%">
<CApTIoN><H5>Table 17.2. os.stat() Return Values</h5></CAPTIOn><colGROUp spaN="3">
<TR>
<Th>
<fonT SIZe="2">
<p>Index</p>
</font></th>
<th>
<font size="2">
<p>Constant</p>
</FONT></TH>
<tH>
<FoNT sIZE="2">
<P>Description</P>
</Font></tH>
</TR>
<Tr>
<td>
<fONT Size="2">
<p>0</P>
</FONt></td>
<td>
<font size="2">
<p><tt class="monofont">stat.ST_MODE</TT></P>
</FONt></TD>
<tD>
<FoNT SIZE="2">
<p>Bit mask for file-mode information. The
<tt cLASS="monofont">stat.S_IFDIR</tt> bit is set if <tt CLASs="monofont">path</tt>
specifies a directory; the <tT CLAss="monofont">stat.S_IFREG</tt> bit is set
if <tt class="monofont">path</tt> specifies an ordinary file or a device.</p>
</font></td>
</tR>
<TR>
<TD>
<FoNT sIZe="2">
<P>1</P>
</FONT></td>
<td>
<FONT size="2">
<P><TT Class="monofont">stat.ST_INO</TT></P>
</Font></td>
<td>
<font size="2">
<p>Not used on Windows filesystems.</p>
</font></TD>
</TR>
<TR>
<tD>
<FoNT sIZE="2">
<P>2</P>
</Font></tD>
<TD>
<Font sIZE="2">
<P><tt clASS="monofont">stat.ST_DEV</Tt></p>
</font></td>
<td>
<font size="2">
<p>Drive number of the disk containing the file.</p>
</fONT></TD>
</Tr>
<TR>
<tD>
<FoNT SIZE="2">
<p>3</p>
</foNT></TD>
<td>
<foNT SIze="2">
<p><tT CLAss="monofont">stat.ST_NLINK</tt></p>
</font></td>
<td>
<font size="2">
<P>The Visual C++ documentation is not very helpful on this one. It
simply states "Always 1 on non-NTFS filesystems."</P>
</FONT></tD>
</Tr>
<TR>
<tD>
<FONT Size="2">
<p>4</P>
</FONt></td>
<tD>
<FONt sizE="2">
<P><TT class="monofont">stat.ST_UID</tt></p>
</font></td>
<td>
<font sIZE="2">
<P>Not used on Windows.</P>
</FoNT></tD>
</Tr>
<TR>
<TD>
<FOnt siZE="2">
<P>5</P>
</font></TD>
<TD>
<font SIZE="2">
<p><tt class="monofont">stat.ST_GID</tt></p>
</font></td>
<td>
<foNT SIZE="2">
<p>Not used on Windows.</P>
</FoNT></tD>
</TR>
<TR>
<Td>
<fonT SIZe="2">
<p>6</p>
</fONT></Td>
<td>
<fONT Size="2">
<p><tt class="monofont">stat.ST_SIZE</tt></p>
</font></td>
<tD>
<FONT SiZE="2">
<p>Size of the file in bytes. This is limited to 64 bits, so for large
files you should use the <TT cLASS="monofont">win32file.GetFileSize()</TT>
function, which returns large file sizes as a long integer.</p>
</fonT></TD>
</Tr>
<tr>
<tD>
<FONt sizE="2">
<P>7</P>
</Font></td>
<td>
<font size="2">
<p><tt claSS="monofont">stat.ST_ATIME</TT></P>
</FoNT></tD>
<Td>
<FONT SIze="2">
<p>The time the file was last accessed or zero if the filesystem
doesn't support this information.</p>
</FONT></td>
</tr>
<TR>
<TD>
<font SIZE="2">
<p>8</p>
</font></td>
<td>
<font size="2">
<p><tt CLASS="monofont">stat.ST_MTIME</Tt></P>
</FoNT></tD>
<TD>
<FONt sizE="2">
<P>The time the file was last modified or zero if the filesystem
doesn't support this information.</P>
</Font></tD>
</TR>
<Tr>
<td>
<fONT Size="2">
<p>9</p>
</font></td>
<td>
<font size="2">
<P><TT CLAsS="monofont">stat.ST_CTIME</Tt></P>
</FoNT></TD>
<TD>
<font SIZE="2">
<p>The time the file was created or zero if the filesystem doesn't
support this information.</p>
</foNT></TD>
</tr>
</coLGROup>
</table></p>



<p>Some of these aren't used on Windows, but contain useful
information when used on other operating systems. Also, note that all
dates are returned as integers compatible with the Python
<tt class="monofont">time</tt> module. Depending on the format of the disk
holding the file, some of these time values may not be available.</p>



<p>Let's see an example of using the <tT CLASS="monofont">stat()</tT>
function:</P>



<pRE cLASS="monofont">&gt;&gt;&gt; os.stat('c:\\autoexec.bat')
(33279, 0, 2, 1, 0, 0, 640, 916444800, 915484932, 915484930)
&gt;&gt;&gt;</PRe>


<p>Here's a function to decode it:</p>



<pRE CLass="monofont">import os, stat, time

def getfileinfo(filename):
    stats = os.stat(filename)
    
    size = stats[stat.ST_SIZE]
    print 'File size is %d bytes' % size
    
    accessed = stats[stat.ST_ATIME]
    modified = stats[stat.ST_MTIME]
    
    print 'Last accessed: ' + time.ctime(accessed)
    print 'Last modified: ' + time.ctime(modified)</pRE>


<P>And the output:</P>



<pre cLASS="monofont">&gt;&gt;&gt; decode_stat.getfileinfo('c:\\autoexec.bat')
File size is 640 bytes
Last accessed: Sat Jan 16 00:00:00 1999
Last modified: Mon Jan 04 21:22:12 1999
&gt;&gt;&gt;</pre>


<p>Unfortunately, there's no portable Python module for working
with file permissions. Modules exist for working with permissions on
various operating systems, including Windows and Unix, but the
differences between the various schemes make a simple and unified
model difficult. Windows NT permissions are themselves complex and
beyond the scope of this book; indeed, it would require a book of
this size to cover them in detail. There is a brief example of
working with permissions in <a href="pythonwin32_cnode123.html">Chapter 16</a>.</p>






<h5>17.1.1.4
Walking through a directory tree</h5>


<p><tt class="monofont"></TT>
<A NAMe="idx1667"></A>Often you need to move through a
directory tree looking at all the subdirectories or files in turn.
The Python library provides a powerful generic routine to do this:
<Tt CLaSS="monofont">os.path.walk()</TT>
<A Name="idx1668"></a>.</P>



<P>The general idea is that you specify a directory, and
<TT clasS="monofont">os.path.walk()</TT> calls a function (that you write)
once for each subdirectory of the main directory. Each time your
function is called, it's passed a list of all filenames in that
directory. Thus, your function can examine every file in every
directory under the starting point you specify.</P>



<p>The function you write to perform the desired operation on the file
is of the form <tt cLASS="monofont">myfunc(arg,</tt>
<tt class="monofont">dirname,</tt> <tt class="monofont">filenames)</tt>. The first
argument can be anything you want; we will see examples later. The
second argument contains the name of the current directory being
examined, starting with the directory you specify in the argument to
<tT CLASS="monofont">os.path.walk()</tT>; the third is the list of filenames
in the directory.</P>



<p>Once you have written the function, call
<TT cLASS="monofont">os.path.walk()</TT> with three parameters: the name of
the directory in which to begin the walking, your callback function,
and any third parameter you choose. This third parameter is passed
unchanged in your callback function's first parameter, as
described previously.</p>



<p>This first example lists the directories examined and how many files
are present in each. This makes the callback function simple: you
print the <tt CLASs="monofont">dirname</tt> parameter, and the length of the
<tT CLAss="monofont">filenames</tt> parameter. Then call
<TT CLass="monofont">os.path.walk()</tt>, passing a directory from the
Python installation and the simple function as the callback:</p>



<pre class="monofont">&gt;&gt;&gt; def walker1(arg, dirname, filenames):
...     #List directories and numbers of files
...     print dirname,' contains', len(filenames), 'files'
...     
&gt;&gt;&gt; os.path.walk('c:\\program files\\python\\win32', walker1, None)
c:\program files\python\win32  contains 24 files
c:\program files\python\win32\lib  contains 39 files
c:\program files\python\win32\Help  contains 3 files
c:\program files\python\win32\demos  contains 19 files
c:\program files\python\win32\demos\service  contains 8 files
c:\program files\python\win32\demos\service\install  contains 3 files
&gt;&gt;&gt;</pre>


<p>That was easy! Note that you don't need the extra argument and
so use the value <tt cLASS="monofont">None</TT>. Now let's try
something a bit more practical and write a program to scan for
<a NAmE="idx1669"></A> <a NAME="idx1670"></A>
<A name="idx1671"></A>recent changes. This is useful
for archiving or for trying to figure out which new application just
ate your registry. The callback function becomes slightly more
complex as you loop over the list of files. The example then checks
the Windows system directory for all files changed in the last 30
days:</P>



<PRe claSS="monofont">&gt;&gt;&gt; import time
&gt;&gt;&gt; def walker2(arg, dirname, filenames):
...     "Lists files modified in last ARG days"
...     cutoff = time.time() - (arg * 24 * 60 * 60)
...     for filename in filenames:
...         stats = os.stat(dirname + os.sep + filename)	
...         modified = stats[8]
...         if modified &gt;= cutoff:
...             print dirname + os.sep + filename
... 
&gt;&gt;&gt; os.path.walk('c:\\windows\\system', walker2, 30)
c:\windows\system\FFASTLOG.TXT
c:\windows\system\MSISYS.VXD
c:\windows\system\HwInfoD.vxd
c:\windows\system\ws552689.ocx
&gt;&gt;&gt;</PRe>


<p>So far you haven't returned anything; indeed, if
<tt CLASs="monofont">walker2</tt><i> </i>returned a value,
you'd have no easy way to grab it. This is another common use
for the "extra argument." Let's imagine you want to
total the size of all files in a directory. It's tempting to
try this:</p>



<pre class="monofont">def walker3(arg, dirname, filenames):
    "Adds up total size of all files"
    for filename in filenames:
        stats = os.stat(dirname + os.sep + filename)
        size = stats[6]
        arg = arg + size

def compute_size(rootdir):
    "uses walker3 to compute the size"
    total = 0
    os.path.walk(rootdir, walker3, total)
    return total</pre>


<p>Here, a <tt cLASS="monofont">walker</TT> function does the work, and a
controlling function sets up the arguments and returns the results.
This is a common pattern when dealing with recursive functions.</p>



<P>Unfortunately this returns zero. You can't modify a simple
numeric argument in this way, since <Tt CLaSS="monofont">arg</TT><I>
</I>within the function <tt clASS="monofont">walker3()</Tt> is a
local variable. However, if <tt cLASS="monofont">arg</tt> was an object, you
could modify its properties. One of the simplest answers is to use a
list; it's passed around, and the <tt CLASs="monofont">walker</tt>
function is free to modify its contents. Let's rewrite the
function to generate a list of sizes:</p>



<pre class="monofont"># these two work...
def walker4(arg, dirname, filenames):
    "Adds up total size of all files"
    for filename in filenames:
        stats = os.stat(dirname + os.sep + filename)
        size = stats[6]
        arg.append(size)

def compute_size(rootdir):
    "uses walker3 to compute the size"
    sizes = []
    os.path.walk(rootdir, walker4, sizes)

    # now add them up
    total = 0
    for size in sizes:
        total = total + size
    return total</pre>


<p>When run, this code behaves as desired:</p>



<pre cLASS="monofont">&gt;&gt;&gt; compute_size('c:\\program files\\python')
26386305
&gt;&gt;&gt; # well, I do have a lot of extensions installed</PRe>


<P>There are numerous uses for this function, and it can save a lot of
lines of code. Some possibilities include:</P>



<uL>
<Li><P>Archiving all files older than a certain date</P>
</LI>
<LI><p>Building a list of filenames meeting certain criteria for further
processing</p>
</li>
<LI><P>Synchronizing two file trees efficiently across a network, copying
only the changes</P>
</li>
<li><P>Keeping an eye on users' storage requirements</P>
</LI>
</ul>
<p>We've started to see what makes Python so powerful for
manipulating filesystems. It's not just the
<tT CLAss="monofont">walk</tt> function: that could have been done in many
languages. The key point is how <tt class="monofont">walk</tt> interacts
with Python's higher-level data structures, such as lists, to
make these examples simple and<tt class="monofont"></tT>
<A NAME="idx1672"></a>
straightforward.<A NaME="idx1673"></a></P>








<H4>17.1.2
Working with Python File Objects</H4>


<P>
<A Name="idx1674"></a>Now
we've had a good look at moving files around; it's time
to look inside them.</P>



<P>Python has a built-in file object, which is available on all Python
platforms. Any Python program you hope to run on platforms other than
Windows should use the standard file objects. Once you have a Python
file object, you can use the methods to read data from the file,
write data to the file, and perform various other operations.</P>




<H5>17.1.2.1
Opening a file</h5>


<p>The function
<tt CLASs="monofont">open(</tt><tT CLAss="monofont"><i>filename</i></tt><tt class="monofont">,</tt>
<tt clasS="monofont">mode="r")</TT> returns a file object. If
<TT ClASs="monofont">mode</TT> is omitted, the file is opened read-only.
<tT CLASS="monofont">Mode</tt> is a string, and can be <tt CLASs="monofont">r</tt>
for reading, <tT CLAss="monofont">w</tt> for writing, or
<TT CLass="monofont">a</tt> for appending. Add the letter
<tt class="monofont">b</tt> for binary (as discussed in <a href="pythonwin32_cnode24.html">Chapter 3</a>), and <tT CLASS="monofont">w+</tT> opens it for
updating. See the Python Library Reference (included in HTML format
in the standard Python distribution) for further details.</P>



<p><A href="pythonwin32_snode132.html#14">Table 17.3</A> shows the most important methods for
file objects. C programmers will note the similarity to the STDIO
routines; this should be no surprise, as they are implemented using
the C STDIO routines of the same names.</P>



<A Name="14"></a><P><TABle boRDER="1" cellSPACing="0" cellpadding="1" width="100%">
<caPTION><H5>Table 17.3. Methods of File Objects</h5></CApTIoN><COLGRoup sPAN="2">
<Tr>
<th>
<fONT Size="2">
<p>Method</P>
</FONt></th>
<th>
<font size="2">
<p>Description</p>
</font></th>
</TR>
<TR>
<TD>
<fONt SIzE="2">
<PRE CLass="monofont">close()</pRE></FOnt></td>
<TD>
<FOnt siZE="2">
<P>Closes the file.</P>
</font></td>
</tr>
<tr>
<td>
<font size="2">
<pRE CLASs="monofont">flush()</PRe></FOnT></TD>
<TD>
<Font sIZE="2">
<P>
<a namE="idx1675"></A>Flushes to disk.
Windows caches disk activity; if you write a file, you can hear the
lag between writing a file and the disk clicking. This ensures
it's written immediately.</P>
</Font></tD>
</TR>
<Tr>
<td>
<font size="2">
<pre class="monofont">isatty()</prE></FONT></Td>
<TD>
<fONt SIZE="2">
<P>Nonzero if the input is a terminal-type device (e.g., standard input
when using Python from the console).</P>
</font></TD>
</TR>
<tr>
<td>
<FONT size="2">
<PRE Class="monofont">read([<tt class="monofont"><i>size</i></tt>])</pre></fonT></TD>
<TD>
<FoNT sIZe="2">
<P>Reads up to
<TT CLAss="monofont">[</tt><TT CLass="monofont"><i>size</I></TT><Tt claSS="monofont">]</TT>
bytes and returns a string. Omit
<tt class="monofont">[</tt><tt class="monofont"><i>size</i></tt><tT CLASS="monofont">]</tT>,
and the whole file is read into memory. When end of file is reached,
returns an empty string.</P>
</fONt></TD>
</TR>
<TR>
<td>
<foNT SIze="2">
<prE CLAss="monofont">readline()</prE></FONt></td>
<td>
<font size="2">
<p>Returns a string up to and including the next newline character.</p>
</font></td>
</TR>
<TR>
<TD>
<fONt SIzE="2">
<PRE CLass="monofont">readlines()</pRE></FOnt></td>
<TD>
<FOnt siZE="2">
<P>Returns a list of strings containing all lines in the file. Each
string includes the trailing newline character.</P>
</font></td>
</tr>
<tr>
<td>
<font size="2">
<pRE CLASs="monofont">seek(<TT cLAsS="monofont"><I>offset</I></TT>, [whence])</Pre></foNT></TD>
<td>
<foNT SIze="2">
<p>Jumps to the location <tT CLAss="monofont"><i>offset</i></tt> in the file.
<tt class="monofont">whence</tt> is optional and specifies a mode: if zero,
<tt clasS="monofont"><I>offset</I></TT> is an absolute position, if 1,
relative to the current position, and if 2, relative to the end of
the file.</P>
</fONt></TD>
</tR>
<TR>
<TD>
<Font sIZE="2">
<Pre clASS="monofont">tell()</Pre></foNT></TD>
<td>
<font size="2">
<p>Returns the current location in the file.</p>
</font></td>
</tr>
<tR>
<TD>
<FONt SIzE="2">
<PrE CLASS="monofont">truncate([<tt clASS="monofont"><I>size</i></tt>])</pRE></FOnt></td>
<TD>
<FOnt size="2">
<p>Truncates the file at the current position or at
<tt class="monofont"><i>size</i></tt> if it's provided.</p>
</foNT></TD>
</TR>
<tR>
<Td>
<FOnT SIZE="2">
<Pre clASS="monofont">write(<Tt claSS="monofont"><I>str</I></tt>)</prE></FONt></td>
<td>
<font size="2">
<p>Writes the string to the file.</p>
</font></td>
</TR>
<TR>
<TD>
<fONt SIzE="2">
<PRE CLass="monofont">writelines(<tT CLAss="monofont"><i>list</i></TT>)</PRe></fonT></TD>
<Td>
<font size="2">
<p>Writes a list of strings to the file. It doesn't insert any
newlines or other delimiters.</p>
</font></td>
</tr>
</coLGROUP>
</tABlE></P>



<p>Every language has functions, such as <TT CLASs="monofont">read</tt> and
<tT CLAss="monofont">write</tt>, and many have <TT CLass="monofont">readline</tT>.
Python's ability to handle lists and strings is what really
makes file processing a joy. Let's run through a few common
idioms.</P>






<H5>17.1.2.2
Reading a text file into a list</H5>


<p>Here <tt class="monofont">readlines</tt>
<a name="idx1676"></a>
<a name="idx1677"></A>
<A NAME="idx1678"></a> loads the entire file into a list of
strings in memory:</P>



<PrE ClASS="monofont">&gt;&gt;&gt; f = open('c:\\config.sys','r')
&gt;&gt;&gt; lines = f.readlines()
&gt;&gt;&gt; f.close()
&gt;&gt;&gt; from pprint import pprint
&gt;&gt;&gt; pprint(lines[0:3])
['DEVICEHIGH = A:\\CDROM\\CDROM.SYS /D:CD001\012',
 'device=C:\\WINDOWS\\COMMAND\\display.sys con=(ega,,1)\012',
 'Country=044,850,C:\\WINDOWS\\COMMAND\\country.sys\012']
&gt;&gt;&gt;</PRE>


<p>The <tt cLASS="monofont">pprint</tt> function (short for pretty-print) lets
you display large data structures on several lines. Note also that
each line still ends in a newline character (octal 012, decimal 10).
Because the file is opened in text mode (by omitting the binary
specification), you see a single newline character terminating each
line, even if the actual file is terminated with
carriage-return/linefeed pairs.</p>



<p>You can follow this with a call to <TT CLass="monofont">string.split()</tT>
to parse each line. Here's a generic function to parse
tab-delimited data:</P>



<PRe class="monofont">def read_tab_delimited_file(filename):
    "returns a list of tuples"
    # we can compress the file opening down to a one-liner -
    # the file will be closed automatically
    lines = open(filename).readlines()
    table = []
    for line in lines:
        #chop off the final newline
        line = line[:-1]
        # split up the row on tab characters
        row = string.split(line, '\t')
        table.append(row)
    return table</pre>


<p>And here's what it can do:</p>



<pre class="monofont">&gt;&gt;&gt; data = read_tab_delimited_file('c:\\temp\\sales.txt')
&gt;&gt;&gt; pprint(data)
[['Sales', '1996', '1997', '1998'],
 ['North', '100', '115', '122'],
 ['South', '176', '154', '180'],
 ['East', '130', '150', '190']]
&gt;&gt;&gt;</prE>


<P>Note once again how useful <TT CLaSS="monofont">pprint</tT> is! This is
another of Python's key strengths: you can work at the
interactive prompt, looking at your raw data, which helps you to get
your code right early in the development process.</P>






<h5>17.1.2.3
Reading a line at a time</H5>


<P><TT CLass="monofont"></tT>
<A NAme="idx1679"></a>
<a NAME="idx1680"></a>The previous example is suitable only for
files that definitely fit into memory. If they might get bigger, you
should loop a line at a time. Here is the common idiom for doing
this:</p>



<prE CLAss="monofont">f = open(filename,'r')
    s = f.readline()
    while s &lt;&gt; '':
        # do something with string 's'
        s = f.readline()
    f.close()</pre>





<h5>17.1.2.4
The fileinput module</h5>


<p>A number of people have complained about having to type
<tt class="monofont">readline()</tt> twice, while Perl has a one-line
construction to loop over files. The standard library now includes a
module called
<tt clASS="monofont">fileinput</TT>
<A nAMe="idx1681"></A> to save you this minimal amount of extra
typing. The module lets you do the following:</P>



<pRE CLASs="monofont">import fileinput
for line in fileinput.input([filename]):
    process(line)</pre>


<P>If no filename is provided, the module loops over standard input,
useful in script processing. Pass the <TT Class="monofont">filename</TT>
parameter in single item list; <TT clasS="monofont">fileinput</TT> iterates
automatically over any number of files simply by including more items
in this parameter. <Tt class="monofont">fileinput</tt> also lets you access
the name of the file and the current line number and provides a
mechanism to modify files in place (with a backup) in case something
goes wrong.</p>






<h5>17.1.2.5
Reading binary data</h5>


<p>
<a name="idx1682"></a>The
<tt cLASS="monofont">read()</TT> command loads an entire file into memory if
you don't specify a size. You often see the one liner:</p>



<PRe CLaSS="monofont">&gt;&gt;&gt; mystring = open('c:\\temp\\sales.txt').read()
&gt;&gt;&gt;</PRE>


<P>This code uses the fact that file objects are closed just before they
get garbage-collected. You didn't assign the file object to a
variable, so Python closes it and deletes the object (but not the
file!) after the line executes. You can slurp an entire file into a
string in one line.</p>



<p>Python strings are eight-bit safe and are the easiest means to
manipulate binary data. In addition to this, the
<tt CLASs="monofont">struct</tt> module lets you create C-compatible
structures and convert them to and from strings; and the
<tT CLAss="monofont">array</tt> module efficiently handles arrays of data,
which it can convert to and from strings and files.</P>



<P>
<A Name="idx1683"></a>More
information on working with files and the other various Python
modules we discussed here can be found in either of these fine
O'Reilly Python books we've mentioned before:
<i>Programming Python</i> and <i>Learning
Python</i>
<a name="idx1684"></a>.<a name="idx1685"></a></p>



</FONT>
 
<table width="100%" border="0" cellspacing="0" cellpadding="0" bgcolor="#CCCCCC">
<td><font color="black" size=1>I l<font color="#FF0000">@</font>ve RuBoard</td>
<td valign="top" class="v2" align="right"><a href="pythonwin32_cnode130.html"><img src="FILES/previous.gif" width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a> <a href="pythonwin32_snode133.html"><img src="FILES/next.gif" width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a></td></table>
</BODY></HTML>