<HTML><HEAD><META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=iso-8859-1">
<!--SafClassName="docSection1Title"--><!--SafTocEntry="1.2 Python as an Integration Tool"-->
<LINK REL="stylesheet" href="FILES/sbolM.css">
</HEAD>
<BODY link="#354278" vlink="#000066" alink="#000080" topmargin="0">
<table width="100%" border="0" cellspacing="0" cellpadding="0" bgcolor="#CCCCCC">
<td><font color="black" size=1>I l<font color="#FF0000">@</font>ve RuBoard</td>
<td valign="top" class="v2" align="right"><a href="pythonwin32_snode13.html"><img src="FILES/previous.gif" width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a> <a href="pythonwin32_snode15.html"><img src="FILES/next.gif" width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a></td></table>
<FONT>
<h3>1.2
Python as an Integration Tool</h3>


<p>
<a NAME="idx55"></a>
<a naME="idx56"></A>Python can integrate a variety of disparate
systems; you may hear it referred to as a <I>glue
language,</i>
<a naME="idx57"></A> because it's a powerful way to
glue systems together. We have broken the basic integration
technologies available on Windows into five groups: files, DLLs, COM,
networking, and distributed objects. We'll take a quick look at
the Python features that support each one.</P>




<h4>1.2.1
Working with Files</h4>


<p>
<a name="idx58"></a>The most fundamental technique for making
systems talk is working with files. They are at the foundation of
every operating system, and huge and reliable systems can be built
and maintained by batch-processing files. Every programming language
can work with files, but some make it easier than others. Here are
some key features:</p>



<ul>
<li><p>Python can read a file into a string (or read a multiline text file
into a list of strings) in one line. Strings have no limitations on
what they can hold: null bytes and non-ASCII encodings are fine.</p>
</li>
<li><p>Python can capture and redirect its own standard input and output;
subroutines that print to standard output can thus be diverted to
different destinations.</P>
</LI>
<LI><P>It provides a platform-independent API for working with filenames and
paths, selecting multiple files, and even recursing through directory
trees.</p>
</LI>
<lI><P>For binary files, Python can read and write arrays of uniform types.</p>
</LI>
<LI><P>A variety of text-parsing tools are available, ranging from string
splitting and joining operations and a pattern-matching language, up
to complete data-driven parsers. The key parts of these are written
in C, allowing Python text-processing programs to run as fast as
fully compiled languages.</P>
</li>
<li><P>When generating output, Python allows you to create multiline
templates with formatting codes and perform text substitutions to
them from a set of keys and values. In essence, you can do a
mailmerge in one line at incredibly high speeds.</P>
</LI>
</ul>
<p><a href="pythonwin32_cnode130.html">Chapter 17</a>, provides a comprehensive introduction
to these features.</p>







<h4>1.2.2
Working with DLLs and C Programs</h4>


<P>
<A NAme="idx59"></a>
<a name="idx60"></a> <a name="idx61"></a> <a name="idx62"></a>Windows uses dynamic
link libraries extensively. DLLs allow collections of functions,
usually written in <A NAME="idx63"></A>C or
<a NAmE="idx64"></A>C++, to be
stored in one file and loaded dynamically by many different programs.
DLLs influence everything that happens on Windows; indeed, the
Windows API is a collection of such DLLs.</p>



<P>Python is written in ANSI C, and one of its original design goals was
to be easy to extend and embed at the C level. Most of its
functionality lives in a DLL, so that other programs can import
Python at runtime and start using it to execute and evaluate
expressions. Python extension modules can also be written in C, C++,
or Delphi to add new capabilities to the language that can be
imported at runtime.</P>



<P>The Win32 extensions for Python, which we cover throughout this book,
are a collection of such libraries that expose much of the Windows
API to Python.</P>



<P>The basic
<A name="idx65"></A>Python
distribution includes a manual called <I>Extending and
Embedding the Python Interpreter</I>, which describes the
process in detail. <A href="pythonwin32_cnode170.html">Chapter 22</A>, shows you how to
work with Python at this level on Windows.</P>







<H4>1.2.3
COM</H4>


<p>The <a naME="idx66"></A> <A name="idx67"></a>
<a name="idx68"></a>Component Object Model (COM)
is Microsoft's newest integration technology and pervades
Windows 95, 98, NT, and 2000. The DLL lets you call functions someone
else has written; COM lets you talk to objects someone else has
written. They don't even have to be on the same computer!</p>



<p>Windows provides a host of API calls to get things done, but using
the calls generally requires C programming expertise, and they have a
tortuous syntax. COM provides alternative, easier-to-use interfaces
to a wide range of operating-system services, and it lets
applications expose and share their functionality as well. COM is now
mature, stable, and as fast as using DLLs, but much easier to use,
and so opens up many new possibilities. Want a spreadsheet and chart
within your application? Borrow the ones in Excel. To a programmer
with a COM-enabled language (and most of them are by now), Windows
feels like a sea of objects, each with its own capabilities, standing
by and waiting to help you get your job done.</p>



<p>Python's support for COM is superb and is the thrust for a
large portion of this book.</p>







<h4>1.2.4
Networking</h4>


<p>
<a nAME="idx69"></A>The fourth
integration technology we'll talk about is the network. Most of
the world's networks now run on <A NaME="idx70"></a>TCP/IP, the Internet
protocol. There is a standard programming API to TCP/IP, the
<I>sockets</I>
<a NAME="idx71"></A>
interface, which is available at the C level on Windows and almost
every other operating system. Python exposes the sockets API and
allows you to directly write network applications and protocols. We
cover sockets in <A href="pythonwin32_cnode149.html">Chapter 19</A>.</P>



<P>
<A name="idx72"></A>
<A NAme="idx73"></a>You may not want to work with sockets
directly, but you will certainly have use for the higher-level
protocols built on top of it, such as Telnet, FTP, and HTTP.
Python's standard library provides modules that implement these
protocols, allowing you to automate FTP sessions or retrieval of data
from email servers and the Web. It even includes ready-made web
servers for you to customize. <a href="pythonwin32_cnode112.html">Chapter 14</a>, and <a href="pythonwin32_cnode117.html">Chapter 15</a>, cover these standard library features.</p>







<h4>1.2.5
Distributed Objects</h4>


<p>
<a name="idx74"></a>The most
sophisticated level of integration yet seen in computing is the field
of <i>distributed</i> <i>objects</i>:
essentially, letting objects on different machines (and written in
different languages) talk to each other. Many large corporations are
moving from two-tier applications with databases and GUIs to
three-tier applications that have a layer of
<I>business</I>
<A NAMe="idx75"></A><I>
</i><I>objects</I><i> </I>in the
middle. These objects offer a higher level of abstraction than the
database row and can represent tangible things in the business such
as a customer or an invoice. The two main contenders in this arena
are COM, which is a Windows-only solution and
<A NAME="idx76"></a> <a naME="idx77"></A>Common<I>
</i>Object<i> </i>Request<i>
</I>Broker<I> </I>Architecture<I>
</i>(CORBA), which is multiplatform. Python is used
extensively with both. Our focus is on <a naME="idx78"></A>COM, and we show how to build a
distributed Python application in <A href="pythonwin32_cnode85.html">Chapter 11</a>.
Building a distributed application is absurdly easy; COM does all the
work, and it's a matter of configuring the machine correctly.</p>



<p>Python's support for all five technologies and the fact that it
runs on many different operating systems are what makes it a superb
integration tool. We believe that Python can be used to acquire data
easily from anything, anywhere.</p>







<h4>1.2.6
Where Python Fits in the Development Picture</h4>


<p>
<a name="idx79"></a>You are of course free to fall in
love with Python, switch over to it for all your development needs,
and hang out extolling its virtues on Usenet in the small hours of
the morning: you'll find good company, possibly including the
authors. However, if you have so far escaped conversion, we have
tried to identify the areas where Python fits into a corporate
computing environment. Home users are a more varied bunch, but what
follows should give you an idea of what the language is good for.</p>



<p>A standard corporate computing environment these days involves
Windows NT 4.0 and Microsoft Office on the desktop; networks using
TCP/IP; developers building systems tools and business objects in C
and C++; GUI development in Visual Basic; and relational databases
such as Oracle, Sybase, and SQL Server. It may involve legacy systems
predating relational databases and Unix boxes in the back office
running databases and network services. It undoubtedly involves a
dozen applications bought or developed over time that need to be kept
talking to each other as things evolve. More sophisticated
environments are moving from two- to three-tier architectures and
building distributed object systems with COM and CORBA, with
libraries of C++ business objects in between the database and the
GUI.</p>



<p>Maintaining the diversity of skills necessary to support such an
environment is a challenge, and IT managers won't allow a new
development tool unless it offers clear business benefits. Arguments
that Language X is twice as productive as Language Y just don't
suffice and are impossible to prove. The following areas are ones in
which you may not be well served at present, and in which Python can
supply a missing piece of the puzzle:</P>



<A NAME="idx80"></a><A NaME="idx81"></a><A NAME="idx82"></A><a namE="idx83"></A><A Name="idx84"></a><A NAMe="idx85"></a><a nAME="idx86"></A><a name="idx87"></a><a name="idx88"></a><a name="idx89"></a><a naME="idx90"></A><A NAmE="idx91"></A><a NAmE="idx92"></A><DL>
<DT>
<i><fonT COLor="#990000">A macro language</foNT></I></Dt>
<dd>
<p>
<A NAMe="idx80"></a>If
we had to pick one killer feature, this would be it. You can use
Python to add a <a name="idx81"></a>macro language or
<a name="idx82"></a>scripting
capability to existing applications, and it's simple enough for
user-level scripting with a minimum of training. If a useful
application starts growing more and more features, needing larger and
larger configuration files and more options screens and GUIs to do
its job, it may be time to add a macro language. All those
configuration screens can be replaced with short scripts that do
exactly what they say and can be adapted easily. The problem is that
most people don't have a clue where to start. Developing a new
language is often thought of as a task for the big boys in Redmond
and no one else. You might be vaguely aware that
<a name="idx83"></a>Visio
Corporation licensed <a NAME="idx84"></A>Visual Basic for Applications, but
this choice is undoubtedly going to (a) be expensive, and (b) require
enormous resources and levels of skill in making your applications
work just like Microsoft Office. Python is an off-the-shelf macro
language you can plug in to your existing tools at a variety of
levels. In <A href="pythonwin32_cnode47.html">Part II</A> we'll show you how
easy it is and how far it can take you.</P>
</dD>
<DT>
<I><FOnt coLOR="#990000">A rapid prototyping tool for object models and algorithms</Font></i></DT>
<DD>
<p>
<a naME="idx85"></A>Designing
software in C++ is expensive and time-consuming, although superb
results can be achieved. As a consequence, many companies try to
design object models using data-modeling languages and graphical
tools, or at least by writing and criticizing design documents before
allowing their developers to start writing code. But these tools
don't run, and they can't tell you much. You can create
objects in Python with fewer lines of code and fewer hours than any
other language we know, and there is full support for inheritance
(single and multiple), encapsulation, and polymorphism. A popular
approach is to prototype a program in Python until you're sure
the design is right, and only then move to C++. An even more popular
approach is to profile the Python application and rewrite just the
speed-critical parts in C++. There is, however, a risk that the
prototype will work so well you may end up using Python in a
production environment!</P>
</dd>
<dt>
<i><font color="#990000">A testing tool</font></i></dt>
<DD>
<P>
<A NAmE="idx86"></A>New programs and
code libraries need testing. Experienced developers know that
building a test suite for a new function or program saves them time
and grief. These test suites are often regarded as disposable and
thus a low-risk place to introduce and start learning about Python.
If a program works with files as its input and output, Python scripts
can generate input, execute the program, look at the output, and
analyze it. If the data is the issue, you can write disposable
scripts to check identities in the data. If you are building a
general-purpose C++ component or library, it's quite likely
that only a small proportion of its functionality will be used in its
early days, and bugs could lurk for a long time. By exposing the
component or library to Python, you can quickly write test scripts to
exercise functionality and prove it works correctly, then rerun the
scripts every time the C++ source changes. We'll show you how
later on.</p>
</DD>
<dT>
<I><FONT coloR="#990000">Data cleaning and transformation</FONt></i></dt>
<DD>
<P>
<A name="idx87"></A>You may need
to move data from an old to a new database, refreshing daily for
months during a changeover, or build interfaces to let data flow
between incompatible systems. This can be a tedious and error-prone
process when done by hand, and you always miss something and have to
redo it later. Python's native support for lists and
dictionaries makes complex <A NAme="idx88"></a>data transformations easy, and
the interactive mode lets programmers view the data at each stage in
the process. Scripts can be written to transform data from source to
destination and run as often as needed until they do the job right.</p>
</dd>
<dt>
<i><font color="#990000">Python as glue</fonT></I></DT>
<DD>
<p>
<A NaME="idx89"></a>Incompatible
systems often need to be tied together, and processes need to be
automated. Python supports all the key technologies for integration;
it's equally happy working with files, network protocols, DLLs,
and COM objects, and it offers extensive libraries to help you get at
almost any kind of data. It's well suited to controlling other
packages, doing system-administration tasks, and controlling the flow
of data between other<A NAME="idx90"></A> systems.<a namE="idx91"></A> <A Name="idx92"></a></P>
</DD>
</Dl>

</fonT>
 
<table width="100%" border="0" cellspacing="0" cellpadding="0" bgcolor="#CCCCCC">
<td><font color="black" size=1>I l<font color="#FF0000">@</font>ve RuBoard</td>
<td valign="top" class="v2" align="right"><a href="pythonwin32_snode13.html"><img src="FILES/previous.gif" width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a> <a href="pythonwin32_snode15.html"><img src="FILES/next.gif" width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a></td></table>
</BODY></HTML>