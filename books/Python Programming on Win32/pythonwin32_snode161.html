<HTML><HEAD><META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=iso-8859-1">
<!--SafClassName="docSection1Title"--><!--SafTocEntry="20.3 wxPython"-->
<LINK REL="stylesheet" href="FILES/sbolM.css">
</HEAD>
<BODY link="#354278" vlink="#000066" alink="#000080" topmargin="0">
<table width="100%" border="0" cellspacing="0" cellpadding="0" bgcolor="#CCCCCC">
<td><font color="black" size=1>I l<font color="#FF0000">@</font>ve RuBoard</td>
<td valign="top" class="v2" align="right"><a href="pythonwin32_snode160.html"><img src="FILES/previous.gif" width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a> <a href="pythonwin32_cnode162.html"><img src="FILES/next.gif" width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a></td></table>
<FONT>
<h3>20.3
wxPython</h3>


<p>
<a NAME="idx1990"></a> <a naME="idx1991"></A>Another GUI toolkit available for Python
is called <Tt claSS="monofont">wxPython</TT>. The current incarnation is
fairly new to the Python scene and is rapidly gaining popularity
amongst Python developers. <tt class="monofont">wxPython</tt> is a Python
extension module that encapsulates the wxWindows C++ class library.</p>



<p><tt class="monofont">wxPython</tt> is a cross-platform GUI framework for
Python that is quite mature on the Windows platform. It exposes the
popular <tT CLASS="monofont">wxWindows</tT> C++ framework Python to provide
an attractive alternative for GUI development.</P>




<h4>20.3.1
wxWindows</H4>


<P><tT CLASS="monofont">wxWindows</tt>
<a nAME="idx1992"></A>
is a free C++ framework designed to make cross-platform programming
child's play. Well, almost. <tt clASS="monofont">wxWindows</Tt> 2.0
supports Windows 3.1/95/98/NT, Unix with GTK/Motif/Lesstif, with a
Mac version underway. Other ports are under consideration.</p>



<p><tT CLAss="monofont">wxWindows</tt> is a set of libraries that allows C++
applications to compile and run on several different types of
computers, with minimal source-code changes. There's one
library per supported GUI (such as Motif, or Windows). As well as
providing a common API for GUI functionality, it provides
functionality for accessing some commonly used operating-system
facilities, such as copying or deleting files.
<tt class="monofont">wxWindows</tt> is a framework in the sense that it
provides a lot of built-in functionality, which the application can
use or replace as required, thus saving a great deal of coding
effort. Basic data structures such as strings, linked lists, and hash
tables are also supplied.</p>



<p>Native versions of controls, common dialogs, and other window types
are used on platforms that support them. For other platforms,
suitable alternatives are created using <tt clasS="monofont">wxWindows</TT>
itself. For example, on Win32 platforms the native list control is
used, but on GTK, a generic list control with similar capabilities
was created for use in the <TT ClASs="monofont">wxWindows</TT> class
library.</p>



<P>Experienced Windows programmers will feel right at home with the
<TT CLAss="monofont">wxWindows</tt> object model. Many of the classes and
concepts will be familiar. For example, the Multiple Document
Interface, drawing on Device Contexts with GDI objects such as
brushes, pens, and so on.</P>







<H4>20.3.2
wxWindows + Python = wxPython</H4>


<P><tt clASS="monofont">wxPython</Tt> is a Python extension module that
provides a set of bindings from the <tt cLASS="monofont">wxWindows</tt>
library to the Python language. In other words, the extension module
allows Python programers to create instances of
<tt class="monofont">wxWindows</tt> classes and to invoke methods of those
classes.</p>



<p>The <tt class="monofont">wxPython</tT> extension module attempts to mirror
the class hierarchy of <TT CLAsS="monofont">wxWindows</Tt> as closely as
possible. This means that there is a <TT cLASS="monofont">wxFrame</TT> class
in <tt clASS="monofont">wxPython</Tt> that looks, smells, tastes, and acts
almost the same as the <tt cLASS="monofont">wxFrame</tt> class in the C++
version.</p>



<p><TT CLass="monofont">wxPython</tt> is close enough to the C++ version that
the majority of the <tt class="monofont">wxPython</tt> documentation is
actually annotations to the C++ documentation that describe the
places where <tt class="monofont">wxPython</TT> is different. There is also
a series of sample programs included, and a series of documentation
pages that assist the programmer in getting started with
<TT CLaSS="monofont">wxPython</tT>.</P>




<h5>20.3.2.1
Where to get wxPython</H5>


<P>The latest version of <TT CLass="monofont">wxPython</tT> can always be found
at
<A NAme="idx1993"></a><a TARGet="_blank" hrEF="http://http://../alldunn.com/wxPython/default.htm">http://alldunn.com/wxPython/</A>. From this site
you can download a self-installer for Win32 systems that includes a
prebuilt extension module, documentation in HTML help format, and a
set of demos.</P>



<p>Also available from this site is a Linux RPM,
<tt class="monofont">wxPython</tt> sources, documentation in raw HTML, and
pointers to other sites, mail lists, the <tt class="monofont">wxPython</tt>
FAQ, and so forth.</p>



<p>If you want to build <TT CLASs="monofont">wxPython</TT> from sources
yourself, you also need the <tT ClASS="monofont">wxWindows</TT> sources,
available from <A targET="_blank" HRef="http://www.wxwindows.org/default.htm">http://www.wxwindows.org/</a>.</p>






<H5>20.3.2.2
Where to go from here</H5>


<P>The remainder of this chapter gives a basic introduction to using
<Tt claSS="monofont">wxPython</TT>, starting with a simple example teaching
the basic structure of a <tt class="monofont">wxPython</tt> application. We
then build a more involved sample that touches on some of the more
advanced features of the toolkit, using classes from the Doubletalk
financial modeler you're already familiar with.</p>








<h4>20.3.3
Using wxPython</h4>


<p>
<a name="idx1994"></a>We've
always found that the best way to learn is by doing and then
experimenting and tweaking with what's been done. So download
and install <tt CLASS="monofont">wxPython</Tt>, fire up your favorite text
editor<FOnT SiZE="1"><SUP><A href="#FOOTNOTE-1">[1]</A></SUP></font>
 and get ready to
play along as you read the next few sections.</P>


<BLOckquOTE><Font size="1">
<p class="footnote">
<sup><a name="FOOTNOTE-1">[1]</A></SUP>
When getting started, you should probably
avoid using PythonWin or IDLE for running <TT cLAsS="monofont">wxPython</Tt>
programs, because the interactions between the various toolkits may
have unexpected consequences.</P>
</FONT></BlockQUOTe>






<h5>20.3.3.1
A simple example</h5>


<p>Familiarize yourself with this little <TT CLass="monofont">wxPython</tT>
program, and refer back to it as you read through the explanations
that follow:</P>



<PRe class="monofont">from wxPython.wx import *

class MyApp(wxApp):
    def OnInit(self):
        frame = wxFrame(NULL, -1, "Hello from wxPython")
        frame.Show(true)
        self.SetTopWindow(frame)
        return true

app = MyApp(0)
app.MainLoop()</pre>


<p>When you run this code, you should see a Window appear similar to
<a href="pythonwin32_snode161.html#10">Figure 20.6</a>.</p>



<centER>
<H5>
<A NAmE="10"></A>Figure 20.6. A basic wxPython application</h5>

<IMg BORDER="0" widtH="502" HEIght="93" src="FILES/ppw.2006.gif" ALt="figs/ppw.2006.gif"></cenTER>


<P>The first thing to do is import the entire
<tt class="monofont">wxPython</tt> library with the <tt class="monofont">from</tt>
<tt cLASS="monofont">wxPython.wx</TT> <tT ClASs="monofont">import</TT>
<TT CLass="monofont">*</tT> statement. This is common practice for
<TT Class="monofont">wxPython</TT> programs, but you can obviously perform
more restrictive imports if you prefer.</P>



<P>Every <tt clASS="monofont">wxPython</Tt> application needs to derive a class
from <tt class="monofont">wxApp</tt> and provide an
<tt class="monofont">OnInit</tt> method for it. The framework calls this
method as part of its initialization sequence, and the usual purpose
of <tt CLASS="monofont">OnInit</Tt> is to create the windows and essentials
necessary for the program to begin operation. In the sample you
created a frame with no parent, with a title of "Hello from
<TT cLAsS="monofont">wxPython</TT>" and then showed it. We could also
have specified a position and size for the frame in its constructor,
but since we didn't, defaults are used. The last two lines of
the <TT Class="monofont">OnInit</TT> method will probably be the same for
all applications; <TT clasS="monofont">SetTopWindow</TT> method informs
<Tt claSS="monofont">wxWindows</TT> that this frame is one of the main
frames (in this case the only one) for the application, and you
return <tt class="monofont">true</tt> to indicate success. When all
top-level windows have been closed, the application terminates.</p>



<p>The final two lines of the script again will probably be the same for
all your <tt class="monofont">wxPython</tt> applications. You create an
instance of the application class and call its
<tT CLASS="monofont">MainLoop</tT> method. <Tt CLaSS="monofont">MainLoop</TT> is
the heart of the application: it's where events are processed
and dispatched to the various windows, and it returns when the final
window is closed. Fortunately, <TT clasS="monofont">wxWindows</TT> insulates
you from the differences in event processing in the various GUI
toolkits.</P>



<p>Most of the time you will want to customize the main frame of the
application, and so using the stock <tt cLASS="monofont">wxFrame</tt>
isn't sufficient. As you might expect, you can derive your own
class from <tt CLASs="monofont">wxFrame</tt> to begin customization. This
next example builds on the last by defining a frame class and
creating an instance in the application's
<tt class="monofont">OnInit</tt> method. Notice that except for the name of
the class created in <tt class="monofont">OnInit</tt>, the rest of the
<TT CLASs="monofont">MyApp</TT> code is identical to the previous example.
This code is displayed in <a href="pythonwin32_snode161.html#11">Figure 20.7</A>.</P>



<PRE clasS="monofont">from wxPython.wx import *

ID_ABOUT = 101
ID_EXIT  = 102

class MyFrame(wxFrame):
    def __init__(self, parent, ID, title):
        wxFrame.__init__(self, parent, ID, title,
                         wxDefaultPosition, wxSize(200, 150))
        self.CreateStatusBar()
        self.SetStatusText("This is the statusbar")

        menu = wxMenu()
        menu.Append(ID_ABOUT, "&amp;About",
                    "More information about this program")
        menu.AppendSeparator()
        menu.Append(ID_EXIT, "E&amp;xit", "Terminate the program")

        menuBar = wxMenuBar()
        menuBar.Append(menu, "&amp;File");

        self.SetMenuBar(menuBar)


class MyApp(wxApp):
    def OnInit(self):
        frame = MyFrame(NULL, -1, "Hello from wxPython")
        frame.Show(true)
        self.SetTopWindow(frame)
        return true

app = MyApp(0)
app.MainLoop()</PRE>


<centER>
<H5>
<A name="11"></A>Figure 20.7. A wxPython application with menus</H5>

<IMg border="0" width="502" height="141" src="FILES/ppw.2007.gif" ALT="figs/ppw.2007.gif"></CENtER>


<p>This example shows some of the built-in capabilities of the
<TT cLASS="monofont">wxFrame</TT> class. For example, creating a status bar
for the frame is as simple as calling a single method. The frame
itself automatically manages its placement, size, and drawing. On the
other hand, if you want to customize the status bar, create an
instance of your own <tt clASS="monofont">wxStatusBar</Tt>-derived class and
attach it to the frame.</p>



<p>Creating a simple menu bar and a drop-down menu is also demonstrated
in this example. The full range of expected menu capabilities is
supported: cascading submenus, checkable items, popup menus, etc.;
all you have to do is create a menu object and append menu items to
it. The items can be text as shown here, or other menus. With each
item you can optionally specify some short help text, as we have
done, which are shown in the status bar automatically when the menu
item is selected.</p>






<H5>20.3.3.2
Events in wxPython</H5>


<P>
<A name="idx1995"></A> <A NAme="idx1996"></a>The one thing that the last sample
doesn't do is show how to make the menus actually do something.
If you run the sample and select Exit from the menu, nothing happens.
The next sample takes care of that little problem.</p>



<p>To process events in <tt class="monofont">wxPython</tt>, any method (or
standalone function for that matter) can be attached to any event
using a helper function from the toolkit. <tt class="monofont">wxPython</TT>
also provides a <TT CLaSS="monofont">wxEvent</tT> class and a whole bunch of
derived classes for containing the details of the event. Each time a
method is invoked due to an event, an object derived from
<Tt CLASS="monofont">wxEvent</Tt> is sent as a parameter, the actual type of
the event object depends on the type of the event;
<tt cLASS="monofont">wxSizeEvent</tt> for when the window changes size,
<tt CLASs="monofont">wxCommandEvent</tt> for menu selections and button
clicks, <tT CLAss="monofont">wxMouseEvent</tt> for (you guessed it) mouse
events, and so forth.</p>



<p>To solve our little problem with the last sample, all you have to do
is add two lines to the <tt class="monofont">MyFrame</tt> constructor and
add some methods to handle the events. We'll also demonstrate
one of the common dialogs, the <tt clasS="monofont">wxMessageDialog</TT>.
Here's the code, with the new parts in bold, and the running
code shown in <A href="pythonwin32_snode161.html#15">Figure 20.8</A>:</p>



<PRe CLASS="monofont">from wxPython.wx import *

ID_ABOUT = 101
ID_EXIT  = 102

class MyFrame(wxFrame):
    def __init__(self, parent, ID, title):
        wxFrame.__init__(self, parent, ID, title,
                         wxDefaultPosition, wxSize(200, 150))
        self.CreateStatusBar()
        self.SetStatusText("This is the statusbar")
        menu = wxMenu()
        menu.Append(ID_ABOUT, "&amp;About",
                    "More information about this program")
        menu.AppendSeparator()
        menu.Append(ID_EXIT, "E&amp;xit", "Terminate the program")
        menuBar = wxMenuBar()
        menuBar.Append(menu, "&amp;File");
        self.SetMenuBar(menuBar)
<B>
        EVT_MENU(self, ID_ABOUT, self.OnAbout)
        EVT_MENU(self, ID_EXIT,  self.TimeToQuit)
    def OnAbout(self, event):
        dlg = wxMessageDialog(self, "This sample program shows off\n"
                              "frames, menus, statusbars, and this\n"
                              "message dialog.",
                              "About Me", wxOK | wxICON_INFORMATION)
        dlg.ShowModal()
        dlg.Destroy()

    def TimeToQuit(self, event):
        self.Close(true)</b>

class MyApp(wxApp):
    def OnInit(self):
        frame = MyFrame(NULL, -1, "Hello from wxPython")
        frame.Show(true)
        self.SetTopWindow(frame)
        return true

app = MyApp(0)
app.MainLoop()</pre>


<CENTer>
<h5>
<a NAME="15"></a>Figure 20.8. The application with an About box</h5>

<imG BORder="0" width="502" height="168" src="FILES/ppw.2008.gif" alt="figs/ppw.2008.gif"></cENTER>


<P>The <tT ClASs="monofont">EVT_MENU</TT> function called here is one of the
helper functions for attaching events to methods. Sometimes it helps
to understand what is happening if you translate the function call to
English. The first one says, "For any menu item selection event
sent to the window <TT CLass="monofont">self</tT> with an ID of
<TT Class="monofont">ID_ABOUT</TT>, invoke the method
<TT clasS="monofont">self.OnAbout</TT>."</P>



<p>There are many of these <tt class="monofont">EVT_*</tt> helper functions,
all of which correspond to a specific type of event, or events. Some
popular ones are listed in <a href="pythonwin32_snode161.html#16">Table 20.4</a>. See the
<tt claSS="monofont">wxPython</TT> documentation for<A NaME="idx1997"></a> <A NaME="idx1998"></A>
details.<A NAme="idx1999"></a></p>



<A NAMe="16"></a><p><tABLE bordER="1" CEllspacing="0" cellpadding="1" wIDTH="100%">
<CApTIoN><H5>Table 20.4. Common wxPython Event Functions</h5></CAPTIOn><colGROUp spaN="2">
<TR>
<Th>
<fonT SIZe="2">
<p>Event Function</p>
</font></th>
<th>
<font size="2">
<p>Event Description</p>
</FONT></TH>
</tR>
<Tr>
<TD>
<fONT SIZe="2">
<p><tt CLASs="monofont">EVT_SIZE</tt></p>
</FONT></td>
<td>
<FONT size="2">
<p>Sent to a window when its size has changed, either interactively by
the user or programmatically.</p>
</font></td>
</tr>
<tr>
<td>
<fonT SIZE="2">
<P><tT ClASs="monofont">EVT_MOVE</TT></P>
</FONt></td>
<tD>
<FONt sizE="2">
<P>
<A Name="idx2000"></a>Sent to a window when it has been
moved, either interactively by the user or programmatically.</P>
</FONt></td>
</tr>
<tr>
<td>
<font size="2">
<p><tt cLASS="monofont">EVT_CLOSE</TT></p>
</FOnT></Td>
<TD>
<FONT size="2">
<P>Sent to a frame when it has been requested to close. Unless the close
is being forced, it can be canceled by calling
<TT Class="monofont">event.Veto(true)</TT>.</P>
</Font></tD>
</TR>
<Tr>
<td>
<font size="2">
<p><tt class="monofont">EVT_PAINT</tt></P>
</FONT></Td>
<TD>
<fONt SIZE="2">
<P>This event is sent whenever a portion of the window needs to be
redrawn.</P>
</font></TD>
</TR>
<tr>
<td>
<FONT size="2">
<P><TT Class="monofont">EVT_CHAR</tt></p>
</font></td>
<td>
<font siZE="2">
<P>Sent for each nonmodifier (Shift key, etc.) keystroke when the window
has the focus.</P>
</FOnT></Td>
</TR>
<tR>
<TD>
<FONt sizE="2">
<P><TT clasS="monofont">EVT_IDLE</TT></P>
</font></TD>
<TD>
<font size="2">
<p>This event is sent periodically when the system isn't
processing other events.</p>
</font></td>
</tr>
<tr>
<tD>
<FONT SiZE="2">
<p><TT cLASS="monofont">EVT_LEFT_DOWN</TT></p>
</fonT></TD>
<Td>
<fonT SIZe="2">
<p>The left mouse button has been pressed down.</p>
</fONT></Td>
</tr>
<tr>
<td>
<font size="2">
<p><tt claSS="monofont">EVT_LEFT_UP</TT></P>
</FoNT></tD>
<Td>
<FONT SIze="2">
<p>The left mouse button has been let up.</p>
</FONT></td>
</tr>
<TR>
<TD>
<font SIZE="2">
<p><tt class="monofont">EVT_LEFT_DCLICK </tt></p>
</font></td>
<td>
<foNT SIZE="2">
<p>The left mouse button has been double-clicked.</P>
</FoNT></tD>
</TR>
<TR>
<Td>
<fonT SIZe="2">
<p><tt CLASs="monofont">EVT_MOTION</tt></p>
</FONT></td>
<td>
<font size="2">
<p>The mouse is in motion.</p>
</font></td>
</tR>
<TR>
<TD>
<FoNT sIZe="2">
<P><TT CLAss="monofont">EVT_SCROLL</tt></P>
</FONt></td>
<tD>
<FONt sizE="2">
<P>A scrollbar has been manipulated. This one is actually a collection
of events, which can be captured individually if desired.</P>
</Font></td>
</tr>
<tr>
<td>
<font size="2">
<p><tT CLASS="monofont">EVT_BUTTON</tT></P>
</fONt></TD>
<TD>
<FOnt siZE="2">
<P>A button has been clicked.</P>
</font></TD>
</TR>
<tr>
<td>
<FONT size="2">
<p><tt class="monofont">EVT_MENU</tt></p>
</font></td>
<TD>
<FONT sIZe="2">
<P>A menu item has been selected.</P>
</fONT></TD>
</Tr>
</colGROUp>
</tabLE></P>








<H4>20.3.4
Building a Doubletalk Browser with wxPython</h4>


<p>
<a nAME="idx2001"></A> <a name="idx2002"></a>Okay, now let's
build something that's actually useful and learn more about the
<tt class="monofont">wxPython</tt> framework along the way. As has been
shown with the other GUI toolkits, we'll build a small
application around the Doubletalk class library that allows browsing
and editing of transactions.</p>




<h5>20.3.4.1
MDI Frame</h5>


<p>
<a nAME="idx2003"></A>
<A NaME="idx2004"></a>We're going to implement a Multiple
Document Interface, where the child frames are different views of the
transactional data, rather than separate "documents."
Just as with previous samples, the first thing to do is create an
application class and have it create a main frame in its
<TT cLASS="monofont">OnInit</TT> method:</p>



<pre CLASs="monofont">class DoubleTalkBrowserApp(wxApp):
    def OnInit(self):
        frame = MainFrame(NULL)
        frame.Show(true)
        self.SetTopWindow(frame)
        return true

app = DoubleTalkBrowserApp(0)
app.MainLoop()</pre>


<P>Since we are using MDI, there is a special class to use for the
frame's base class. Here is the code for the initialization
method of the main application frame:</P>



<PRe claSS="monofont">class MainFrame(wxMDIParentFrame):
    title = "Doubletalk Browser - wxPython Edition"
    def __init__(self, parent):
        wxMDIParentFrame.__init__(self, parent, -1, self.title)
        self.bookset = None
        self.views = []

        if wxPlatform == '__WXMSW__':
            self.icon = wxIcon('chart7.ico', wxBITMAP_TYPE_ICO)
            self.SetIcon(self.icon)

        # create a statusbar that shows the time and date on the right
        sb = self.CreateStatusBar(2)
        sb.SetStatusWidths([-1, 150])
        self.timer = wxPyTimer(self.Notify)
        self.timer.Start(1000)
        self.Notify()

        menu = self.MakeMenu(false)
        self.SetMenuBar(menu)
        menu.EnableTop(1, false)

        EVT_MENU(self, ID_OPEN,  self.OnMenuOpen)
        EVT_MENU(self, ID_CLOSE, self.OnMenuClose)
        EVT_MENU(self, ID_SAVE,  self.OnMenuSave)
        EVT_MENU(self, ID_SAVEAS,self.OnMenuSaveAs)
        EVT_MENU(self, ID_EXIT,  self.OnMenuExit)
        EVT_MENU(self, ID_ABOUT, self.OnMenuAbout)
        EVT_MENU(self, ID_ADD,   self.OnAddTrans)
        EVT_MENU(self, ID_JRNL,  self.OnViewJournal)
        EVT_MENU(self, ID_DTAIL, self.OnViewDetail)
        EVT_CLOSE(self, self.OnCloseWindow)</PRe>


<p><a href="pythonwin32_snode161.html#23">Figure 20.9</a> shows the state of the application so
far.</p>



<center>
<h5>
<a name="23"></A>Figure 20.9. The first MDI wxPython application</H5>

<IMG BoRDeR="0" WiDTH="502" HEIght="124" src="FILES/ppw.2009.gif" ALt="figs/ppw.2009.gif"></cenTER>


<P>Obviously, we're not showing all the code yet, but we'll
get to it all eventually as we go through piece by piece.</p>



<p>Notice the use of <tt CLASs="monofont">wxMDIParentFrame</tt> as the base
class of <tt class="monofont">MainFrame</tt>. By using this class you
automatically get everything needed to implement MDI for the
application without having to worry about what's really
happening behind the scenes. The <tt class="monofont">wxMDIParentFrame</tt>
class has the same interface as the <TT CLASs="monofont">wxFrame</TT> class,
with only a few additional methods. Often changing a single document
interface program to a MDI program is as easy as changing the base
classes the application's classes are derived from. There is a
corresponding <tT ClASS="monofont">wxMDIChildFrame</TT> to be used for the
document windows, as we'll see later. If you ever need to have
access to the client area (or the background area) of the MDI parent,
you can use the <Tt claSS="monofont">wxMDIClientWindow</TT> class. You might
use this for placing a background image behind all the child
windows.<a namE="idx2005"></A> <A Name="idx2006"></a></P>






<H5>20.3.4.2
Icons</H5>


<P>
<a name="idx2007"></a>
<a name="idx2008"></a>The next thing the previous code does is
create an icon and associate it with the frame. Normally Windows
applications load items such as icons from a resource file that is
linked with the executable. Since <tt class="monofont">wxPython</tt>
programs have no binary executable file, you create the icon by
specifying the full path to a <I>.ico</I> file.
Assigning the icon to the frame only requires calling the
frame's <TT CLaSS="monofont">SetIcon</tT> method.</P>






<h5>20.3.4.3
Timers</H5>


<P>
<A NAMe="idx2009"></a>
<a nAME="idx2010"></A>You may have noticed from <a href="pythonwin32_snode161.html#23">Figure 20.9</A> that the status bar has two sections, with the
date and time displayed in the second one. The next bit of code in
the initialization method handles that functionality. The
frame's
<TT clasS="monofont">CreateStatusBar</TT>
<A name="idx2011"></a> method takes an optional parameter
specifying the number of sections to create, and
<tt class="monofont">SetStatusWidths</tt> can be given a list of integers to
specify how many pixels to reserve for each section. The -1 means
that the first section should take all the remaining space.</p>



<p>In order to update the date and time, you create a
<tt claSS="monofont">wxPyTimer</TT>
<A NaME="idx2012"></a> object. There are two types of timer
classes in <TT cLASS="monofont">wxPython</TT>. The first is the
<tt clASS="monofont">wxPyTimer</Tt> used here, which accepts a function or
method to use as a callback. The other is the
<tt cLASS="monofont">wxTimer</tt> class, which is intended to be derived
from and will call a required method in the derived class when the
timer expires. In the example you specify that when the timer
expires, the <tt CLASs="monofont">Notify</tt> method should be called. Then
start the timer, telling it to expire every 1000 milliseconds (i.e.,
every second). Here is the code for the <tt class="monofont">Notify</tt>
method:</p>



<pre class="monofont"># Time-out handler
def Notify(self):
    t = time.localtime(time.time())
    st = time.strftime(" %d-%b-%Y   %I:%M:%S", t)
    self.SetStatusText(st, 1)</PRE>


<P>You first use Python's <TT cLAsS="monofont">time</Tt> module to get
the current time and format it in to a nice, human-readable formatted
string. Then by calling the frame's
<TT CLASs="monofont">SetStatus-Text</tt> method, you can put that string
into the status bar, in this case in slot 1.</p>






<H5>20.3.4.4
Main menu</H5>


<P>
<A name="idx2013"></A> <A NAme="idx2014"></a>As you can see in the next
bit of code, we have moved the building of the menu to a separate
method. This is mainly for two reasons. The first is to help reduce
clutter in the <tT CLAss="monofont">__init__</tt>
<a name="idx2015"></a> method
and better organize the functionality of the class. The second reason
has to do with MDI. As with all MDI applications, each child frame
can have its own menu bar, automatically updated as the frame is
selected.</p>



<p>The approach taken by our sample is to either add or remove a single
item from the <tt class="monofont">BookSet</tt> menu based on whether a view
can select transactions for editing. Here's the code for the
<TT CLASs="monofont">MakeMenu</TT> method. Notice how the parameter controls
whether the Edit Transaction item is added to the menu. It might have
made better sense to just enable or disable this item as needed, but
then you wouldn't be able to see how
<tT ClASS="monofont">wxPython</TT> changes the menus automatically when the
active window changes. Also notice that you don't create the
Window menu. The
<Tt claSS="monofont">wxMDIParentFrame</TT>
<a namE="idx2016"></A>
takes care of that for you:</P>



<Pre clASS="monofont">def MakeMenu(self, withEdit):
        fmenu = wxMenu()
        fmenu.Append(ID_OPEN,  "&amp;Open BookSet",  "Open a BookSet file")
        fmenu.Append(ID_CLOSE, "&amp;Close BookSet",
                     "Close the current BookSet")
        fmenu.Append(ID_SAVE,  "&amp;Save", "Save the current BookSet")
        fmenu.Append(ID_SAVEAS,  "Save &amp;As", "Save the current BookSet")
        fmenu.AppendSeparator()
        fmenu.Append(ID_EXIT, "E&amp;xit",   "Terminate the program")

        dtmenu = wxMenu()
        dtmenu.Append(ID_ADD, "&amp;Add Transaction",
                      "Add a new transaction")
        if withEdit:
            dtmenu.Append(ID_EDIT, "&amp;Edit Transaction",
                          "Edit selected transaction in current view")
        dtmenu.Append(ID_JRNL, "&amp;Journal view",
                      "Open or raise the journal view")
        dtmenu.Append(ID_DTAIL,"&amp;Detail view",
                      "Open or raise the detail view")

        hmenu = wxMenu()
        hmenu.Append(ID_ABOUT, "&amp;About",
                     "More information about this program")

        main = wxMenuBar()
        main.Append(fmenu, "&amp;File")
        main.Append(dtmenu,"&amp;Bookset")
        main.Append(hmenu, "&amp;Help")

        return main</Pre>


<p>If you skip back to the <tt class="monofont">__init__</tt> method, notice
that after you create the menu and attach it to the window, the
<tt class="monofont">EnableTop</tt> method of the menubar is called. This is
how to disable the entire <TT CLASs="monofont">BookSet</TT> submenu. (Since
there is no <tT ClASS="monofont">BookSet</TT> file open, you can't
really do anything with it yet.) There is also an
<Tt claSS="monofont">Enable</TT> method that allows you to enable or disable
individual menu items by ID.</p>



<p>The last bit of the <tt CLASs="monofont">__init__</tt> method attaches
event handlers to the various menu items. We'll be going
through them one by one as we explore the functionality behind those
options. But first, here are some of the simpler ones:</p>



<PRE Class="monofont">    def OnMenuExit(self, event):
        self.Close()

    def OnCloseWindow(self, event):
        self.timer.Stop()
        del self.timer
        del self.icon
        self.Destroy()

    def OnMenuAbout(self, event):
        dlg = wxMessageDialog(self,
                      "This program uses the doubletalk package to\n"
                      "demonstrate the wxPython toolkit.\n\n"
                      "by Robin Dunn",
                      "About", wxOK | wxICON_INFORMATION)
        dlg.ShowModal()
        dlg.Destroy()</pre>


<p>The user selects Exit from the File menu, then the
<tt class="monofont">OnMenuExit</tt> method is called, which asks the window
to close itself. Whenever the window wants to close, whether
it's because its <tt clASS="monofont">Close</TT> method was called or
because the user clicks on the Close button in the titlebar, the
<Tt CLaSS="monofont">OnCloseWindow</tT> method is called. If you want to
prompt the user with an "Are you sure you want to exit?"
type of message, do it here. If he decides not to quit, just call the
method <TT CLAss="monofont">event.Veto(true)</tt>.</P>



<P>Most programs will want to have a fancier About box than the
<TT clasS="monofont">wxMessageDialog</TT> provides, but for our purposes
here it works out just fine. Don't forget to call the
dialog's <Tt claSS="monofont">Destroy</TT> method, or you may leak
memory.</p>






<h5>20.3.4.5
wxFileDialog</h5>


<p>Before doing anything with a <tt class="monofont">BookSet</tt>, you have to
have one opened. For this, use the common dialog
<tt class="monofont">wxFileDialog</tT>
<A NAME="idx2017"></a>. This is the same File <IMg BOrDER="0" ALIgn="absmiddle" wiDTH="20" HeighT="16" src="FILES/U2192.gif" alt="figs/U2192.gif">
Open dialog you see in all your other Windows applications, all
wrapped in a nice <tT CLAss="monofont">wxPython</tt>-compatible class
interface.</p>



<p>Here's the event handler that catches the File <img border="0" align="absmiddle" wIDTH="20" HEiGHt="16" src="FILES/U2192.gif" ALT="figs/U2192.gif"> Open menu
event, and <A href="pythonwin32_snode161.html#28">Figure 20.10</a> shows the dialog in action:</p>



<PRE Class="monofont">def OnMenuOpen(self, event):
        # This should be checking if another is already open,
        # but is left as an exercise for the reader...
        dlg = wxFileDialog(self)
        dlg.SetStyle(wxOPEN)
        dlg.SetWildcard("*.dtj")
        if dlg.ShowModal() == wxID_OK:
            self.path = dlg.GetPath()
            self.SetTitle(self.title + ' - ' + self.path)
            self.bookset = BookSet()
            self.bookset.load(self.path)
            self.GetMenuBar().EnableTop(1, true)
            
            win = JournalView(self, self.bookset, ID_EDIT)
            self.views.append((win, ID_JRNL))
            
        dlg.Destroy()</PRE>


<CenteR>
<H5>
<A Name="28"></a>Figure 20.10. wxPython browsing for a Doubletalk transaction file</h5>

<img border="0" width="502" heIGHT="214" src="FILES/ppw.2010.gif" ALt="figs/ppw.2010.gif"></CEnTER>


<P>Start off by creating the file dialog and tell it how to behave. Next
show the dialog and give the user a chance to select a
<TT clasS="monofont">BookSet</TT> file. Notice that this time you're
checking the return value of the
<Tt claSS="monofont">ShowModal</TT>
<a namE="idx2018"></A> method. This is how the dialog says what
the result was. By default, dialogs understand the
<TT class="monofont">wxID_OK</tt> and <tt class="monofont">wxID_CANCEL</tt> IDs
assigned to buttons in the dialog and do the right thing when they
are clicked. For dialogs you create, you can also specify other
values to return if you wish.</p>



<p>The first thing to do after a successful completion of the file
dialog is ask the dialog what the selected pathname was, and then use
this to modify the frame's title and to open a
<tt cLASS="monofont">BookSet</TT> file.</p>



<P>Take a look at the next line. It reenables the
<Tt CLaSS="monofont">BookSet</TT> menu since there is now a file open.
It's really two statements in one and is equivalent to these
two lines:</P>



<Pre clASS="monofont">
menu = self.GetMenuBar()
menu.EnableTop(1, true)</Pre>


<p>Since it makes sense to actually let the user see something when they
ask to open a file, you should create and show one of the views in
the last bits of the <tT CLAss="monofont">OnMenuOpen</tt> handler above.
We'll take a look at that next.</P>






<H5>20.3.4.6
wxListCtrl</H5>


<P><tt class="monofont"></tt>
<a name="idx2019"></a>The
Journal view consists of a <tt clasS="monofont">wxListCtrl</TT> with a
single-line summary for each transaction. It's placed inside a
<TT ClASs="monofont">wxMDIChildFrame</TT>
<a NAME="idx2020"></A>
and since it's the only thing in the frame, don't worry
about setting or maintaining the size, the frame does it
automatically. (Unfortunately, since some platforms send the first
resize event at different times, sometimes the window shows up
without its child sized properly.) Here's a simple workaround:</P>



<pre cLASS="monofont">class JournalView(wxMDIChildFrame):
    def __init__(self, parent, bookset, editID):
        wxMDIChildFrame.__init__(self, parent, -1, "")
        self.bookset = bookset
        self.parent = parent

        tID = wxNewId()
        self.lc = wxListCtrl(self, tID, wxDefaultPosition, 
                             wxDefaultSize, wxLC_REPORT)
        ## Forces a resize event to get around a minor bug...
        self.SetSize(self.GetSize())

        self.lc.InsertColumn(0, "Date")
        self.lc.InsertColumn(1, "Comment")
        self.lc.InsertColumn(2, "Amount")

        self.currentItem = 0
        EVT_LIST_ITEM_SELECTED(self, tID, self.OnItemSelected)
        EVT_LEFT_DCLICK(self.lc, self.OnDoubleClick)

        menu = parent.MakeMenu(true)
        self.SetMenuBar(menu)
        EVT_MENU(self, editID, self.OnEdit)
        EVT_CLOSE(self, self.OnCloseWindow)

        self.UpdateView()</pre>


<p><A href="pythonwin32_snode161.html#31">Figure 20.11</a> shows the application is progressing
nicely and starting to look like a serious Windows application.</p>



<cENTEr>
<h5>
<a name="31"></a>Figure 20.11. The list of Doubletalk transactions</h5>

<img border="0" widTH="502" HEIGhT="303" src="FILES/ppw.2011.gif" AlT="figs/ppw.2011.gif"></CENTEr>


<p>The <tt CLASs="monofont">wxListCtrl</tt> has many personalities, but they
should all be familiar to you. Underneath its
<tT CLAss="monofont">wxPython</tt> wrappers, it's the same control
used in Windows Explorer in the right side panel. All the same
options are available: large icons, small icons, list mode, and the
report mode used here. You define the columns with their headers and
then set some events for the list control. You want to be able to
edit the transactions when they are double-clicked, so why are both
event handlers needed? The list control sends an event when an item
is selected, but it doesn't keep track of double-clicks. The
base <TT CLass="monofont">wxWindow</tt> class, on the other hand, reports
double-clicks, but it knows nothing about the list control. So by
catching both events you can easily implement the functionality you
need. Here is the code for the event handlers:</p>



<pre class="monofont">    def OnItemSelected(self, event):
        self.currentItem = event.m_itemIndex

    def OnDoubleClick(self, event):
        self.OnEdit()</pre>


<p>After creating and setting up the list control, you create a menubar
for this frame. Here you call the menu-making method in the parent,
asking it to add the Edit Transaction menu item.</p>



<p>The last thing the <tT CLASS="monofont">__init__</tT> method does is call
a method to fill the list control from the
<Tt CLaSS="monofont">BookSet</TT>. We've split this into a separate
method so it can be called independently whenever the
<TT clasS="monofont">BookSet</TT> data changes. Here's the
<Tt claSS="monofont">UpdateView</TT> method:</p>



<pre CLASs="monofont">    def UpdateView(self):
        self.lc.DeleteAllItems()
        for x in range(len(self.bookset)):
            trans = self.bookset[x]
            self.lc.InsertStringItem(x, trans.getDateString())
            self.lc.SetStringItem(x, 1, trans.comment)
            self.lc.SetStringItem(x, 2, str(trans.magnitude()))

        self.lc.SetColumnWidth(0, wxLIST_AUTOSIZE)
        self.lc.SetColumnWidth(1, wxLIST_AUTOSIZE)
        self.lc.SetColumnWidth(2, wxLIST_AUTOSIZE)

        self.SetTitle("Journal view - %d transactions" %
                      len(self.bookset))</pre>


<p>Putting data in a list control is fairly easy; just insert each item.
For the report mode, you insert an item for the first column and then
set values for the remaining columns. For each column in the example,
just fetch some data from the transaction and send it to the list
control. If you were using icons or combination of icons and text,
there are different methods to handle that.</p>



<p>Now that there's data in the list control, you should resize
the columns. You can either specify actual pixel widths or have the
list auto-size the columns based on the widths of the data.</p>



<p>The last thing the <tt class="monofont">JournalView</tt> class needs to do
is to enable the editing of the transactions. We saw previously that
when an item is double-clicked, a method named
<tt cLASS="monofont">OnEdit</TT> is invoked. Here it is:</p>



<PRe CLaSS="monofont">    def OnEdit(self, *event):
        if self.currentItem:
            trans = self.bookset[self.currentItem]
            dlg = EditTransDlg(self, trans,
                               self.bookset.getAccountList())
            if dlg.ShowModal() == wxID_OK:
                trans = dlg.GetTrans()
                self.bookset.edit(self.currentItem, trans)
                self.parent.UpdateViews()
            dlg.Destroy()</PRE>


<P>This looks like what we did with the file dialog in the main frame,
and indeed you will find yourself using this pattern quite often when
using dialogs. The one item to notice here is the call to
<tt clASS="monofont">UpdateViews()</Tt> in the parent window. This is how to
manage keeping all the views of the <tt cLASS="monofont">BookSet</tt> up to
date. Whenever a transaction is updated, this method is called and
then loops through all open views, telling the views to update
themselves with their<tt CLASs="monofont"></tt>
<a name="idx2021"></a> <tt class="monofont">UpdateView()</tt>
method.</p>



<p><a NAME="32"></A><TaBLe CElLSPACIng="0" wiDTH="90%" BordeR="1"><TR><Td>
<cenTER><H2>
wxPython Window Layout</h2></center>


<p><tt class="monofont">wxPython</tt>
<a namE="idx2022"></A> includes a number of powerful
techniques for controlling the layout of your windows and controls.
There are several alternative mechanisms provided and potentially
several ways to accomplish the same thing. This allows the programmer
to use whichever mechanism works best in a particular situation or
whichever they are most comfortable with.</P>



<A NAmE="idx2023"></A><dL>
<Dt>
<I><FONT Color="#990000">Constraints</FONT></i></dt>
<dD>
<P>There is a class called
<TT clasS="monofont">wxLayoutConstraints</TT>
<A name="idx2023"></a> that allows the specification of a
window's position and size in relationship to its siblings and
its parent. Each <tt class="monofont">wxLayoutContraints</tt> object is
composed of eight <tt class="monofont">wxIndividualLayoutConstraint</TT>
objects, which define different sorts of relationships, such as which
window is above this window, what is the relative width of this
window, etc. You usually have to specify four of the eight individual
constraints in order for the window to be fully constrained. For
example, this button will be positioned in the center of its parent
and will always be 50% of the parent's width:</P>



<PRE cLAsS="monofont">b = wxButton(self.panelA, 100, ' Panel A `)
lc = wxLayoutConstraints()
lc.centreX.SameAs   (self.panelA, wxCentreX)
lc.centreY.SameAs   (self.panelA, wxCentreY)
lc.height.AsIs      ()
lc.width.PercentOf  (self.panelA, wxWidth, 50)
b.SetConstraints(lc);</PrE>
</DD>
<DT>
<I><font COLOr="#990000">Layout algorithm</fonT></I></DT>
<dd>
<p>The class named <tT CLAss="monofont">wxLayoutAlgorithm</tt> implements
layout of subwindows in MDI or SDI frames. It sends a
<tt class="monofont">wxCalculateLayoutEvent</tt> to children of the frame,
asking them for information about their size. Because the event
system is used this technique can be applied to any window, even
those that aren't necessarily aware of the layout classes.
However, you may wish to use <tt class="monofont">wxSashLayoutWindow</tT>
for your subwindows since this class provides handlers for the
required events and accessors to specify the desired size of the
window. The sash behavior in the base class can be used, optionally,
to make the windows user-resizable.
<TT CLAsS="monofont">wxLayoutAlgorithm</Tt> is typically used in IDE style
of applications, where there are several resizable windows in
addition to the MDI client window or other primary editing window.
Resizable windows might include toolbars, a project window, and a
window for displaying error and warning messages.</P>
</Dd>
<DT>
<I><FONt colOR="#990000">Sizers</FOnt></i></dT>
<DD>
<P>In an effort to simplify the programming of simple layouts, a family of wxSizer classes has been added to the wxPython library. These are classes that are implemented in pure Python instead of wrapping C++ code from wxWindows. They are somewhat reminiscent of the layout managers from Java in that you select the type of sizer you want and then add windows or other sizers to it, and they all follow the same rules for layout. For example, this code fragment creates five buttons that are laid out horizontally in a box, and the last button is allowed to stretch to fill the remaining space allocated to the box:</p>


<pre CLASs="monofont">box = wxBoxSizer(wxHORIZONTAL)
box.Add(wxButton(win, 1010, "one"), 0)
box.Add(wxButton(win, 1010, "two"), 0)
box.Add(wxButton(win, 1010, "three"), 0)
box.Add(wxButton(win, 1010, "four"), 0)
box.Add(wxButton(win, 1010, "five"), 1)</pre></dd>
<dt>
<i><font color="#990000">Resources</fonT></I></DT>
<DD>
<p>
The wxWindows library has a simple dialog editor available that can assist with the layout of controls on a dialog and generates a portable cross-platform resource file. This file can be loaded into a program at runtime and transformed on the fly into a window with the specified controls on it. The only downfall with this approach is that you don't have the opportunity to subclass the windows that are generated, but if you can do everything you need with existing control types and event handlers, it should work out great. Eventually, there will be a wxPython-specific application builder tool that will generate either a resource type of file or actual Python source code for you.</P>
</Dd>
<DT>
<i><FONT COlor="#990000">Brute force</fONT></I></dt>
<dd>
<P>
Finally, there is the brute-force mechanism of specifying the exact position of every component programmatically. Sometimes the layout needs of a window don't fit with any of the sizers or don't warrant the complexity of the constraints or the layout algorithm. For these situations, you can fall back on doing it "by hand," but you probably don't want to attempt it for anything much more complex than the Edit Transaction dialog.</P>
</DD>
</dl>


</td></TR></TAble></p>






<h5>20.3.4.7
wxDialog and friends</h5>


<p>
<a name="idx2024"></a>The
next step is to build a dialog to edit a
<a name="idx2025"></a>transaction.
As you've seen, the transaction object is composed of a date, a
comment, and a variable number of transaction lines each of which has
an account name and an amount. We know that all the lines should add
up to zero and that the date should be a valid date. In addition to
editing the date and comment, you need to be able to add, edit, and
delete lines. <a href="pythonwin32_snode161.html#35">Figure 20.12</A> shows one possible layout
for this dialog and the one used for this example.</P>



<CeNTeR>
<H5>
<a NAME="35"></A>Figure 20.12. The wxPython Doubletalk transaction editor</H5>

<img bORDEr="0" widTH="502" HEight="259" src="FILES/ppw.2012.gif" Alt="figs/ppw.2012.gif"></center>


<p>Since there's quite a bit going on here, let's go through
the initialization of this class step by step. Here's the first
bit:</p>



<pre class="monofont">class EditTransDlg(wxDialog):
    def __init__(self, parent, trans, accountList):
        wxDialog.__init__(self, parent, -1, "")
        self.item = -1
        if trans:
            self.trans = copy.deepcopy(trans)
            self.SetTitle("Edit Transaction")
        else:
            self.trans = Transaction()
            self.trans.setDateString(dates.ddmmmyyyy(self.trans.date))
            self.SetTitle("Add Transaction")</pre>


<P>This is fairly simple stuff. Just invoke the parent class's
<TT CLAsS="monofont">__init__</Tt> method, do some initialization, and
determine if you're editing an existing transaction or creating
a new one. If editing an existing transaction, use the Python copy
module to make a copy of the object. You do this because you will be
editing the transaction in-place and don't want to have any
partially edited transactions stuck in the
<TT cLASS="monofont">BookSet</TT>. If the dialog is being used to add a new
transaction, create one, and then fix its date by truncating the time
from it. The default date in the transaction includes the current
time, but this dialog is equipped to deal only with the date portion.</p>



<p>If you review the sidebar <a href="pythonwin32_snode161.html#32">wxPython Window Layout</A>, you'll see a
number of choices available, but we have chosen to use the brute-force
mechanism for the Edit Transaction dialog:</p>



<pre CLASs="monofont"># Create some controls
wxStaticText(self, -1, "Date:", wxDLG_PNT(self, 5,5))
self.date = wxTextCtrl(self, ID_DATE, "",
                  wxDLG_PNT(self, 35,5), wxDLG_SZE(self, 50,-1))

    wxStaticText(self, -1, "Comment:", wxDLG_PNT(self, 5,21))
    self.comment = wxTextCtrl(self, ID_COMMENT, "",
                      wxDLG_PNT(self, 35, 21), wxDLG_SZE(self, 195,-1)</pre>


<P>The code shows how to create the labels and the text fields at the
top of the dialog. Notice the use of <TT Class="monofont">wxDLG_PNT</tt> and
<tt class="monofont">wxDLG_SZE</tt> to convert dialog units to a
<tt clasS="monofont">wxPoint</TT> and a <TT ClASs="monofont">wxSize</TT>,
respectively. (The -1's used above mean that the default size
should be used for the height.) Using dialog units instead of pixels
to define the dialog means you are somewhat insulated from changes in
the font used for the dialog, so you use dialog units wherever
possible. The <tT CLASS="monofont">wxPoint</tt> and
<tt CLASs="monofont">wxSize</tt> are always defined in terms of pixels, but
these conversion functions allow the actual number of pixels used to
vary automatically from machine to machine with different fonts. This
makes it easy to move programs between platforms that have completely
different window managers. <a href="pythonwin32_snode161.html#36">Figure 20.13</a> shows this
same program running on RedHat Linux 6.0, and you can see that for
the most part, the controls are still spaced appropriately even
though a completely different font is used on the form. It looks like
the <tt cLASS="monofont">wxTextCtrl</tt> is a few dialog units taller on
this platform, so perhaps there should be a bit more space between
the rows. We leave this as an exercise for you.</p>



<center>
<h5>
<a name="36"></a>Figure 20.13. The wxPython Doubletalk editor running on Redhat Linux 6.0</h5>

<img bORDER="0" WiDTh="502" HEiGHT="380" src="FILES/ppw.2013.gif" alt="figs/ppw.2013.gif"></cENTEr>


<p>The next control to be defined is the <tt CLASs="monofont">wxListCtrl</tt>
that displays the account and amount lines:</p>



<PRE Class="monofont">    self.lc = wxListCtrl(self, ID_LIST,
                         wxDLG_PNT(self, 5,34), wxDLG_SZE(self, 225,60),
                         wxLC_REPORT)

    self.lc.InsertColumn(0, "Account")
    self.lc.InsertColumn(1, "Amount")
    self.lc.SetColumnWidth(0, wxDLG_SZE(self, 180,-1).width)
    self.lc.SetColumnWidth(1, wxDLG_SZE(self,  40,-1).width)</pre>


<p>It's important to note that the width of this control is 225
dialog units. Since this control spans the entire width of the
dialog, you know the space you have to work with. You can use this
value when deciding where to place or how to size the other controls.</p>



<p>Instead of auto-sizing the width of the list columns, let's now
use explicit sizes. But you can still use dialog units to do it by
extracting the <tt class="monofont">width</tt> attribute from the
<tt CLASS="monofont">wxSize</Tt> object returned from
<TT cLAsS="monofont">wxDLG_SZE</TT>. We should mention the following points:</P>



<UL>
<li><p>The balance field is disabled, as you only want to use it to display
a value.</p>
</LI>
<LI><p>Use a <tt cLASS="monofont">wxStaticLine</tt> control for drawing the line
across the dialog.</p>
</lI>
<LI><P>A <tt class="monofont">wxComboBox</tt> is used for selecting existing
account names from a list.</p>
</li>
<li><p>Use the standard IDs <tt clasS="monofont">wxID_OK</TT> and
<TT ClASs="monofont">wxID_CANCEL</TT> for OK and Cancel buttons,
respectively, and force the OK button as the default button.</p>
</LI>
<LI><P>Call the base class <Tt claSS="monofont">Fit()</TT> method to determine the
initial size of the dialog window. This function calculates the total
required size based on the size information specified in each of the
children.</p>
</li>
</uL>
<P>Here's the rest of the code for creating the controls:</P>



<Pre clASS="monofont">    wxStaticText(self, -1, "Balance:", wxDLG_PNT(self, 165,100))
    self.balance = wxTextCtrl(self, ID_BAL, "",
                              wxDLG_PNT(self, 190,100), 
                              wxDLG_SZE(self, 40, -1))
    self.balance.Enable(false)

    wxStaticLine(self, -1, wxDLG_PNT(self, 5,115), 
                           wxDLG_SZE(self, 225,-1))

    wxStaticText(self, -1, "Account:", wxDLG_PNT(self, 5,122))
    self.account = wxComboBox(self, ID_ACCT, "",
                       wxDLG_PNT(self, 30,122), wxDLG_SZE(self, 130,-1),
                       accountList, wxCB_DROPDOWN | wxCB_SORT)

    wxStaticText(self, -1, "Amount:", wxDLG_PNT(self, 165,122))
    self.amount = wxTextCtrl(self, ID_AMT, "",
                         wxDLG_PNT(self, 190,122), 
                         wxDLG_SZE(self, 40, -1))

    btnSz = wxDLG_SZE(self, 40,12)
    wxButton(self, ID_ADD, "&amp;Add Line", wxDLG_PNT(self, 52,140), btnSz)
    wxButton(self, ID_UPDT, "&amp;Update Line", wxDLG_PNT(self, 97,140),
             btnSz)
    wxButton(self, ID_DEL, "&amp;Delete Line", wxDLG_PNT(self, 142,140),
             btnSz)

    self.ok = wxButton(self, wxID_OK, "OK", wxDLG_PNT(self, 145,5),
                       btnSz)
    self.ok.SetDefault()
    wxButton(self, wxID_CANCEL, "Cancel", wxDLG_PNT(self, 190,5), btnSz)

    # Resize the window to fit the controls
    self.Fit()</Pre>


<p>The last thing to do is set up some event handlers and load the
dialog controls with data. The event handling for the controls is
almost identical to the menu handling discussed previously, so there
shouldn't be any surprises:</p>



<pre class="monofont">    # Set some event handlers
    EVT_BUTTON(self, ID_ADD,  self.OnAddBtn)
    EVT_BUTTON(self, ID_UPDT, self.OnUpdtBtn)
    EVT_BUTTON(self, ID_DEL,  self.OnDelBtn)
    EVT_LIST_ITEM_SELECTED(self,   ID_LIST, self.OnListSelect)
    EVT_LIST_ITEM_DESELECTED(self, ID_LIST, self.OnListDeselect)
    EVT_TEXT(self, ID_DATE, self.Validate)

    # Initialize the controls with current values
    self.date.SetValue(self.trans.getDateString())
    self.comment.SetValue(self.trans.comment)
    for x in range(len(self.trans.lines)):
        account, amount, dict = self.trans.lines[x]
        self.lc.InsertStringItem(x, account)
        self.lc.SetStringItem(x, 1, str(amount))

    self.Validate()</pre>


<p>The last thing the code snippet does is call a
<tt claSS="monofont">Validate()</TT>
<A NaME="idx2026"></a> method, which as you can probably guess,
is responsible for validating the dialog data; in this case,
validating the date and that all transaction lines sum to zero. Check
the date when the field is updated (via the
<TT cLASS="monofont">EVT_TEXT()</TT> call shown in the code) and check the
balance any time a line is added or updated. If anything
doesn't stack up, disable the OK button. Here is
<tt clASS="monofont">Validate</Tt>:</p>



<prE CLAss="monofont">def Validate(self, *ignore):
    bal = self.trans.balance()
    self.balance.SetValue(str(bal))
    date = self.date.GetValue()
    try:
        dateOK = (date == dates.testasc(date))
    except:
        dateOK = 0

    if bal == 0 and dateOK:
        self.ok.Enable(true)
    else:
        self.ok.Enable(false)</prE>


<P>Notice that the balance field is updated. The next thing we
demonstrate is the Add Line functionality. To do this, you need to
take whatever is in the account and amount fields, add them to the
transaction, and also add them to the list control:</P>



<Pre class="monofont">def OnAddBtn(self, event):
    account = self.account.GetValue()
    amount = string.atof(self.amount.GetValue())
    self.trans.addLine(account, amount)

    # update the list control
    idx = len(self.trans.lines)
    self.lc.InsertStringItem(idx-1, account)
    self.lc.SetStringItem(idx-1, 1, str(amount))

    self.Validate()
    self.account.SetValue("")
    self.amount.SetValue("")</pre>


<p>You call <tt class="monofont">Validate</tt> again to check if the
transaction's lines are in balance. The event handlers for the
Update and Delete buttons are similar and not shown here.</p>



<P>That's about all there is to it! <TT CLAsS="monofont">wxPython</Tt>
takes care of the tab-traversal between fields, auto-completion on
the Enter key, auto-cancel on Esc, and all the<A NaME="idx2027"></A> rest.<A NAme="idx2028"></a> <a NAME="idx2029"></a></p>








<h4>20.3.5
wxPython Conclusion</h4>


<P>This small section has barely touched the surface of what
<TT Class="monofont">wxPython</TT> is capable of. There are many more window
and control types than what have been shown here, and the advanced
features lend themselves to highly flexible and dynamic GUI
applications across many platforms. Combined with the flexibility of
Python, you end up with a powerful tool for quickly creating
world-class applications.</P>



<P>For more information on <tt class="monofont">wxPython</tt>, including
extensive documentation and sample code, see the
<tt class="monofont">wxPython</tt> home page at
<a naME="idx2030"></A><A TArGEt="_blank" HReF="http://http://../alldunn.com/wxPython/default.htm">http://alldunn.com/wxPython/</A>.</P>



<P>For more information on the underlying
<TT clasS="monofont">wxWindows</TT>
<A name="idx2031"></A>
framework, please visit its home page at<A NAme="idx2032"></a> <a NAME="idx2033"></a> <a target="_blank" href="http://www.wxwindows.org/default.htm">http://www.wxwindows.org/</a>.<a name="idx2034"></a></p>


</fONT>
 
<table width="100%" border="0" cellspacing="0" cellpadding="0" bgcolor="#CCCCCC">
<td><font color="black" size=1>I l<font color="#FF0000">@</font>ve RuBoard</td>
<td valign="top" class="v2" align="right"><a href="pythonwin32_snode160.html"><img src="FILES/previous.gif" width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a> <a href="pythonwin32_cnode162.html"><img src="FILES/next.gif" width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a></td></table>
</BODY></HTML>