<HTML><HEAD><META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=iso-8859-1">
<!--SafClassName="docSection1Title"--><!--SafTocEntry="A.3 Built-in Functions"-->
<LINK REL="stylesheet" href="FILES/sbolM.css">
</HEAD>
<BODY link="#354278" vlink="#000066" alink="#000080" topmargin="0">
<table width="100%" border="0" cellspacing="0" cellpadding="0" bgcolor="#CCCCCC">
<td><font color="black" size=1>I l<font color="#FF0000">@</font>ve RuBoard</td>
<td valign="top" class="v2" align="right"><a href="pythonwin32_snode183.html"><img src="FILES/previous.gif" width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a> <a href="pythonwin32_snode185.html"><img src="FILES/next.gif" width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a></td></table>
<FONT>
<h3>A.3
Built-in Functions </h3>


<p>
<a NAME="idx2183"></a>The Python interpreter has a number of
built-in functions that are always available. They are listed here in
alphabetical order:</p>



<dl>
<DT>
<FOnt coLOR="#990000"><Font color="#990000"><span class="monofont">__import__(</span></FONT>

     
  <TT cLAsS="monofont"><I>name[,</i></TT> <FONT coloR="#990000"><SPAn claSS="monofont">globals</SPan></foNT>

     
  <TT class="monofont"><i>[,</i></tt> <font color="#990000"><spaN CLASS="monofont">locals</sPAn></FOnT>

     
  <TT CLAss="monofont"><i>[,</i></TT> <TT clasS="monofont"><I>fromlist]]]</I></Tt><fonT COLor="#990000"><span class="monofont">)</span></font>

     
  </foNT></DT>
<DD>
<p>This function is invoked by the <TT cLAsS="monofont">import</TT> statement.
It exists so that you can replace it with another function that has a
compatible interface, in order to change the semantics of the
<TT Class="monofont">import</TT> statement. For examples of why and how
you'd do this, see the standard library modules
<TT clasS="monofont">ihooks</TT> and <Tt claSS="monofont">rexec</TT>. See also the
built-in module <tt class="monofont">imp</tt> that defines some useful
operations from which you can build your own <tt class="monofont">__import__()</tt> function.</p>


<p>For example, the statement <tT CLASS="monofont">import</tT>
<Tt CLaSS="monofont">spam</TT> results in the call <TT clasS="monofont">__import_
_('spam',</TT> <Tt claSS="monofont">globals(),</TT>
<tt clASS="monofont">locals(),</Tt> <tt class="monofont">[])</tt>; the statement
<tt class="monofont">from</tt> <tt CLASS="monofont">spam.ham</Tt>
<TT cLAsS="monofont">import</TT> <TT Class="monofont">eggs</TT> results in
<TT clasS="monofont">__import__('spam.ham',</TT>
<Tt claSS="monofont">globals(),</TT>
<tt class="monofont">locals(),['eggs']</tt>). Even though
<tt class="monofont">locals()</tt> and <tt cLASS="monofont">['eggs']</TT> are
passed in as arguments, the <tT ClASs="monofont">__import__()</TT>
function doesn't set the local variable named
<TT CLass="monofont">eggs</tT>; this is done by subsequent code that's
generated for the import statement. (In fact, the standard
implementation doesn't use its <TT Class="monofont">locals</TT>
argument at all, and uses its <TT clasS="monofont">globals</TT> only to
determine the package context of the <Tt class="monofont">import</tt>
statement.)</p>



<p>When the name variable is of the form
<tt class="monofont"><i>package.module</i></tt>, normally, the top-level
package (the name up to the first dot) is returned, not the module
named by <TT CLASs="monofont">name</TT>. However, when a nonempty
<tT ClASS="monofont">fromlist</TT> argument is given, the module named by
<Tt claSS="monofont">name</TT> is returned. This is done for compatibility
with the bytecode generated for the different kinds of
<tt clASS="monofont">import</Tt> statement; when using
<tt cLASS="monofont">import</tt> <tt class="monofont">spam.ham.eggs</tt>, the
top-level package <tt class="monofont">spam</tt> must be placed in the
importing namespace, but when using <tT CLASS="monofont">from</tT>
<Tt CLaSS="monofont">spam.ham</TT> <TT clasS="monofont">import</TT>
<Tt claSS="monofont">eggs</TT>, the <tt clASS="monofont">spam.ham</Tt> subpackage
must find the <tt class="monofont">eggs</tt> variable. As a workaround for
this behavior, use <tt class="monofont">getattr()</tt> to extract the
desired components. For example, you could define the following
helper:</p>



<pRE CLASs="monofont">import string
def my_import(name):
    mod = __import__(name)
    components = string.split(name, '.')
    for comp in components[1:]:
        mod = getattr(mod, comp)
    return mod</PRe></DD>
<dT>
<FONT Color="#990000"><FONT coloR="#990000"><SPAn claSS="monofont">abs(</SPan></font>

     
  <tt class="monofont"><i>x</i></tt><font COLOR="#990000"><SpAN cLAsS="monofont">)</SPAN></Font>

     
  </fONT></Dt>
<dd>
<p>Returns the absolute value of a number. The argument may be a plain
or long integer or a floating-point number. If the argument is a
complex number, its magnitude is returned.</P>
</DD>
<Dt>
<fonT COLor="#990000"><font color="#990000"><span class="monofont">apply(</sPAN></FONt>

     
  <TT cLAsS="monofont"><I>function,</I></TT> <Tt claSS="monofont"><I>args[,</I></tt> <tt CLASs="monofont"><i>keywords]</i></tT><FONt color="#990000"><span class="monofont">)</span></foNT>

     
  </FONT></dT>
<Dd>
<P>The <Tt CLASS="monofont"><I>function</i></tt> argument must be a callable
object (a user-defined or built-in function or method, or a class
object), and the <tT CLAss="monofont"><i>args</i></TT> argument must be a
sequence (if it's not a tuple, the sequence is first converted
to a tuple). The function is called with
<TT clasS="monofont"><I>args</I></Tt> as the argument list; the number of
arguments is the length of the tuple. (This is different from just
calling
<tt class="monofont">func(</tt><tt class="monofont"><i>args</i></tt><TT CLASs="monofont">)</TT>,
since in that case, there's always exactly one argument.) If
the optional <tT ClASS="monofont"><I>keywords</I></Tt> argument is present,
it must be a dictionary whose keys are strings. It specifies keyword
arguments to be added to the end of the argument list.</p>
</dd>
<DT>
<FOnt coLOR="#990000"><Font cOLOR="#990000"><span class="monofont">buffer(</span></font>

     
  <tt clASS="monofont"><I>object[,</I></Tt> <TT cLAsS="monofont"><I>offset[,</I></TT> <Tt claSS="monofont"><I>size]]</I></tt><foNT COlor="#990000"><sPAN Class="monofont">)</span></font>

     
  </font></dt>
<dd>
<p>The <TT CLASs="monofont"><I>object</I></tT> argument must be an object that
supports the buffer call interface (such as strings, arrays, and
buffers). A new buffer object is created that references the
<Tt CLASS="monofont"><I>object</i></tt> argument; that buffer object is a
slice from the beginning of <tT CLAss="monofont"><i>object</i></TT> (or
from the specified <TT clasS="monofont"><I>offset</I></Tt>). The slice
extends to the end of <tt class="monofont"><i>object</i></tt> (or has a
length given by the <tt class="monofont"><i>size</i></TT> argument).</P>
</DD>
<Dt>
<FOnT CoLOR="#990000"><FONt colOR="#990000"><SPan clASS="monofont">callable(</Span></fONT>

     
  <Tt class="monofont"><i>object</i></tt><font color="#990000"><spAN CLASs="monofont">)</SPaN></FoNT>

     
  </FONT></dt>
<dd>
<P>Returns <TT Class="monofont">true</TT> if the
<TT clasS="monofont"><I>object</I></Tt> argument appears callable,
<tt class="monofont">false</tt> if not. If it returns
<tt class="monofont">true</tt>, it's still possible that a call fails,
but if it's <tt CLASS="monofont">false</Tt>, the calling object never
succeeds. Note that classes are callable (calling a class returns a
new instance); class instances are callable if they have a <TT cLAsS="monofont">_
_call__()</TT> method.</P>
</DD>
<dt>
<foNT COlor="#990000"><fONT Color="#990000"><SPAN class="monofont">chr(</span></font>

     
  <tt class="monofont"><i>i</I></TT><FONt COlOR="#990000"><sPAN CLAss="monofont">)</spAN></FOnt>

     
  </foNT></DT>
<dd>
<p>Returns a string of one character whose ASCII code is the integer
<tT CLAss="monofont"><i>i</i></tt>, e.g., <tt class="monofont">chr(97)</tt>
returns the string <tt clasS="monofont">a</TT>. This is the inverse of
<TT ClASs="monofont">ord()</TT>. The argument must be in the range
[0...255], inclusive.</p>
</DD>
<DT>
<FOnt coLOR="#990000"><Font cOLOR="#990000"><span CLASs="monofont">cmp(</span></font>

     
  <tt class="monofont"><i>x</i></tt><fONT COLoR="#990000"><SpAN cLASS="monofont">,</SPan></foNT>

     
   <TT clasS="monofont"><I>y</I></Tt><fonT COLor="#990000"><span class="monofont">)</span></font>

     
  </foNT></DT>
<DD>
<p>Compares the two objects <TT cLAsS="monofont"><I>x</I></TT> and
<Tt claSS="monofont"><I>y</I></tt> and returns an integer according to the
outcome. The return value is negative if <tt CLASs="monofont"><i>x</i></tT>
&lt; <TT Class="monofont"><i>y</i></tt>, zero if
<tt class="monofont"><i>x</i></tt> <tt CLASS="monofont">==</Tt>
<TT cLAsS="monofont"><I>y</I></TT>, and strictly positive if
<Tt claSS="monofont"><I>x</I></tt> <tt CLASs="monofont">&gt;</tt>
<tT CLAss="monofont"><i>y</i></tt>.</p>
</dd>
<dt>
<font color="#990000"><fONT COLoR="#990000"><SpAN cLASS="monofont">coerce(</SPan></foNT>

     
  <TT clasS="monofont"><I>x,</I></Tt> <tt cLASS="monofont"><i>y</i></tt><font color="#990000"><span clasS="monofont">)</SPAN></FoNT>

     
  </fONt></DT>
<DD>
<P>Returns a tuple consisting of the two numeric arguments converted to
a common type, using the same rules used by arithmetic operations.</P>
</dd>
<dt>
<FONT coloR="#990000"><FONt colOR="#990000"><SPan class="monofont">compile(</span></font>

     
  <tt clasS="monofont"><I>string,</I></TT> <Tt CLaSS="monofont"><i>filename,</I></TT> <TT Class="monofont"><I>kind</I></TT><font COLOr="#990000"><spaN CLAss="monofont">)</span></font>

     
  </font></dt>
<dd>
<p>Compiles the <tt CLASS="monofont"><I>string</i></TT> into a code object.
Code objects can be executed by an <tT ClASS="monofont">exec</TT> statement
or evaluated by a call to <Tt claSS="monofont">eval()</TT>. The
<tt clASS="monofont"><I>filename</i></tt> argument should give the file
from which the code was read; pass <tT CLAss="monofont"><i>string</i></tt>
if it wasn't read from a file. The
<tt class="monofont"><i>kind</i></tt> argument specifies what kind of code
must be compiled; it can be <tt clASS="monofont">exec</TT> if
<Tt CLaSS="monofont"><i>string</I></TT> consists of a sequence of
statements, <TT Class="monofont">eval</TT> if it consists of a single
expression, or <TT clasS="monofont">single</TT> if it consists of a single
interactive statement (in the latter case, expression statements that
evaluate to something other than <Tt claSS="monofont">None</TT> will print).</p>
</dd>
<dt>
<font color="#990000"><font colOR="#990000"><SPAN cLAsS="monofont">complex(</SpAN></FONT>

     
  <tt clASS="monofont"><I>real[,</i></tt> <tT CLAss="monofont"><i>imag]</i></TT><FOnt color="#990000"><span class="monofont">)</span></fONT>

     
  </FONt></DT>
<dD>
<P>Creates a complex number with the value
<tT CLASS="monofont"><i>real</i></tt> <TT CLass="monofont">+</tT>
<TT Class="monofont"><I>imag</I></TT><tt class="monofont">*j</tt> or converts a
string or number to a complex number. Each argument may be any
numeric type (including complex). If <tt class="monofont"><i>imag</i></tt>
is omitted, it defaults to zero, and the function serves as a numeric
conversion function like <tT CLASS="monofont">int()</tT>,
<Tt CLaSS="monofont">long()</TT>, and <TT clasS="monofont">float()</TT>; in this
case it also accepts a string argument that should be a valid complex
number.</P>
</dd>
<dt>
<FONT coloR="#990000"><FONt color="#990000"><span class="monofont">delattr(</span></foNT>

     
  <TT CLaSS="monofont"><i>object,</I></Tt> <TT CLASs="monofont"><i>name</i></tT><FONt colOR="#990000"><SPan clASS="monofont">)</Span></font>

     
  </font></dt>
<dd>
<p>A relative of <tt claSS="monofont">setattr()</TT>. The arguments are an
<TT cLAsS="monofont"><I>object</i></TT> and a string. The string must be
the <TT CLass="monofont"><i>name</I></TT> of one of the object's
attributes. The function deletes the named attribute, provided the
object allows it. For example, <Tt claSS="monofont">delattr(x,</TT>
<tt clASS="monofont">'foobar')</Tt> is equivalent to
<tt class="monofont">del</tt> <tt class="monofont">x.foobar</tt>.</p>
</dD>
<DT>
<FONt COlOR="#990000"><fONT COLor="#990000"><spAN CLass="monofont">dir(</sPAN></Font>

     
  <tT CLAss="monofont"><i>[object]</i></tt><font color="#990000"><span clASS="monofont">)</SPAn></FOnT>

     
  </FoNT></DT>
<DD>
<p>Without arguments, returns the list of names in the current local
symbol table. With an argument, attempts to return a list of valid
attribute for that object. This information is gleaned from the
object's <tt cLASS="monofont">__dict__ </tt>, <tt CLASs="monofont">__methods__
</tt>, and <tT CLAss="monofont">__members__</tt> attributes, if
defined. The list is not necessarily complete; e.g., for classes,
attributes defined in base classes aren't included, and for
class instances, methods aren't included. The resulting list is
sorted alphabetically. For example:</p>



<pre class="monofont">&gt;&gt;&gt; import sys
&gt;&gt;&gt; dir()
['sys']
&gt;&gt;&gt; dir(sys)
['argv', 'exit', 'modules', 'path', 'stderr', 'stdin', 'stdout']
&gt;&gt;&gt;</pre></dd>
<dt>
<fONT COLoR="#990000"><FoNT cOLOR="#990000"><SPan clASS="monofont">divmod(</Span></fONT>

     
  <Tt claSS="monofont"><I>a</I></tt><font color="#990000"><span class="monofont">,</sPAN></FONt>

     
   <TT cLAsS="monofont"><I>b</I></TT><Font cOLOR="#990000"><span CLASs="monofont">)</spaN></FONt>

     
  </font></dt>
<dd>
<p>Takes two numbers as arguments and returns a pair of numbers
consisting of their quotient and remainder when using long division.
With mixed operand types, the rules for binary arithmetic operators
apply. For plain and long integers, the result is the same as
<tt class="monofont">(</tt><tt CLASS="monofont"><I>a</i></TT> <tT ClASS="monofont">/</TT>
<Tt claSS="monofont"><I>b</I></tt><tt CLASs="monofont">,</tt>
<tT CLAss="monofont"><i>a</i></tt> <tt class="monofont">%</tt>
<tt clasS="monofont"><I>b</I></TT><Tt CLaSS="monofont">)</tT>. For floating-point
numbers, the result is the same as
<TT CLAss="monofont">(math.floor(</tt><TT CLass="monofont"><i>a</I></TT>
<Tt claSS="monofont">/</TT>
<tt class="monofont"><i>b</i></tt><tt class="monofont">),</tt>
<tT CLASS="monofont"><i>a</I></Tt> <TT cLASS="monofont">%</TT>
<tt clASS="monofont"><I>b</i></tt><tT CLAss="monofont">)</tt>.</P>
</DD>
<Dt>
<font color="#990000"><font color="#990000"><spAN CLASs="monofont">eval(</SPaN></FoNT>

     
  <TT CLass="monofont"><i>expression[,</I></TT> <Font cOLOR="#990000"><span CLASs="monofont">globals</span></font>

     
  <tt class="monofont"><i>[,</i></tt> <fONT COLoR="#990000"><SpAN cLASS="monofont">locals</SPan></foNT>

     
  <TT clasS="monofont"><I>]]</I></Tt><fonT COLor="#990000"><span class="monofont">)</span></font>

     
  </foNT></DT>
<DD>
<p>The arguments are a string and two optional dictionaries. The
<TT cLAsS="monofont"><I>expression</I></TT> argument is parsed and
evaluated as a Python expression (technically speaking, a condition
list) using the <Tt claSS="monofont">globals</TT> and
<tt clASS="monofont">locals</Tt> dictionaries as global and local namespace.
If the <tt cLASS="monofont">locals</tt> dictionary is omitted, it defaults
to the <tt class="monofont">globals</tt> dictionary. If both dictionaries
are omitted, the expression is executed in the environment where
<tt class="monofont">eval</tt> is called. The return value is the result of
the evaluated expression. Syntax errors are reported as exceptions.
Example:</p>



<PRE CLAsS="monofont">&gt;&gt;&gt; x = 1
&gt;&gt;&gt; print eval('x+1')
2</PrE>


<P>This function can also execute arbitrary code objects (e.g., created
by <tT CLASS="monofont">compile())</tt>. In this case, it passes a code
object instead of a string. The code object must have been compiled
passing <tt CLASs="monofont">eval</tt> to the kind argument.</p>



<P>Hints: dynamic execution of statements is supported by the
<TT Class="monofont">exec</TT> statement. Execution of statements from a
file is supported by the <TT class="monofont">execfile()</tt> function. The
<tt class="monofont">globals()</tt> and <tt claSS="monofont">locals()</TT>
functions returns the current global and local dictionary,
respectively, which may be useful to pass around for use by
<TT cLAsS="monofont">eval()</Tt> or <TT CLASs="monofont">execfile()</tt>.</p>
</DD>
<DT>
<font COLOr="#990000"><fonT COLor="#990000"><span class="monofont">execfile(</span></font>

     
  <tt CLASS="monofont"><I>file[,</i></TT> <fONt COLOR="#990000"><Span cLASS="monofont">globals</span></FONT>

     
  <tt clASS="monofont"><I>[,</i></tt> <font color="#990000"><span class="monofont">locals</SPAN></FOnT>

     
  <Tt CLaSS="monofont"><I>]]</I></TT><font COLOr="#990000"><spaN CLAss="monofont">)</spAN></FOnt>

     
  </font></dt>
<dd>
<p>Similar to the <tt class="monofont">exec</tt> statement, but parses a file
instead of a string. It's different from the
<tT CLASS="monofont">import</tT> statement in that it doesn't use the
module administration; it reads the file unconditionally and
doesn't create a new module.<FoNT sIZE="1"><SUP><a hreF="#FOOTNOTE-G">[G]</A></SUp></fonT>
</P>


<BLockqUOTE><font size="1">
<p class="footnote">
<sup><a namE="FOOTNOTE-G">[G]</A></SUP>
It's used
relatively rarely so it doesn't warrant being made into a
statement.</P>
</fONt></BLoCKQUOTe>





<p>The arguments are a filename and two optional dictionaries. The file
is parsed and evaluated as a sequence of Python statements (similar
to a module) using the <tt CLASs="monofont">globals</tt> and
<tT CLAss="monofont">locals</tt> dictionaries as global and local namespace.
If the <TT CLass="monofont">locals</tt> dictionary is omitted, it defaults
to the <tt class="monofont">globals</tt> dictionary. If both dictionaries
are omitted, the expression is executed in the environment where
<tt class="monofont">execfile()</TT> is called. The return value is
<TT CLaSS="monofont">None</tT>.</P>
</dD>
<DT>
<FONt colOR="#990000"><FOnt coLOR="#990000"><Span cLASS="monofont">filter(</span></font>

     
  <tt class="monofont"><i>function,</i></tt> <tt CLASS="monofont"><I>list</i></TT><fONt COLOR="#990000"><Span cLASS="monofont">)</span></FONT>

     
  </font></DT>
<DD>
<p>Constructs a list from those elements of
<tt class="monofont"><i>list</i></tt> for which
<tt class="monofont"><i>function</i></TT> returns <TT CLaSS="monofont">true</tT>.
If <Tt CLASS="monofont"><I>list</i></tt> is a string or a tuple, the result
also has that type; otherwise it's always a list. If
<tT CLAss="monofont"><i>function</i></TT> is <TT clasS="monofont">None</TT>, the
identity function is assumed, i.e., all elements of
<Tt class="monofont"><i>list</i></tt> that are <tt class="monofont">false</tt>
(zero or empty) are removed.</p>
</dD>
<DT>
<FONt COlOR="#990000"><fONT COLor="#990000"><spAN CLass="monofont">float(</sPAN></Font>

     
  <tT CLAss="monofont"><i>x</i></tt><font color="#990000"><span clASS="monofont">)</SPAn></FOnT>

     
  </FoNT></DT>
<DD>
<p>Converts a string or a number to floating point. If the argument is a
string, it must contain a possibly signed decimal or floating-point
number, possibly embedded in whitespace; this behaves identically to
<tt cLASS="monofont">string.atof(</tt><tt CLASs="monofont"><i>x</i></tT><TT Class="monofont">)</tt>.
Otherwise, the argument may be a plain or long integer or a
floating-point number, and a floating-point number with the same
value (within Python's floating-point precision) is returned.</p>



<p>When passing in a string, values for <tt class="monofont">NaN</tt> and
<tt clASS="monofont">Infinity</TT> may be returned, depending on the
underlying C library. The specific set of strings accepted that cause
these values to be returned depends entirely on the C library and is
known to vary.</P>
</dD>
<Dt>
<FOnT COLOR="#990000"><font COLOr="#990000"><spaN CLAss="monofont">getattr(</spAN></FOnt>

     
  <tt class="monofont"><i>object,</i></tt> <tt class="monofont"><i>name</I></TT><FONt COlOR="#990000"><sPAN CLAss="monofont">)</spAN></FOnt>

     
  </foNT></DT>
<dd>
<p>The arguments are an object and a string. The string must be the name
of one of the object's attributes. The result is the value of
that attribute. For example,
<tT CLAss="monofont">getattr(</tt><tt class="monofont"><i>x,</i></tt>
<tt clasS="monofont"><I>'foobar'</I></TT><Tt CLaSS="monofont">)</tT> is equivalent
to <TT CLAss="monofont"><i>x</i></TT><TT clasS="monofont">.foobar</TT>.</P>
</dd>
<dt>
<FONT color="#990000"><font color="#990000"><span claSS="monofont">globals()</SPAN></fONt>
</FOnT></DT>
<DD>
<P>Returns a dictionary representing the current global symbol table.
This is always the dictionary of the current module (inside a
function or method, this is the module where it is defined, not the
module from which it is called).</p>
</dd>
<dT>
<FONt colOR="#990000"><FOnt coLOR="#990000"><Span class="monofont">hasattr(</span></font>

     
  <tt claSS="monofont"><I>object,</I></TT> <tT ClASs="monofont"><I>name</I></TT><FOnt coLOR="#990000"><Span cLASS="monofont">)</span></FONT>

     
  </font></dt>
<dd>
<p>The arguments are an object and a string. The result is 1 if the
string is the name of one of the object's attributes,
if not. (This is implemented by calling
<tt class="monofont">getattr(</tt><tt cLASS="monofont"><I>object,</I></tT>
<Tt CLaSS="monofont"><I>name</I></TT><tt clASS="monofont">)</Tt> and seeing
whether it raises an exception.)</p>
</dd>
<DT>
<FOnt coLOR="#990000"><Font color="#990000"><span class="monofont">hash(</span></FONT>

     
  <TT cLAsS="monofont"><I>object</i></TT><FONT coloR="#990000"><SPAn claSS="monofont">)</SPan></foNT>

     
  </FOnt></dt>
<dd>
<p>Returns the hash value of the object (if it has one). Hash values are
integers. They can quickly compare dictionary keys during a
dictionary lookup. Numeric values that compare equal have the same
hash value (even if they are of different types, e.g., 1 and 1.0).</p>
</dd>
<dt>
<font color="#990000"><FONT COlOR="#990000"><sPAn CLASS="monofont">hex(</Span></fONT>

     
  <Tt claSS="monofont"><I>x</I></tt><foNT COlor="#990000"><span class="monofont">)</span></font>

     
  </fONT></DT>
<Dd>
<P>Converts an integer number (of any size) to a hexadecimal string. The
result is a valid Python expression. This always yields an unsigned
literal, e.g., on a 32-bit machine, <Tt CLaSS="monofont">hex(-1)</TT> yields
'<TT clasS="monofont">0xffffffff</TT>'. When evaluated on a machine with the
same word size, this literal is evaluated as -1; at a different word
size, it may be a large positive number or raise an
<Tt claSS="monofont">OverflowError</TT> exception.</p>
</dd>
<dT>
<FONt color="#990000"><font color="#990000"><span clASS="monofont">id(</SPAn></FOnT>

     
  <Tt CLASS="monofont"><I>object</i></tt><fONT Color="#990000"><SPAN clasS="monofont">)</SPAn></font>

     
  </font></dt>
<dd>
<p>Returns the identity of an object. This is an integer that's
guaranteed to be unique and constant for this object during its
lifetime. Two objects whose lifetimes don't overlap may have
the same <tt class="monofont">id()</TT> value. (Implementation note: this is
the address of the object.)</P>
</DD>
<Dt>
<FOnT CoLOR="#990000"><FONt colOR="#990000"><SPan clASS="monofont">input(</Span></fONT>

     
  <Tt class="monofont"><i>[prompt]</i></tt><font color="#990000"><spAN CLASs="monofont">)</SPaN></FoNT>

     
  </FONT></dt>
<dd>
<P>Equivalent to
<TT Class="monofont">eval(raw_input(</TT><TT clasS="monofont"><I>prompt</I></Tt><tt class="monofont">))</tt>.</p>
</dd>
<dt>
<font coLOR="#990000"><FONt COlOR="#990000"><sPAN CLAss="monofont">intern(</spAN></FOnt>

     
  <tt CLASs="monofont"><i>string</i></tT><FONt color="#990000"><span class="monofont">)</span></foNT>

     
  </FONT></dT>
<Dd>
<P>Enters <Tt CLASS="monofont"><I>string</i></tt> in the table of interned
strings and returns the interned string, which is
<tT CLAss="monofont"><i>string</i></TT> itself or a copy. Interning strings
is useful to gain a little performance on dictionary lookup; if the
keys in a dictionary are interned, and the lookup key is interned,
the key comparisons (after hashing) can be done by a pointer compare
instead of a string compare. Normally, the names used in Python
programs are automatically interned, and the dictionaries that hold
module, class, or instance attributes have interned keys. Interned
strings are immortal (i.e., never get garbage-collected).</P>
</Dd>
<dt>
<fONT Color="#990000"><font color="#990000"><span clasS="monofont">int(</SPAN></FoNT>

     
  <tT ClASS="monofont"><I>x</I></Tt><fonT COLor="#990000"><spAN CLass="monofont">)</sPAN></Font>

     
  </font></dt>
<dd>
<p>Converts a string or number to a plain integer. If the argument is a
string, it must contain a possibly signed decimal number
representable as a Python integer, possibly embedded in whitespace;
this behaves identically to
<tt class="monofont">string.atoi(</tt><TT CLASs="monofont"><I>x</I></tT><Tt CLASS="monofont">).</Tt>
Otherwise, the argument may be a plain or long integer or a
floating-point number. Conversion of floating-point numbers to
integers is defined by the C semantics; normally the conversion
truncates towards zero.<fonT SIZe="1"><sup><A HREf="#FOOTNOTE-H">[H]</a></suP></FONt>
</p>


<blockquote><font size="1">
<p CLASS="footnote">
<SuP><A nAMe="FOOTNOTE-H">[H]</A></SUP>
This is ugly: the language
definition should require truncation towards zero.</P>
</Font></bLOCKquotE>


</DD>
<Dt>
<fonT COLor="#990000"><font color="#990000"><span class="monofont">isinstance(</sPAN></FONt>

     
  <TT cLAsS="monofont"><I>object,</I></TT> <Tt claSS="monofont"><I>class</I></tt><foNT COlor="#990000"><sPAN Class="monofont">)</span></font>

     
  </font></dt>
<dd>
<p>Returns <TT CLASs="monofont">true</TT> if the
<tT ClASS="monofont"><I>object</I></Tt> argument is an instance of the
<tt cLASS="monofont"><i>class</i></tt> argument or of a (direct or
indirect) subclass thereof. Also returns <TT CLass="monofont">true</tT> if
<TT Class="monofont"><i>class</i></tt> is a type object and
<tt class="monofont"><i>object</i></tt> is an object of that type. If
<tt CLASS="monofont"><I>object</i></TT> is not a class instance or an
object of the given type, the function always returns
<tT ClASS="monofont">false</TT>. If <Tt claSS="monofont"><I>class</I></tt> is
neither a class object nor a type object, a
<tt CLASs="monofont">TypeError</tt> exception is raised.</p>
</DD>
<DT>
<font color="#990000"><font color="#990000"><spaN CLASS="monofont">issubclass(</sPAn></FOnT>

     
  <TT CLAss="monofont"><i>class1</i></TT><FOnt coLOR="#990000"><Span cLASS="monofont">,</span></font>

     
   <tt class="monofont"><i>class2</i></tt><foNT COLOr="#990000"><SPaN ClASS="monofont">)</SPAn></fonT>

     
  </FONt></dt>
<dD>
<P>Returns <TT clasS="monofont">true</TT> if <Tt class="monofont"><i>class1</i></tt>
is a subclass (direct or indirect) of
<tt class="monofont"><i>class2</i></tt>. A class is considered a subclass
of itself. If either argument isn't a class object, a
<TT CLASs="monofont">TypeError</TT> exception is raised.</p>
</DD>
<dT>
<FONT Color="#990000"><FONT coloR="#990000"><SPAn claSS="monofont">len(</SPan></font>

     
  <tt class="monofont"><i>s</i></tt><font COLOR="#990000"><SpAN cLAsS="monofont">)</SPAN></Font>

     
  </fONT></Dt>
<dd>
<p>Returns the length (the number of items) of an object. The argument
may be a sequence (string, tuple, or list) or a mapping (dictionary).</P>
</DD>
<Dt>
<fonT COLor="#990000"><font color="#990000"><span class="monofont">list(</sPAN></FONt>

     
  <TT cLAsS="monofont"><I>sequence</I></TT><Font cOLOR="#990000"><span CLASs="monofont">)</spaN></FONt>

     
  </font></dt>
<dd>
<p>Returns a list whose items are the same and in the same order as
<tt class="monofont"><i>sequence </i></tt>'s items. If
<TT CLASs="monofont"><I>sequence</I></tT> is already a list, a copy is made
and returned, similar to
<Tt CLASS="monofont"><I>sequence</i></tt><tT CLAss="monofont">[:]</tt>. For
instance, <TT CLass="monofont">list('abc')</tT> returns
<TT Class="monofont">['a',</tt> <tt class="monofont">'b',</tt>
<tt clasS="monofont">'c']</TT>, and <TT ClASs="monofont">list(</TT>
<tT CLASS="monofont">(1,</tt> <tt CLASs="monofont">2,</tt> <tT CLAss="monofont">3)</tt>
<TT CLass="monofont">)</tt> returns <tt class="monofont">[1,</tt>
<tt class="monofont">2,</TT> <TT CLaSS="monofont">3]</tT>.</P>
</dD>
<DT>
<FONt colOR="#990000"><FOnt coLOR="#990000"><Span cLASS="monofont">locals()</span></font>
</font></dt>
<dd>
<p>Returns a dictionary representing the current local symbol table.
Warning: the contents of this dictionary should not be modified;
changes may not affect the values of local variables used by the
interpreter.</p>
</dd>
<dT>
<FONT CoLOr="#990000"><FOnT COLOR="#990000"><span CLASs="monofont">long(</spaN></FONt>

     
  <tt cLASS="monofont"><i>x</i></tt><font color="#990000"><span clasS="monofont">)</SPAN></FoNT>

     
  </fONt></DT>
<DD>
<P>Converts a string or number to a long integer. If the argument is a
string, it must contain a possibly signed decimal number of arbitrary
size, possibly embedded in whitespace; this behaves identically to
<Tt claSS="monofont">string.atol(</TT><tt clASS="monofont"><I>x</i></tt><tT CLAss="monofont">)</tt>.
Otherwise, the argument may be a plain or long integer or a
floating-point number, and a long integer with the same value is
returned. Conversion of floating-point numbers to integers is defined
by the C semantics; see the description of <tt class="monofont">int()</tt>.</p>
</dd>
<dt>
<fonT COLOR="#990000"><fONt COlOR="#990000"><SPAN clasS="monofont">map(</SPAn></fonT>

     
  <TT Class="monofont"><I>function,</I></TT> <tt class="monofont"><i>list</i></tt><font color="#990000"><sPAN CLAsS="monofont">,</SpAN></fONT>

     
   <FONt colOR="#990000"><SPan clASS="monofont">...)</Span></fONT>

     
  </Font></dt>
<dd>
<p>Applies <tt class="monofont"><i>function</i></tt> to every item of
<tt CLASS="monofont"><I>list</i></TT> and returns a list of the results. If
additional list arguments are passed,
<tT ClASS="monofont"><I>function</I></Tt> must take that many arguments and
is applied to the items of all lists in parallel; if a list is
shorter than another, it's assumed to be extended with
<tt cLASS="monofont">None</tt> items. If <tt CLASs="monofont"><i>function</i></tT>
is <TT Class="monofont">None</tt>, the identity function is assumed; if
there are multiple <tt class="monofont"><i>list</i></tt> arguments,
<tt clASS="monofont">map()</TT> returns a list consisting of tuples
containing the corresponding items from all lists (i.e., a kind of
transpose operation). The list arguments may be any kind of sequence;
the result is always a list.</P>
</dD>
<Dt>
<FOnT COLOR="#990000"><font COLOr="#990000"><spaN CLAss="monofont">max(</spAN></FOnt>

     
  <tt class="monofont"><i>s[,</i></tt> <tt class="monofont"><i>args...]</I></TT><FONt COlOR="#990000"><sPAN CLAss="monofont">)</spAN></FOnt>

     
  </foNT></DT>
<dd>
<p>With a single argument <tT CLAss="monofont"><i>s</i></tt>, returns the
largest item of a nonempty sequence (e.g., a string, tuple, or list).
With more than one argument, returns the largest of the arguments.</p>
</dd>
<dt>
<font color="#990000"><fONT COLoR="#990000"><SpAN cLASS="monofont">min(</SPan></foNT>

     
  <TT clasS="monofont"><I>s[,</I></Tt> <tt cLASS="monofont"><i>args...]</i></tt><font color="#990000"><span clasS="monofont">)</SPAN></FoNT>

     
  </fONt></DT>
<DD>
<P>With a single argument <Tt claSS="monofont"><I>s</I></tt>, returns the
smallest item of a nonempty sequence (e.g., a string, tuple, or
list). With more than one argument, returns the smallest of the
arguments.</p>
</dD>
<DT>
<Font cOLOR="#990000"><font color="#990000"><span class="monofont">oct(</spaN></FONT>

     
  <Tt CLaSS="monofont"><i>x</I></TT><FONt colOR="#990000"><SPan clASS="monofont">)</Span></fONT>

     
  </Font></dt>
<dd>
<p>Converts an integer number (of any size) to an octal string. The
result is a valid Python expression. This always yields an unsigned
literal, e.g., on a 32-bit machine, <tt class="monofont">oct(-1)</tt> yields
<tt clASS="monofont">'037777777777'</TT>. When evaluated on a machine with
the same word size, this literal is evaluated as
<Tt CLaSS="monofont">-1</tT>; at a different word size, it may be a large
positive number or raise an <TT CLAss="monofont">OverflowError</tt>
exception.</P>
</DD>
<Dt>
<fonT COLor="#990000"><foNT COlor="#990000"><span class="monofont">open(</span></font>

     
  <tT CLASS="monofont"><i>filename[,</I></Tt> <TT cLASS="monofont"><I>mode[,</I></tt> <tt CLASs="monofont"><i>bufsize]]</i></tT><FONt colOR="#990000"><SPan class="monofont">)</span></font>

     
  </font></dt>
<DD>
<P>Returns a new file object (described earlier in the section<I>
</I><A href="pythonwin32_snode182.html">Section A.1</A>). The first two
arguments are the same as for <Tt CLASS="monofont">stdio</Tt>'s
<tt cLASS="monofont">fopen()</tt>: <tt CLASs="monofont"><i>filename</i></tT> is
the filename to be opened, <TT Class="monofont"><i>mode</i></tt> indicates
how the file is to be opened: <tt class="monofont">'r'</tt> for reading,
<tt clASS="monofont">'w'</TT> for writing (truncating an existing file), and
<Tt CLaSS="monofont">'a'</tT> opens it for appending (which on some Unix
systems means that all writes append to the end of the file,
regardless of the current seek position).</P>



<P>Modes <TT Class="monofont">'r+'</TT>, <TT clasS="monofont">'w+'</TT>, and
<Tt claSS="monofont">'a+'</TT> open the file for updating (note that
<tt class="monofont">'w+'</tt> truncates the file). Append
<tt class="monofont">'b'</tt> to the mode to open the file in binary mode,
on systems that differentiate between binary and text files (else it
is ignored). If the file can't be opened,
<tt cLASS="monofont">IOError</TT> is raised.</p>



<P>If <Tt CLaSS="monofont"><I>mode</I></TT> is omitted, it defaults to
<tt clASS="monofont">'r'</Tt>. When opening a binary file, you should append
<tt cLASS="monofont">'b'</tt> to the mode value for improved portability.
(It's useful even on systems that don't treat binary and
text files differently, where it serves as documentation.) The
optional <tt CLASs="monofont"><i>bufsize</i></tt> argument specifies the
file's desired buffer size: <tt class="monofont">0</tt> means
unbuffered, <tt class="monofont">1</TT> means line buffered, any other
positive value means use a buffer of (approximately) that size. A
negative <TT CLaSS="monofont"><i>bufsize</I></Tt> means to use the system
default, which is usually line buffered for tty devices and fully
buffered for other files. If omitted, the system default is
used.<FONT SIze="1"><suP><A HRef="#FOOTNOTE-I">[I]</a></sUP></FOnt>
</p>


<bLOCKquote><font size="1">
<p class="footnote">
<suP><A NAME="FOOTNOTE-I">[I]</a></SUp>
Specifying a buffer size currently has no
effect on systems that don't have <TT cLASS="monofont">setvbuf()</TT>.
The interface to specify the buffer size is not done using a method
that calls <tt clASS="monofont">setvbuf()</Tt>, because that may dump core
when called after any I/O has been performed, and there's no
reliable way to determine whether this is the case.</p>
</foNT></BLockqUOTE>


</dd>
<dt>
<font color="#990000"><font coloR="#990000"><SPAN ClASs="monofont">ord(</SPaN></FONT>

     
  <Tt claSS="monofont"><I>c</I></tt><foNT COlor="#990000"><sPAN Class="monofont">)</span></font>

     
  </font></dt>
<dd>
<p>Returns the ASCII value of a string of one character. For example,
<TT CLASs="monofont">ord('a')</TT> returns the integer 97. This is the
inverse of <tT ClASS="monofont">chr()</TT>.</P>
</dd>
<dt>
<FONT coloR="#990000"><FONt colOR="#990000"><SPan class="monofont">pow(x,</span></font>
 <font coLOR="#990000"><SPAn CLaSS="monofont">y[,</sPAN></FONt>
 <fonT COLor="#990000"><spAN CLass="monofont">z])</sPAN></Font>
</font></dt>
<dd>
<p>Returns <tt class="monofont">x</tt> to the power <TT CLASs="monofont">y</TT>; if
<tT ClASS="monofont">z</TT> is present, return <Tt claSS="monofont">x</TT> to the
power <tt clASS="monofont">y</Tt>, modulo <tt cLASS="monofont">z</tt> (computed
more efficiently than <tt class="monofont">pow(x,</tt> <tt class="monofont">y)</tt>
<tT CLASS="monofont">%</tT> <Tt CLaSS="monofont">z)</TT>. The arguments must have
numeric types. With mixed operand types, the rules for binary
arithmetic operators apply. The effective operand type is also the
type of the result; if the result isn't expressible in this
type, the function raises an exception; e.g.,
<TT clasS="monofont">pow(2,</TT> <Tt claSS="monofont">-1)</TT> or
<tt clASS="monofont">pow(2,</Tt> <tt class="monofont">35000)</tt> isn't
allowed.</p>
</dd>
<dt>
<font coLOR="#990000"><FONt COlOR="#990000"><sPAN CLAss="monofont">range(</spAN></FOnt>

     
  <tt CLASs="monofont"><i>[start,]</i></tT> <TT Class="monofont"><i>stop[,</i></tt> <tt class="monofont"><i>step]</i></tt><foNT COLOr="#990000"><SPaN ClASS="monofont">)</SPAn></fonT>

     
  </FONt></dt>
<dD>
<P>This is a versatile function to create lists containing arithmetic
progressions. It is most often used in <TT clasS="monofont">for</TT> loops.
The arguments must be plain integers. If the
<Tt class="monofont"><i>step</i></tt> argument is omitted, it defaults to
1. If the <tt class="monofont"><i>start</i></tt> argument is omitted, it
defaults to 0. The full form returns a list of plain integers
<TT CLASs="monofont">[</TT><tT ClASS="monofont"><I>start</I></Tt><tt cLASS="monofont">,</tt>
<tt CLASs="monofont"><i>start</i></tT> <TT Class="monofont">+</tt>
<tt class="monofont"><i>step</i></tt><tt clASS="monofont">,</TT>
<Tt CLaSS="monofont"><i>start</I></TT> <TT Class="monofont">+</TT>
<TT clasS="monofont">2</TT> <Tt claSS="monofont">*</TT>
<tt class="monofont"><i>step</i></tt><tt class="monofont">,</tt>
<tT CLASS="monofont">...]</tT>. If <Tt CLaSS="monofont"><I>step</I></TT> is
positive, the last element is the largest
<tt clASS="monofont"><I>start</i></tt> <tT CLAss="monofont">+</tt>
<TT CLass="monofont">i</tt> <tt class="monofont">*</tt>
<tt class="monofont"><I>step</I></TT> less than <TT cLAsS="monofont"><I>stop
</i></TT>; if <TT CLass="monofont"><i>step</I></TT> is negative, the
last element is the largest <Tt claSS="monofont"><I>start</I></tt>
<tt CLASs="monofont">+</tt> <tt class="monofont">i</tt> <tt class="monofont">*</tt>
<TT CLASs="monofont"><I>step</I></tT> greater than
<Tt CLASS="monofont"><I>stop</i></tt>. <tT CLAss="monofont"><i>step</i></TT> must
not be zero (or else <TT clasS="monofont">ValueError</TT> is raised).
Here's an example:</P>



<pre class="monofont">&gt;&gt;&gt; range(10)
[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
&gt;&gt;&gt; range(1, 11)
[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
&gt;&gt;&gt; range(0, 30, 5)
[0, 5, 10, 15, 20, 25]
&gt;&gt;&gt; range(0, 10, 3)
[0, 3, 6, 9]
&gt;&gt;&gt; range(0, -10, -1)
[0, -1, -2, -3, -4, -5, -6, -7, -8, -9]
&gt;&gt;&gt; range(0)
[]
&gt;&gt;&gt; range(1, 0)
[]
&gt;&gt;&gt;</pre></dd>
<dt>
<font coLOR="#990000"><FONt COlOR="#990000"><sPAN CLAss="monofont">raw_input(</spAN></FOnt>

     
  <tt CLASs="monofont"><i>[prompt]</i></tT><FONt color="#990000"><span class="monofont">)</span></foNT>

     
  </FONT></dT>
<Dd>
<P>If the <Tt CLASS="monofont"><I>prompt</i></tt> argument is present,
it's written to standard output without a trailing newline. The
function then reads a line from input, converts it to a string
(stripping a trailing newline), and returns that. When EOF is read,
<tT CLAss="monofont">EOFError</tt> is raised. Here's an example:</P>



<PRE clasS="monofont">&gt;&gt;&gt; s = raw_input('--&gt; ')
--&gt; Monty Python's Flying Circus
&gt;&gt;&gt; s
"Monty Python's Flying Circus"
&gt;&gt;&gt;</PRE>


<p>If the <tt class="monofont">readline</tt> module was loaded, then
<tt class="monofont">raw_input()</tt> uses it to provide elaborate
line-editing and history features.</p>
</dD>
<DT>
<FONt COlOR="#990000"><fONT COLor="#990000"><spAN CLass="monofont">reduce(</sPAN></Font>

     
  <tT CLAss="monofont"><i>function,</i></tt> <tt class="monofont"><i>sequence[,</i></tt> <tt clASS="monofont"><I>initializer]</I></Tt><FOnT CoLOR="#990000"><SPAn claSS="monofont">)</SPan></foNT>

     
  </FOnt></dt>
<DD>
<P>Applies <Tt class="monofont"><i>function</i></tt> of two arguments
cumulatively to the items of <tt class="monofont"><i>sequence</i></tt>,
from left to right, so as to reduce the sequence to a single value.
For example, <TT CLASs="monofont">reduce(lambda</TT> <tT ClASS="monofont">x,</TT>
<Tt claSS="monofont">y:</TT> <tt clASS="monofont">x+y,</Tt> <tt cLASS="monofont">[1,</tt>
<tt class="monofont">2,</tt> <tt class="monofont">3,</tt> <tT CLASS="monofont">4,</tT>
<Tt CLaSS="monofont">5])</TT> calculates
<TT clasS="monofont">((((1+2)+3)+4)+5)</TT>. If the optional
<Tt claSS="monofont"><I>initializer</I></tt> is present, it's placed
before the items of the sequence in the calculation and serves as a
default when the sequence is empty.</p>
</dD>
<DT>
<Font color="#990000"><font color="#990000"><span CLASS="monofont">reload(</SpAN></fONt>

     
  <TT CLASs="monofont"><i>module</i></tT><FONt colOR="#990000"><SPan clASS="monofont">)</Span></font>

     
  </font></dt>
<dd>
<p>Reparses and reinitializes an already imported
<tt claSS="monofont"><I>module</I></TT>. The argument must be a module
object, so it must have been successfully imported before. This is
useful if you have edited the module source file using an external
editor and want to try out the new version without leaving the Python
interpreter. The return value is the module object (i.e., the same as
the
<tT ClASs="monofont">mo</TT><TT CLass="monofont"><i>d</I></TT><Tt claSS="monofont">ule</TT>
argument). There are a number of caveats:</p>
</dd>
</dL>


<UL>
<Li><p>If a module is syntactically correct but its initialization fails,
the first <tt class="monofont">import</tt> statement for it doesn't
bind its name locally, but does store a (partially initialized)
module object in <tt class="monofont">sys.modules</tt>. To reload the module
you must first import it again (this binds the name to the partially
initialized module object) before you can <tT CLASS="monofont">reload()</tT>
it.</P>
</lI>
</Ul>
<UL>
<LI><P>When a module is reloaded, its dictionary (containing the
module's global variables) is retained. Redefinitions of names
override the old definitions, so this is generally not a problem. If
the new version of a module doesn't define a name that was
defined by the old version, the old definition remains. This feature
can be used to the module's advantage if it maintains a global
table or cache of objects; with a <Tt claSS="monofont">try</TT> statement it
can test for the table's presence and skip its initialization
if desired.</p>
</li>
</uL>
<UL>
<Li><p>It is legal though generally not useful to reload built-in or
dynamically loaded modules, except for <tt CLASs="monofont">sys</tt>,
<tt class="monofont">__main__</tt> , and <tt class="monofont">__builtin__</tt>.
In certain cases, however, extension modules aren't designed to
be initialized more than once, and may fail in arbitrary ways when
reloaded.</P>
</LI>
</UL>
<Ul>
<LI><p>If a module imports objects from another module using
<TT cLASS="monofont">from</TT> <tt clASS="monofont">... import</Tt>
<tt cLASS="monofont">...</tt>, calling <tt CLASs="monofont">reload()</tt> for the
other module doesn't redefine the objects imported from it; one
way around this is to reexecute the <tt class="monofont">from</tt>
statement, another is to use <tt class="monofont">import</tt> and qualified
names (<TT CLASs="monofont"><I>module.name</I></tT>) instead.</P>
</lI>
</UL>
<UL>
<Li><p>If a module instantiates instances of a class, reloading the module
that defines the class doesn't affect the method definitions of
the instances; they continue to use the old class definition. The
same is true for derived classes.</p>
</lI>
</UL>
<A name="idx2184"></A><DL>
<Dt>
<fonT COLor="#990000"><font color="#990000"><span class="monofont">repr(</sPAN></FONt>

     
  <TT cLAsS="monofont"><I>object</I></TT><Font cOLOR="#990000"><span CLASs="monofont">)</spaN></FONt>

     
  </font></dt>
<dd>
<p>Returns a string containing a printable representation of an object.
This is the same value yielded by conversions (reverse quotes).
It's sometimes useful to be able to access this operation as an
ordinary function. For many types, this function makes an attempt to
return a string that would yield an object with the same value when
passed to <tt class="monofont">eval()</tt>.</p>
</dD>
<DT>
<FONt COlOR="#990000"><fONT COLor="#990000"><spAN CLass="monofont">round(</sPAN></Font>

     
  <tT CLAss="monofont"><i>x[,</i></tt> <tt class="monofont"><i>n]</i></tt><font COLOR="#990000"><SpAN cLAsS="monofont">)</SPAN></Font>

     
  </fONT></Dt>
<dd>
<p>Returns the floating-point value <TT CLass="monofont"><i>x</I></TT> rounded
to <Tt class="monofont"><i>n</i></tt> digits after the decimal point. If
<tt class="monofont"><i>n</i></tt> is omitted, it defaults to zero. The
result is a floating-point number. Values are rounded to the closest
multiple of 10 to the power minus <TT CLASs="monofont"><I>n</I></tT> ; if
two multiples are equally close, rounding is done away from
(e.g., <Tt CLASS="monofont">round(0.5)</Tt> is 1.0 and
<tt cLASS="monofont">round(-0.5)</tt> is -1.0).</p>
</dD>
<DT>
<Font cOLOR="#990000"><font color="#990000"><span class="monofont">setattr(</spaN></FONT>

     
  <Tt CLaSS="monofont"><i>object</I></TT><FONt colOR="#990000"><SPan clASS="monofont">,</Span></fONT>

     
   <Tt class="monofont"><i>name</i></tt><font color="#990000"><spAN CLASs="monofont">,</SPaN></FoNT>

     
   <TT CLass="monofont"><i>value</I></TT><Font cOLOR="#990000"><span CLASs="monofont">)</span></font>

     
  </font></dt>
<dd>
<p>The counterpart of <tt cLASS="monofont">getattr()</TT>. The arguments are an
object, a string, and an arbitrary value. The string may name an
existing attribute or a new attribute. The function assigns the value
to the attribute, provided the object allows it. For example,
<tT ClASs="monofont">setattr(x,</TT> <TT CLass="monofont">'foobar',</tT>
<TT Class="monofont">123)</TT> is equivalent to <TT clasS="monofont">x.foobar</TT>
<Tt class="monofont">=</tt> <tt class="monofont">123</tt>.</p>
</dd>
<dT>
<FONT CoLOr="#990000"><FOnT COLOR="#990000"><span CLASs="monofont">slice(</spaN></FONt>

     
  <tt cLASS="monofont"><i>[start,]</i></tt> <tt class="monofont"><i>stop[,</i></tt> <tt clasS="monofont"><I>step]</I></TT><FoNT cOLoR="#990000"><SPAN Class="monofont">)</SPAN></font>

     
  </FONT></dt>
<dd>
<P>Returns a slice object representing the set of indexes specified by
<TT Class="monofont">range(</tt><tt class="monofont"><i>start,</i></tt>
<tt clASS="monofont"><I>stop,</I></Tt> <TT cLAsS="monofont"><I>step</I></TT>).
The <Tt claSS="monofont"><I>start</I></tt> and
<tt CLASs="monofont"><i>step</i></tT> arguments default to
<TT Class="monofont">None</tt>. Slice objects have read-only data attributes
<tt class="monofont"><i>start</i></tt>, <tt clASS="monofont"><I>stop</I></Tt>,
and <TT cLAsS="monofont"><I>step</I></TT>, which merely return the argument
values (or their default). They have no other explicit functionality;
however, they are used by Numerical Python and other third-party
extensions. Slice objects are also generated when extended indexing
syntax is used, e.g., for <Tt claSS="monofont">a[start:stop:step]</TT> or
<tt clASS="monofont">a[start:stop,</Tt> <tt cLASS="monofont">i]</tt>.</p>
</dd>
<dt>
<font color="#990000"><font cOLOR="#990000"><SPaN ClASs="monofont">str(</SPAN></FOnt>

     
  <tt CLASs="monofont"><i>object</i></tT><FONt colOR="#990000"><SPan class="monofont">)</span></font>

     
  </font></dt>
<DD>
<P>Returns a string containing a nicely printable representation of an
object. For strings, this returns the string itself. The difference
with
<TT ClASs="monofont">repr(</TT><tT CLASS="monofont"><i>object</i></tt><TT CLass="monofont">)</tT>
is that
<TT Class="monofont">str(</TT><TT class="monofont"><i>object</i></tt><tt class="monofont">)</tt>
doesn't always attempt to return a string that is acceptable to
<tt cLASS="monofont">eval()</TT>; its goal is to return a printable string.</p>
</DD>
<dT>
<FoNT COLOr="#990000"><fonT COLor="#990000"><spAN CLass="monofont">tuple(</sPAN></Font>

     
  <tt class="monofont"><i>sequence</i></tt><font colOR="#990000"><SPAN cLAsS="monofont">)</SpAN></FONT>

     
  </font></DT>
<DD>
<p>Returns a tuple whose items are the same and in the same order as
<tt cLASS="monofont"><i>sequence</i></tt>'s items. If
<TT CLass="monofont"><i>sequence</i></tt> is already a tuple, it's
returned unchanged. For instance, <tt class="monofont">tuple('abc')</tt>
returns <tt claSS="monofont">('a',</TT> <TT cLAsS="monofont">'b',</Tt>
<TT CLASs="monofont">'c')</tt>, and <tT CLAss="monofont">tuple([1,</tt>
<TT CLass="monofont">2,</tT> <TT Class="monofont">3])</tt> returns
<tt class="monofont">(1,</tt> <tt clasS="monofont">2,</TT> <TT ClASs="monofont">3)</TT>.</p>
</DD>
<DT>
<FOnt coLOR="#990000"><Font cOLOR="#990000"><span CLASs="monofont">type(</span></font>

     
  <tt class="monofont"><i>object</i></tt><fONT COLoR="#990000"><SpAN cLASS="monofont">)</SPan></foNT>

     
  </FOnt></dt>
<DD>
<P>Returns the type of an object. The return value is a type object. The
standard module types defines names for all built-in types. For
instance:</P>



<pre cLASS="monofont">&gt;&gt;&gt; import types
&gt;&gt;&gt; if type(x) == types.StringType: print "It's a string"
&gt;&gt;&gt;</pre></dd>
<dt>
<font color="#990000"><font cOLOR="#990000"><SPaN ClASs="monofont">vars([</SPAN></FOnt>

     
  <tt CLASs="monofont"><i>object</i></tT><FONt colOR="#990000"><SPan class="monofont">])</span></font>

     
  </font></dt>
<DD>
<P>Without arguments, returns a dictionary corresponding to the current
local symbol table. With a module, class, or class instance object as
argument (or anything else that has a <TT ClASs="monofont">__dict__</TT>
attribute), returns a dictionary corresponding to the object's
symbol table. The returned dictionary should not be modified: the
effects on the corresponding symbol table are undefined.<fONT SIZe="1"><sup><A HREf="#FOOTNOTE-J">[J]</a></suP></FONt>
</p>


<blOCKQuote><font size="1">
<p class="footnote">
<sup><A NAME="FOOTNOTE-J">[J]</A></sUP>
In the current implementation, local variable bindings
can't normally be affected this way, but variables retrieved
from other scopes (e.g., modules) can. This may change.</p>
</FOnT></BLOCKquotE>


</DD>
<Dt>
<fonT COLor="#990000"><foNT COlor="#990000"><span class="monofont">xrange([</span></font>

     
  <tT CLASS="monofont"><i>start</I></Tt><FOnT COLOR="#990000"><span CLASs="monofont">,]</spaN></FONt>

     
   <tt cLASS="monofont"><i>stop</i></tt><font color="#990000"><span clasS="monofont">[,</SPAN></FoNT>

     
   <tT ClASS="monofont"><I>step</I></Tt><fonT COLor="#990000"><spAN CLass="monofont">])</sPAN></Font>

     
  </font></dt>
<dd>
<p>Similar to <tt class="monofont">range()</tt>, but returns an
<TT CLASs="monofont">xrange</TT> object instead of a list. This is an opaque
sequence type that yields the same values as the corresponding list,
without actually storing them all simultaneously. The advantage of
<tT ClASS="monofont">xrange()</TT> over <Tt claSS="monofont">range()</TT> is
minimal (since <tt clASS="monofont">xrange()</Tt> still has to create the
values when asked for them) except when a large range is used on a
memory-starved machine (e.g., MS-DOS) or when all of the
range's elements are never used (e.g., when the loop is usually
terminated with break).<a naME="idx2184"></A></P>
</dd>
</dl>
</font>
 
<table width="100%" border="0" cellspacing="0" cellpadding="0" bgcolor="#CCCCCC">
<td><font color="black" size=1>I l<font color="#FF0000">@</font>ve RuBoard</td>
<td valign="top" class="v2" align="right"><a href="pythonwin32_snode183.html"><img src="FILES/previous.gif" width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a> <a href="pythonwin32_snode185.html"><img src="FILES/next.gif" width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a></td></table>
</BODY></HTML>