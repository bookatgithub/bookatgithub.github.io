<HTML><HEAD><META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=iso-8859-1">
<!--SafClassName="docSection1Title"--><!--SafTocEntry="6.2 A Crash Course in Accounting"-->
<LINK REL="stylesheet" href="FILES/sbolM.css">
</HEAD>
<BODY link="#354278" vlink="#000066" alink="#000080" topmargin="0">
<table width="100%" border="0" cellspacing="0" cellpadding="0" bgcolor="#CCCCCC">
<td><font color="black" size=1>I l<font color="#FF0000">@</font>ve RuBoard</td>
<td valign="top" class="v2" align="right"><a href="pythonwin32_snode51.html"><img src="FILES/previous.gif" width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a> <a href="pythonwin32_snode53.html"><img src="FILES/next.gif" width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a></td></table>
<FONT>
<h3>6.2
A Crash Course in Accounting</h3>


<p>
<a NAME="idx553"></a>We'll
make this as quick as possible. There are two concepts to grasp:
transactions and the chart of accounts.</p>




<h4>6.2.1
Transactions</h4>


<P>
<A NAme="idx554"></a>
<a NAME="idx555"></a>The
<i>double-entry</i>
<a name="idx556"></a> system of accounting dates back over
400 years, to an Italian named Fra. Luca <a name="idx557"></a>Pacioli (who recently had a PC accounting
package named after him). The key idea was to keep track of where
money comes from and where it goes. Double-entry must rate as one of
the most powerful notations ever, the business equivalent of
Newton's achievements in physics. What follows is a formal
notation and set of rules to encapsulate double-entry. As with
physics, it's best just to work through a few examples rather
than analyze the concepts too early.</p>



<p>A <i>transaction</i> is a financial event. It occurs at
a certain point in time, affects two or more accounts, and the effect
of those accounts sums to zero. The use of the term
transaction<i> </i>in the database world was borrowed
from accountants, who got there first by a few centuries. The key
concept is that the whole thing has to happen at once or not at all;
if only part of a transaction takes place, your system goes out of
whack. Conceptually you can lay one out on the page like the
following table.</P>



<P><TABLe BOrDEr="1" CeLLSPacinG="0" CELlpadDING="1" widtH="100%">
<COLgroup span="2">
<tr>
<td>
<font size="2">
<P>Date:</P>
</FONT></tD>
<Td>
<FOnT sIZE="2">
<P>01/01/1998</p>
</fonT></TD>
</Tr>
<tr>
<tD>
<FONt sizE="2">
<P>Comment:</P>
</Font></td>
<td>
<font size="2">
<p>Start the company</p>
</font></TD>
</TR>
<TR>
<tD>
<FoNT sIzE="2">
<P>Cash</P>
</Font></tD>
<TD>
<Font sIZE="2">
<P>+10 000</p>
</fonT></TD>
</Tr>
<tr>
<td>
<font size="2">
<p>Share Capital</p>
</font></td>
<TD>
<FONT sIZe="2">
<P>-10 000</P>
</fOnT></TD>
</Tr>
</colGROUp>
</tabLE></P>


<P>A set of accounts (or
<tt clASS="monofont">BookSet</Tt>
<a name="idx558"></a>)
is basically a list of such transactions. An account is a way of
categorizing money, but it has no precise economic meaning;
fortunately, it soon becomes obvious what an account means in
practice.</p>



<p>Here's what happens when you go out and buy something for cash.</p>



<p><table bordeR="1" CELLSpACiNG="0" cElLPADding="1" WIDTh="100%">
<colGROUp spaN="2">
<TR>
<Td>
<font size="2">
<p>Date:</p>
</font></td>
<td>
<foNT SIZE="2">
<p>07/03/1998</P>
</FoNT></tD>
</tR>
<TR>
<Td>
<fonT SIZe="2">
<p>Comment:</p>
</fONT></Td>
<td>
<fONT Size="2">
<p>Buy computer manuals</p>
</font></td>
</tr>
<tr>
<td>
<font SIZE="2">
<P>Cash</P>
</fONt></TD>
<tD>
<fONT Size="2">
<p>-27.95</P>
</FONt></td>
</tR>
<TR>
<Td>
<fonT SIZe="2">
<p>Expenditure (Publications)</p>
</font></td>
<td>
<font size="2">
<p>+27.95</p>
</FONT></TD>
</tR>
</CoLGrOuP>
</TABle></p>


<p>By convention, increases in cash are positive, and decreases are
negative. Thus, accounts for tracking expenditure like the previous
one for Publications, are usually positive, and Share Capital (from
the first example) has to be negative. The nonintuitive part is that
accounts for classifying income have to be negative<I>,
</I>and so does profit, which is income minus expenditure. It
could as easily have been the other way around, but the decision was
made centuries ago.</P>



<P>Cleaning this process up for the shareholders and managers should be
a function of the <i>reporting layer</i> of the system,
which aims to hide the complexity of these negative numbers. Only the
programmer or database designer really needs to grasp them.</p>



<p>The ancients were not so happy with negative numbers and used the
left and right sides of a sheet of paper, naming them
<I>debit</I> and <I>credit</I>, which are
<i>plus</i> and <i>minus</i> in our
system. Accountants just knew that cash went on the left and income
went on the right, and nobody saw a minus sign. Most people expect it
to be the other way around, but the banks have been fooling you by
using their viewpoint on statements and not the customer's;
when your bank statement says "CR" in small letters, it
means the bank is in credit: they owe you money. We programmers
should be perfectly happy with a minus sign and a list of numbers, so
we'll use the raw data.</P>



<P>It's worth noting that the phrase double-entry bookkeeping
itself is slightly out of date. The old paper procedures involved two
entries, but with the addition of sales taxes, many real-world
transactions have three entries, and others have many entries. So
<I>multiple-entry</I>
<a name="idx559"></a> <a name="idx560"></a> would be a better name. If a
business sells three items in the United Kingdom you want to classify
separately and where sales tax is 17.5%, the sales transaction needs
five entries that look like the following table.</p>



<p><table boRDER="1" CElLSpACiNg="0" CELLpaddING="1" Width="100%">
<COLGroup SPAN="2">
<tr>
<td>
<font size="2">
<p>Date:</p>
</font></td>
<tD>
<FONT SiZE="2">
<p>10/03/1999</P>
</FoNt></TD>
</TR>
<tr>
<td>
<FONT size="2">
<P>Comment:</P>
</FOnt></td>
<TD>
<FOnt size="2">
<p>Sell Widgets</p>
</font></td>
</tr>
<tr>
<td>
<fONT SIZe="2">
<P>Cash</P>
</fONt></Td>
<TD>
<FOnt siZE="2">
<P>+117.50</P>
</font></TD>
</TR>
<tr>
<td>
<FONT size="2">
<p>Sales Category 1</p>
</font></td>
<td>
<font sizE="2">
<P>-50.00</P>
</FONt></TD>
</tR>
<Tr>
<Td>
<FONT size="2">
<P>Sales Category 2</P>
</FOnt></td>
<TD>
<FOnt siZE="2">
<P>-30.00</P>
</font></td>
</tr>
<tr>
<td>
<font size="2">
<p>Sales Category 3</P>
</FONT></Td>
<TD>
<fONt SiZE="2">
<P>-20.00</P>
</font></TD>
</TR>
<tr>
<td>
<FONT size="2">
<P>Sales tax on all three (owed to Customs &amp; Excise)</P>
</FOnt></td>
<td>
<font size="2">
<p>-17.50</p>
</font></tD>
</TR>
</COLgROuP>
</TaBlE></P>


<P>Unfortunately, accountants generally are not database designers, and
arguments rage in theoretical texts over the proper way to
deconstruct this into pairs of entries. We won't worry about
it; we've got a simple master-detail view and a constraint that
the right column sums to zero, and that's all there is to
it.<A name="idx561"></A>
<A NAme="idx562"></a></p>







<H4>6.2.2
The Chart of Accounts</H4>


<P>
<A name="idx563"></A>The second concept to grasp is that of
the <I>chart</I>
<A name="idx564"></a>
<i>of</i> <i>accounts</i>, or as we call
it, the <i>tree</i> <i>of</i>
<i>accounts</i>. There is an almost universal consensus
on what standard accounts should be called and how they relate to
each other. This is a large part of what is known as
<a name="idx565"></a> <A NAME="idx566"></A>Generally
Accepted Accounting Practice or GAAP<i>.</I> If you
have ever struggled with rules such as <I>assets = liabilities
+ capital</i>
<A NaMe="idx567"></A>
<A NAme="idx568"></a>
<a NAME="idx569"></a>,
relax: we deal with that in the next few minutes. Every
company's balance sheet is just a tree, and (with the arrival
of Windows 95) almost everyone in the world knows what tree views
look like, as shown in <a href="pythonwin32_snode52.html#13">Figure 6.1</A>.</P>



<centER>
<H5>
<A name="13"></a>Figure 6.1. The outermost layers of a balance sheet, as a tree</h5>

<img border="0" width="502" hEIGHT="114" src="FILES/ppw.0601.gif" AlT="figs/ppw.0601.gif"></CeNtER>


<P><A href="pythonwin32_snode52.html#13">Figure 6.1</A> shows a tree view of a company's
account structure. The <A NAme="idx570"></a>balance sheet has two sections, Net Assets
and Capital, both of which necessarily have equal size and opposite
signs.<fONT Size="1"><sUP><A Href="#FOOTNOTE-1">[1]</a></sup></font>
 Net Assets are what the
company is worth on paper and include Assets, which have a plus sign,
and Liabilities, which have a negative sign. The totals on the right
are inclusive balances showing everything in the tree below that
point; ignore them for now.</p>


<blockquotE><FONT SiZE="1">
<p CLaSs="footnote">
<SUP><A name="FOOTNOTE-1">[1]</A></SUP>
Some companies cut the cake differently,
displaying Assets as the top half of the balance sheet, and
Liabilities and Capital together on the bottom half. If you are
interested in the book value of the company, the way we have done it
brings the right numbers to the top. It won't affect our data
structures either way.</p>
</fonT></BLOckquOTE>





<P>If you investigate further (see <a href="pythonwin32_snode52.html#14">Figure 6.2</a>),
you'll see that Assets are made up of cash, tangible assets a
company owns (like computers), and money owed by others. Similarly,
Liabilities includes overdrafts, money owed to creditors, and
long-term loans. Capital, which has to match Net Assets, is made up
of what you started with (your capital) and what you have made or
lost since (Profit/Loss). Profit/Loss is simply income minus
expenditure.</p>



<center>
<h5>
<a name="14"></a>Figure 6.2. A simple tree of accounts</h5>

<IMG BORdER="0" wIDtH="502" hEIGHt="211" src="FILES/ppw.0602.gif" ALT="figs/ppw.0602.gif"></CenteR>


<P>Naturally, <A Name="idx571"></a>Income and
<A NAMe="idx572"></a>Expenditure can
be divided into further specific categories, as can just about any of
the accounts. But this is the simplest, reasonably complete picture
of an accounting system.</p>




<h5>6.2.2.1
Timing considerations</h5>


<p><a href="pythonwin32_snode52.html#14">Figure 6.2</a> is essentially correct but a bit too
simple for the real world. What follows presents more realistic data,
so feel free to skip to the next section if it doesn't interest
you.</p>



<p>One of the main reasons companies have to publish accounts is to tell
the world how safe they are to do business with. There are two
definitions of
<a name="idx573"></a>insolvency. If a
company's net assets go below zero, it's insolvent.
However, an important consideration for managers, suppliers, and
shareholders is whether the company has enough cash to meet its
short-term obligations. If a company doesn't appear able to
meet its <a NAME="idx574"></A>short-term obligations, it can also
be ruled insolvent. In the United Kingdom, there are titled
aristocrats who own huge, historic estates they are not allowed to
sell or modify for heritage reasons, and they can't possibly
meet the running costs. These people have positive net assets, but
they are insolvent by the second criterion. Company accounts have to
handle these possibilities. We therefore introduce a distinction
between current assets (cash, or things that should turn into cash
within a year, like stock and debtors) and fixed assets (things with
longer term value, like your factory). We then regroup things to get
a single total of net current assets (NCA), a key indication of the
short-term health of a business.</P>



<p><A href="pythonwin32_snode52.html#16">Figure 6.3</a> shows a simple business from two
viewpoints. The left side displays six transactions occurring in date
order; the right, a tree view at a point in time following the six
transactions, with inclusive totals at each level. This is the tree
structure we will use in examples from now on. You may find it
interesting to trace how the totals were worked out.</P>



<cENTEr>
<h5>
<a nAME="16"></A>Figure 6.3. A set of books showing Journal and Tree Views</h5>

<img BORDer="0" wiDTH="502" Height="370" src="FILES/ppw.0603.gif" alt="figs/ppw.0603.gif"></center>


<p>In the real world, category names differ from country to country, and
there are many more sublevels and exceptions to deal with. But the
chart of accounts is still a tree and broadly follows that pattern.</p>



<p>A large number of accounting systems don't actually use a tree
structure. They have a flat list of numbered accounts with hardcoded
rules defining which numeric ranges are assets, liabilities, income,
and expenditure. This can lead to complex reporting problems, when
the accounts system doesn't quite match the desired grouping
for a particular kind of report. We're going to sidestep all
that.</p>



<P>The data structures we need, then, must capture the following
features:</P>



<UL>
<LI><p>A transaction affects a number of accounts, but must sum to zero.</P>
</Li>
<LI><p>The accounts must be arranged in a<A nAME="idx575"></A> <a namE="idx576"></A> <A Name="idx577"></a> tree.<A NAMe="idx578"></a></p>
</lI>
</UL>







<H4>6.2.3
Back to Python</h4>


<p>Our design goal is a general-purpose toolkit that allows you to
formulate and solve financial problems in Python. To create the
toolkit, we will build classes to represent common financial objects.
All the code is available for downloading, so we show only selected
excerpts; we do, however, list the main functions our class library
makes available, for use in later chapters.</p>



<p>First of all, let's look at a few utilities. If you are fluent
in Python, the code will be straightforward and not particularly
interesting; but please skim through it anyway to grasp the business
logic. If you are new to Python, this chapter should help consolidate
your understanding of the language.</p>




<h5>6.2.3.1
Dates and times</h5>


<p>
<a name="idx579"></a>
<a name="idx580"></a>Python uses the
<a NAME="idx581"></A>Unix time system, which measures
seconds since midnight on January 1, 1970 (which is when urban legend
says the first Unix system booted up). The latest time possible in
the system is sometime on January 19, 2038. We don't want to be
tied to this system forever and will therefore express input and
output in calendar units, hiding the actual implementation. The
<I>dates.py</i>
<A NaME="idx582"></a> module defines a few helper constants
and functions.</P>



<p><TT CLass="monofont">EARLY</tT> is defined as the
earliest date possible on your system or at least earlier than any
transactions you will enter. <TT Class="monofont">LATE</TT> is an arbitrary
date later than any transaction you will enter. The functions
<TT clasS="monofont">asc2sec(aDateString</TT><I>)</i> and
<tt class="monofont">sec2asc (aTime)</tt> convert between a string
representation such as 31-Dec-1998 and seconds. Be aware that the
Python <tt class="monofont">time</tt>
<a nAME="idx583"></A> module exposes functions to do the same
thing, in a slightly wordy manner, but with more options. There is
also a package available called
<TT cLAsS="monofont">mxDateTime</Tt>
<A nAME="idx584"></A> that offers a wider range of date
utilities and functions and is worth considering for a commercial
application.</p>



<p>The function <tt CLASs="monofont">later()</tt> works with the constants
<tT CLAss="monofont">YEARS</tt>, <TT CLass="monofont">MONTHS</tt>,
<tt class="monofont">WEEKS</tt>, <tt class="monofont">DAYS</TT>,
<TT CLaSS="monofont">HOURS</tT>, <Tt ClASS="monofont">MINUTES</Tt>, and
<tt cLASS="monofont">SECONDS</tt> to let you do calendar math easily. The
following console session should clarify these:</p>



<pRE CLass="monofont">&gt;&gt;&gt; from dates import *
&gt;&gt;&gt; sec2asc(EARLY), sec2asc(LATE)
('1-Jan-1970', '19-Jan-2038')
&gt;&gt;&gt; endAugust = asc2sec('31-Aug-1999')
&gt;&gt;&gt; billingDate = later(endAugust, 5, DAYS)
&gt;&gt;&gt; sec2asc(billingDate)
'5-Sep-1999'
&gt;&gt;&gt; paymentDate = later(billingDate, 2, MONTHS)
&gt;&gt;&gt; sec2asc(paymentDate)
'5-Nov-1999'
&gt;&gt;&gt;</pRE>


<P>Now we examine a couple of helper data structures that will come in
handy later. These can be found in the module
<I>datastruct.py</i>
<a name="idx585"></a>. A <tt class="monofont">Set</tt> holds only one
copy of each item; we'll use it to find the unique elements in
a big list quickly. A <tt claSS="monofont">NumDict</TT> categorizes numbers.
Here's the usage:</P>



<PrE ClASs="monofont">&gt;&gt;&gt; import datastruct
&gt;&gt;&gt; myset = datastruct.Set()
&gt;&gt;&gt; myset.add('Spam')
&gt;&gt;&gt; myset.add('Eggs')
&gt;&gt;&gt; myset.add('Spam')
&gt;&gt;&gt; myset.contains('beer')
0
&gt;&gt;&gt; myset.elements()          # returned in alpha order
['Eggs', 'Spam']
&gt;&gt;&gt; sales = datastruct.NumDict()
&gt;&gt;&gt; sales['North'] = 100      # direct assignment, like a dictionary
&gt;&gt;&gt; sales.inc('North',50)     # increment it
&gt;&gt;&gt; sales.inc('East', 130)
&gt;&gt;&gt; sales['East']
130
&gt;&gt;&gt; sales.items()
[('East', 130), ('North', 150)]
&gt;&gt;&gt; sales['South']            # returned in alpha order
0
&gt;&gt;&gt;</PrE>


<P>Both structures are built on top of Python dictionaries and are
extremely efficient with large amounts of data.
<TT clasS="monofont">NumDict</TT> is particularly useful as we will spend a
lot of time categorizing numeric data.</P>



<p>Now to see how these are defined. Here is the module
<i>datastruct.py </i>:</p>



<PRE Class="monofont"># datastruct.py - some generic data structures
# see the Language Reference under 3.3, Special Method Names

class Set:
    "minimal implementation to help clarity of code elsewhere"
    def __init__(self):
        self.data = {}
    def contains(self, element):
        return self.data.has_key(element)
    def add(self, element):
        self.data[element] = 1
    def elements(self):
        keys = self.data.keys()
        keys.sort()
        return keys
        
class NumDict:
    "Dictionary to categorize numbers."

    def __init__(self, input = None):
        self.data = {}
        if input is not None:
            for item in input:
                (category, value) = item
                self.inc(category, value)    
        

    def __getitem__(self, key):
        return self.data.get(key, 0)

    def __setitem__(self, key, value): 
        self.data[key] = value
    
    def inc(self, key, value):
        self.data[key] = self.data.get(key, 0) + value
    
    def items(self):
        it = self.data.items()
        it.sort()
        return it

    def clear(self):
        self.data.clear()</PRE>


<P>These data structures introduce some of Python's
<a name="idx586"></a>Magic Methods
such as __<tt class="monofont">getitem</tt>__<tt clasS="monofont">(self,</TT>
<TT ClASs="monofont">key)</TT>. Magic Methods allow user-defined classes to
respond to just about every operator Python provides. You can think
of the most compact syntax you want for users of your class, and then
implement it with Magic Methods. They are fully documented in the
Python reference manual, Section 3.3, which is part of the standard
distribution.</p>








<H4>6.2.4
Coding Transactions</h4>


<P>
<A NAme="idx587"></a>Now it's time to design a core
object model. The module <i>transac.py
</I>
<A NAme="idx588"></a>defines a
<tT CLAss="monofont">Transaction</tt>
<A NAMe="idx589"></a> class that captures the key notions we
covered earlier. It also goes somewhat further; we've used
Magic Methods to define a basic algebra of accounting. The class
construction is straightforward. However, first we need to mention
three design issues. Since this is a contrived application,
we've gone for simple solutions that are good enough for our
needs; for a proper accounting system, the solutions would be
different.</p>



<ul>
<li><p>The first issue is how to represent the tree structure behind a
company's accounts. After several years of experimenting with
different designs, it's clear that simple strings do the job
nicely. Thus a cash account can be represented with a string like
<i>MyCo.Assets.NCA.CurAss.Cash.MyWallet</i>. This
reduces lots of complex tree operations to simple string functions;
finding the sum of all cash accounts becomes trivial. It should of
course be hidden in the user interface to save end users from typing,
but it clarifies the data structure.</p>
</li>
<li><p>The second issue is how to keep the balance sheet in the right order
as shown in <a href="pythonwin32_snode52.html#16">Figure 6.3</A>. You'll see that the
accounts were named in alphabetical order at every level; we cheated
and used <TT CLAsS="monofont">1_NetAssets</Tt> and
<TT cLaSS="monofont">2_Capital</TT> at the top level to force an
alphabetical order. This hack keeps our tree in the conventional
balance sheet order without needing any extra sort fields. The
display account names used in reports (or indeed a GUI) could easily
be looked up in a dictionary.</p>
</li>
<lI><P>The final design issue is whether to have a separate class instance
for every single transaction, or to go for a lower-level (and faster)
implementation involving nested lists and tuples, since indexing into
a list is faster than accessing a class attribute. For this book
we've opted for a slower but more readable implementation, and
a recent upgrade from 75 to 266 MHz largely covers up the loss. We
discuss options for optimizing later on.</P>
</Li>
</ul>
<p>Let's take a quick tour of how to construct and work with
transactions:</P>



<PRE clasS="monofont">&gt;&gt;&gt; import transac
&gt;&gt;&gt; T1 = transac.Transaction()
&gt;&gt;&gt; T1.date = asc2sec('1/1/1999')
&gt;&gt;&gt; T1.comment = 'Start the company'
&gt;&gt;&gt; T1.addLine('MyCo.Assets.NCA.CurAss.Cash', 10000)
&gt;&gt;&gt; T1.addLine('MyCo.Capital.Shares', -10000)
&gt;&gt;&gt; T1.validate()
&gt;&gt;&gt; T1.display()                                   # print to standard output
Date:        1-Jan-1999
Comment:     Start the company
MyCo.Assets.NCA.CurAss.Cash              10000.000000
MyCo.Capital.Shares                      -10000.000000

&gt;&gt;&gt; T2 = transac.Transaction()
&gt;&gt;&gt; T2.date = asc2sec('5-Jan-1999')                # four days later...
&gt;&gt;&gt; T2.comment = 'Loan from Grandma'
&gt;&gt;&gt; T2.addLine('MyCo.Assets.NCA.CurAss.Cash', 15000)
&gt;&gt;&gt; T2.addLastLine('MyCo.Assets.OtherLia.Loans')   # addLastLine rounds\
&gt;&gt;&gt;                                                # off the final line for you
&gt;&gt;&gt; T2.display()
Date:        5-Jan-1999
Comment:     Loan from Grandma
MyCo.Assets.NCA.CurAss.Cash              15000.000000
MyCo.Assets.OtherLia.Loans               -15000.000000</PRE>


<p>The <tt class="monofont">validate()</tt>
<a name="idx590"></a> method checks if a transaction balances
and raises an error if it doesn't. Later on we'll show
how to ensure this is called.</p>



<p><tt cLASS="monofont">Transaction</TT>
<a NAmE="idx591"></A>
objects are atomic packets of data; they don't do a lot by
themselves and get interesting only in large numbers. However, they
can display themselves, convert themselves to and from other formats
such as blocks of text, and most important, they support some
mathematical operations:</p>



<PrE CLAss="monofont">&gt;&gt;&gt; T3 = T1 + T2   # we can add them together
&gt;&gt;&gt; T3.display()
Date:        5-Jan-1999
Comment:     &lt;derived transaction&gt;
MyCo.Assets.NCA.CurAss.Cash              25000.000000
MyCo.Assets.OtherLia.Loans               -15000.000000
MyCo.Capital.Shares                      -10000.000000

&gt;&gt;&gt; T4 = T1 * 1.2
&gt;&gt;&gt; T4.display()
Date:      1-Jan-1999
Comment:   &lt;New Transaction&gt;
MyCo.Assets.NCA.CurAss.Cash              12000.000000
MyCo.Capital.Shares                      -12000.000000

&gt;&gt;&gt;</prE>


<P>These operations make it simple to express, for example, the combined
effects of a complex multistage deal or to model sales growing by 10%
per month. The full API supported by
<TT clasS="monofont">Transaction</TT>
<A name="idx592"></A> objects is as
follows:</P>



<DL>
<dt>
<font color="#990000"><font color="#990000"><sPAN CLAsS="monofont">def __init__(self):</SpAN></fOnT>
</FONt></dt>
<dD>
<P>Creates <TT clasS="monofont">Transaction</TT>s with the current time and no
lines.</P>
</dd>
<dt>
<FONT color="#990000"><font color="#990000"><span claSS="monofont">__cmp__(self, other)</SPAN></fONt>
</FOnT></dT>
<DD>
<P>Sorts <tt clASS="monofont">Transaction</Tt>s according to date.</p>
</dd>
<DT>
<FOnt coLOR="#990000"><Font color="#990000"><span class="monofont">__str__(self)</span></FONT>
</FOnT></Dt>
<DD>
<p>Returns a printable description suitable for inclusion in, e.g., a
list box.</P>
</dD>
<DT>
<Font cOLOR="#990000"><font COLOr="#990000"><spaN CLAss="monofont">getDateString(self)</span></font>
</font></dt>
<dd>
<p>Returns its date as a string formatted as "12-Aug-1999
18:55:42."</p>
</dD>
<DT>
<FONt COlOR="#990000"><fOnT COLor="#990000"><spAN CLass="monofont">setDateString(self, aDateString)</sPAN></Font>
</fONT></Dt>
<dd>
<p>Allows date to be set from a text string as well as directly.</p>
</dd>
<dt>
<font color="#990000"><fonT COLOR="#990000"><sPAn CLaSs="monofont">isEqual(self, other)</SPAN></font>
</FONT></dt>
<dd>
<P>Returns <TT Class="monofont">true</TT> if the
<TT class="monofont">Transaction</tt>s agree to the nearest second and 1/100
of a currency unit (even if comments differ).</p>
</dd>
<dt>
<font color="#990000"><FONT COlOR="#990000"><sPAn ClASS="monofont">addLine(self, account, amount, dict=None)</Span></fONT>
</Font></dT>
<DD>
<P>Lets you build transactions up a line at a time.</p>
</dd>
<dT>
<FONt color="#990000"><font color="#990000"><span clASS="monofont">addLastLine(self, account, dict=None)</SPAn></FOnT>
</FoNt></DT>
<DD>
<p>Saves you doing the math. The amount for the last line is worked out
for you to ensure the transaction balances.</p>
</dd>
<DT>
<FOnt coLOR="#990000"><Font cOLOR="#990000"><span class="monofont">validate(self, autocorrect=0)</span></font>
</font></DT>
<DD>
<P>By default, raises an exception if the transaction isn't zero.
If <Tt CLaSS="monofont">autocorrect</tT> is set to zero, it silently adds an
entry for the magic account <tT CLAss="monofont">(uncategorized)</tt> to
round it off. This might be useful in a huge import, and the extra
account shows up on all your reports.</P>
</DD>
<Dt>
<fonT COLor="#990000"><foNT COlor="#990000"><span class="monofont">renameAccount(self, oldAcct, newAcct)</span></font>
</fONT></DT>
<Dd>
<P>Renames accounts, or the first part of any accounts, within the
transaction, thereby allowing you to restructure the tree of
accounts.</P>
</dD>
<Dt>
<FoNT COlor="#990000"><fONT Color="#990000"><SPAN clasS="monofont">compact(self)</SPAn></font>
</font></dt>
<dd>
<p>If there are several lines, e.g., for Cash, compacts them into one
total.</p>
</dd>
<dt>
<foNT COLOr="#990000"><FOnT CoLoR="#990000"><SPAn claSS="monofont">effectOn(self, targetAccount)</SPan></foNT>
</FOnt></dt>
<DD>
<P>Tells you the effect the transaction has on the target account.</P>
</dd>
<dt>
<font color="#990000"><font coloR="#990000"><SPAN ClASs="monofont">__add__(self,</SPaN></fONT>
 <Font cOLOR="#990000"><span CLASs="monofont">other)</spaN></FONt>
, <font color="#990000"><span class="monofont">__neg__(self)</spAN></FONT>
, <fONt COlOr="#990000"><SPAN clasS="monofont">__mul__(self,</SPAn></fonT>
 <FONt colOR="#990000"><SPan class="monofont">scalar)</span></font>
, <font coLOR="#990000"><SPAn CLaSS="monofont">__div__(self, scalar)</sPaN></FONt>
</fonT></DT>
<Dd>
<p>Implements basic transaction algebra.</p>
</dD>
<DT>
<Font cOLOR="#990000"><font color="#990000"><span class="monofont">flows(self, fromAccount)</spaN></FONT>
</FoNT></dT>
<Dd>
<P>For analyzing financial flows: tells you how much money flowed into
(or out of, if negative) the transaction from the given account.</p>
</DD>
<DT>
<font COLOr="#990000"><fonT COLor="#990000"><spAN CLass="monofont">display(self)</span></font>
</font></dt>
<dd>
<p>Prints a readable representation containing all the lines on standard
output.</p>
</DD>
<DT>
<FOnT CoLOr="#990000"><FoNT COlor="#990000"><sPAN Class="monofont">asTuple(self)</SPAN></font>
</FONT></dt>
<dd>
<p>Returns a compact representation as a Python tuple, useful sometimes
for portability and speed, as we will see later on. The module
defines a function
<tt class="monofont">tranFromTuple</tt><tt class="monofont"><I>(aTuple)</I></TT>
that converts these back to <TT cLAsS="monofont">Transaction</Tt> class
instances.</P>
</dD>
<DT>
<Font cOLOR="#990000"><font COLOr="#990000"><spaN CLAss="monofont">asString(self)</span></font>
</font></dt>
<dd>
<p>Returns a multiline string for use in displaying or saving to text
files. The module defines a function
<tt CLASS="monofont">tranFromString</Tt><TT cLAsS="monofont"><i>(aChunk)</I></TT>
to help parse transactions in text files, although slight rounding
errors can become a problem with text storage and prevent perfect
round trips.</P>
</dd>
<dt>
<FONT coloR="#990000"><FONt colOR="#990000"><SPan class="monofont">asDicts(self)</span></font>
</font></dt>
<DD>
<P>Returns a set of dictionaries holding data for multidimensional
analysis.</P>
</DD>
<dT>
<FoNT cOlOR="#990000"><FOnt coLOR="#990000"><Span cLASS="monofont">magnitude(self)</span></FONT>
</font></dt>
<dd>
<p>Returns a number indicating the rough size of the transaction, for
display in graphical views to help users find transactions. The
meaning is somewhat undefined for complex multiline transactions!</p>
</dd>
</dl>


<p>Finally, the <tt clasS="monofont">transac</TT>
<A NAmE="idx593"></A> module defines a function
<tT ClAsS="monofont">transfer</TT><Tt claSS="monofont"><I>(date,</I></tt>
<tt CLASs="monofont"><i>comment,</i></tT>
<TT Class="monofont"><i>debitAccount,</i></tt>
<tt class="monofont"><i>creditAccount,</i></tt>
<tt CLASS="monofont"><I>amount</i></TT><i>)</I> that lets you
create a transaction rapidly with just
two<Tt ClASS="monofont"></Tt>
<a naME="idx594"></A> lines.<A name="idx595"></A></P>







<H4>6.2.5
BookSets</H4>


<p>
<a naME="idx596"></A>The
next step is to represent a set of books. Many accounting systems
grew up with programmers and analysts trying to model the paper
processes of old accounting systems, with complex posting and
validation rules. Our representation turns out to be nothing more
than a list of transactions in date order. Many of the common
financial reports can be extracted with some simple loops through
this list. In database parlance, we have
<A name="idx597"></a>normalized our design, and will now
define lots of
<i>views</i>
<a name="idx598"></a>
on top of it to get the data the users want. By storing transactions
and only transactions, rather than allowing the line items to exist
separately in some other kind of database, it's easy to ensure
that the whole system obeys the fundamental rule of summing to zero
as we manipulate the data.</p>



<p>The <tt clasS="monofont">BookSet</TT> class now captures the logical
structure of a general set of books. We also give it the ability to
load and save its data, add, edit, and delete transactions, and
display common views of the data.</P>



<P>The examples at the web site <A tARgET="_blank" hReF="http://../starship.python.net/crew/mhammond/ppw32">http://starship.python.net/crew/mhammond/ppw32</A>/
include a script, <I>demodata1.py</I>, that generates a
<tt clASS="monofont">BookSet</Tt> with 1,000 transactions and saves it to a
file for future use. This test set of data is constant and can be
used for volume testing and optimization. It shows a two-year
forecast <a naME="idx599"></A>business
model for a small consulting company called Pythonics Ltd. which,
after a shaky start, achieves superior productivity and wealth
through Python.</P>



<p>As before, we kick off with a quick demo of some of
<tt cLASS="monofont">BookSet</tt>'s capabilities. We adopt the
<a name="idx600"></a>convention that methods beginning with
<tt class="monofont">get</tt> retrieve data, usually in the form of a list
of strings or tuples, and methods beginning with
<tt clASS="monofont">list</TT> print that data to the console:</P>



<pRE cLAsS="monofont">&gt;&gt;&gt; bs = demodata1.getData()
&gt;&gt;&gt; bs[0].display()
Date:       1-Jan-1999
Comment:    Initial investment
MyCo.Assets.NCA.CurAss.Cash              10000.000000
MyCo.Capital.Shares                      -10000.000000

&gt;&gt;&gt; bs.listAccountDetails('MyCo.Assets.OtherLia.BankLoan')
Details of account MyCo.Assets.OtherLia.BankLoan
------------------ -----------------------------
   37 1-Feb-1999     Loan drawdown                 -10000.00  -10000.00
   72 1-Mar-1999     Loan repayment                   378.12   -9621.88
  113 1-Apr-1999     Loan repayment                   381.27   -9240.61
  149 1-May-1999     Loan repayment                   384.45   -8856.16
&lt;&lt;lines omitted&gt;&gt;
  993 1-Jan-2001     Loan repayment                   453.86    -457.50
  998 1-Feb-2001     Final loan repayment             457.50       0.00

&gt;&gt;&gt; endOfYear2 = asc2sec('31-Dec-2000')
&gt;&gt;&gt; bs.getAccountBalance('MyCo.Capital.PL', endOfYear2)  # are we in profit yet?
-258416.088
&gt;&gt;&gt; # Yes, rolling in it  (remember, cash is positive, profits and income are 
&gt;&gt;&gt; # negative)
&gt;&gt;&gt; Q1, Q2 = asc2sec('31-Mar-2000'), asc2sec('30-Jun-2000') 
&gt;&gt;&gt; bs.getAccountActivity('MyCo.Capital.PL.Expenses', Q1, Q2)
69961.19
&gt;&gt;&gt;</pRE>


<P>All these queries are implemented as simple loops over the
transactions in the <Tt claSS="monofont">BookSet</TT>. For example, to get
the previous account details, we implement an internal function
called <tt clASS="monofont">getAccountDetails()</Tt> as follows:</p>



<prE CLAss="monofont">
    def getAccountDetails(self, match):
        from string import find  # import into local namespace, a bit faster
        runtot = 0
        tranNo = 0
        results = []
        for tran in self.__journal:
            dateStr = sec2asc(tran.date)
            comment = tran.comment
            for (account, delta, etc) in tran.lines:
                if find(account,match)&lt;&gt; -1:
                    runtot = runtot + delta
                    results.append((tranNo, dateStr, comment, delta, runtot)) 
            tranNo = tranNo + 1
        return results
        
    def listAccountDetails(self, match):
        print 'Details of account',match
        print '------------------ ' + ('-' * len(match))
        for row in self.getAccountDetails(match):
            print '%5d %-12s %-40s %10.2f %10.2f' % row
        print</pre>


<p>Note line 6, <tt class="monofont">for</tt> <tt clasS="monofont">tran</TT>
<TT ClASs="monofont">in</TT> <tT cLASS="monofont">self.__journal</tt>. The
<tt CLASs="monofont">__</tt>
<a NAME="idx601"></a>convention provides private
attributes; these attributes can be referenced by name only inside
the class, not by external users of the class. This is a good way to
hide information.</p>



<p>It's worth noting the way
<a NAME="idx602"></a>transactions
are added. They must be stored internally in date order. To ensure
this, use a modified binary insertion routine lifted from the Python
library module
<i>insort.py</i>
<a name="idx603"></a>. You first validate the transaction, and
then do a quick check to see if it's the first transaction in
the <tt class="monofont">BookSet</tt> or if it's dated the same or
later than the last one, and put it at the end. Loading from a file
that's already in date order is fast and saves searching.
Otherwise, you should do a binary search. Inserting a transaction in
a 1000-transaction journal takes no more than eight comparisons:</p>



<prE CLASS="monofont">
    def add(self, tran):
        # this could be optimized by putting the
        # length=0 case in an exception handler
        tran.validate()
        if len(self.__journal) == 0:
            self.__journal.append(tran)
        else:
            # quick check if it's the last - might happen
            # very often when loading from a file
            if cmp(tran, self.__journal[-1]) &gt;= 0:
                self.__journal.append(tran)
            else:
                self._insertInOrder(tran)

    def _insertInOrder(self, tran):
        # copied from Python library - binary
        # insertion routine
        lo = 0
        hi = len(self.__journal)
        while lo &lt; hi:        
            mid = (lo + hi) / 2
            if tran &lt; self.__journal[mid]:
                hi = mid
            else:
                lo = mid + 1
        self.__journal.insert(lo, tran)</pRE>



<h5>6.2.5.1
Adding persistence: Pickles last forever</H5>


<P>In most languages you would have to write a lot of code to save and
load your data. In Python you don't.</p>



<P><tT CLAss="monofont">BookSet</tt> uses one of Python's
<A NAMe="idx604"></a>persistence
tools, the <tt CLASs="monofont">cPickle</tt>
<a NAME="idx605"></a> module. Python has three modules that
can save almost any structure to disk for you.
<tt class="monofont">Marshal</tt>
<a name="idx606"></a><i> </i>is written in C and
is the fastest, but is limited to numbers, strings, lists,
dictionaries, and tuples.
<tt cLASS="monofont">Pickle</TT>
<a NAmE="idx607"></A> was written in Python and allows
arbitrary objects to be stored to disk. <tT cLASS="monofont">cPickle</tt> is
a recent rewrite of <tt CLASs="monofont">pickle</tt> in C, which allows
high-speed storage approaching that of <tT CLAss="monofont">Marshal</tt>.
Here are the <TT CLass="monofont">BookSet</tt> methods to save and load the
data:</p>



<pre class="monofont">
    def save(self, filename):
        f = open(filename,'wb')
        cPickle.dump(self.__journal,f)
        f.close()

    def load(self, filename):
        f = open(filename, 'r')
        data = cPickle.load(f)
        for tran in data:
            self.add(tran)
        f.close()</pre>


<p>We did a little preparation by opening a file, but it takes only one
line to save and reload all of our data. If you subsequently redesign
your <tt cLASS="monofont">Transaction</TT> class, you don't need to
rewrite the persistence code. Persistence is one of Python's
most powerful features.</p>






<H5>6.2.5.2
Summary of the BookSet API</H5>


<p><TT cLaSS="monofont">BookSet</TT>
<a namE="idx608"></A>
<A Name="idx609"></a>
offers a lot of methods. We won't list them
exhaustively—you'll see plenty later on—but here
are the main families:</P>



<A NAme="idx610"></a><a NAME="idx611"></a><a name="idx612"></a><a name="idx613"></a><a name="idx614"></a><a nAME="idx615"></A><DL>
<dT>
<I><fONt CoLOR="#990000">Editing methods</Font></i></DT>
<DD>
<p><tt cLASS="monofont">add(</tt>
<a nAME="idx610"></A><tt class="monofont"><i>self,</i></tt>
<tt class="monofont"><i>tran</i></tT><TT CLAsS="monofont">)</Tt>,
<TT cLaSS="monofont">remove(</TT><tt clASS="monofont"><I>self,</i></tt>
<tT CLAss="monofont"><i>index</i></TT><TT class="monofont">)</tt>,
<tt class="monofont">edit(</tt><tt claSS="monofont"><I>self,</I></TT>
<tT ClASs="monofont"><I>index,</i></TT>
<TT clasS="monofont"><I>newTran</I></Tt><tt cLASS="monofont">)</tt>,
<tt CLASs="monofont">renameAccount(</tt><tt class="monofont"><i>seDates
lf,</i></tt> <tt class="monofont"><I>oldAcct,</I></TT>
<TT cLAsS="monofont"><I>newAcct,</i></Tt>
<TT CLass="monofont">compact=1</tT><I>)</I>. These allow
modification. <Tt claSS="monofont">edit()</TT> breaks down into a
<tt clASS="monofont">remove()</Tt> followed by an <tt class="monofont">add()</tt>,
since the date and thus the location in the array might have changed.
<tt class="monofont">renameAccount()</tt> loops over the whole bookset; like
the DOS rename command, it can also move things to a different part
of the tree.</p>
</dD>
<DT>
<I><FOnT CoLOr="#990000">Storage methods</FoNT></I></Dt>
<dd>
<p><TT CLass="monofont">save</tT>
<A NAme="idx611"></a>
<a NAME="idx612"></a><tt class="monofont"><i>(self,</i></tt>
<tt class="monofont"><i>filename)</i></TT>,
<TT CLaSS="monofont">saveAsText</tT><Tt ClASS="monofont"><I>(self,</i></tt>
<tT CLAss="monofont"><i>filename)</i></TT>,
<TT clasS="monofont">load</TT><Tt class="monofont"><i>(self,</i></tt>
<tt class="monofont"><i>filename)</i></tt>,
<TT CLASs="monofont">loadFromText</TT><tT ClAsS="monofont"><I>(self,</I></Tt>
<tt cLASS="monofont"><i>filename)</i></tt> allow storage in files in either
a fast native format or human-readable text. The native format is
that produced by the <TT CLass="monofont">cPickle</tT> utility discussed
previously.</P>
</DD>
<dt>
<i><font color="#990000">Query methods</font></i></dt>
<dd>
<P><TT CLAsS="monofont">getAccountDetails(</Tt>
<A NaMe="idx613"></A>
<A NAme="idx614"></a><tT CLAss="monofont"><i>self,</i></TT>
<TT clasS="monofont"><I>account</I></Tt><tt class="monofont">)</tt> gets the full
history of entries in an account.
<tt class="monofont">getAccountList(</tt><tt CLASS="monofont"><I>self
</i></TT><tT ClAsS="monofont">)</TT> returns a list of all the unique
accounts in a <Tt claSS="monofont">BookSet</TT>. <tt clASS="monofont">getAccountBalance
(</Tt><tt cLASS="monofont"><i>self,</i></tt>
<tt class="monofont"><i>acct,</i></tt>
<tt clasS="monofont"><I>date=LATE</I></TT><Tt CLaSS="monofont">)</tT> tells you
the balance of an account on a date, and
<tT CLAss="monofont">getAccountActivity(</tt><TT CLass="monofont"><i>self,</I></TT>
<Tt claSS="monofont"><I>acct, startDate=EARLY,</I></tt>
<tt class="monofont"><i>endDate=LATE</i></tt><tt class="monofont">)</tT> gives the
change in the account between two dates.
<TT CLAsS="monofont">getAllBalancesOn(</Tt><TT cLaSS="monofont"><I>self,</I></tt>
<tt CLASs="monofont"><i>date=LATE</i></tT><TT Class="monofont">)</TT> returns the
balances of all accounts on the given date or the closing balances if
no date is given. We'll see how to extend the
<TT class="monofont">BookSet</tt> to let the user create custom queries in
<a href="pythonwin32_cnode61.html">Chapter 8</a>.<a name="idx615"></a></p>
</dD>
</DL>







<H4>6.2.6
Storing Extra Information in Transactions</H4>


<P>
<a NAmE="idx616"></A>We've defined some basic
classes that represent what is commonly known as the
<a NaME="idx617"></A>
<A name="idx618"></A>general
ledger or <A NAme="idx619"></a>nominal ledger, the core of any
accounting system. Accounting systems generally build layers and
modules around the general ledger to handle things like sales and
purchases, cash management, payroll, and job and project tracking. In
a conventional architecture, these might each be extra modules (sold
separately) that add tables, editing screens, and reports. When new
items are added, these modules might post entries to the general
ledger as well as keep their own records. Unfortunately, this is the
point at which businesses start to vary from each other: it's
hard to predict in advance what facts companies need to keep track
of.</p>



<P>Our transactions so far deal with the two dimensions of time and
account. However, you may wish to store extra information in the
future, such as the name of a customer or supplier, a check number
for a payment, or a tax code for an invoice line; and you don't
want to be limited to a predefined set of attributes.</P>



<P>Python has an unusual and extremely flexible (but potentially
dangerous) feature that enables you to minimize the number of these
extensions: any class instance can be given any
<A name="idx620"></A>attribute, regardless of its class
definition. Let's look at how a transaction is initialized:</P>



<PRe class="monofont">class Transaction:
    def __init__(self):
        "By default, you get a zero transaction with time = now"
        import time
        self.date = int(time.time())
        self.comment = '&lt;New Transaction&gt;'
        self.lines = []</pre>


<p>It has three attributes, <tt class="monofont">date</tt>,
<tt CLASS="monofont">comment</Tt>, and <TT cLAsS="monofont">lines</tT>. In most
other object-oriented languages you would be limited to these. In
Python there is absolutely nothing to stop you from doing the
following:</P>



<PRe claSS="monofont">&gt;&gt;&gt; import doubletalk.transac
&gt;&gt;&gt; t = doubletalk.transac.Transaction()
&gt;&gt;&gt; t.Customer = 'HugeCo'
&gt;&gt;&gt; t.InvoiceNo = 199904007
&gt;&gt;&gt;</PRe>


<p>You don't need to define the attributes
<tt CLASs="monofont">Customer</tt> and <tT CLAss="monofont">InvoiceNo</tt> in the
class definition, which means you aren't limited. Your
transactions can store any extra facts you wish. Furthermore, the
<tt class="monofont">cPickle</tt><i> </i>module that provides
the persistence capabilities will still save and load the objects.</p>



<p>In general, adding attributes on the fly like this is a bad design,
because there is a strong chance users will overwrite attributes that
are important to the functioning of the program. We can get away with
it here since <tt clASS="monofont">Transaction</TT> is essentially just a
packet of data to be manipulated, and we want to keep the code short.
In <A href="pythonwin32_cnode101.html">Chapter 13</A>, you will see a much safer technique
for doing the same thing, which preserves the friendly user-level
syntax.</P>



<p>By adding these two facts to sales invoices and records of payments,
you can generate reports showing who owes what or breaking down sales
by customer. The converse also applies to invoices received and
payments to suppliers. You can also imagine end users finding
interesting new applications for this; you could tag transactions
with the person who entered them, add cross references to check
stubs, or anything else you want.<A nAME="idx621"></A><a namE="idx622"></A>
<A Name="idx623"></a></P>



<P><TAble cELLSpacing="0" width="90%" border="1"><tr><td>
<CENTER><h2>
Introspection in Python</H2></CeNTeR>


<p>
<A NAMe="idx624"></a>
<a nAME="idx625"></A>Python objects can examine their own
insides and trap access to them, a feature rarely found in compiled
languages. This enables modules such as
<tt clASS="monofont">pickle</Tt><i> </i>and
<tT CLAss="monofont">cPickle</tt><i> </i>to be written.
<tt class="monofont">dir(</tt><tt clasS="monofont"><I>objec</I></TT><I>t</i><TT cLAsS="monofont">)</tT>
lists the attributes of any object; the magic attribute _
_<TT Class="monofont">dict</TT>__ returns a dictionary of keys and values.
<TT clasS="monofont">getattr(</TT><Tt claSS="monofont"><I>object,</I></tt>
<tt class="monofont"><i>key</i></tt><tt class="monofont">)</tT> and
<TT CLAsS="monofont">setattr</Tt><TT cLaSS="monofont"><I>(object,</I></tt>
<tt CLASs="monofont"><i>key,</i></tT> <TT Class="monofont"><I>value</I></TT>) let
you create and access attributes dynamically at runtime. Let's
explore the transaction object previously created:</p>



<pre class="monofont">&gt;&gt;&gt; dir(t)   # lists an object's attributes
['Customer', 'InvoiceNo', 'comment', 'date', 'lines']
&gt;&gt;&gt; from pprint import pprint # displays nicely over several lines
&gt;&gt;&gt; pprint(t. _   _dict_   _)
{'Customer': 'HugeCo',
'InvoiceNo': 199904007,
'comment': '&lt;New Transaction&gt;',
'date': 925245509,
'lines': []}
&gt;&gt;&gt; getattr(t, 'Customer')
'HugeCo'
&gt;&gt;&gt; setattr(t, 'InputBy', 'A.Anorak')
&gt;&gt;&gt; t.InputBy
'A.Anorak'</pre>


<p>It's also possible for objects to trap attempts to set
and get attributes and react in special ways using the Magic Methods
<tt class="monofont">__getattr__</tT>(<TT CLAsS="monofont"><I>self,</i></TT>
<tT cLASS="monofont"><i>name</i></tt><TT CLass="monofont">)</tT> and <TT Class="monofont">_
_setattr__</TT><TT class="monofont"><i>(self,</i></tt>
<tt class="monofont"><i>name,</i></tt> <tT CLASS="monofont"><i>value</I></Tt>).
We've defined a class that lets you set attributes unless they
are named "spam":</P>


<PrE cLASS="monofont">class HateSpam:
    def __setattr__(self, name, value):
        if name == 'spam':
            print "Keep that stuff away from me"
        else:
            self.__dict__[name] = value
    def __getattr__(self, name):
        if name == 'spam':
            print "you won't find any of that here"
        else:
            return self.__dict__[name]</pre>



<p>Having defined this, we can do the following:</P>




<PRE clasS="monofont">&gt;&gt;&gt; h = HateSpam()
&gt;&gt;&gt; h.eggs = 12
&gt;&gt;&gt; h.spam = 3
Keep that stuff away from me
&gt;&gt;&gt; h.spam
you won't find any of that here
&gt;&gt;&gt; h.eggs
12</PRE>


<p>You can even grab a function and attach it to an object at runtime:</p>


<prE CLAss="monofont">&gt;&gt;&gt; def sing(food) :
…    print '%s, %s, %s, everybody loves %s' %
(food,food,food,food,food)
…
&gt;&gt;&gt; sing ('eggs')
eggs, eggs, eggs, eggs, everybody loves eggs
&gt;&gt;&gt; h.shout = sing
&gt;&gt;&gt; h.shout('beer')
beer, beer, beer, beer, everybody loves beer
&gt;&gt;&gt; dir (h)
['eggs', 'shout']
&gt;&gt;&gt;</pre>

</td></tr></table></p>


<p>However, there are occasions when an attribute doesn't apply to
the whole transaction but just to one line. Imagine you are billing a
large customer for consulting work done by four of your staff, all
working in different departments, and you want to track the income by
department or team internally. You have only one transaction, but
different attributes per line. To cope with this, the lines inside
transactions are three-element tuples. Element three is usually
<tt claSS="monofont">None</TT>, but can be a dictionary. Later we will write
queries that can loop over a <TT cLAsS="monofont">BookSet</Tt> and query
based on these attributes. In the next example, we create a
transaction with extra attributes at both the transaction and line
level and split the income from a sale between two internal projects:</P>



<pRE CLass="monofont">&gt;&gt;&gt; INCOME='MyCo.Capital.PL.Income.Consulting'  # save typing
&gt;&gt;&gt; t = doubletalk.transac.Transaction()
&gt;&gt;&gt; t.Customer = 'HugeCo'
&gt;&gt;&gt; t.InvoiceNo = 199904007
&gt;&gt;&gt; t.addLine(INCOME, 15000, {'Project':'P1'} )
&gt;&gt;&gt; t.addLine(INCOME, 10000, {'Project':'P2'} )
&gt;&gt;&gt; t.addLine('MyCo.NCA.CurrentAssets.Creditors', 25000)
&gt;&gt;&gt; t.display()   # shows the basics
Date:      27-Apr-1999 21:17:52
Comment:   &lt;New Transaction&gt;
MyCo.Capital.PL.Income.Consulting        10000.000000
MyCo.Capital.PL.Income.Consulting        15000.000000
MyCo.NCA.CurrentAssets.Creditors         25000.000000
&gt;&gt;&gt; from pprint import pprint
&gt;&gt;&gt; pprint(t.__dict__)   # look inside the object
{'Customer': 'HugeCo',
 'InvoiceNo': 199904007,
 'comment': '&lt;New Transaction&gt;', 
 'date': 925247872,
 'lines': [('MyCo.Capital.PL.Income.Consulting', 10000, {'Project': 'P2'}),
           ('MyCo.Capital.PL.Income.Consulting', 15000, {'Project': 'P1'}),
           ('MyCo.NCA.CurrentAssets.Creditors', 25000, None)]}
&gt;&gt;&gt;</pRE>


<P>Our data model still obeys all the fundamental rules of double-entry
accounting but is now much more extensible: users can add their own
attributes at will. This is the basis of a highly open, extensible
system.</P>


</font>
 
<table width="100%" border="0" cellspacing="0" cellpadding="0" bgcolor="#CCCCCC">
<td><font color="black" size=1>I l<font color="#FF0000">@</font>ve RuBoard</td>
<td valign="top" class="v2" align="right"><a href="pythonwin32_snode51.html"><img src="FILES/previous.gif" width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a> <a href="pythonwin32_snode53.html"><img src="FILES/next.gif" width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a></td></table>
</BODY></HTML>