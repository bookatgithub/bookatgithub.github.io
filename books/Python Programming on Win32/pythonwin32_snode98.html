<HTML><HEAD><META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=iso-8859-1">
<!--SafClassName="docSection1Title"--><!--SafTocEntry="12.6 Implementing COM Objects in Python"-->
<LINK REL="stylesheet" href="FILES/sbolM.css">
</HEAD>
<BODY link="#354278" vlink="#000066" alink="#000080" topmargin="0">
<table width="100%" border="0" cellspacing="0" cellpadding="0" bgcolor="#CCCCCC">
<td><font color="black" size=1>I l<font color="#FF0000">@</font>ve RuBoard</td>
<td valign="top" class="v2" align="right"><a href="pythonwin32_snode97.html"><img src="FILES/previous.gif" width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a> <a href="pythonwin32_snode99.html"><img src="FILES/next.gif" width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a></td></table>
<FONT>
<h3>12.6
Implementing COM Objects in Python</h3>


<p>
<a NAME="idx1175"></a>Implementing a COM object using Python
means you expose a Python object to be used by any COM-aware
environment, such as Visual Basic or Delphi.</p>



<p>In <a href="pythonwin32_cnode40.html">Chapter 5</a>, we presented a simple example of a
Python class exposed as a COM object. In this section, we provide a
more detailed picture of exposing Python objects via COM.</p>




<h4>12.6.1
Implementing a COM Server</h4>


<P>
<A NAme="idx1176"></a>In
<a href="pythonwin32_cnode40.html">Chapter 5</a> we presented a sample COM server. This
example recaps that code:</p>



<pre class="monofont"># SimpleCOMServer.py - A sample COM server - almost as small as they come!
# 
# We simply expose a single method in a Python COM object.
class PythonUtilities:
    _public_methods_ = [ 'SplitString' ]
    _reg_progid_ = "PythonDemos.Utilities"
    # NEVER copy the following ID 
    # Use "print pythoncom.CreateGuid()" to make a new one.
    _reg_clsid_ = "{41E24E95-D45A-11D2-852C-204C4F4F5020}"
    
    def SplitString(self, val, item=None):
        import string
        if item != None: item = str(item)
        return string.split(str(val), item)

# Add code so that when this script is run by
# Python.exe, it self-registers.
if __name__=='__main__':
    print "Registering COM server..."
    import win32com.server.register
    win32com.server.register.UseCommandLine(PythonUtilities)</pre>


<P>The main points from the example are:</P>



<UL>
<LI><p>Most COM servers are implemented as Python classes. These classes
have special attribute annotations that indicate how the object is
published via COM; our sample uses the minimum possible to register
and expose a COM server.</P>
</Li>
<LI><p>The <Tt CLASs="monofont">win32com</tt>
<a NAME="idx1177"></a> package automatically registers
and unregisters the COM server.</p>
</li>
</UL>
<P>The list of annotation attributes can be broken into two sets: those
that expose the object via COM and those that allow the object to be
registered via COM. <A href="pythonwin32_snode98.html#3">Table 12.3</A> lists the
annotations used at runtime; registration attributes are covered in
the next section.</P>



<A Name="3"></a><p><table border="1" cellsPACING="0" cELlPAdDiNG="1" WIdth="100%">
<cAPTIon><h5>Table 12.3. Runtime-Related Annotations on COM Objects</h5></CAPTion><cOLGRoup span="2">
<tr>
<th>
<font size="2">
<p>Attribute</p>
</FONT></TH>
<tH>
<FoNT sIzE="2">
<P>Description</P>
</Font></tH>
</TR>
<Tr>
<td>
<fONT Size="2">
<p><TT CLass="monofont">_public_methods_</tt></p>
</font></td>
<td>
<font sizE="2">
<P>A list of strings that indicate the names of the public methods for
the object. COM objects can use only methods listed here, the rest
are considered private. This is the only required attribute; all
others are optional.</P>
</FONt></TD>
</tR>
<Tr>
<Td>
<FONT size="2">
<P><TT Class="monofont">_public_attrs_</TT></P>
</Font></tD>
<TD>
<Font size="2">
<p>
<a name="idx1178"></a>
<a name="idx1179"></a>A list of strings that indicate the
public attributes (or properties) for the object. Any attributes not
listed here are considered private. Any attributes listed here but
not in <tT CLASS="monofont">_readonly_attrs_</tT> can be read or written. It
is possible to list the name of Python methods here, in which case
the property is implemented by calling the Python method rather than
fetching the attribute directly.</P>
</fONt></Td>
</TR>
<TR>
<td>
<foNT SIze="2">
<p><tT CLAss="monofont">_readonly_attrs_</tt></P>
</FONt></td>
<td>
<font size="2">
<p>A list of attributes that should be considered read-only. All names
in this list should also be in <tt class="monofont">_public_attrs_ </TT>,
otherwise they shouldn't be exposed.</P>
</FONt></TD>
</tR>
<Tr>
<Td>
<FONT size="2">
<P><TT Class="monofont">_value_</TT></P>
</Font></tD>
<TD>
<Font size="2">
<p>A method (not the name of a method) that provides the default value
for the object. We present an example of this in the sample code.
Because this is a method, the typical way to implement this is to add
a method to your class named <tt class="monofont">_value_</tt>.</p>
</fonT></TD>
</TR>
<Tr>
<TD>
<fONt SiZE="2">
<P><Tt claSS="monofont">_NewEnum</TT></p>
</fonT></TD>
<Td>
<fonT SIZe="2">
<p>A method (not the name of a method) that's used to when the
client using this object requests an enumerator. This function must
provide a function that conforms to the enumerator specification.</p>
</font></td>
</tr>
<tr>
<td>
<font siZE="2">
<P><TT ClASs="monofont">_Evaluate</TT></p>
</FoNT></TD>
<td>
<foNT SIze="2">
<p>Used when the client using this object requests to evaluate it. This
appears to be a rarely used COM concept.</p>
</FONT></td>
</tr>
</COLGroup>
</table></p>






<a name="4"></a>
<h4>12.6.2
Registering Your COM Server</h4>


<p>
<a nAME="idx1180"></A>Although
our sample object implements registration of the object, we
haven't discussed it in detail.</P>



<P>Registering an
<a NAmE="idx1181"></A>object
is the process of allowing the object to be independently created;
once an object is registered, a language can use its standard
techniques for creating COM objects to access it, e.g.,
<tT cLASS="monofont">CreateObject()</tt> in Visual Basic or
<tt CLASs="monofont">win32com.client.Dispatch()</tt> in Python.</p>



<P>There are many cases where you wish to implement a COM object but
don't need it registered. For example, let's assume you
are designing an object model for an editor that has a root
<TT Class="monofont">Application</TT> object, and inside this
<TT class="monofont">Application</tt> object there are a number of
<tt class="monofont">Document</tt> objects. In this case, you would
typically want to register the <tt claSS="monofont">Application</TT> object
(clients need to be able to create this object directly) but not
register the <TT cLAsS="monofont">Document</Tt> object (making requests on
the <Tt CLASs="monofont">Application</tt> object creates these). In this
case, you don't need to specify any registration information
for the <tT CLAss="monofont">Document</tt> object.</P>



<P>To prepare an object for registration, you need to provide additional
attribute annotations on the object. The registration process uses
these annotations to provide the correct information in the Windows
registry for the object. The full list of registration related
attributes can be found in <A href="pythonwin32_snode98.html#6">Table 12.4</a>.</P>



<A NAme="6"></a><p><table border="1" cellspACING="0" CeLLpADdInG="1" WIDth="100%">
<caPTIOn><h5>Table 12.4. Registration-Related Attributes on COM Objects</h5></cAPTIon><coLGROup span="2">
<tr>
<th>
<font size="2">
<p>Attribute</p>
</fONT></TH>
<Th>
<FOnT SiZe="2">
<P>Description</P>
</FOnt></th>
</TR>
<TR>
<td>
<foNT SIze="2">
<p><tT CLAss="monofont">_reg_progid_</tt></p>
</font></td>
<td>
<font size="2">
<P>The ProgID for the object. This is the name of the COM object clients
use to create the object.</P>
</FONT></tD>
</Tr>
<TR>
<tD>
<fONT Size="2">
<p><TT CLass="monofont">_reg_desc_</tT></P>
</FOnt></td>
<TD>
<FOnt size="2">
<p>
<a name="idx1182"></a>
<a name="idx1183"></a>Optional description of the COM object.
If not specified, <tt CLASS="monofont">_reg_progid_</Tt> is used as the
description.</P>
</FoNT></tD>
</tR>
<TR>
<Td>
<fonT SIZe="2">
<p><tt CLASs="monofont">_reg_classspec_</tt></p>
</FONT></td>
<td>
<font size="2">
<p>An optional string identifying the Python module and the object in
the module. The PythonCOM framework uses this string to instantiate
the COM object. If neither this nor
<tt class="monofont">_reg_policyspec_</tT> are provided, the COM framework
determines the value from the command line.</P>
</FONT></tD>
</Tr>
<TR>
<tD>
<fONT Size="2">
<p><TT CLass="monofont">_reg_policyspec_</tT></P>
</FOnt></td>
<TD>
<FOnt size="2">
<p>An optional string identifying the PythonCOM policy to be used for
this object. If not provided, the default policy is used. See the
section <a href="pythonwin32_snode98.html#9">Section 12.6.4</a> later in this chapter.</p>
</font></td>
</tR>
<TR>
<TD>
<FoNT sIZe="2">
<P><tT CLAss="monofont">_reg_verprogid_</tt></P>
</FONt></td>
<tD>
<FONt sizE="2">
<P>The version-dependent ProgID. This is typically the ProgID with a
version number appended. For example, the second version of a
particular server may have a ProgID of
<TT class="monofont">Python.Object</tt> and a VerProgId of
<tt class="monofont">Python.Object.2</tt>.</p>
</font></TD>
</TR>
<TR>
<tD>
<FoNT sIzE="2">
<P><TT clasS="monofont">_reg_icon_</TT></P>
</font></TD>
<TD>
<font SIZE="2">
<p>The default icon for the COM object.</p>
</font></td>
</tr>
<tr>
<td>
<font sizE="2">
<P><TT CLaSS="monofont">_reg_threading_</tT></P>
</fOnT></TD>
<Td>
<fonT SIZe="2">
<p>The default threading model for the COM object. This must be one of
the COM-defined values acceptable for the ThreadingModel key of the
COM server, e.g., <tt CLASs="monofont">Apartment</tt>,
<tT CLAss="monofont">Free</tt>, or <tt class="monofont">Both</tt>. If not
specified, <tt class="monofont">Both</tT> is used. See <A href="pythonwin32_cnode217.html">Appendix D</a>, for a discussion on COM threading models.</P>
</FoNT></tD>
</tR>
<TR>
<Td>
<fonT SIZe="2">
<p><tt CLASs="monofont">_reg_catids_</tt></p>
</FONT></td>
<td>
<font size="2">
<p>A list of category IDs for the server. See the COM documentation on
categories for more information.</p>
</font></td>
</tR>
<TR>
<TD>
<FoNT sIZe="2">
<P><tT CLAss="monofont">_reg_options_</tt></P>
</FONt></td>
<tD>
<FONt sizE="2">
<P>A dictionary of additional keys to be written to the registry for the
COM object. The PythonCOM framework doesn't define the values
for this; it's up to the author to specify meaningful values.</P>
</Font></td>
</tr>
<tr>
<td>
<font size="2">
<p><tT CLASS="monofont">_reg_clsctx_</tT></P>
</fONt></Td>
<TD>
<FOnt siZE="2">
<P>The contexts defining how this object is to be registered. This
attribute defines if the COM object is registered as an
<Tt claSS="monofont">InProc</TT> object (i.e., implemented by a DLL) or a
<tt clASS="monofont">LocalServer</Tt> object (i.e, implemented in an EXE).
If not specified, the default of
<tt class="monofont">CLSCTX_LOCAL_SERVER</tt> <tt class="monofont">|</tt>
<tt CLASS="monofont">CLSCTX_INPROC_SERVER</Tt> is used (i.e., the object is
registered as both <TT cLAsS="monofont">InProc</tT> and
<TT Class="monofont">LocalServer</TT>).</P>
</Font></tD>
</TR>
<Tr>
<td>
<fONT Size="2">
<p><tt class="monofont">_reg_disable_pycomcat_</tt></p>
</font></td>
<tD>
<FONT SiZE="2">
<p>A boolean flag indicating if the COM object should be associated with
the list of PythonCOM servers installed on the machine. If not
specified, the object is associated with the PythonCOM servers.</P>
</FoNt></TD>
</TR>
<tr>
<td>
<FONT size="2">
<P><TT Class="monofont">_reg_dispatcher_spec_</TT></P>



<P><tt class="monofont">_reg_debug_dispatcher_spec_</tt></p>
</font></td>
<td>
<fonT SIZE="2">
<P>The dispatcher for the COM object. Dispatchers are largely a
debugging aid, allowing you to snoop on your COM object as calls are
made on it. Dispatchers are closely related to policies but
aren't covered in this book.</p>
</FOnT></Td>
</Tr>
</COLGroup>
</TABLe></p>



<p>The module
<tT CLAss="monofont">win32com.server.register</tt>
<A NAMe="idx1184"></a> contains many utilities for registering
and unregistering COM servers. The most useful of these functions is
<tt class="monofont">UseCommandLine()</tt>
<a name="idx1185"></a>, which allows you to register any
number of Python
<a namE="idx1186"></A>classes.
Using this function is a no-brainer; pass to this function the class
objects you wish to expose.</P>



<P>In the COM example, we include the following code:</P>



<PrE ClASs="monofont">if __name__=='__main__':
    print "Registering COM server..."
    import win32com.server.register
    win32com.server.register.UseCommandLine(PythonUtilities)</PrE>


<P>The <TT clasS="monofont">PythonUtilities</TT> object is the class to
register. Adding this functionality allows the
<A name="idx1187"></A> <A NAme="idx1188"></a>COM
<a NAME="idx1189"></a>object to be registered or
unregistered from the command line as detailed in <a href="pythonwin32_snode98.html#7">Table 12.5</a>.</p>



<a name="7"></a><p><table bORDER="1" CeLLsPAcInG="0" CELlpadDING="1" widtH="100%">
<CAPtion><H5>Table 12.5. Command-Line Options Recognized by UseCommandLine</H5></CAption><colgroup span="2">
<tr>
<th>
<FONT SIzE="2">
<P>Command-Line Option</p>
</FOnT></tH>
<TH>
<Font sIZE="2">
<P>Description</p>
</fonT></TH>
</Tr>
<tr>
<tD>
<FONt size="2"> </font></td>
<td>
<font size="2">
<P>The default is to register the COM objects.</P>
</FONT></tD>
</Tr>
<TR>
<tD>
<fONT Size="2">
<p><TT CLass="monofont">--unregister</tT></P>
</FOnt></td>
<TD>
<FOnt size="2">
<p>Unregisters the objects. This removes all references to the objects
from the Windows registry.</p>
</font></td>
</tr>
<tr>
<td>
<fONT SIZe="2">
<P><Tt CLaSs="monofont">--debug</TT></P>
</Font></tD>
<TD>
<Font sIZE="2">
<P>Registers the COM servers in debug mode. We discuss debugging COM
servers later in this chapter.</p>
</fonT></TD>
</Tr>
<tr>
<td>
<font size="2">
<p><tt class="monofont">--quiet</TT></P>
</FONt></TD>
<tD>
<FoNt SIZE="2">
<p>Register (or unregister) the object quietly (i.e., don't report
success).</p>
</foNT></TD>
</tr>
</coLGROup>
</taBLE></P>



<p>Each option uses a <a name="idx1190"></a>double hyphen. For example,
if your COM objects are implemented in
<i>YourServer.py</i>, use the following commands.</p>



<p>To register objects:</p>



<pre class="monofont">C:\Scripts&gt; Python.exe YourServer.py</pRE>


<P>To unregister the objects:</P>



<PRe CLaSS="monofont">C:\Scripts&gt; Python.exe YourServer.py --unregister</pRe>


<P>To register the objects for debugging:</P>



<PRe claSS="monofont">C:\Scripts&gt; Python.exe YourServer.py --debug</PRe>


<p>With a standard Python setup, double-clicking on a Python COM server
script in Explorer has the same effect as the first example and
registers the server.<a nAME="idx1191"></A></p>







<h4>12.6.3
Error Handling for COM Servers</h4>


<p>
<A NAMe="idx1192"></a>
<a name="idx1193"></a>
<a name="idx1194"></a>When you implement a COM
object, it's often necessary to return error information to the
caller. Although Python has a powerful exception mechanism, the
caller of your objects is likely to be Visual Basic or Delphi, so
standard Python exceptions don't really work.</p>



<p>To support this, the
<tt claSS="monofont">win32com.server.exception</TT>
<A NaME="idx1195"></a> module exposes the
<TT cLaSS="monofont">COMException</TT>
<a namE="idx1196"></A> Python object in order to raise an
exception to COM. This object allows you to specify many details
about the error, including the error message, the name of the
application generating the error, the name of a help file in which
the user can find additional information, etc. See the
<TT clasS="monofont">win32com.server.exception</TT> module for more details.</P>



<p>The PythonCOM framework makes the assumption that all Python
exceptions other than <tt cLASS="monofont">COMException</tt> indicate a
<a name="idx1197"></a>bug in your
code. Thus, your object shouldn't allow normal Python
exceptions to be raised when calling your methods, but should take
steps to handle these Python exceptions and translate them to an
appropriate <tt class="monofont">COMException</tt>.</p>



<p>As an example, let's assume you want to publish a method called
<tt CLASS="monofont">sqrt()</Tt> that returns the square root of its
argument. If you use the following code:</P>



<PrE ClAsS="monofont">def sqrt(self, val):
        return math.sqrt(val)</PRE>


<p>you have a potential problem; in fact, a few of them. If you pass
anything other than a positive number to your function, the code
fails, and a Python exception is raised. This is considered a bug in
your COM object. To improve this function, use the following code:</p>



<prE CLAss="monofont">def sqrt(self, val):
        try:
            return math.sqrt(val)
        except (TypeError, ValueError):
            raise COMException("The argument must be a positive number", \
                                winerror.DISP_E_TYPEMISMATCH)</prE>


<P>This version of the code does the right thing: it traps the
exceptions that may be raised by the <TT clasS="monofont">math.sqrt()</TT>
function and raises a <Tt class="monofont">COMException</tt> object with a
useful message and value.</p>






<a name="9"></a>
<h4>12.6.4
Policies</h4>


<p>
<a naME="idx1198"></A>
<A NAmE="idx1199"></A>PythonCOM policies are an advanced
topic and typically don't need to be understood to successfully
use Python and COM. However, if you need to perform advanced
techniques using Python and COM, this information is valuable. You
may wish to skip this section and come back to it when the need
arises.</p>



<P>A PythonCOM policy determines how Python objects are exposed to COM;
the policy dictates which attributes are exposed to COM and the IDs
these attributes get. The policy actually sits between COM and your
object and is responsible for responding to the
<Tt ClASS="monofont">IDispatch</Tt>
<a naME="idx1200"></A>
interface's
<Tt claSS="monofont">GetIDsOfNames()</TT>
<a namE="idx1201"></A> and
<TT class="monofont">Invoke()</tt>
<a name="idx1202"></a> functions. The policy dictates how
these <tt class="monofont">IDispatch</tT> calls are translated into the
references to your Python object.</P>



<P>The
<A NAmE="idx1203"></A>
<a NAmE="idx1204"></a>default
PythonCOM policy is suitable in most cases, and all the examples to
date have used the default policy. The policy implemented is:</P>



<UL>
<Li><p>All methods named in the <tt CLASs="monofont">_public_methods_</tt>
attribute are exposed to COM. Any method not listed in
<tT CLAss="monofont">_public_methods_</tt> is considered private.</P>
</LI>
<Li><p>All properties named in the <tt class="monofont">_public_attrs_</tt>
attribute are exposed to COM. If the property name also appears in
the attribute <tt class="monofont">_readonly_attrs_</tt>, it can be read,
but not written; otherwise, users of this object can change the
property.</p>
</LI>
<LI><P>Other special attributes can obtain advanced behavior. You can review
the full list of attributes in <A href="pythonwin32_snode98.html#6">Table 12.4</A>.</P>
</lI>
</uL>
<P>What this means is that the PythonCOM framework itself doesn't
determine how an object is exposed via COM; it's determined by
the policy.</P>



<P>The PythonCOM package provides two useful policies: the default
policy (known as the <a namE="idx1205"></A>DesignatedWrapPolicy, because
the attributes exposed via COM must be explicitly designated) and the
<A Name="idx1206"></a>DynamicPolicy that implements a far more
liberal approach to publishing objects. These policies are
implemented in the
<TT CLass="monofont">win32com.server.policy</tT>
<A NAme="idx1207"></a> module.</p>



<p>The DynamicPolicy requires your Python class to implement a single
function named <tt class="monofont">_dynamic_ </tt>, and this function must
implement the logic to determine if the COM call is requesting a
property reference or a method call.</p>



<p>To demonstrate the DynamicPolicy, we present a more advanced COM
server in the following example. The aim of this COM server is to
expose the entire Python string module. Anyone using Visual Basic or
Delphi can then use all the string-processing functions available to
Python.</p>



<p>Before we look at the code, there are a couple of points:</p>



<ul>
<LI><P>The Unicode strings bite us again! As COM passes all strings as
Unicode, you need to convert them to Python strings before the string
module can work with them.</P>
</LI>
<lI><P>Most of the registration data is the same as discussed previously,
except there is a new attribute,
<tT ClAsS="monofont">_reg_policy_spec_</TT>. This attribute identifies that
you need to use the DynamicPolicy rather than the default
DesignatedWrapPolicy.</P>
</li>
<li><P>The handling of <TT Class="monofont">IDispatch.GetIDsOfNames()</TT> has been
done for you (the <TT clasS="monofont">_dynamic_</TT> methods deal with
attribute names), and the policy has dealt with the IDs for the
attributes.</P>
</li>
<li><p>There is some extra internal knowledge of COM needed to implement the
<tt class="monofont">_dynamic_</tt> method. Specifically, you need to
differentiate between a property reference and a method call. Also
remember that VB is not case-sensitive, while Python is.</p>
</li>
</ul>
<prE CLASS="monofont"># DynamicPolicy.py -- A demonstration of dynamic policies in PythonCOM
import string
import pythoncom
import pywintypes
import winerror
import types
from win32com.server.exception import COMException

def FixArgs(args):
    # Fix the arguments, so Unicode objects are
    # converted to strings.  Does this recursively,
    # to ensure sub-lists (ie, arrays) are also converted
    newArgs = []
    for arg in args:
        if type(arg)==types.TupleType:
            arg = FixArgs(arg)
        elif type(arg)==pywintypes.UnicodeType:
            arg = str(arg)
        newArgs.append(arg)
    return tuple(newArgs)

class PythonStringModule:
    _reg_progid_ = "PythonDemos.StringModule"
    _reg_clsid_ = "{CB2E1BC5-D6A5-11D2-852D-204C4F4F5020}"
    _reg_policy_spec_ = "DynamicPolicy"

    # The dynamic policy insists that we provide a method
    # named _dynamic_, and that we handle the IDispatch::Invoke logic.
    def _dynamic_(self, name, lcid, wFlags, args):
        # Get the requested attribute from the string module.
        try:
            item = getattr(string, string.lower(name))
        except AttributeError:
            raise COMException("No attribute of that name", \
                               winerror.DISP_E_MEMBERNOTFOUND)
        # Massage the arguments...
        args = FixArgs(args)
        # VB will often make calls with wFlags set to
        # DISPATCH_METHOD | DISPATCH_PROPERTYGET, as the VB
        # syntax makes the distinction impossible to make.
        # Therefore, we also check the object being referenced is
        # in fact a Python function
        if (wFlags &amp; pythoncom.DISPATCH_METHOD) and \
           type(item) in [types.BuiltinFunctionType, types.FunctionType]:
            return apply(item, args)
        elif wFlags &amp; pythoncom.DISPATCH_PROPERTYGET:
            return item
        else:
            raise COMException("You can not set this attribute", 
                               winerror.DISP_E_BADVARTYPE)

# Add code so that when this script is run by
# Python.exe, it self-registers.
if __name__=='__main__':
    import win32com.server.register
    win32com.server.register.UseCommandLine(PythonStringModule)</pRE>


<p>To test the COM object, use the following VBA code:</P>



<PrE cLASS="monofont">Sub Test()
    ' Create the Python COM objects.
    Set stringmod = CreateObject("PythonDemos.StringModule")
    ' Call string.split
    response = stringmod.Split("Hello from VB")
    For Each Item In response
        MsgBox (Item)
    Next
    ' Call string.join
    MsgBox "The items joined are " &amp; stringmod.join(response)
    ' Get string.uppercase
    MsgBox "The upper case character are" &amp; stringmod.uppercase
    
    ' Attempt to set a property - this should fail.
    stringmod.uppercase = "Hi"

End Sub</pre>


<p>When you run this code, you should see a series of message boxes,
followed by an error dialog. As mentioned in the code, the attempt to
set <TT CLass="monofont">string.uppercase</tT> should fail, and indeed it
does.</P>



<P>As you can see, the DynamicPolicy has given you the tools to wrap any
arbitrary Python object, rather than requiring you to explicitly
declare the public interface. Depending on your requirements, this
may or may not serve your purpose better than the default policy, but
if neither of these policies meet your requirements, just write your
own! The <Tt claSS="monofont">Python.Dictionary</TT> sample COM object
(implemented in the module
<tt class="monofont">win32com.servers.dictionary</tt>) implements its own
specialized policy, so it's a good starting point if you need
to go this<a name="idx1208"></a> route.<a name="idx1209"></a> <A NAME="idx1210"></A></p>







<H4>12.6.5
Wrapping and Unwrapping</H4>


<p>
<A NaMe="idx1211"></A>
<A NAme="idx1212"></a>Whenever you expose a Python object via
COM, you actually expose an
<tT CLAss="monofont">IDispatch</tt>
<A NAMe="idx1213"></a>
object. As described previously, the
<tt CLASs="monofont">IDispatch</tt>
<a name="idx1214"></a> interface is used to expose
automation objects. Thus, whenever a Visual Basic program is using a
Python COM object, VB itself is dealing with a COM
<tt class="monofont">IDispatch</tt> object. The Python COM framework
provides the <tt cLASS="monofont">IDispatch</TT> object that wraps your
Python COM class instance. Whenever the COM framework creates a new
Python COM object, the general process is:</p>



<UL>
<lI><P>An instance of the selected policy for the object is created.</p>
</Li>
<LI><P>The policy creates an instance of your Python class.</P>
</li>
<li><P>An <TT Class="monofont">IDispatch</TT> object is created that wraps the
Python policy (which in turn wraps your instance).</P>
</Li>
<li><p>The <TT CLass="monofont">IDispatch</tt> object is returned to the client
(e.g., Visual Basic).</p>
</li>
</ul>
<p>Thus, when you need to create an <tt class="monofont">IDispatch</tt> from a
Python class instance, you should wrap the object. Unwrapping is the
reverse of this process; if you have an <tT CLASS="monofont">IDispatch</tT>
object that wraps a Python instance, you can unwrap the
<Tt CLaSs="monofont">IDispatch</TT> object, returning the underlying Python
instance.</P>



<P>In many cases you don't need to worry about this. When you
expose a COM object that can be directly created via COM, the Python
COM framework handles all the wrapping for you. However, there are a
number of cases where the explicit wrapping of objects is necessary.</p>



<p>The most common scenario is when you need to expose a COM object via
some sort of factory method; that is, rather than allowing the user
to create your object directly using VB's
<tt CLASs="monofont">CreateObject()</tt>, you return the object from another
object. Microsoft <a NAME="idx1215"></a>Office provides good examples of
this behavior: the object model defines <tt cLASS="monofont">Cell</tt> or
<tt class="monofont">Paragraph</tt> objects, but you can't create them
directly. You must create the <tt class="monofont">Application</tt> object
and use it to create or reference <tT CLASS="monofont">Cells</tT> and
<Tt CLaSs="monofont">Paragraphs</TT>.</P>



<P>We will use a contrived example to demonstrate the wrapping and
unwrapping of objects. But before that, we take a small digression
into techniques that debug the COM objects. These debugging
techniques demonstrate wrapping and unwrapping and also how to use
<tt clASS="monofont">IDispatch</Tt> objects passed as parameters.</p>







<h4>12.6.6
Debugging Python COM Objects</h4>


<P>
<A NAme="idx1216"></a>When you
use COM clients such as Excel from Python, you can employ the same
debugging techniques as for any Python code; you are simply calling
Python objects. However, when you implement COM objects in Python,
things become more difficult. In this case, the caller of your Python
code isn't Python, but another application, such as Visual
Basic or Delphi. These applications obviously have no concept of a
Python exception or a Python traceback, so finding bugs in your
Python code can be a problem.</p>



<P>In a nutshell: register your COM objects using <A NAme="idx1217"></a>
<a name="idx1218"></a>-<tt class="monofont">debug</tt> on the
command line. Then use the <a naME="idx1219"></A>Trace Collector
Debugging Tool item on the PythonWin Tools menu to see any print
statements or Python exceptions. The rest of this section is devoted
to how this works.</P>



<P>To assist with the debugging problem, the Python COM framework has
the concept of a
<I>dispatcher</i>
<A NaME="idx1220"></a>.
A dispatcher is similar to a policy object, but dispatches calls to
the policy. The
<Tt CLASs="monofont">win32com</tt>
<a NAME="idx1221"></a>
package provides a number of useful dispatchers.</p>



<p>When you register the <a NAME="idx1222"></a>COM Server with
<tt cLASS="monofont">--debug</tt> (note the double hyphen), the registration
mechanism also registers a dispatcher for your object. The default
dispatcher is known as
<tt class="monofont">DispatcherWin32trace,</tt>
<a name="idx1223"></a> although you can specify a
different dispatcher using the
<tt clASS="monofont">_reg_debug_dispatcher_spec_</TT> attribute on your
object, as described in the earlier section <A href="pythonwin32_snode98.html#4">Section 12.6.2</A>.</P>



<p>The default <Tt CLASs="monofont">DispatcherWin32trace</tt> uses the
<tT CLAss="monofont">win32trace</tt>
<A NAMe="idx1224"></a> module to display its output. To see the
output of a COM server when debugging, use the Trace Collector
Debugging Tool item on the PythonWin Tools menu.</p>







<h4>12.6.7
The Final Sample</H4>


<P>
<A Name="idx1225"></a> <a name="idx1226"></a>A final sample COM server demonstrates
wrapping and unwrapping objects, how to use
<tt class="monofont">IDispatch</tt>
<a nAME="idx1227"></A> objects when passed as parameters to COM
functions, and also how to debug your COM servers. This example is
contrived and does nothing useful other than demonstrate these
concepts.</P>



<P>The sample exposes two COM objects, a <tT ClASs="monofont">Parent</Tt>
object and a <TT CLass="monofont">Child</tT> object. The
<TT Class="monofont">Parent</TT> object is registered with COM so VB code
can use <TT clasS="monofont">CreateObject</TT> to create it. The
<Tt class="monofont">Child</tt> object isn't registered and can be
created only by calling the <tt class="monofont">CreateChild()</tt> method
on the <tt clASS="monofont">Parent</TT>. The <Tt CLaSS="monofont">Child</tT> object
has no methods, just a <tT CLAss="monofont">Name</tt> property.</P>



<P>The Parent object also has a method called
<TT clasS="monofont">KissChild()</TT>, that should be called with a
<Tt claSS="monofont">Child</TT> object previously created by the parent.
The <tt class="monofont">KissChild()</tt> method demonstrates how to use the
<tt class="monofont">IDispatch</tt> passed to the method and also how to
unwrap the <tt cLASS="monofont">IDispatch</TT> to obtain the underlying
Python object.</p>



<P>Finally, the code has a number of <Tt CLaSs="monofont">print</TT> statements
and a lack of error handling. We use the debugging techniques to see
these <TT clasS="monofont">print</TT> statements and also a Python exception
raised:</P>



<pre cLASS="monofont"># ContrivedServer.py
#
# A contrived sample Python server that demonstrates 
# wrapping, unwrapping, and passing IDispatch objects.

# Import the utilities for wrapping and unwrapping.
from win32com.server.util import wrap, unwrap

import win32com.client

# Although we are able to register our Parent object for debugging,
# our Child object is not registered, so this won't work. To get
# the debugging behavior for our wrapped objects, we must do it ourself.
debugging = 1
if debugging:
    from win32com.server.dispatcher import DefaultDebugDispatcher
    useDispatcher = DefaultDebugDispatcher
else:
    useDispatcher = None

# Our Parent object.
# This is registered, and therefore creatable
# using CreateObject etc from VB.
class Parent:
    _public_methods_ = ['CreateChild', 'KissChild']
    _reg_clsid_ = "{E8F7F001-DB69-11D2-8531-204C4F4F5020}"
    _reg_progid_ = "PythonDemos.Parent"

    def CreateChild(self):
        # We create a new Child object, and wrap
        # it using the default policy
        # If we are debugging, we also specify the default dispatcher
        child = Child()
        print "Our Python child is", child
        wrapped = wrap( child, useDispatcher=useDispatcher )
        print "Returing wrapped", wrapped
        return wrapped

    def KissChild(self, child):
        print "KissChild called with child", child
        # Our child is a PyIDispatch object, so we will attempt
        # to use it as such.  To make it into something useful,
        # we must convert it to a win32com.client.Dispatch object.
        dispatch = win32com.client.Dispatch(child)
        print "KissChild called with child named", dispatch.Name

        # Now, assuming it is a Python child object, let's
        # unwrap it to get the object back!
        child = unwrap(child)
        print "The Python child is", child

# Our Child object.
# This is not registered        
class Child:
    _public_methods_ = []
    _public_attrs_ = ['Name']
    def __init__(self):
        self.Name = "Unnamed"

if __name__=='__main__':
    import win32com.server.register
    win32com.server.register.UseCommandLine(Parent, debug=debugging)</pre>


<p>Before you register your class, we must mention some of the
debugging-related code. Near the top of the source file, we declare a
variable named <TT CLass="monofont">debugging</tt>. If this variable is
<tt class="monofont">true</tt>, you then load the
<tt class="monofont">DefaultDebugDispatcher</TT> and assign it to a
variable. In the <TT CLaSS="monofont">CreateChild()</tT> method, you pass
this dispatcher to the <Tt ClASS="monofont">wrap</Tt> function. This is due
to a quirk in the debug mechanism. As mentioned previously, the
registration mechanism allows you to register an object for debugging
by using <tt cLASS="monofont">--debug</tt> on the command line. While this
works fine for objects you register, recall that our
<tt CLASs="monofont">Child</tt> object isn't registered, so it
doesn't benefit from this mechanism; this code enables it for
both objects. Also note that you pass this debugging variable to
the<tT CLAss="monofont">
UseCommandLine()</tt>
<a name="idx1228"></a> function. This allows you to control
the debugging behavior totally from your debugging variable. If set,
debugging is enabled for all objects, regardless of the command line.
If not set, you don't get debugging for either object.</p>



<p>So you can register this <a name="idx1229"></a>COM server like the other COM
servers; no need for anything special on the command line. You
register the server by running the script (either from within
PythonWin, or using Windows Explorer). After registration, you should
see the message:</p>



<prE CLASS="monofont">Registered: PythonDemos.Parent (for debugging)</pRE>


<p>The next step is for some VB code to use your object. For this
demonstration, you can use the following Visual Basic for
Applications code from either Excel or Word:</P>



<PrE cLASS="monofont">Sub DebuggingTest()
  Set ParentObj = CreateObject("PythonDemos.Parent")

  Set child = ParentObj.CreateChild()
  MsgBox "Child's name is " &amp; child.Name

  ParentObj.KissChild child
  MsgBox "I kissed my child"

  ' Now lets pass a non-python object!
  ' As we are using VBA (either Word or Excel)
  ' we just pass our application object.
  ' This should fail with an InternalError.
  Set app = Application
  ParentObj.KissChild (app)
End Sub</pre>


<p>This code is simple: it creates a <TT CLass="monofont">Parent</tT> object,
then calls the <TT Class="monofont">CreateChild()</TT> method, giving a
<TT class="monofont">Child</tt> object. You fetch the name of the child,
then display it in a message box. The next step is to call the
<tt class="monofont">KissChild()</tt> method and display another message box
when the kiss is complete. The final step is to call the
<tt claSS="monofont">KissChild()</TT> method, but pass a different object,
in this case the Excel (or Word) <TT cLAsS="monofont">Application</Tt>
object.</P>



<p>Before running this code, you should open the window that displays
the debugging output and select the Trace Collector Debugging Tool
item on the PythonWin Tools menu.</P>



<P>Now, let's run the Visual Basic code and stop at the first
message box. The debug window should now display:</P>



<Pre clASS="monofont">Object with win32trace dispatcher created (object=None)
in _GetIDsOfNames_ with '('CreateChild',)' and '1033'
in _Invoke_ with 1000 1033L 3 ()
Our Python child is &lt;ContrivedServer.Child instance at 2a8d5e0&gt;
Object with win32trace dispatcher created (object=&lt;ContrivedServer.Child instance ...
Returing wrapped &lt;PyIDispatch at 0x2a80254 with obj at 0x2a801c0&gt;
in _GetIDsOfNames_ with '('Name',)' and '1033'
in _Invoke_ with 1000 1033L 3 ()</Pre>


<p>The first thing to note is there are a number of unexpected lines;
the Python COM framework has printed some extra debugging information
for you. The first three lines show how internally
<tT CLAss="monofont">GetIDsOfNames()</tt>
<A NAMe="idx1230"></a> and
<tt class="monofont">Invoke()</tt>
<a name="idx1231"></a> have been translated by the Python COM
framework. The fourth line is one of yours: it's the
<tt clASS="monofont">print</TT> statement in the
<Tt CLaSS="monofont">CreateChild()</tT> method. Wrapping the
<tT CLAss="monofont">Child</tt> object causes the Python COM framework to
print the next output line, which is followed by the next
<TT CLass="monofont">print</tT> statement.</P>



<P>If you now dismiss the next couple of message boxes in the VB
example, you should see an error message that looks like that in
<A href="pythonwin32_snode98.html#19">Figure 12.3</A>.</P>



<CEnter>
<h5>
<a name="19"></a>Figure 12.3. Visual Basic error dialog when running the sample</h5>

<img border="0" WIDTH="502" HeIGhT="130" src="FILES/ppw.1203.gif" aLT="figs/ppw.1203.gif"></CEnter>


<P>
<A NAme="idx1232"></a>
<a NAME="idx1233"></a>As you can see, you have the
"Unexpected Python Error," discussed previously, which
means you have an unhandled Python exception in the COM server. If
you look in the debugging window, the last few lines are:</p>



<prE CLAss="monofont">in _Invoke_ with 1001 1033L 1 (&lt;PyIDispatch at 0x2a7bbb4 with obj at 0xcdd4f8&gt;,)
KissChild called with child &lt;PyIDispatch at 0x2a7bbb4 with obj at 0xcdd4f8&gt;
KissChild called with child named Microsoft Word
Traceback (innermost last):
  File "L:\src\pythonex\com\win32com\server\dispatcher.py", line 40, in _Invoke_
    return self.policy._Invoke_(dispid, lcid, wFlags, args)
  File "L:\src\pythonex\com\win32com\server\policy.py", line 265, in _Invoke_
    return self._invoke_(dispid, lcid, wFlags, args)
  File "L:\src\pythonex\com\win32com\server\policy.py", line 486, in _invoke_
    return S_OK, -1, self._invokeex_(dispid, lcid, wFlags, args, None, None)
  File "L:\src\pythonex\com\win32com\server\policy.py", line 498, in _invokeex_
    return apply(func, args)
  File "L:\docs\Book\Python and COM\ContrivedServer.py", line 49, in KissChild
    child = unwrap(child)
  File "L:\src\pythonex\com\win32com\server\util.py", line 36, in unwrap
    ob = pythoncom.UnwrapObject(ob)
ValueError: argument is not a Python gateway</pre>


<p>Here are the full details of the Python exception. This makes
tracking the error much simpler: it should be obvious that the error
occurs when you attempt to unwrap the Microsoft Excel application
object. The unwrap fails because there is no Python object behind
this interface.</p>



<p>One final note relates to how an
<tt class="monofont">IDispatch</tt>
<a namE="idx1234"></A> object is used as a parameter to a COM
function. In the debugging window, locate the following messages:</P>



<PRE cLAsS="monofont">KissChild called with child &lt;PyIDispatch at 0x2a86624 with obj at 0x2a865b0&gt;
KissChild called with child named in _GetIDsOfNames_ with '('Name',)' and '0'

in _Invoke_ with 1000 0L 2 ()
Unnamed
The Python child is &lt;ContrivedServer.Child instance at 2a7aa90&gt;</PrE>


<p>The raw parameter to <TT CLass="monofont">KissChild()</tT> is in fact a
<TT Class="monofont">PyIDispatch</TT>
<A Name="idx1235"></a> object. You may recall from the start of
this chapter that a <TT CLass="monofont">PyIDispatch</tt> object only has
methods <tt class="monofont">GetIDsOfNames()</tt> and
<tt class="monofont">Invoke()</TT>. To turn the object into something
useful, you must use a <TT CLaSS="monofont">win32com.client.Dispatch()</tT>
object. Once you have the <Tt ClASS="monofont">win32com.client.Dispatch</Tt>
object, use it like any other COM object; in the
example<tt cLASS="monofont"></tt>
<a nAME="idx1236"></A>, we called the<a namE="idx1237"></A> <A Name="idx1238"></a>
<tt class="monofont">Name</tt> property.<a name="idx1239"></a></p>


</fONT>
 
<table width="100%" border="0" cellspacing="0" cellpadding="0" bgcolor="#CCCCCC">
<td><font color="black" size=1>I l<font color="#FF0000">@</font>ve RuBoard</td>
<td valign="top" class="v2" align="right"><a href="pythonwin32_snode97.html"><img src="FILES/previous.gif" width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a> <a href="pythonwin32_snode99.html"><img src="FILES/next.gif" width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a></td></table>
</BODY></HTML>