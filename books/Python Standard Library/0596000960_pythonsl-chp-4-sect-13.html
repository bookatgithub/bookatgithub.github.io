<html><head>
<META http-equiv="Content-Type" content="text/html">
<!--SafClassName="docSection1Title"--><!--SafTocEntry="4.13 The quopri Module"-->
<link rel="STYLESHEET" type="text/css" href="FILES/style.css">
<link rel="STYLESHEET" type="text/css" href="FILES/docsafari.css">
</head>
<body>
<table width="100%" border="0" cellspacing="0" cellpadding="0" bgcolor="#CCCCCC">
<td><font color="black" size=1>I l<font color="#FF0000">@</font>ve RuBoard</td>
<td valign="top" class="v2" align="right">
	<a href="0596000960_pythonsl-CHP-4-SECT-12.html"><img src="FILES/previous.gif" width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a>
	<a href="0596000960_pythonsl-CHP-4-SECT-14.html"><img src="FILES/next.gif" width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a>
</td></table>
<br>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<tr>
<td valign="top"><A NAME="pythonsl-CHP-4-SECT-13"></A>
<H3 class="docSection1Title">4.13 The quopri Module</H3>

<P class="docText">

<A NAME="IXT-4-189587"></A>
<A NAME="IXT-4-189588"></A>

The <TT>quopri</TT> module implements quoted printable encoding, according to
the MIME standard.</P>


<P class="docText">This encoding can be used to convert text messages
that consist mostly of plain U.S. ASCII text, such as messages written
in most European languages, to messages that only use U.S. ASCII.  This
can be quite useful if you're sending stuff via steam-powered mail
transports to people using vintage mail agents. <A class="docLink" HREF="#pythonsl-CHP-4-EX-23">Example 4-23</A> demonstrates.</P>


<H5 class="docExampleTitle"><A NAME="pythonsl-CHP-4-EX-23"></A>Example 4-23. Using the quopri Module</H5>

<PRE>
File: quopri-example-1.py

import quopri
import StringIO

# helpers (the quopri module only supports file-to-file conversion)

def encodestring(instring, tabs=0):
    outfile = StringIO.StringIO()
    quopri.encode(StringIO.StringIO(instring), outfile, tabs)
    return outfile.getvalue()

def decodestring(instring):
    outfile = StringIO.StringIO()
    quopri.decode(StringIO.StringIO(instring), outfile)
    return outfile.getvalue()

#
# try it out

MESSAGE = "&aring; i &aring;a &auml; e &ouml;!"

encoded_message = encodestring(MESSAGE)
decoded_message = decodestring(encoded_message)

print "original:", MESSAGE
print "encoded message:", repr(encoded_message)
print "decoded message:", decoded_message

<B>original: &aring; i &aring;a &auml; e &ouml;!
encoded message: '=E5 i =E5a =E4 e =F6!\012'
decoded message: &aring; i &aring;a &auml; e &ouml;!</B></PRE>


<P class="docText">As <A class="docLink" HREF="#pythonsl-CHP-4-EX-23">Example 4-23</A> shows, non-U.S. characters are mapped to an equals sign (=)
followed by two hexadecimal digits.  So it is the equals sign character itself
(
"=3D"), as well as whitespace at the end of lines
(
"=20").  Everything else looks just like before.  So
provided you don't use too many weird characters, the encoded string
is nearly as readable as the original.</P>

<P class="docText">(Europeans generally hate this encoding and strongly believe
that certain U.S. programmers deserve to be slapped in the head with a
huge great fish to the jolly music of Edward German....)</P>

<ul></ul>
</td>
</tr>
</table>
<td></td>
<table width="100%" border="0" cellspacing="0" cellpadding="0" bgcolor="#CCCCCC">
<td><font color="black" size=1>I l<font color="#FF0000">@</font>ve RuBoard</td>
<td valign="top" class="v2" align="right">
          <a href="0596000960_pythonsl-CHP-4-SECT-12.html"><img src="FILES/previous.gif" width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a>
          <a href="0596000960_pythonsl-CHP-4-SECT-14.html"><img src="FILES/next.gif" width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a>
</td></table>
</body></html>
