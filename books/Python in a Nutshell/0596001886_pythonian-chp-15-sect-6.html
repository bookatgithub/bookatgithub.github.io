<html><head>
<META http-equiv="Content-Type" content="text/html">
<!--SafClassName="docSection1Title"--><!--SafTocEntry="15.6 Array Objects"-->
<link rel="STYLESHEET" type="text/css" href="FILES/style.css">
<link rel="STYLESHEET" type="text/css" href="FILES/docsafari.css">
<style type="text/css">	.tt1    {font-size: 10pt;}</style>
</head>
<body>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<td class="tt1"><a href="NFO/lib.html">[ Team LiB ]</a></td><td valign="top" class="tt1" align="right">
	<a href="0596001886_pythonian-chp-15-sect-5.html"><img src="FILES/previous.gif" width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a>
	<a href="0596001886_pythonian-chp-15-sect-7.html"><img src="FILES/next.gif" width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a>
</td></table>
<br>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<tr>
<td valign="top"><A NAME="pythonian-CHP-15-SECT-6"></A>
<H3 class="docSection1Title">15.6 Array Objects</H3>

<P class="docText"><TT>Numeric</TT><A NAME="pythonian-CHP-15-ITERM-7179"></A>
<A NAME="pythonian-CHP-15-ITERM-7180"></A> provides an
<TT>array</TT> type that represents a grid of items. An
<TT>array</TT> object <TT><I>a</I></TT> has a
specified number of dimensions, known as its
<span class="docEmphasis">rank</span>, up to some arbitrarily high limit
(normally <TT>40</TT>, when <TT>Numeric</TT> is
built with default options). A scalar (i.e., a single number) has
rank <TT>0</TT>, a vector has rank <TT>1</TT>, a
matrix has rank <TT>2</TT>, and so
forth.<A NAME="pythonian-CHP-15-ITERM-7181"></A></P>

<A NAME="pythonian-CHP-15-SECT-6.1"></A>
<H4 class="docSection2Title">15.6.1 Type Codes</H4>

<P class="docText"><A NAME="pythonian-CHP-15-ITERM-7182"></A>
<A NAME="pythonian-CHP-15-ITERM-7183"></A>The
values that occupy cells in the grid of an <TT>array</TT>
object, known as the <span class="docEmphasis">elements</span> of the array, are
homogeneous, meaning they are all of the same type, and all element
values are stored within one memory area. This contrasts with a list
or tuple, where the items may be of different types and each is
stored as a separate Python object. This means a
<TT>Numeric</TT> array occupies far less memory than a
Python list or tuple with the same number of items. The type of
<TT><I>a</I></TT>'s elements is encoded
as <TT><I>a</I></TT>'s type code, a
one-character string, as shown in <A class="docLink" HREF="#pythonian-CHP-15-TABLE-3">Table 15-3</A>.
Factory functions that build <TT>array</TT> instances,
covered in <A class="docLink" HREF="#pythonian-CHP-15-SECT-6.6">Section 15.6.6</A>
later in this chapter, take a <TT><I>typecode</I></TT>
argument that is one of the values in <A class="docLink" HREF="#pythonian-CHP-15-TABLE-3">Table 15-3</A>.</P>

<A NAME="pythonian-CHP-15-TABLE-3"></A><P><TABLE BORDER="1" CELLSPACING="0" CELLPADDING="1" WIDTH="100%">
<CAPTION><h5 class="docTableTitle">Table 15-3. Type codes for Numeric arrays</h5></CAPTION><COLGROUP span="4">
<TR>
<TH class="docTableHeader">
<P class="docText">Type code</P>
</TH>
<TH class="docTableHeader">
<P class="docText">C type</P>
</TH>
<TH class="docTableHeader">
<P class="docText">Python type</P>
</TH>
<TH class="docTableHeader">
<P class="docText">Synonym</P>
</TH>
</TR>
<TR>
<TD class="docTableCell">
<PRE>'c'</PRE>
</TD>
<TD class="docTableCell">
<PRE>char</PRE>
</TD>
<TD class="docTableCell">
<P class="docText"><TT>str</TT> (length 1)</P>
</TD>
<TD class="docTableCell">
<PRE>Character</PRE>
</TD>
</TR>
<TR>
<TD class="docTableCell">
<PRE>'b'</PRE>
</TD>
<TD class="docTableCell">
<PRE>unsigned char</PRE>
</TD>
<TD class="docTableCell">
<PRE>int</PRE>
</TD>
<TD class="docTableCell">
<PRE>UnsignedInt8</PRE>
</TD>
</TR>
<TR>
<TD class="docTableCell">
<PRE>'1'</PRE>
</TD>
<TD class="docTableCell">
<PRE>signed char</PRE>
</TD>
<TD class="docTableCell">
<PRE>int</PRE>
</TD>
<TD class="docTableCell">
<PRE>Int8</PRE>
</TD>
</TR>
<TR>
<TD class="docTableCell">
<PRE>'s'</PRE>
</TD>
<TD class="docTableCell">
<PRE>short</PRE>
</TD>
<TD class="docTableCell">
<PRE>int</PRE>
</TD>
<TD class="docTableCell">
<PRE>Int16</PRE>
</TD>
</TR>
<TR>
<TD class="docTableCell">
<PRE>'i'</PRE>
</TD>
<TD class="docTableCell">
<PRE>int</PRE>
</TD>
<TD class="docTableCell">
<PRE>int</PRE>
</TD>
<TD class="docTableCell">
<PRE>Int32</PRE>
</TD>
</TR>
<TR>
<TD class="docTableCell">
<PRE>'l'</PRE>
</TD>
<TD class="docTableCell">
<PRE>long</PRE>
</TD>
<TD class="docTableCell">
<PRE>int</PRE>
</TD>
<TD class="docTableCell">
<PRE>Int</PRE>
</TD>
</TR>
<TR>
<TD class="docTableCell">
<PRE>'f'</PRE>
</TD>
<TD class="docTableCell">
<PRE>float</PRE>
</TD>
<TD class="docTableCell">
<PRE>float</PRE>
</TD>
<TD class="docTableCell">
<PRE>Float32</PRE>
</TD>
</TR>
<TR>
<TD class="docTableCell">
<PRE>'F'</PRE>
</TD>
<TD class="docTableCell">
<P class="docText">two <TT>float</TT>s</P>
</TD>
<TD class="docTableCell">
<PRE>complex</PRE>
</TD>
<TD class="docTableCell">
<PRE>Complex32</PRE>
</TD>
</TR>
<TR>
<TD class="docTableCell">
<PRE>'d'</PRE>
</TD>
<TD class="docTableCell">
<PRE>double</PRE>
</TD>
<TD class="docTableCell">
<PRE>float</PRE>
</TD>
<TD class="docTableCell">
<PRE>Float</PRE>
</TD>
</TR>
<TR>
<TD class="docTableCell">
<PRE>'D'</PRE>
</TD>
<TD class="docTableCell">
<P class="docText">two <TT>double</TT>s</P>
</TD>
<TD class="docTableCell">
<PRE>complex</PRE>
</TD>
<TD class="docTableCell">
<PRE>Complex</PRE>
</TD>
</TR>
<TR>
<TD class="docTableCell">
<PRE>'O'</PRE>
</TD>
<TD class="docTableCell">
<PRE>PyObject*</PRE>
</TD>
<TD class="docTableCell">
<PRE>any</PRE>
</TD>
<TD class="docTableCell">
<PRE>PyObject</PRE>
</TD>
</TR>
</COLGROUP>
</TABLE></P>

<P class="docText"><TT>Numeric</TT> supplies readable attribute names for each
type code, as shown in the last column of <A class="docLink" HREF="#pythonian-CHP-15-TABLE-3">Table 15-3</A>. <TT>Numeric</TT> also supplies, on
all platforms, the names <TT>Int0</TT>,
<TT>Float0</TT>, <TT>Float8</TT>,
<TT>Float16</TT>, <TT>Float64</TT>,
<TT>Complex0</TT>, <TT>Complex8</TT>,
<TT>Complex16</TT>, and <TT>Complex64</TT>. In
each case, the name refers to the smallest type of the requested kind
with at least that many bits. For example, <TT>Float8</TT>
is the smallest floating-point type of at least 8 bits (generally the
same as <TT>Float32</TT>, but some platforms may provide
very small floating-point types), while <TT>Complex0</TT>
is the smallest complex type. On some platforms, but not all,
<TT>Numeric</TT> also supplies the names
<TT>Int64</TT>, <TT>Int128</TT>,
<TT>Float128</TT>, and <TT>Complex128</TT>, with
similar meanings. These names are not supplied on all platforms
because not all platforms provide numbers with that many bits. The
next release of <TT>Numeric</TT> will also support unsigned
integer types.</P>

<P class="docText">A type code of '<TT>O</TT>' indicates that elements are
references to Python objects. In this case, elements can be of
different types. This lets you use <TT>Numeric</TT>
<TT>array</TT> objects as Python containers, for advanced
array-processing tasks that may have nothing to do with numeric
processing. When you build an array <TT><I>a</I></TT> with
one of <TT>Numeric</TT>'s factory
functions, you can either specify
<TT><I>a</I></TT>'s type code explicitly
or accept a default data-dependent type code.</P>

<P class="docText">To get the type code of an array <TT><I>a</I></TT>, call
<TT><I>a</I></TT><TT>.typecode( )</TT>.
<TT><I>a</I></TT>'s type code determines
how many bytes each element of <TT><I>a</I></TT> takes up
in memory. Call <TT><I>a</I></TT><TT>.itemsize(
)</TT> to get this information. When the type code is
'<TT>O</TT>', the item size is small (e.g., 4 bytes on a
32-bit platform), but this size accounts only for the reference held
in each of <TT><I>a</I></TT>'s cells. The
objects indicated by the references are stored elsewhere as separate
Python objects; each such object may occupy an arbitrary amount of
extra memory, which is not accounted for in the item size of an array
with type code '<TT>O</TT>'.</P>


<A NAME="pythonian-CHP-15-SECT-6.2"></A>
<H4 class="docSection2Title">15.6.2 Shape and Indexing</H4>

<P class="docText"><A NAME="pythonian-CHP-15-ITERM-7185"></A>
<A NAME="pythonian-CHP-15-ITERM-7186"></A>
<A NAME="pythonian-CHP-15-ITERM-7187"></A> <A NAME="pythonian-CHP-15-ITERM-7188"></A>Each <TT>array</TT> object
<TT><I>a</I></TT> has an attribute
<TT><I>a</I></TT><TT>.shape</TT>, which is a
tuple of integer values.
<TT>len(</TT><TT><I>a</I></TT><TT>.shape)</TT>
is <TT><I>a</I></TT>'s rank, so for
example, a one-dimensional array of numbers (also known as a
<span class="docEmphasis">vector</span>) has rank <TT>1</TT>, and
<TT><I>a</I></TT><TT>.shape</TT> has just one
item. More generally, each item of
<TT><I>a</I></TT><TT>.shape</TT> is the length
of the corresponding dimension of <TT><I>a</I></TT>.
<TT><I>a</I></TT>'s number of elements,
known as its <span class="docEmphasis">size</span>, is the product of all items
of <TT><I>a</I></TT><TT>.shape</TT>. Each
dimension of <TT><I>a</I></TT> is also known as an
<span class="docEmphasis">axis</span>. Axis indices are from <TT>0</TT>
up, as usual in Python. Negative axis indices are allowed and count
from the right, so <TT>-1</TT> is the last (rightmost)
axis.</P>

<P class="docText">Each array <TT><I>a</I></TT> is a Python sequence. Each
item
<TT><I>a</I></TT><TT>[</TT><TT><I>i</I></TT><TT>]</TT>
of <TT><I>a</I></TT> is a subarray of
<TT><I>a</I></TT>, meaning it is an array with a rank one
less than <TT><I>a</I></TT>'s:</P>

<PRE><TT><I>a</I></TT>[<TT><I>i</I></TT>].shape=  =<TT><I>a</I></TT>.shape[1:]</PRE>

<P class="docText">For example, if <TT><I>a</I></TT> is a two-dimensional
matrix (<TT><I>a</I></TT> is of rank
<TT>2</TT>),
<TT><I>a</I></TT><TT>[</TT><TT><I>i</I></TT><TT>]</TT>,
for any valid index <TT><I>i</I></TT>, is a
one-dimensional subarray of <TT><I>a</I></TT>
corresponding to a row of the matrix. When
<TT><I>a</I></TT>'s rank is
<TT>1</TT> or <TT>0</TT>,
<TT><I>a</I></TT>'s items are
<TT><I>a</I></TT>'s elements. Since
<TT><I>a</I></TT> is a sequence, you can index
<TT><I>a</I></TT> with normal indexing syntax to access or
change <TT><I>a</I></TT>'s items. Note
that <TT><I>a</I></TT>'s items are
<TT><I>a</I></TT>'s subarrays; only for
an array of rank <TT>1</TT> or <TT>0</TT> are the
array's items the same thing as the
array's elements.</P>

<P class="docText">You can also use <TT><I>a</I></TT> in a
<TT>for</TT> loop, as for any other sequence. For example:</P>

<PRE>for x in <TT><I>a</I></TT>:
    process(x)</PRE>

<P class="docText">means the same thing as:</P>

<PRE>for i in range(len(<TT><I>a</I></TT>)):
    x = <TT><I>a</I></TT>[i]
    process(x)</PRE>

<P class="docText"><A NAME="pythonian-CHP-15-ITERM-7189"></A>
<A NAME="pythonian-CHP-15-ITERM-7190"></A>In these
examples, each item <TT><I>x</I></TT> of
<TT><I>a</I></TT> in the <TT>for</TT> loop is a
subarray of <TT><I>a</I></TT>. For example, if
<TT><I>a</I></TT> is a two-dimensional matrix, each
<TT><I>x</I></TT> in either of these loops is a
one-dimensional subarray of <TT><I>a</I></TT>
corresponding to a row of the matrix.</P>

<P class="docText">You can also index <TT><I>a</I></TT> by a tuple. For
example, if <TT><I>a</I></TT>'s rank is
at least <TT>2</TT>, you can write
<TT><I>a</I></TT><TT>[</TT><TT><I>i</I></TT><TT>][</TT><TT><I>j</I></TT><TT>]</TT>
as
<TT><I>a</I></TT><TT>[</TT><TT><I>i,j</I></TT><TT>]</TT>
for any valid <TT><I>i</I></TT> and
<TT><I>j</I></TT>, for rebinding as well as for access.
Tuple indexing is faster and more convenient. You do not need to use
parentheses inside the brackets in order to indicate that you are
indexing <TT><I>a</I></TT> by a tuple: it suffices to
write the indices one after the other, separated by commas. In other
words,
<TT><I>a</I></TT><TT>[</TT><TT><I>i,j</I></TT><TT>]</TT>
means the same thing as
<TT><I>a</I></TT><TT>[(</TT><TT><I>i,j</I></TT><TT>)]</TT>,
but the syntax without the parentheses is more natural and readable.</P>

<P class="docText">If the result of indexing is a single number,
<TT>Numeric</TT> implicitly converts the result from a
rank-zero array to a scalar quantity of the appropriate Python type.
In other words, as a result of such an indexing you get a number, not
an array with one number in it. While this makes it convenient to
pass array elements to other non-<TT>Numeric</TT> software,
it also has unfortunate consequences, and this behavior will change
in <TT>numarray</TT>. With the present behavior,
special-casing is required. For example:</P>

<PRE><TT><I>a</I></TT>[<TT><I>i</I></TT>].shape=  =<TT><I>a</I></TT>.shape[1:]</PRE>

<P class="docText">does not execute correctly as Python code when
<TT><I>a</I></TT>'s rank is
<TT>1</TT>. In this case,
<TT><I>a</I></TT><TT>[</TT><TT><I>i</I></TT><TT>]</TT>
is just a number, and numbers don't have a
<TT>shape</TT> attribute. Thus, an
<TT>AttributeError</TT> exception
results.<A NAME="pythonian-CHP-15-ITERM-7191"></A></P>


<A NAME="pythonian-CHP-15-SECT-6.3"></A>
<H4 class="docSection2Title">15.6.3 Storage</H4>

<P class="docText"><A NAME="pythonian-CHP-15-ITERM-7192"></A>
<A NAME="pythonian-CHP-15-ITERM-7193"></A> <A NAME="pythonian-CHP-15-ITERM-7194"></A>An
<TT>array</TT> object <TT><I>a</I></TT> is
usually stored in a continuous memory area, with the elements one
after the other in what is traditionally called row-major order. This
means that, for example, when
<TT><I>a</I></TT>'s rank is
<TT>2</TT>, the elements of
<TT><I>a</I></TT>'s first row
(<TT><I>a</I></TT><TT>[0]</TT>) come first,
immediately followed by those of
<TT><I>a</I></TT>'s second row
(<TT><I>a</I></TT><TT>[1]</TT>), and so on.</P>

<P class="docText">An array can be noncontiguous when it shares some of the storage of a
larger array, as covered in the following section <A class="docLink" HREF="#pythonian-CHP-15-SECT-6.4">Section 15.6.4</A>. For example, if
<TT><I>a</I></TT>'s rank is
<TT>2</TT>, the slice
<TT><I>b</I></TT><TT>=</TT><TT><I>a</I></TT><TT>[:,0]</TT>
is the first column of <TT><I>a</I></TT>, and is stored
noncontiguously because it occupies some of the same storage as
<TT><I>a</I></TT>. In other words,
<TT><I>b</I></TT><TT>[0]</TT> occupies the same
storage as <TT><I>a</I></TT><TT>[0,0]</TT>,
while <TT><I>b</I></TT><TT>[1]</TT> occupies the
same storage as <TT><I>a</I></TT><TT>[1,0]</TT>,
which cannot be adjacent to the memory occupied by
<TT><I>a</I></TT><TT>[0,0]</TT> when
<TT><I>a</I></TT> has more than one column.</P>

<P class="docText"><TT>Numeric</TT> handles both contiguous and noncontiguous
arrays transparently in most cases. In the rest of this chapter, I
will point out the rare exceptions where a contiguous array is
needed. When you want to copy a noncontiguous array
<TT><I>b</I></TT> into a new contiguous array
<TT><I>c</I></TT>, use method <TT>copy</TT>,
covered in <A class="docLink" HREF="#pythonian-CHP-15-SECT-6.7">Section 15.6.7</A> later in
this chapter.</P>


<A NAME="pythonian-CHP-15-SECT-6.4"></A>
<H4 class="docSection2Title">15.6.4 Slicing</H4>

<P class="docText"><A NAME="pythonian-CHP-15-ITERM-7195"></A>
<A NAME="pythonian-CHP-15-ITERM-7196"></A> <A NAME="pythonian-CHP-15-ITERM-7197"></A>Arrays may
share some or all of their data with other arrays.
<TT>Numeric</TT> shares data between arrays whenever
feasible. If you want <TT>Numeric</TT> to copy data,
explicitly ask for a copy. Data sharing particularly applies to
slices. For built-in Python lists and standard library
<TT>array</TT> objects, slices are copies, but for
<TT>Numeric</TT> <TT>array</TT> objects, slices
share data with the array they're sliced from:</P>

<PRE>from Numeric import *
alist=range(10)
list_slice=alist[3:7]
list_slice[2]=22
print list_slice, alist       # prints: [3,4,22,6] [0,1,2,3,4,5,6,7,8,9]
anarray=array(alist)
arr_slice=anarray[3:7]
arr_slice[2]=33
print arr_slice, anarray      # prints: [ 3 4 33 6] [ 0 1 2 3 4 33 6 7 8 9]</PRE>

<P class="docText">Rebinding an item of <TT>list_slice</TT> does not affect
the list <TT>alist</TT> that <TT>list_slice</TT>
is sliced from, since for built-in lists, slicing performs a copy.
However, because for <TT>Numeric</TT> arrays, slicing
shares data, assigning to an item of <TT>arr_slice</TT>
does affect the <TT>array</TT> object
<TT>anarray</TT> that <TT>arr_slice</TT> is
sliced from. This behavior may be unexpected for a beginner, but was
chosen to enable high
performance.<A NAME="pythonian-CHP-15-ITERM-7198"></A></P>

<A NAME="pythonian-CHP-15-SECT-6.4.1"></A>
<H5 class="docSection3Title">15.6.4.1 Slicing examples</H5>

<P class="docText">You can use a tuple to slice an array, just as you can to index it.
For arrays, slicing and indexing blend into each other. Each item in
a slicing tuple can be an integer, and the slice has one fewer axis
than the array being sliced. Slicing removes the axis for which you
give a number by selecting the indicated plane of the array.</P>

<P class="docText">A slicing tuple item can also be a slice expression; the general
syntax is
<TT><I>start</I></TT>:<TT><I>stop</I></TT>:<TT><I>step</I></TT>,
and you can omit one or more of the three parts (see
<A class="docLink" HREF="0596001886_pythonian-chp-4-sect-6.html#pythonian-CHP-4-SECT-6">Section 4.6</A> in <A class="docLink" HREF="0596001886_pythonian-chp-4.html#pythonian-CHP-4">Chapter 4</A>, and function <TT>slice</TT> in
<A class="docLink" HREF="0596001886_pythonian-chp-8.html#pythonian-CHP-8">Chapter 8</A>, for details on slice semantics and
defaults). Here are some example slicings:</P>

<PRE># a is [[ 0, 1, 2, 3, 4, 5],
#       [10,11,12,13,14,15],
#       [20,21,22,23,24,25],
#       [30,31,32,33,34,35],
#       [40,41,42,43,44,45],
#       [50,51,52,53,54,55]]
a[0,2:4)                        # array([2,3])
a[3:,3:]                        # array([[33,34,35],
                                #        [43,44,45],
                                #        [53,54,55]])
a[:,4]                          # array([4,14,24,34,44,54])
a[2::2,::2]                     # array([[20,22,24],
                                #        [40,42,44]])</PRE>

<P class="docText">A slicing-tuple item can also use an ellipsis
(<TT>..</TT>.) to indicate that the following items in the
slicing tuple apply to the last (rightmost) axes of the array
you're slicing. For example, consider slicing an
array <TT>b</TT> of rank <TT>3</TT>:</P>

<PRE>b.shape                            # (4,2,3)
b[1].shape                         # (2,3)
b[...,1].shape                     # (4,2)</PRE>

<P class="docText">When we slice with <TT>b[1]</TT> (equivalent to indexing),
we give an integer index for axis <TT>0</TT>, and therefore
we select a specific plane along
<TT>b</TT>'s axis <TT>0</TT>. By
selecting a specific plane, we remove that axis from the
result's shape. Therefore, the
result's shape is <TT>b.shape[1:]</TT>.
When we slice with <TT>b[...,1]</TT>, we select a specific
plane along <TT>b</TT>'s axis
<TT>-1</TT> (the rightmost axis of <TT>b</TT>).
Again, by selecting a specific plane, we remove that axis from the
result's shape. Therefore, the
result's shape in this case is
<TT>b.shape[:-1]</TT>.</P>

<P class="docText">A slicing-tuple item can also be the pseudo-index
<TT>NewAxis</TT>. The resulting slice has an additional
axis at the point at which you use <TT>NewAxis</TT>, with a
value of <TT>1</TT> in the corresponding item of the shape
tuple. Continuing the previous example:</P>

<PRE>b[NewAxis,...,NewAxis].shape       # (1,4,2,3,1)</PRE>

<P class="docText">Here, rather than selecting and thus removing some of
<TT>b</TT>'s axes, we have added two new
axes, one at the start of the shape and one at the end, thanks to the
ellipsis.</P>

<P class="docText">Axis removal and addition can both occur in the same slicing. For
example:</P>

<PRE>b[NewAxis,:,0,:,NewAxis].shape     # (1,4,3,1)</PRE>

<P class="docText">Here, we both add new axes at the start and end of the shape, and
select a specific index from the middle axis (axis
<TT>1</TT>) of <TT>b</TT> by giving an index for
that axis. Therefore, axis <TT>1</TT> of
<TT>b</TT> is removed from the result's
shape. The colons (:) used as the second and
fourth items in the slicing tuple in this example are slice
expressions with both <TT><I>start</I></TT> and
<TT><I>stop</I></TT> omitted, meaning that all of the
corresponding axis is included in the slice. In all these examples,
all slices share some or all of
<TT>b</TT>'s data. Slicing affects only
the shape of the resulting array. No data is copied, and no
operations are performed on the data.</P>



<A NAME="pythonian-CHP-15-SECT-6.4.2"></A>
<H5 class="docSection3Title">15.6.4.2 Assigning to array slices</H5>

<P class="docText"><A NAME="pythonian-CHP-15-ITERM-7199"></A>Assignment to array slices is less
flexible than assignment to list slices. Normally, you can assign to
an array slice only another array of the same shape as the slice.
However, if the right-hand side of the assignment is not an array,
<TT>Numeric</TT> implicitly creates a temporary array from
it. Each element of the right-hand side is coerced to the left-hand
side's type. If the right-hand side array is not the
same shape as the left-hand side slice, broadcasting applies, as
covered in <A class="docLink" HREF="#pythonian-CHP-15-SECT-6.8">Section 15.6.8</A>
later in this chapter. So, for example, you can assign a scalar (a
single number) to any slice of a numeric array. In this case, the
right-hand side number is coerced, then broadcast (replicated) as
needed to make the assignment succeed.</P>

<P class="docText">When you assign to an array slice (or indexing) a right-hand side of
a type different from that of the left-hand side,
<TT>Numeric</TT> coerces the values to the left-hand
side's type, for example by truncating
floating-point numbers to integers. This does not apply if the
right-hand side values are complex. Full coercion does not apply to
in-place operators, which can only cast the right-hand side values
upwards (for example, an integer right-hand side may be used for
in-place operations with a floating-point left-hand side, but not
vice versa), as covered in <A class="docLink" HREF="#pythonian-CHP-15-SECT-6.8.2">Section 15.6.8.2</A> later in this chapter.<A NAME="pythonian-CHP-15-ITERM-7200"></A> <A NAME="pythonian-CHP-15-ITERM-7201"></A> <A NAME="pythonian-CHP-15-ITERM-7202"></A></P>



<A NAME="pythonian-CHP-15-SECT-6.5"></A>
<H4 class="docSection2Title">15.6.5 Truth Values</H4>

<P class="docText">Although an <TT>array</TT> object
<TT><I>a</I></TT> is a Python sequence, in recent versions
of <TT>Numeric</TT> <TT><I>a</I></TT> does not
follow Python's normal rule for truth values of
sequences, where
<TT>bool(</TT><TT><I>a</I></TT><TT>)</TT>
depends only on
<TT>len(</TT><TT><I>a</I></TT><TT>)</TT>
and not on <TT><I>a</I></TT>'s elements
(i.e., the rule by which any sequence is false only when empty,
otherwise it is true). Rather, <TT><I>a</I></TT> is false
when <TT><I>a</I></TT> has no elements or all of
<TT><I>a</I></TT>'s elements are numeric
<TT>0</TT>. This lets you test for element-wise equality of
arrays in the natural way:</P>

<PRE>if a=  =b:</PRE>

<P class="docText">Without this proviso, such an <TT>if</TT> condition would
be satisfied by any non-empty comparable arrays
<TT><I>a</I></TT> and <TT><I>b</I></TT>.</P>

<P class="docText">Do remember, however, that you have to be explicit when you want to
test whether <TT><I>a</I></TT> has any items or whether
<TT><I>a</I></TT> has any elements, as these are two
different conditions:</P>

<PRE>a = Numeric.array( [ [  ], [  ], [  ] ] )
if a: print 'a is true'
else: print 'a is false'                       # prints: a is false
if len(a): print 'a has some items'
else: print 'a has no items'                   # prints: a has some items
if Numeric.size(a): print 'a has some elements'
else: print 'a has no elements'                # prints: a has no elements</PRE>

<P class="docText"><A NAME="pythonian-CHP-15-ITERM-7203"></A> <A NAME="pythonian-CHP-15-ITERM-7204"></A>In most
cases, the best way to compare arrays of numbers is for approximate
equality with function <TT>allclose</TT>, covered later in
this chapter.</P>


<A NAME="pythonian-CHP-15-SECT-6.6"></A>
<H4 class="docSection2Title">15.6.6 Factory Functions</H4>

<P class="docText"><TT>Numeric</TT> supplies numerous factory functions that
create <TT>array</TT> objects.</P>

<A NAME="ch15-77071"></A><A NAME="pythonian-CHP-15-ITERM-7205"></A><A NAME="pythonian-CHP-15-ITERM-7206"></A><table width="515" border="0" cellpadding="5">
<tr>
<td align="left"><b><i>array</i></b></td>
<td align="right"></td>
</tr>
</table>
<hr width="515" size="3" noshade="true" align="left" color="black">
<table width="515" border="0" cellpadding="5">
<tr>
<td align="left">
<pre>array(<TT><I>data</I></TT>,<TT><I>typecode</I></TT>=None,<TT><I>copy</I></TT>=True,<TT><I>savespace</I></TT>=False)</pre>
</td>
<td align="right"></td>
</tr>
</table>
<P class="docText">Returns a new <TT>array</TT> object
<TT><I>a</I></TT>.
<TT><I>a</I></TT>'s shape depends on
<TT><I>data</I></TT>. When <TT><I>data</I></TT>
is a number, <TT><I>a</I></TT> has rank
<TT>0</TT> and
<TT><I>a</I></TT><TT>.shape</TT> is the empty
tuple <TT>( )</TT>. When <TT><I>data</I></TT> is
a sequence of numbers, <TT><I>a</I></TT> has rank
<TT>1</TT> and
<TT><I>a</I></TT><TT>.shape</TT> is the
singleton tuple
<TT>(len(</TT><TT><I>data</I></TT><TT>),)</TT>.
When <TT><I>data</I></TT> is a sequence of sequences of
numbers, all of <TT><I>data</I></TT>'s
items must have the same length, <TT><I>a</I></TT> has
rank <TT>2</TT>, and
<TT><I>a</I></TT><TT>.shape</TT> is the pair
<TT>(len(</TT><TT><I>data</I></TT><TT>),len(</TT><TT><I>data</I></TT><TT>[0]))</TT>.
This idea generalizes to any nesting level of
<TT><I>data</I></TT> as a sequence of sequences, up to the
arbitrarily high limit on rank mentioned earlier in this chapter. If
data is nested over that limit, <TT>array</TT> raises
<TT>TypeError</TT>. (This is unlikely to be a problem in
practice, as an array of rank at least <TT>40</TT>, with
each axis of length at least <TT>2</TT>, would have well
over a million of millions of elements).</P>
<P class="docText"><TT><I>typecode</I></TT> can be any of the values shown in
<A class="docLink" HREF="0596001886_pythonian-chp-15-sect-4.html#pythonian-CHP-15-TABLE-2">Table 15-2</A> or <TT>None</TT>. When
<TT><I>typecode</I></TT> is <TT>None</TT>,
<TT>array</TT> chooses a default type code depending on the
types of the elements of <TT><I>data</I></TT>. When any
one or more elements in <TT><I>data</I></TT> are long
integer values or are neither numbers nor plain strings (e.g.,
<TT>None</TT> or Unicode strings), the type code is
<TT>PyObject</TT>. When all elements are plain strings, the
type code is <TT>Character</TT>. When any one or more
elements (but not all) are plain strings, all others are numbers (not
long integers), and <TT><I>typecode</I></TT> is
<TT>None</TT>, <TT>array</TT> raises
<TT>TypeError</TT>. You must explicitly pass
'<TT>O</TT>' or <TT>PyObject</TT> as argument
<TT><I>typecode</I></TT> if you want to have
<TT>array</TT> build an array from some plain strings and
some non-long integers. When all elements are numbers (not long
integers), the default type code depends on the widest numeric type
among the elements. When any of the elements is a
<TT>complex</TT>, the type code is
<TT>Complex</TT>. When no elements are complex but some are
floating-point values, the type code is <TT>Float</TT>.
When all elements are integers, the type code is
<TT>Int</TT>.</P>
<P class="docText">Function <TT>array</TT>, by default, returns an
<TT>array</TT> object <TT><I>a</I></TT> that
doesn't share data with others. If
<TT><I>data</I></TT> is an <TT>array</TT>
object, and you explicitly pass a false value for argument
<TT><I>copy</I></TT>, <TT>array</TT> returns an
<TT>array</TT> object <TT><I>a</I></TT> that
shares data with <TT><I>data</I></TT>, if feasible.</P>
<P class="docText">By default, an <TT>array</TT> object with a numeric type
code is implicitly cast up when operated with numbers of wider
numeric types. When you do not need this implicit casting, you can
save some memory by explicitly passing a true value for argument
<TT><I>savespace</I></TT> to the <TT>array</TT>
factory function, to set the resulting <TT>array</TT>
object <TT><I>a</I></TT> into space-saving mode. For
example:</P>
<PRE>array(range(4),typecode='b')+2.0    # array([2.,3.,4.,5.])
array(range(4),typecode='b',savespace=True)+2.0     
# array([2,3,4,5])
array(range(4),typecode='b',savespace=True)+258.7   
# array([2,3,4,5])</PRE><P class="docText">The first statement creates an array of floating-point values, as
<TT><I>savespace</I></TT> is not specified and thus each
element is implicitly cast up to a <TT>float</TT> when
added to <TT>2.0</TT>. The second and third statements
create arrays of 8-bit integers, since
<TT><I>savespace</I></TT> is specified. Therefore, instead
of implicit casting up of the array's element, we
get implicit casting down of the <TT>float</TT> added to
each element. <TT>258.7</TT> is cast down to
<TT>2</TT>: the fractional part <TT>.7</TT> is
lost because of the cast to an integer, and the resulting
<TT>258</TT> becomes <TT>2</TT> because, since
the cast is to 8-bit integers, only the lowest 8 bits are kept. The
<TT><I>savespace</I></TT> mode can be very useful for
large arrays, but be careful lest you suffer unexpected loss of
precision when using it.</P>

<A NAME="ch15-77072"></A><A NAME="pythonian-CHP-15-ITERM-7207"></A><A NAME="pythonian-CHP-15-ITERM-7208"></A><A NAME="pythonian-CHP-15-ITERM-7209"></A><A NAME="pythonian-CHP-15-ITERM-7210"></A><table width="515" border="0" cellpadding="5">
<tr>
<td align="left"><b><i>arrayrange, arange</i></b></td>
<td align="right"></td>
</tr>
</table>
<hr width="515" size="3" noshade="true" align="left" color="black">
<table width="515" border="0" cellpadding="5">
<tr>
<td align="left">
<pre>arrayrange([<TT><I>start</I></TT>,]<TT><I>stop</I></TT>[,<TT><I>step</I></TT>=1],<TT><I>typecode</I></TT>=None)</pre>
</td>
<td align="right"></td>
</tr>
</table>
<P class="docText">Like
<TT>array(range(</TT><TT><I>start</I></TT>,<TT><I>stop</I></TT>,<TT><I>step</I></TT><TT>)</TT>,<TT><I>typecode</I></TT><TT>)</TT>,
but faster. See built-in function <A class="docLink" HREF="0596001886_pythonian-chp-8-sect-2.html#ch08-77055">range</A>, covered
in <A class="docLink" HREF="0596001886_pythonian-chp-8.html#pythonian-CHP-8">Chapter 8</A>, for details about
<TT><I>start</I></TT>, <TT><I>stop</I></TT>,
and <TT><I>step</I></TT>. <TT>arrayrange</TT>
allows <TT>float</TT> values for these arguments, not just
<TT>int</TT> values. Be careful when exploiting this
feature, since the approximations inherent in floating-point
arithmetic may lead to a result with one more or fewer items than you
might expect. <TT>arange</TT> is a synonym of
<TT>arrayrange</TT>.</P>

<A NAME="ch15-77073"></A><A NAME="pythonian-CHP-15-ITERM-7211"></A><A NAME="pythonian-CHP-15-ITERM-7212"></A><table width="515" border="0" cellpadding="5">
<tr>
<td align="left"><b><i>fromstring</i></b></td>
<td align="right"></td>
</tr>
</table>
<hr width="515" size="3" noshade="true" align="left" color="black">
<table width="515" border="0" cellpadding="5">
<tr>
<td align="left">
<pre>fromstring(<TT><I>data</I></TT>,<TT><I>count</I></TT>=None,<TT><I>typecode</I></TT>=Int)</pre>
</td>
<td align="right"></td>
</tr>
</table>
<P class="docText">Returns a one-dimensional array <TT><I>a</I></TT> of shape
<TT>(</TT><TT><I>count</I></TT><TT>,)</TT>
with data copied from the bytes of string
<TT><I>data</I></TT>. When
<TT><I>count</I></TT> is <TT>None</TT>,
<TT>len(</TT><TT><I>data</I></TT><TT>)</TT>
must be a multiple of
<TT><I>typecode</I></TT>'s item size, and
<TT><I>a</I></TT>'s shape is
<TT>(len(</TT><TT><I>data</I></TT><TT>)/</TT><TT><I>a</I></TT><TT>.itemsize(
),)</TT>. When <TT><I>count</I></TT> is not
<TT>None</TT>,
<TT>len(</TT><TT><I>data</I></TT><TT>)</TT>
must be greater than or equal to
<TT><I>count</I></TT><TT>*</TT><TT><I>a</I></TT><TT>.itemsize(
)</TT>, and <TT>fromstring</TT> ignores
<TT><I>data</I></TT>'s trailing bytes, if
any.</P>
<P class="docText">Together with methods
<TT><I>a</I></TT><TT>.tostring</TT> and
<TT><I>a</I></TT><TT>.byteswapped</TT> (covered
in the following section <A class="docLink" HREF="#pythonian-CHP-15-SECT-6.7">Section 15.6.7</A>), function
<TT>fromstring</TT> allows binary input/output of
<TT>array</TT> objects. When you need to save arrays and
later reload them, and don't need to use the saved
form in non-Python programs, it's simpler and faster
to use module <TT>cPickle</TT>, covered in <A class="docLink" HREF="0596001886_pythonian-chp-11.html#pythonian-CHP-11">Chapter 11</A>. Many experienced users prefer to use a
portable self-describing file format such as
<TT>netCDF</TT> (see <A class="docLink" target="_blank" HREF="http://met-www.cit.cornell.edu/noon/ncmodule.html">http://met-www.cit.cornell.edu/noon/ncmodule.html</A>).</P>

<A NAME="ch15-77074"></A><A NAME="pythonian-CHP-15-ITERM-7213"></A><A NAME="pythonian-CHP-15-ITERM-7214"></A><table width="515" border="0" cellpadding="5">
<tr>
<td align="left"><b><i>identity</i></b></td>
<td align="right"></td>
</tr>
</table>
<hr width="515" size="3" noshade="true" align="left" color="black">
<table width="515" border="0" cellpadding="5">
<tr>
<td align="left">
<pre>identity(<TT><I>n</I></TT>,<TT><I>typecode</I></TT>=Int)</pre>
</td>
<td align="right"></td>
</tr>
</table>
<P class="docText">Returns a two-dimensional array <TT><I>a</I></TT> of shape
<TT>(</TT><TT><I>n</I></TT>,<TT><I>n</I></TT><TT>)</TT>.
<TT><I>a</I></TT>'s elements are
<TT>0</TT>, except those on the main diagonal
(<TT><I>a</I></TT><TT>[</TT><TT><I>j</I></TT>,<TT><I>j</I></TT><TT>]</TT>
for <TT><I>j</I></TT> in
<TT>range(</TT><TT><I>n</I></TT><TT>)</TT>),
which are <TT>1</TT>.</P>

<A NAME="ch15-77075"></A><A NAME="pythonian-CHP-15-ITERM-7215"></A><A NAME="pythonian-CHP-15-ITERM-7216"></A><table width="515" border="0" cellpadding="5">
<tr>
<td align="left"><b><i>ones</i></b></td>
<td align="right"></td>
</tr>
</table>
<hr width="515" size="3" noshade="true" align="left" color="black">
<table width="515" border="0" cellpadding="5">
<tr>
<td align="left">
<pre>ones(<TT><I>shapetuple</I></TT>,<TT><I>typecode</I></TT>=Int,<TT><I>savespace</I></TT>=False)</pre>
</td>
<td align="right"></td>
</tr>
</table>
<P class="docText">Returns an array <TT><I>a</I></TT> such that
<TT><I>a</I></TT><TT>.shape=
=</TT><TT><I>shapetuple</I></TT>. All of
<TT><I>a</I></TT>'s elements are
<TT>1</TT>.</P>

<A NAME="ch15-77076"></A><A NAME="pythonian-CHP-15-ITERM-7217"></A><A NAME="pythonian-CHP-15-ITERM-7218"></A><table width="515" border="0" cellpadding="5">
<tr>
<td align="left"><b><i>zeros</i></b></td>
<td align="right"></td>
</tr>
</table>
<hr width="515" size="3" noshade="true" align="left" color="black">
<table width="515" border="0" cellpadding="5">
<tr>
<td align="left">
<pre>zeros(<TT><I>shapetuple</I></TT>,<TT><I>typecode</I></TT>=Int,<TT><I>savespace</I></TT>=False)</pre>
</td>
<td align="right"></td>
</tr>
</table>
<P class="docText">Returns an array <TT><I>a</I></TT> such that
<TT><I>a</I></TT><TT>.shape=
=</TT><TT><I>shapetuple</I></TT>. All of
<TT><I>a</I></TT>'s elements are
<TT>0</TT>.</P>

<P class="docText">Note that, by default, <TT>identity</TT>,
<TT>ones</TT>, and <TT>zeros</TT> all return
arrays whose type is <TT>Int</TT>. Be sure to specify
explicitly a different type code, such as <TT>Float</TT>,
if that is what you really want. For example, be sure to avoid the
following common mistake:</P>

<PRE>a = zeros(3)
a[0] = 0.3                    # a is array([0,0,0])</PRE>

<P class="docText">Since <TT>a</TT> is <TT>Int</TT> in this snippet,
the <TT>0.3</TT> we assign to one of its items gets
truncated to the integer <TT>0</TT>. Instead, you typically
want something closer to the following:</P>

<PRE>a = zeros(3,Float)
a[0] = 0.3                    # a is array([0.3,0.,0.])</PRE>

<P class="docText">Here, we have explicitly specified <TT>Float</TT> as the
type code for <TT>a</TT>, and therefore no truncation
occurs when we assign <TT>0.3</TT> to one of
<TT>a</TT>'s items.</P>


<A NAME="pythonian-CHP-15-SECT-6.7"></A>
<H4 class="docSection2Title">15.6.7 Attributes and Methods</H4>

<P class="docText"><A NAME="pythonian-CHP-15-ITERM-7219"></A>
<A NAME="pythonian-CHP-15-ITERM-7220"></A>For most
array manipulations, <TT>Numeric</TT> supplies functions
you can call with array arguments. You can also use Python lists as
arguments; this polymorphism offers flexibility that is not available
for functionality packaged up as array attributes and methods. Each
<TT>array</TT> object <TT><I>a</I></TT> also
supplies some methods and attributes, for direct access to
functionality that would not benefit from polymorphic possibilities.</P>

<A NAME="ch15-77078"></A><A NAME="pythonian-CHP-15-ITERM-7221"></A><A NAME="pythonian-CHP-15-ITERM-7222"></A><table width="515" border="0" cellpadding="5">
<tr>
<td align="left"><b><i>astype</i></b></td>
<td align="right"></td>
</tr>
</table>
<hr width="515" size="3" noshade="true" align="left" color="black">
<table width="515" border="0" cellpadding="5">
<tr>
<td align="left">
<pre><TT><I>a</I></TT>.astype(<TT><I>typecode</I></TT>)</pre>
</td>
<td align="right"></td>
</tr>
</table>
<P class="docText">Returns a new array <TT><I>b</I></TT> with the same shape
as <TT><I>a</I></TT>.
<TT><I>b</I></TT>'s elements are
<TT><I>a</I></TT>'s elements coerced to
the type indicated by <TT><I>typecode</I></TT>.
<TT><I>b</I></TT> does not share
<TT><I>a</I></TT>'s data, even if
<TT><I>typecode</I></TT> equals
<TT><I>a</I></TT><TT>.typecode( )</TT>.</P>

<A NAME="ch15-77079"></A><A NAME="pythonian-CHP-15-ITERM-7223"></A><A NAME="pythonian-CHP-15-ITERM-7224"></A><table width="515" border="0" cellpadding="5">
<tr>
<td align="left"><b><i>byteswapped</i></b></td>
<td align="right"></td>
</tr>
</table>
<hr width="515" size="3" noshade="true" align="left" color="black">
<table width="515" border="0" cellpadding="5">
<tr>
<td align="left">
<pre><TT><I>a</I></TT>.byteswapped(  )</pre>
</td>
<td align="right"></td>
</tr>
</table>
<P class="docText">Returns a new <TT>array</TT> object
<TT><I>b</I></TT> with the same type code and shape as
<TT><I>a</I></TT>. Each element of
<TT><I>b</I></TT> is copied from the corresponding element
of <TT><I>a</I></TT>, inverting the order of the bytes in
the value. This swapping transforms each value from little-endian to
big-endian or vice versa. Together with function
<TT>fromstring</TT> and method
<TT><I>a</I></TT><TT>.tostring</TT>, this helps
when you have binary data from one kind of machine and need them for
the other kind (for example, Intel platforms are little-endian, while
Sun platforms are big-endian).</P>

<A NAME="ch15-77080"></A><A NAME="pythonian-CHP-15-ITERM-7225"></A><A NAME="pythonian-CHP-15-ITERM-7226"></A><table width="515" border="0" cellpadding="5">
<tr>
<td align="left"><b><i>copy</i></b></td>
<td align="right"></td>
</tr>
</table>
<hr width="515" size="3" noshade="true" align="left" color="black">
<table width="515" border="0" cellpadding="5">
<tr>
<td align="left">
<pre><TT><I>a</I></TT>.copy(  )</pre>
</td>
<td align="right"></td>
</tr>
</table>
<P class="docText">Returns a new contiguous <TT>array</TT> object
<TT><I>b</I></TT>, identical to
<TT><I>a</I></TT>, but not sharing
<TT><I>a</I></TT>'s data.</P>

<A NAME="ch15-77081"></A><A NAME="pythonian-CHP-15-ITERM-7227"></A><A NAME="pythonian-CHP-15-ITERM-7228"></A><table width="515" border="0" cellpadding="5">
<tr>
<td align="left"><b><i>flat</i></b></td>
<td align="right"></td>
</tr>
</table>
<hr width="515" size="3" noshade="true" align="left" color="black">
<table width="515" border="0" cellpadding="5">
<tr>
<td align="left"></td>
<td align="right"></td>
</tr>
</table>
<P class="docText"><TT><I>a</I></TT><A NAME="pythonian-CHP-15-ITERM-7227"></A> <A NAME="pythonian-CHP-15-ITERM-7228"></A><TT>.flat</TT> is an
attribute that contains an array with rank of one less than
<TT><I>a</I></TT> and of the same size as
<TT><I>a</I></TT>, sharing
<TT><I>a</I></TT>'s data. Indexing or
slicing <TT><I>a</I></TT><TT>.flat</TT> lets you
access or change <TT><I>a</I></TT>'s
elements through this alternate view of <TT><I>a</I></TT>.
Trying to access <TT><I>a</I></TT><TT>.flat</TT>
raises a <TT>TypeError</TT> exception if
<TT><I>a</I></TT> is noncontiguous. When
<TT><I>a</I></TT> is contiguous,
<TT><I>a</I></TT><TT>.flat</TT> is in row-major
order. This means that, for example, when
<TT><I>a</I></TT>'s shape is
<TT>(7,4)</TT> (i.e., <TT><I>a</I></TT> is a
two-dimensional matrix with seven rows and four columns),
<TT><I>a</I></TT><TT>.flat[</TT><TT><I>i</I></TT><TT>]</TT>
is the same as
<TT><I>a</I></TT><TT>[divmod(</TT><TT><I>i</I></TT><TT>,4)]</TT>
for all <TT><I>i</I></TT> in <TT>range(28)</TT>.</P>

<A NAME="ch15-77082"></A><A NAME="pythonian-CHP-15-ITERM-7229"></A><A NAME="pythonian-CHP-15-ITERM-7230"></A><A NAME="pythonian-CHP-15-ITERM-7231"></A><A NAME="pythonian-CHP-15-ITERM-7232"></A><A NAME="pythonian-CHP-15-ITERM-7233"></A><A NAME="pythonian-CHP-15-ITERM-7234"></A><table width="515" border="0" cellpadding="5">
<tr>
<td align="left"><b><i>imag, imaginary, real</i></b></td>
<td align="right"></td>
</tr>
</table>
<hr width="515" size="3" noshade="true" align="left" color="black">
<table width="515" border="0" cellpadding="5">
<tr>
<td align="left"></td>
<td align="right"></td>
</tr>
</table>
<P class="docText"><A NAME="pythonian-CHP-15-ITERM-7229"></A>
<A NAME="pythonian-CHP-15-ITERM-7230"></A>
<A NAME="pythonian-CHP-15-ITERM-7231"></A> <A NAME="pythonian-CHP-15-ITERM-7232"></A> <A NAME="pythonian-CHP-15-ITERM-7233"></A> <A NAME="pythonian-CHP-15-ITERM-7234"></A>Trying to access the
<TT><I>a</I></TT><TT>.real</TT> and
<TT><I>a</I></TT><TT>.imag</TT> attributes
raises a <TT>TypeError</TT> exception unless
<TT><I>a</I></TT>'s type code is complex.
When <TT><I>a</I></TT>'s type code is
complex, each of <TT><I>a</I></TT><TT>.real</TT>
and <TT><I>a</I></TT><TT>.imag</TT> is a
noncontiguous array with the same shape as
<TT><I>a</I></TT> and a <TT>float</TT> type
code, sharing data with <TT><I>a</I></TT>. By accessing or
modifying <TT><I>a</I></TT><TT>.real</TT> or
<TT><I>a</I></TT><TT>.imag</TT>, you access or
modify the real or imaginary parts of
<TT><I>a</I></TT>'s complex-number
elements. <TT>imaginary</TT> is a synonym of
<TT>imag</TT>.</P>

<A NAME="ch15-77083"></A><A NAME="pythonian-CHP-15-ITERM-7235"></A><A NAME="pythonian-CHP-15-ITERM-7236"></A><table width="515" border="0" cellpadding="5">
<tr>
<td align="left"><b><i>iscontiguous</i></b></td>
<td align="right"></td>
</tr>
</table>
<hr width="515" size="3" noshade="true" align="left" color="black">
<table width="515" border="0" cellpadding="5">
<tr>
<td align="left">
<pre><TT><I>a</I></TT>.iscontiguous(  )</pre>
</td>
<td align="right"></td>
</tr>
</table>
<P class="docText">Returns <TT>True</TT> if
<TT><I>a</I></TT>'s data occupies
contiguous storage, otherwise <TT>False</TT>. This matters
particularly when interfacing to C-coded extensions.
<TT><I>a</I></TT><TT>.copy( )</TT> makes a
contiguous copy of <TT><I>a</I></TT>. Noncontiguous arrays
arise when slicing or transposing arrays, as well as for attributes
<TT><I>a</I></TT><TT>.real</TT> and
<TT><I>a</I></TT><TT>.imag</TT> of an array
<TT><I>a</I></TT> with a complex type code.</P>

<A NAME="ch15-77084"></A><A NAME="pythonian-CHP-15-ITERM-7237"></A><A NAME="pythonian-CHP-15-ITERM-7238"></A><table width="515" border="0" cellpadding="5">
<tr>
<td align="left"><b><i>itemsize</i></b></td>
<td align="right"></td>
</tr>
</table>
<hr width="515" size="3" noshade="true" align="left" color="black">
<table width="515" border="0" cellpadding="5">
<tr>
<td align="left">
<pre><TT><I>a</I></TT>.itemsize(  )</pre>
</td>
<td align="right"></td>
</tr>
</table>
<P class="docText">Returns the number of bytes of memory used by each of
<TT><I>a</I></TT>'s elements (not by each
of <TT><I>a</I></TT>'s items, which are
subarrays of <TT><I>a</I></TT>).</P>

<A NAME="ch15-77085"></A><A NAME="pythonian-CHP-15-ITERM-7239"></A><A NAME="pythonian-CHP-15-ITERM-7240"></A><table width="515" border="0" cellpadding="5">
<tr>
<td align="left"><b><i>savespace</i></b></td>
<td align="right"></td>
</tr>
</table>
<hr width="515" size="3" noshade="true" align="left" color="black">
<table width="515" border="0" cellpadding="5">
<tr>
<td align="left">
<pre><TT><I>a</I></TT>.savespace(<TT><I>flag</I></TT>=True)</pre>
</td>
<td align="right"></td>
</tr>
</table>
<P class="docText">Sets or resets the space-saving mode of array
<TT><I>a</I></TT>, depending on the truth value of
<TT><I>flag</I></TT>. When <TT><I>flag</I></TT>
is true,
<TT><I>a</I></TT><TT>.savespace(</TT><TT><I>flag</I></TT><TT>)</TT>
sets <TT><I>a</I></TT>'s space-saving
mode so that <TT><I>a</I></TT>'s elements
are not implicitly cast up when operated with arrays of wider numeric
types. For more details on this, see the discussion of
<TT><I>savespace</I></TT> for function
<A class="docLink" HREF="#ch15-77071">array</A> earlier in this chapter. When
<TT><I>flag</I></TT> is false,
<TT><I>a</I></TT><TT>.savespace(</TT><TT><I>flag</I></TT><TT>)</TT>
resets <TT><I>a</I></TT>'s space-saving
mode so that <TT><I>a</I></TT>'s elements
<span class="docEmphasis">are</span> implicitly cast up when needed.</P>

<A NAME="ch15-77086"></A><A NAME="pythonian-CHP-15-ITERM-7241"></A><A NAME="pythonian-CHP-15-ITERM-7242"></A><table width="515" border="0" cellpadding="5">
<tr>
<td align="left"><b><i>shape</i></b></td>
<td align="right"></td>
</tr>
</table>
<hr width="515" size="3" noshade="true" align="left" color="black">
<table width="515" border="0" cellpadding="5">
<tr>
<td align="left"></td>
<td align="right"></td>
</tr>
</table>
<P class="docText"><A NAME="pythonian-CHP-15-ITERM-7241"></A>
<A NAME="pythonian-CHP-15-ITERM-7242"></A>The
<TT><I>a</I></TT><TT>.shape</TT> attribute is a
tuple with one item per axis of <TT><I>a</I></TT>, giving
the length of that axis. You can assign a sequence of integers to
<TT><I>a</I></TT><TT>.shape</TT> to change the
shape of <TT><I>a</I></TT>, but
<TT><I>a</I></TT>'s size (the total
number of elements) must remain the same. When you assign to
<TT><I>a</I></TT><TT>.shape</TT> another
sequence <TT><I>s</I></TT>, one of
<TT><I>s</I></TT>'s items can be
<TT>-1</TT>, meaning that the length along that axis is
whatever is needed to keep
<TT><I>a</I></TT>'s size unchanged.
However, the product of the other items of
<TT><I>s</I></TT> must evenly divide
<TT><I>a</I></TT>'s size, or else the
reshaping raises an exception. When you need to change the total
number of elements in <TT><I>a</I></TT>, call function
<TT>resize</TT> (covered in <A class="docLink" HREF="#pythonian-CHP-15-SECT-6.9">Section 15.6.9</A> later in this chapter).</P>

<A NAME="ch15-77087"></A><A NAME="pythonian-CHP-15-ITERM-7243"></A><A NAME="pythonian-CHP-15-ITERM-7244"></A><table width="515" border="0" cellpadding="5">
<tr>
<td align="left"><b><i>spacesaver</i></b></td>
<td align="right"></td>
</tr>
</table>
<hr width="515" size="3" noshade="true" align="left" color="black">
<table width="515" border="0" cellpadding="5">
<tr>
<td align="left">
<pre><TT><I>a</I></TT>.spacesaver(  )</pre>
</td>
<td align="right"></td>
</tr>
</table>
<P class="docText"><A NAME="pythonian-CHP-15-ITERM-7243"></A> <A NAME="pythonian-CHP-15-ITERM-7244"></A>Returns <TT>True</TT> if
space-saving mode is on for array <TT><I>a</I></TT>,
otherwise <TT>False</TT>. See the discussion of
<TT><I>savespace</I></TT> for function
<A class="docLink" HREF="#ch15-77071">array</A> earlier in this chapter.</P>

<A NAME="ch15-77088"></A><A NAME="pythonian-CHP-15-ITERM-7245"></A><A NAME="pythonian-CHP-15-ITERM-7246"></A><table width="515" border="0" cellpadding="5">
<tr>
<td align="left"><b><i>tolist</i></b></td>
<td align="right"></td>
</tr>
</table>
<hr width="515" size="3" noshade="true" align="left" color="black">
<table width="515" border="0" cellpadding="5">
<tr>
<td align="left">
<pre><TT><I>a</I></TT>.tolist(  )</pre>
</td>
<td align="right"></td>
</tr>
</table>
<P class="docText">Returns a list <TT><I>L</I></TT> equivalent to
<TT><I>a</I></TT>. For example, if
<TT><I>a</I></TT><TT>.shape</TT> is
<TT>(2,3)</TT> and
<TT><I>a</I></TT>'s type code is
'<TT>d</TT>', <TT><I>L</I></TT> is a list of two
lists of three <TT>float</TT> values each. In other words,
for each valid <TT><I>i</I></TT> and
<TT><I>j</I></TT>,
<TT><I>L</I></TT><TT>[</TT><TT><I>i</I></TT><TT>][</TT><TT><I>j</I></TT><TT>]=
=</TT><TT><I>a</I></TT><TT>[</TT><TT><I>i</I></TT>,<TT><I>j</I></TT><TT>]</TT>.
Note that
<TT>list(</TT><TT><I>a</I></TT><TT>)</TT>
converts only the top-level (axis <TT>0</TT>) of array
<TT><I>a</I></TT> into a list, and thus is not equivalent
to <TT><I>a</I></TT><TT>.tolist( )</TT> if
<TT><I>a</I></TT>'s rank is
<TT>2</TT> or more. For example:</P>
<PRE>a=array([[1,2,3],[4,5,6]],typecode='d')
print a.shape             # prints: (2,3)
print a                   # prints: [[1. 2. 3.]
                          #          [4. 5. 6.]]
print list(a)             
# prints: [array([1.,2.,3.]), array([4.,5.,6.])]
print a.tolist(  )          
# prints: [[1.0,2.0,3.0],[4.0,5.0,6.0]]</PRE>

<A NAME="ch15-77089"></A><A NAME="pythonian-CHP-15-ITERM-7247"></A><A NAME="pythonian-CHP-15-ITERM-7248"></A><table width="515" border="0" cellpadding="5">
<tr>
<td align="left"><b><i>tostring</i></b></td>
<td align="right"></td>
</tr>
</table>
<hr width="515" size="3" noshade="true" align="left" color="black">
<table width="515" border="0" cellpadding="5">
<tr>
<td align="left">
<pre><TT><I>a</I></TT>.tostring(  )</pre>
</td>
<td align="right"></td>
</tr>
</table>
<P class="docText">Returns a binary string <TT><I>s</I></TT> whose bytes are
a copy of the bytes of
<TT><I>a</I></TT>'s elements.</P>

<A NAME="ch15-77090"></A><A NAME="pythonian-CHP-15-ITERM-7249"></A><A NAME="pythonian-CHP-15-ITERM-7250"></A><A NAME="pythonian-CHP-15-ITERM-7251"></A><A NAME="pythonian-CHP-15-ITERM-7252"></A><table width="515" border="0" cellpadding="5">
<tr>
<td align="left"><b><i>typecode</i></b></td>
<td align="right"></td>
</tr>
</table>
<hr width="515" size="3" noshade="true" align="left" color="black">
<table width="515" border="0" cellpadding="5">
<tr>
<td align="left">
<pre><TT><I>a</I></TT>.typecode(  )</pre>
</td>
<td align="right"></td>
</tr>
</table>
<P class="docText">Returns the type code of <TT><I>a</I></TT> as a
one-character string.<A NAME="pythonian-CHP-15-ITERM-7251"></A> <A NAME="pythonian-CHP-15-ITERM-7252"></A></P>


<A NAME="pythonian-CHP-15-SECT-6.8"></A>
<H4 class="docSection2Title">15.6.8 Operations on Arrays</H4>

<P class="docText"><A NAME="pythonian-CHP-15-ITERM-7253"></A>
<A NAME="pythonian-CHP-15-ITERM-7254"></A>Arithmetic operators
<TT>+</TT>, <TT>-</TT>, <TT>*</TT>,
<TT>/</TT>, <TT>%</TT>, and
<TT>**</TT>, comparison operators <TT>&gt;</TT>,
<TT>&gt;=</TT>, <TT>&lt;</TT>,
<TT>&lt;=</TT>, <TT>= =</TT>, and
<TT>!=</TT>, and bitwise operators
<TT>&amp;</TT>, <TT>|</TT>, <TT>^</TT>,
and <TT>~</TT> (all covered in <A class="docLink" HREF="0596001886_pythonian-chp-4.html#pythonian-CHP-4">Chapter 4</A>) also apply to arrays. If both operands
<TT><I>a</I></TT> and <TT><I>b</I></TT> are
arrays with equal shapes and type codes, the result is a new array
<TT><I>c</I></TT> with the same shape and type code. Each
element of <TT><I>c</I></TT> is the result of the operator
on corresponding elements of <TT><I>a</I></TT> and
<TT><I>b</I></TT> (element-wise operation).</P>

<P class="docText">Arrays do not follow sequence semantics for <TT>*</TT>
(replication) and <TT>+</TT> (concatenation), but rather
use <TT>*</TT> and <TT>+</TT> for element-wise
arithmetic. Similarly, <TT>*</TT> does not mean matrix
multiplication, but element-wise multiplication.
<TT>Numeric</TT> supplies functions to perform replication,
concatenation, and matrix multiplication; all operators on arrays
perform element-wise operations.</P>

<P class="docText">When the type codes of <TT><I>a</I></TT> and
<TT><I>b</I></TT> differ, the narrower numeric type is
converted to the wider one, like for other Python numeric operations.
As usual, operations between numeric and non-numeric values are
disallowed. In the case of arrays, you can inhibit casting up by
setting an array into space-saving mode with method
<TT>savespace</TT>. Use space-saving mode with care, since
it can result in silent loss of significant data. For more details on
this, see the discussion of <TT><I>savespace</I></TT> for
function <A class="docLink" HREF="#ch15-77071">array</A> earlier in this chapter.</P>

<A NAME="pythonian-CHP-15-SECT-6.8.1"></A>
<H5 class="docSection3Title">15.6.8.1 Broadcasting</H5>

<P class="docText">Element-wise operations between arrays of different shapes are
generally not possible: attempting such operations raises an
exception. <TT>Numeric</TT> allows some such operations by
broadcasting (replicating) a smaller array up to the shape of the
larger one when feasible. To make broadcasting efficient, the
replication is only conceptual: <TT>Numeric</TT> does not
need to physically copy the data being broadcast (i.e., you need not
worry that performance will be degraded because an operation involves
broadcasting).</P>

<P class="docText"><A NAME="pythonian-CHP-15-ITERM-7255"></A>
<A NAME="pythonian-CHP-15-ITERM-7256"></A>The
simplest case of broadcasting is when one operand,
<TT><I>a</I></TT>, is a scalar (an array of rank
<TT>0</TT>), while <TT><I>b</I></TT>, the other
operand, is an array. In this case, <TT>Numeric</TT>
conceptually builds a temporary array <TT><I>t</I></TT>,
with shape <TT><I>b</I></TT><TT>.shape</TT>,
where each element of <TT><I>t</I></TT> equals
<TT><I>a</I></TT>. <TT>Numeric</TT> then
performs the requested operation between <TT><I>t</I></TT>
and <TT><I>b</I></TT>. In practice, therefore, when you
operate an array <TT><I>b</I></TT> with a scalar
<TT><I>a</I></TT>, as in
<TT><I>a</I></TT><TT>+</TT><TT><I>b</I></TT>
or
<TT><I>b</I></TT><TT>+</TT><TT><I>a</I></TT>,
the resulting array has the same shape as
<TT><I>b</I></TT>, and each element is the result of
applying the operator to the corresponding element of
<TT><I>b</I></TT> and the single number
<TT><I>a</I></TT>.</P>

<P class="docText">More generally, broadcasting can also apply when both operands
<TT><I>a</I></TT> and <TT><I>b</I></TT> are
arrays. Conceptually, broadcasting works according to rather
complicated general rules:</P>

<span style="font-weight:bold"><OL class="docList" TYPE="1">
<LI><span style="font-weight:normal"><P class="docList">When <TT><I>a</I></TT> and <TT><I>b</I></TT>
differ in rank, the one whose shape tuple is shorter is padded up to
the other's rank by adding leading axes, each with a
length of <TT>1</TT>.</P></span></LI>
<LI><span style="font-weight:normal"><P class="docList"><TT><I>a</I></TT><TT>.shape</TT> and
<TT><I>b</I></TT><TT>.shape</TT>, padded to the
same length as per rule 1, are compared starting from the right
(i.e., from the length of the last axis).</P></span></LI>
<LI><span style="font-weight:normal"><P class="docList">When the axis length along the axis being examined is the same for
<TT><I>a</I></TT> and <TT><I>b</I></TT>, that
axis is okay, and examination moves leftward to the previous axis.</P></span></LI>
<LI><span style="font-weight:normal"><P class="docList">When the lengths of the axes differ and both are greater than
<TT>1</TT>, <TT>Numeric</TT> raises an exception.</P></span></LI>
<LI><span style="font-weight:normal"><P class="docList">When one axis length is <TT>1</TT>,
<TT>Numeric</TT> broadcasts the corresponding array by
replication along that plane to the axis length of the other array.</P></span></LI>
</OL></span>
<P class="docText">Broadcasting's rules are complicated because of
their generality, but most typical applications of broadcasting are
in simple cases. For example, say we compute
<TT><I>a</I></TT><TT>+</TT><TT><I>b</I></TT>,
and <TT><I>a</I></TT><TT>.shape</TT> is
<TT>(5,3)</TT> (a matrix of five rows, three columns).
Further, say typical values for
<TT><I>b</I></TT><TT>.shape</TT> include
<TT>( )</TT> (a scalar), <TT>(3,)</TT> (a
one-dimensional vector with three elements), and
<TT>(5,1)</TT> (a matrix with five rows, one column). In
each of these cases, <TT><I>b</I></TT> is broadcast up to
a temporary array <TT><I>t</I></TT> with shape
<TT>(5,3)</TT> by replicating
<TT><I>b</I></TT>'s elements along the
needed axis (both axes, when <TT><I>b</I></TT> is a
scalar), and <TT>Numeric</TT> computes
<TT><I>a</I></TT><TT>+</TT><TT><I>t</I></TT>.
The simplest and most frequent case, of course, is when
<TT><I>b</I></TT><TT>.shape</TT> is
<TT>(5,3)</TT>, the same shape as
<TT><I>a</I></TT>'s. In this case, no
broadcasting is needed.</P>



<A NAME="pythonian-CHP-15-SECT-6.8.2"></A>
<H5 class="docSection3Title">15.6.8.2 In-place operations</H5>

<P class="docText"><A NAME="pythonian-CHP-15-ITERM-7257"></A>Arrays
support in-place operations through augmented assignment operators
<TT>+=</TT>, <TT>-=</TT>, and so on. The
left-hand side array or slice cannot be broadcast, but the right-hand
side can be. Similarly, the left-hand side cannot be cast up, but the
right-hand side can be. In other words, in-place operations treat the
left-hand side as rigid in both shape and type, but the right-hand
side is subject to the normal, more lenient rules.</P>



<A NAME="pythonian-CHP-15-SECT-6.9"></A>
<H4 class="docSection2Title">15.6.9 Functions</H4>

<P class="docText"><TT>Numeric</TT> defines several functions that operate on
arrays, or polymorphically on Python sequences, conceptually forming
temporary arrays from non-array operands.</P>

<A NAME="ch15-77095"></A><A NAME="pythonian-CHP-15-ITERM-7258"></A><A NAME="pythonian-CHP-15-ITERM-7259"></A><table width="515" border="0" cellpadding="5">
<tr>
<td align="left"><b><i>allclose</i></b></td>
<td align="right"></td>
</tr>
</table>
<hr width="515" size="3" noshade="true" align="left" color="black">
<table width="515" border="0" cellpadding="5">
<tr>
<td align="left">
<pre>allclose(<TT><I>x</I></TT>,<TT><I>y</I></TT>,<TT><I>rtol</I></TT>=1.e-5,<TT><I>atol</I></TT>=1.e-8)</pre>
</td>
<td align="right"></td>
</tr>
</table>
<P class="docText">Returns <TT>True</TT> when every element of
<TT><I>x</I></TT> is close to the corresponding element of
<TT><I>y</I></TT>, otherwise <TT>False</TT>. Two
elements <TT><I>ex</I></TT> and
<TT><I>ey</I></TT> are defined to be close if:</P>
<PRE>abs(<TT><I>ex</I></TT>-<TT><I>ey</I></TT>)&lt;<TT><I>atol</I></TT>+<TT><I>rtol</I></TT>*abs(<TT><I>ey</I></TT>)</PRE><P class="docText">In other words, <TT><I>ex</I></TT> and
<TT><I>ey</I></TT> are close if both are tiny (less than
<TT><I>atol</I></TT>) or if the relative difference is
small (less than <TT><I>rtol</I></TT>).
<TT>allclose</TT> is generally a better way to check array
equality than <TT>= =</TT>, since floating-point arithmetic
requires some comparison tolerance. However,
<TT>allclose</TT> is not applicable to complex arrays, only
to floating-point and integer arrays. To compare two complex arrays
<TT><I>x</I></TT> and <TT><I>y</I></TT> for
approximate equality, you can use:</P>
<PRE>allclose(x.real, y.real) and allclose(x.imag, y.imag)</PRE>

<A NAME="ch15-77096"></A><A NAME="pythonian-CHP-15-ITERM-7260"></A><A NAME="pythonian-CHP-15-ITERM-7261"></A><A NAME="pythonian-CHP-15-ITERM-7262"></A><A NAME="pythonian-CHP-15-ITERM-7263"></A><table width="515" border="0" cellpadding="5">
<tr>
<td align="left"><b><i>argmax, argmin</i></b></td>
<td align="right"></td>
</tr>
</table>
<hr width="515" size="3" noshade="true" align="left" color="black">
<table width="515" border="0" cellpadding="5">
<tr>
<td align="left">
<pre>argmax(<TT><I>a</I></TT>,<TT><I>axis</I></TT>=-1)
argmin(<TT><I>a</I></TT>,<TT><I>axis</I></TT>=-1)</pre>
</td>
<td align="right"></td>
</tr>
</table>
<P class="docText"><TT>argmax</TT> returns a new integer array
<TT><I>m</I></TT> whose shape tuple is
<TT><I>a</I></TT><TT>.shape</TT> minus the
indicated <TT><I>axis</I></TT>. Each element of
<TT><I>m</I></TT> is the index of a maximal element of
<TT><I>a</I></TT> along <TT><I>axis</I></TT>.
<TT>argmin</TT> is similar, but indicates minimal elements
rather than maximal ones.</P>

<A NAME="ch15-77097"></A><A NAME="pythonian-CHP-15-ITERM-7264"></A><A NAME="pythonian-CHP-15-ITERM-7265"></A><table width="515" border="0" cellpadding="5">
<tr>
<td align="left"><b><i>argsort</i></b></td>
<td align="right"></td>
</tr>
</table>
<hr width="515" size="3" noshade="true" align="left" color="black">
<table width="515" border="0" cellpadding="5">
<tr>
<td align="left">
<pre>argsort(<TT><I>a</I></TT>,<TT><I>axis</I></TT>=-1)</pre>
</td>
<td align="right"></td>
</tr>
</table>
<P class="docText">Returns a new integer array <TT><I>m</I></TT> with the
same shape as <TT><I>a</I></TT>. Each vector of
<TT><I>m</I></TT> along <TT><I>axis</I></TT> is
the index sequence needed to sort the corresponding axis of
<TT><I>a</I></TT>. In particular, if
<TT><I>a</I></TT> has rank <TT>1</TT>, the most
common case,
<TT>take(</TT><TT><I>a</I></TT><TT>,argsort(</TT><TT><I>a</I></TT><TT>))=
=sort(</TT><TT><I>a</I></TT><TT>)</TT>. For
example:</P>
<PRE>x = [52, 115, 99, 111, 114, 101, 97, 110, 100, 55]
print Numeric.argsort(x)   # prints: [0 9 6 2 8 5 7 3 4 1]
print Numeric.sort(x)      
# prints: [52 55 97 99 100 101 110 111 114 115]
print Numeric.take(x, Numeric.argsort(x))
# prints: [52 55 97 99 100 101 110 111 114 115]</PRE><P class="docText">Here, the result of
<TT>Numeric.argsort(</TT><TT><I>x</I></TT><TT>)</TT>
tells us that <TT><I>x</I></TT>'s
smallest element is
<TT><I>x</I></TT><TT>[0]</TT>, the second
smallest is <TT><I>x</I></TT><TT>[9]</TT>, the
third smallest is <TT><I>x</I></TT><TT>[6]</TT>,
and so on. The call to <TT>Numeric.take</TT> in the last
<TT>print</TT> statement takes
<TT><I>x</I></TT>'s elements exactly in
this order, and therefore produces the same sorted array as the call
to <TT>Numeric.sort</TT> in the second
<TT>print</TT> statement.</P>

<A NAME="ch15-77098"></A><A NAME="pythonian-CHP-15-ITERM-7266"></A><A NAME="pythonian-CHP-15-ITERM-7267"></A><table width="515" border="0" cellpadding="5">
<tr>
<td align="left"><b><i>array2string</i></b></td>
<td align="right"></td>
</tr>
</table>
<hr width="515" size="3" noshade="true" align="left" color="black">
<table width="515" border="0" cellpadding="5">
<tr>
<td align="left">
<pre>array2string(<TT><I>a</I></TT>,<TT><I>max_line_width</I></TT>=None,<TT><I>precision</I></TT>=None,
<TT><I>             suppress_small</I></TT>=None,<TT><I>separator</I></TT>=' ',
<TT><I>            array_output</I></TT>=False)</pre>
</td>
<td align="right"></td>
</tr>
</table>
<P class="docText">Returns a string representation <TT><I>s</I></TT> of array
<TT><I>a</I></TT>, showing elements within brackets,
separated by string <TT><I>separator</I></TT>. The last
dimension is horizontal, the penultimate one vertical, and further
dimensions are denoted by bracket nesting. If
<TT><I>array_output</I></TT> is true,
<TT><I>s</I></TT> starts with '<TT>array(</TT>'
and ends with '<TT>)</TT>'. <TT><I>s</I></TT>
ends with "<TT>,'X')</TT>" instead if <TT>X</TT>,
which is <TT><I>a</I></TT>'s type code,
is not <TT>Float</TT>, <TT>Complex</TT>, or
<TT>Int</TT>, which lets you later use
<TT>eval(</TT><TT><I>s</I></TT><TT>)</TT>
if <TT><I>separator</I></TT> is '<TT>,</TT>'.</P>
<P class="docText">Lines longer than <TT><I>max_line_width</I></TT> (by
default, <TT>77</TT>) are broken up.
<TT><I>precision</I></TT> determines how many digits are
used per element (by default, <TT>8</TT>). If
<TT><I>suppress_small</I></TT> is true, very small numbers
are shown as <TT>0</TT>. You can change these defaults by
binding attributes of module <TT>sys</TT> named
<TT>output_line_width</TT>,
<TT>float_output_precision</TT>, and
<TT>float_output_suppress_small</TT>.</P>
<P class="docText"><TT>str(</TT><TT><I>a</I></TT><TT>)</TT>
is like
<TT>array2string(</TT><TT><I>a</I></TT><TT>)</TT>.
<TT>repr(</TT><TT><I>a</I></TT><TT>)</TT>
is like
<TT>array2string(</TT><TT><I>a</I></TT><TT>,separator='</TT>,
'<TT>,array_output=True)</TT>.</P>

<A NAME="ch15-77099"></A><A NAME="pythonian-CHP-15-ITERM-7268"></A><A NAME="pythonian-CHP-15-ITERM-7269"></A><table width="515" border="0" cellpadding="5">
<tr>
<td align="left"><b><i>average</i></b></td>
<td align="right"></td>
</tr>
</table>
<hr width="515" size="3" noshade="true" align="left" color="black">
<table width="515" border="0" cellpadding="5">
<tr>
<td align="left">
<pre>average(<TT><I>a</I></TT>,<TT><I>axis</I></TT>=0,<TT><I>weights</I></TT>=None,<TT><I>returned</I></TT>=False)</pre>
</td>
<td align="right"></td>
</tr>
</table>
<P class="docText">Returns <TT><I>a</I></TT>'s average along
<TT><I>axis</I></TT>. When <TT><I>axis</I></TT>
is <TT>None</TT>, returns the average of all
<TT><I>a</I></TT>'s elements. When
<TT><I>weights</I></TT> is not <TT>None</TT>,
<TT><I>weights</I></TT> must be an array with
<TT><I>a</I></TT>'s shape, or a
one-dimensional array with the length of
<TT><I>a</I></TT>'s given
<TT><I>axis</I></TT>, and <TT>average</TT>
computes a weighted average. When <TT><I>returned</I></TT>
is true, returns a pair: the first item is the average, the second
item is the sum of weights (the count of values, when
<TT><I>weights</I></TT> is <TT>None</TT>).</P>

<A NAME="ch15-77100"></A><A NAME="pythonian-CHP-15-ITERM-7270"></A><A NAME="pythonian-CHP-15-ITERM-7271"></A><table width="515" border="0" cellpadding="5">
<tr>
<td align="left"><b><i>choose</i></b></td>
<td align="right"></td>
</tr>
</table>
<hr width="515" size="3" noshade="true" align="left" color="black">
<table width="515" border="0" cellpadding="5">
<tr>
<td align="left">
<pre>choose(<TT><I>a</I></TT>,<TT><I>values</I></TT>)</pre>
</td>
<td align="right"></td>
</tr>
</table>
<P class="docText">Returns an array <TT><I>c</I></TT> with the same shape as
<TT><I>a</I></TT>. <TT><I>values</I></TT> is a
sequence. <TT><I>a</I></TT>'s elements
are integers between <TT>0</TT>, included, and
<TT>len(</TT><TT><I>values</I></TT><TT>)</TT>,
excluded. Each element of <TT><I>c</I></TT> is the item of
<TT><I>values</I></TT> whose index is the corresponding
element of <TT><I>a</I></TT>. For example:</P>
<PRE>print Numeric.choose(Numeric.identity(3),'ox')   
# prints: [[x o o]
#          [o x o]
#          [o o x]]</PRE>

<A NAME="ch15-77101"></A><A NAME="pythonian-CHP-15-ITERM-7272"></A><A NAME="pythonian-CHP-15-ITERM-7273"></A><table width="515" border="0" cellpadding="5">
<tr>
<td align="left"><b><i>clip</i></b></td>
<td align="right"></td>
</tr>
</table>
<hr width="515" size="3" noshade="true" align="left" color="black">
<table width="515" border="0" cellpadding="5">
<tr>
<td align="left">
<pre>clip(<TT><I>m</I></TT>,<TT><I>min</I></TT>,<TT><I>max</I></TT>)</pre>
</td>
<td align="right"></td>
</tr>
</table>
<P class="docText">Returns an array <TT><I>c</I></TT> with the same type code
and shape as <TT><I>a</I></TT>. Each element
<TT><I>ec</I></TT> of <TT><I>c</I></TT> is the
corresponding element <TT><I>ea</I></TT> of
<TT><I>a</I></TT>, where
<TT><I>min</I></TT><TT>&lt;=</TT><TT><I>ea</I></TT><TT>&lt;=</TT><TT><I>max</I></TT>.
Where
<TT><I>ea</I></TT><TT>&lt;</TT><TT><I>min</I></TT>,
<TT><I>ec</I></TT> is <TT><I>min</I></TT>;
where
<TT><I>ea</I></TT><TT>&gt;</TT><TT><I>max</I></TT>,
<TT><I>ec</I></TT> is <TT><I>max</I></TT>. For
example:</P>
<PRE>print Numeric.clip(Numeric.arange(10),2,7)  
# prints: [2 2 2 3 4 5 6 7 7 7]</PRE>

<A NAME="ch15-77102"></A><A NAME="pythonian-CHP-15-ITERM-7274"></A><A NAME="pythonian-CHP-15-ITERM-7275"></A><table width="515" border="0" cellpadding="5">
<tr>
<td align="left"><b><i>compress</i></b></td>
<td align="right"></td>
</tr>
</table>
<hr width="515" size="3" noshade="true" align="left" color="black">
<table width="515" border="0" cellpadding="5">
<tr>
<td align="left">
<pre>compress(<TT><I>condition</I></TT>,<TT><I>a</I></TT>,<TT><I>axis</I></TT>=0)</pre>
</td>
<td align="right"></td>
</tr>
</table>
<P class="docText">Returns an array <TT><I>c</I></TT> with the same type code
and rank as <TT><I>a</I></TT>.
<TT><I>c</I></TT> includes only the elements of
<TT><I>a</I></TT> for which the item of
<TT><I>condition</I></TT>, corresponding along the given
<TT><I>axis</I></TT>, is true. For example,
<TT>compress((1,0,1)</TT>,<TT><I>a</I></TT><TT>)</TT>
<TT>= =</TT>
<TT>take(</TT><TT><I>a</I></TT><TT>,(0,2),0)</TT>
since <TT>(1,0,1)</TT> has true values only at indices
<TT>0</TT> and <TT>2</TT>.
Here's how to get only the even numbers from an
array:</P>
<PRE>a = Numeric.arange(10)
print Numeric.compress(a%2=  =0, a)   # prints: [0 2 4 6 8]</PRE>

<A NAME="ch15-77103"></A><A NAME="pythonian-CHP-15-ITERM-7276"></A><A NAME="pythonian-CHP-15-ITERM-7277"></A><table width="515" border="0" cellpadding="5">
<tr>
<td align="left"><b><i>concatenate</i></b></td>
<td align="right"></td>
</tr>
</table>
<hr width="515" size="3" noshade="true" align="left" color="black">
<table width="515" border="0" cellpadding="5">
<tr>
<td align="left">
<pre>concatenate(<TT><I>arrays</I></TT>, <TT><I>axis</I></TT>=0)</pre>
</td>
<td align="right"></td>
</tr>
</table>
<P class="docText"><TT><I>arrays</I></TT> is a sequence of arrays, all with
the same shape except possibly along the given
<TT><I>axis</I></TT>. <TT>concatenate</TT>
returns an array that is the concatenation of the
<TT><I>arrays</I></TT> along the given
<TT><I>axis</I></TT>. In particular,
<TT>concatenate((s,)*n)</TT> has the same sequence
replication semantics that
<TT><I>s</I></TT><TT>*</TT><TT><I>n</I></TT>
would have if <TT><I>s</I></TT> were a generic Python
sequence rather than an array. For example:</P>
<PRE>print Numeric.concatenate([Numeric.arange(5),
                           Numeric.arange(3)])
# prints: [0 1 2 3 4 0 1 2]</PRE>

<A NAME="ch15-77104"></A><A NAME="pythonian-CHP-15-ITERM-7278"></A><A NAME="pythonian-CHP-15-ITERM-7279"></A><table width="515" border="0" cellpadding="5">
<tr>
<td align="left"><b><i>convolve</i></b></td>
<td align="right"></td>
</tr>
</table>
<hr width="515" size="3" noshade="true" align="left" color="black">
<table width="515" border="0" cellpadding="5">
<tr>
<td align="left">
<pre>convolve(<TT><I>a</I></TT>,<TT><I>b</I></TT>,<TT><I>mode</I></TT>=2)</pre>
</td>
<td align="right"></td>
</tr>
</table>
<P class="docText">Returns an array <TT><I>c</I></TT> with rank
<TT>1</TT>, the linear convolution of rank
<TT>1</TT> arrays <TT><I>a</I></TT> and
<TT><I>b</I></TT>. Linear convolution is defined over
unbounded sequences. <TT>convolve</TT> conceptually extends
<TT><I>a</I></TT> and <TT><I>b</I></TT> to
infinite length by padding with <TT>0</TT>, then clips the
infinite-length result to its central part, yielding
<TT><I>c</I></TT>. When <TT><I>mode</I></TT> is
<TT>2</TT>, the default, <TT>convolve</TT> clips
only the padding, so <TT><I>c</I></TT>'s
shape is
<TT>(len(</TT><TT><I>a</I></TT><TT>)+len(</TT><TT><I>b</I></TT><TT>)-1,)</TT>.
Otherwise, <TT>convolve</TT> clips more. Say
<TT>len(</TT><TT><I>a</I></TT><TT>)</TT>
is greater than or equal to
<TT>len(</TT><TT><I>b</I></TT><TT>)</TT>:
when <TT><I>mode</I></TT> is <TT>0</TT>,
<TT>len(</TT><TT><I>c</I></TT><TT>)</TT>
is
<TT>len(</TT><TT><I>a</I></TT><TT>)-len(</TT><TT><I>b</I></TT><TT>)+1</TT>;
when <TT><I>mode</I></TT> is <TT>1</TT>,
<TT>len(</TT><TT><I>c</I></TT><TT>)</TT>
is
<TT>len(</TT><TT><I>a</I></TT><TT>)</TT>.
When
<TT>len(</TT><TT><I>a</I></TT><TT>)</TT>
is less than
<TT>len(</TT><TT><I>b</I></TT><TT>)</TT>,
the effect is symmetrical. For example:</P>
<PRE>a = Numeric.arange(6)
b = Numeric.arange(4)
print Numeric.convolve(a, b)          
# prints: [0 0 1 4 10 16 22 22 15]
print Numeric.convolve(a, b, 1)       
# prints: [0 1 4 10 16 22]
print Numeric.convolve(a, b, 0)       # prints: [4 10 16]</PRE>

<A NAME="ch15-77105"></A><A NAME="pythonian-CHP-15-ITERM-7280"></A><A NAME="pythonian-CHP-15-ITERM-7281"></A><table width="515" border="0" cellpadding="5">
<tr>
<td align="left"><b><i>cross_correlate</i></b></td>
<td align="right"></td>
</tr>
</table>
<hr width="515" size="3" noshade="true" align="left" color="black">
<table width="515" border="0" cellpadding="5">
<tr>
<td align="left">
<pre>cross_correlate(<TT><I>a</I></TT>,<TT><I>b</I></TT>,<TT><I>mode</I></TT>=0)</pre>
</td>
<td align="right"></td>
</tr>
</table>
<P class="docText">Like
<TT>convolve(</TT><TT><I>a</I></TT>,<TT><I>b</I></TT><TT>[::-1]</TT>,<TT><I>mode</I></TT><TT>)</TT>.</P>

<A NAME="ch15-77106"></A><A NAME="pythonian-CHP-15-ITERM-7282"></A><A NAME="pythonian-CHP-15-ITERM-7283"></A><table width="515" border="0" cellpadding="5">
<tr>
<td align="left"><b><i>diagonal</i></b></td>
<td align="right"></td>
</tr>
</table>
<hr width="515" size="3" noshade="true" align="left" color="black">
<table width="515" border="0" cellpadding="5">
<tr>
<td align="left">
<pre>diagonal(<TT><I>a</I></TT>,<TT><I>k</I></TT>=0,<TT><I>axis1</I></TT>=0,<TT><I>axis2</I></TT>=1)</pre>
</td>
<td align="right"></td>
</tr>
</table>
<P class="docText">Returns the elements of <TT><I>a</I></TT> whose index
along <TT><I>axis1</I></TT> and index along
<TT><I>axis2</I></TT> differ by
<TT><I>k</I></TT>. When <TT><I>a</I></TT> has
rank <TT>2</TT>, this means the main diagonal when
<TT><I>k</I></TT> equals <TT>0</TT>,
subdiagonals above the main one when <TT><I>k</I></TT> is
greater than <TT>0</TT>, and subdiagonals below the main
one when <TT><I>k</I></TT> is less than
<TT>0</TT>. For example:</P>
<PRE># a is [[0 1 2 3]
#       [4 5 6 7]
#       [8 9 10 11]
#       [12 13 14 15]]
print Numeric.diagonal(a)        # prints: [0 5 10 15]
print Numeric.diagonal(a,1)      # prints: [1 6 11]
print Numeric.diagonal(a,-1)     # prints: [4 9 14]</PRE><P class="docText">As shown,
<TT>diagonal(</TT><TT><I>a</I></TT><TT>)</TT>
is the main diagonal,
<TT>diagonal(</TT><TT><I>a</I></TT><TT>,1)</TT>
the subdiagonal just above the main one, and
<TT>diagonal(</TT><TT><I>a</I></TT><TT>,-1)</TT>
the subdiagonal just below the main one.</P>

<A NAME="ch15-77107"></A><A NAME="pythonian-CHP-15-ITERM-7284"></A><A NAME="pythonian-CHP-15-ITERM-7285"></A><table width="515" border="0" cellpadding="5">
<tr>
<td align="left"><b><i>indices</i></b></td>
<td align="right"></td>
</tr>
</table>
<hr width="515" size="3" noshade="true" align="left" color="black">
<table width="515" border="0" cellpadding="5">
<tr>
<td align="left">
<pre>indices(<TT><I>shapetuple</I></TT>,<TT><I>typecode</I></TT>=None)</pre>
</td>
<td align="right"></td>
</tr>
</table>
<P class="docText">Returns an integer array <TT><I>x</I></TT> of shape
<TT>(len(</TT><TT><I>shapetuple</I></TT><TT>),)+</TT><TT><I>shapetuple</I></TT>.
Each element of subarray
<TT><I>x</I></TT><TT>[</TT><TT><I>i</I></TT><TT>]</TT>
is equal to the element's
<TT><I>i</I></TT> index in the subarray. For example:</P>
<PRE>print Numeric.indices((2,4))     # prints: [[[0 0 0 0]
                                 #           [1 1 1 1]]
                                 #          [[0 1 2 3]
                                 #           [0 1 2 3]]]</PRE>

<A NAME="ch15-77108"></A><A NAME="pythonian-CHP-15-ITERM-7286"></A><A NAME="pythonian-CHP-15-ITERM-7287"></A><table width="515" border="0" cellpadding="5">
<tr>
<td align="left"><b><i>innerproduct</i></b></td>
<td align="right"></td>
</tr>
</table>
<hr width="515" size="3" noshade="true" align="left" color="black">
<table width="515" border="0" cellpadding="5">
<tr>
<td align="left">
<pre>innerproduct(a,b)</pre>
</td>
<td align="right"></td>
</tr>
</table>
<P class="docText">Returns an array <TT><I>m</I></TT> with the result of the
inner product of <TT><I>a</I></TT> and
<TT><I>b</I></TT>, like
<TT>matrixmultiply(</TT><TT><I>a</I></TT><TT>,transpose(</TT><TT><I>b</I></TT><TT>))</TT>.
<TT><I>a</I></TT><TT>.shape[-1]</TT> must equal
<TT><I>b</I></TT><TT>.shape[-1]</TT>, and
<TT><I>m</I></TT><TT>.shape</TT> is the tuple
<TT><I>a</I></TT><TT>.shape[:-1]+</TT><TT><I>b</I></TT><TT>.shape[0:-1:-1]</TT>.</P>

<A NAME="ch15-77109"></A><A NAME="pythonian-CHP-15-ITERM-7288"></A><A NAME="pythonian-CHP-15-ITERM-7289"></A><table width="515" border="0" cellpadding="5">
<tr>
<td align="left"><b><i>matrixmultiply</i></b></td>
<td align="right"></td>
</tr>
</table>
<hr width="515" size="3" noshade="true" align="left" color="black">
<table width="515" border="0" cellpadding="5">
<tr>
<td align="left">
<pre>matrixmultiply(<TT><I>a</I></TT>,<TT><I>b</I></TT>)</pre>
</td>
<td align="right"></td>
</tr>
</table>
<P class="docText">Returns an array <TT><I>m</I></TT> with
<TT><I>a</I></TT> times <TT><I>b</I></TT> in
the matrix-multiplication sense, rather than element-wise
multiplication.
<TT><I>a</I></TT><TT>.shape[-1]</TT> must equal
<TT><I>b</I></TT><TT>.shape[0]</TT>, and
<TT><I>m</I></TT><TT>.shape</TT> is the tuple
<TT><I>a</I></TT><TT>.shape[:-1]+</TT><TT><I>b</I></TT><TT>.shape[1:]</TT>.</P>

<A NAME="ch15-77110"></A><A NAME="pythonian-CHP-15-ITERM-7290"></A><A NAME="pythonian-CHP-15-ITERM-7291"></A><table width="515" border="0" cellpadding="5">
<tr>
<td align="left"><b><i>nonzero</i></b></td>
<td align="right"></td>
</tr>
</table>
<hr width="515" size="3" noshade="true" align="left" color="black">
<table width="515" border="0" cellpadding="5">
<tr>
<td align="left">
<pre>nonzero(<TT><I>a</I></TT>)</pre>
</td>
<td align="right"></td>
</tr>
</table>
<P class="docText">Returns the indices of those elements of <TT><I>a</I></TT>
that are not equal to <TT>0</TT>, like the expression:</P>
<PRE>array([<TT><I>i</I></TT> for <TT><I>i</I></TT> in range(len(<TT><I>a</I></TT>)) if <TT><I>a</I></TT>[<TT><I>i</I></TT>] != 0])</PRE><P class="docText"><TT><I>a</I></TT> must be a sequence or one-dimensional
array.</P>

<A NAME="ch15-77111"></A><A NAME="pythonian-CHP-15-ITERM-7292"></A><A NAME="pythonian-CHP-15-ITERM-7293"></A><table width="515" border="0" cellpadding="5">
<tr>
<td align="left"><b><i>put</i></b></td>
<td align="right"></td>
</tr>
</table>
<hr width="515" size="3" noshade="true" align="left" color="black">
<table width="515" border="0" cellpadding="5">
<tr>
<td align="left">
<pre>put(<TT><I>a</I></TT>,<TT><I>indices</I></TT>,<TT><I>values</I></TT>)</pre>
</td>
<td align="right"></td>
</tr>
</table>
<P class="docText"><TT><I>a</I></TT> must be a contiguous array.
<TT><I>indices</I></TT> is a sequence of integers, taken
as indices into <TT><I>a</I></TT><TT>.flat</TT>.
<TT><I>values</I></TT> is a sequence of values that can be
converted to <TT><I>a</I></TT>'s type
code (if shorter than <TT><I>indices</I></TT>,
<TT><I>values</I></TT> is repeated as needed). Each
element of <TT><I>a</I></TT> indicated by an item in
<TT><I>indices</I></TT> is replaced by the corresponding
item in <TT><I>values</I></TT>. <TT>put</TT> is
therefore similar to (but faster than) the loop:</P>
<PRE>for i,v in zip(indices,values*len(indices)):
    a.flat[i]=v</PRE>

<A NAME="ch15-77112"></A><A NAME="pythonian-CHP-15-ITERM-7294"></A><A NAME="pythonian-CHP-15-ITERM-7295"></A><table width="515" border="0" cellpadding="5">
<tr>
<td align="left"><b><i>putmask</i></b></td>
<td align="right"></td>
</tr>
</table>
<hr width="515" size="3" noshade="true" align="left" color="black">
<table width="515" border="0" cellpadding="5">
<tr>
<td align="left">
<pre>putmask(<TT><I>a</I></TT>,<TT><I>mask</I></TT>,<TT><I>values</I></TT>)</pre>
</td>
<td align="right"></td>
</tr>
</table>
<P class="docText"><TT><I>a</I></TT> must be a contiguous array.
<TT><I>mask</I></TT> is a sequence with the same length as
<TT><I>a</I></TT><TT>.flat</TT>.
<TT><I>values</I></TT> is a sequence of values that can be
converted to <TT><I>a</I></TT>'s type
code (if shorter than <TT><I>mask</I></TT>,
<TT><I>values</I></TT> is repeated as needed). Each
element of <TT><I>a</I></TT> corresponding to a true item
in <TT><I>mask</I></TT> is replaced by the corresponding
item in <TT><I>values</I></TT>. <TT>putmask</TT>
is therefore similar to (but faster than) the loop:</P>
<PRE>for i,v in zip(xrange(len(mask)),values*len(mask)):
    if mask[i]: a.flat[i]=v</PRE>

<A NAME="ch15-77113"></A><A NAME="pythonian-CHP-15-ITERM-7296"></A><A NAME="pythonian-CHP-15-ITERM-7297"></A><table width="515" border="0" cellpadding="5">
<tr>
<td align="left"><b><i>rank</i></b></td>
<td align="right"></td>
</tr>
</table>
<hr width="515" size="3" noshade="true" align="left" color="black">
<table width="515" border="0" cellpadding="5">
<tr>
<td align="left">
<pre>rank(<TT><I>a</I></TT>)</pre>
</td>
<td align="right"></td>
</tr>
</table>
<P class="docText">Returns the rank of <TT><I>a</I></TT>, just like
<TT>len(array(</TT><TT><I>a</I></TT><TT>,copy=False).shape)</TT>.</P>

<A NAME="ch15-77114"></A><A NAME="pythonian-CHP-15-ITERM-7298"></A><A NAME="pythonian-CHP-15-ITERM-7299"></A><table width="515" border="0" cellpadding="5">
<tr>
<td align="left"><b><i>ravel</i></b></td>
<td align="right"></td>
</tr>
</table>
<hr width="515" size="3" noshade="true" align="left" color="black">
<table width="515" border="0" cellpadding="5">
<tr>
<td align="left">
<pre>ravel(<TT><I>a</I></TT>)</pre>
</td>
<td align="right"></td>
</tr>
</table>
<P class="docText">Returns the flat form of <TT><I>a</I></TT>, just like
<TT>array(</TT><TT><I>a</I></TT><TT>,copy=False).flat</TT>.</P>

<A NAME="ch15-77115"></A><A NAME="pythonian-CHP-15-ITERM-7300"></A><A NAME="pythonian-CHP-15-ITERM-7301"></A><table width="515" border="0" cellpadding="5">
<tr>
<td align="left"><b><i>repeat</i></b></td>
<td align="right"></td>
</tr>
</table>
<hr width="515" size="3" noshade="true" align="left" color="black">
<table width="515" border="0" cellpadding="5">
<tr>
<td align="left">
<pre>repeat(<TT><I>a</I></TT>,<TT><I>repeat</I></TT>,<TT><I>axis</I></TT>=0)</pre>
</td>
<td align="right"></td>
</tr>
</table>
<P class="docText">Returns an array with the same type code and rank as
<TT><I>a</I></TT>, where each of
<TT><I>a</I></TT>'s elements is repeated
along <TT><I>axis</I></TT> as many times as the value of
the corresponding element of <TT><I>repeat</I></TT>.
<TT><I>repeat</I></TT> is an integer, or an integer
sequence of length
<TT><I>a</I></TT><TT>.shape[</TT><TT><I>axis</I></TT><TT>]</TT>.</P>

<A NAME="ch15-77116"></A><A NAME="pythonian-CHP-15-ITERM-7302"></A><A NAME="pythonian-CHP-15-ITERM-7303"></A><table width="515" border="0" cellpadding="5">
<tr>
<td align="left"><b><i>reshape</i></b></td>
<td align="right"></td>
</tr>
</table>
<hr width="515" size="3" noshade="true" align="left" color="black">
<table width="515" border="0" cellpadding="5">
<tr>
<td align="left">
<pre>reshape(<TT><I>a</I></TT>,<TT><I>shapetuple</I></TT>)</pre>
</td>
<td align="right"></td>
</tr>
</table>
<P class="docText">Returns an array <TT><I>r</I></TT> with shape
<TT><I>shapetuple</I></TT>, sharing
<TT><I>a</I></TT>'s data.
<TT><I>r</I></TT><TT>=reshape(</TT><TT><I>a</I></TT>,<TT><I>shapetuple</I></TT><TT>)</TT>
is just like
<TT><I>r</I></TT><TT>=</TT><TT><I>a</I></TT><TT>;</TT><TT><I>r</I></TT><TT>.shape=</TT><TT><I>shapetuple</I></TT>.
The product of
<TT><I>shapetuple</I></TT>'s items must
equal the product of
<TT><I>a</I></TT><TT>.shape</TT>'s,
but one of <TT><I>shapetuple</I></TT>'s
items may be <TT>-1</TT> to ask for adaptation of that
axis's length. For example:</P>
<PRE>print Numeric.reshape(range(12),(3,-1))     
# prints: [[0 1 2 3]
#          [4 5 6 7]
#          [8 9 10 11]]</PRE>

<A NAME="ch15-77117"></A><A NAME="pythonian-CHP-15-ITERM-7304"></A><A NAME="pythonian-CHP-15-ITERM-7305"></A><table width="515" border="0" cellpadding="5">
<tr>
<td align="left"><b><i>resize</i></b></td>
<td align="right"></td>
</tr>
</table>
<hr width="515" size="3" noshade="true" align="left" color="black">
<table width="515" border="0" cellpadding="5">
<tr>
<td align="left">
<pre>resize(<TT><I>a</I></TT>,<TT><I>shapetuple</I></TT>)</pre>
</td>
<td align="right"></td>
</tr>
</table>
<P class="docText">Returns an array <TT><I>r</I></TT> with shape
<TT><I>shapetuple</I></TT> and data copied from
<TT><I>a</I></TT>. If
<TT><I>r</I></TT>'s size is smaller than
<TT><I>a</I></TT>'s size,
<TT><I>r</I></TT><TT>.flat</TT> is copied from
the start of
<TT>ravel(</TT><TT><I>a</I></TT><TT>)</TT>;
if <TT><I>r</I></TT>'s size is larger,
the data in
<TT>ravel(</TT><TT><I>a</I></TT><TT>)</TT>
is replicated as many times as needed. In particular,
<TT>resize(</TT><TT><I>s</I></TT><TT>,(</TT><TT><I>n</I></TT><TT>*len(</TT><TT><I>s</I></TT><TT>),))</TT>
has the sequence replication semantics that
<TT><I>s</I></TT><TT>*</TT><TT><I>n</I></TT>
would have if <TT><I>s</I></TT> were a generic Python
sequence rather than an array. For example:</P>
<PRE>print Numeric.resize(range(5),(3,4))        
# prints: [[0 1 2 3]
#          [4 0 1 2]
#          [3 4 0 1]]</PRE>

<A NAME="ch15-77119"></A><A NAME="pythonian-CHP-15-ITERM-7306"></A><A NAME="pythonian-CHP-15-ITERM-7307"></A><table width="515" border="0" cellpadding="5">
<tr>
<td align="left"><b><i>searchsorted</i></b></td>
<td align="right"></td>
</tr>
</table>
<hr width="515" size="3" noshade="true" align="left" color="black">
<table width="515" border="0" cellpadding="5">
<tr>
<td align="left">
<pre>searchsorted(<TT><I>a</I></TT>,<TT><I>values</I></TT>)</pre>
</td>
<td align="right"></td>
</tr>
</table>
<P class="docText"><TT><I>a</I></TT> must be a sorted rank
<TT>1</TT> array. <TT>searchsorted</TT> returns
an array of integers <TT><I>s</I></TT> with the same shape
as <TT><I>values</I></TT>. Each element of
<TT><I>s</I></TT> is the index in
<TT><I>a</I></TT> where the corresponding element of
<TT><I>values</I></TT> would fit in the sorted order of
<TT><I>a</I></TT>. For example:</P>
<PRE>print Numeric.searchsorted([0,1],
    [0.2,-0.3,0.5,1.3,1.0,0.0,0.3])
# prints: [1 0 1 2 1 0 1]</PRE><P class="docText">This specific idiom returns an array with <TT>0</TT> in
correspondence to each element <TT><I>x</I></TT> of
<TT><I>values</I></TT> when <TT><I>x</I></TT>
is less than or equal to <TT>0</TT>; <TT>1</TT>
when <TT><I>x</I></TT> is greater than
<TT>0</TT> and less than or equal to <TT>1</TT>;
and <TT>2</TT> when <TT><I>x</I></TT> is greater
than <TT>1</TT>. With slight generalization, and with
appropriate thresholds as the elements of sorted array
<TT><I>a</I></TT>, this idiom allows very fast
classification of what subrange each element
<TT><I>x</I></TT> of <TT><I>values</I></TT>
falls into.</P>

<A NAME="ch15-77118"></A><A NAME="pythonian-CHP-15-ITERM-7308"></A><A NAME="pythonian-CHP-15-ITERM-7309"></A><table width="515" border="0" cellpadding="5">
<tr>
<td align="left"><b><i>shape</i></b></td>
<td align="right"></td>
</tr>
</table>
<hr width="515" size="3" noshade="true" align="left" color="black">
<table width="515" border="0" cellpadding="5">
<tr>
<td align="left">
<pre>shape(<TT><I>a</I></TT>)</pre>
</td>
<td align="right"></td>
</tr>
</table>
<P class="docText">Returns the shape of <TT><I>a</I></TT>, just like
<TT>array(</TT><TT><I>a</I></TT><TT>,copy=False).shape</TT>.</P>

<A NAME="ch15-77120"></A><A NAME="pythonian-CHP-15-ITERM-7310"></A><A NAME="pythonian-CHP-15-ITERM-7311"></A><table width="515" border="0" cellpadding="5">
<tr>
<td align="left"><b><i>size</i></b></td>
<td align="right"></td>
</tr>
</table>
<hr width="515" size="3" noshade="true" align="left" color="black">
<table width="515" border="0" cellpadding="5">
<tr>
<td align="left">
<pre>size(<TT><I>a</I></TT>,<TT><I>axis</I></TT>=None)</pre>
</td>
<td align="right"></td>
</tr>
</table>
<P class="docText">When <TT><I>axis</I></TT> is <TT>None</TT>,
returns the total number of elements in <TT><I>a</I></TT>.
Otherwise, returns the number of elements of
<TT><I>a</I></TT> along <TT><I>axis</I></TT>,
like
<TT>array(</TT><TT><I>a</I></TT><TT>,copy=False).shape[</TT><TT><I>axis</I></TT><TT>]</TT>.</P>

<A NAME="ch15-77121"></A><A NAME="pythonian-CHP-15-ITERM-7312"></A><A NAME="pythonian-CHP-15-ITERM-7313"></A><table width="515" border="0" cellpadding="5">
<tr>
<td align="left"><b><i>sort</i></b></td>
<td align="right"></td>
</tr>
</table>
<hr width="515" size="3" noshade="true" align="left" color="black">
<table width="515" border="0" cellpadding="5">
<tr>
<td align="left">
<pre>sort(<TT><I>a</I></TT>,<TT><I>axis</I></TT>=-1)</pre>
</td>
<td align="right"></td>
</tr>
</table>
<P class="docText">Returns an array <TT><I>s</I></TT> with the same type code
and shape as <TT><I>a</I></TT>, with elements along each
plane of the given <TT><I>axis</I></TT> reordered so that
the plane is sorted in increasing order. For example:</P>
<PRE># x is [[0 1 2 3]
#       [4 0 1 2]
#       [3 4 0 1]]
print Numeric.sort(x)       # prints: [[0 1 2 3]
                            #          [0 1 2 4]
                            #          [0 1 3 4]]
print Numeric.sort(x,0)     # prints: [[0 0 0 1]
                            #          [3 1 1 2]
                            #          [4 4 2 3]]</PRE><P class="docText"><TT>sort(</TT><TT><I>x</I></TT><TT>)</TT>
returns a result where each row is sorted.
<TT>sort(</TT><TT><I>x</I></TT><TT>,0)</TT>
returns a result where each column is sorted.</P>

<A NAME="ch15-77122"></A><A NAME="pythonian-CHP-15-ITERM-7314"></A><A NAME="pythonian-CHP-15-ITERM-7315"></A><table width="515" border="0" cellpadding="5">
<tr>
<td align="left"><b><i>swapaxes</i></b></td>
<td align="right"></td>
</tr>
</table>
<hr width="515" size="3" noshade="true" align="left" color="black">
<table width="515" border="0" cellpadding="5">
<tr>
<td align="left">
<pre>swapaxes(<TT><I>a</I></TT>,<TT><I>axis1</I></TT>,<TT><I>axis2</I></TT>)</pre>
</td>
<td align="right"></td>
</tr>
</table>
<P class="docText">Returns an array <TT><I>s</I></TT> with the same type
code, rank, and size as <TT><I>a</I></TT>, sharing
<TT><I>a</I></TT>'s data.
<TT><I>s</I></TT>'s shape is the same as
<TT><I>a</I></TT>, but with the lengths of axes
<TT><I>axis1</I></TT> and <TT><I>axis2</I></TT>
swapped. In other words,
<TT><I>s</I></TT><TT>=swapaxes(</TT><TT><I>a</I></TT>,<TT><I>axis1</I></TT>,<TT><I>axis2</I></TT><TT>)</TT>
is like:</P>
<PRE><TT><I>swapped_shape</I></TT>=range(length(<TT><I>a</I></TT>.shape))
<TT><I>swapped_shape</I></TT>[<TT><I>axis1</I></TT>]=<TT><I>axis2</I></TT>
<TT><I>swapped_shape</I></TT>[<TT><I>axis2</I></TT>]=<TT><I>axis1</I></TT>
<TT><I>s</I></TT>=transpose(<TT><I>a</I></TT>,<TT><I>swapped_shape</I></TT>)</PRE>

<A NAME="ch15-77123"></A><A NAME="pythonian-CHP-15-ITERM-7316"></A><A NAME="pythonian-CHP-15-ITERM-7317"></A><table width="515" border="0" cellpadding="5">
<tr>
<td align="left"><b><i>take</i></b></td>
<td align="right"></td>
</tr>
</table>
<hr width="515" size="3" noshade="true" align="left" color="black">
<table width="515" border="0" cellpadding="5">
<tr>
<td align="left">
<pre>take(<TT><I>a</I></TT>,<TT><I>indices</I></TT>,<TT><I>axis</I></TT>=0)</pre>
</td>
<td align="right"></td>
</tr>
</table>
<P class="docText">Returns an array <TT><I>t</I></TT> with the same type code
and rank as <TT><I>a</I></TT>, containing the subset of
<TT><I>a</I></TT>'s elements that would
be in a slice along <TT><I>axis</I></TT> comprising the
given <TT><I>indices</I></TT>. For example, after
<TT><I>t</I></TT><TT>=take(</TT><TT><I>a</I></TT><TT>,(1,3))</TT>,
<TT><I>t</I></TT><TT>.shape=
=(2,)+</TT><TT><I>a</I></TT><TT>.shape[1:]</TT>,
and <TT><I>t</I></TT>'s elements are
those in the second and fourth rows of <TT><I>a</I></TT>.</P>

<A NAME="ch15-77124"></A><A NAME="pythonian-CHP-15-ITERM-7318"></A><A NAME="pythonian-CHP-15-ITERM-7319"></A><table width="515" border="0" cellpadding="5">
<tr>
<td align="left"><b><i>trace</i></b></td>
<td align="right"></td>
</tr>
</table>
<hr width="515" size="3" noshade="true" align="left" color="black">
<table width="515" border="0" cellpadding="5">
<tr>
<td align="left">
<pre>trace(<TT><I>a</I></TT>,<TT><I>k</I></TT>=0)</pre>
</td>
<td align="right"></td>
</tr>
</table>
<P class="docText">Returns the sum of <TT><I>a</I></TT>'s
elements along the <TT><I>k</I></TT> diagonal, like
<TT>sum(diagonal(</TT><TT><I>a</I></TT>,<TT><I>k</I></TT><TT>))</TT>.</P>

<A NAME="ch15-77125"></A><A NAME="pythonian-CHP-15-ITERM-7320"></A><A NAME="pythonian-CHP-15-ITERM-7321"></A><table width="515" border="0" cellpadding="5">
<tr>
<td align="left"><b><i>transpose</i></b></td>
<td align="right"></td>
</tr>
</table>
<hr width="515" size="3" noshade="true" align="left" color="black">
<table width="515" border="0" cellpadding="5">
<tr>
<td align="left">
<pre>transpose(<TT><I>a</I></TT>,<TT><I>axes</I></TT>=None)</pre>
</td>
<td align="right"></td>
</tr>
</table>
<P class="docText">Returns an array <TT><I>t</I></TT>, with the same type
code, rank, and size as <TT><I>a</I></TT>, sharing
<TT><I>a</I></TT>'s data.
<TT><I>t</I></TT>'s axes are permuted
with respect to <TT><I>a</I></TT>'s by
the axis indices in sequence <TT><I>axes</I></TT>. When
<TT><I>axes</I></TT> is <TT>None</TT>,
<TT><I>t</I></TT>'s axes invert the order
of <TT><I>a</I></TT>'s, as if
<TT><I>axes</I></TT> were
<TT><I>a</I></TT><TT>.shape[::-1]</TT>.</P>

<A NAME="ch15-77126"></A><A NAME="pythonian-CHP-15-ITERM-7322"></A><A NAME="pythonian-CHP-15-ITERM-7323"></A><A NAME="pythonian-CHP-15-ITERM-7324"></A><A NAME="pythonian-CHP-15-ITERM-7325"></A><A NAME="pythonian-CHP-15-ITERM-7326"></A><table width="515" border="0" cellpadding="5">
<tr>
<td align="left"><b><i>where</i></b></td>
<td align="right"></td>
</tr>
</table>
<hr width="515" size="3" noshade="true" align="left" color="black">
<table width="515" border="0" cellpadding="5">
<tr>
<td align="left">
<pre>where(<TT><I>condition</I></TT>,<TT><I>x</I></TT>,<TT><I>y</I></TT>)</pre>
</td>
<td align="right"></td>
</tr>
</table>
<P class="docText">Returns an array <TT><I>w</I></TT> with the same shape as
<TT><I>condition</I></TT>. Where an element of
<TT><I>condition</I></TT> is true, the corresponding
element of <TT><I>w</I></TT> is the corresponding element
of <TT><I>x</I></TT>; otherwise it is the corresponding
element of <TT><I>y</I></TT>. For example,
<TT>clip(</TT><TT><I>a</I></TT>,<TT><I>min</I></TT>,<TT><I>max</I></TT><TT>)</TT>
is the same as
<TT>where(greater(</TT><TT><I>a</I></TT>,<TT><I>max</I></TT><TT>)</TT>,<TT><I>max</I></TT><TT>,where(greater(</TT><TT><I>a</I></TT>,<TT><I>min</I></TT><TT>)</TT>,<TT><I>a</I></TT>,<TT><I>min</I></TT><TT>))</TT>.<A NAME="pythonian-CHP-15-ITERM-7324"></A> <A NAME="pythonian-CHP-15-ITERM-7325"></A> <A NAME="pythonian-CHP-15-ITERM-7326"></A></P>



<ul></ul>
</td>
</tr>
</table>
<td></td>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<td class="tt1"><a href="NFO/lib.html">[ Team LiB ]</a></td><td valign="top" class="tt1" align="right">
          <a href="0596001886_pythonian-chp-15-sect-5.html"><img src="FILES/previous.gif" width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a>
          <a href="0596001886_pythonian-chp-15-sect-7.html"><img src="FILES/next.gif" width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a>
</td></table>
</body></html>
