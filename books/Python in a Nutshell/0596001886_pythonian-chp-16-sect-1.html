<html><head>
<META http-equiv="Content-Type" content="text/html">
<!--SafClassName="docSection1Title"--><!--SafTocEntry="16.1 Tkinter Fundamentals"-->
<link rel="STYLESHEET" type="text/css" href="FILES/style.css">
<link rel="STYLESHEET" type="text/css" href="FILES/docsafari.css">
<style type="text/css">	.tt1    {font-size: 10pt;}</style>
</head>
<body>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<td class="tt1"><a href="NFO/lib.html">[ Team LiB ]</a></td><td valign="top" class="tt1" align="right">
	<a href="0596001886_pythonian-chp-16.html"><img src="FILES/previous.gif" width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a>
	<a href="0596001886_pythonian-chp-16-sect-2.html"><img src="FILES/next.gif" width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a>
</td></table>
<br>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<tr>
<td valign="top"><A NAME="pythonian-CHP-16-SECT-1"></A>
<H3 class="docSection1Title">16.1 Tkinter Fundamentals</H3>

<P class="docText">The <TT>Tkinter</TT> module makes it easy to build simple
GUI applications. You simply import <TT>Tkinter</TT>,
create, configure, and position the widgets you want, and then enter
the <TT>Tkinter</TT> main loop. Your application becomes
<I>event-driven</I>, which means that the user
interacts with the widgets, causing events, and your application
responds via the functions you installed as handlers for these
events.<A NAME="pythonian-CHP-16-ITERM-7364"></A></P>

<P class="docText"><A NAME="pythonian-CHP-16-ITERM-7365"></A>The following example shows a
simple application that exhibits this general structure:</P>

<PRE>import sys, Tkinter
Tkinter.Label(text="Welcome!").pack(  )
Tkinter.Button(text="Exit", command=sys.exit).pack(  )
Tkinter.mainloop(  )</PRE>

<P class="docText">The calls to <TT>Label</TT> and <TT>Button</TT>
create the respective widgets and return them as results. Since we
specify no parent windows, <TT>Tkinter</TT> puts the
widgets directly in the application's main window.
The named arguments specify each widget's
configuration. In this simple case, we don't need to
bind variables to the widgets. We just call the
<TT>pack</TT> method on each widget, handing control of the
widget's geometry to a layout manager object known
as the packer. A <I>layout</I>
<I>manager</I> is an invisible component whose job is
to position widgets within other widgets (known as
<I>container</I> or <I>parent</I>
widgets), handling geometrical layout issues. The previous example
passes no arguments to control the packer's
operation, so therefore the packer operates in a default
way.<A NAME="pythonian-CHP-16-ITERM-7366"></A>
<A NAME="pythonian-CHP-16-ITERM-7367"></A>
<A NAME="pythonian-CHP-16-ITERM-7368"></A></P>

<P class="docText">When the user clicks on the button, the <TT>command</TT>
callable of the <TT>Button</TT> widget executes without
arguments. The example passes function <TT>sys.exit</TT> as
the argument named <TT>command</TT> when it creates the
<TT>Button</TT>. Therefore, when the user clicks on the
button, <TT>sys.exit( )</TT> executes and terminates the
application (as covered in <A class="docLink" HREF="0596001886_pythonian-chp-8.html#pythonian-CHP-8">Chapter 8</A>).</P>

<P class="docText">After creating and packing the widgets, the example calls
<TT>Tkinter</TT>'s
<TT>mainloop</TT> function, and thus enters the
<TT>Tkinter</TT> main loop and becomes event-driven. Since
the only event for which the example installs a handler is a click on
the button, nothing happens from the application's
viewpoint until the user clicks the button. Meanwhile, however, the
<TT>Tkinter</TT> toolkit responds in the expected way to
other user actions, such as moving the <TT>Tkinter</TT>
window, covering and uncovering the window, and so on. When the user
resizes the window, the packer layout manager works to update the
widgets' geometry. In this example, the widgets
remain centered, close to the upper edge of the window, with the
label above the button.</P>

<P class="docText">All strings going to or coming from <TT>Tkinter</TT> are
Unicode strings, so be sure to review
<A class="docLink" HREF="0596001886_pythonian-chp-9-sect-6.html#pythonian-CHP-9-SECT-6">Section 9.6</A> in <A class="docLink" HREF="0596001886_pythonian-chp-9.html#pythonian-CHP-9">Chapter 9</A> if you need to show, or accept as input,
characters outside of the ASCII encoding (you may then need to use
some other appropriate
codec).<A NAME="pythonian-CHP-16-ITERM-7369"></A> <A NAME="pythonian-CHP-16-ITERM-7370"></A></P>

<P class="docText"><A NAME="pythonian-CHP-16-ITERM-7371"></A> <A NAME="pythonian-CHP-16-ITERM-7372"></A>Note that all the scripts in this
chapter are meant to be run standalone (i.e., from a command line or
in a platform-dependent way, such as by double clicking on a
script's icon). Running a GUI script from inside
another program that has its own GUI, such as a Python integrated
development environment (e.g., IDLE or PythonWin), can cause various
anomalies. This can be a particular problem when the GUI script
attempts to terminate (and thus close down the GUI), since the
script's GUI and the other
program's GUI may interfere with each other.</P>

<P class="docText"><A NAME="pythonian-CHP-16-ITERM-7373"></A>Note
also that this chapter refers to several all-uppercase, multi-letter
identifiers (e.g., <TT>LEFT</TT>,
<TT>RAISED</TT>, <TT>ACTIVE</TT>). All these
identifiers are constant attributes of module
<TT>Tkinter</TT>, used for a wide variety of purposes. If
your code uses <TT>from</TT> <TT>Tkinter</TT>
<TT>import</TT> <TT>*</TT>, you can then use the
identifiers directly. If your code uses <TT>import</TT>
<TT>Tkinter</TT> instead, you need to qualify those
identifiers, just like all others you import from
<TT>Tkinter</TT>, by preceding them with
'<TT>Tkinter.</TT>'. <TT>Tkinter</TT> is one of
the rare Python modules designed to support <TT>from</TT>
<TT>Tkinter</TT> <TT>import</TT>
<TT>*</TT>, but of course you may choose to use
<TT>import</TT> <TT>Tkinter</TT> anyway,
sacrificing some convenience and brevity in favor of greater clarity.
A good compromise between convenience and clarity is often to import
<TT>Tkinter</TT> with a shorter name (e.g.,
<TT>import</TT> <TT>Tkinter</TT>
<TT>as</TT> <TT>Tk</TT>).</P>


<a href="0596001886_"><img src="FILES/pixel.gif" width="1" height="1" border="0"></a><ul></ul>
</td>
</tr>
</table>
<td></td>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<td class="tt1"><a href="NFO/lib.html">[ Team LiB ]</a></td><td valign="top" class="tt1" align="right">
          <a href="0596001886_pythonian-chp-16.html"><img src="FILES/previous.gif" width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a>
          <a href="0596001886_pythonian-chp-16-sect-2.html"><img src="FILES/next.gif" width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a>
</td></table>
</body></html>
