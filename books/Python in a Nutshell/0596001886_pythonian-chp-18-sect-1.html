<html><head>
<META http-equiv="Content-Type" content="text/html">
<!--SafClassName="docSection1Title"--><!--SafTocEntry="18.1 URL Access"-->
<link rel="STYLESHEET" type="text/css" href="FILES/style.css">
<link rel="STYLESHEET" type="text/css" href="FILES/docsafari.css">
<style type="text/css">	.tt1    {font-size: 10pt;}</style>
</head>
<body>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<td class="tt1"><a href="NFO/lib.html">[ Team LiB ]</a></td><td valign="top" class="tt1" align="right">
	<a href="0596001886_pythonian-chp-18.html"><img src="FILES/previous.gif" width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a>
	<a href="0596001886_pythonian-chp-18-sect-2.html"><img src="FILES/next.gif" width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a>
</td></table>
<br>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<tr>
<td valign="top"><A NAME="pythonian-CHP-18-SECT-1"></A>
<H3 class="docSection1Title">18.1 URL Access</H3>

<P class="docText"><A NAME="pythonian-CHP-18-ITERM-7991"></A> <A NAME="pythonian-CHP-18-ITERM-7992"></A>A
URL identifies a resource on the Internet. A URL is a string composed
of several optional parts, called components, known as scheme,
location, path, query, and fragment. A URL with all its parts looks
something like:<A NAME="pythonian-CHP-18-ITERM-7993"></A></P>

<PRE>scheme://lo.ca.ti.on/pa/th?query#fragment</PRE>

<P class="docText"><A NAME="pythonian-CHP-18-ITERM-7994"></A>
<A NAME="pythonian-CHP-18-ITERM-7995"></A>For example, in <A class="docLink" target="_blank" HREF="http://www.python.org/faq.cgi@src=fie">http://www.python.org:80/faq.cgi?src=fie</A>, the
scheme is <I>http</I>, the location is
<I>www.python.org:80</I>, the path is
<I>/faq.cgi</I>, the query is
<I>src=fie</I>, and there is no fragment. Some of the
punctuation characters form a part of one of the components they
separate, while others are just separators and are part of no
component. Omitting punctuation implies missing components. For
example, in <span class="docEmphasis">mailto:me@you.com</span>,
the scheme is <I>mailto</I>, the path is
<I>me@you.com</I>, and there is no location, query, or
fragment. The missing <I>// </I>means the URL has no
location part, the missing <I>?</I> means it has no
query part, and the missing <I>#</I> means it has no
fragment part.</P>

<A NAME="pythonian-CHP-18-SECT-1.1"></A>
<H4 class="docSection2Title">18.1.1 The urlparse Module</H4>

<P class="docText"><A NAME="pythonian-CHP-18-ITERM-7996"></A> <A NAME="pythonian-CHP-18-ITERM-7997"></A>The <TT>urlparse</TT> module
supplies functions to analyze and synthesize URL strings. In Python
2.2, the most frequently used functions of module
<TT>urlparse</TT> are <TT>urljoin</TT>,
<TT>urlsplit</TT>, and <TT>urlunsplit</TT>.</P>

<A NAME="ch18-4-fm2xml"></A><A NAME="pythonian-CHP-18-ITERM-7998"></A><A NAME="pythonian-CHP-18-ITERM-7999"></A><A NAME="pythonian-CHP-18-ITERM-8000"></A><table width="515" border="0" cellpadding="5">
<tr>
<td align="left"><b><i>urljoin</i></b></td>
<td align="right"></td>
</tr>
</table>
<hr width="515" size="3" noshade="true" align="left" color="black">
<table width="515" border="0" cellpadding="5">
<tr>
<td align="left">
<pre>urljoin(<TT><I>base_url_string</I></TT>,<TT><I>relative_url_string</I></TT>)</pre>
</td>
<td align="right"></td>
</tr>
</table>
<P class="docText">Returns a URL string <TT><I>u</I></TT>, obtained by
joining <TT><I>relative_url_string</I></TT>, which may be
relative, with <TT><I>base_url_string</I></TT>. The
joining procedure that <TT>urljoin</TT> performs to obtain
its result <TT><I>u</I></TT> may be summarized as follows:</P>
<UL>
<LI><P class="docList">When either of the argument strings is empty,
<TT><I>u</I></TT> is the other argument.</P></LI>
<LI><P class="docList">When <TT><I>relative_url_string</I></TT> explicitly
specifies a scheme different from that of
<TT><I>base_url_string</I></TT>,
<TT><I>u</I></TT> is
<TT><I>relative_url_string</I></TT>. Otherwise,
<TT><I>u</I></TT>'s scheme is that of
<TT><I>base_url_string</I></TT>.</P></LI>
<LI><P class="docList">When the scheme does not allow relative URLs (e.g.,
<I>mailto</I>), or
<TT><I>relative_url_string</I></TT> explicitly specifies a
location (even when it is the same as the location of
<TT><I>base_url_string</I></TT>), all other components of
<TT><I>u</I></TT> are those of
<TT><I>relative_url_string</I></TT>. Otherwise,
<TT><I>u</I></TT>'s location is that of
<TT><I>base_url_string</I></TT>.</P></LI>
<LI><P class="docList"><TT><I>u</I></TT>'s path is obtained by
joining the paths of <TT><I>base_url_string</I></TT> and
<TT><I>relative_url_string</I></TT> according to standard
syntax for absolute and relative URL paths. For example:</P><PRE>import urlparse
urlparse.urljoin(
    'http://somehost.com/some/path/here',
    '../other/path')
# Result is: 'http://somehost.com/some/other/path'</PRE></LI>
</UL>

<A NAME="ch18-5-fm2xml"></A><A NAME="pythonian-CHP-18-ITERM-8001"></A><A NAME="pythonian-CHP-18-ITERM-8002"></A><table width="515" border="0" cellpadding="5">
<tr>
<td align="left"><b><i>urlsplit</i></b></td>
<td align="right"></td>
</tr>
</table>
<hr width="515" size="3" noshade="true" align="left" color="black">
<table width="515" border="0" cellpadding="5">
<tr>
<td align="left">
<pre>urlsplit(<TT><I>url_string</I></TT>,<TT><I>default_scheme</I></TT>='',<TT><I>allow_fragments</I></TT>=True)</pre>
</td>
<td align="right"></td>
</tr>
</table>
<P class="docText">Analyzes <TT><I>url_string</I></TT> and returns a tuple
with five string items: scheme, location, path, query, and fragment.
<TT><I>default_scheme</I></TT> is the first item when the
<TT><I>url_string</I></TT> lacks a scheme. When
<TT><I>allow_fragments</I></TT> is
<TT>False</TT>, the tuple's last item is
always '', whether or not
<TT><I>url_string</I></TT> has a fragment. Items
corresponding to missing parts are always ''. For
example:</P>
<PRE>urlparse.urlsplit(
    'http://www.python.org:80/faq.cgi?src=fie')
# Result is: 
# ('http','www.python.org:80','/faq.cgi','src=fie','')</PRE>

<A NAME="ch18-6-fm2xml"></A><A NAME="pythonian-CHP-18-ITERM-8003"></A><A NAME="pythonian-CHP-18-ITERM-8004"></A><table width="515" border="0" cellpadding="5">
<tr>
<td align="left"><b><i>urlunsplit</i></b></td>
<td align="right"></td>
</tr>
</table>
<hr width="515" size="3" noshade="true" align="left" color="black">
<table width="515" border="0" cellpadding="5">
<tr>
<td align="left">
<pre>urlunsplit(<TT><I>url_tuple</I></TT>)</pre>
</td>
<td align="right"></td>
</tr>
</table>
<P class="docText"><TT><I>url_tuple</I></TT> is a tuple with exactly five
items, all strings. For example, any return value from a
<TT>urlsplit</TT> call is an acceptable argument for
<TT>urlunsplit</TT>. <TT>urlunsplit</TT> returns
a URL string with the given components and the needed separators, but
with no redundant separators (e.g., there is no <TT>#</TT>
in the result when the fragment,
<TT><I>url_tuple</I></TT>'s last item, is
''). For example:</P>
<PRE>urlparse.urlunsplit(('http','www.python.org:80',
    '/faq.cgi','src=fie',''))
# Result is: 'http://www.python.org:80/faq.cgi?src=fie'</PRE><P class="docText"><TT>urlunsplit(urlsplit(</TT><TT><I>x</I></TT><TT>))</TT>
returns a normalized form of URL string <TT><I>x</I></TT>,
not necessarily equal to <TT><I>x</I></TT> because
<TT><I>x</I></TT> need not be normalized. For example:</P>
<PRE>urlparse.urlunsplit(
    urlparse.urlsplit('http://a.com/path/a?'))
# Result is: 'http://a.com/path/a'</PRE><P class="docText">In this case, the normalization ensures that redundant separators,
such as the trailing <I>?</I> in the argument to
<TT>urlsplit</TT>, are not present in the result.</P>

<P class="docText">Module <TT>urlparse</TT> also supplies functions
<TT>urlparse</TT> and <TT>urlunparse</TT>. In
Python 2.1, <TT>urlparse</TT> did not supply
<TT>urlsplit</TT> and <TT>urlunsplit</TT>, so you
had to use <TT>urlparse</TT> and
<TT>urlunparse</TT> instead. <TT>urlparse</TT>
and <TT>urlunparse</TT> are akin to
<TT>urlsplit</TT> and <TT>urlunsplit</TT>, but
are based on six components rather than five. The
<TT>parse</TT> functions insert a
<TT><I>parameters</I></TT> component between
<TT><I>path</I></TT> and <TT><I>query</I></TT>
using an older standard for URLs, where parameters applied to the
entire path. According to the current standard, parameters apply to
each part of the path separately. Therefore, the path URL component
may now include parameters to subdivide in further phases of the
analysis. For example:</P>

<PRE>u.urlsplit('http://a.com/path;with/some;params?anda=query')
# Result is: ('http','a.com','/path;with/some;params','anda=query','')
u.urlparse('http://a.com/path;with/some;params?anda=query')
# Result is: ('http','a.com','/path;with/some','params','anda=query','')</PRE>

<P class="docText">In this code, <TT>urlparse</TT> is able to split off the
'<TT>;params</TT>' part of the parameters, but considers
the '<TT>/path;with/some</TT>' substring to be the path.
<TT>urlsplit</TT> considers the entire
'<TT>/path;with/some;params</TT>' to be the path, returned
as the third item in the result tuple. Should you then need to
separate the '<TT>with</TT>' and
'<TT>params</TT>' parameters parts of the path component,
you can perform further string processing on the third item of
<TT>urlsplit</TT>'s return tuple, such as
splitting on <TT>/</TT> and then on <TT>;</TT>.
In practice, very few URLs on the Net make use of parameters, so you
may not care about this subtle distinction.</P>


<A NAME="pythonian-CHP-18-SECT-1.2"></A>
<H4 class="docSection2Title">18.1.2 The urllib Module</H4>

<P class="docText"><A NAME="pythonian-CHP-18-ITERM-8005"></A> <A NAME="pythonian-CHP-18-ITERM-8006"></A>The
<TT>urllib</TT> module supplies simple functions to read
data from URLs. <TT>urllib</TT> supports the following
protocols (schemes): <I>http</I>,
<I>https</I>, <I>ftp</I>,
<I>gopher</I>, and <I>file</I>.
<I>file</I> indicates a local file.
<TT>urllib</TT> uses <I>file</I> as the
default scheme for URLs that lack an explicit scheme. You can find
simple, typical examples of <TT>urllib</TT> use in <A class="docLink" HREF="0596001886_pythonian-chp-22.html#pythonian-CHP-22">Chapter 22</A> and <A class="docLink" HREF="0596001886_pythonian-chp-23.html#pythonian-CHP-23">Chapter 23</A>, where
<TT>urllib.urlopen</TT> is used to fetch HTML and XML pages
that various examples parse and analyze.<A NAME="pythonian-CHP-18-ITERM-8007"></A></P>

<A NAME="pythonian-CHP-18-SECT-1.2.1"></A>
<H5 class="docSection3Title">18.1.2.1 Functions</H5>

<P class="docText">Module <TT>urllib</TT> supplies a number of functions, with
<TT>urlopen</TT> being the most frequently used.</P>

<A NAME="ch18-9-fm2xml"></A><A NAME="pythonian-CHP-18-ITERM-8008"></A><A NAME="pythonian-CHP-18-ITERM-8009"></A><table width="515" border="0" cellpadding="5">
<tr>
<td align="left"><b><i>quote</i></b></td>
<td align="right"></td>
</tr>
</table>
<hr width="515" size="3" noshade="true" align="left" color="black">
<table width="515" border="0" cellpadding="5">
<tr>
<td align="left">
<pre>quote(<TT><I>str</I></TT>,<TT><I>safe</I></TT>='/')</pre>
</td>
<td align="right"></td>
</tr>
</table>
<P class="docText">Returns a copy of <TT><I>str</I></TT> where special
characters are changed into Internet-standard quoted form
<TT>%</TT><TT><I>xx</I></TT>. Does not quote
alphanumeric characters, spaces, any of the characters
'<TT>_,.-</TT>', nor any of the characters in string
<TT><I>safe</I></TT>.</P>

<A NAME="ch18-10-fm2xml"></A><A NAME="pythonian-CHP-18-ITERM-8010"></A><A NAME="pythonian-CHP-18-ITERM-8011"></A><table width="515" border="0" cellpadding="5">
<tr>
<td align="left"><b><i>quote_plus</i></b></td>
<td align="right"></td>
</tr>
</table>
<hr width="515" size="3" noshade="true" align="left" color="black">
<table width="515" border="0" cellpadding="5">
<tr>
<td align="left">
<pre>quote_plus(<TT><I>str</I></TT>, <TT><I>safe</I></TT>='/')</pre>
</td>
<td align="right"></td>
</tr>
</table>
<P class="docText">Like <TT>quote</TT>, but also changes spaces into plus
signs.</P>

<A NAME="ch18-11-fm2xml"></A><A NAME="pythonian-CHP-18-ITERM-8012"></A><A NAME="pythonian-CHP-18-ITERM-8013"></A><table width="515" border="0" cellpadding="5">
<tr>
<td align="left"><b><i>unquote</i></b></td>
<td align="right"></td>
</tr>
</table>
<hr width="515" size="3" noshade="true" align="left" color="black">
<table width="515" border="0" cellpadding="5">
<tr>
<td align="left">
<pre>unquote(<TT><I>str</I></TT>)</pre>
</td>
<td align="right"></td>
</tr>
</table>
<P class="docText">Returns a copy of <TT><I>str</I></TT> where each quoted
form <TT>%</TT><TT><I>xx</I></TT> is changed
into the corresponding character.</P>

<A NAME="ch18-12-fm2xml"></A><A NAME="pythonian-CHP-18-ITERM-8014"></A><A NAME="pythonian-CHP-18-ITERM-8015"></A><table width="515" border="0" cellpadding="5">
<tr>
<td align="left"><b><i>unquote_plus</i></b></td>
<td align="right"></td>
</tr>
</table>
<hr width="515" size="3" noshade="true" align="left" color="black">
<table width="515" border="0" cellpadding="5">
<tr>
<td align="left">
<pre>unquote_plus(<TT><I>str</I></TT>)</pre>
</td>
<td align="right"></td>
</tr>
</table>
<P class="docText">Like <TT>unquote</TT>, but also changes plus signs into
spaces.</P>

<A NAME="ch18-13-fm2xml"></A><A NAME="pythonian-CHP-18-ITERM-8016"></A><A NAME="pythonian-CHP-18-ITERM-8017"></A><table width="515" border="0" cellpadding="5">
<tr>
<td align="left"><b><i>urlcleanup</i></b></td>
<td align="right"></td>
</tr>
</table>
<hr width="515" size="3" noshade="true" align="left" color="black">
<table width="515" border="0" cellpadding="5">
<tr>
<td align="left">
<pre>urlcleanup(  )</pre>
</td>
<td align="right"></td>
</tr>
</table>
<P class="docText">Clears the cache of function <TT>urlretrieve</TT>, covered
later in this section.</P>

<A NAME="ch18-14-fm2xml"></A><A NAME="pythonian-CHP-18-ITERM-8018"></A><A NAME="pythonian-CHP-18-ITERM-8019"></A><table width="515" border="0" cellpadding="5">
<tr>
<td align="left"><b><i>urlencode</i></b></td>
<td align="right"></td>
</tr>
</table>
<hr width="515" size="3" noshade="true" align="left" color="black">
<table width="515" border="0" cellpadding="5">
<tr>
<td align="left">
<pre>urlencode(<TT><I>query</I></TT>,<TT><I>doseq</I></TT>=False)</pre>
</td>
<td align="right"></td>
</tr>
</table>
<P class="docText">Returns a string with the URL-encoded form of
<TT><I>query</I></TT>. <TT><I>query</I></TT>
can be either a sequence of
<TT>(</TT><TT><I>name</I></TT>,
<TT><I>value</I></TT><TT>)</TT> pairs, or a
mapping, in which case the resulting string encodes the
mapping's
<TT>(</TT><TT><I>key</I></TT>,
<TT><I>value</I></TT><TT>)</TT> pairs. For
example:</P>
<PRE>urllib.urlencode([('ans',42),('key','val')])
# 'ans=42&amp;key=val'
urllib.urlencode({'ans':42, 'key':'val'})
# 'key=val&amp;ans=42'</PRE><P class="docText">Remember that the order of items in a dictionary is not defined: if
you need the URL-encoded form to have the key/value pairs in a
specific order, use a sequence as the
<TT><I>query</I></TT> argument, as in the first call in
this example.</P>
<P class="docText">When <TT><I>doseq</I></TT> is true, any
<TT><I>value</I></TT> in <TT><I>query</I></TT>
that is a sequence is encoded as separate parameters, one per item in
<TT><I>value</I></TT>. For example:</P>
<PRE>u.urlencode([('K',('x','y','z'))],1)
# 'K=x&amp;K=y&amp;K=z'
u.urlencode([('K',('x','y','z'))],0)
# 'K=%28%27x%27%2C+%27y%27%2C+%27z%27%29'</PRE><P class="docText">When <TT><I>doseq</I></TT> is false (the default), each
value is encoded as the <TT>quote_plus</TT> of its string
form given by built-in <TT>str</TT>, whether the value is a
sequence or not.</P>

<A NAME="ch18-15-fm2xml"></A><A NAME="pythonian-CHP-18-ITERM-8020"></A><A NAME="pythonian-CHP-18-ITERM-8021"></A><A NAME="pythonian-CHP-18-ITERM-8022"></A><A NAME="pythonian-CHP-18-ITERM-8023"></A><A NAME="pythonian-CHP-18-ITERM-8024"></A><A NAME="pythonian-CHP-18-ITERM-8025"></A><A NAME="pythonian-CHP-18-ITERM-8026"></A><A NAME="pythonian-CHP-18-ITERM-8027"></A><A NAME="pythonian-CHP-18-ITERM-8028"></A><A NAME="pythonian-CHP-18-ITERM-8029"></A><A NAME="pythonian-CHP-18-ITERM-8030"></A><A NAME="pythonian-CHP-18-ITERM-8031"></A><A NAME="pythonian-CHP-18-ITERM-8032"></A><A NAME="pythonian-CHP-18-ITERM-8033"></A><table width="515" border="0" cellpadding="5">
<tr>
<td align="left"><b><i>urlopen</i></b></td>
<td align="right"></td>
</tr>
</table>
<hr width="515" size="3" noshade="true" align="left" color="black">
<table width="515" border="0" cellpadding="5">
<tr>
<td align="left">
<pre>urlopen(<TT><I>urlstring</I></TT>,<TT><I>data</I></TT>=None)</pre>
</td>
<td align="right"></td>
</tr>
</table>
<P class="docText">Accesses the given URL and returns a read-only file-like object
<TT><I>f</I></TT>. <TT><I>f</I></TT> supplies
file-like methods <TT>read</TT>,
<TT>readline</TT>, <TT>readlines</TT>, and
<TT>close</TT>, as well as two
others:<A NAME="pythonian-CHP-18-ITERM-8022"></A> <A NAME="pythonian-CHP-18-ITERM-8023"></A> <A NAME="pythonian-CHP-18-ITERM-8024"></A> <A NAME="pythonian-CHP-18-ITERM-8025"></A></P><A NAME="pythonian-CHP-18-ITERM-8026"></A><A NAME="pythonian-CHP-18-ITERM-8027"></A><A NAME="pythonian-CHP-18-ITERM-8028"></A><A NAME="pythonian-CHP-18-ITERM-8029"></A><A NAME="pythonian-CHP-18-ITERM-8030"></A><A NAME="pythonian-CHP-18-ITERM-8031"></A><A NAME="pythonian-CHP-18-ITERM-8032"></A><A NAME="pythonian-CHP-18-ITERM-8033"></A><DL class="docList">
<DT><span class="docPubcolor"><TT><I>f</I></TT><span class="docPubcolor"><span class="docMonofont">.geturl(  )</span></span> </span></DT>
<DD>
<P class="docList"><A NAME="pythonian-CHP-18-ITERM-8026"></A> <A NAME="pythonian-CHP-18-ITERM-8027"></A> <A NAME="pythonian-CHP-18-ITERM-8028"></A> <A NAME="pythonian-CHP-18-ITERM-8029"></A>Returns the URL of
<TT><I>f</I></TT>. This may differ from
<TT><I>urlstring</I></TT> both because of normalization
(as mentioned for function <TT>urlunsplit</TT> earlier) and
because the server may issue HTTP redirects (i.e., indications that
the requested data is located elsewhere). <TT>urllib</TT>
supports redirects transparently, and method
<TT>geturl</TT> lets you check for them if you
want.<A NAME="pythonian-CHP-18-ITERM-8030"></A> <A NAME="pythonian-CHP-18-ITERM-8031"></A>
<A NAME="pythonian-CHP-18-ITERM-8032"></A> <A NAME="pythonian-CHP-18-ITERM-8033"></A></P>
</DD>
<DT><span class="docPubcolor"><TT><I>f</I></TT><span class="docPubcolor"><span class="docMonofont">.info(  )</span></span> </span></DT>
<DD>
<P class="docList">Returns an instance <TT><I>m</I></TT> of class
<TT>Message</TT> of module <TT>mimetools</TT>,
covered in <A class="docLink" HREF="0596001886_pythonian-chp-21.html#pythonian-CHP-21">Chapter 21</A>. The main use of
<TT><I>m</I></TT> is as a container of headers holding
metadata about <TT><I>f</I></TT>. For example,
<TT><I>m</I></TT><TT>['Content-Type']</TT> is
the MIME type and subtype of the data in
<TT><I>f</I></TT>. You can also access this information by
calling <TT><I>m</I></TT>'s methods
<TT><I>m</I></TT><TT>.gettype( )</TT>,
<TT><I>m</I></TT><TT>.getmaintype( )</TT>, and
<TT><I>m</I></TT><TT>.getsubtype( )</TT>.</P>
</DD>
</DL><P class="docText">When <TT><I>data</I></TT> is <TT>None</TT> and
<TT><I>urlstring</I></TT>'s scheme is
<I>http</I>, <TT>urlopen</TT> sends a
<TT>GET</TT> request. When <TT><I>data</I></TT>
is not <TT>None</TT>,
<TT><I>urlstring</I></TT>'s scheme must
be <I>http</I>, and <TT>urlopen</TT> sends a
POST request. <TT><I>data</I></TT> must then be in
URL-encoded form, and you normally prepare it with function
<TT>urlencode</TT>, covered earlier in this section.</P>
<P class="docText"><TT>urlopen</TT> can transparently use proxies that do not
require authentication. Set environment variables
<TT>http_proxy</TT>, <TT>ftp_proxy</TT>, and
<TT>gopher_proxy</TT> to the proxies' URLs
to exploit this. You normally perform such settings in your
system's environment, in platform-dependent ways,
before you start Python. On the Macintosh only,
<TT>urlopen</TT> transparently and implicitly retrieves
proxy URLs from your Internet configuration settings.
<TT>urlopen</TT> does not support proxies that require
authentication—for such advanced needs, use the richer and more
complicated library module <TT>urllib2</TT>, covered in a
moment.</P>

<A NAME="ch18-16-fm2xml"></A><A NAME="pythonian-CHP-18-ITERM-8034"></A><A NAME="pythonian-CHP-18-ITERM-8035"></A><table width="515" border="0" cellpadding="5">
<tr>
<td align="left"><b><i>urlretrieve</i></b></td>
<td align="right"></td>
</tr>
</table>
<hr width="515" size="3" noshade="true" align="left" color="black">
<table width="515" border="0" cellpadding="5">
<tr>
<td align="left">
<pre>urlretrieve(<TT><I>urlstring</I></TT>,<TT><I>filename</I></TT>=None,<TT><I>reporthook</I></TT>=None,<TT><I>data</I></TT>=None)</pre>
</td>
<td align="right"></td>
</tr>
</table>
<P class="docText">Similar to
<TT>urlopen(</TT><TT><I>urlstring</I></TT>,<TT><I>data</I></TT><TT>)</TT>,
but instead returns a pair
<TT>(</TT><TT><I>f</I></TT>,<TT><I>m</I></TT><TT>)</TT>.
<TT><I>f</I></TT> is a string that specifies the path to a
file on the local filesystem. <TT><I>m</I></TT> is an
instance of class <TT>Message</TT> of module
<TT>mimetools</TT>, like the result of method
<TT>info</TT> called on the result value of
<TT>urlopen</TT>, covered earlier in this section.</P>
<P class="docText">When <TT><I>filename</I></TT> is <TT>None</TT>,
<TT>urlretrieve</TT> copies retrieved data to a temporary
local file, and <TT><I>f</I></TT> is the path to the
temporary local file. When <TT><I>filename</I></TT> is not
<TT>None</TT>, <TT>urlretrieve</TT> copies
retrieved data to the file named <TT><I>filename</I></TT>,
and <TT><I>f</I></TT> is
<TT><I>filename</I></TT>. When
<TT><I>reporthook</I></TT> is not <TT>None</TT>,
it must be a callable with three arguments, as in the function:</P>
<PRE>def <TT><I>reporthook</I></TT>(<TT><I>block_count</I></TT>, <TT><I>block_size</I></TT>, <TT><I>file_size</I></TT>):
    print <TT><I>block_count</I></TT></PRE><P class="docText"><TT>urlretrieve</TT> calls
<TT><I>reporthook</I></TT> zero or more times while
retrieving data. At each call, it passes
<TT><I>block_count</I></TT>, the number of blocks of data
retrieved so far; <TT><I>block_size</I></TT>, the size in
bytes of each block; and <TT><I>file_size</I></TT>, the
total size of the file in bytes. <TT>urlretrieve</TT>
passes <TT><I>file_size</I></TT> as <TT>-1</TT>
when unable to determine file size, which depends on the protocol
involved and on how completely the server implements that protocol.
The purpose of <TT><I>reporthook</I></TT> is to let your
program give graphical or textual feedback to the user about the
progress of the file retrieval operation that
<TT>urlretrieve</TT> performs.</P>



<A NAME="pythonian-CHP-18-SECT-1.2.2"></A>
<H5 class="docSection3Title">18.1.2.2 The FancyURLopener class</H5>

<P class="docText">You normally use module <TT>urllib</TT> through the
functions it supplies (most often <TT>urlopen</TT>). To
customize <TT>urllib</TT>'s functionality,
however, you can subclass
<TT>urllib</TT>'s
<TT>FancyURLopener</TT> class and bind an instance of your
subclass to attribute <TT>_urlopener</TT> of module
<TT>urllib</TT>. The customizable aspects of an instance
<TT><I>f</I></TT> of a subclass of
<TT>FancyURLopener</TT> are the
following.<A NAME="pythonian-CHP-18-ITERM-8036"></A> <A NAME="pythonian-CHP-18-ITERM-8037"></A> <A NAME="pythonian-CHP-18-ITERM-8038"></A></P>

<A NAME="ch18-18-fm2xml"></A><A NAME="pythonian-CHP-18-ITERM-8039"></A><A NAME="pythonian-CHP-18-ITERM-8040"></A><table width="515" border="0" cellpadding="5">
<tr>
<td align="left"><b><i>prompt_user_passwd</i></b></td>
<td align="right"></td>
</tr>
</table>
<hr width="515" size="3" noshade="true" align="left" color="black">
<table width="515" border="0" cellpadding="5">
<tr>
<td align="left">
<pre><TT><I>f</I></TT>.prompt_user_passwd(<TT><I>host</I></TT>,<TT><I>realm</I></TT>)</pre>
</td>
<td align="right"></td>
</tr>
</table>
<P class="docText"><A NAME="pythonian-CHP-18-ITERM-8039"></A> <A NAME="pythonian-CHP-18-ITERM-8040"></A>Returns a pair
<TT>(</TT><TT><I>user</I></TT>,<TT><I>password</I></TT><TT>)</TT>
to use to authenticate access to <TT><I>host</I></TT> in
the security <TT><I>realm</I></TT>. The default
implementation in class <TT>FancyURLopener</TT> prompts the
user for this data in interactive text mode. Your subclass can
override this method for such purposes as interacting with the user
via a GUI or fetching authentication data from persistent storage.</P>

<A NAME="ch18-19-fm2xml"></A><A NAME="pythonian-CHP-18-ITERM-8041"></A><A NAME="pythonian-CHP-18-ITERM-8042"></A><A NAME="pythonian-CHP-18-ITERM-8043"></A><A NAME="pythonian-CHP-18-ITERM-8044"></A><table width="515" border="0" cellpadding="5">
<tr>
<td align="left"><b><i>version</i></b></td>
<td align="right"></td>
</tr>
</table>
<hr width="515" size="3" noshade="true" align="left" color="black">
<table width="515" border="0" cellpadding="5">
<tr>
<td align="left">
<pre><TT><I>f</I></TT>.version</pre>
</td>
<td align="right"></td>
</tr>
</table>
<P class="docText"><A NAME="pythonian-CHP-18-ITERM-8041"></A> <A NAME="pythonian-CHP-18-ITERM-8042"></A>The
string that <TT><I>f</I></TT> uses to identify itself to
the server, for example via the User-Agent header in the HTTP
protocol. You can override this attribute by subclassing, or rebind
it directly on an instance of
<TT>FancyURLopener</TT>.<A NAME="pythonian-CHP-18-ITERM-8043"></A> <A NAME="pythonian-CHP-18-ITERM-8044"></A></P>



<A NAME="pythonian-CHP-18-SECT-1.3"></A>
<H4 class="docSection2Title">18.1.3 The urllib2 Module</H4>

<P class="docText"><A NAME="pythonian-CHP-18-ITERM-8045"></A>
<A NAME="pythonian-CHP-18-ITERM-8046"></A>The <TT>urllib2</TT> module is
a rich, highly customizable superset of module
<TT>urllib</TT>. <TT>urllib2</TT> lets you work
directly with rather advanced aspects of protocols such as HTTP. For
example, you can send requests with customized headers as well as
URL-encoded POST bodies, and handle authentication in various realms,
in both Basic and Digest forms, directly or via HTTP proxies.
<A NAME="pythonian-CHP-18-ITERM-8047"></A></P>

<P class="docText">In the rest of this section, I cover only the ways in which
<TT>urllib2</TT> lets your program customize these advanced
aspects of URL retrieval. I do not try to impart the advanced
knowledge of HTTP and other network protocols, independent of Python,
that you need to make full use of
<TT>urllib2</TT>'s rich functionality. As
an HTTP tutorial, I recommend <span class="docEmphasis">Python Web
Programming</span>, by Steve Holden (New Riders): it offers good
coverage of HTTP basics with examples coded in Python, and a good
bibliography if you need further details about network protocols.</P>

<A NAME="pythonian-CHP-18-SECT-1.3.1"></A>
<H5 class="docSection3Title">18.1.3.1 Functions</H5>

<P class="docText"><TT>urllib2</TT> supplies a function
<TT>urlopen</TT> basically identical to
<TT>urllib</TT>'s
<TT>urlopen</TT>. To customize
<TT>urllib2</TT>'s behavior, you can
install, before calling <TT>urlopen</TT>, any number of
handlers grouped into an opener using the
<TT>build_opener</TT> and <TT>install_opener</TT>
functions.</P>

<P class="docText">You can also optionally pass to <TT>urlopen</TT> an
instance of class <TT>Request</TT> instead of a URL string.
Such an instance may include both a URL string and supplementary
information on how to access it, as covered shortly in <A class="docLink" HREF="#pythonian-CHP-18-SECT-1.3.2">Section 18.1.3.2</A>.</P>

<A NAME="ch18-22-fm2xml"></A><A NAME="pythonian-CHP-18-ITERM-8048"></A><A NAME="pythonian-CHP-18-ITERM-8049"></A><table width="515" border="0" cellpadding="5">
<tr>
<td align="left"><b><i>build_opener</i></b></td>
<td align="right"></td>
</tr>
</table>
<hr width="515" size="3" noshade="true" align="left" color="black">
<table width="515" border="0" cellpadding="5">
<tr>
<td align="left">
<pre>build_opener(*<TT><I>handlers</I></TT>)</pre>
</td>
<td align="right"></td>
</tr>
</table>
<P class="docText">Creates and returns an instance of class
<TT>OpenerDirector</TT>, covered later in this chapter,
with the given <TT><I>handlers</I></TT>. Each handler can
be a subclass of class <TT>BaseHandler</TT>, instantiable
without arguments, or an instance of such a subclass, however
instantiated. <TT>build_opener</TT> adds instances of
various handler classes provided by module <TT>urllib2</TT>
in front of the handlers you specify, to handle proxies, unknown
schemes, the <I>http</I>, <I>file</I>,
and <I>https</I> schemes, HTTP errors, and HTTP
redirects. However, if you have instances or subclasses of said
classes in <TT><I>handlers</I></TT>, this indicates that
you want to override these defaults.</P>

<A NAME="ch18-23-fm2xml"></A><A NAME="pythonian-CHP-18-ITERM-8050"></A><A NAME="pythonian-CHP-18-ITERM-8051"></A><table width="515" border="0" cellpadding="5">
<tr>
<td align="left"><b><i>install_opener</i></b></td>
<td align="right"></td>
</tr>
</table>
<hr width="515" size="3" noshade="true" align="left" color="black">
<table width="515" border="0" cellpadding="5">
<tr>
<td align="left">
<pre>install_opener(<TT><I>opener</I></TT>)</pre>
</td>
<td align="right"></td>
</tr>
</table>
<P class="docText">Installs <TT><I>opener</I></TT> as the opener for further
calls to <TT>urlopen</TT>.
<TT><I>opener</I></TT> can be an instance of class
<TT>OpenerDirector</TT>, such as the result of a call to
function <TT>build_opener</TT>, or any signature-compatible
object.</P>

<A NAME="ch18-24-fm2xml"></A><A NAME="pythonian-CHP-18-ITERM-8052"></A><A NAME="pythonian-CHP-18-ITERM-8053"></A><table width="515" border="0" cellpadding="5">
<tr>
<td align="left"><b><i>urlopen</i></b></td>
<td align="right"></td>
</tr>
</table>
<hr width="515" size="3" noshade="true" align="left" color="black">
<table width="515" border="0" cellpadding="5">
<tr>
<td align="left">
<pre>urlopen(<TT><I>url</I></TT>,<TT><I>data</I></TT>=None)</pre>
</td>
<td align="right"></td>
</tr>
</table>
<P class="docText">Almost identical to the <TT>urlopen</TT> function in module
<TT>urllib</TT>. However, you customize behavior via the
opener and handler classes of <TT>urllib2</TT>, covered
later in this chapter, rather than via class
<TT>FancyURLopener</TT> as in module
<TT>urllib</TT>. Argument <TT><I>url</I></TT>
can be a URL string, like for the <TT>urlopen</TT> function
in module <TT>urllib</TT>. Alternatively,
<TT><I>url</I></TT> can be an instance of class
<TT>Request</TT>, covered in the next section.</P>



<A NAME="pythonian-CHP-18-SECT-1.3.2"></A>
<H5 class="docSection3Title">18.1.3.2 The Request class</H5>

<P class="docText">You can optionally pass to function <TT>urlopen</TT> an
instance of class <TT>Request</TT> instead of a URL string.
Such an instance can embody both a URL and, optionally, other
information on how to access the target
URL.<A NAME="pythonian-CHP-18-ITERM-8054"></A> <A NAME="pythonian-CHP-18-ITERM-8055"></A> <A NAME="pythonian-CHP-18-ITERM-8056"></A></P>

<A NAME="ch18-25-fm2xml"></A><table width="515" border="0" cellpadding="5">
<tr>
<td align="left"><b><i>Request</i></b></td>
<td align="right"></td>
</tr>
</table>
<hr width="515" size="3" noshade="true" align="left" color="black">
<table width="515" border="0" cellpadding="5">
<tr>
<td align="left">
<pre>class Request(<TT><I>urlstring</I></TT>,<TT><I>data</I></TT>=None,<TT><I>headers</I></TT>={})</pre>
</td>
<td align="right"></td>
</tr>
</table>
<P class="docText"><TT><I>urlstring</I></TT> is the URL that this instance of
class <TT>Request</TT> embodies. For example, if there are
no <TT><I>data</I></TT> and
<TT><I>headers</I></TT>, calling:</P>
<PRE>urllib2.urlopen(urllib2.Request(<TT><I>urlstring</I></TT>))</PRE><P class="docText">is just like calling:</P>
<PRE>urllib2.urlopen(<TT><I>urlstring</I></TT>)</PRE><P class="docText">When <TT><I>data</I></TT> is not <TT>None</TT>,
the <TT>Request</TT> constructor implicitly calls on the
new instance <TT><I>r</I></TT> its method
<TT><I>r</I></TT><TT>.add_data(</TT><TT><I>data</I></TT><TT>)</TT>.
<TT><I>headers</I></TT> must be a mapping of header names
to header values. The <TT>Request</TT> constructor executes
the equivalent of the loop:</P>
<PRE>for <TT><I>k</I></TT>,<TT><I>v</I></TT> in <TT><I>headers</I></TT>.items(  ): <TT><I>r</I></TT>.add_header(<TT><I>k</I></TT>,<TT><I>v</I></TT>)</PRE>

<P class="docText">An instance <TT><I>r</I></TT> of class
<TT>Request</TT> supplies the following methods.</P>

<A NAME="ch18-26-fm2xml"></A><A NAME="pythonian-CHP-18-ITERM-8057"></A><A NAME="pythonian-CHP-18-ITERM-8058"></A><table width="515" border="0" cellpadding="5">
<tr>
<td align="left"><b><i>add_data</i></b></td>
<td align="right"></td>
</tr>
</table>
<hr width="515" size="3" noshade="true" align="left" color="black">
<table width="515" border="0" cellpadding="5">
<tr>
<td align="left">
<pre><TT><I>r</I></TT>.add_data(<TT><I>data</I></TT>)</pre>
</td>
<td align="right"></td>
</tr>
</table>
<P class="docText">Sets <TT><I>data</I></TT> as
<TT><I>r</I></TT>'s data. Calling
<TT>urlopen(</TT><TT><I>r</I></TT><TT>)</TT>
then becomes like calling
<TT>urlopen(</TT><TT><I>r</I></TT>,<TT><I>data</I></TT><TT>)</TT>,
i.e., it requires <TT><I>r</I></TT>'s
scheme to be <I>http</I>, and uses a POST request with
a body of <TT><I>data</I></TT>, which must be a
URL-encoded string.</P>
<P class="docText">Despite its name, method <TT>add_data</TT> does not
necessarily add the <TT><I>data</I></TT>. If
<TT><I>r</I></TT> already had data, set in
<TT><I>r</I></TT>'s constructor or by
previous calls to
<TT><I>r</I></TT><TT>.add_data</TT>, the latest
call to <TT><I>r</I></TT><TT>.add_data</TT>
replaces the previous value of
<TT><I>r</I></TT>'s data with the new
given one. In particular,
<TT><I>r</I></TT><TT>.add_data(None)</TT>
removes <TT><I>r</I></TT>'s previous
data, if any.</P>

<A NAME="ch18-27-fm2xml"></A><A NAME="pythonian-CHP-18-ITERM-8059"></A><A NAME="pythonian-CHP-18-ITERM-8060"></A><table width="515" border="0" cellpadding="5">
<tr>
<td align="left"><b><i>add_header</i></b></td>
<td align="right"></td>
</tr>
</table>
<hr width="515" size="3" noshade="true" align="left" color="black">
<table width="515" border="0" cellpadding="5">
<tr>
<td align="left">
<pre><TT><I>r</I></TT>.add_header(<TT><I>key</I></TT>,<TT><I>value</I></TT>)</pre>
</td>
<td align="right"></td>
</tr>
</table>
<P class="docText">Adds a header with the given <TT><I>key</I></TT> and
<TT><I>value</I></TT> to
<TT><I>r</I></TT>'s headers. If
<TT><I>r</I></TT>'s scheme is
<I>http</I>,
<TT><I>r</I></TT>'s headers are sent as
part of the request. When you add more than one header with the same
<TT><I>key</I></TT>, later additions overwrite previous
ones, so out of all headers with one given
<TT><I>key</I></TT>, only the one given last matters.</P>

<A NAME="ch18-28-fm2xml"></A><A NAME="pythonian-CHP-18-ITERM-8061"></A><A NAME="pythonian-CHP-18-ITERM-8062"></A><table width="515" border="0" cellpadding="5">
<tr>
<td align="left"><b><i>get_data</i></b></td>
<td align="right"></td>
</tr>
</table>
<hr width="515" size="3" noshade="true" align="left" color="black">
<table width="515" border="0" cellpadding="5">
<tr>
<td align="left">
<pre><TT><I>r</I></TT>.get_data(  )</pre>
</td>
<td align="right"></td>
</tr>
</table>
<P class="docText">Returns the data of <TT><I>r</I></TT>, either
<TT>None</TT> or a URL-encoded string.</P>

<A NAME="ch18-29-fm2xml"></A><A NAME="pythonian-CHP-18-ITERM-8063"></A><A NAME="pythonian-CHP-18-ITERM-8064"></A><table width="515" border="0" cellpadding="5">
<tr>
<td align="left"><b><i>get_full_url</i></b></td>
<td align="right"></td>
</tr>
</table>
<hr width="515" size="3" noshade="true" align="left" color="black">
<table width="515" border="0" cellpadding="5">
<tr>
<td align="left">
<pre><TT><I>r</I></TT>.get_full_url(  )</pre>
</td>
<td align="right"></td>
</tr>
</table>
<P class="docText">Returns the URL of <TT><I>r</I></TT>, as given in the
constructor for <TT><I>r</I></TT>.</P>

<A NAME="ch18-30-fm2xml"></A><A NAME="pythonian-CHP-18-ITERM-8065"></A><A NAME="pythonian-CHP-18-ITERM-8066"></A><table width="515" border="0" cellpadding="5">
<tr>
<td align="left"><b><i>get_host</i></b></td>
<td align="right"></td>
</tr>
</table>
<hr width="515" size="3" noshade="true" align="left" color="black">
<table width="515" border="0" cellpadding="5">
<tr>
<td align="left">
<pre><TT><I>r</I></TT>.get_host(  )</pre>
</td>
<td align="right"></td>
</tr>
</table>
<P class="docText">Returns the <TT>host</TT> component of
<TT><I>r</I></TT>'s URL.</P>

<A NAME="ch18-31-fm2xml"></A><A NAME="pythonian-CHP-18-ITERM-8067"></A><A NAME="pythonian-CHP-18-ITERM-8068"></A><table width="515" border="0" cellpadding="5">
<tr>
<td align="left"><b><i>get_selector</i></b></td>
<td align="right"></td>
</tr>
</table>
<hr width="515" size="3" noshade="true" align="left" color="black">
<table width="515" border="0" cellpadding="5">
<tr>
<td align="left">
<pre><TT><I>r</I></TT>.get_selector(  )</pre>
</td>
<td align="right"></td>
</tr>
</table>
<P class="docText">Returns the selector components of
<TT><I>r</I></TT>'s URL (i.e., the path
and all following components).</P>

<A NAME="ch18-32-fm2xml"></A><A NAME="pythonian-CHP-18-ITERM-8069"></A><A NAME="pythonian-CHP-18-ITERM-8070"></A><table width="515" border="0" cellpadding="5">
<tr>
<td align="left"><b><i>get_type</i></b></td>
<td align="right"></td>
</tr>
</table>
<hr width="515" size="3" noshade="true" align="left" color="black">
<table width="515" border="0" cellpadding="5">
<tr>
<td align="left">
<pre><TT><I>r</I></TT>.get_type(  )</pre>
</td>
<td align="right"></td>
</tr>
</table>
<P class="docText">Returns the scheme component of
<TT><I>r</I></TT>'s URL (i.e., the
protocol).</P>

<A NAME="ch18-33-fm2xml"></A><A NAME="pythonian-CHP-18-ITERM-8071"></A><A NAME="pythonian-CHP-18-ITERM-8072"></A><table width="515" border="0" cellpadding="5">
<tr>
<td align="left"><b><i>has_data</i></b></td>
<td align="right"></td>
</tr>
</table>
<hr width="515" size="3" noshade="true" align="left" color="black">
<table width="515" border="0" cellpadding="5">
<tr>
<td align="left">
<pre><TT><I>r</I></TT>.has_data(  )</pre>
</td>
<td align="right"></td>
</tr>
</table>
<P class="docText">Like <TT><I>r</I></TT><TT>.get_data( )</TT>
<TT>is</TT> <TT>not</TT> <TT>None</TT>.</P>

<A NAME="ch18-34-fm2xml"></A><A NAME="pythonian-CHP-18-ITERM-8073"></A><A NAME="pythonian-CHP-18-ITERM-8074"></A><table width="515" border="0" cellpadding="5">
<tr>
<td align="left"><b><i>set_proxy </i></b></td>
<td align="right"></td>
</tr>
</table>
<hr width="515" size="3" noshade="true" align="left" color="black">
<table width="515" border="0" cellpadding="5">
<tr>
<td align="left">
<pre><TT><I>r</I></TT>.set_proxy(<TT><I>host</I></TT>,<TT><I>scheme</I></TT>)</pre>
</td>
<td align="right"></td>
</tr>
</table>
<P class="docText">Sets <TT><I>r</I></TT> to use a proxy at the given
<TT><I>host</I></TT> and <TT><I>scheme</I></TT>
for accessing <TT><I>r</I></TT>'s URL.</P>



<A NAME="pythonian-CHP-18-SECT-1.3.3"></A>
<H5 class="docSection3Title">18.1.3.3 The OpenerDirector class</H5>

<P class="docText"><A NAME="pythonian-CHP-18-ITERM-8075"></A> <A NAME="pythonian-CHP-18-ITERM-8076"></A>
<A NAME="pythonian-CHP-18-ITERM-8077"></A>An
instance <TT><I>d</I></TT> of class
<TT>OpenerDirector</TT> collects instances of handler
classes and orchestrates their use to open URLs of various schemes
and to handle errors. Normally, you create
<TT><I>d</I></TT> by calling function
<TT>build_opener</TT>, and then install it by calling
function <TT>install_opener</TT>. For advanced uses, you
may also access various attributes and methods of
<TT><I>d</I></TT>, but this is a rare need and I do not
cover it further in this book.</P>



<A NAME="pythonian-CHP-18-SECT-1.3.4"></A>
<H5 class="docSection3Title">18.1.3.4 Handler classes</H5>

<P class="docText"><A NAME="pythonian-CHP-18-ITERM-8078"></A>
<A NAME="pythonian-CHP-18-ITERM-8079"></A> <A NAME="pythonian-CHP-18-ITERM-8080"></A>
<A NAME="pythonian-CHP-18-ITERM-8081"></A>
<A NAME="pythonian-CHP-18-ITERM-8082"></A>
<A NAME="pythonian-CHP-18-ITERM-8083"></A>
<A NAME="pythonian-CHP-18-ITERM-8084"></A>Module
<TT>urllib2</TT> supplies a class
<TT>BaseHandler</TT> to use as the superclass of any custom
handler classes you write. <TT>urllib2</TT> also supplies
many concrete subclasses of <TT>BaseHandler</TT> that
handle schemes <I>gopher</I>, <I>ftp</I>,
<I>http</I>, <I>https</I>, and
<I>file</I>, as well as authentication, proxies,
redirects, and errors. Writing custom handlers is an advanced topic
and I do not cover it further in this book.</P>



<A NAME="pythonian-CHP-18-SECT-1.3.5"></A>
<H5 class="docSection3Title">18.1.3.5 Handling authentication</H5>

<P class="docText"><TT>urllib2</TT><A NAME="pythonian-CHP-18-ITERM-8085"></A>
<A NAME="pythonian-CHP-18-ITERM-8086"></A>'s
default opener does not include authentication handlers. To get
authentication, call <TT>build_opener</TT> to build an
opener that includes instances of classes
<TT>HTTPBasicAuthHandler</TT>,
<TT>ProxyBasicAuthHandler</TT>,
<TT>HTTPDigestAuthHandler</TT>, and/or
<TT>ProxyDigestAuthHandler</TT>, depending on whether you
need the authentication to be directly in HTTP or to a proxy, and on
whether you need Basic or Digest authentication.</P>

<P class="docText"><A NAME="pythonian-CHP-18-ITERM-8087"></A> <A NAME="pythonian-CHP-18-ITERM-8088"></A> <A NAME="pythonian-CHP-18-ITERM-8089"></A> <A NAME="pythonian-CHP-18-ITERM-8090"></A>
<A NAME="pythonian-CHP-18-ITERM-8091"></A>To instantiate each of these
authentication handlers, use an instance <TT><I>x</I></TT>
of class <TT>HTTPPasswordMgrWithDefaultRealm</TT> as the
only argument to the authentication handler's
constructor. You normally use the same <TT><I>x</I></TT>
to instantiate all the authentication handlers you need. To record
users and passwords for given authentication realms and URLs, call
<TT><I>x</I></TT><TT>.add_password</TT> one or
more times.</P>

<A NAME="ch18-38-fm2xml"></A><A NAME="pythonian-CHP-18-ITERM-8092"></A><A NAME="pythonian-CHP-18-ITERM-8093"></A><A NAME="pythonian-CHP-18-ITERM-8094"></A><A NAME="pythonian-CHP-18-ITERM-8095"></A><A NAME="pythonian-CHP-18-ITERM-8096"></A><table width="515" border="0" cellpadding="5">
<tr>
<td align="left"><b><i>add_password</i></b></td>
<td align="right"></td>
</tr>
</table>
<hr width="515" size="3" noshade="true" align="left" color="black">
<table width="515" border="0" cellpadding="5">
<tr>
<td align="left">
<pre><TT><I>x</I></TT>.add_password(<TT><I>realm</I></TT>,<TT><I>URLs</I></TT>,<TT><I>user</I></TT>,<TT><I>password</I></TT>)</pre>
</td>
<td align="right"></td>
</tr>
</table>
<P class="docText"><A NAME="pythonian-CHP-18-ITERM-8092"></A>Records
in <TT><I>x</I></TT> the pair
<TT>(</TT><TT><I>user</I></TT>,<TT><I>password</I></TT><TT>)</TT>
as the authentication in the given <TT><I>realm</I></TT>
of applicable URLs, as determined by argument
<TT><I>URLs</I></TT>. <TT><I>realm</I></TT> is
either a string, the name of an authentication realm, or
<TT>None</TT>, to apply this authentication as the default
for any realm not specifically recorded.
<TT><I>URLs</I></TT> is a URL string or a sequence of URL
strings. A URL <TT><I>u</I></TT> is deemed applicable for
this authentication if there is an item <TT><I>u1</I></TT>
of <TT><I>URLs</I></TT> such that the
<TT>location</TT> components of
<TT><I>u</I></TT> and <TT><I>u1</I></TT> are
equal, and the <TT>path</TT> component of
<TT><I>u1</I></TT> is a prefix of that of
<TT><I>u</I></TT>. Note that other components (scheme,
query, and fragment) don't matter to applicability
for authentication purposes.</P>
<P class="docText">The following example shows how to use <TT>urllib2</TT>
with basic HTTP authentication:</P>
<PRE>import urllib2

x = urllib2.HTTPPasswordMgrWithDefaultRealm(  )
x.add_password(None, 'http://myhost.com/', 'auser',
               'apassword')
auth = urrlib2.HTTPBasicAuthHandler(x)
opener = urllib2.build_opener(auth)
urllib2.install_opener(opener)

flob = urllib2.urlopen('http://myhost.com/index.html')
for line in flob.readlines(  ): print line,</PRE>




<a href="0596001886_"><img src="FILES/pixel.gif" width="1" height="1" border="0"></a><ul></ul>
</td>
</tr>
</table>
<td></td>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<td class="tt1"><a href="NFO/lib.html">[ Team LiB ]</a></td><td valign="top" class="tt1" align="right">
          <a href="0596001886_pythonian-chp-18.html"><img src="FILES/previous.gif" width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a>
          <a href="0596001886_pythonian-chp-18-sect-2.html"><img src="FILES/next.gif" width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a>
</td></table>
</body></html>
