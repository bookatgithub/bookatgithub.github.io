<html><head>
<META http-equiv="Content-Type" content="text/html">
<!--SafClassName="docSection1Title"--><!--SafTocEntry="21.2 MIME and Email Format Handling"-->
<link rel="STYLESHEET" type="text/css" href="FILES/style.css">
<link rel="STYLESHEET" type="text/css" href="FILES/docsafari.css">
<style type="text/css">	.tt1    {font-size: 10pt;}</style>
</head>
<body>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<td class="tt1"><a href="NFO/lib.html">[ Team LiB ]</a></td><td valign="top" class="tt1" align="right">
	<a href="0596001886_pythonian-chp-21-sect-1.html"><img src="FILES/previous.gif" width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a>
	<a href="0596001886_pythonian-chp-22.html"><img src="FILES/next.gif" width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a>
</td></table>
<br>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<tr>
<td valign="top"><A NAME="pythonian-CHP-21-SECT-2"></A>
<H3 class="docSection1Title">21.2 MIME and Email Format Handling</H3>

<P class="docText"><A NAME="pythonian-CHP-21-ITERM-8731"></A> <A NAME="pythonian-CHP-21-ITERM-8732"></A>Python supplies the
<TT>email</TT> package to handle parsing, generation, and
manipulation of MIME files such as email messages, network news
posts, and so on. The Python standard library also contains other
modules that handle some parts of these jobs. However, the new
<TT>email</TT> package offers a more complete and
systematic approach to these important tasks. I therefore suggest you
use package <TT>email</TT>, not the older modules that
partially overlap with parts of
<TT>email</TT>'s functionality. Package
<TT>email</TT> has nothing to do with receiving or sending
email; for such tasks, see modules <TT>poplib</TT> and
<TT>smtplib</TT>, covered in <A class="docLink" HREF="0596001886_pythonian-chp-18.html#pythonian-CHP-18">Chapter 18</A>.
Instead, package <TT>email</TT> deals with how you handle
messages after you receive them or before you send
them.<A NAME="pythonian-CHP-21-ITERM-8733"></A></P>

<A NAME="pythonian-CHP-21-SECT-2.1"></A>
<H4 class="docSection2Title">21.2.1 Functions in Package email</H4>

<P class="docText">Package <TT>email</TT> supplies two factory functions
returning an instance <TT><I>m</I></TT> of class
<TT>email.Message.Message</TT>. These functions rely on
class <TT>email.Parser.Parser</TT>, but the factory
functions are handier and simpler. Therefore, I do not cover module
<TT>Parser</TT> further in this
book.<A NAME="pythonian-CHP-21-ITERM-8734"></A>
<A NAME="pythonian-CHP-21-ITERM-8735"></A> <A NAME="pythonian-CHP-21-ITERM-8736"></A></P>

<A NAME="ch21-18-fm2xml"></A><table width="515" border="0" cellpadding="5">
<tr>
<td align="left"><b><i>message_from_string</i></b></td>
<td align="right"></td>
</tr>
</table>
<hr width="515" size="3" noshade="true" align="left" color="black">
<table width="515" border="0" cellpadding="5">
<tr>
<td align="left">
<pre>message_from_string(<TT><I>s</I></TT>)</pre>
</td>
<td align="right"></td>
</tr>
</table>
<P class="docText">Builds <TT><I>m</I></TT> by parsing string
<TT><I>s</I></TT>.</P>

<A NAME="ch21-19-fm2xml"></A><A NAME="pythonian-CHP-21-ITERM-8737"></A><A NAME="pythonian-CHP-21-ITERM-8738"></A><table width="515" border="0" cellpadding="5">
<tr>
<td align="left"><b><i>message_from_file</i></b></td>
<td align="right"></td>
</tr>
</table>
<hr width="515" size="3" noshade="true" align="left" color="black">
<table width="515" border="0" cellpadding="5">
<tr>
<td align="left">
<pre>message_from_file(<TT><I>f</I></TT>)</pre>
</td>
<td align="right"></td>
</tr>
</table>
<P class="docText">Builds <TT><I>m</I></TT> by parsing the contents of
file-like object <TT><I>f</I></TT>, which must be open for
reading.</P>


<A NAME="pythonian-CHP-21-SECT-2.2"></A>
<H4 class="docSection2Title">21.2.2 The email.Message Module</H4>

<P class="docText"><A NAME="pythonian-CHP-21-ITERM-8739"></A> <A NAME="pythonian-CHP-21-ITERM-8740"></A>
<A NAME="pythonian-CHP-21-ITERM-8741"></A>
<A NAME="pythonian-CHP-21-ITERM-8742"></A>The <TT>email.Message</TT>
module supplies class <TT>Message</TT>. All parts of
package <TT>email</TT> produce, modify, or use instances of
class <TT>Message</TT>. An instance
<TT><I>m</I></TT> of <TT>Message</TT> models a
MIME message, including headers and a payload (data content). You can
create <TT><I>m</I></TT>, initially empty, by calling
class <TT>Message</TT>, which accepts no arguments. More
often, you create <TT><I>m</I></TT> by parsing via
functions <TT>message_from_string</TT> and
<TT>message_from_file</TT> of module
<TT>email</TT>, or by other indirect means such as the
classes covered in "Creating
Messages" later in this chapter.
<TT><I>m</I></TT>'s payload can be a
string, a single other instance of <TT>Message</TT>, or a
list of other <TT>Message</TT> instances for a multipart
message.</P>

<P class="docText">You can set arbitrary headers on email messages
you're building. Several Internet RFCs specify
headers that you can use for a wide variety of purposes. The main
applicable RFC is RFC 2822 (see <A class="docLink" target="_blank" HREF="http://www.faqs.org/rfcs/rfc2822.html">http://www.faqs.org/rfcs/rfc2822.html</A>). An
instance <TT><I>m</I></TT> of class
<TT>Message</TT> holds headers as well as a payload.
<TT><I>m</I></TT> is a mapping, with header names as keys
and header value strings as values. The semantics of
<TT><I>m</I></TT> as a mapping are rather different from
those of a dictionary, to make <TT><I>m</I></TT> more
convenient. <TT><I>m</I></TT>'s keys are
case-insensitive. <TT><I>m</I></TT> keeps headers in the
order in which you add them, and methods <TT>keys</TT>,
<TT>values</TT>, and <TT>items</TT> return
headers in that order. <TT><I>m</I></TT> can have more
than one header named
<TT><I>key</I></TT>—<TT><I>m</I></TT><TT>[</TT><TT><I>key</I></TT><TT>]</TT>
returns an arbitrary one of them, <TT>del</TT>
<TT><I>m</I></TT><TT>[</TT><TT><I>key</I></TT><TT>]</TT>
deletes all of them.
<TT>len(</TT><TT><I>m</I></TT><TT>)</TT>
returns the total number of headers, counting duplicates, not just
the number of distinct header names. If there is no header named
<TT><I>key</I></TT>,
<TT><I>m</I></TT><TT>[</TT><TT><I>key</I></TT><TT>]</TT>
returns <TT>None</TT> and does not raise
<TT>KeyError</TT> (i.e., behaves like
<TT><I>m</I></TT><TT>.get(</TT><TT><I>key</I></TT><TT>)</TT>),
and <TT>del</TT>
<TT><I>m</I></TT><TT>[</TT><TT><I>key</I></TT><TT>]</TT>
is a no-operation.</P>

<P class="docText">An instance <TT><I>m</I></TT> of
<TT>Message</TT> supplies the following attributes and
methods dealing with <TT><I>m</I></TT>'s
headers and payload.</P>

<A NAME="ch21-21-fm2xml"></A><A NAME="pythonian-CHP-21-ITERM-8743"></A><A NAME="pythonian-CHP-21-ITERM-8744"></A><table width="515" border="0" cellpadding="5">
<tr>
<td align="left"><b><i>add_header</i></b></td>
<td align="right"></td>
</tr>
</table>
<hr width="515" size="3" noshade="true" align="left" color="black">
<table width="515" border="0" cellpadding="5">
<tr>
<td align="left">
<pre><TT><I>m</I></TT>.add_header(<TT><I>_name</I></TT>,<TT><I>_value</I></TT>,**<TT><I>_params</I></TT>)</pre>
</td>
<td align="right"></td>
</tr>
</table>
<P class="docText">Like
<TT><I>m</I></TT><TT>[</TT><TT><I>_name</I></TT><TT>]=</TT><TT><I>_value</I></TT>,
but you can also supply header parameters as keyword arguments. For
each keyword argument
<TT><I>pname</I></TT><TT>=</TT><TT><I>pvalue</I></TT>,
<TT>add_header</TT> changes underscores to dashes, then
appends to the header's value a parameter of the
form:</P>
<PRE>; <TT><I>pname</I></TT>="<TT><I>pvalue</I></TT>"</PRE><P class="docText">If <TT><I>pvalue</I></TT> is <TT>None</TT>,
<TT>add_header</TT> appends only a parameter
'<TT>;</TT>
<TT><I>pname</I></TT>'.</P>

<A NAME="ch21-22-fm2xml"></A><A NAME="pythonian-CHP-21-ITERM-8745"></A><A NAME="pythonian-CHP-21-ITERM-8746"></A><table width="515" border="0" cellpadding="5">
<tr>
<td align="left"><b><i>add_payload</i></b></td>
<td align="right"></td>
</tr>
</table>
<hr width="515" size="3" noshade="true" align="left" color="black">
<table width="515" border="0" cellpadding="5">
<tr>
<td align="left">
<pre><TT><I>m</I></TT>.add_payload(<TT><I>payload</I></TT>)</pre>
</td>
<td align="right"></td>
</tr>
</table>
<P class="docText">Adds the <TT><I>payload</I></TT> to
<TT><I>m</I></TT>'s payload. If
<TT><I>m</I></TT>'s payload was
<TT>None</TT>,
<TT><I>m</I></TT>'s payload is now
<TT><I>payload</I></TT>. If
<TT><I>m</I></TT>'s payload was a list,
appends <TT><I>payload</I></TT> to the list. If
<TT><I>m</I></TT>'s payload was a single
item <TT><I>x</I></TT>,
<TT><I>m</I></TT>'s payload becomes the
list
<TT>[</TT><TT><I>x</I></TT>,<TT><I>payload</I></TT><TT>]</TT>,
but only if <TT><I>m</I></TT>'s
Content-Type header is missing or has a main type of
<TT>multipart</TT>. Otherwise, when
<TT><I>m</I></TT> has a single payload and a Content-Type
whose main type is not <TT>multipart</TT>,
<TT><I>m</I></TT><TT>.add_payload(</TT><TT><I>payload</I></TT><TT>)</TT>
raises a <TT>MultipartConversionError</TT> exception.</P>

<A NAME="ch21-23-fm2xml"></A><A NAME="pythonian-CHP-21-ITERM-8747"></A><A NAME="pythonian-CHP-21-ITERM-8748"></A><table width="515" border="0" cellpadding="5">
<tr>
<td align="left"><b><i>as_string</i></b></td>
<td align="right"></td>
</tr>
</table>
<hr width="515" size="3" noshade="true" align="left" color="black">
<table width="515" border="0" cellpadding="5">
<tr>
<td align="left">
<pre><TT><I>m</I></TT>.as_string(<TT><I>unixfrom</I></TT>=False)</pre>
</td>
<td align="right"></td>
</tr>
</table>
<P class="docText">Returns the entire message as a string. When
<TT><I>unixfrom</I></TT> is true, also includes a first
line, normally starting with '<TT>From </TT>', known as the
envelope header of the message.</P>

<A NAME="ch21-24-fm2xml"></A><A NAME="pythonian-CHP-21-ITERM-8749"></A><A NAME="pythonian-CHP-21-ITERM-8750"></A><table width="515" border="0" cellpadding="5">
<tr>
<td align="left"><b><i>epilogue</i></b></td>
<td align="right"></td>
</tr>
</table>
<hr width="515" size="3" noshade="true" align="left" color="black">
<table width="515" border="0" cellpadding="5">
<tr>
<td align="left"></td>
<td align="right"></td>
</tr>
</table>
<P class="docText"><A NAME="pythonian-CHP-21-ITERM-8749"></A> <A NAME="pythonian-CHP-21-ITERM-8750"></A>Attribute
<TT><I>m</I></TT><TT>.epilogue</TT> can be
<TT>None</TT>, or a string that becomes part of the
message's string form after the last boundary line.
Mail programs normally don't display this text.
<TT>epilogue</TT> is a normal attribute of
<TT><I>m</I></TT>: your program can access it when
you're examining an <TT><I>m</I></TT>
that is fully built by whatever means, and your program can bind it
when you're building or modifying
<TT><I>m</I></TT> in your program.</P>

<A NAME="ch21-25-fm2xml"></A><A NAME="pythonian-CHP-21-ITERM-8751"></A><A NAME="pythonian-CHP-21-ITERM-8752"></A><table width="515" border="0" cellpadding="5">
<tr>
<td align="left"><b><i>get_all</i></b></td>
<td align="right"></td>
</tr>
</table>
<hr width="515" size="3" noshade="true" align="left" color="black">
<table width="515" border="0" cellpadding="5">
<tr>
<td align="left">
<pre><TT><I>m</I></TT>.get_all(<TT><I>name</I></TT>,<TT><I>default</I></TT>=None)</pre>
</td>
<td align="right"></td>
</tr>
</table>
<P class="docText">Returns a list with all values of headers named
<TT><I>name</I></TT>, in the order in which the headers
were added to <TT><I>m</I></TT>. When
<TT><I>m</I></TT> has no header named
<TT><I>name</I></TT>, <TT>get_all</TT> returns
<TT><I>default</I></TT>.</P>

<A NAME="ch21-26-fm2xml"></A><A NAME="pythonian-CHP-21-ITERM-8753"></A><A NAME="pythonian-CHP-21-ITERM-8754"></A><table width="515" border="0" cellpadding="5">
<tr>
<td align="left"><b><i>get_boundary</i></b></td>
<td align="right"></td>
</tr>
</table>
<hr width="515" size="3" noshade="true" align="left" color="black">
<table width="515" border="0" cellpadding="5">
<tr>
<td align="left">
<pre><TT><I>m</I></TT>.get_boundary(<TT><I>default</I></TT>=None)</pre>
</td>
<td align="right"></td>
</tr>
</table>
<P class="docText"><A NAME="pythonian-CHP-21-ITERM-8753"></A> <A NAME="pythonian-CHP-21-ITERM-8754"></A>Returns the string value of the
<TT>boundary</TT> parameter of
<TT><I>m</I></TT>'s Content-Type header.
When <TT><I>m</I></TT> has no Content-Type header, or the
header has no <TT>boundary</TT> parameter,
<TT>get_boundary</TT> returns
<TT><I>default</I></TT>.</P>

<A NAME="ch21-27-fm2xml"></A><A NAME="pythonian-CHP-21-ITERM-8755"></A><A NAME="pythonian-CHP-21-ITERM-8756"></A><table width="515" border="0" cellpadding="5">
<tr>
<td align="left"><b><i>get_charsets</i></b></td>
<td align="right"></td>
</tr>
</table>
<hr width="515" size="3" noshade="true" align="left" color="black">
<table width="515" border="0" cellpadding="5">
<tr>
<td align="left">
<pre><TT><I>m</I></TT>.get_charsets(<TT><I>default</I></TT>=None)</pre>
</td>
<td align="right"></td>
</tr>
</table>
<P class="docText">Returns the list <TT><I>L</I></TT> of string values of
parameter <TT>charset</TT> of
<TT><I>m</I></TT>'s Content-Type headers.
When <TT><I>m</I></TT> is multipart,
<TT><I>L</I></TT> has one item per part, otherwise
<TT><I>L</I></TT> has length 1. For parts that have no
Content-Type, no <TT>charset</TT> parameter, or a main type
different from '<TT>text</TT>', the corresponding item in
<TT><I>L</I></TT> is <TT><I>default</I></TT>.</P>

<A NAME="ch21-28-fm2xml"></A><A NAME="pythonian-CHP-21-ITERM-8757"></A><A NAME="pythonian-CHP-21-ITERM-8758"></A><table width="515" border="0" cellpadding="5">
<tr>
<td align="left"><b><i>get_filename</i></b></td>
<td align="right"></td>
</tr>
</table>
<hr width="515" size="3" noshade="true" align="left" color="black">
<table width="515" border="0" cellpadding="5">
<tr>
<td align="left">
<pre><TT><I>m</I></TT>.get_filename(<TT><I>default</I></TT>=None)</pre>
</td>
<td align="right"></td>
</tr>
</table>
<P class="docText">Returns the string value of the <TT>filename</TT> parameter
of <TT><I>m</I></TT>'s
Content-Disposition header. When <TT><I>m</I></TT> has no
Content-Disposition, or the header has no <TT>filename</TT>
parameter, <TT>get_filename</TT> returns
<TT><I>default</I></TT>.</P>

<A NAME="ch21-29-fm2xml"></A><A NAME="pythonian-CHP-21-ITERM-8759"></A><A NAME="pythonian-CHP-21-ITERM-8760"></A><table width="515" border="0" cellpadding="5">
<tr>
<td align="left"><b><i>get_maintype</i></b></td>
<td align="right"></td>
</tr>
</table>
<hr width="515" size="3" noshade="true" align="left" color="black">
<table width="515" border="0" cellpadding="5">
<tr>
<td align="left">
<pre><TT><I>m</I></TT>.get_maintype(<TT><I>default</I></TT>=None)</pre>
</td>
<td align="right"></td>
</tr>
</table>
<P class="docText">Returns <TT><I>m</I></TT>'s main content
type, a string
'<TT><I>maintype</I></TT>'
taken from header Content-Type converted to lowercase. When
<TT><I>m</I></TT> has no header Content-Type,
<TT>get_maintype</TT> returns
<TT><I>default</I></TT>.</P>

<A NAME="ch21-30-fm2xml"></A><A NAME="pythonian-CHP-21-ITERM-8761"></A><A NAME="pythonian-CHP-21-ITERM-8762"></A><table width="515" border="0" cellpadding="5">
<tr>
<td align="left"><b><i>get_param</i></b></td>
<td align="right"></td>
</tr>
</table>
<hr width="515" size="3" noshade="true" align="left" color="black">
<table width="515" border="0" cellpadding="5">
<tr>
<td align="left">
<pre><TT><I>m</I></TT>.get_param(<TT><I>param</I></TT>,<TT><I>default</I></TT>=None,<TT><I>header</I></TT>='Content-Type')</pre>
</td>
<td align="right"></td>
</tr>
</table>
<P class="docText">Returns the string value of the parameter named
<TT><I>param</I></TT> of
<TT><I>m</I></TT>'s header named
<TT><I>header</I></TT>. Returns the empty string for a
parameter specified just by name. When <TT><I>m</I></TT>
has no header <TT><I>header</I></TT>, or the header has no
parameter named <TT><I>param</I></TT>,
<TT>get_param</TT> returns
<TT><I>default</I></TT>.</P>

<A NAME="ch21-31-fm2xml"></A><table width="515" border="0" cellpadding="5">
<tr>
<td align="left"><b><i>get_params</i></b></td>
<td align="right"></td>
</tr>
</table>
<hr width="515" size="3" noshade="true" align="left" color="black">
<table width="515" border="0" cellpadding="5">
<tr>
<td align="left">
<pre><TT><I>m</I></TT>.get_params(<TT><I>default</I></TT>=None,<TT><I>header</I></TT>='Content-Type')</pre>
</td>
<td align="right"></td>
</tr>
</table>
<P class="docText">Returns the parameters of
<TT><I>m</I></TT>'s header named
<TT><I>header</I></TT>, a list of pairs of strings giving
each parameter's name and value. Uses the empty
string as the value for parameters specified just by name. When
<TT><I>m</I></TT> has no header
<TT><I>header</I></TT>, <TT>get_params</TT>
returns <TT><I>default</I></TT>.</P>

<A NAME="ch21-32-fm2xml"></A><A NAME="pythonian-CHP-21-ITERM-8763"></A><A NAME="pythonian-CHP-21-ITERM-8764"></A><table width="515" border="0" cellpadding="5">
<tr>
<td align="left"><b><i>get_payload</i></b></td>
<td align="right"></td>
</tr>
</table>
<hr width="515" size="3" noshade="true" align="left" color="black">
<table width="515" border="0" cellpadding="5">
<tr>
<td align="left">
<pre><TT><I>m</I></TT>.get_payload(<TT><I>i</I></TT>=None,<TT><I>decode</I></TT>=False)</pre>
</td>
<td align="right"></td>
</tr>
</table>
<P class="docText">Returns <TT><I>m</I></TT>'s payload. When
<TT><I>m</I></TT><TT>.is_multipart( )</TT> is
<TT>False</TT>, <TT><I>i</I></TT> must be
<TT>None</TT>, and
<TT><I>m</I></TT><TT>.get_payload( )</TT>
returns <TT><I>m</I></TT>'s entire
payload, a string or a <TT>Message</TT> instance. If
<TT><I>decode</I></TT> is true, and the value of header
Content-Transfer-Encoding is either
'<TT>quoted-printable</TT>' or '<TT>base64</TT>',
<TT><I>m</I></TT><TT>.get_payload</TT> also
decodes the payload. If <TT><I>decode</I></TT> is false,
or header Content-Transfer-Encoding is missing or has other values,
<TT><I>m</I></TT><TT>.get_payload</TT> returns
the payload unchanged.</P>
<P class="docText">When <TT><I>m</I></TT><TT>.is_multipart( )</TT>
is <TT>True</TT>, <TT><I>decode</I></TT> must be
<TT>false</TT>. When <TT><I>i</I></TT> is
<TT>None</TT>,
<TT><I>m</I></TT><TT>.get_payload( )</TT>
returns <TT><I>m</I></TT>'s payload as a
list. Otherwise, <TT><I>m</I></TT><TT>.get_payload(
)</TT> returns the <TT><I>i</I></TT>th item of the
payload, and raises <TT>TypeError</TT> if
<TT><I>i</I></TT> is less than <TT>0</TT> or is
too large.</P>

<A NAME="ch21-33-fm2xml"></A><A NAME="pythonian-CHP-21-ITERM-8765"></A><A NAME="pythonian-CHP-21-ITERM-8766"></A><table width="515" border="0" cellpadding="5">
<tr>
<td align="left"><b><i>get_subtype</i></b></td>
<td align="right"></td>
</tr>
</table>
<hr width="515" size="3" noshade="true" align="left" color="black">
<table width="515" border="0" cellpadding="5">
<tr>
<td align="left">
<pre><TT><I>m</I></TT>.get_subtype(<TT><I>default</I></TT>=None)</pre>
</td>
<td align="right"></td>
</tr>
</table>
<P class="docText">Returns <TT><I>m</I></TT>'s content
subtype, a string
'<TT><I>subtype</I></TT>'
taken from header Content-Type converted to lowercase. When
<TT><I>m</I></TT> has no header Content-Type,
<TT>get_subtype</TT> returns
<TT><I>default</I></TT>.</P>

<A NAME="ch21-34-fm2xml"></A><A NAME="pythonian-CHP-21-ITERM-8767"></A><A NAME="pythonian-CHP-21-ITERM-8768"></A><table width="515" border="0" cellpadding="5">
<tr>
<td align="left"><b><i>get_type</i></b></td>
<td align="right"></td>
</tr>
</table>
<hr width="515" size="3" noshade="true" align="left" color="black">
<table width="515" border="0" cellpadding="5">
<tr>
<td align="left">
<pre><TT><I>m</I></TT>.get_type(<TT><I>default</I></TT>=None)</pre>
</td>
<td align="right"></td>
</tr>
</table>
<P class="docText">Returns <TT><I>m</I></TT>'s content type,
a string
'<TT><I>maintype</I></TT><TT>/</TT><TT><I>subtype</I></TT>'
taken from header Content-Type converted to lowercase. When
<TT><I>m</I></TT> has no header Content-Type,
<TT>get_type</TT> returns
<TT><I>default</I></TT>.</P>

<A NAME="ch21-35-fm2xml"></A><A NAME="pythonian-CHP-21-ITERM-8769"></A><A NAME="pythonian-CHP-21-ITERM-8770"></A><table width="515" border="0" cellpadding="5">
<tr>
<td align="left"><b><i>get_unixfrom</i></b></td>
<td align="right"></td>
</tr>
</table>
<hr width="515" size="3" noshade="true" align="left" color="black">
<table width="515" border="0" cellpadding="5">
<tr>
<td align="left">
<pre><TT><I>m</I></TT>.get_unixfrom(  )</pre>
</td>
<td align="right"></td>
</tr>
</table>
<P class="docText">Returns the envelope header string for <TT><I>m</I></TT>,
or <TT>None</TT> if the envelope header was never set.</P>

<A NAME="ch21-36-fm2xml"></A><A NAME="pythonian-CHP-21-ITERM-8771"></A><A NAME="pythonian-CHP-21-ITERM-8772"></A><table width="515" border="0" cellpadding="5">
<tr>
<td align="left"><b><i>is_multipart</i></b></td>
<td align="right"></td>
</tr>
</table>
<hr width="515" size="3" noshade="true" align="left" color="black">
<table width="515" border="0" cellpadding="5">
<tr>
<td align="left">
<pre><TT><I>m</I></TT>.is_multipart(  )</pre>
</td>
<td align="right"></td>
</tr>
</table>
<P class="docText">Returns <TT>True</TT> when
<TT><I>m</I></TT>'s payload is a list,
otherwise <TT>False</TT>.</P>

<A NAME="ch21-37-fm2xml"></A><A NAME="pythonian-CHP-21-ITERM-8773"></A><A NAME="pythonian-CHP-21-ITERM-8774"></A><table width="515" border="0" cellpadding="5">
<tr>
<td align="left"><b><i>preamble</i></b></td>
<td align="right"></td>
</tr>
</table>
<hr width="515" size="3" noshade="true" align="left" color="black">
<table width="515" border="0" cellpadding="5">
<tr>
<td align="left"></td>
<td align="right"></td>
</tr>
</table>
<P class="docText"><A NAME="pythonian-CHP-21-ITERM-8773"></A> <A NAME="pythonian-CHP-21-ITERM-8774"></A>Attribute
<TT><I>m</I></TT><TT>.preamble</TT> can be
<TT>None</TT> or a string that becomes part of the
message's string form before the first boundary
line. Only mail programs that don't support
multipart messages display this text to the user, so you can use this
attribute to alert the user that your message is multipart and that a
different mail program is needed to view it.
<TT>preamble</TT> is a normal attribute of
<TT><I>m</I></TT>: your program can access it when
you're examining an <TT><I>m</I></TT>
that is fully built by whatever means, and your program can bind it
when you're building or modifying
<TT><I>m</I></TT> in your program.</P>

<A NAME="ch21-38-fm2xml"></A><A NAME="pythonian-CHP-21-ITERM-8775"></A><A NAME="pythonian-CHP-21-ITERM-8776"></A><table width="515" border="0" cellpadding="5">
<tr>
<td align="left"><b><i>set_boundary</i></b></td>
<td align="right"></td>
</tr>
</table>
<hr width="515" size="3" noshade="true" align="left" color="black">
<table width="515" border="0" cellpadding="5">
<tr>
<td align="left">
<pre><TT><I>m</I></TT>.set_boundary(<TT><I>boundary</I></TT>)</pre>
</td>
<td align="right"></td>
</tr>
</table>
<P class="docText">Sets the <TT>boundary</TT> parameter of
<TT><I>m</I></TT>'s Content-Type header
to <TT><I>boundary</I></TT>. When
<TT><I>m</I></TT> has no Content-Type header, raises
<TT>HeaderParseError</TT>.</P>

<A NAME="ch21-39-fm2xml"></A><A NAME="pythonian-CHP-21-ITERM-8777"></A><A NAME="pythonian-CHP-21-ITERM-8778"></A><table width="515" border="0" cellpadding="5">
<tr>
<td align="left"><b><i>set_payload</i></b></td>
<td align="right"></td>
</tr>
</table>
<hr width="515" size="3" noshade="true" align="left" color="black">
<table width="515" border="0" cellpadding="5">
<tr>
<td align="left">
<pre><TT><I>m</I></TT>.set_payload(<TT><I>payload</I></TT>)</pre>
</td>
<td align="right"></td>
</tr>
</table>
<P class="docText">Sets <TT><I>m</I></TT>'s payload to
<TT><I>payload</I></TT>, which must be a string or list,
as appropriate.</P>

<A NAME="ch21-40-fm2xml"></A><A NAME="pythonian-CHP-21-ITERM-8779"></A><A NAME="pythonian-CHP-21-ITERM-8780"></A><table width="515" border="0" cellpadding="5">
<tr>
<td align="left"><b><i>set_unixfrom</i></b></td>
<td align="right"></td>
</tr>
</table>
<hr width="515" size="3" noshade="true" align="left" color="black">
<table width="515" border="0" cellpadding="5">
<tr>
<td align="left">
<pre><TT><I>m</I></TT>.set_unixfrom(<TT><I>unixfrom</I></TT>)</pre>
</td>
<td align="right"></td>
</tr>
</table>
<P class="docText">Sets the envelope header string for <TT><I>m</I></TT>.
<TT><I>unixfrom</I></TT> is the entire envelope header
line, including the leading '<TT>From </TT>' but not
including the trailing '<TT>\n</TT>'.</P>

<A NAME="ch21-41-fm2xml"></A><A NAME="pythonian-CHP-21-ITERM-8781"></A><A NAME="pythonian-CHP-21-ITERM-8782"></A><A NAME="pythonian-CHP-21-ITERM-8783"></A><A NAME="pythonian-CHP-21-ITERM-8784"></A><table width="515" border="0" cellpadding="5">
<tr>
<td align="left"><b><i>walk</i></b></td>
<td align="right"></td>
</tr>
</table>
<hr width="515" size="3" noshade="true" align="left" color="black">
<table width="515" border="0" cellpadding="5">
<tr>
<td align="left">
<pre><TT><I>m</I></TT>.walk(  )</pre>
</td>
<td align="right"></td>
</tr>
</table>
<P class="docText">Returns an iterator on all parts and subparts of
<TT><I>m</I></TT>, to walk the tree of parts
depth-first.<A NAME="pythonian-CHP-21-ITERM-8783"></A> <A NAME="pythonian-CHP-21-ITERM-8784"></A></P>


<A NAME="pythonian-CHP-21-SECT-2.3"></A>
<H4 class="docSection2Title">21.2.3 The email.Generator Module</H4>

<P class="docText"><A NAME="pythonian-CHP-21-ITERM-8785"></A> <A NAME="pythonian-CHP-21-ITERM-8786"></A>The <TT>email.Generator</TT>
module supplies class <TT>Generator</TT>, which you can use
to generate the textual form of a message
<TT><I>m</I></TT>.
<TT><I>m</I></TT><TT>.as_string</TT> and
<TT>str(</TT><TT><I>m</I></TT><TT>)</TT>
may be sufficient, but class <TT>Generator</TT> gives you
slightly more flexibility. You instantiate
<TT>Generator</TT> with a mandatory argument and two
optional ones.</P>

<A NAME="ch21-43-fm2xml"></A><A NAME="pythonian-CHP-21-ITERM-8787"></A><table width="515" border="0" cellpadding="5">
<tr>
<td align="left"><b><i>Generator</i></b></td>
<td align="right"></td>
</tr>
</table>
<hr width="515" size="3" noshade="true" align="left" color="black">
<table width="515" border="0" cellpadding="5">
<tr>
<td align="left">
<pre>class Generator(<TT><I>outfp</I></TT>,<TT><I>mangle_from_</I></TT>=False,<TT><I>maxheaderlen</I></TT>=78)</pre>
</td>
<td align="right"></td>
</tr>
</table>
<P class="docText"><TT><I>outfp</I></TT> is a file or file-like object
supplying method <TT>write</TT>. When
<TT><I>mangle_from_</I></TT> is true,
<TT><I>g</I></TT> prepends a '<TT>&gt;</TT>' to
any line in a message's payload that starts with
'<TT>From </TT>' This helps make the
message's textual form more safely parseable.
<TT><I>g</I></TT> wraps each header line at semicolons,
into physical lines of no more than
<TT><I>maxheaderlen</I></TT> characters, for readability.
To use <TT><I>g</I></TT>, just call it:</P>
<PRE><TT><I>g</I></TT>(<TT><I>m</I></TT>, <TT><I>unixfrom</I></TT>=False)</PRE><P class="docText">This emits <TT><I>m</I></TT> in text form to
<TT><I>outfp</I></TT>, like
<TT><I>outfp</I></TT><TT>.write(</TT><TT><I>m</I></TT><TT>.as_string(</TT><TT><I>unixfrom</I></TT><TT>))</TT>.</P>


<A NAME="pythonian-CHP-21-SECT-2.4"></A>
<H4 class="docSection2Title">21.2.4 Creating Messages</H4>

<P class="docText">Package <TT>email</TT> supplies modules with names starting
with '<TT>MIME</TT>', each module supplying a subclass of
<TT>Message</TT> named like the module. These classes make
it easier to create <TT>Message</TT> instances of various
MIME types. The MIME classes are as follows.</P>

<A NAME="ch21-45-fm2xml"></A><A NAME="pythonian-CHP-21-ITERM-8788"></A><table width="515" border="0" cellpadding="5">
<tr>
<td align="left"><b><i>MIMEAudio</i></b></td>
<td align="right"></td>
</tr>
</table>
<hr width="515" size="3" noshade="true" align="left" color="black">
<table width="515" border="0" cellpadding="5">
<tr>
<td align="left">
<pre>class MIMEAudio(<TT><I>_audiodata</I></TT>,<TT><I>_subtype</I></TT>=None,<TT><I>_encoder</I></TT>=None,**<TT><I>_params</I></TT>)</pre>
</td>
<td align="right"></td>
</tr>
</table>
<P class="docText"><TT><I>_audiodata</I></TT> is a byte
string of audio data to pack in a message of MIME type
'<TT>audio/</TT><TT><I>_subtype</I></TT>'.
When <TT><I>_subtype</I></TT> is <TT>None</TT>,
<TT><I>_audiodata</I></TT> must be parseable by standard
Python module <TT>sndhdr</TT> to determine the subtype;
otherwise <TT>MIMEAudio</TT> raises a
<TT>TypeError</TT>. When
<TT><I>_encoder</I></TT> is <TT>None</TT>,
<TT>MIMEAudio</TT> encodes data as Base 64, which is
generally optimal. Otherwise, <TT><I>_encoder</I></TT>
must be callable with one parameter <TT><I>m</I></TT>, the
message being constructed; <TT><I>_encoder</I></TT> must
then call <TT><I>m</I></TT><TT>.get_payload(
)</TT> to get the payload, encode the payload, put the encoded
form back by calling
<TT><I>m</I></TT><TT>.set_payload</TT>, and set
<TT><I>m</I></TT><TT>['Content-Transfer-Encoding']</TT>
appropriately. <TT>MIMEAudio</TT> passes the
<TT><I>_params</I></TT> dictionary of keyword argument
names and values to
<TT><I>m</I></TT><TT>.add_header</TT> to
construct <TT><I>m</I></TT>'s
<TT>Content-Type</TT>.</P>

<A NAME="ch21-46-fm2xml"></A><A NAME="pythonian-CHP-21-ITERM-8789"></A><table width="515" border="0" cellpadding="5">
<tr>
<td align="left"><b><i>MIMEBase</i></b></td>
<td align="right"></td>
</tr>
</table>
<hr width="515" size="3" noshade="true" align="left" color="black">
<table width="515" border="0" cellpadding="5">
<tr>
<td align="left">
<pre>class MIMEBase(<TT><I>_maintype</I></TT>,<TT><I>_subtype</I></TT>,**<TT><I>_params</I></TT>)</pre>
</td>
<td align="right"></td>
</tr>
</table>
<P class="docText">The base class of all MIME classes; directly subclasses
<TT>Message</TT>. Instantiating:</P>
<PRE><TT><I>m</I></TT> = MIMEBase(<TT><I>main</I></TT>,<TT><I>sub</I></TT>,**<TT><I>parms</I></TT>)</PRE><P class="docText">is equivalent to the longer and less convenient idiom:</P>
<PRE><TT><I>m</I></TT> = Message(  )
<TT><I>m</I></TT>.add_header('Content-Type','%s/%s'%(<TT><I>main</I></TT>,<TT><I>sub</I></TT>),**<TT><I>parms</I></TT>)
<TT><I>m</I></TT>.add_header('Mime-Version','1.0')</PRE>

<A NAME="ch21-47-fm2xml"></A><A NAME="pythonian-CHP-21-ITERM-8790"></A><table width="515" border="0" cellpadding="5">
<tr>
<td align="left"><b><i>MIMEImage</i></b></td>
<td align="right"></td>
</tr>
</table>
<hr width="515" size="3" noshade="true" align="left" color="black">
<table width="515" border="0" cellpadding="5">
<tr>
<td align="left">
<pre>class MIMEAudio(<TT><I>_imagedata</I></TT>,<TT><I>_subtype</I></TT>=None,<TT><I>_encoder</I></TT>=None,**<TT><I>_params</I></TT>)</pre>
</td>
<td align="right"></td>
</tr>
</table>
<P class="docText">Like <TT>MIMEAudio</TT>, but with maintype
'<TT>image</TT>' and using standard Python module
<TT>imghdr</TT> to determine the subtype if needed.</P>

<A NAME="ch21-48-fm2xml"></A><A NAME="pythonian-CHP-21-ITERM-8791"></A><table width="515" border="0" cellpadding="5">
<tr>
<td align="left"><b><i>MIMEMessage</i></b></td>
<td align="right"></td>
</tr>
</table>
<hr width="515" size="3" noshade="true" align="left" color="black">
<table width="515" border="0" cellpadding="5">
<tr>
<td align="left">
<pre>class MIMEMessage(<TT><I>msg</I></TT>,<TT><I>_subtype</I></TT>='rfc822')</pre>
</td>
<td align="right"></td>
</tr>
</table>
<P class="docText">Packs <TT><I>msg</I></TT>, which must be an instance of
<TT>Message</TT> (or a subclass), as the payload of a
message of MIME type
'<TT>message/</TT><TT><I>_subtype</I></TT>'.</P>

<A NAME="ch21-49-fm2xml"></A><A NAME="pythonian-CHP-21-ITERM-8792"></A><table width="515" border="0" cellpadding="5">
<tr>
<td align="left"><b><i>MIMEText</i></b></td>
<td align="right"></td>
</tr>
</table>
<hr width="515" size="3" noshade="true" align="left" color="black">
<table width="515" border="0" cellpadding="5">
<tr>
<td align="left">
<pre>class MIMEText(<TT><I>_text</I></TT>,<TT><I>_subtype</I></TT>='plain',<TT><I>_charset</I></TT>='us-ascii',<TT><I>_encoder</I></TT>=None)</pre>
</td>
<td align="right"></td>
</tr>
</table>
<P class="docText">Packs text string <TT><I>_text</I></TT> as the payload of
a message of MIME type
'<TT>text/</TT><TT><I>_subtype</I></TT>'
with the given <TT>charset</TT>. When
<TT><I>_encoder</I></TT> is <TT>None</TT>,
<TT>MIMEText</TT> does not encode the text, which is
generally optimal. Otherwise, <TT><I>_encoder</I></TT>
must be callable with one parameter <TT><I>m</I></TT>, the
message being constructed; <TT><I>_encoder</I></TT> must
then call <TT><I>m</I></TT><TT>.get_payload(
)</TT> to get the payload, encode the payload, put the encoded
form back by calling
<TT><I>m</I></TT><TT>.set_payload</TT>, and set
<TT><I>m</I></TT><TT>['Content-Transfer-Encoding']</TT>
appropriately.</P>


<A NAME="pythonian-CHP-21-SECT-2.5"></A>
<H4 class="docSection2Title">21.2.5 The email.Encoders Module</H4>

<P class="docText"><A NAME="pythonian-CHP-21-ITERM-8793"></A> <A NAME="pythonian-CHP-21-ITERM-8794"></A>The <TT>email.Encoders</TT>
module supplies functions that take a message
<TT><I>m</I></TT> as their only argument, encode
<TT><I>m</I></TT>'s payload, and set
<TT><I>m</I></TT>'s headers
appropriately.</P>

<A NAME="ch21-51-fm2xml"></A><A NAME="pythonian-CHP-21-ITERM-8795"></A><A NAME="pythonian-CHP-21-ITERM-8796"></A><table width="515" border="0" cellpadding="5">
<tr>
<td align="left"><b><i>encode_base64</i></b></td>
<td align="right"></td>
</tr>
</table>
<hr width="515" size="3" noshade="true" align="left" color="black">
<table width="515" border="0" cellpadding="5">
<tr>
<td align="left">
<pre>encode_base64(<TT><I>m</I></TT>)</pre>
</td>
<td align="right"></td>
</tr>
</table>
<P class="docText">Uses Base 64 encoding, optimal for arbitrary binary data.</P>

<A NAME="ch21-52-fm2xml"></A><A NAME="pythonian-CHP-21-ITERM-8797"></A><A NAME="pythonian-CHP-21-ITERM-8798"></A><table width="515" border="0" cellpadding="5">
<tr>
<td align="left"><b><i>encode_noop</i></b></td>
<td align="right"></td>
</tr>
</table>
<hr width="515" size="3" noshade="true" align="left" color="black">
<table width="515" border="0" cellpadding="5">
<tr>
<td align="left">
<pre>encode_noop(<TT><I>m</I></TT>)</pre>
</td>
<td align="right"></td>
</tr>
</table>
<P class="docText">Does nothing to <TT><I>m</I></TT>'s
payload and headers.</P>

<A NAME="ch21-53-fm2xml"></A><A NAME="pythonian-CHP-21-ITERM-8799"></A><A NAME="pythonian-CHP-21-ITERM-8800"></A><table width="515" border="0" cellpadding="5">
<tr>
<td align="left"><b><i>encode_quopri</i></b></td>
<td align="right"></td>
</tr>
</table>
<hr width="515" size="3" noshade="true" align="left" color="black">
<table width="515" border="0" cellpadding="5">
<tr>
<td align="left">
<pre>encode_quopri(<TT><I>m</I></TT>)</pre>
</td>
<td align="right"></td>
</tr>
</table>
<P class="docText">Uses Quoted Printable encoding, optimal for textual data that is not
fully ASCII.</P>

<A NAME="ch21-54-fm2xml"></A><A NAME="pythonian-CHP-21-ITERM-8801"></A><A NAME="pythonian-CHP-21-ITERM-8802"></A><table width="515" border="0" cellpadding="5">
<tr>
<td align="left"><b><i>encode_7or8bit</i></b></td>
<td align="right"></td>
</tr>
</table>
<hr width="515" size="3" noshade="true" align="left" color="black">
<table width="515" border="0" cellpadding="5">
<tr>
<td align="left">
<pre>encode_7or8bit(<TT><I>m</I></TT>)</pre>
</td>
<td align="right"></td>
</tr>
</table>
<P class="docText">Does nothing to <TT><I>m</I></TT>'s
payload, sets header Content-Transfer-Encoding to
'<TT>8bit</TT>' if any byte of
<TT><I>m</I></TT>'s payload has the high
bit set, or otherwise to '<TT>7bit</TT>'.</P>


<A NAME="pythonian-CHP-21-SECT-2.6"></A>
<H4 class="docSection2Title">21.2.6 The email.Utils Module</H4>

<P class="docText"><A NAME="pythonian-CHP-21-ITERM-8803"></A> <A NAME="pythonian-CHP-21-ITERM-8804"></A>The
<TT>email.Utils</TT> module supplies miscellaneous
functions useful for email processing.</P>

<A NAME="ch21-56-fm2xml"></A><A NAME="pythonian-CHP-21-ITERM-8805"></A><A NAME="pythonian-CHP-21-ITERM-8806"></A><table width="515" border="0" cellpadding="5">
<tr>
<td align="left"><b><i>decode</i></b></td>
<td align="right"></td>
</tr>
</table>
<hr width="515" size="3" noshade="true" align="left" color="black">
<table width="515" border="0" cellpadding="5">
<tr>
<td align="left">
<pre>decode(<TT><I>s</I></TT>)</pre>
</td>
<td align="right"></td>
</tr>
</table>
<P class="docText">Decodes string <TT><I>s</I></TT> as per the rules in RFC
2047 and returns the resulting Unicode string.</P>

<A NAME="ch21-57-fm2xml"></A><A NAME="pythonian-CHP-21-ITERM-8807"></A><A NAME="pythonian-CHP-21-ITERM-8808"></A><table width="515" border="0" cellpadding="5">
<tr>
<td align="left"><b><i>dump_address_pair</i></b></td>
<td align="right"></td>
</tr>
</table>
<hr width="515" size="3" noshade="true" align="left" color="black">
<table width="515" border="0" cellpadding="5">
<tr>
<td align="left">
<pre>dump_address_pair(<TT><I>pair</I></TT>)</pre>
</td>
<td align="right"></td>
</tr>
</table>
<P class="docText"><TT><I>pair</I></TT> is a pair of strings
<TT>(</TT><TT><I>name</I></TT>,<TT><I>email_address</I></TT><TT>)</TT>.
<TT>dump_address_pair</TT> returns a string
<TT><I>s</I></TT> with the address to insert in header
fields such as To and Cc. When <TT><I>name</I></TT> is
false (e.g., ''),
<TT>dump_address_pair</TT> returns
<TT><I>email_address</I></TT>.</P>

<A NAME="ch21-58-fm2xml"></A><A NAME="pythonian-CHP-21-ITERM-8809"></A><A NAME="pythonian-CHP-21-ITERM-8810"></A><table width="515" border="0" cellpadding="5">
<tr>
<td align="left"><b><i>encode</i></b></td>
<td align="right"></td>
</tr>
</table>
<hr width="515" size="3" noshade="true" align="left" color="black">
<table width="515" border="0" cellpadding="5">
<tr>
<td align="left">
<pre>encode(<TT><I>s</I></TT>,<TT><I>charset</I></TT>='iso-8859-1',<TT><I>encoding</I></TT>='q')</pre>
</td>
<td align="right"></td>
</tr>
</table>
<P class="docText">Encodes string <TT><I>s</I></TT> (which must use the given
<TT><I>charset</I></TT>) as per the rules in RFC 2047.
<TT><I>encoding</I></TT> must be '<TT>q</TT>' to
specify Quoted Printable, or '<TT>b</TT>' to specify Base
64.</P>

<A NAME="ch21-59-fm2xml"></A><A NAME="pythonian-CHP-21-ITERM-8811"></A><A NAME="pythonian-CHP-21-ITERM-8812"></A><table width="515" border="0" cellpadding="5">
<tr>
<td align="left"><b><i>formatdate</i></b></td>
<td align="right"></td>
</tr>
</table>
<hr width="515" size="3" noshade="true" align="left" color="black">
<table width="515" border="0" cellpadding="5">
<tr>
<td align="left">
<pre>formatdate(<TT><I>timeval</I></TT>=None,<TT><I>localtime</I></TT>=False)</pre>
</td>
<td align="right"></td>
</tr>
</table>
<P class="docText"><TT><I>timeval</I></TT> is a number of seconds since the
epoch. When <TT><I>timeval</I></TT> is
<TT>None</TT>, <TT>formatdate</TT> uses the
current time. When <TT><I>localtime</I></TT> is true,
<TT>formatdate</TT> uses the local timezone; otherwise it
uses UTC. <TT>formatdate</TT> returns a string with the
given time instant formatted in the way specified by RFC 2822.</P>

<A NAME="ch21-60-fm2xml"></A><A NAME="pythonian-CHP-21-ITERM-8813"></A><A NAME="pythonian-CHP-21-ITERM-8814"></A><table width="515" border="0" cellpadding="5">
<tr>
<td align="left"><b><i>getaddresses</i></b></td>
<td align="right"></td>
</tr>
</table>
<hr width="515" size="3" noshade="true" align="left" color="black">
<table width="515" border="0" cellpadding="5">
<tr>
<td align="left">
<pre>getaddresses(<TT><I>L</I></TT>)</pre>
</td>
<td align="right"></td>
</tr>
</table>
<P class="docText">Parses each item of <TT><I>L</I></TT>, a list of address
strings as used in header fields such as <TT>To</TT> and
<TT>Cc</TT>, and returns a list of pairs of strings
<TT>(</TT><TT><I>name</I></TT>,<TT><I>email_address</I></TT><TT>)</TT>.
When <TT>getaddresses</TT> cannot parse an item of
<TT><I>L</I></TT> as an address,
<TT>getaddresses</TT> uses <TT>(None,None)</TT>
as the corresponding item in the list it returns.</P>

<A NAME="ch21-61-fm2xml"></A><A NAME="pythonian-CHP-21-ITERM-8815"></A><A NAME="pythonian-CHP-21-ITERM-8816"></A><table width="515" border="0" cellpadding="5">
<tr>
<td align="left"><b><i>mktime_tz</i></b></td>
<td align="right"></td>
</tr>
</table>
<hr width="515" size="3" noshade="true" align="left" color="black">
<table width="515" border="0" cellpadding="5">
<tr>
<td align="left">
<pre>mktime_tz(<TT><I>t</I></TT>)</pre>
</td>
<td align="right"></td>
</tr>
</table>
<P class="docText"><TT><I>t</I></TT> is a tuple with 10 items, the first 9 in
the same format used in module <TT>time</TT> covered in
<A class="docLink" HREF="0596001886_pythonian-chp-12.html#pythonian-CHP-12">Chapter 12</A>,
<TT><I>t</I></TT><TT>[-1]</TT> is a time zone as
an offset in seconds from UTC (with the opposite sign from
<TT>time.timezone</TT>, as specified by RFC 2822). When
<TT><I>t</I></TT><TT>[-1]</TT> is
<TT>None</TT>, <TT>mktime_tz</TT> uses the local
time zone. <TT>mktime_tz</TT> returns a float with the
number of seconds since the epoch, in UTC, corresponding to the time
instant that <TT><I>t</I></TT> denotes.</P>

<A NAME="ch21-62-fm2xml"></A><A NAME="pythonian-CHP-21-ITERM-8817"></A><A NAME="pythonian-CHP-21-ITERM-8818"></A><table width="515" border="0" cellpadding="5">
<tr>
<td align="left"><b><i>parseaddr</i></b></td>
<td align="right"></td>
</tr>
</table>
<hr width="515" size="3" noshade="true" align="left" color="black">
<table width="515" border="0" cellpadding="5">
<tr>
<td align="left">
<pre>parseaddr(<TT><I>s</I></TT>)</pre>
</td>
<td align="right"></td>
</tr>
</table>
<P class="docText">Parses string <TT><I>s</I></TT>, which contains an address
as typically specified in header fields such as <TT>To</TT>
and <TT>Cc</TT>, and returns a pair of strings
<TT>(</TT><TT><I>name</I></TT>,<TT><I>email_address</I></TT><TT>)</TT>.
When <TT>parseaddr</TT> cannot parse
<TT><I>s</I></TT> as an address,
<TT>parseaddr</TT> returns <TT>(None,None)</TT>.</P>

<A NAME="ch21-63-fm2xml"></A><A NAME="pythonian-CHP-21-ITERM-8819"></A><A NAME="pythonian-CHP-21-ITERM-8820"></A><table width="515" border="0" cellpadding="5">
<tr>
<td align="left"><b><i>parsedate</i></b></td>
<td align="right"></td>
</tr>
</table>
<hr width="515" size="3" noshade="true" align="left" color="black">
<table width="515" border="0" cellpadding="5">
<tr>
<td align="left">
<pre>parsedate(<TT><I>s</I></TT>)</pre>
</td>
<td align="right"></td>
</tr>
</table>
<P class="docText">Parses string <TT><I>s</I></TT> as per the rules in RFC
2822 and returns a tuple <TT><I>t</I></TT> with 9 items,
as used in module <TT>time</TT> covered in <A class="docLink" HREF="0596001886_pythonian-chp-12.html#pythonian-CHP-12">Chapter 12</A> (the items
<TT><I>t</I></TT><TT>[-3:]</TT> are not
meaningful). <TT>parsedate</TT> also attempts to parse
erroneous variations on RFC 2822 that widespread mailers use. When
<TT>parsedate</TT> cannot parse
<TT><I>s</I></TT>, <TT>parsedate</TT> returns
<TT>None</TT>.</P>

<A NAME="ch21-64-fm2xml"></A><A NAME="pythonian-CHP-21-ITERM-8821"></A><A NAME="pythonian-CHP-21-ITERM-8822"></A><table width="515" border="0" cellpadding="5">
<tr>
<td align="left"><b><i>parsedate_tz</i></b></td>
<td align="right"></td>
</tr>
</table>
<hr width="515" size="3" noshade="true" align="left" color="black">
<table width="515" border="0" cellpadding="5">
<tr>
<td align="left">
<pre>parsedate_tz(<TT><I>s</I></TT>)</pre>
</td>
<td align="right"></td>
</tr>
</table>
<P class="docText">Like <TT>parsedate</TT>, but returns a tuple
<TT><I>t</I></TT> with 10 items, where
<TT><I>t</I></TT><TT>[-1]</TT> is
<TT><I>s</I></TT>'s time zone as an
offset in seconds from UTC (with the opposite sign from
<TT>time.timezone</TT>, as specified by RFC 2822), like in
the argument that <TT>mktime_tz</TT> accepts. Items
<TT><I>t</I></TT><TT>[-4:-1]</TT> are not
meaningful. When <TT><I>s</I></TT> has no time zone,
<TT><I>t</I></TT><TT>[-1]</TT> is
<TT>None</TT>.</P>

<A NAME="ch21-65-fm2xml"></A><A NAME="pythonian-CHP-21-ITERM-8823"></A><A NAME="pythonian-CHP-21-ITERM-8824"></A><table width="515" border="0" cellpadding="5">
<tr>
<td align="left"><b><i>quote</i></b></td>
<td align="right"></td>
</tr>
</table>
<hr width="515" size="3" noshade="true" align="left" color="black">
<table width="515" border="0" cellpadding="5">
<tr>
<td align="left">
<pre>quote(s)</pre>
</td>
<td align="right"></td>
</tr>
</table>
<P class="docText">Returns a copy of string <TT><I>s</I></TT> where each
double quote (") becomes '<TT>\"</TT>'
and each existing backslash is repeated.</P>

<A NAME="ch21-66-fm2xml"></A><A NAME="pythonian-CHP-21-ITERM-8825"></A><A NAME="pythonian-CHP-21-ITERM-8826"></A><A NAME="pythonian-CHP-21-ITERM-8827"></A><A NAME="pythonian-CHP-21-ITERM-8828"></A><table width="515" border="0" cellpadding="5">
<tr>
<td align="left"><b><i>unquote</i></b></td>
<td align="right"></td>
</tr>
</table>
<hr width="515" size="3" noshade="true" align="left" color="black">
<table width="515" border="0" cellpadding="5">
<tr>
<td align="left">
<pre>unquote(<TT><I>s</I></TT>)</pre>
</td>
<td align="right"></td>
</tr>
</table>
<P class="docText">Returns a copy of string <TT><I>s</I></TT> where leading
and trailing double quote characters (") and angle
brackets (<TT>&lt;&gt;</TT>) are removed if they surround
the rest of <TT><I>s</I></TT>.<A NAME="pythonian-CHP-21-ITERM-8827"></A> <A NAME="pythonian-CHP-21-ITERM-8828"></A></P>


<A NAME="pythonian-CHP-21-SECT-2.7"></A>
<H4 class="docSection2Title">21.2.7 The Message Classes of the rfc822 and mimetools Modules</H4>

<P class="docText"><A NAME="pythonian-CHP-21-ITERM-8829"></A> <A NAME="pythonian-CHP-21-ITERM-8830"></A> <A NAME="pythonian-CHP-21-ITERM-8831"></A>
<A NAME="pythonian-CHP-21-ITERM-8832"></A>The best way to handle email-like messages
is with package <TT>email</TT>. However, other modules
covered in <A class="docLink" HREF="0596001886_pythonian-chp-18.html#pythonian-CHP-18">Chapter 18</A> and <A class="docLink" HREF="0596001886_pythonian-chp-20.html#pythonian-CHP-20">Chapter 20</A> use instances of class
<TT>rfc822.Message</TT> or its subclass
<TT>mimetools.Message</TT>. This section covers the subset
of these classes' functionality that you need to
make effective use of the modules covered in <A class="docLink" HREF="0596001886_pythonian-chp-18.html#pythonian-CHP-18">Chapter 18</A> and <A class="docLink" HREF="0596001886_pythonian-chp-20.html#pythonian-CHP-20">Chapter 20</A>.</P>

<P class="docText">An instance <TT><I>m</I></TT> of class
<TT>Message</TT> is a mapping, with the
headers' names as keys and the corresponding header
value strings as values. Keys and values are strings, and keys are
case-insensitive. <TT><I>m</I></TT> supports all mapping
methods except <TT>clear</TT>, <TT>copy</TT>,
<TT>popitem</TT>, and <TT>update</TT>.
<TT>get</TT> and <TT>setdefault</TT> default to
'', instead of <TT>None</TT>. Instance
<TT><I>m</I></TT> also supplies convenience methods (e.g.,
to combine getting a header's value and parsing it
as a date or an address). I suggest you use for such purposes the
functions of module <TT>email.Utils</TT>, covered earlier
in this chapter, and use <TT><I>m</I></TT> just as a
mapping.</P>

<P class="docText">When <TT><I>m</I></TT> is an instance of
<TT>mimetools.Message</TT>, <TT><I>m</I></TT>
supplies additional methods.</P>

<A NAME="ch21-68-fm2xml"></A><A NAME="pythonian-CHP-21-ITERM-8833"></A><A NAME="pythonian-CHP-21-ITERM-8834"></A><table width="515" border="0" cellpadding="5">
<tr>
<td align="left"><b><i>getmaintype</i></b></td>
<td align="right"></td>
</tr>
</table>
<hr width="515" size="3" noshade="true" align="left" color="black">
<table width="515" border="0" cellpadding="5">
<tr>
<td align="left">
<pre><TT><I>m</I></TT>.getmaintype(  )</pre>
</td>
<td align="right"></td>
</tr>
</table>
<P class="docText"><A NAME="pythonian-CHP-21-ITERM-8833"></A> <A NAME="pythonian-CHP-21-ITERM-8834"></A>Returns
<TT><I>m</I></TT>'s main content type,
taken from header Content-Type converted to lowercase. When
<TT><I>m</I></TT> has no header Content-Type,
<TT>getmaintype</TT> returns '<TT>text</TT>'.</P>

<A NAME="ch21-69-fm2xml"></A><A NAME="pythonian-CHP-21-ITERM-8835"></A><A NAME="pythonian-CHP-21-ITERM-8836"></A><table width="515" border="0" cellpadding="5">
<tr>
<td align="left"><b><i>getparam</i></b></td>
<td align="right"></td>
</tr>
</table>
<hr width="515" size="3" noshade="true" align="left" color="black">
<table width="515" border="0" cellpadding="5">
<tr>
<td align="left">
<pre><TT><I>m</I></TT>.getparam(<TT><I>param</I></TT>)</pre>
</td>
<td align="right"></td>
</tr>
</table>
<P class="docText"><A NAME="pythonian-CHP-21-ITERM-8835"></A> <A NAME="pythonian-CHP-21-ITERM-8836"></A>Returns the string value of the
parameter named <TT><I>param</I></TT> of
<TT><I>m</I></TT>'s header Content-Type.</P>

<A NAME="ch21-70-fm2xml"></A><A NAME="pythonian-CHP-21-ITERM-8837"></A><A NAME="pythonian-CHP-21-ITERM-8838"></A><table width="515" border="0" cellpadding="5">
<tr>
<td align="left"><b><i>getsubtype</i></b></td>
<td align="right"></td>
</tr>
</table>
<hr width="515" size="3" noshade="true" align="left" color="black">
<table width="515" border="0" cellpadding="5">
<tr>
<td align="left">
<pre><TT><I>m</I></TT>.getsubtype(  )</pre>
</td>
<td align="right"></td>
</tr>
</table>
<P class="docText">Returns <TT><I>m</I></TT>'s content
subtype, taken from header Content-Type converted to lowercase. When
<TT><I>m</I></TT> has no header Content-Type,
<TT>getsubtype</TT> returns '<TT>plain</TT>'.</P>

<A NAME="ch21-71-fm2xml"></A><A NAME="pythonian-CHP-21-ITERM-8839"></A><A NAME="pythonian-CHP-21-ITERM-8840"></A><A NAME="pythonian-CHP-21-ITERM-8841"></A><A NAME="pythonian-CHP-21-ITERM-8842"></A><table width="515" border="0" cellpadding="5">
<tr>
<td align="left"><b><i>gettype</i></b></td>
<td align="right"></td>
</tr>
</table>
<hr width="515" size="3" noshade="true" align="left" color="black">
<table width="515" border="0" cellpadding="5">
<tr>
<td align="left">
<pre><TT><I>m</I></TT>.gettype(  )</pre>
</td>
<td align="right"></td>
</tr>
</table>
<P class="docText"><A NAME="pythonian-CHP-21-ITERM-8839"></A> <A NAME="pythonian-CHP-21-ITERM-8840"></A>Returns
<TT><I>m</I></TT>'s content type, taken
from header Content-Type converted to lowercase. When
<TT><I>m</I></TT> has no header Content-Type,
<TT>gettype</TT> returns
'<TT>text/plain</TT>'.<A NAME="pythonian-CHP-21-ITERM-8841"></A> <A NAME="pythonian-CHP-21-ITERM-8842"></A></P>



<a href="0596001886_"><img src="FILES/pixel.gif" width="1" height="1" border="0"></a><ul></ul>
</td>
</tr>
</table>
<td></td>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<td class="tt1"><a href="NFO/lib.html">[ Team LiB ]</a></td><td valign="top" class="tt1" align="right">
          <a href="0596001886_pythonian-chp-21-sect-1.html"><img src="FILES/previous.gif" width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a>
          <a href="0596001886_pythonian-chp-22.html"><img src="FILES/next.gif" width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a>
</td></table>
</body></html>
