<html><head>
<META http-equiv="Content-Type" content="text/html">
<!--SafClassName="docSection1Title"--><!--SafTocEntry="24.1 Extending Python with Python's C API"-->
<link rel="STYLESHEET" type="text/css" href="FILES/style.css">
<link rel="STYLESHEET" type="text/css" href="FILES/docsafari.css">
<style type="text/css">	.tt1    {font-size: 10pt;}</style>
</head>
<body>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<td class="tt1"><a href="NFO/lib.html">[ Team LiB ]</a></td><td valign="top" class="tt1" align="right">
	<a href="0596001886_pythonian-chp-24.html"><img src="FILES/previous.gif" width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a>
	<a href="0596001886_pythonian-chp-24-sect-2.html"><img src="FILES/next.gif" width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a>
</td></table>
<br>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<tr>
<td valign="top"><A NAME="pythonian-CHP-24-SECT-1"></A>
<H3 class="docSection1Title">24.1 Extending Python with Python's C API</H3>

<P class="docText"><A NAME="pythonian-CHP-24-ITERM-9226"></A>
<A NAME="pythonian-CHP-24-ITERM-9227"></A>A Python extension module named
<TT><I>x</I></TT> resides in a dynamic library with the
same filename (<I>x.pyd</I> on Windows,
<I>x.so</I> on most Unix-like platforms) in an
appropriate directory (normally the
<I>site-packages</I> subdirectory of the Python library
directory). You generally build the <TT><I>x</I></TT>
extension module from a C source file <I>x.c</I> with
the overall structure:</P>

<PRE>#include &lt;Python.h&gt;

/* omitted: the body of the <TT><I>x</I></TT> module */

void
init<TT><I>x</I></TT>(void)
{
    /* omitted: the code that initializes the module named <TT><I>x</I></TT> */
}</PRE>

<P class="docText">When you have built and installed the extension module, a Python
statement <TT>import</TT> <TT><I>x</I></TT>
loads the dynamic library, then locates and calls the function named
<TT>init</TT><TT><I>x</I></TT>, which must do
all that is needed to initialize the module object named
<TT><I>x</I></TT>.</P>

<A NAME="pythonian-CHP-24-SECT-1.1"></A>
<H4 class="docSection2Title">24.1.1 Building and Installing C-Coded Python Extensions</H4>

<P class="docText"><A NAME="pythonian-CHP-24-ITERM-9228"></A> <A NAME="pythonian-CHP-24-ITERM-9229"></A>
<A NAME="pythonian-CHP-24-ITERM-9230"></A>To build and install a C-coded
Python extension module, it's simplest and most
productive to use the distribution utilities,
<TT>distutils</TT>, covered in <A class="docLink" HREF="0596001886_pythonian-chp-26.html#pythonian-CHP-26">Chapter 26</A>. In the same directory as
<I>x.c</I>, place a file named
<I>setup.py</I> that contains at least the following
statements:</P>

<PRE>from distutils.core import setup, Extension
setup(name='<TT><I>x</I></TT>', ext_modules=[ Extension('<TT><I>x</I></TT>',sources=['<TT><I>x</I></TT>.c']) ])</PRE>

<P class="docText">From a shell prompt in this directory, you can now run:</P>

<PRE>C:\&gt; <B>python setup.py install</B></PRE>

<P class="docText">to build the module and install it so that it becomes usable in your
Python installation. The <TT>distutils</TT> perform all
needed compilation and linking steps, with the right compiler and
linker commands and flags, and copy the resulting dynamic library in
an appropriate directory, dependent on your Python installation. Your
Python code can then access the resulting module with the statement
<TT>import</TT>
<TT><I>x</I></TT>.<A NAME="pythonian-CHP-24-ITERM-9231"></A></P>


<A NAME="pythonian-CHP-24-SECT-1.2"></A>
<H4 class="docSection2Title">24.1.2 Overview of C-Coded Python Extension Modules</H4>

<P class="docText"><A NAME="pythonian-CHP-24-ITERM-9232"></A>
<A NAME="pythonian-CHP-24-ITERM-9233"></A>Your C
function <TT>init</TT><TT><I>x</I></TT>
generally has the following overall structure:</P>

<PRE>void
init<TT><I>x</I></TT>(void)
{
    PyObject* <TT><I>thismod</I></TT> = Py_InitModule3("<TT><I>x</I></TT>", <TT><I>x_methods</I></TT>, "docstring for <TT><I>x</I></TT>");
    /* optional: calls to PyModule_AddObject(<TT><I>thismod</I></TT>, "<TT><I>somename</I></TT>", <TT><I>someobj</I></TT>)
       and other Python C API calls to finish preparing module object
       <TT><I>thismod</I></TT> and its types (if any) and other objects.
    */
}</PRE>

<P class="docText"><A NAME="pythonian-CHP-24-ITERM-9234"></A>More details are covered in
<A class="docLink" HREF="#pythonian-CHP-24-SECT-1.4">Section 24.1.4</A>
later in this chapter. <TT><I>x_methods</I></TT> is an
array of <TT>PyMethodDef</TT> structs. Each
<TT>PyMethodDef</TT> struct in the
<TT><I>x_methods</I></TT> array describes a C function
that your module <TT><I>x</I></TT> makes available to
Python code that imports <TT><I>x</I></TT>. Each such C
function has the following overall structure:</P>

<PRE>static PyObject*
<TT><I>func_with_named_arguments</I></TT>(PyObject* self, PyObject* args, PyObject* kwds)
{
    /* omitted: body of function, which accesses arguments via the Python C
       API function PyArg_ParseTupleAndKeywords, and returns a PyObject*
       result, NULL for errors */
}</PRE>

<P class="docText">or some simpler variant, such as:</P>

<PRE>static PyObject*
<TT><I>func_with_positional_args_only</I></TT>(PyObject* self, PyObject* args)
{
    /* omitted: body of function, which accesses arguments via the Python C
       API function PyArg_ParseTuple, and returns a PyObject* result,
       NULL for errors */
}</PRE>

<P class="docText">How C-coded functions access arguments passed by Python code is
covered in <A class="docLink" HREF="#pythonian-CHP-24-SECT-1.6">Section 24.1.6</A>
later in this chapter. How such functions build Python objects is
covered in <A class="docLink" HREF="#pythonian-CHP-24-SECT-1.7">Section 24.1.7</A>, and how they raise or propagate exceptions back to the
Python code that called them is covered in <A class="docLink" HREF="#pythonian-CHP-24-SECT-1.8">Section 24.1.8</A>. When your module defines
new Python types (as well as or instead of Python-callable
functions), your C code defines one or more instances of struct
<TT>PyTypeObject</TT>. This subject is covered in <A class="docLink" HREF="#pythonian-CHP-24-SECT-1.12">Section 24.1.12</A> later in this
chapter.</P>

<P class="docText">A simple example that makes use of all these concepts is shown in
<A class="docLink" HREF="#pythonian-CHP-24-SECT-1.11">Section 24.1.11</A> later in this chapter.
A toy-level "Hello World" example
could be as simple as:</P>

<PRE>#include &lt;Python.h&gt;

static PyObject*
helloworld(PyObject* self)
{
    return Py_BuildValue("s", "Hello, C-coded Python extensions world!");
}

static char helloworld_docs[] = 
    "helloworld(  ): return a popular greeting phrase\n";

static PyMethodDef helloworld_funcs[] = {
    {"helloworld", (PyCFunction)helloworld, METH_NOARGS, helloworld_docs},
    {NULL}
};

void
inithelloworld(void)
{
    Py_InitModule3("helloworld", helloworld_funcs, 
                   "Toy-level extension module");
}</PRE>

<P class="docText">Save this as <I>helloworld.c</I>, and build it through
a <I>setup.py</I> script with
<TT>distutils</TT>. After you have run <I>python
setup.py install</I>, you can use the newly installed module,
for example from a Python interactive session, such as:</P>

<A NAME="pythonian-CHP-24-ITERM-9235"></A><A NAME="pythonian-CHP-24-ITERM-9236"></A><PRE>&gt;&gt;&gt; import helloworld
&gt;&gt;&gt; print helloworld.helloworld(  )
<B>Hello, C-coded Python extensions world!</B>
&gt;&gt;&gt;</PRE>


<A NAME="pythonian-CHP-24-SECT-1.3"></A>
<H4 class="docSection2Title">24.1.3 Return Values of Python's C API Functions</H4>

<P class="docText"><A NAME="pythonian-CHP-24-ITERM-9237"></A>
<A NAME="pythonian-CHP-24-ITERM-9238"></A>All functions in the Python
C API return either an <TT>int</TT> or a
<TT>PyObject*</TT>. Most functions returning
<TT>int</TT> return <TT>0</TT> in case of
success, and <TT>-1</TT> to indicate errors. Some functions
return results that are true or false: those functions return
<TT>0</TT> to indicate false and an integer not equal to
<TT>0</TT> to indicate true, and never indicate errors.
Functions returning <TT>PyObject*</TT> return
<TT>NULL</TT> in case of errors. See
"Exceptions" later in this chapter
for more details on how C-coded functions handle and raise errors.</P>


<A NAME="pythonian-CHP-24-SECT-1.4"></A>
<H4 class="docSection2Title">24.1.4 Module Initialization</H4>

<P class="docText"><A NAME="pythonian-CHP-24-ITERM-9239"></A>
<A NAME="pythonian-CHP-24-ITERM-9240"></A>Function
<TT>init</TT><TT><I>x</I></TT> must contain, at
a minimum, a call to one of the module initialization functions
supplied by the C API. You can always use the
<TT>Py_InitModule3</TT> function.</P>

<A NAME="ch24-7-fm2xml"></A><A NAME="pythonian-CHP-24-ITERM-9241"></A><table width="515" border="0" cellpadding="5">
<tr>
<td align="left"><b><i>Py_InitModule3</i></b></td>
<td align="right"></td>
</tr>
</table>
<hr width="515" size="3" noshade="true" align="left" color="black">
<table width="515" border="0" cellpadding="5">
<tr>
<td align="left">
<pre>PyObject* Py_InitModule3(char* <TT><I>name</I></TT>,PyMethodDef* <TT><I>methods</I></TT>,char* <TT><I>doc</I></TT>)</pre>
</td>
<td align="right"></td>
</tr>
</table>
<P class="docText"><TT><I>name</I></TT> is the C string name of the module
you are initializing (e.g., "<TT>name</TT>").
<TT><I>methods</I></TT> is an array of
<TT>PyMethodDef</TT> structures, covered next in this
chapter. <TT><I>doc</I></TT> is the C string that becomes
the docstring of the module. <TT>Py_InitModule3</TT>
returns a <TT>PyObject*</TT> that is a borrowed reference
to the new module object, as covered in <A class="docLink" HREF="#pythonian-CHP-24-SECT-1.5">Section 24.1.5</A> later in this chapter. In
practice, this means that you can ignore the return value if you need
to perform no more initialization operations on this module.
Otherwise, assign the return value to a C variable of type
<TT>PyObject*</TT> and continue initialization.</P>

<P class="docText"><TT>Py_InitModule3</TT> initializes the module object to
contain the functions described in table
<TT><I>methods</I></TT>. Further initialization, if any,
may add other module attributes, and is generally best performed with
calls to the following convenience functions.</P>

<A NAME="ch24-8-fm2xml"></A><A NAME="pythonian-CHP-24-ITERM-9242"></A><table width="515" border="0" cellpadding="5">
<tr>
<td align="left"><b><i>PyModule_AddIntConstant</i></b></td>
<td align="right"></td>
</tr>
</table>
<hr width="515" size="3" noshade="true" align="left" color="black">
<table width="515" border="0" cellpadding="5">
<tr>
<td align="left">
<pre>int PyModule_AddIntConstant(PyObject* <TT><I>module</I></TT>,char* <TT><I>name</I></TT>,int <TT><I>value</I></TT>)</pre>
</td>
<td align="right"></td>
</tr>
</table>
<P class="docText">Adds to module <TT><I>module</I></TT> an attribute named
<TT><I>name</I></TT> with integer value
<TT><I>value</I></TT>.</P>

<A NAME="ch24-9-fm2xml"></A><A NAME="pythonian-CHP-24-ITERM-9243"></A><table width="515" border="0" cellpadding="5">
<tr>
<td align="left"><b><i>PyModule_AddObject</i></b></td>
<td align="right"></td>
</tr>
</table>
<hr width="515" size="3" noshade="true" align="left" color="black">
<table width="515" border="0" cellpadding="5">
<tr>
<td align="left">
<pre>int PyModule_AddObject(PyObject* <TT><I>module</I></TT>,char* <TT><I>name</I></TT>,PyObject* <TT><I>value</I></TT>)</pre>
</td>
<td align="right"></td>
</tr>
</table>
<P class="docText">Adds to module <TT><I>module</I></TT> an attribute named
<TT><I>name</I></TT> with value
<TT><I>value</I></TT> and steals a reference to value, as
covered in <A class="docLink" HREF="#pythonian-CHP-24-SECT-1.5">Section 24.1.5</A>.</P>

<A NAME="ch24-10-fm2xml"></A><A NAME="pythonian-CHP-24-ITERM-9244"></A><table width="515" border="0" cellpadding="5">
<tr>
<td align="left"><b><i>PyModule_AddStringConstant</i></b></td>
<td align="right"></td>
</tr>
</table>
<hr width="515" size="3" noshade="true" align="left" color="black">
<table width="515" border="0" cellpadding="5">
<tr>
<td align="left">
<pre>int PyModule_AddStringConstant(PyObject* <TT><I>module</I></TT>,char* <TT><I>name</I></TT>,char* <TT><I>value</I></TT>)</pre>
</td>
<td align="right"></td>
</tr>
</table>
<P class="docText">Adds to module <TT><I>module</I></TT> an attribute named
<TT><I>name</I></TT> with string value
<TT><I>value</I></TT>.</P>

<P class="docText">Some module initialization operations may be conveniently performed
by executing Python code with <TT>PyRun_String</TT>,
covered later in <A class="docLink" HREF="0596001886_pythonian-chp-24-sect-3.html#pythonian-CHP-24-SECT-3.4">Section 24.3.4</A>, with
the module's dictionary as both the
<TT><I>globals</I></TT> and
<TT><I>locals</I></TT> argument. If you find yourself
using <TT>PyRun_String</TT> extensively, rather than just
as an occasional convenience, consider the possibility of splitting
your extension module in two: a C-coded extension module offering
raw, fast functionality, and a Python module wrapping the C-coded
extension to provide further convenience and handy utilities.</P>

<P class="docText">When you do need to get a module's dictionary, use
the <TT>PyModule_GetDict</TT> function.</P>

<A NAME="ch24-11-fm2xml"></A><A NAME="pythonian-CHP-24-ITERM-9245"></A><table width="515" border="0" cellpadding="5">
<tr>
<td align="left"><b><i>PyModule_GetDict</i></b></td>
<td align="right"></td>
</tr>
</table>
<hr width="515" size="3" noshade="true" align="left" color="black">
<table width="515" border="0" cellpadding="5">
<tr>
<td align="left">
<pre>PyObject* PyModule_GetDict(PyObject* <TT><I>module</I></TT>)</pre>
</td>
<td align="right"></td>
</tr>
</table>
<P class="docText">Returns a borrowed reference to the dictionary of module
<TT><I>module</I></TT>. You should not use
<TT>PyModule_GetDict</TT> for the specific tasks supported
by the <TT>PyModule_Add</TT> functions covered earlier in
this section; I suggest using <TT>PyModule_GetDict</TT>
only for such purposes as supporting the use of
<TT>PyRun_String</TT>.</P>

<P class="docText">If you need to access another module, you can import it by calling
the <TT>PyImport_Import</TT> function.</P>

<A NAME="ch24-12-fm2xml"></A><A NAME="pythonian-CHP-24-ITERM-9246"></A><table width="515" border="0" cellpadding="5">
<tr>
<td align="left"><b><i>PyImport_Import</i></b></td>
<td align="right"></td>
</tr>
</table>
<hr width="515" size="3" noshade="true" align="left" color="black">
<table width="515" border="0" cellpadding="5">
<tr>
<td align="left">
<pre>PyObject* PyImport_Import(PyObject* <TT><I>name</I></TT>)</pre>
</td>
<td align="right"></td>
</tr>
</table>
<P class="docText">Imports the module named in Python string object
<TT><I>name</I></TT> and returns a new reference to the
module object, like Python's <TT>_ _import_
_(</TT><TT><I>name</I></TT><TT>)</TT>.
<TT>PyImport_Import</TT> is the highest-level, simplest,
and most often used way to import a module.</P>
<P class="docText">Beware, in particular, of using function
<TT>PyImport_ImportModule</TT>, which may often look more
convenient because it accepts a <TT>char*</TT> argument.
<TT>PyImport_ImportModule</TT> operates on a lower level,
bypassing any import hooks that may be in force, so extensions that
use it will be far harder to incorporate in packages such as those
built by tools <TT>py2exe</TT> and
<TT>Installer</TT>, covered in <A class="docLink" HREF="0596001886_pythonian-chp-26.html#pythonian-CHP-26">Chapter 26</A>. Therefore, always do your importing by
calling <TT>PyImport_Import</TT>, unless you have very
specific needs and know exactly what you're doing.</P>

<P class="docText">To add functions to a module (or non-special methods to new types, as
covered later in <A class="docLink" HREF="#pythonian-CHP-24-SECT-1.12">Section 24.1.12</A>), you
must describe the functions or methods in an array of
<TT>PyMethodDef</TT> structures, and terminate the array
with a <I>sentinel</I> (i.e., a structure whose fields
are all <TT>0</TT> or <TT>NULL</TT>).
<TT>PyMethodDef</TT> is defined as follows:</P>

<PRE>typedef struct {
    char* <TT><I>ml_name</I></TT>;        /* Python name of function or method */
    PyCFunction <TT><I>ml_meth</I></TT>;  /* pointer to C function impl */
    int <TT><I>ml_flags</I></TT>;         /* flag describing how to pass arguments */
    char* <TT><I>ml_doc</I></TT>;         /* docstring for the function or method */
} PyMethodDef</PRE>

<P class="docText">You must cast the second field to <TT>(PyCFunction)</TT>
unless the C function's signature is exactly
<TT>PyObject*</TT>
<TT><I>function</I></TT><TT>(PyObject*</TT>
<TT><I>self</I></TT>,
<TT>PyObject*</TT>
<TT><I>args</I></TT><TT>)</TT>, which is the
<TT>typedef</TT> for <TT>PyCFunction</TT>. This
signature is correct when <TT>ml_flags</TT> is
<TT>METH_O</TT>, meaning a function that accepts a single
argument, or <TT>METH_VARARGS</TT>, meaning a function that
accepts positional arguments. For <TT>METH_O</TT>,
<TT><I>args</I></TT> is the only argument. For
<TT>METH_VARARGS</TT>, <TT><I>args</I></TT> is a
tuple of all arguments, to be parsed with the C API function
<TT>PyArg_ParseTuple</TT>. However,
<TT>ml_flags</TT> can also be
<TT>METH_NOARGS</TT>, meaning a function that accepts no
arguments, or <TT>METH_KEYWORDS</TT>, meaning a function
that accepts both positional and named arguments. For
<TT>METH_NOARGS</TT>, the signature is
<TT>PyObject*</TT>
<TT><I>function</I></TT><TT>(PyObject*</TT>
<TT><I>self</I></TT><TT>)</TT>, without
arguments. For <TT>METH_KEYWORDS</TT>, the signature is:</P>

<PRE>PyObject* <TT><I>function</I></TT>(PyObject* <TT><I>self</I></TT>, PyObject* <TT><I>args</I></TT>, PyObject* <TT><I>kwds</I></TT>)</PRE>

<P class="docText"><TT><I>args</I></TT> is the tuple of positional arguments,
and <TT><I>kwds</I></TT> the dictionary of named
arguments. <TT><I>args</I></TT> and
<TT><I>kwds</I></TT> are parsed together with the C API
function <TT>PyArg_ParseTupleAndKeywords</TT>.</P>

<P class="docText">When a C-coded function implements a module's
function, the <TT>self</TT> parameter of the C function is
always <TT>NULL</TT> for any value of the
<TT>ml_flags</TT> field. When a C-coded function implements
a non-special method of an extension type, the
<TT>self</TT> parameter points to the instance on which the
method is being called.</P>


<A NAME="pythonian-CHP-24-SECT-1.5"></A>
<H4 class="docSection2Title">24.1.5 Reference Counting</H4>

<P class="docText"><A NAME="pythonian-CHP-24-ITERM-9247"></A>
<A NAME="pythonian-CHP-24-ITERM-9248"></A>Python
objects live on the heap, and C code sees them via
<TT>PyObject*</TT>. Each <TT>PyObject</TT> counts
how many references to itself are outstanding, and destroys itself
when the number of references goes down to <TT>0</TT>. To
make this possible, your code must use Python-supplied macros:
<TT>Py_INCREF</TT> to add a reference to a Python object,
and <TT>Py_DECREF</TT> to abandon a reference to a Python
object. The <TT>Py_XINCREF</TT> and
<TT>Py_XDECREF</TT> macros are like
<TT>Py_INCREF</TT> and <TT>Py_DECREF</TT>, but
you may also use them innocuously on a null pointer. The test for a
non-null pointer is implicitly performed inside the
<TT>Py_XINCREF</TT> and <TT>Py_XDECREF</TT>
macros, which saves you from needing to write out that test
explicitly.</P>

<P class="docText">A <TT>PyObject*</TT> <TT><I>p</I></TT>, which
your code receives by calling or being called by other functions, is
known as a <I>new reference</I> if the code that
supplies <TT><I>p</I></TT> has already called
<TT>Py_INCREF</TT> on your behalf. Otherwise, it is called
a <I>borrowed</I> <I>reference</I>. Your
code is said to <I>own</I> new references it holds, but
not borrowed ones. You can call <TT>Py_INCREF</TT> on a
borrowed reference to make it into a reference that you own; you must
do this if you need to use the reference across calls to code that
might cause the count of the reference you borrowed to be
decremented. You must always call <TT>Py_DECREF</TT> before
abandoning or overwriting references that you own, but never on
references you don't own. Therefore, understanding
which interactions transfer reference ownership and which ones rely
on reference borrowing is absolutely crucial. For most functions in
the C API, and for all functions that you write and Python calls, the
following general rules apply:</P>

<span style="font-weight:bold"><OL class="docList" TYPE="1">
<LI><span style="font-weight:normal"><P class="docList"><TT>PyObject*</TT> arguments are borrowed references</P></span></LI>
<LI><span style="font-weight:normal"><P class="docList">A <TT>PyObject*</TT> returned as the
function's result transfers ownership</P></span></LI>
</OL></span>
<P class="docText">For each of the two rules, there are occasional exceptions.
<TT>PyList_SetItem</TT> and
<TT>PyTuple_SetItem</TT> <I>steal</I> a
reference to the item they are setting (but not to the list or tuple
object into which they're setting it). So do the
faster versions of these two functions that exist as C preprocessor
macros, <TT>PyList_SET_ITEM</TT> and
<TT>PyTuple_SET_ITEM</TT>. So does
<TT>PyModule_AddObject</TT>, covered earlier in this
chapter. There are no other exceptions to the first rule. The
rationale for these exceptions, which may help you remember them, is
that the object you're setting is most often one you
created for the purpose, so the reference-stealing semantics save you
from having to call <TT>Py_DECREF</TT> immediately
afterward.</P>

<P class="docText">The second rule has more exceptions than the first one: there are
several cases in which the returned <TT>PyObject*</TT> is a
borrowed reference rather than a new reference. The abstract
functions, whose names begin with <TT>PyObject_</TT>,
<TT>PySequence_</TT>, <TT>PyMapping_</TT>, and
<TT>PyNumber_</TT>, return new references. This is because
you can call them on objects of many types, and there might not be
any other reference to the resulting object that they return (i.e.,
the returned object might be created on the fly). The concrete
functions, whose names begin with <TT>PyList_</TT>,
<TT>PyTuple_</TT>, <TT>PyDict_</TT>, and so on,
return a borrowed reference when the semantics of the object they
return ensure that there must be some other reference to the returned
object somewhere.</P>

<P class="docText">In this chapter, I indicate all cases of exceptions to these rules
(i.e., the return of borrowed references and the rare cases of
reference stealing from arguments) regarding all functions that I
cover. When I don't explicitly mention a function as
being an exception, it means that the function follows the rules: its
<TT>PyObject*</TT> arguments, if any, are borrowed
references, and its <TT>PyObject*</TT> result, if any, is a
new reference.</P>


<A NAME="pythonian-CHP-24-SECT-1.6"></A>
<H4 class="docSection2Title">24.1.6 Accessing Arguments</H4>

<P class="docText"><A NAME="pythonian-CHP-24-ITERM-9249"></A>A
function that has <TT>ml_flags</TT> in its
<TT>PyMethodDef</TT> set to <TT>METH_NOARGS</TT>
is called from Python with no arguments. The corresponding C function
has a signature with only one argument,
<TT><I>self</I></TT>. When <TT>ml_flags</TT> is
<TT>METH_O</TT>, Python code must call the function with
one argument. The C function's second argument is a
borrowed reference to the object that the Python caller passes as the
argument's value.</P>

<P class="docText">When <TT>ml_flags</TT> is <TT>METH_VARARGS</TT>,
Python code can call the function with any number of positional
arguments, which are collected as a tuple. The C
function's second argument is a borrowed reference
to the tuple. Your C code can then call the
<TT>PyArg_ParseTuple</TT> function.</P>

<A NAME="ch24-13-fm2xml"></A><A NAME="pythonian-CHP-24-ITERM-9250"></A><table width="515" border="0" cellpadding="5">
<tr>
<td align="left"><b><i>PyArg_ParseTuple</i></b></td>
<td align="right"></td>
</tr>
</table>
<hr width="515" size="3" noshade="true" align="left" color="black">
<table width="515" border="0" cellpadding="5">
<tr>
<td align="left">
<pre>int PyArg_ParseTuple(PyObject* <TT><I>tuple</I></TT>,char* <TT><I>format</I></TT>,...)</pre>
</td>
<td align="right"></td>
</tr>
</table>
<P class="docText">Returns <TT>0</TT> for errors, a value not equal to
<TT>0</TT> for success. <TT><I>tuple</I></TT> is
the <TT>PyObject*</TT> that was the C
function's second argument.
<TT><I>format</I></TT> is a C string that describes
mandatory and optional arguments. The following arguments of
<TT>PyArg_ParseTuple</TT> are the addresses of the C
variables in which to put the values extracted from the tuple. Any
<TT>PyObject*</TT> variables among the C variables are
borrowed references. <A class="docLink" HREF="#pythonian-CHP-24-TABLE-1">Table 24-1</A> lists the commonly
used code strings, of which zero or more are joined to form string
<TT><I>format</I></TT>.</P>

<A NAME="pythonian-CHP-24-TABLE-1"></A><P><TABLE BORDER="1" CELLSPACING="0" CELLPADDING="1" WIDTH="100%">
<CAPTION><h5 class="docTableTitle">Table 24-1. Format codes for PyArg_ParseTuple</h5></CAPTION><COLGROUP span="3">
<TR>
<TH class="docTableHeader">
<P class="docText">Code</P>
</TH>
<TH class="docTableHeader">
<P class="docText">C type</P>
</TH>
<TH class="docTableHeader">
<P class="docText">Meaning</P>
</TH>
</TR>
<TR>
<TD class="docTableCell">
<PRE>c</PRE>
</TD>
<TD class="docTableCell">
<PRE>char</PRE>
</TD>
<TD class="docTableCell">
<P class="docText">A Python string of length <TT>1</TT> becomes a C
<TT>char</TT></P>
</TD>
</TR>
<TR>
<TD class="docTableCell">
<PRE>d</PRE>
</TD>
<TD class="docTableCell">
<PRE>double</PRE>
</TD>
<TD class="docTableCell">
<P class="docText">A Python <TT>float</TT> becomes a C
<TT>double</TT></P>
</TD>
</TR>
<TR>
<TD class="docTableCell">
<PRE>D</PRE>
</TD>
<TD class="docTableCell">
<PRE>Py_Complex</PRE>
</TD>
<TD class="docTableCell">
<P class="docText">A Python <TT>complex</TT> becomes a C
<TT>Py_Complex</TT></P>
</TD>
</TR>
<TR>
<TD class="docTableCell">
<PRE>f</PRE>
</TD>
<TD class="docTableCell">
<PRE>float</PRE>
</TD>
<TD class="docTableCell">
<P class="docText">A Python <TT>float</TT> becomes a C <TT>float</TT></P>
</TD>
</TR>
<TR>
<TD class="docTableCell">
<PRE>i</PRE>
</TD>
<TD class="docTableCell">
<PRE>int</PRE>
</TD>
<TD class="docTableCell">
<P class="docText">A Python <TT>int</TT> becomes a C <TT>int</TT></P>
</TD>
</TR>
<TR>
<TD class="docTableCell">
<PRE>l</PRE>
</TD>
<TD class="docTableCell">
<PRE>long</PRE>
</TD>
<TD class="docTableCell">
<P class="docText">A Python <TT>int</TT> becomes a C <TT>long</TT></P>
</TD>
</TR>
<TR>
<TD class="docTableCell">
<PRE>L</PRE>
</TD>
<TD class="docTableCell">
<PRE>long long</PRE>
</TD>
<TD class="docTableCell">
<P class="docText">A Python <TT>int</TT> becomes a C <TT>long</TT>
<TT>long</TT> (or <TT>_int64</TT> on Windows)</P>
</TD>
</TR>
<TR>
<TD class="docTableCell">
<PRE>O</PRE>
</TD>
<TD class="docTableCell">
<PRE>PyObject*</PRE>
</TD>
<TD class="docTableCell">
<P class="docText">Gets non-<TT>NULL</TT> borrowed reference to a Python
argument</P>
</TD>
</TR>
<TR>
<TD class="docTableCell">
<PRE>O!</PRE>
</TD>
<TD class="docTableCell">
<PRE>type + PyObject*</PRE>
</TD>
<TD class="docTableCell">
<P class="docText">Like code <TT>O</TT>, plus type checking or
<TT>TypeError</TT> (see below)</P>
</TD>
</TR>
<TR>
<TD class="docTableCell">
<PRE>O&amp;</PRE>
</TD>
<TD class="docTableCell">
<PRE>convert + void*</PRE>
</TD>
<TD class="docTableCell">
<P class="docText">Arbitrary conversion (see below)</P>
</TD>
</TR>
<TR>
<TD class="docTableCell">
<PRE>s</PRE>
</TD>
<TD class="docTableCell">
<PRE>char*</PRE>
</TD>
<TD class="docTableCell">
<P class="docText">Python string without embedded nulls to C <TT>char*</TT></P>
</TD>
</TR>
<TR>
<TD class="docTableCell">
<PRE>s#</PRE>
</TD>
<TD class="docTableCell">
<PRE>char* + int</PRE>
</TD>
<TD class="docTableCell">
<P class="docText">Any Python string to C address and length</P>
</TD>
</TR>
<TR>
<TD class="docTableCell">
<PRE>t#</PRE>
</TD>
<TD class="docTableCell">
<PRE>char* + int</PRE>
</TD>
<TD class="docTableCell">
<P class="docText">Read-only single-segment buffer to C address and length</P>
</TD>
</TR>
<TR>
<TD class="docTableCell">
<PRE>u</PRE>
</TD>
<TD class="docTableCell">
<PRE>Py_UNICODE*</PRE>
</TD>
<TD class="docTableCell">
<P class="docText">Python Unicode without embedded nulls to C (UTF-16)</P>
</TD>
</TR>
<TR>
<TD class="docTableCell">
<PRE>u#</PRE>
</TD>
<TD class="docTableCell">
<PRE>Py_UNICODE* + int</PRE>
</TD>
<TD class="docTableCell">
<P class="docText">Any Python Unicode C (UTF-16) address and length</P>
</TD>
</TR>
<TR>
<TD class="docTableCell">
<PRE>w#</PRE>
</TD>
<TD class="docTableCell">
<PRE>char* + int</PRE>
</TD>
<TD class="docTableCell">
<P class="docText">Read-write single-segment buffer to C address and length</P>
</TD>
</TR>
<TR>
<TD class="docTableCell">
<PRE>z</PRE>
</TD>
<TD class="docTableCell">
<PRE>char*</PRE>
</TD>
<TD class="docTableCell">
<P class="docText">Like code <TT>s</TT>, also accepts <TT>None</TT>
(sets C's <TT>char*</TT> to
<TT>NULL</TT>)</P>
</TD>
</TR>
<TR>
<TD class="docTableCell">
<PRE>z#</PRE>
</TD>
<TD class="docTableCell">
<PRE>char* + int</PRE>
</TD>
<TD class="docTableCell">
<P class="docText">Like code <TT>s#</TT>, also accepts <TT>None</TT>
(sets C's <TT>char*</TT> to
<TT>NULL</TT>)</P>
</TD>
</TR>
<TR>
<TD class="docTableCell">
<PRE>(...)</PRE>
</TD>
<TD class="docTableCell">
<P class="docText">as per <TT>..</TT>.</P>
</TD>
<TD class="docTableCell">
<P class="docText">A Python sequence is treated as one argument per item</P>
</TD>
</TR>
<TR>
<TD class="docTableCell">
<PRE>|</PRE>
</TD>
<TD class="docTableCell">&nbsp;</TD>
<TD class="docTableCell">
<P class="docText">The following arguments are optional</P>
</TD>
</TR>
<TR>
<TD class="docTableCell">
<PRE>:</PRE>
</TD>
<TD class="docTableCell">&nbsp;</TD>
<TD class="docTableCell">
<P class="docText">Format finished, followed by function name for error messages</P>
</TD>
</TR>
<TR>
<TD class="docTableCell">
<PRE>;</PRE>
</TD>
<TD class="docTableCell">&nbsp;</TD>
<TD class="docTableCell">
<P class="docText">Format finished, followed by entire error message text</P>
</TD>
</TR>
</COLGROUP>
</TABLE></P>

<P class="docText">Code formats <TT>d</TT> to <TT>L</TT> accept
numeric arguments from Python. Python coerces the corresponding
values. For example, a code of <TT>i</TT> can correspond to
a Python <TT>float</TT>—the fractional part gets
truncated, as if built-in function <TT>int</TT> had been
called. <TT>Py_Complex</TT> is a C struct with two fields
named <TT>real</TT> and <TT>imag</TT>, both of
type <TT>double</TT>.</P>

<P class="docText"><TT>O</TT> is the most general format code and accepts any
argument, which you can later check and/or convert as needed. Variant
<TT>O!</TT> corresponds to two arguments in the variable
arguments: first the address of a Python type object, then the
address of a <TT>PyObject*</TT>. <TT>O!</TT>
checks that the corresponding value belongs to the given type (or any
subtype of that type) before setting the <TT>PyObject*</TT>
to point to the value. Variant <TT>O&amp;</TT> also
corresponds to two arguments in the variable arguments: first the
address of a converter function you coded, then a
<TT>void*</TT> (i.e., any address at all). The converter
function must have signature <TT>int</TT>
<TT><I>convert</I></TT><TT>(PyObject*</TT>,
<TT>void*)</TT>. Python calls your conversion function with
the value passed from Python as the first argument and the
<TT>void*</TT> from the variable arguments as the second
argument. The conversion function must either return
<TT>0</TT> and raise an exception (as covered in <A class="docLink" HREF="#pythonian-CHP-24-SECT-1.8">Section 24.1.8</A> later in this chapter) to
indicate an error, or return <TT>1</TT> and store whatever
is appropriate via the <TT>void*</TT> it gets.</P>

<P class="docText">Code format <TT>s</TT> accepts a string from Python and the
address of a <TT>char*</TT> (i.e., a
<TT>char**</TT>) among the variable arguments. It changes
the <TT>char*</TT> to point at the
string's buffer, which your C code must then treat
as a read-only, null-terminated array of <TT>char</TT>s
(i.e., a typical C string; however, your code must not modify it).
The Python string must contain no embedded null characters.
<TT>s#</TT> is similar, but corresponds to two arguments
among the variable arguments: first the address of a
<TT>char*</TT>, then the address of an
<TT>int</TT> to set to the string's
length. The Python string can contain embedded nulls, and therefore
so can the buffer to which the <TT>char*</TT> is set to
point. <TT>u</TT> and <TT>u#</TT> are similar,
but accept any Unicode string, and the C-side pointers must be
<TT>Py_UNICODE*</TT> rather than <TT>char*</TT>.
<TT>Py_UNICODE</TT> is a macro defined in
<I>Python.h</I>, and corresponds to the type of a
Python Unicode character in the implementation (this is often, but
not always, the same as a <TT>wchar_t</TT> in C).</P>

<P class="docText"><TT>t#</TT> and <TT>w#</TT> are similar to
<TT>s#</TT>, but the corresponding Python argument can be
any object of a type that respects the buffer protocol, respectively
read-only and read-write. Strings are a typical example of read-only
buffers. <TT>mmap</TT> and <TT>array</TT>
instances are typical examples of read-write buffers, and they are
also acceptable where a read-only buffer is required (i.e., for a
<TT>t#</TT>).</P>

<P class="docText">When one of the arguments is a Python sequence of known length, you
can use format codes for each of its items, and corresponding C
addresses among the variable arguments, by grouping the format codes
in parentheses. For example, code <TT>(ii)</TT> corresponds
to a Python sequence of two numbers, and, among the remaining
arguments, corresponds to two addresses of <TT>int</TT>s.</P>

<P class="docText">The format string may include a vertical bar (<TT>|</TT>)
to indicate that all following arguments are optional. You must
initialize the C variables, whose addresses you pass among the
variable arguments for later arguments, to suitable default values
before you call <TT>PyArg_ParseTuple</TT>.
<TT>PyArg_ParseTuple</TT> does not change the C variables
corresponding to optional arguments that were not passed in a given
call from Python to your C-coded function.</P>

<P class="docText">The format string may optionally end with
:<TT><I>name</I></TT> to indicate that
<TT><I>name</I></TT> must be used as the function name if
any error messages are needed. Alternatively, the format string may
end with <TT>;</TT><TT><I>text</I></TT> to
indicate that <TT><I>text</I></TT> must be used as the
entire error message if <TT>PyArg_ParseTuple</TT> detects
errors (this is rarely used).</P>

<P class="docText">A function that has <TT>ml_flags</TT> in its
<TT>PyMethodDef</TT> set to
<TT>METH_KEYWORDS</TT> accepts positional and keyword
arguments. Python code calls the function with any number of
positional arguments, which get collected as a tuple, and keyword
arguments, which get collected as a dictionary. The C
function's second argument is a borrowed reference
to the tuple, and the third one is a borrowed reference to the
dictionary. Your C code then calls the
<TT>PyArg_ParseTupleAndKeywords</TT> function.</P>

<A NAME="ch24-14-fm2xml"></A><A NAME="pythonian-CHP-24-ITERM-9251"></A><table width="515" border="0" cellpadding="5">
<tr>
<td align="left"><b><i>PyArg_ParseTupleAndKeywords</i></b></td>
<td align="right"></td>
</tr>
</table>
<hr width="515" size="3" noshade="true" align="left" color="black">
<table width="515" border="0" cellpadding="5">
<tr>
<td align="left">
<pre>int PyArg_ParseTupleAndKeywords(PyObject* <TT><I>tuple</I></TT>,PyObject* <TT><I>dict</I></TT>, 
char* <TT><I>format</I></TT>,char** <TT><I>kwlist</I></TT>,...)</pre>
</td>
<td align="right"></td>
</tr>
</table>
<P class="docText">Returns <TT>0</TT> for errors, a value not equal to
<TT>0</TT> for success. <TT><I>tuple</I></TT> is
the <TT>PyObject*</TT> that was the C
function's second argument.
<TT><I>dict</I></TT> is the <TT>PyObject*</TT>
that was the C function's third argument.
<TT><I>format</I></TT> is like for
<TT>PyArg_ParseTuple</TT>, except that it cannot include
the <TT>(...)</TT> format code to parse nested sequences.
<TT><I>kwlist</I></TT> is an array of
<TT>char*</TT> terminated by a <TT>NULL</TT>
sentinel, with the names of the parameters, one after the other. For
example, the following C code:</P>
<PRE>static PyObject*
func_c(PyObject* self, PyObject* args, PyObject* kwds)
{
    static char* argnames[] = {"x", "y", "z", NULL};
    double x, y=0.0, z=0.0;
    if(!PyArg_ParseTupleAndKeywords(
        args,kwds,"d|dd",argnames,&amp;x,&amp;y,&amp;z))
        return NULL;
    /* rest of function snipped */</PRE><P class="docText">is roughly equivalent to this Python code:</P>
<PRE>def func_py(x, y=0.0, z=0.0):
    x, y, z = map(float, (x,y,z))
    # rest of function snipped</PRE>


<A NAME="pythonian-CHP-24-SECT-1.7"></A>
<H4 class="docSection2Title">24.1.7 Creating Python Values</H4>

<P class="docText"><A NAME="pythonian-CHP-24-ITERM-9252"></A>C functions that communicate with Python
must often build Python values, both to return as their
<TT>PyObject*</TT> result and for other purposes, such as
setting items and attributes. The simplest and handiest way to build
a Python value is most often with the
<TT>Py_BuildValue</TT> function.</P>

<A NAME="ch24-15-fm2xml"></A><A NAME="pythonian-CHP-24-ITERM-9253"></A><table width="515" border="0" cellpadding="5">
<tr>
<td align="left"><b><i>Py_BuildValue</i></b></td>
<td align="right"></td>
</tr>
</table>
<hr width="515" size="3" noshade="true" align="left" color="black">
<table width="515" border="0" cellpadding="5">
<tr>
<td align="left">
<pre>PyObject* Py_BuildValue(char* <TT><I>format</I></TT>,...)</pre>
</td>
<td align="right"></td>
</tr>
</table>
<P class="docText"><TT><I>format</I></TT> is a C string that describes the
Python object to build. The following arguments of
<TT>Py_BuildValue</TT> are C values from which the result
is built. The <TT>PyObject*</TT> result is a new reference.
<A class="docLink" HREF="#pythonian-CHP-24-TABLE-2">Table 24-2</A> lists the commonly used code strings, of
which zero or more are joined into string
<TT><I>format</I></TT>. <TT>Py_BuildValue</TT>
builds and returns a tuple if <TT><I>format</I></TT>
contains two or more format codes, or if
<TT><I>format</I></TT> begins with <TT>(</TT>
and ends with <TT>)</TT>. Otherwise, the result is not a
tuple. When you pass buffers, as for example in the case of format
code <TT>s#</TT>, <TT>Py_BuildValue</TT> copies
the data. You can therefore modify, abandon, or <TT>free(
)</TT> your original copy of the data after
<TT>Py_BuildValue</TT> returns.
<TT>Py_BuildValue</TT> always returns a new reference
(except for format code <TT>N</TT>). Called with an empty
<TT><I>format</I></TT>,
<TT>Py_BuildValue("")</TT> returns a new reference to
<TT>None</TT>.</P>

<A NAME="pythonian-CHP-24-TABLE-2"></A><P><TABLE BORDER="1" CELLSPACING="0" CELLPADDING="1" WIDTH="100%">
<CAPTION><h5 class="docTableTitle">Table 24-2. Format codes for Py_BuildValue</h5></CAPTION><COLGROUP span="3">
<TR>
<TH class="docTableHeader">
<P class="docText">Code</P>
</TH>
<TH class="docTableHeader">
<P class="docText">C type</P>
</TH>
<TH class="docTableHeader">
<P class="docText">Meaning</P>
</TH>
</TR>
<TR>
<TD class="docTableCell">
<PRE>c</PRE>
</TD>
<TD class="docTableCell">
<PRE>char</PRE>
</TD>
<TD class="docTableCell">
<P class="docText">A C <TT>char</TT> becomes a Python string of length
<TT>1</TT></P>
</TD>
</TR>
<TR>
<TD class="docTableCell">
<PRE>d</PRE>
</TD>
<TD class="docTableCell">
<PRE>double</PRE>
</TD>
<TD class="docTableCell">
<P class="docText">A C <TT>double</TT> becomes a Python
<TT>float</TT></P>
</TD>
</TR>
<TR>
<TD class="docTableCell">
<PRE>D</PRE>
</TD>
<TD class="docTableCell">
<PRE>Py_Complex</PRE>
</TD>
<TD class="docTableCell">
<P class="docText">A C <TT>Py_Complex</TT> becomes a Python
<TT>complex</TT></P>
</TD>
</TR>
<TR>
<TD class="docTableCell">
<PRE>i</PRE>
</TD>
<TD class="docTableCell">
<PRE>int</PRE>
</TD>
<TD class="docTableCell">
<P class="docText">A C <TT>int</TT> becomes a Python <TT>int</TT></P>
</TD>
</TR>
<TR>
<TD class="docTableCell">
<PRE>l</PRE>
</TD>
<TD class="docTableCell">
<PRE>long</PRE>
</TD>
<TD class="docTableCell">
<P class="docText">A C <TT>long</TT> becomes a Python <TT>int</TT></P>
</TD>
</TR>
<TR>
<TD class="docTableCell">
<PRE>N</PRE>
</TD>
<TD class="docTableCell">
<PRE>PyObject*</PRE>
</TD>
<TD class="docTableCell">
<P class="docText">Passes a Python object and steals a reference</P>
</TD>
</TR>
<TR>
<TD class="docTableCell">
<PRE>O</PRE>
</TD>
<TD class="docTableCell">
<PRE>PyObject*</PRE>
</TD>
<TD class="docTableCell">
<P class="docText">Passes a Python object and <TT>INCREF</TT>s it as per
normal rules</P>
</TD>
</TR>
<TR>
<TD class="docTableCell">
<PRE>O&amp;</PRE>
</TD>
<TD class="docTableCell">
<PRE>convert + void*</PRE>
</TD>
<TD class="docTableCell">
<P class="docText">Arbitrary conversion (see below)</P>
</TD>
</TR>
<TR>
<TD class="docTableCell">
<PRE>s</PRE>
</TD>
<TD class="docTableCell">
<PRE>char*</PRE>
</TD>
<TD class="docTableCell">
<P class="docText">C null-terminated <TT>char*</TT> to Python string, or
<TT>NULL</TT> to <TT>None</TT></P>
</TD>
</TR>
<TR>
<TD class="docTableCell">
<PRE>s#</PRE>
</TD>
<TD class="docTableCell">
<PRE>char* + int</PRE>
</TD>
<TD class="docTableCell">
<P class="docText">C <TT>char*</TT> and length to Python string, or
<TT>NULL</TT> to <TT>None</TT></P>
</TD>
</TR>
<TR>
<TD class="docTableCell">
<PRE>u</PRE>
</TD>
<TD class="docTableCell">
<PRE>Py_UNICODE*</PRE>
</TD>
<TD class="docTableCell">
<P class="docText">C wide (UCS-2) null-terminated string to Python Unicode, or
<TT>NULL</TT> to <TT>None</TT></P>
</TD>
</TR>
<TR>
<TD class="docTableCell">
<PRE>u#</PRE>
</TD>
<TD class="docTableCell">
<PRE>Py_UNICODE* + int</PRE>
</TD>
<TD class="docTableCell">
<P class="docText">C wide (UCS-2) string and length to Python Unicode, or
<TT>NULL</TT> to <TT>None</TT></P>
</TD>
</TR>
<TR>
<TD class="docTableCell">
<PRE>(...)</PRE>
</TD>
<TD class="docTableCell">
<P class="docText">as per <TT>..</TT>.</P>
</TD>
<TD class="docTableCell">
<P class="docText">Build Python tuple from C values</P>
</TD>
</TR>
<TR>
<TD class="docTableCell">
<PRE>[...]</PRE>
</TD>
<TD class="docTableCell">
<P class="docText">as per <TT>..</TT>.</P>
</TD>
<TD class="docTableCell">
<P class="docText">Build Python list from C values</P>
</TD>
</TR>
<TR>
<TD class="docTableCell">
<PRE>{...}</PRE>
</TD>
<TD class="docTableCell">
<P class="docText">as per <TT>..</TT>.</P>
</TD>
<TD class="docTableCell">
<P class="docText">Build Python dictionary from C values, alternating keys and values
(must be an even number of C values)</P>
</TD>
</TR>
</COLGROUP>
</TABLE></P>

<P class="docText">Code <TT>O&amp;</TT> corresponds to two arguments among the
variable arguments: first the address of a converter function you
code, then a <TT>void*</TT> (i.e., any address at all). The
converter function must have signature <TT>PyObject*</TT>
<TT><I>convert</I></TT><TT>(void*)</TT>. Python
calls the conversion function with the <TT>void*</TT> from
the variable arguments as the only argument. The conversion function
must either return <TT>NULL</TT> and raise an exception (as
covered in <A class="docLink" HREF="#pythonian-CHP-24-SECT-1.8">Section 24.1.8</A> later in
this chapter) to indicate an error, or return a new reference
<TT>PyObject*</TT> built from the data in the
<TT>void*</TT>.</P>

<P class="docText">Code <TT>{...}</TT> builds dictionaries from an even number
of C values, alternately keys and values. For example,
<TT>Py_BuildValue("{issi}",23,"zig","zag",42)</TT> returns
a dictionary like Python's
<TT>{23:'zig','zag':42}</TT>.</P>

<P class="docText">Note the important difference between codes <TT>N</TT> and
<TT>O</TT>. <TT>N</TT> steals a reference from
the <TT>PyObject*</TT> corresponding value among the
variable arguments, so it's convenient when
you're building an object including a reference you
own that you would otherwise have to <TT>Py_DECREF</TT>.
<TT>O</TT> does no reference stealing, so
it's appropriate when you're
building an object including a reference you don't
own, or a reference you must also keep elsewhere.</P>


<A NAME="pythonian-CHP-24-SECT-1.8"></A>
<H4 class="docSection2Title">24.1.8 Exceptions</H4>

<P class="docText"><A NAME="pythonian-CHP-24-ITERM-9254"></A>
<A NAME="pythonian-CHP-24-ITERM-9255"></A>To propagate exceptions raised from
other functions you call, return <TT>NULL</TT> as the
<TT>PyObject*</TT> result from your C function. To raise
your own exceptions, set the current-exception indicator and return
<TT>NULL</TT>. Python's built-in exception
classes (covered in <A class="docLink" HREF="0596001886_pythonian-chp-6.html#pythonian-CHP-6">Chapter 6</A>) are globally
available, with names starting with <TT>PyExc_</TT>, such
as <TT>PyExc_AttributeError</TT>,
<TT>PyExc_KeyError</TT>, and so on. Your extension module
can also supply and use its own exception classes. The most commonly
used C API functions related to raising exceptions are the following.</P>

<A NAME="ch24-16-fm2xml"></A><A NAME="pythonian-CHP-24-ITERM-9256"></A><table width="515" border="0" cellpadding="5">
<tr>
<td align="left"><b><i>PyErr_Format</i></b></td>
<td align="right"></td>
</tr>
</table>
<hr width="515" size="3" noshade="true" align="left" color="black">
<table width="515" border="0" cellpadding="5">
<tr>
<td align="left">
<pre>PyObject* PyErr_Format(PyObject* <TT><I>type</I></TT>,char* <TT><I>format</I></TT>,...)</pre>
</td>
<td align="right"></td>
</tr>
</table>
<P class="docText"><A NAME="pythonian-CHP-24-ITERM-9256"></A>Raises an exception of class
<TT><I>type</I></TT>, a built-in such as
<TT>PyExc_IndexError</TT>, or an exception class created
with <TT>PyErr_NewException</TT>. Builds the associated
value from format string <TT><I>format</I></TT>, which has
syntax similar to <TT>printf</TT>'s, and
the following C values indicated as variable arguments above. Returns
<TT>NULL</TT>, so your code can just call:</P>
<PRE>return PyErr_Format(PyExc_KeyError, 
    "Unknown key name (%s)", thekeystring);</PRE>

<A NAME="ch24-17-fm2xml"></A><A NAME="pythonian-CHP-24-ITERM-9257"></A><table width="515" border="0" cellpadding="5">
<tr>
<td align="left"><b><i>PyErr_NewException</i></b></td>
<td align="right"></td>
</tr>
</table>
<hr width="515" size="3" noshade="true" align="left" color="black">
<table width="515" border="0" cellpadding="5">
<tr>
<td align="left">
<pre>PyObject* PyErr_NewException(char* <TT><I>name</I></TT>,PyObject* <TT><I>base</I></TT>,PyObject* <TT><I>dict</I></TT>)</pre>
</td>
<td align="right"></td>
</tr>
</table>
<P class="docText">Subclasses exception class <TT><I>base</I></TT>, with
extra class attributes and methods from dictionary
<TT><I>dict</I></TT> (normally <TT>NULL</TT>,
meaning no extra class attributes or methods), creating a new
exception class named <TT><I>name</I></TT> (string
<TT><I>name</I></TT> must be of the form
"<TT><I>modulename</I></TT>.<TT><I>classname</I></TT>")
and returning a new reference to the new class object. When
<TT><I>base</I></TT> is <TT>NULL</TT>, uses
<TT>PyExc_Exception</TT> as the base class. You normally
call this function during initialization of a module object
<TT><I>module</I></TT>. For example:</P>
<PRE>PyModule_AddObject(module, "error", 
    PyErr_NewException("mymod.error", NULL, NULL));</PRE>

<A NAME="ch24-18-fm2xml"></A><A NAME="pythonian-CHP-24-ITERM-9258"></A><table width="515" border="0" cellpadding="5">
<tr>
<td align="left"><b><i>PyErr_NoMemory</i></b></td>
<td align="right"></td>
</tr>
</table>
<hr width="515" size="3" noshade="true" align="left" color="black">
<table width="515" border="0" cellpadding="5">
<tr>
<td align="left">
<pre>PyObject* PyErr_NoMemory(  )</pre>
</td>
<td align="right"></td>
</tr>
</table>
<P class="docText"><A NAME="pythonian-CHP-24-ITERM-9258"></A>Raises an out-of-memory error and returns
<TT>NULL</TT>, so your code can just call:</P>
<PRE>return PyErr_NoMemory(  );</PRE>

<A NAME="ch24-19-fm2xml"></A><A NAME="pythonian-CHP-24-ITERM-9259"></A><table width="515" border="0" cellpadding="5">
<tr>
<td align="left"><b><i>PyErr_SetObject</i></b></td>
<td align="right"></td>
</tr>
</table>
<hr width="515" size="3" noshade="true" align="left" color="black">
<table width="515" border="0" cellpadding="5">
<tr>
<td align="left">
<pre>void PyErr_SetObject(PyObject* <TT><I>type</I></TT>,PyObject* <TT><I>value</I></TT>)</pre>
</td>
<td align="right"></td>
</tr>
</table>
<P class="docText">Raises an exception of class <TT><I>type</I></TT>, a
built-in such as <TT>PyExc_KeyError</TT>, or an exception
class created with <TT>PyErr_NewException</TT>, with
<TT><I>value</I></TT> as the associated value (a borrowed
reference). <TT>PyErr_SetObject</TT> is a
<TT>void</TT> function (i.e., returns no value).</P>

<A NAME="ch24-20-fm2xml"></A><A NAME="pythonian-CHP-24-ITERM-9260"></A><table width="515" border="0" cellpadding="5">
<tr>
<td align="left"><b><i>PyErr_SetFromErrno</i></b></td>
<td align="right"></td>
</tr>
</table>
<hr width="515" size="3" noshade="true" align="left" color="black">
<table width="515" border="0" cellpadding="5">
<tr>
<td align="left">
<pre>PyObject* PyErr_SetFromErrno(PyObject* <TT><I>type</I></TT>)</pre>
</td>
<td align="right"></td>
</tr>
</table>
<P class="docText">Raises an exception of class <TT><I>type</I></TT>, a
built-in such as <TT>PyExc_OSError</TT>, or an exception
class created with <TT>PyErr_NewException</TT>. Takes all
details from global variable <TT>errno</TT>, which C
library functions and system calls set for many error cases, and the
standard C library function <TT>strerror</TT>. Returns
<TT>NULL</TT>, so your code can just call:</P>
<PRE>return PyErr_SetFromErrno(PyExc_IOError);</PRE>

<A NAME="ch24-21-fm2xml"></A><A NAME="pythonian-CHP-24-ITERM-9261"></A><table width="515" border="0" cellpadding="5">
<tr>
<td align="left"><b><i>PyErr_SetFromErrnoWithFilename</i></b></td>
<td align="right"></td>
</tr>
</table>
<hr width="515" size="3" noshade="true" align="left" color="black">
<table width="515" border="0" cellpadding="5">
<tr>
<td align="left">
<pre>PyObject* PyErr_SetFromErrnoWithFilename(PyObject* <TT><I>type</I></TT>,char* <TT><I>filename</I></TT>)</pre>
</td>
<td align="right"></td>
</tr>
</table>
<P class="docText">Like <TT>PyErr_SetFromErrno</TT>, but also provides string
<TT><I>filename</I></TT> as part of the
exception's value. When
<TT><I>filename</I></TT> is <TT>NULL</TT>, works
like <TT>PyErr_SetFromErrno</TT>.</P>

<P class="docText">Your C code may want to deal with an exception and continue, as a
<TT>try</TT>/<TT>except</TT> statement would let
you do in Python code. The most commonly used C API functions related
to catching exceptions are the following.</P>

<A NAME="ch24-22-fm2xml"></A><A NAME="pythonian-CHP-24-ITERM-9262"></A><table width="515" border="0" cellpadding="5">
<tr>
<td align="left"><b><i>PyErr_Clear</i></b></td>
<td align="right"></td>
</tr>
</table>
<hr width="515" size="3" noshade="true" align="left" color="black">
<table width="515" border="0" cellpadding="5">
<tr>
<td align="left">
<pre>void PyErr_Clear(  )</pre>
</td>
<td align="right"></td>
</tr>
</table>
<P class="docText"><A NAME="pythonian-CHP-24-ITERM-9262"></A>Clears the error indicator. Innocuous if no
error is pending.</P>

<A NAME="ch24-23-fm2xml"></A><A NAME="pythonian-CHP-24-ITERM-9263"></A><table width="515" border="0" cellpadding="5">
<tr>
<td align="left"><b><i>PyErr_ExceptionMatches</i></b></td>
<td align="right"></td>
</tr>
</table>
<hr width="515" size="3" noshade="true" align="left" color="black">
<table width="515" border="0" cellpadding="5">
<tr>
<td align="left">
<pre>int PyErr_ExceptionMatches(PyObject* <TT><I>type</I></TT>)</pre>
</td>
<td align="right"></td>
</tr>
</table>
<P class="docText"><A NAME="pythonian-CHP-24-ITERM-9263"></A>Call only when an error is pending, or the
whole program might crash. Returns a value not equal to
<TT>0</TT> when the pending exception is an instance of the
given <TT><I>type</I></TT> or any subclass of
<TT><I>type</I></TT>, or <TT>0</TT> when the
pending exception is not such an instance.</P>

<A NAME="ch24-24-fm2xml"></A><A NAME="pythonian-CHP-24-ITERM-9264"></A><table width="515" border="0" cellpadding="5">
<tr>
<td align="left"><b><i>PyErr_Occurred</i></b></td>
<td align="right"></td>
</tr>
</table>
<hr width="515" size="3" noshade="true" align="left" color="black">
<table width="515" border="0" cellpadding="5">
<tr>
<td align="left">
<pre>PyObject* PyErr_Occurred(  )</pre>
</td>
<td align="right"></td>
</tr>
</table>
<P class="docText">Returns <TT>NULL</TT> if no error is pending, otherwise a
borrowed reference to the type of the pending exception.
(Don't use the returned value; call
<TT>PyErr_ExceptionMatches</TT> instead, in order to catch
exceptions of subclasses as well, as is normal and expected.)</P>

<A NAME="ch24-25-fm2xml"></A><A NAME="pythonian-CHP-24-ITERM-9265"></A><table width="515" border="0" cellpadding="5">
<tr>
<td align="left"><b><i>PyErr_Print</i></b></td>
<td align="right"></td>
</tr>
</table>
<hr width="515" size="3" noshade="true" align="left" color="black">
<table width="515" border="0" cellpadding="5">
<tr>
<td align="left">
<pre>void PyErr_Print(  )</pre>
</td>
<td align="right"></td>
</tr>
</table>
<P class="docText">Call only when an error is pending, or the whole program might crash.
Outputs a standard traceback to <TT>sys.stderr</TT>, then
clears the error indicator.</P>

<P class="docText">If you need to process errors in highly sophisticated ways, study
other error-related functions of the C API, such as
<TT>PyErr_Fetch</TT>, <TT>PyErr_Normalize</TT>,
<TT>PyErr_GivenExceptionMatches</TT>, and
<TT>PyErr_Restore</TT>. However, I do not cover such
advanced and rarely needed possibilities in this book.</P>


<A NAME="pythonian-CHP-24-SECT-1.9"></A>
<H4 class="docSection2Title">24.1.9 Abstract Layer Functions</H4>

<P class="docText"><A NAME="pythonian-CHP-24-ITERM-9266"></A>The code for a C extension typically
needs to use some Python functionality. For example, your code may
need to examine or set attributes and items of Python objects, call
Python-coded and built-in functions and methods, and so on. In most
cases, the best approach is for your code to call functions from the
abstract layer of Python's C API. These are
functions that you can call on any Python object (functions whose
names start with <TT>PyObject_</TT>), or any object within
a wide category, such as mappings, numbers, or sequences (with names
respectively starting with <TT>PyMapping_</TT>,
<TT>PyNumber_</TT>, and <TT>PySequence_</TT>).</P>

<P class="docText">Some of the functions callable on objects within these categories
duplicate functionality that is also available from
<TT>PyObject_</TT> functions; in these cases, you should
use the <TT>PyObject_</TT> function instead. I
don't cover such redundant functions in this book.</P>

<P class="docText">Functions in the abstract layer raise Python exceptions if you call
them on objects to which they are not applicable. All of these
functions accept borrowed references for <TT>PyObject*</TT>
arguments, and return a new reference (<TT>NULL</TT> for an
exception) if they return a <TT>PyObject*</TT> result.</P>

<P class="docText">The most frequently used abstract layer functions are the following.</P>

<A NAME="ch24-27-fm2xml"></A><A NAME="pythonian-CHP-24-ITERM-9267"></A><table width="515" border="0" cellpadding="5">
<tr>
<td align="left"><b><i>PyCallable_Check</i></b></td>
<td align="right"></td>
</tr>
</table>
<hr width="515" size="3" noshade="true" align="left" color="black">
<table width="515" border="0" cellpadding="5">
<tr>
<td align="left">
<pre>int PyCallable_Check(PyObject* <TT><I>x</I></TT>)</pre>
</td>
<td align="right"></td>
</tr>
</table>
<P class="docText">True if <TT><I>x</I></TT> is callable, like
Python's
<TT>callable(</TT><TT><I>x</I></TT><TT>)</TT>.</P>

<A NAME="ch24-28-fm2xml"></A><A NAME="pythonian-CHP-24-ITERM-9268"></A><table width="515" border="0" cellpadding="5">
<tr>
<td align="left"><b><i>PyEval_CallObject</i></b></td>
<td align="right"></td>
</tr>
</table>
<hr width="515" size="3" noshade="true" align="left" color="black">
<table width="515" border="0" cellpadding="5">
<tr>
<td align="left">
<pre>PyObject* PyEval_CallObject(PyObject* <TT><I>x</I></TT>,PyObject* <TT><I>args</I></TT>)</pre>
</td>
<td align="right"></td>
</tr>
</table>
<P class="docText">Calls callable Python object <TT><I>x</I></TT> with the
positional arguments held in tuple <TT><I>args</I></TT>.
Returns the call's result, like
Python's <TT>return</TT>
<TT><I>x</I></TT><TT>(*</TT><TT><I>args</I></TT><TT>)</TT>.</P>

<A NAME="ch24-29-fm2xml"></A><A NAME="pythonian-CHP-24-ITERM-9269"></A><table width="515" border="0" cellpadding="5">
<tr>
<td align="left"><b><i>PyEval_CallObjectWithKeywords</i></b></td>
<td align="right"></td>
</tr>
</table>
<hr width="515" size="3" noshade="true" align="left" color="black">
<table width="515" border="0" cellpadding="5">
<tr>
<td align="left">
<pre>PyObject* PyEval_CallObjectWithKeywords(PyObject* <TT><I>x</I></TT>,PyObject* <TT><I>args</I></TT>,PyObject* <TT><I>kwds</I></TT>)</pre>
</td>
<td align="right"></td>
</tr>
</table>
<P class="docText">Calls callable Python object <TT><I>x</I></TT> with the
positional arguments held in tuple <TT><I>args</I></TT>
and the named arguments held in dictionary
<TT><I>kwds</I></TT> Returns the call's
result, like Python's <TT>return</TT>
<TT><I>x</I></TT><TT>(*</TT><TT><I>args</I></TT><TT>,**</TT><TT><I>kwds</I></TT><TT>)</TT>.</P>

<A NAME="ch24-30-fm2xml"></A><A NAME="pythonian-CHP-24-ITERM-9270"></A><table width="515" border="0" cellpadding="5">
<tr>
<td align="left"><b><i>PyIter_Check</i></b></td>
<td align="right"></td>
</tr>
</table>
<hr width="515" size="3" noshade="true" align="left" color="black">
<table width="515" border="0" cellpadding="5">
<tr>
<td align="left">
<pre>int PyIter_Check(PyObject* <TT><I>x</I></TT>)</pre>
</td>
<td align="right"></td>
</tr>
</table>
<P class="docText">True if <TT><I>x</I></TT> supports the iterator protocol
(i.e., if <TT><I>x</I></TT> is an iterator).</P>

<A NAME="ch24-31-fm2xml"></A><A NAME="pythonian-CHP-24-ITERM-9271"></A><table width="515" border="0" cellpadding="5">
<tr>
<td align="left"><b><i>PyIter_Next</i></b></td>
<td align="right"></td>
</tr>
</table>
<hr width="515" size="3" noshade="true" align="left" color="black">
<table width="515" border="0" cellpadding="5">
<tr>
<td align="left">
<pre>PyObject* PyIter_Next(PyObject* <TT><I>x</I></TT>)</pre>
</td>
<td align="right"></td>
</tr>
</table>
<P class="docText">Returns the next item from iterator <TT><I>x</I></TT>.
Returns <TT>NULL</TT> without raising any exception if
<TT><I>x</I></TT>'s iteration is finished
(i.e., when Python's
<TT><I>x</I></TT><TT>.next( )</TT> raises
<TT>StopIteration</TT>).</P>

<A NAME="ch24-32-fm2xml"></A><A NAME="pythonian-CHP-24-ITERM-9272"></A><table width="515" border="0" cellpadding="5">
<tr>
<td align="left"><b><i>PyNumber_Check</i></b></td>
<td align="right"></td>
</tr>
</table>
<hr width="515" size="3" noshade="true" align="left" color="black">
<table width="515" border="0" cellpadding="5">
<tr>
<td align="left">
<pre>int PyNumber_Check(PyObject* <TT><I>x</I></TT>)</pre>
</td>
<td align="right"></td>
</tr>
</table>
<P class="docText">True if <TT><I>x</I></TT> supports the number protocol
(i.e., if <TT><I>x</I></TT> is a number).</P>

<A NAME="ch24-33-fm2xml"></A><A NAME="pythonian-CHP-24-ITERM-9273"></A><table width="515" border="0" cellpadding="5">
<tr>
<td align="left"><b><i>PyObject_CallFunction</i></b></td>
<td align="right"></td>
</tr>
</table>
<hr width="515" size="3" noshade="true" align="left" color="black">
<table width="515" border="0" cellpadding="5">
<tr>
<td align="left">
<pre>PyObject* PyObject_CallFunction(PyObject* <TT><I>x</I></TT>,char* <TT><I>format</I></TT>,...)</pre>
</td>
<td align="right"></td>
</tr>
</table>
<P class="docText">Calls the callable Python object <TT><I>x</I></TT> with
positional arguments described by format string
<TT><I>format</I></TT>, using the same format codes as
<TT>Py_BuildValue</TT>, covered earlier. When
<TT><I>format</I></TT> is <TT>NULL</TT>, calls
<TT><I>x</I></TT> with no arguments. Returns the
call's result.</P>

<A NAME="ch24-34-fm2xml"></A><A NAME="pythonian-CHP-24-ITERM-9274"></A><table width="515" border="0" cellpadding="5">
<tr>
<td align="left"><b><i>PyObject_CallMethod</i></b></td>
<td align="right"></td>
</tr>
</table>
<hr width="515" size="3" noshade="true" align="left" color="black">
<table width="515" border="0" cellpadding="5">
<tr>
<td align="left">
<pre>PyObject* PyObject_CallMethod(PyObject* <TT><I>x</I></TT>,char* <TT><I>method</I></TT>,char* <TT><I>format</I></TT>,...)</pre>
</td>
<td align="right"></td>
</tr>
</table>
<P class="docText">Calls the method named <TT><I>method</I></TT> of Python
object <TT><I>x</I></TT> with positional arguments
described by format string <TT><I>format</I></TT>, using
the same format codes as <TT>Py_BuildValue</TT>. When
<TT><I>format</I></TT> is <TT>NULL</TT>, calls
the method with no arguments. Returns the call's
result.</P>

<A NAME="ch24-35-fm2xml"></A><A NAME="pythonian-CHP-24-ITERM-9275"></A><table width="515" border="0" cellpadding="5">
<tr>
<td align="left"><b><i>PyObject_Cmp</i></b></td>
<td align="right"></td>
</tr>
</table>
<hr width="515" size="3" noshade="true" align="left" color="black">
<table width="515" border="0" cellpadding="5">
<tr>
<td align="left">
<pre>int PyObject_Cmp(PyObject* <TT><I>x1</I></TT>,PyObject* <TT><I>x2</I></TT>,int* <TT><I>result</I></TT>)</pre>
</td>
<td align="right"></td>
</tr>
</table>
<P class="docText">Compares objects <TT><I>x1</I></TT> and
<TT><I>x2</I></TT> and places the result
(<TT>-1</TT>, <TT>0</TT>, or
<TT>1</TT>) in
<TT>*</TT><TT><I>result</I></TT>, like
Python's
<TT><I>result</I></TT><TT>=cmp(</TT><TT><I>x1</I></TT>,<TT><I>x2</I></TT><TT>)</TT>.</P>

<A NAME="ch24-36-fm2xml"></A><A NAME="pythonian-CHP-24-ITERM-9276"></A><table width="515" border="0" cellpadding="5">
<tr>
<td align="left"><b><i>PyObject_DelAttrString</i></b></td>
<td align="right"></td>
</tr>
</table>
<hr width="515" size="3" noshade="true" align="left" color="black">
<table width="515" border="0" cellpadding="5">
<tr>
<td align="left">
<pre>int PyObject_DelAttrString(PyObject* <TT><I>x</I></TT>,char* <TT><I>name</I></TT>)</pre>
</td>
<td align="right"></td>
</tr>
</table>
<P class="docText">Deletes <TT><I>x</I></TT>'s attribute
named <TT><I>name</I></TT>, like Python's
<TT>del</TT>
<TT><I>x</I></TT>.<TT><I>name</I></TT>.</P>

<A NAME="ch24-37-fm2xml"></A><A NAME="pythonian-CHP-24-ITERM-9277"></A><table width="515" border="0" cellpadding="5">
<tr>
<td align="left"><b><i>PyObject_DelItem</i></b></td>
<td align="right"></td>
</tr>
</table>
<hr width="515" size="3" noshade="true" align="left" color="black">
<table width="515" border="0" cellpadding="5">
<tr>
<td align="left">
<pre>int PyObject_DelItem(PyObject* <TT><I>x</I></TT>,PyObject* <TT><I>key</I></TT>)</pre>
</td>
<td align="right"></td>
</tr>
</table>
<P class="docText">Deletes <TT><I>x</I></TT>'s item with key
(or index) <TT><I>key</I></TT>, like
Python's <TT>del</TT>
<TT><I>x</I></TT><TT>[</TT><TT><I>key</I></TT><TT>]</TT>.</P>

<A NAME="ch24-38-fm2xml"></A><A NAME="pythonian-CHP-24-ITERM-9278"></A><table width="515" border="0" cellpadding="5">
<tr>
<td align="left"><b><i>PyObject_DelItemString</i></b></td>
<td align="right"></td>
</tr>
</table>
<hr width="515" size="3" noshade="true" align="left" color="black">
<table width="515" border="0" cellpadding="5">
<tr>
<td align="left">
<pre>int PyObject_DelItemString(PyObject* <TT><I>x</I></TT>,char* <TT><I>key</I></TT>)</pre>
</td>
<td align="right"></td>
</tr>
</table>
<P class="docText">Deletes <TT><I>x</I></TT>'s item with key
<TT><I>key</I></TT>, like Python's
<TT>del</TT>
<TT><I>x</I></TT><TT>[</TT><TT><I>key</I></TT><TT>]</TT>.</P>

<A NAME="ch24-39-fm2xml"></A><A NAME="pythonian-CHP-24-ITERM-9279"></A><table width="515" border="0" cellpadding="5">
<tr>
<td align="left"><b><i>PyObject_GetAttrString</i></b></td>
<td align="right"></td>
</tr>
</table>
<hr width="515" size="3" noshade="true" align="left" color="black">
<table width="515" border="0" cellpadding="5">
<tr>
<td align="left">
<pre>PyObject* PyObject_GetAttrString(PyObject* <TT><I>x</I></TT>,char* <TT><I>name</I></TT>)</pre>
</td>
<td align="right"></td>
</tr>
</table>
<P class="docText">Returns <TT><I>x</I></TT>'s attribute
named <TT><I>name</I></TT>, like Python's
<TT><I>x</I></TT>.<TT><I>name</I></TT>.</P>

<A NAME="ch24-40-fm2xml"></A><A NAME="pythonian-CHP-24-ITERM-9280"></A><table width="515" border="0" cellpadding="5">
<tr>
<td align="left"><b><i>PyObject_GetItem</i></b></td>
<td align="right"></td>
</tr>
</table>
<hr width="515" size="3" noshade="true" align="left" color="black">
<table width="515" border="0" cellpadding="5">
<tr>
<td align="left">
<pre>PyObject* PyObject_GetItem(PyObject* <TT><I>x</I></TT>,PyObject* <TT><I>key</I></TT>)</pre>
</td>
<td align="right"></td>
</tr>
</table>
<P class="docText">Returns <TT><I>x</I></TT>'s item with key
(or index) <TT><I>key</I></TT>, like
Python's
<TT><I>x</I></TT><TT>[</TT><TT><I>key</I></TT><TT>]</TT>.</P>

<A NAME="ch24-41-fm2xml"></A><A NAME="pythonian-CHP-24-ITERM-9281"></A><table width="515" border="0" cellpadding="5">
<tr>
<td align="left"><b><i>PyObject_GetItemString</i></b></td>
<td align="right"></td>
</tr>
</table>
<hr width="515" size="3" noshade="true" align="left" color="black">
<table width="515" border="0" cellpadding="5">
<tr>
<td align="left">
<pre>int PyObject_GetItemString(PyObject* <TT><I>x</I></TT>,char* <TT><I>key</I></TT>)</pre>
</td>
<td align="right"></td>
</tr>
</table>
<P class="docText">Returns <TT><I>x</I></TT>'s item with key
<TT><I>key</I></TT>, like Python's
<TT><I>x</I></TT><TT>[</TT><TT><I>key</I></TT><TT>]</TT>.</P>

<A NAME="ch24-42-fm2xml"></A><A NAME="pythonian-CHP-24-ITERM-9282"></A><table width="515" border="0" cellpadding="5">
<tr>
<td align="left"><b><i>PyObject_GetIter</i></b></td>
<td align="right"></td>
</tr>
</table>
<hr width="515" size="3" noshade="true" align="left" color="black">
<table width="515" border="0" cellpadding="5">
<tr>
<td align="left">
<pre>PyObject* PyObject_GetIter(PyObject* <TT><I>x</I></TT>)</pre>
</td>
<td align="right"></td>
</tr>
</table>
<P class="docText">Returns an iterator on <TT><I>x</I></TT>, like
Python's
<TT>iter(</TT><TT><I>x</I></TT><TT>)</TT>.</P>

<A NAME="ch24-43-fm2xml"></A><A NAME="pythonian-CHP-24-ITERM-9283"></A><table width="515" border="0" cellpadding="5">
<tr>
<td align="left"><b><i>PyObject_HasAttrString</i></b></td>
<td align="right"></td>
</tr>
</table>
<hr width="515" size="3" noshade="true" align="left" color="black">
<table width="515" border="0" cellpadding="5">
<tr>
<td align="left">
<pre>int PyObject_HasAttrString(PyObject* <TT><I>x</I></TT>,char* <TT><I>name</I></TT>)</pre>
</td>
<td align="right"></td>
</tr>
</table>
<P class="docText">True if <TT><I>x</I></TT> has an attribute named
<TT><I>name</I></TT>, like Python's
<TT>hasattr(</TT><TT><I>x</I></TT>,<TT><I>name</I></TT><TT>)</TT>.</P>

<A NAME="ch24-44-fm2xml"></A><A NAME="pythonian-CHP-24-ITERM-9284"></A><table width="515" border="0" cellpadding="5">
<tr>
<td align="left"><b><i>PyObject_IsTrue</i></b></td>
<td align="right"></td>
</tr>
</table>
<hr width="515" size="3" noshade="true" align="left" color="black">
<table width="515" border="0" cellpadding="5">
<tr>
<td align="left">
<pre>int PyObject_IsTrue(PyObject* <TT><I>x</I></TT>)</pre>
</td>
<td align="right"></td>
</tr>
</table>
<P class="docText">True if <TT><I>x</I></TT> is true for Python, like
Python's
<TT>bool(</TT><TT><I>x</I></TT><TT>)</TT>.</P>

<A NAME="ch24-45-fm2xml"></A><A NAME="pythonian-CHP-24-ITERM-9285"></A><table width="515" border="0" cellpadding="5">
<tr>
<td align="left"><b><i>PyObject_Length</i></b></td>
<td align="right"></td>
</tr>
</table>
<hr width="515" size="3" noshade="true" align="left" color="black">
<table width="515" border="0" cellpadding="5">
<tr>
<td align="left">
<pre>int PyObject_Length(PyObject* <TT><I>x</I></TT>)</pre>
</td>
<td align="right"></td>
</tr>
</table>
<P class="docText">Returns <TT><I>x</I></TT>'s length, like
Python's
<TT>len(</TT><TT><I>x</I></TT><TT>)</TT>.</P>

<A NAME="ch24-46-fm2xml"></A><A NAME="pythonian-CHP-24-ITERM-9286"></A><table width="515" border="0" cellpadding="5">
<tr>
<td align="left"><b><i>PyObject_Repr</i></b></td>
<td align="right"></td>
</tr>
</table>
<hr width="515" size="3" noshade="true" align="left" color="black">
<table width="515" border="0" cellpadding="5">
<tr>
<td align="left">
<pre>PyObject* PyObject_Repr(PyObject* <TT><I>x</I></TT>)</pre>
</td>
<td align="right"></td>
</tr>
</table>
<P class="docText">Returns <TT><I>x</I></TT>'s detailed
string representation, like Python's
<TT>repr(</TT><TT><I>x</I></TT><TT>)</TT>.</P>

<A NAME="ch24-47-fm2xml"></A><A NAME="pythonian-CHP-24-ITERM-9287"></A><table width="515" border="0" cellpadding="5">
<tr>
<td align="left"><b><i>PyObject_RichCompare</i></b></td>
<td align="right"></td>
</tr>
</table>
<hr width="515" size="3" noshade="true" align="left" color="black">
<table width="515" border="0" cellpadding="5">
<tr>
<td align="left">
<pre>PyObject* PyObject_RichCompare(PyObject* <TT><I>x</I></TT>,PyObject* <TT><I>y</I></TT>,int <TT><I>op</I></TT>)</pre>
</td>
<td align="right"></td>
</tr>
</table>
<P class="docText">Performs the comparison indicated by <TT><I>op</I></TT>
between <TT><I>x</I></TT> and
<TT><I>y</I></TT>, and returns the result as a Python
object. <TT><I>op</I></TT> can be
<TT>Py_EQ</TT>, <TT>Py_NE</TT>,
<TT>Py_LT</TT>, <TT>Py_LE</TT>,
<TT>Py_GT</TT>, or <TT>Py_GE</TT>, corresponding
to Python comparisons
<TT><I>x</I></TT><TT>==</TT><TT><I>y</I></TT>,
<TT><I>x</I></TT><TT>!=</TT><TT><I>y</I></TT>,
<TT><I>x</I></TT><TT>&lt;</TT><TT><I>y</I></TT>,
<TT><I>x</I></TT><TT>&lt;=</TT><TT><I>y</I></TT>,
<TT><I>x</I></TT><TT>&gt;</TT><TT><I>y</I></TT>,
or
<TT><I>x</I></TT><TT>&gt;=</TT><TT><I>y</I></TT>,
respectively.</P>

<A NAME="ch24-48-fm2xml"></A><A NAME="pythonian-CHP-24-ITERM-9288"></A><table width="515" border="0" cellpadding="5">
<tr>
<td align="left"><b><i>PyObject_RichCompareBool</i></b></td>
<td align="right"></td>
</tr>
</table>
<hr width="515" size="3" noshade="true" align="left" color="black">
<table width="515" border="0" cellpadding="5">
<tr>
<td align="left">
<pre>int PyObject_RichCompareBool(PyObject* <TT><I>x</I></TT>,PyObject* <TT><I>y</I></TT>,int <TT><I>op</I></TT>)</pre>
</td>
<td align="right"></td>
</tr>
</table>
<P class="docText">Like <TT>PyObject_RichCompare</TT>, but returns
<TT>0</TT> for false, <TT>1</TT> for true.</P>

<A NAME="ch24-49-fm2xml"></A><A NAME="pythonian-CHP-24-ITERM-9289"></A><table width="515" border="0" cellpadding="5">
<tr>
<td align="left"><b><i>PyObject_SetAttrString</i></b></td>
<td align="right"></td>
</tr>
</table>
<hr width="515" size="3" noshade="true" align="left" color="black">
<table width="515" border="0" cellpadding="5">
<tr>
<td align="left">
<pre>int PyObject_SetAttrString(PyObject* <TT><I>x</I></TT>,char* <TT><I>name</I></TT>,PyObject* <TT><I>v</I></TT>)</pre>
</td>
<td align="right"></td>
</tr>
</table>
<P class="docText">Sets <TT><I>x</I></TT>'s attribute named
<TT><I>name</I></TT> to <TT><I>v</I></TT>, like
Python's
<TT><I>x</I></TT>.<TT><I>name</I></TT><TT>=</TT><TT><I>v</I></TT>.</P>

<A NAME="ch24-50-fm2xml"></A><A NAME="pythonian-CHP-24-ITERM-9290"></A><table width="515" border="0" cellpadding="5">
<tr>
<td align="left"><b><i>PyObject_SetItem</i></b></td>
<td align="right"></td>
</tr>
</table>
<hr width="515" size="3" noshade="true" align="left" color="black">
<table width="515" border="0" cellpadding="5">
<tr>
<td align="left">
<pre>int PyObject_SetItem(PyObject* <TT><I>x</I></TT>,PyObject* <TT><I>k</I></TT>,PyObject *<TT><I>v</I></TT>)</pre>
</td>
<td align="right"></td>
</tr>
</table>
<P class="docText">Sets <TT><I>x</I></TT>'s item with key
(or index) <TT><I>key</I></TT> to
<TT><I>v</I></TT>, like Python's
<TT><I>x</I></TT><TT>[</TT><TT><I>key</I></TT><TT>]=</TT><TT><I>v</I></TT>.</P>

<A NAME="ch24-51-fm2xml"></A><A NAME="pythonian-CHP-24-ITERM-9291"></A><table width="515" border="0" cellpadding="5">
<tr>
<td align="left"><b><i>PyObject_SetItemString</i></b></td>
<td align="right"></td>
</tr>
</table>
<hr width="515" size="3" noshade="true" align="left" color="black">
<table width="515" border="0" cellpadding="5">
<tr>
<td align="left">
<pre>int PyObject_SetItemString(PyObject* <TT><I>x</I></TT>,char* <TT><I>key</I></TT>,PyObject *<TT><I>v</I></TT>)</pre>
</td>
<td align="right"></td>
</tr>
</table>
<P class="docText">Sets <TT><I>x</I></TT>'s item with key
<TT><I>key</I></TT> to <TT><I>v</I></TT>, like
Python's
<TT><I>x</I></TT><TT>[</TT><TT><I>key</I></TT><TT>]=</TT><TT><I>v</I></TT>.</P>

<A NAME="ch24-52-fm2xml"></A><A NAME="pythonian-CHP-24-ITERM-9292"></A><table width="515" border="0" cellpadding="5">
<tr>
<td align="left"><b><i>PyObject_Str</i></b></td>
<td align="right"></td>
</tr>
</table>
<hr width="515" size="3" noshade="true" align="left" color="black">
<table width="515" border="0" cellpadding="5">
<tr>
<td align="left">
<pre>PyObject* PyObject_Str(PyObject* <TT><I>x</I></TT>)</pre>
</td>
<td align="right"></td>
</tr>
</table>
<P class="docText">Returns <TT><I>x</I></TT>'s readable
string form, like Python's
<TT>str(</TT><TT><I>x</I></TT><TT>)</TT>.</P>

<A NAME="ch24-53-fm2xml"></A><A NAME="pythonian-CHP-24-ITERM-9293"></A><table width="515" border="0" cellpadding="5">
<tr>
<td align="left"><b><i>PyObject_Type</i></b></td>
<td align="right"></td>
</tr>
</table>
<hr width="515" size="3" noshade="true" align="left" color="black">
<table width="515" border="0" cellpadding="5">
<tr>
<td align="left">
<pre>PyObject* PyObject_Type(PyObject* <TT><I>x</I></TT>)</pre>
</td>
<td align="right"></td>
</tr>
</table>
<P class="docText">Returns <TT><I>x</I></TT>'s type object,
like Python's
<TT>type(</TT><TT><I>x</I></TT><TT>)</TT>.</P>

<A NAME="ch24-54-fm2xml"></A><A NAME="pythonian-CHP-24-ITERM-9294"></A><table width="515" border="0" cellpadding="5">
<tr>
<td align="left"><b><i>PyObject_Unicode</i></b></td>
<td align="right"></td>
</tr>
</table>
<hr width="515" size="3" noshade="true" align="left" color="black">
<table width="515" border="0" cellpadding="5">
<tr>
<td align="left">
<pre>PyObject* PyObject_Unicode(PyObject* <TT><I>x</I></TT>)</pre>
</td>
<td align="right"></td>
</tr>
</table>
<P class="docText">Returns <TT><I>x</I></TT>'s Unicode
string form, like Python's
<TT>unicode(</TT><TT><I>x</I></TT><TT>)</TT>.</P>

<A NAME="ch24-55-fm2xml"></A><A NAME="pythonian-CHP-24-ITERM-9295"></A><table width="515" border="0" cellpadding="5">
<tr>
<td align="left"><b><i>PySequence_Contains</i></b></td>
<td align="right"></td>
</tr>
</table>
<hr width="515" size="3" noshade="true" align="left" color="black">
<table width="515" border="0" cellpadding="5">
<tr>
<td align="left">
<pre>int PySequence_Contains(PyObject* <TT><I>x</I></TT>,PyObject* <TT><I>v</I></TT>)</pre>
</td>
<td align="right"></td>
</tr>
</table>
<P class="docText">True if <TT><I>v</I></TT> is an item in
<TT><I>x</I></TT>, like Python's
<TT><I>v</I></TT> <TT>in</TT>
<TT><I>x</I></TT>.</P>

<A NAME="ch24-56-fm2xml"></A><A NAME="pythonian-CHP-24-ITERM-9296"></A><table width="515" border="0" cellpadding="5">
<tr>
<td align="left"><b><i>PySequence_DelSlice</i></b></td>
<td align="right"></td>
</tr>
</table>
<hr width="515" size="3" noshade="true" align="left" color="black">
<table width="515" border="0" cellpadding="5">
<tr>
<td align="left">
<pre>int PySequence_DelSlice(PyObject* <TT><I>x</I></TT>,int <TT><I>start</I></TT>,int <TT><I>stop</I></TT>)</pre>
</td>
<td align="right"></td>
</tr>
</table>
<P class="docText">Delete <TT><I>x</I></TT>'s slice from
<TT><I>start</I></TT> to <TT><I>stop</I></TT>,
like Python's <TT>del</TT>
<TT><I>x</I></TT><TT>[</TT><TT><I>start</I></TT>:<TT><I>stop</I></TT><TT>]</TT>.</P>

<A NAME="ch24-57-fm2xml"></A><A NAME="pythonian-CHP-24-ITERM-9297"></A><table width="515" border="0" cellpadding="5">
<tr>
<td align="left"><b><i>PySequence_Fast</i></b></td>
<td align="right"></td>
</tr>
</table>
<hr width="515" size="3" noshade="true" align="left" color="black">
<table width="515" border="0" cellpadding="5">
<tr>
<td align="left">
<pre>PyObject* PySequence_Fast(PyObject* <TT><I>x</I></TT>)</pre>
</td>
<td align="right"></td>
</tr>
</table>
<P class="docText"><A NAME="pythonian-CHP-24-ITERM-9297"></A>Returns a new reference to a tuple with the
same items as <TT><I>x</I></TT>, unless
<TT><I>x</I></TT> is a list, in which case returns a new
reference to <TT><I>x</I></TT>. When you need to get many
items of an arbitrary sequence <TT><I>x</I></TT>,
it's fastest to call
<TT><I>t</I></TT><TT>=PySequence_Fast(</TT><TT><I>x</I></TT><TT>)</TT>
once, then call
<TT>PySequence_Fast_GET_ITEM(</TT><TT><I>t</I></TT>,<TT><I>i</I></TT><TT>)</TT>
as many times as needed, and finally call
<TT>Py_DECREF(</TT><TT><I>t</I></TT><TT>)</TT>.</P>

<A NAME="ch24-58-fm2xml"></A><A NAME="pythonian-CHP-24-ITERM-9298"></A><table width="515" border="0" cellpadding="5">
<tr>
<td align="left"><b><i>PySequence_Fast_GET_ITEM</i></b></td>
<td align="right"></td>
</tr>
</table>
<hr width="515" size="3" noshade="true" align="left" color="black">
<table width="515" border="0" cellpadding="5">
<tr>
<td align="left">
<pre>PyObject* PySequence_Fast_GET_ITEM(PyObject* <TT><I>x</I></TT>,int <TT><I>i</I></TT>)</pre>
</td>
<td align="right"></td>
</tr>
</table>
<P class="docText"><A NAME="pythonian-CHP-24-ITERM-9298"></A>Returns the <TT><I>i</I></TT>
item of <TT><I>x</I></TT>, where
<TT><I>x</I></TT> must be the result of
<TT>PySequence_Fast</TT>,
<TT><I>x</I></TT><TT>!=NULL</TT>, and
<TT>0&lt;=i&lt;PySequence_Fast_GET_SIZE(</TT><TT><I>t</I></TT><TT>)</TT>.
Violating these conditions can cause program crashes: this approach
is optimized for speed, not for safety.</P>

<A NAME="ch24-59-fm2xml"></A><A NAME="pythonian-CHP-24-ITERM-9299"></A><table width="515" border="0" cellpadding="5">
<tr>
<td align="left"><b><i>PySequence_Fast_GET_SIZE</i></b></td>
<td align="right"></td>
</tr>
</table>
<hr width="515" size="3" noshade="true" align="left" color="black">
<table width="515" border="0" cellpadding="5">
<tr>
<td align="left">
<pre>int PySequence_Fast_GET_SIZE(PyObject* <TT><I>x</I></TT>)</pre>
</td>
<td align="right"></td>
</tr>
</table>
<P class="docText">Returns the length of <TT><I>x</I></TT>.
<TT><I>x</I></TT> must be the result of
<TT>PySequence_Fast</TT>,
<TT><I>x</I></TT><TT>!=NULL</TT>.</P>

<A NAME="ch24-60-fm2xml"></A><A NAME="pythonian-CHP-24-ITERM-9300"></A><table width="515" border="0" cellpadding="5">
<tr>
<td align="left"><b><i>PySequence_GetSlice</i></b></td>
<td align="right"></td>
</tr>
</table>
<hr width="515" size="3" noshade="true" align="left" color="black">
<table width="515" border="0" cellpadding="5">
<tr>
<td align="left">
<pre>PyObject* PySequence_GetSlice(PyObject* <TT><I>x</I></TT>,int <TT><I>start</I></TT>,int <TT><I>stop</I></TT>)</pre>
</td>
<td align="right"></td>
</tr>
</table>
<P class="docText">Returns <TT><I>x</I></TT>'s slice from
<TT><I>start</I></TT> to <TT><I>stop</I></TT>,
like Python's
<TT><I>x</I></TT><TT>[</TT><TT><I>start</I></TT>:<TT><I>stop</I></TT><TT>]</TT>.</P>

<A NAME="ch24-61-fm2xml"></A><A NAME="pythonian-CHP-24-ITERM-9301"></A><table width="515" border="0" cellpadding="5">
<tr>
<td align="left"><b><i>PySequence_List</i></b></td>
<td align="right"></td>
</tr>
</table>
<hr width="515" size="3" noshade="true" align="left" color="black">
<table width="515" border="0" cellpadding="5">
<tr>
<td align="left">
<pre>PyObject* PySequence_List(PyObject* <TT><I>x</I></TT>)</pre>
</td>
<td align="right"></td>
</tr>
</table>
<P class="docText">Returns a new list object with the same items as
<TT><I>x</I></TT>, like Python's
<TT>list(</TT><TT><I>x</I></TT><TT>)</TT>.</P>

<A NAME="ch24-62-fm2xml"></A><A NAME="pythonian-CHP-24-ITERM-9302"></A><table width="515" border="0" cellpadding="5">
<tr>
<td align="left"><b><i>PySequence_SetSlice</i></b></td>
<td align="right"></td>
</tr>
</table>
<hr width="515" size="3" noshade="true" align="left" color="black">
<table width="515" border="0" cellpadding="5">
<tr>
<td align="left">
<pre>int PySequence_SetSlice(PyObject* <TT><I>x</I></TT>,int <TT><I>start</I></TT>,int <TT><I>stop</I></TT>,PyObject* <TT><I>v</I></TT>)</pre>
</td>
<td align="right"></td>
</tr>
</table>
<P class="docText">Sets <TT><I>x</I></TT>'s slice from
<TT><I>start</I></TT> to <TT><I>stop</I></TT>
to <TT><I>v</I></TT>, like Python's
<TT><I>x</I></TT><TT>[</TT><TT><I>start</I></TT>:<TT><I>stop</I></TT><TT>]=</TT><TT><I>v</I></TT>.
Just as in the equivalent Python statement,
<TT><I>v</I></TT> must be a sequence of the same type as
<TT><I>x</I></TT>.</P>

<A NAME="ch24-63-fm2xml"></A><A NAME="pythonian-CHP-24-ITERM-9303"></A><table width="515" border="0" cellpadding="5">
<tr>
<td align="left"><b><i>PySequence_Tuple</i></b></td>
<td align="right"></td>
</tr>
</table>
<hr width="515" size="3" noshade="true" align="left" color="black">
<table width="515" border="0" cellpadding="5">
<tr>
<td align="left">
<pre>PyObject* PySequence_Tuple(PyObject* <TT><I>x</I></TT>)</pre>
</td>
<td align="right"></td>
</tr>
</table>
<P class="docText"><A NAME="pythonian-CHP-24-ITERM-9303"></A>Returns a new reference to a tuple with the
same items as <TT><I>x</I></TT>, like
Python's
<TT>tuple(</TT><TT><I>x</I></TT><TT>)</TT>.</P>

<P class="docText">The functions whose names start with <TT>PyNumber_</TT>
allow you to perform numeric operations. Unary
<TT>PyNumber</TT> functions, which take one argument
<TT>PyObject*</TT> <TT><I>x</I></TT> and return
a <TT>PyObject*</TT>, are listed in <A class="docLink" HREF="#pythonian-CHP-24-TABLE-3">Table 24-3</A> with their Python equivalents.</P>

<A NAME="pythonian-CHP-24-TABLE-3"></A><P><TABLE BORDER="1" CELLSPACING="0" CELLPADDING="1" WIDTH="100%">
<CAPTION><h5 class="docTableTitle">Table 24-3. Unary PyNumber functions</h5></CAPTION><COLGROUP span="2">
<TR>
<TH class="docTableHeader">
<P class="docText">Function</P>
</TH>
<TH class="docTableHeader">
<P class="docText">Python equivalent</P>
</TH>
</TR>
<TR>
<TD class="docTableCell">
<A NAME="pythonian-CHP-24-ITERM-9304"></A><PRE>PyNumber_Absolute</PRE>
</TD>
<TD class="docTableCell">
<PRE>abs(x)</PRE>
</TD>
</TR>
<TR>
<TD class="docTableCell">
<A NAME="pythonian-CHP-24-ITERM-9305"></A><PRE>PyNumber_Float</PRE>
</TD>
<TD class="docTableCell">
<PRE>float(x)</PRE>
</TD>
</TR>
<TR>
<TD class="docTableCell">
<A NAME="pythonian-CHP-24-ITERM-9306"></A><PRE>PyNumber_Int</PRE>
</TD>
<TD class="docTableCell">
<PRE>int(x)</PRE>
</TD>
</TR>
<TR>
<TD class="docTableCell">
<A NAME="pythonian-CHP-24-ITERM-9307"></A><PRE>PyNumber_Invert</PRE>
</TD>
<TD class="docTableCell">
<PRE>~x</PRE>
</TD>
</TR>
<TR>
<TD class="docTableCell">
<A NAME="pythonian-CHP-24-ITERM-9308"></A><PRE>PyNumber_Long</PRE>
</TD>
<TD class="docTableCell">
<PRE>long(x)</PRE>
</TD>
</TR>
<TR>
<TD class="docTableCell">
<A NAME="pythonian-CHP-24-ITERM-9309"></A><PRE>PyNumber_Negative</PRE>
</TD>
<TD class="docTableCell">
<PRE>-x</PRE>
</TD>
</TR>
<TR>
<TD class="docTableCell">
<A NAME="pythonian-CHP-24-ITERM-9310"></A><PRE>PyNumber_Positive</PRE>
</TD>
<TD class="docTableCell">
<PRE>+x</PRE>
</TD>
</TR>
</COLGROUP>
</TABLE></P>

<P class="docText">Binary <TT>PyNumber</TT> functions, which take two
<TT>PyObject*</TT> arguments <TT><I>x</I></TT>
and <TT><I>y</I></TT> and return a
<TT>PyObject*</TT>, are similarly listed in <A class="docLink" HREF="#pythonian-CHP-24-TABLE-4">Table 24-4</A>.</P>

<A NAME="pythonian-CHP-24-TABLE-4"></A><P><TABLE BORDER="1" CELLSPACING="0" CELLPADDING="1" WIDTH="100%">
<CAPTION><h5 class="docTableTitle">Table 24-4. Binary PyNumber functions</h5></CAPTION><COLGROUP span="2">
<TR>
<TH class="docTableHeader">
<P class="docText">Function</P>
</TH>
<TH class="docTableHeader">
<P class="docText">Python equivalent</P>
</TH>
</TR>
<TR>
<TD class="docTableCell">
<A NAME="pythonian-CHP-24-ITERM-9311"></A><PRE>PyNumber_Add</PRE>
</TD>
<TD class="docTableCell">
<PRE>x + y</PRE>
</TD>
</TR>
<TR>
<TD class="docTableCell">
<A NAME="pythonian-CHP-24-ITERM-9312"></A><PRE>PyNumber_And</PRE>
</TD>
<TD class="docTableCell">
<PRE>x &amp; y</PRE>
</TD>
</TR>
<TR>
<TD class="docTableCell">
<A NAME="pythonian-CHP-24-ITERM-9313"></A><PRE>PyNumber_Divide</PRE>
</TD>
<TD class="docTableCell">
<PRE>x / y</PRE>
</TD>
</TR>
<TR>
<TD class="docTableCell">
<A NAME="pythonian-CHP-24-ITERM-9314"></A><PRE>PyNumber_Divmod</PRE>
</TD>
<TD class="docTableCell">
<PRE>divmod(x, y)</PRE>
</TD>
</TR>
<TR>
<TD class="docTableCell">
<A NAME="pythonian-CHP-24-ITERM-9315"></A><PRE>PyNumber_FloorDivide</PRE>
</TD>
<TD class="docTableCell">
<PRE>x // y</PRE>
</TD>
</TR>
<TR>
<TD class="docTableCell">
<A NAME="pythonian-CHP-24-ITERM-9316"></A><PRE>PyNumber_Lshift</PRE>
</TD>
<TD class="docTableCell">
<PRE>x &lt;&lt; y</PRE>
</TD>
</TR>
<TR>
<TD class="docTableCell">
<A NAME="pythonian-CHP-24-ITERM-9317"></A><PRE>PyNumber_Multiply</PRE>
</TD>
<TD class="docTableCell">
<PRE>x * y</PRE>
</TD>
</TR>
<TR>
<TD class="docTableCell">
<A NAME="pythonian-CHP-24-ITERM-9318"></A><PRE>PyNumber_Or</PRE>
</TD>
<TD class="docTableCell">
<PRE>x | y</PRE>
</TD>
</TR>
<TR>
<TD class="docTableCell">
<A NAME="pythonian-CHP-24-ITERM-9319"></A><PRE>PyNumber_Remainder</PRE>
</TD>
<TD class="docTableCell">
<PRE>x % y</PRE>
</TD>
</TR>
<TR>
<TD class="docTableCell">
<A NAME="pythonian-CHP-24-ITERM-9320"></A><PRE>PyNumber_Rshift</PRE>
</TD>
<TD class="docTableCell">
<PRE>x &gt;&gt; y</PRE>
</TD>
</TR>
<TR>
<TD class="docTableCell">
<A NAME="pythonian-CHP-24-ITERM-9321"></A><PRE>PyNumber_Subtract</PRE>
</TD>
<TD class="docTableCell">
<PRE>x - y</PRE>
</TD>
</TR>
<TR>
<TD class="docTableCell">
<A NAME="pythonian-CHP-24-ITERM-9322"></A><PRE>PyNumber_TrueDivide</PRE>
</TD>
<TD class="docTableCell">
<P class="docText"><TT>x / y</TT> (non-truncating)</P>
</TD>
</TR>
<TR>
<TD class="docTableCell">
<A NAME="pythonian-CHP-24-ITERM-9323"></A><PRE>PyNumber_Xor</PRE>
</TD>
<TD class="docTableCell">
<PRE>x ^ y</PRE>
</TD>
</TR>
</COLGROUP>
</TABLE></P>

<P class="docText">All the binary <TT>PyNumber</TT> functions have in-place
equivalents whose names start with
<TT>PyNumber_InPlace</TT>, such as
<TT>PyNumber_InPlaceAdd</TT> and so on. The in-place
versions try to modify the first argument in-place, if possible, and
in any case return a new reference to the result, be it the first
argument (modified) or a new object. Python's
built-in numbers are immutable; therefore, when the first argument is
a number of a built-in type, the in-place versions work just the same
as the ordinary versions. Function <TT>PyNumber_Divmod</TT>
returns a tuple with two items (the quotient and the remainder) and
has no in-place equivalent.</P>

<P class="docText">There is one ternary <TT>PyNumber</TT> function,
<TT>PyNumber_Power</TT>.</P>

<A NAME="ch24-64-fm2xml"></A><A NAME="pythonian-CHP-24-ITERM-9324"></A><table width="515" border="0" cellpadding="5">
<tr>
<td align="left"><b><i>PyNumber_Power</i></b></td>
<td align="right"></td>
</tr>
</table>
<hr width="515" size="3" noshade="true" align="left" color="black">
<table width="515" border="0" cellpadding="5">
<tr>
<td align="left">
<pre>PyObject* PyNumber_Power(PyObject* <TT><I>x</I></TT>,PyObject* <TT><I>y</I></TT>,PyObject* <TT><I>z</I></TT>)</pre>
</td>
<td align="right"></td>
</tr>
</table>
<P class="docText">When <TT><I>z</I></TT> is <TT>Py_None</TT>,
returns <TT><I>x</I></TT> raised to the
<TT><I>y</I></TT> power, like Python's
<TT><I>x</I></TT><TT>**</TT><TT><I>y</I></TT>
or equivalently
<TT>pow(</TT><TT><I>x,y</I></TT><TT>)</TT>.
Otherwise, returns
<TT><I>x</I></TT><TT>**</TT><TT><I>y</I></TT><TT>%</TT><TT><I>z</I></TT>,
like Python's
<TT>pow(</TT><TT><I>x,y,z</I></TT><TT>)</TT>.
The in-place version is named
<TT>PyNumber_InPlacePower</TT>.</P>


<A NAME="pythonian-CHP-24-SECT-1.10"></A>
<H4 class="docSection2Title">24.1.10 Concrete Layer Functions</H4>

<P class="docText"><A NAME="pythonian-CHP-24-ITERM-9325"></A>Each specific type of Python built-in
object supplies concrete functions to operate on instances of that
type, with names starting with
<TT>Py</TT><TT><I>type</I></TT><TT>_</TT>
(e.g., <TT>PyInt_</TT> for functions related to Python
<TT>int</TT>s). Most such functions duplicate the
functionality of abstract-layer functions or auxiliary functions
covered earlier in this chapter, such as
<TT>Py_BuildValue</TT>, which can generate objects of many
types. In this section, I cover some frequently used functions from
the concrete layer that provide unique functionality or substantial
convenience or speed. For most types, you can check if an object
belongs to the type by calling
<TT>Py</TT><TT><I>type</I></TT><TT>_Check</TT>,
which also accepts instances of subtypes, or
<TT>Py</TT><TT><I>type</I></TT><TT>_CheckExact</TT>,
which accepts only instances of <TT><I>type</I></TT>, not
of subtypes. Signatures are as for functions
<TT>PyIter_Check</TT>, covered earlier in this chapter.</P>

<A NAME="ch24-66-fm2xml"></A><A NAME="pythonian-CHP-24-ITERM-9326"></A><table width="515" border="0" cellpadding="5">
<tr>
<td align="left"><b><i>PyDict_GetItem</i></b></td>
<td align="right"></td>
</tr>
</table>
<hr width="515" size="3" noshade="true" align="left" color="black">
<table width="515" border="0" cellpadding="5">
<tr>
<td align="left">
<pre>PyObject* PyDict_GetItem(PyObject* <TT><I>x</I></TT>,PyObject* <TT><I>key</I></TT>)</pre>
</td>
<td align="right"></td>
</tr>
</table>
<P class="docText">Returns a borrowed reference to the item with key
<TT><I>key</I></TT> of dictionary
<TT><I>x</I></TT>.</P>

<A NAME="ch24-67-fm2xml"></A><A NAME="pythonian-CHP-24-ITERM-9327"></A><table width="515" border="0" cellpadding="5">
<tr>
<td align="left"><b><i>PyDict_GetItemString</i></b></td>
<td align="right"></td>
</tr>
</table>
<hr width="515" size="3" noshade="true" align="left" color="black">
<table width="515" border="0" cellpadding="5">
<tr>
<td align="left">
<pre>int PyDict_GetItemString(PyObject* <TT><I>x</I></TT>,char* <TT><I>key</I></TT>)</pre>
</td>
<td align="right"></td>
</tr>
</table>
<P class="docText">Returns a borrowed reference to the item with key
<TT><I>key</I></TT> of dictionary
<TT><I>x</I></TT>.<A NAME="pythonian-CHP-24-ITERM-9327"></A></P>

<A NAME="ch24-68-fm2xml"></A><A NAME="pythonian-CHP-24-ITERM-9328"></A><table width="515" border="0" cellpadding="5">
<tr>
<td align="left"><b><i>PyDict_Next</i></b></td>
<td align="right"></td>
</tr>
</table>
<hr width="515" size="3" noshade="true" align="left" color="black">
<table width="515" border="0" cellpadding="5">
<tr>
<td align="left">
<pre>int PyDict_Next(PyObject* <TT><I>x</I></TT>,int* <TT><I>pos</I></TT>,PyObject** <TT><I>k</I></TT>,PyObject** <TT><I>v</I></TT>)</pre>
</td>
<td align="right"></td>
</tr>
</table>
<P class="docText">Iterates over items in dictionary <TT><I>x</I></TT>. You
must initialize <TT>*</TT><TT><I>pos</I></TT> to
<TT>0</TT> at the start of the iteration:
<TT>PyDict_Next</TT> uses and updates
<TT>*</TT><TT><I>pos</I></TT> to keep track of
its place. For each successful iteration step, returns
<TT>1</TT>; when there are no more items, returns
<TT>0</TT>. Updates
<TT>*</TT><TT><I>k</I></TT> and
<TT>*</TT><TT><I>v</I></TT> to point to the next
key and value respectively (borrowed references) at each step that
returns <TT>1</TT>. You can pass either
<TT><I>k</I></TT> or <TT><I>v</I></TT> as
<TT>NULL</TT> if you are not interested in the key or
value. During an iteration, you must not change in any way the set of
<TT><I>x</I></TT>'s keys, but you can
change <TT><I>x</I></TT>'s values as long
as the set of keys remains identical.</P>

<A NAME="ch24-69-fm2xml"></A><A NAME="pythonian-CHP-24-ITERM-9329"></A><table width="515" border="0" cellpadding="5">
<tr>
<td align="left"><b><i>PyDict_Merge</i></b></td>
<td align="right"></td>
</tr>
</table>
<hr width="515" size="3" noshade="true" align="left" color="black">
<table width="515" border="0" cellpadding="5">
<tr>
<td align="left">
<pre>int PyDict_Merge(PyObject* <TT><I>x</I></TT>,PyObject* <TT><I>y</I></TT>,int <TT><I>override</I></TT>)</pre>
</td>
<td align="right"></td>
</tr>
</table>
<P class="docText">Updates dictionary <TT><I>x</I></TT> by merging the items
of dictionary <TT><I>y</I></TT> into
<TT><I>x</I></TT>. <TT><I>override</I></TT>
determines what happens when a key <TT><I>k</I></TT> is
present in both <TT><I>x</I></TT> and
<TT><I>y</I></TT>: if <TT><I>override</I></TT>
is <TT>0</TT>, then
<TT><I>x</I></TT><TT>[</TT><TT><I>k</I></TT><TT>]</TT>
remains the same; otherwise
<TT><I>x</I></TT><TT>[</TT><TT><I>k</I></TT><TT>]</TT>
is replaced by the value
<TT><I>y</I></TT><TT>[</TT><TT><I>k</I></TT><TT>]</TT>.</P>

<A NAME="ch24-70-fm2xml"></A><A NAME="pythonian-CHP-24-ITERM-9330"></A><table width="515" border="0" cellpadding="5">
<tr>
<td align="left"><b><i>PyDict_MergeFromSeq2</i></b></td>
<td align="right"></td>
</tr>
</table>
<hr width="515" size="3" noshade="true" align="left" color="black">
<table width="515" border="0" cellpadding="5">
<tr>
<td align="left">
<pre>int PyDict_MergeFromSeq2(PyObject* <TT><I>x</I></TT>,PyObject* <TT><I>y</I></TT>,int <TT><I>override</I></TT>)</pre>
</td>
<td align="right"></td>
</tr>
</table>
<P class="docText">Like <TT>PyDict_Merge</TT>, except that
<TT><I>y</I></TT> is not a dictionary but a sequence of
sequences, where each subsequence has length 2 and is used as a
<TT>(</TT><TT><I>key</I></TT>,<TT><I>value</I></TT><TT>)</TT>
pair.</P>

<A NAME="ch24-71-fm2xml"></A><A NAME="pythonian-CHP-24-ITERM-9331"></A><table width="515" border="0" cellpadding="5">
<tr>
<td align="left"><b><i>PyFloat_AS_DOUBLE</i></b></td>
<td align="right"></td>
</tr>
</table>
<hr width="515" size="3" noshade="true" align="left" color="black">
<table width="515" border="0" cellpadding="5">
<tr>
<td align="left">
<pre>double PyFloat_AS_DOUBLE(PyObject* <TT><I>x</I></TT>)</pre>
</td>
<td align="right"></td>
</tr>
</table>
<P class="docText"><A NAME="pythonian-CHP-24-ITERM-9331"></A>Returns the C <TT>double</TT>
value of Python <TT>float</TT>
<TT><I>x</I></TT>, very fast, without error checking.</P>

<A NAME="ch24-72-fm2xml"></A><A NAME="pythonian-CHP-24-ITERM-9332"></A><table width="515" border="0" cellpadding="5">
<tr>
<td align="left"><b><i>PyList_New</i></b></td>
<td align="right"></td>
</tr>
</table>
<hr width="515" size="3" noshade="true" align="left" color="black">
<table width="515" border="0" cellpadding="5">
<tr>
<td align="left">
<pre>PyObject* PyList_New(int <TT><I>length</I></TT>)</pre>
</td>
<td align="right"></td>
</tr>
</table>
<P class="docText">Returns a new, uninitialized list of the given
<TT><I>length</I></TT>. You must then initialize the list,
typically by calling <TT>PyList_SET_ITEM</TT>
<TT><I>length</I></TT> times.</P>

<A NAME="ch24-73-fm2xml"></A><A NAME="pythonian-CHP-24-ITERM-9333"></A><table width="515" border="0" cellpadding="5">
<tr>
<td align="left"><b><i>PyList_GET_ITEM</i></b></td>
<td align="right"></td>
</tr>
</table>
<hr width="515" size="3" noshade="true" align="left" color="black">
<table width="515" border="0" cellpadding="5">
<tr>
<td align="left">
<pre>PyObject* PyList_GET_ITEM(PyObject* <TT><I>x</I></TT>,int <TT><I>pos</I></TT>)</pre>
</td>
<td align="right"></td>
</tr>
</table>
<P class="docText">Returns the <TT><I>pos</I></TT> item of list
<TT><I>x</I></TT>, without error checking.</P>

<A NAME="ch24-74-fm2xml"></A><A NAME="pythonian-CHP-24-ITERM-9334"></A><table width="515" border="0" cellpadding="5">
<tr>
<td align="left"><b><i>PyList_SET_ITEM</i></b></td>
<td align="right"></td>
</tr>
</table>
<hr width="515" size="3" noshade="true" align="left" color="black">
<table width="515" border="0" cellpadding="5">
<tr>
<td align="left">
<pre>int PyList_SET_ITEM(PyObject* <TT><I>x</I></TT>,int <TT><I>pos</I></TT>,PyObject* <TT><I>v</I></TT>)</pre>
</td>
<td align="right"></td>
</tr>
</table>
<P class="docText">Sets the <TT><I>pos</I></TT> item of list
<TT><I>x</I></TT> to <TT><I>v</I></TT>, without
error checking. Steals a reference to <TT><I>v</I></TT>.
Use only immediately after creating a new list
<TT><I>x</I></TT> with <TT>PyList_New</TT>.</P>

<A NAME="ch24-75-fm2xml"></A><A NAME="pythonian-CHP-24-ITERM-9335"></A><table width="515" border="0" cellpadding="5">
<tr>
<td align="left"><b><i>PyString_AS_STRING</i></b></td>
<td align="right"></td>
</tr>
</table>
<hr width="515" size="3" noshade="true" align="left" color="black">
<table width="515" border="0" cellpadding="5">
<tr>
<td align="left">
<pre>char* PyString_AS_STRING(PyObject* <TT><I>x</I></TT>)</pre>
</td>
<td align="right"></td>
</tr>
</table>
<P class="docText">Returns a pointer to the internal buffer of string
<TT><I>x</I></TT>, very fast, without error checking. You
must not modify the buffer in any way, unless you just allocated it
by calling
<TT>PyString_FromStringAndSize(NULL</TT>,<TT><I>size</I></TT><TT>)</TT>.</P>

<A NAME="ch24-76-fm2xml"></A><A NAME="pythonian-CHP-24-ITERM-9336"></A><table width="515" border="0" cellpadding="5">
<tr>
<td align="left"><b><i>PyString_AsStringAndSize</i></b></td>
<td align="right"></td>
</tr>
</table>
<hr width="515" size="3" noshade="true" align="left" color="black">
<table width="515" border="0" cellpadding="5">
<tr>
<td align="left">
<pre>int PyString_AsStringAndSize(PyObject* <TT><I>x</I></TT>,char** <TT><I>buffer</I></TT>,int* <TT><I>length</I></TT>)</pre>
</td>
<td align="right"></td>
</tr>
</table>
<P class="docText">Puts a pointer to the internal buffer of string
<TT><I>x</I></TT> in
<TT>*</TT><TT><I>buffer</I></TT>, and
<TT><I>x</I></TT>'s length in
<TT>*</TT><TT><I>length</I></TT>. You must not
modify the buffer in any way, unless you just allocated it by calling
<TT>PyString_FromStringAndSize(NULL</TT>,<TT><I>size</I></TT><TT>)</TT>.</P>

<A NAME="ch24-77-fm2xml"></A><A NAME="pythonian-CHP-24-ITERM-9337"></A><table width="515" border="0" cellpadding="5">
<tr>
<td align="left"><b><i>PyString_FromFormat</i></b></td>
<td align="right"></td>
</tr>
</table>
<hr width="515" size="3" noshade="true" align="left" color="black">
<table width="515" border="0" cellpadding="5">
<tr>
<td align="left">
<pre>PyObject* PyString_FromFormat(char* <TT><I>format</I></TT>,...)</pre>
</td>
<td align="right"></td>
</tr>
</table>
<P class="docText">Returns a Python string built from format string
<TT><I>format</I></TT>, which has syntax similar to
<TT>printf</TT>'s, and the following C
values indicated as variable arguments above.</P>

<A NAME="ch24-78-fm2xml"></A><A NAME="pythonian-CHP-24-ITERM-9338"></A><table width="515" border="0" cellpadding="5">
<tr>
<td align="left"><b><i>PyString_FromStringAndSize</i></b></td>
<td align="right"></td>
</tr>
</table>
<hr width="515" size="3" noshade="true" align="left" color="black">
<table width="515" border="0" cellpadding="5">
<tr>
<td align="left">
<pre>PyObject* PyString_FromFormat(char* <TT><I>data</I></TT>,int <TT><I>size</I></TT>)</pre>
</td>
<td align="right"></td>
</tr>
</table>
<P class="docText">Returns a Python string of length <TT><I>size</I></TT>,
copying <TT><I>size</I></TT> bytes from
<TT><I>data</I></TT>. When <TT><I>data</I></TT>
is <TT>NULL</TT>, the Python string is uninitialized, and
you must initialize it. You can get the pointer to the
string's internal buffer by calling
<TT>PyString_AS_STRING</TT>.</P>

<A NAME="ch24-79-fm2xml"></A><A NAME="pythonian-CHP-24-ITERM-9339"></A><table width="515" border="0" cellpadding="5">
<tr>
<td align="left"><b><i>PyTuple_New</i></b></td>
<td align="right"></td>
</tr>
</table>
<hr width="515" size="3" noshade="true" align="left" color="black">
<table width="515" border="0" cellpadding="5">
<tr>
<td align="left">
<pre>PyObject* PyTuple_New(int <TT><I>length</I></TT>)</pre>
</td>
<td align="right"></td>
</tr>
</table>
<P class="docText">Returns a new, uninitialized tuple of the given
<TT><I>length</I></TT>. You must then initialize the
tuple, typically by calling <TT>PyTuple_SET_ITEM</TT>
<TT><I>length</I></TT> times.</P>

<A NAME="ch24-80-fm2xml"></A><A NAME="pythonian-CHP-24-ITERM-9340"></A><table width="515" border="0" cellpadding="5">
<tr>
<td align="left"><b><i>PyTuple_GET_ITEM</i></b></td>
<td align="right"></td>
</tr>
</table>
<hr width="515" size="3" noshade="true" align="left" color="black">
<table width="515" border="0" cellpadding="5">
<tr>
<td align="left">
<pre>PyObject* PyTuple_GET_ITEM(PyObject* <TT><I>x</I></TT>,int <TT><I>pos</I></TT>)</pre>
</td>
<td align="right"></td>
</tr>
</table>
<P class="docText">Returns the <TT><I>pos</I></TT> item of tuple
<TT><I>x</I></TT>, without error checking.</P>

<A NAME="ch24-81-fm2xml"></A><A NAME="pythonian-CHP-24-ITERM-9341"></A><table width="515" border="0" cellpadding="5">
<tr>
<td align="left"><b><i>PyTuple_SET_ITEM</i></b></td>
<td align="right"></td>
</tr>
</table>
<hr width="515" size="3" noshade="true" align="left" color="black">
<table width="515" border="0" cellpadding="5">
<tr>
<td align="left">
<pre>int PyTuple_SET_ITEM(PyObject* <TT><I>x</I></TT>,int <TT><I>pos</I></TT>,PyObject* <TT><I>v</I></TT>)</pre>
</td>
<td align="right"></td>
</tr>
</table>
<P class="docText">Sets the <TT><I>pos</I></TT> item of tuple
<TT><I>x</I></TT> to <TT><I>v</I></TT>, without
error checking. Steals a reference to <TT><I>v</I></TT>.
Use only immediately after creating a new tuple
<TT><I>x</I></TT> with <TT>PyTuple_New</TT>.</P>


<A NAME="pythonian-CHP-24-SECT-1.11"></A>
<H4 class="docSection2Title">24.1.11 A Simple Extension Example</H4>

<P class="docText"><A class="docLink" HREF="#pythonian-CHP-24-EX-1">Example 24-1</A> exposes the functionality of Python C
API functions <TT>PyDict_Merge</TT> and
<TT>PyDict_MergeFromSeq2</TT> for Python use. The
<TT>update</TT> method of dictionaries works like
<TT>PyDict_Merge</TT> with
<TT><I>override</I></TT><TT>=1</TT>, but <A class="docLink" HREF="#pythonian-CHP-24-EX-1">Example 24-1</A> is more general.</P>


<H5 class="docExampleTitle"><A NAME="pythonian-CHP-24-EX-1"></A>Example 24-1. A simple Python extension module merge.c</H5>
<PRE>#include &lt;Python.h&gt;

static PyObject*
merge(PyObject* self, PyObject* args, PyObject* kwds)
{
    static char* argnames[] = {"x","y","override",NULL};
    PyObject *x, *y;
    int override = 0;
    if(!PyArg_ParseTupleAndKeywords(args, kwds, "O!O|i", argnames,
        &amp;PyDict_Type, &amp;x, &amp;y, &amp;override))
            return NULL;
    if(-1 == PyDict_Merge(x, y, override)) {
        if(!PyErr_ExceptionMatches(PyExc_TypeError)):
            return NULL;
        PyErr_Clear(  );
        if(-1 == PyDict_MergeFromSeq2(x, y, override))
            return NULL;
    }
    return Py_BuildValue("");
}

static char merge_docs[] = "\
merge(x,y,override=False): merge into dict x the items of dict y (or the pairs\n\
    that are the items of y, if y is a sequence), with optional override.\n\
    Alters dict x directly, returns None.\n\
";

static PyObject*
mergenew(PyObject* self, PyObject* args, PyObject* kwds)
{
    static char* argnames[] = {"x","y","override",NULL};
    PyObject *x, *y, *result;
    int override = 0;
    if(!PyArg_ParseTupleAndKeywords(args, kwds, "O!O|i", argnames,
        &amp;PyDict_Type, &amp;x, &amp;y, &amp;override))
            return NULL;
    result = PyObject_CallMethod(x, "copy", "");
    if(!result)
        return NULL;
    if(-1 == PyDict_Merge(result, y, override)) {
        if(!PyErr_ExceptionMatches(PyExc_TypeError)):
            return NULL;
        PyErr_Clear(  );
        if(-1 == PyDict_MergeFromSeq2(result, y, override))
            return NULL;
    }
    return result;
}

static char merge_docs[] = "\
mergenew(x,y,override=False): merge into dict x the items of dict y (or\n\
     the pairs that are the items of y, if y is a sequence), with optional\n\
     override.  Does NOT alter x, but rather returns the modified copy as\n\
     the function's result.\n\
";

static PyMethodDef funcs[] = {
    {"merge", (PyCFunction)merge, METH_KEYWORDS, merge_docs},
    {"mergenew", (PyCFunction)mergenew, METH_KEYWORDS, mergenew_docs},
    {NULL}
};

void
initmerge(void)
{
    Py_InitModule3("merge", funcs, "Example extension module");
}</PRE>


<P class="docText">This example declares as <TT>static</TT> every function and
global variable in the C source file, except
<TT>initmerge</TT>, which must be visible from the outside
to let Python call it. Since the functions and variables are exposed
to Python via the <TT>PyMethodDef</TT> structures, Python
does not need to see their names directly. Therefore, declaring them
<TT>static</TT> is best: this ensures that names
don't accidentally end up in the whole
program's global namespace, as might otherwise
happen on some platforms, possibly causing conflicts and errors.</P>

<P class="docText">The format string "<TT>O!O|i</TT>" passed to
<TT>PyArg_ParseTupleAndKeywords</TT> indicates that
function <TT>merge</TT> accepts three arguments from
Python: an object with a type constraint, a generic object, and an
optional integer. At the same time, the format string indicates that
the variable part of
<TT>PyArg_ParseTupleAndKeywords</TT>'s
arguments must contain four addresses: in order, the address of a
Python type object, then two addresses of
<TT>PyObject*</TT> variables, and finally the address of an
<TT>int</TT> variable. The <TT>int</TT> variable
must have been previously initialized to its intended default value,
since the corresponding Python argument is optional.</P>

<P class="docText">And indeed, after the <TT><I>argnames</I></TT> argument,
the code passes <TT>&amp;PyDict_Type</TT> (i.e., the
address of the dictionary type object). Then it passes the addresses
of the two <TT>PyObject*</TT> variables. Finally, it passes
the address of variable <TT><I>override</I></TT>, an
<TT>int</TT> that was previously initialized to
<TT>0</TT>, since the default, when the
<TT><I>override</I></TT> argument isn't
explicitly passed from Python, should be no overriding. If the return
value of <TT>PyArg_ParseTupleAndKeywords</TT> is
<TT>0</TT>, the code immediately returns
<TT>NULL</TT> to propagate the exception; this
automatically diagnoses most cases where Python code passes wrong
arguments to our new function <TT>merge</TT>.</P>

<P class="docText">When the arguments appear to be okay, it tries
<TT>PyDict_Merge</TT>, which succeeds if
<TT><I>y</I></TT> is a dictionary. When
<TT>PyDict_Merge</TT> raises a
<TT>TypeError</TT>, indicating that
<TT><I>y</I></TT> is not a dictionary, the code clears the
error and tries again, this time with
<TT>PyDict_MergeFromSeq2</TT>, which succeeds when
<TT><I>y</I></TT> is a sequence of pairs. If that also
fails, it returns <TT>NULL</TT> to propagate the exception.
Otherwise, it returns <TT>None</TT> in the simplest way
(i.e., with <TT>return</TT>
<TT>Py_BuildValue("")</TT>) to indicate success.</P>

<P class="docText">Function <TT>mergenew</TT> basically duplicates
<TT>merge</TT>'s functionality; however,
<TT>mergenew</TT> does not alter its arguments, but rather
builds and returns a new dictionary as the
function's result. The C API function
<TT>PyObject_CallMethod</TT> lets
<TT>mergenew</TT> call the <TT>copy</TT> method
of its first Python-passed argument, a dictionary object, and obtain
a new dictionary object that it then alters (with exactly the same
logic as function <TT>merge</TT>). It then returns the
altered dictionary as the function result (thus, no need to call
<TT>Py_BuildValue</TT> in this case).</P>

<P class="docText">The code of <A class="docLink" HREF="#pythonian-CHP-24-EX-1">Example 24-1</A> must reside in a source file
named <I>merge.c</I>. In the same directory, create the
following script named <I>setup.py</I>:</P>

<PRE>from distutils.core import setup, Extension
setup(name='merge', ext_modules=[ Extension('merge',sources=['merge.c']) ])</PRE>

<P class="docText">Now, run <I>python setup.py install</I> at a shell
prompt in this directory. This command builds the dynamically loaded
library for the <TT>merge</TT> extension module, and copies
it to the appropriate directory, depending on your Python
installation. Now your Python code can use the module. For example:</P>

<PRE>import merge
x = {'a':1,'b':2 }
merge.merge(x,[['b',3],['c',4]])
print x                               # prints: {'a':1, 'b':2, 'c':4 }
print merge.mergenew(x,{'a':5,'d':6},override=1) 
# prints: {'a':5, 'b':2, 'c':4, 'd':6 }
print x                               # prints: {'a':1, 'b':2, 'c':4 }</PRE>

<P class="docText">This example shows the difference between <TT>merge</TT>
(which alters its first argument) and <TT>mergenew</TT>
(which returns a new object and does not alter its argument). It also
shows that the second argument can be either a dictionary or a
sequence of two-item subsequences. Further, it demonstrates default
operation (where keys that are already in the first argument are left
alone) as well as the <TT>override</TT> option (where keys
coming from the second argument take precedence, as in Python
dictionaries' <TT>update</TT> method).</P>


<A NAME="pythonian-CHP-24-SECT-1.12"></A>
<H4 class="docSection2Title">24.1.12 Defining New Types</H4>

<P class="docText"><A NAME="pythonian-CHP-24-ITERM-9342"></A>
<A NAME="pythonian-CHP-24-ITERM-9343"></A>In your extension
modules, you often want to define new types and make them available
to Python. A type's definition is held in a large
struct named <TT>PyTypeObject</TT>. Most of the fields of
<TT>PyTypeObject</TT> are pointers to functions. Some
fields point to other structs, which in turn are blocks of pointers
to functions. <TT>PyTypeObject</TT> also includes a few
fields giving the type's name, size, and behavior
details (option flags). You can leave almost all fields of
<TT>PyTypeObject</TT> set to <TT>NULL</TT> if you
do not supply the related functionality. You can point some fields to
functions in the Python C API in order to supply certain aspects of
fundamental object functionality in standard ways.</P>

<P class="docText"><A NAME="pythonian-CHP-24-ITERM-9344"></A>The best way
to implement a type is to copy from the Python sources the file
<I>Modules/xxsubtype.c</I>, which Python supplies
exactly for such didactical purposes, and edit it.
It's a complete module with two types, subclassing
from <TT>list</TT> and <TT>dict</TT>
respectively. Another example in the Python sources,
<I>Objects/xxobject.c</I>, is not a complete module,
and the type in this file is minimal and old-fashioned, not using
modern recommended approaches. See <A class="docLink" target="_blank" HREF="http://www.python.org/dev/doc/devel/api/type-structs.html">http://www.python.org/dev/doc/devel/api/type-structs.html</A>
for detailed documentation on <TT>PyTypeObject</TT> and
other related structs. File <I>Include/object.h </I>in
the Python sources contains the declarations of these types, as well
as several important comments that you would do well to study.</P>

<A NAME="pythonian-CHP-24-SECT-1.12.1"></A>
<H5 class="docSection3Title">24.1.12.1 Per-instance data</H5>

<P class="docText">To represent each instance of your type, declare a C struct that
starts, right after the opening brace, with macro
<TT>PyObject_HEAD</TT>. The macro expands into the data
fields that your struct must begin with in order to be a Python
object. Those fields include the reference count and a pointer to the
instance's type. Any pointer to your structure can
be correctly cast to a <TT>PyObject*</TT>.</P>

<P class="docText">The <TT>PyTypeObject</TT> struct that defines your
type's characteristics and behavior must contain the
size of your per-instance struct, as well as pointers to the C
functions you write to operate on your structure. Therefore, you
normally place the <TT>PyTypeObject</TT> toward the end of
your code, after the per-instance struct and all the functions that
operate on instances of the per-instance struct. Each
<TT><I>x</I></TT> that points to a structure starting with
<TT>PyObject_HEAD</TT>, and in particular each
<TT>PyObject*</TT> <TT><I>x</I></TT>, has a
field <TT><I>x</I></TT><TT>-&gt;ob_type</TT>
that is the address of the <TT>PyTypeObject</TT> structure
that is <TT><I>x</I></TT>'s Python type
object.</P>



<A NAME="pythonian-CHP-24-SECT-1.12.2"></A>
<H5 class="docSection3Title">24.1.12.2 The PyTypeObject definition</H5>

<P class="docText">Given a per-instance struct such as:</P>

<PRE>typedef struct {
    PyObject_HEAD
    /* other data needed by instances of this type, omitted */
} mytype;</PRE>

<P class="docText">the corresponding <TT>PyTypeObject</TT> struct almost
invariably begins in a way similar to:</P>

<PRE>static PyTypeObject t_mytype = {
/* tp_head */        PyObject_HEAD_INIT(NULL)   /* use NULL, for MSVC++ */
/* tp_internal */    0,                 /* must be 0 */
/* tp_name <span class="docEmphBold">/</span>        "mymodule.mytype",  /* type name with module */
/* tp_basicsize */   sizeof(mytype),
/* tp_itemsize */    0,                 /* 0 except variable-size type */
/* tp_dealloc */     (destructor)mytype_dealloc,
/* tp_print */       0,                 /* usually 0, use str instead */
/* tp_getattr */     0,                 /* usually 0 (see getattro) */
/* tp_setattr */     0,                 /* usually 0 (see setattro) */
/* tp_compare*/      0,                 /* see also richcompare */
/* tp_repr */        (reprfunc)mytype_str,    /* like Python's _  _repr_  _ */
    /* rest of struct omitted */</PRE>

<P class="docText">For portability to Microsoft Visual C++, the
<TT>PyObject_HEAD_INIT</TT> macro at the start of the
<TT>PyTypeObject</TT> must have an argument of
<TT>NULL</TT>. During module initialization, you must call
<TT>PyType_Ready(&amp;t_mytype)</TT>, which, among other
tasks, inserts in <TT>t_mytype</TT> the address of its type
(the type of a type is also known as a metatype), normally
<TT>&amp;PyType_Type</TT>. Another slot in
<TT>PyTypeObject</TT> that points to another type object is
<TT>tp_base</TT>, later in the structure. In the structure
definition itself, you must have a <TT>tp_base</TT> of
<TT>NULL</TT>, again for compatibility with Microsoft
Visual C++. However, before you invoke
<TT>PyType_Ready(&amp;t_mytype)</TT>, you can optionally
set <TT>t_mytype.tp_base</TT> to the address of another
type object. When you do so, your type inherits from the other type,
just like a class coded in Python 2.2 can optionally inherit from a
built-in type. For a Python type coded in C, inheriting means that
for most fields in the <TT>PyTypeObject</TT>, if you set
the field to <TT>NULL</TT>, <TT>PyType_Ready</TT>
copies the corresponding field from the base type. A type must
specifically assert in its field <TT>tp_flags</TT> that it
is usable as a base type, otherwise no other type can inherit from
it.</P>

<P class="docText">The <TT>tp_itemsize</TT> field is of interest only for
types that, like tuples, have instances of different sizes, and can
determine instance size once and forever at creation time. Most types
just set <TT>tp_itemsize</TT> to <TT>0</TT>.
Fields such as <TT>tp_getattr</TT> and
<TT>tp_setattr</TT> are generally set to
<TT>NULL</TT> because they exist only for backward
compatibility: modern types use fields <TT>tp_getattro</TT>
and <TT>tp_setattro</TT> instead. Field
<TT>tp_repr</TT> is typical of most of the following
fields, which are omitted here: the field holds the address of a
function, which corresponds directly to a Python special method
(here, <TT>_ _repr_ _</TT>). You can set the field to
<TT>NULL</TT>, indicating that your type does not supply
the special method, or else set the field to point to a function with
the needed functionality. If you set the field to
<TT>NULL</TT>, but also point to a base type from the
<TT>tp_base</TT> slot, you inherit the special method, if
any, from your base type. You often need to cast your functions to
the specific <TT>typedef</TT> type that a field needs
(here, type <TT>reprfunc</TT> for field
<TT>tp_repr</TT>) because the <TT>typedef</TT>
has a first argument <TT>PyObject*</TT>
<TT>self</TT>, while your functions, being specific to your
type, normally use more specific pointers. For example:</P>

<PRE>static PyObject* mytype_str(mytype* self) { ... /* rest omitted */</PRE>

<P class="docText">Alternatively, you can declare <TT>mytype_str</TT> with a
<TT>PyObject*</TT> <TT>self</TT>, then use a cast
<TT>(mytype*)self</TT> in the function's
body. Either alternative is acceptable, but it's
more common to locate the casts in the
<TT>PyTypeObject</TT> declaration.</P>



<A NAME="pythonian-CHP-24-SECT-1.12.3"></A>
<H5 class="docSection3Title">24.1.12.3 Instance initialization and finalization</H5>

<P class="docText">The task of finalizing your instances is split among two functions.
The <TT>tp_dealloc</TT> slot must never be
<TT>NULL</TT>, except for immortal types (i.e., types whose
instances are never deallocated). Python calls
<TT><I>x</I></TT><TT>-&gt;ob_type-&gt;tp_dealloc(</TT><TT><I>x</I></TT><TT>)</TT>
on each instance <TT><I>x</I></TT> whose reference count
decreases to <TT>0</TT>, and the function thus called must
release any resource held by object <TT><I>x</I></TT>,
including <TT><I>x</I></TT>'s memory.
When an instance of <TT>mytype</TT> holds no other
resources that must be released (in particular, no owned references
to other Python objects that you would have to
<TT>DECREF</TT>),
<TT>mytype</TT>'s destructor can be
extremely simple:</P>

<PRE>static void mytype_dealloc(PyObject *x)
{
    x-&gt;ob_type-&gt;tp_free((PyObject*)x);
}</PRE>

<P class="docText">The function in the <TT>tp_free</TT> slot has the specific
task of freeing <TT><I>x</I></TT>'s
memory. In Python 2.2, the function has signature
<TT>void</TT>
<TT><I>name</I></TT><TT>(PyObject*)</TT>. In
Python 2.3, the signature has changed to <TT>void</TT>
<TT><I>name</I></TT><TT>(void*)</TT>. One way to
ensure your sources compile under both versions of Python is to put
in slot <TT>tp_free</TT> the C API function
<TT>_PyObject_Del</TT>, which has the right signature in
each version.</P>

<P class="docText">The task of initializing your instances is split among three
functions. To allocate memory for new instances of your type, put in
slot <TT>tp_alloc</TT> the C API function
<TT>PyType_GenericAlloc</TT>, which does absolutely minimal
initialization, clearing the newly allocated memory bytes to
<TT>0</TT> except for the type pointer and reference count.
Similarly, you can often set field <TT>tp_new</TT> to the C
API function <TT>PyType_GenericNew</TT>. In this case, you
can perform all per-instance initialization in the function you put
in slot <TT>tp_init</TT>, which has the signature:</P>

<PRE>int <TT><I>init_name</I></TT>(PyObject *<TT><I>self</I></TT>,PyObject *<TT><I>args</I></TT>,PyObject *<TT><I>kwds</I></TT>)</PRE>

<P class="docText">The positional and named arguments to the function in slot
<TT>tp_init</TT> are those passed when calling the type to
create the new instance, just like, in Python, the positional and
named arguments to <TT>_ _init_ _</TT> are those passed
when calling the class object. Again like for types (classes) defined
in Python, the general rule is to do as little initialization as
possible in <TT>tp_new</TT> and as much as possible in
<TT>tp_init</TT>. Using
<TT>PyType_GenericNew</TT> for <TT>tp_new</TT>
accomplishes this. However, you can choose to define your own
<TT>tp_new</TT> for special types, such as ones that have
immutable instances, where initialization must happen earlier. The
signature is:</P>

<PRE>PyObject* <TT><I>new_name</I></TT>(PyObject *<TT><I>subtype</I></TT>,PyObject *<TT><I>args</I></TT>,PyObject *<TT><I>kwds</I></TT>)</PRE>

<P class="docText">The function in <TT>tp_new</TT> must return the newly
created instance, normally an instance of
<TT><I>subtype</I></TT> (which may be a type that inherits
from yours). The function in <TT>tp_init</TT>, on the other
hand, must return <TT>0</TT> for success, or
<TT>-1</TT> to indicate an exception.</P>

<P class="docText">If your type is subclassable, it's important that
any instance invariants be established before the function in
<TT>tp_new</TT> returns. For example, if it must be
guaranteed that a certain field of the instance is never
<TT>NULL</TT>, that field must be set to a
non-<TT>NULL</TT> value by the function in
<TT>tp_new</TT>. Subtypes of your type might fail to call
your <TT>tp_init</TT> function; therefore such
indispensable initializations should be in <TT>tp_new</TT>
for subclassable types.</P>



<A NAME="pythonian-CHP-24-SECT-1.12.4"></A>
<H5 class="docSection3Title">24.1.12.4 Attribute access</H5>

<P class="docText">Access to attributes of your instances, including methods (as covered
in <A class="docLink" HREF="0596001886_pythonian-chp-5.html#pythonian-CHP-5">Chapter 5</A>) is mediated by the functions you put
in slots <TT>tp_getattro</TT> and
<TT>tp_setattro</TT> of your
<TT>PyTypeObject</TT> struct. Normally, you put there the
standard C API functions <TT>PyObject_GenericGetAttr</TT>
and <TT>PyObject_GenericSetAttr</TT>, which implement
standard semantics. Specifically, these API functions access your
type's methods via the slot
<TT>tp_methods</TT>, pointing to a sentinel-terminated
array of <TT>PyMethodDef</TT> structs, and your
instances' members via the slot
<TT>tp_members</TT>, a similar sentinel-terminated array of
<TT>PyMemberDef</TT> structs:</P>

<PRE>typedef struct {
    char* <TT><I>name</I></TT>;        /* Python-visible name of the member */
    int <TT><I>type</I></TT>;          /* code defining the data-type of the member */
    int <TT><I>offset</I></TT>;        /* offset of the member in the per-instance struct */
    int <TT><I>flags</I></TT>;         /* READONLY for a read-only member */
    char* <TT><I>doc</I></TT>;         /* docstring for the member */
} PyMemberDef</PRE>

<P class="docText">As an exception to the general rule that including
<I>Python.h</I> gets you all the declarations you need,
you have to include <I>structmember.h</I> explicitly in
order to have your C source see the declaration of
<TT>PyMemberDef</TT>.</P>

<P class="docText"><TT><I>type</I></TT> is generally
<TT>T_OBJECT</TT> for members that are
<TT>PyObject*</TT>, but many other type codes are defined
in <I>Include/structmember.h</I> for members that your
instances hold as C-native data (e.g., <TT>T_DOUBLE</TT>
for <TT>double</TT> or <TT>T_STRING</TT> for
<TT>char*</TT>). For example, if your per-instance struct
is something like:</P>

<PRE>typedef struct {
    PyObject_HEAD
    double <TT><I>datum</I></TT>;
    char* <TT><I>name</I></TT>;
} mytype;</PRE>

<P class="docText">to expose to Python per-instance attributes
<TT><I>datum</I></TT> (read/write) and
<TT><I>name</I></TT> (read-only), you can define the
following array and point your
<TT>PyTypeObject</TT>'s
<TT>tp_members</TT> to it:</P>

<PRE>static PyMemberDef[] mytype_members = {
    {"datum", T_DOUBLE, offsetof(mytype, datum), 0, "The current datum"},
    {"name", T_STRING, offsetof(mytype, name), READONLY, 
     "Name of the datum"},
    {NULL}
};</PRE>

<P class="docText">Using <TT>PyObject_GenericGetAttr</TT> and
<TT>PyObject_GenericSetAttr</TT> for
<TT>tp_getattro</TT> and <TT>tp_setattro</TT>
also provides further possibilities, which I will not cover in detail
in this book. Field <TT>tp_getset</TT> points to a
sentinel-terminated array of <TT>PyGetSetDef</TT> structs,
the equivalent of having <TT>property</TT> instances in a
Python-coded class. If your
<TT>PyTypeObject</TT>'s field
<TT>tp_dictoffset</TT> is not equal to
<TT>0</TT>, the field's value must be the
offset, within the per-instance struct, of a
<TT>PyObject*</TT> that points to a Python dictionary. In
this case, the generic attribute access API functions use that
dictionary to allow Python code to set arbitrary attributes on your
type's instances, just like for instances of
Python-coded classes.</P>

<P class="docText">Another dictionary is per-type, not per-instance: the
<TT>PyObject*</TT> for the per-type dictionary is slot
<TT>tp_dict</TT> of your <TT>PyTypeObject</TT>
struct. You can set slot <TT>tp_dict</TT> to
<TT>NULL</TT>, and then <TT>PyType_Ready</TT>
initializes the dictionary appropriately. Alternatively, you can set
<TT>tp_dict</TT> to a dictionary of type attributes, and
then <TT>PyType_Ready</TT> adds other entries to that same
dictionary, in addition to the type attributes you set.
It's generally easier to start with
<TT>tp_dict</TT> set to <TT>NULL</TT>, call
<TT>PyType_Ready</TT> to create and initialize the per-type
dictionary, and then, if need be, add any further entries to the
dictionary.</P>

<P class="docText">Field <TT>tp_flags</TT> is a <TT>long</TT> whose
bits determine your type struct's exact layout,
mostly for backward compatibility. Normally, set this field to
<TT>Py_TPFLAGS_DEFAULT</TT> to indicate that you are
defining a normal, modern type. You should set
<TT>tp_flags</TT> to
<TT>Py_TPFLAGS_DEFAULT|Py_TPFLAGS_HAVE_GC</TT> if your type
supports cyclic garbage collection. Your type should support cyclic
garbage collection if instances of the type contain
<TT>PyObject*</TT> fields that might point to arbitrary
objects and form part of a reference loop. However, to support cyclic
garbage collection, it's not enough to add
<TT>Py_TPFLAGS_HAVE_GC</TT> to field
<TT>tp_flags</TT>; you also have to supply appropriate
functions, indicated by slots <TT>tp_traverse</TT> and
<TT>tp_clear</TT>, and register and unregister your
instances appropriately with the cyclic garbage collector. Supporting
cyclic garbage collection is an advanced subject, and I do not cover
it further in this book. Similarly, I do not cover the advanced
subject of supporting weak references.</P>

<P class="docText">Field <TT>tp_doc</TT>, a <TT>char*</TT>, is a
null-terminated character string that is your type's
docstring. Other fields point to structs (whose fields point to
functions); you can set each such field to <TT>NULL</TT> to
indicate that you support none of the functions of that kind. The
fields pointing to such blocks of functions are
<TT>tp_as_number</TT>, for special methods typically
supplied by numbers; <TT>tp_as_sequence</TT>, for special
methods typically supplied by sequences;
<TT>tp_as_mapping</TT>, for special methods typically
supplied by mappings; and <TT>tp_as_buffer</TT>, for the
special methods of the buffer protocol.</P>

<P class="docText">For example, objects that are not sequences can still support one or
a few of the methods listed in the block to which
<TT>tp_as_sequence</TT> points, and in that case the
<TT>PyTypeObject</TT> must have a
non-<TT>NULL</TT> field <TT>tp_as_sequence</TT>,
even if the block of function pointers it points to is in turn mostly
full of <TT>NULL</TT>s. For example, dictionaries supply a
<TT>_ _contains_ _</TT> special method so that you can
check if <TT><I>x</I></TT> <TT>in</TT>
<TT><I>d</I></TT> when <TT><I>d</I></TT> is a
dictionary. At the C code level, the method is a function pointed to
by field <TT>sq_contains</TT>, which is part of the
<TT>PySequenceMethods</TT> struct to which field
<TT>tp_as_sequence</TT> points. Therefore, the
<TT>PyTypeObject</TT> struct for the
<TT>dict</TT> type, named <TT>PyDict_Type</TT>,
has a non-<TT>NULL</TT> value for
<TT>tp_as_sequence</TT>, even though a dictionary supplies
no other field in <TT>PySequenceMethods</TT> except
<TT>sq_contains</TT>, and therefore all other fields in
<TT>*(PyDict_Type.tp_as_sequence)</TT> are
<TT>NULL</TT>.</P>



<A NAME="pythonian-CHP-24-SECT-1.12.5"></A>
<H5 class="docSection3Title">24.1.12.5 Type definition example</H5>

<P class="docText"><A class="docLink" HREF="#pythonian-CHP-24-EX-2">Example 24-2</A> is a complete Python extension module
that defines the very simple type <TT>intpair</TT>, each
instance of which holds two integers named <TT>first</TT>
and <TT>second</TT>.</P>


<H5 class="docExampleTitle"><A NAME="pythonian-CHP-24-EX-2"></A>Example 24-2. Defining a new intpair type</H5>
<PRE>#include "Python.h"
#include "structmember.h"

/* per-instance data structure */
typedef struct {
    PyObject_HEAD
    int first, second;
} intpair;

static int
intpair_init(PyObject *self, PyObject *args, PyObject *kwds)
{
    static char* nams[] = {"first","second",NULL};
    int first, second;
    if(!PyArg_ParseTupleAndKeywords(args, kwds, "ii", nams, &amp;first, &amp;second))
        return -1;
    ((intpair*)self)-&gt;first = first;
    ((intpair*)self)-&gt;second = second;
    return 0;
}

static void
intpair_dealloc(PyObject *self)
{
    self-&gt;ob_type-&gt;tp_free(self);
}

static PyObject*
intpair_str(PyObject* self)
{
    return PyString_FromFormat("intpair(%d,%d)",
        ((intpair*)self)-&gt;first, ((intpair*)self)-&gt;second);
}

static PyMemberDef intpair_members[] = {
    {"first", T_INT, offsetof(intpair, first), 0, "first item" },
    {"second", T_INT, offsetof(intpair, second), 0, "second item" },
    {NULL}
};

static PyTypeObject t_intpair = {
    PyObject_HEAD_INIT(0)               /* tp_head */
    0,                                  /* tp_internal */
    "intpair.intpair",                  /* tp_name */
    sizeof(intpair),                    /* tp_basicsize */
    0,                                  /* tp_itemsize */
    intpair_dealloc,                    /* tp_dealloc */
    0,                                  /* tp_print */
    0,                                  /* tp_getattr */
    0,                                  /* tp_setattr */
    0,                                  /* tp_compare */
    intpair_str,                        /* tp_repr */
    0,                                  /* tp_as_number */
    0,                                  /* tp_as_sequence */
    0,                                  /* tp_as_mapping */
    0,                                  /* tp_hash */
    0,                                  /* tp_call */
    0,                                  /* tp_str */
    PyObject_GenericGetAttr,            /* tp_getattro */
    PyObject_GenericSetAttr,            /* tp_setattro */
    0,                                  /* tp_as_buffer */
    Py_TPFLAGS_DEFAULT,
    "two ints (first,second)",
    0,                                  /* tp_traverse */
    0,                                  /* tp_clear */
    0,                                  /* tp_richcompare */
    0,                                  /* tp_weaklistoffset */
    0,                                  /* tp_iter */
    0,                                  /* tp_iternext */
    0,                                  /* tp_methods */
    intpair_members,                    /* tp_members */
    0,                                  /* tp_getset */
    0,                                  /* tp_base */
    0,                                  /* tp_dict */
    0,                                  /* tp_descr_get */
    0,                                  /* tp_descr_set */
    0,                                  /* tp_dictoffset */
    intpair_init,                       /* tp_init */
    PyType_GenericAlloc,                /* tp_alloc */
    PyType_GenericNew,                  /* tp_new */
    _PyObject_Del,                      /* tp_free */
};

void
initintpair(void)
{
    static PyMethodDef no_methods[] = { {NULL} };
    PyObject* this_module = Py_InitModule("intpair", no_methods);
    PyType_Ready(&amp;t_intpair);
    PyObject_SetAttrString(this_module, "intpair", (PyObject*)&amp;t_intpair);
}</PRE>


<P class="docText">The <TT>intpair</TT> type defined in <A class="docLink" HREF="#pythonian-CHP-24-EX-2">Example 24-2</A> gives just about no substantial benefits when
compared to an equivalent definition in Python, such as:</P>

<PRE>class intpair(object):
    __slots_  _ = 'first', 'second'
    def __init_  _(self, first, second):
        self.first = first
        self.second = second
    def __repr_  _(self):
        return 'intpair(%s,%s)' % (self.first, self.second)</PRE>

<P class="docText">The C-coded version does ensure the two attributes are integers,
truncating float or complex number arguments as needed. For example:</P>

<PRE>import intpair
x=intpair.intpair(1.2,3.4)                 # x is: intpair(1,3)</PRE>

<P class="docText">Each instance of the C-coded version of <TT>intpair</TT>
occupies somewhat less memory than an instance of the Python version
in the above example. However, the purpose of <A class="docLink" HREF="#pythonian-CHP-24-EX-2">Example 24-2</A> is purely didactic: to present a C-coded
Python extension that defines a new type.<A NAME="pythonian-CHP-24-ITERM-9345"></A> <A NAME="pythonian-CHP-24-ITERM-9346"></A></P>




<ul></ul>
</td>
</tr>
</table>
<td></td>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<td class="tt1"><a href="NFO/lib.html">[ Team LiB ]</a></td><td valign="top" class="tt1" align="right">
          <a href="0596001886_pythonian-chp-24.html"><img src="FILES/previous.gif" width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a>
          <a href="0596001886_pythonian-chp-24-sect-2.html"><img src="FILES/next.gif" width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a>
</td></table>
</body></html>
