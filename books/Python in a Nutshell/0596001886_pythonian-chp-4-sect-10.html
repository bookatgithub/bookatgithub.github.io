<html><head>
<META http-equiv="Content-Type" content="text/html">
<!--SafClassName="docSection1Title"--><!--SafTocEntry="4.10 Functions"-->
<link rel="STYLESHEET" type="text/css" href="FILES/style.css">
<link rel="STYLESHEET" type="text/css" href="FILES/docsafari.css">
<style type="text/css">	.tt1    {font-size: 10pt;}</style>
</head>
<body>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<td class="tt1"><a href="NFO/lib.html">[ Team LiB ]</a></td><td valign="top" class="tt1" align="right">
	<a href="0596001886_pythonian-chp-4-sect-9.html"><img src="FILES/previous.gif" width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a>
	<a href="0596001886_pythonian-chp-5.html"><img src="FILES/next.gif" width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a>
</td></table>
<br>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<tr>
<td valign="top"><A NAME="pythonian-CHP-4-SECT-10"></A>
<H3 class="docSection1Title">4.10 Functions</H3>

<P class="docText"><A NAME="pythonian-CHP-4-ITERM-4125"></A>Most
statements in a typical Python program are organized into functions.
A <I>function</I> is a group of statements that
executes upon request. Python provides many built-in functions and
allows programmers to define their own functions. A request to
execute a function is known as a <I>function</I>
<I>call</I>. When a function is called, it may be
passed arguments that specify data upon which the function performs
its computation. In Python, a function always returns a result value,
either <TT>None</TT> or a value that represents the results
of its computation. Functions defined within <TT>class</TT>
statements are also called <I>methods</I>. Issues
specific to methods are covered in <A class="docLink" HREF="0596001886_pythonian-chp-5.html#pythonian-CHP-5">Chapter 5</A>; the
general coverage of functions in this section, however, also applies
to methods.<A NAME="pythonian-CHP-4-ITERM-4126"></A>
<A NAME="pythonian-CHP-4-ITERM-4127"></A></P>

<P class="docText">In Python, functions are objects (values) and are handled like other
objects. Thus, you can pass a function as an argument in a call to
another function. Similarly, a function can return another function
as the result of a call. A function, just like any other object, can
be bound to a variable, an item in a container, or an attribute of an
object. Functions can also be keys into a dictionary. For example, if
you need to quickly find a function's inverse given
the function, you could define a dictionary whose keys and values are
functions and then make the dictionary bidirectional (using some
functions from module <TT>math</TT>, covered in <A class="docLink" HREF="0596001886_pythonian-chp-15.html#pythonian-CHP-15">Chapter 15</A>):</P>

<PRE>inverse = {sin:asin, cos:acos, tan:atan, log:exp}
for f in inverse.keys(  ): inverse[inverse[f]] = f</PRE>

<P class="docText">The fact that functions are objects in Python is often expressed by
saying that functions are first-class objects.</P>

<A NAME="pythonian-CHP-4-SECT-10.1"></A>
<H4 class="docSection2Title">4.10.1 The def Statement</H4>

<P class="docText"><A NAME="pythonian-CHP-4-ITERM-4128"></A>
<A NAME="pythonian-CHP-4-ITERM-4129"></A>
<A NAME="pythonian-CHP-4-ITERM-4130"></A> <A NAME="pythonian-CHP-4-ITERM-4131"></A>The
<TT>def</TT> statement is the most common way to define a
function. <TT>def</TT> is a single-clause compound
statement with the following syntax:</P>

<PRE>def <TT><I>function-name</I></TT>(<TT><I>parameters</I></TT>): 
    <TT><I>statement(s)</I></TT></PRE>

<P class="docText"><TT><I>function-name</I></TT> is an identifier. It is a
variable that gets bound (or rebound) to the function object when
<TT>def</TT> executes.</P>

<P class="docText"><TT><I>parameters</I></TT><A NAME="pythonian-CHP-4-ITERM-4132"></A> is an optional list of identifiers,
called <span class="docEmphasis">formal</span> <span class="docEmphasis">parameters</span> or
just parameters, that are used to represent values that are supplied
as arguments when the function is called. In the simplest case, a
function doesn't have any formal parameters, which
means the function doesn't take any arguments when
it is called. In this case, the function definition has empty
parentheses following <TT><I>function-name</I></TT>.</P>

<P class="docText">When a function does take arguments,
<TT><I>parameters</I></TT> contains one or more
identifiers, separated by commas (,). In this
case, each call to the function supplies values, known as
<I>arguments</I>, that correspond to the parameters
specified in the function definition. The parameters are local
variables of the function, as we'll discuss later in
this section, and each call to the function binds these local
variables to the corresponding values that the caller supplies as
arguments.<A NAME="pythonian-CHP-4-ITERM-4133"></A>
<A NAME="pythonian-CHP-4-ITERM-4134"></A>
<A NAME="pythonian-CHP-4-ITERM-4135"></A>
<A NAME="pythonian-CHP-4-ITERM-4136"></A></P>

<P class="docText">The non-empty sequence of statements, known as the
<I>function</I> <I>body</I>, does not
execute when the <TT>def</TT> statement executes. Rather,
the function body executes later, each time the function is called.
The function body can contain zero or more occurrences of the
<TT>return</TT> statement, as we'll
discuss shortly.</P>

<P class="docText">Here's an example of a simple function that returns
a value that is double the value passed to it:</P>

<PRE>def double(x):
    return x*2</PRE>


<A NAME="pythonian-CHP-4-SECT-10.2"></A>
<H4 class="docSection2Title">4.10.2 Parameters</H4>

<P class="docText"><A NAME="pythonian-CHP-4-ITERM-4137"></A>
<A NAME="pythonian-CHP-4-ITERM-4138"></A>Formal parameters
that are simple identifiers indicate <span class="docEmphasis">mandatory</span>
<span class="docEmphasis">parameters</span>. Each call to the function must
supply a corresponding value (argument) for each mandatory
parameter.<A NAME="pythonian-CHP-4-ITERM-4139"></A></P>

<P class="docText">In the comma-separated list of parameters, zero or more mandatory
parameters may be followed by zero or more
<span class="docEmphasis">optional</span> <span class="docEmphasis">parameters</span>, where
each optional parameter has the syntax:<A NAME="pythonian-CHP-4-ITERM-4140"></A></P>

<PRE><TT><I>identifier</I></TT>=<TT><I>expression</I></TT></PRE>

<P class="docText">The <TT>def</TT> statement evaluates the
<TT><I>expression</I></TT> and saves a reference to the
value returned by the expression, called the
<I>default</I> <I>value</I> for the
parameter, among the attributes of the function object. When a
function call does not supply an argument corresponding to an
optional parameter, the call binds the parameter's
identifier to its default value for that execution of the function.</P>

<P class="docText">Note that the same object, the default value, gets bound to the
optional parameter whenever the caller does not supply a
corresponding argument. This can be tricky when the default value is
a mutable object and the function body alters the parameter. For
example:</P>

<PRE>def f(x, y=[  ]):
    y.append(x)
    return y
print f(23)                # prints: [23]
prinf f(42)                # prints: [23,42]</PRE>

<P class="docText">The second <TT>print</TT> statement prints
<TT>[23,42]</TT> because the first call to
<TT>f</TT> altered the default value of
<TT>y</TT>, originally an empty list <TT>[
]</TT>, by appending <TT>23</TT> to it. If you want
<TT>y</TT> to be bound to a new empty list object each time
<TT>f</TT> is called with a single argument, use the
following:</P>

<PRE>def f(x, y=None):
    if y is None: y = [  ]
    y.append(x)
    return y
print f(23)                # prints: [23]
prinf f(42)                # prints: [42]</PRE>

<P class="docText">At the end of the formal parameters, you may optionally use either or
both of the special forms
<TT>*</TT><TT><I>identifier1</I></TT> and
<TT>**</TT><TT><I>identifier2</I></TT>. If both
are present, the one with two asterisks must be last.
<TT>*</TT><TT><I>identifier1</I></TT> indicates
that any call to the function may supply extra positional arguments,
while <TT>**</TT><TT><I>identifier2</I></TT>
specifies that any call to the function may supply extra named
arguments (positional and named arguments are covered later in this
chapter). Every call to the function binds
<TT><I>identifier1</I></TT> to a tuple whose items are the
extra positional arguments (or the empty tuple, if there are none).
<TT><I>identifier2</I></TT> is bound to a dictionary whose
items are the names and values of the extra named arguments (or the
empty dictionary, if there are none). Here's how to
write a function that accepts any number of arguments and returns
their sum:</P>

<PRE>def sum(*numbers):
    result = 0
    for number in numbers: result += number
    return result
print sum(23,42)           # prints: 65</PRE>

<P class="docText">The <TT>**</TT> form also lets you construct a dictionary
with string keys in a more readable fashion than with the standard
dictionary creation syntax:</P>

<PRE>def adict(**kwds): return kwds
print adict(a=23, b=42)    # prints: {'a':23, 'b':42}</PRE>

<P class="docText">Note that the body of function <TT>adict</TT> is just one
simple statement, and therefore we can exercise the option to put it
on the same line as the <TT>def</TT> statement. Of course,
it would be just as correct (and arguably more readable) to code
function <TT>adict</TT> using two lines instead of one:</P>

<PRE>def adict(**kwds):
    return kwds</PRE>


<A NAME="pythonian-CHP-4-SECT-10.3"></A>
<H4 class="docSection2Title">4.10.3 Attributes of Function Objects</H4>

<P class="docText"><A NAME="pythonian-CHP-4-ITERM-4141"></A>
<A NAME="pythonian-CHP-4-ITERM-4142"></A>The
<TT>def</TT> statement defines some attributes of a
function object. The attribute <TT>func_name</TT>, also
accessible as <TT>_ _name_ _</TT>, is a read-only attribute
(trying to rebind or unbind it raises a runtime exception) that
refers to the identifier used as the function name in the
<TT>def</TT> statement. The attribute
<TT>func_defaults</TT>, which you may rebind or unbind,
refers to the tuple of default values for the optional parameters (or
the empty tuple, if the function has no optional
parameters).<A NAME="pythonian-CHP-4-ITERM-4143"></A></P>

<P class="docText"><A NAME="pythonian-CHP-4-ITERM-4144"></A>
<A NAME="pythonian-CHP-4-ITERM-4145"></A>
<A NAME="pythonian-CHP-4-ITERM-4146"></A>Another function
attribute is the <I>documentation</I>
<I>string</I>, also known as a
<I>docstring</I>. You may use or rebind a
function's docstring attribute as either
<TT>func_doc</TT> or <TT>_ _doc_ _</TT>. If the
first statement in the function body is a string literal, the
compiler binds that string as the function's
docstring attribute. A similar rule applies to classes (see <A class="docLink" HREF="0596001886_pythonian-chp-5.html#pythonian-CHP-5">Chapter 5</A>) and modules (see <A class="docLink" HREF="0596001886_pythonian-chp-7.html#pythonian-CHP-7">Chapter 7</A>). Docstrings most often span multiple physical
lines, and are therefore normally specified in triple-quoted string
literal form. For example:</P>

<PRE>def sum(*numbers):
    '''Accept arbitrary numerical arguments and return their sum.

    The arguments are zero or more numbers.  The result is their sum.'''

    result = 0
    for number in numbers: result += number
    return result</PRE>

<P class="docText">Documentation strings should be part of any Python code you write.
They play a role similar to that of comments in any programming
language, but their applicability is wider since they are available
at runtime. Development environments and other tools may use
docstrings from function, class, and module objects to remind the
programmer how to use those objects. The <TT>doctest</TT>
module (covered in <A class="docLink" HREF="0596001886_pythonian-chp-17.html#pythonian-CHP-17">Chapter 17</A>) makes it easy to
check that the sample code in docstrings is accurate and correct.</P>

<P class="docText">To make your docstrings as useful as possible, you should respect a
few simple conventions. The first line of a docstring should be a
concise summary of the function's purpose, starting
with an uppercase letter and ending with a period. It should not
mention the function's name, unless the name happens
to be a natural-language word that comes naturally as part of a good,
concise summary of the function's operation. If the
docstring is multiline, the second line should be empty, and the
following lines should form one or more paragraphs, separated by
empty lines, describing the function's expected
arguments, preconditions, return value, and side effects (if any).
Further explanations, bibliographical references, and usage examples
(to be checked with <TT>doctest</TT>) can optionally follow
toward the end of the docstring.</P>

<P class="docText">In addition to its predefined attributes, a function object may be
given arbitrary attributes. To create an attribute of a function
object, bind a value to the appropriate attribute references in an
assignment statement after the <TT>def</TT> statement has
executed. For example, a function could count how many times it is
called:</P>

<PRE>def counter(  ):
    counter.count += 1
    return counter.count
counter.count = 0</PRE>

<P class="docText">Note that this is not common usage. More often, when you want to
group together some state (data) and some behavior (code), you should
use the object-oriented mechanisms covered in <A class="docLink" HREF="0596001886_pythonian-chp-5.html#pythonian-CHP-5">Chapter 5</A>. However, the ability to associate arbitrary
attributes with a function can sometimes come in handy.</P>


<A NAME="pythonian-CHP-4-SECT-10.4"></A>
<H4 class="docSection2Title">4.10.4 The return Statement</H4>

<P class="docText"><A NAME="pythonian-CHP-4-ITERM-4147"></A> <A NAME="pythonian-CHP-4-ITERM-4148"></A>The <TT>return</TT>
statement in Python is allowed only inside a function body, and it
can optionally be followed by an expression. When
<TT>return</TT> executes, the function terminates and the
value of the expression is returned. A function returns
<TT>None</TT> if it terminates by reaching the end of its
body or by executing a <TT>return</TT> statement that has
no expression.</P>

<P class="docText">As a matter of style, you should not write a
<TT>return</TT> statement without an expression at the end
of a function body. If some <TT>return</TT> statements in a
function have an expression, all <TT>return</TT> statements
should have an expression. <TT>return</TT>
<TT>None</TT> should only be written explicitly to meet
this style requirement. Python does not enforce these stylistic
conventions, but your code will be clearer and more readable if you
follow them.</P>


<A NAME="pythonian-CHP-4-SECT-10.5"></A>
<H4 class="docSection2Title">4.10.5 Calling Functions</H4>

<P class="docText"><A NAME="pythonian-CHP-4-ITERM-4149"></A> <A NAME="pythonian-CHP-4-ITERM-4150"></A>A function call is an expression
with the following syntax:</P>

<PRE><TT><I>function-object</I></TT>(<TT><I>arguments</I></TT>)</PRE>

<P class="docText"><TT><I>function-object</I></TT> may be any reference to a
function object; it is most often the function's
name. The parentheses denote the function-call operation itself.
<TT><I>arguments</I></TT>, in the simplest case, is a
series of zero or more expressions separated by commas
(,), giving values for the
function's corresponding formal parameters. When a
function is called, the parameters are bound to these values, the
function body executes, and the value of the function-call expression
is whatever the function returns.<A NAME="pythonian-CHP-4-ITERM-4151"></A> <A NAME="pythonian-CHP-4-ITERM-4152"></A></P>

<A NAME="pythonian-CHP-4-SECT-10.5.1"></A>
<H5 class="docSection3Title">4.10.5.1 The semantics of argument passing</H5>

<P class="docText"><A NAME="pythonian-CHP-4-ITERM-4153"></A>In
traditional terms, all argument passing in Python is <I>by
value</I>. For example, if a variable is passed as an
argument, Python passes to the function the object (value) to which
the variable currently refers, not the variable itself. Thus, a
function cannot rebind the caller's variables.
However, if a mutable object is passed as an argument, the function
may request changes to that object since Python passes the object
itself, not a copy. Rebinding a variable and mutating an object are
totally different concepts in Python. For example:</P>

<PRE>def f(x, y):
    x = 23
    y.append(42)
a = 77
b = [99]
f(a, b)
print a, b                # prints: 77 [99, 42]</PRE>

<P class="docText">The <TT>print</TT> statement shows that
<TT>a</TT> is still bound to <TT>77</TT>.
Function <TT>f</TT>'s rebinding of its
parameter <TT>x</TT> to <TT>23</TT> has no effect
on <TT>f</TT>'s caller, and in particular
on the binding of the caller's variable, which
happened to be used to pass <TT>77</TT> as the
parameter's value. However, the
<TT>print</TT> statement also shows that
<TT>b</TT> is now bound to <TT>[99,42]</TT>.
<TT>b</TT> is still bound to the same list object as before
the call, but that object has mutated, as <TT>f</TT> has
appended <TT>42</TT> to that list object. In either case,
<TT>f</TT> has not altered the caller's
bindings, nor can <TT>f</TT> alter the number
<TT>77</TT>, as numbers are immutable. However,
<TT>f</TT> can alter a list object, as list objects are
mutable. In this example, <TT>f</TT> does mutate the list
object that the caller passes to <TT>f</TT> as the second
argument by calling the object's
<TT>append</TT> method.</P>



<A NAME="pythonian-CHP-4-SECT-10.5.2"></A>
<H5 class="docSection3Title">4.10.5.2 Kinds of arguments</H5>

<P class="docText">Arguments that are just expressions are called
<I>positional</I> <span class="docEmphasis">arguments</span>. Each
positional argument supplies the value for the formal parameter that
corresponds to it by position (order) in the function
definition.<A NAME="pythonian-CHP-4-ITERM-4154"></A> <A NAME="pythonian-CHP-4-ITERM-4155"></A> <A NAME="pythonian-CHP-4-ITERM-4156"></A></P>

<P class="docText">In a function call, zero or more positional arguments may be followed
by zero or more <I>named</I>
<span class="docEmphasis">arguments</span> with the following syntax:</P>

<PRE><TT><I>identifier</I></TT>=<TT><I>expression</I></TT></PRE>

<P class="docText">The <TT><I>identifier</I></TT> must be one of the formal
parameter names used in the <TT>def</TT> statement for the
function. The <TT><I>expression</I></TT> supplies the
value for the formal parameter of that name.</P>

<P class="docText">A function call must supply, via either a positional or a named
argument, exactly one value for each mandatory parameter, and zero or
one value for each optional parameter. For example:</P>

<PRE>def divide(divisor, dividend): return dividend // divisor
print divide(12,94)                         # prints: 7
print divide(dividend=94, divisor=12)       # prints: 7</PRE>

<P class="docText">As you can see, the two calls to <TT>divide</TT> are
equivalent. You can pass named arguments for readability purposes
when you think that identifying the role of each argument and
controlling the order of arguments enhances your
code's clarity.</P>

<P class="docText">A more common use of named arguments is to bind some optional
parameters to specific values, while letting other optional
parameters take their default values:</P>

<PRE>def f(middle, begin='init', end='finis'): return begin+middle+end
print f('tini', end='')                     # prints: inittini</PRE>

<P class="docText">Thanks to named argument <TT>end='</TT>', the caller can
specify a value, the empty string '', for
<TT>f</TT>'s third parameter,
<TT>end</TT>, and still let
<TT>f</TT>'s second parameter,
<TT>begin</TT>, use its default value, the string
'<TT>init</TT>'.</P>

<P class="docText">At the end of the arguments in a function call, you may optionally
use either or both of the special forms
<TT>*</TT><TT><I>seq</I></TT> and
<TT>**</TT><TT><I>dict</I></TT>. If both are
present, the one with two asterisks must be last.
<TT>*</TT><TT><I>seq</I></TT> passes the items
of <TT><I>seq</I></TT> to the function as positional
arguments (after the normal positional arguments, if any, that the
call gives with the usual simple syntax).
<TT><I>seq</I></TT> may be any sequence or iterable.
<TT>**</TT><TT><I>dict</I></TT> passes the items
of <TT><I>dict</I></TT> to the function as named
arguments, where <TT><I>dict</I></TT> must be a dictionary
whose keys are all strings. Each item's key is a
parameter name, and the item's value is the
argument's value.</P>

<P class="docText">Sometimes you want to pass an argument of the form
<TT>*</TT><TT><I>seq</I></TT> or
<TT>**</TT><TT><I>dict</I></TT> when the formal
parameters use similar forms, as described earlier under <A class="docLink" HREF="#pythonian-CHP-4-SECT-10.2">Section 4.10.2</A>. For example, using the
function <TT>sum</TT> defined in that section (and shown
again here), you may want to print the sum of all the values in
dictionary <TT><I>d</I></TT>. This is easy with
<TT>*</TT><TT><I>seq</I></TT>:</P>

<PRE>def sum(*numbers):
    result = 0
    for number in numbers: result += number
    return result
print sum(*d.values(  ))</PRE>

<P class="docText">However, you may also pass arguments of the form
<TT>*</TT><TT><I>seq</I></TT> or
<TT>**</TT><TT><I>dict</I></TT> when calling a
function that does not use similar forms in its formal
parameters.<A NAME="pythonian-CHP-4-ITERM-4157"></A> <A NAME="pythonian-CHP-4-ITERM-4158"></A></P>



<A NAME="pythonian-CHP-4-SECT-10.6"></A>
<H4 class="docSection2Title">4.10.6 Namespaces</H4>

<P class="docText"><A NAME="pythonian-CHP-4-ITERM-4159"></A>
<A NAME="pythonian-CHP-4-ITERM-4160"></A>A
function's formal parameters, plus any variables
that are bound (by assignment or by other binding statements) in the
function body, comprise the function's
<I>local</I> <I>namespace</I>, also known
as <I>local</I> <I>scope</I>. Each of
these variables is called a <I>local</I>
<I>variable</I> of the
function.<A NAME="pythonian-CHP-4-ITERM-4161"></A>
<A NAME="pythonian-CHP-4-ITERM-4162"></A></P>

<P class="docText"><A NAME="pythonian-CHP-4-ITERM-4163"></A>Variables
that are not local are known as <I>global</I>
<span class="docEmphasis">variables</span> (in the absence of nested definitions,
which we'll discuss shortly). Global variables are
attributes of the module object, as covered in <A class="docLink" HREF="0596001886_pythonian-chp-7.html#pythonian-CHP-7">Chapter 7</A>. If a local variable in a function has the
same name as a global variable, whenever that name is mentioned in
the function body, the local variable, not the global variable, is
used. This idea is expressed by saying that the local variable hides
the global variable of the same name throughout the function body.</P>

<A NAME="pythonian-CHP-4-SECT-10.6.1"></A>
<H5 class="docSection3Title">4.10.6.1 The global statement</H5>

<P class="docText"><A NAME="pythonian-CHP-4-ITERM-4164"></A>
<A NAME="pythonian-CHP-4-ITERM-4165"></A> <A NAME="pythonian-CHP-4-ITERM-4166"></A>By default, any variable that is bound
within a function body is a local variable of the function. If a
function needs to rebind some global variables, the first statement
of the function must be:</P>

<PRE>global <TT><I>identifiers</I></TT></PRE>

<P class="docText">where <TT><I>identifiers</I></TT> is one or more
identifiers separated by commas (,). The
identifiers listed in a <TT>global</TT> statement refer to
the global variables (i.e., attributes of the module object) that the
function needs to rebind. For example, the function
<TT>counter</TT> that we saw in
<A class="docLink" HREF="#pythonian-CHP-4-SECT-10.3">Section 4.10.3</A>
could be implemented using <TT>global</TT> and a global
variable rather than an attribute of the function object as follows:</P>

<PRE>_count = 0
def counter(  ):
    global _count
    _count += 1
    return _count</PRE>

<P class="docText">Without the <TT>global</TT> statement, the
<TT>counter</TT> function would raise an
<TT>UnboundLocalError</TT> exception because
<TT>_count</TT> would be an uninitialized (unbound) local
variable. Note also that while the <TT>global</TT>
statement does enable this kind of programming, it is neither elegant
nor advisable. As I mentioned earlier, when you want to group
together some state and some behavior, the object-oriented mechanisms
covered in <A class="docLink" HREF="0596001886_pythonian-chp-5.html#pythonian-CHP-5">Chapter 5</A> are typically the best
approach.</P>

<P class="docText">You don't need <TT>global</TT> if the
function body simply uses a global variable, including changing the
object bound to that variable if the object is mutable. You need to
use a <TT>global</TT> statement only if the function body
rebinds a global variable. As a matter of style, you should not use
<TT>global</TT> unless it's strictly
necessary, as its presence will cause readers of your program to
assume the statement is there for some useful purpose.</P>



<A NAME="pythonian-CHP-4-SECT-10.6.2"></A>
<H5 class="docSection3Title">4.10.6.2 Nested functions and nested scopes</H5>

<P class="docText"><A NAME="pythonian-CHP-4-ITERM-4167"></A>
<A NAME="pythonian-CHP-4-ITERM-4168"></A> <A NAME="pythonian-CHP-4-ITERM-4169"></A> <A NAME="pythonian-CHP-4-ITERM-4170"></A>A <TT>def</TT> statement within
a function body defines a <I>nested</I>
<I>function</I>, and the function whose body includes
the <TT>def</TT> is known as an <I>outer</I>
<I>function</I> to the nested one. Code in a nested
function's body may access (but not rebind) local
variables of an outer function, also known as
<I>free</I> <I>variables</I> of the
nested function. This nested-scope access is automatic in Python 2.2
and later. To request nested-scope access in Python 2.1, the first
statement of the module must be:</P>

<PRE>from _ _future_ _ import nested_scopes</PRE>

<P class="docText">The simplest way to let a nested function access a value is often not
to rely on nested scopes, but rather to explicitly pass that value as
one of the function's arguments. The
argument's value can be bound when the nested
function is defined by using the value as the default for an optional
argument. For example:</P>

<PRE>def percent1(a, b, c):                # works with any version
    def pc(x, total=a+b+c): return (x*100.0) / total
    print "Percentages are ", pc(a), pc(b), pc(c)</PRE>

<P class="docText">Here's the same functionality using nested scopes:</P>

<PRE>def percent2(a, b, c):                # needs 2.2 or "from future import"
    def pc(x): return (x*100.0) / (a+b+c)
    print "Percentages are", pc(a), pc(b), pc(c)</PRE>

<P class="docText">In this specific case, <TT>percent1</TT> has a slight
advantage: the computation of
<TT><I>a</I></TT><TT>+</TT><TT><I>b</I></TT><TT>+</TT><TT><I>c</I></TT>
happens only once, while
<TT>percent2</TT>'s inner function
<TT>pc</TT> repeats the computation three times. However,
if the outer function were rebinding its local variables between
calls to the nested function, repeating this computation might be an
advantage. It's therefore advisable to be aware of
both approaches, and choose the most appropriate one case by case.</P>

<P class="docText">A nested function that accesses values from outer local variables is
known as a <I>closure</I>. The following example shows
how to build a closure without nested scopes (using a default value):</P>

<PRE>def make_adder_1(augend):             # works with any version
    def add(addend, _augend=augend): return addend+_augend
    return add</PRE>

<P class="docText">Here's the same closure functionality using nested
scopes:</P>

<PRE>def make_adder_2(augend):             # needs 2.2 or "from future import"
    def add(addend): return addend+augend
    return add</PRE>

<P class="docText">Closures are an exception to the general rule that the
object-oriented mechanisms covered in <A class="docLink" HREF="0596001886_pythonian-chp-5.html#pythonian-CHP-5">Chapter 5</A>
are the best way to bundle together data and code. When you need to
construct callable objects, with some parameters fixed at object
construction time, closures can be simpler and more effective than
classes. For example, the result of
<TT>make_adder_1(7)</TT> is a function that accepts a
single argument and adds <TT>7</TT> to that argument (the
result of <TT>make_adder_2(7)</TT> behaves in just the same
way). You can also express the same idea as <TT>lambda</TT>
<TT><I>x</I></TT>:
<TT><I>x</I></TT><TT>+7</TT>, using the
<TT>lambda</TT> form covered in the next section. A closure
is a "factory" for any member of a
family of functions distinguished by some parameters, such as the
value of argument <TT><I>augend</I></TT> in the previous
examples, and this may often help you avoid code
duplication.<A NAME="pythonian-CHP-4-ITERM-4171"></A> <A NAME="pythonian-CHP-4-ITERM-4172"></A></P>



<A NAME="pythonian-CHP-4-SECT-10.7"></A>
<H4 class="docSection2Title">4.10.7 lambda Expressions</H4>

<P class="docText"><A NAME="pythonian-CHP-4-ITERM-4173"></A> <A NAME="pythonian-CHP-4-ITERM-4174"></A>If a function body contains a single
<TT>return</TT> <TT><I>expression</I></TT>
statement, you may choose to replace the function with the special
<TT>lambda</TT> expression form:</P>

<PRE>lambda <TT><I>parameters</I></TT>: <TT><I>expression</I></TT></PRE>

<P class="docText">A <TT>lambda</TT> expression is the anonymous equivalent of
a normal function whose body is a single <TT>return</TT>
statement. Note that the <TT>lambda</TT> syntax does not
use the <TT>return</TT> keyword. You can use a
<TT>lambda</TT> expression wherever you would use a
reference to a function. <TT>lambda</TT> can sometimes be
handy when you want to use a simple function as an argument or return
value. Here's an example that uses a
<TT>lambda</TT> expression as an argument to the built-in
<TT>filter</TT> function:</P>

<PRE>aList = [1,2,3,4,5,6,7,8,9]
low = 3
high = 7
filter(lambda x,l=low,h=high: h&gt;x&gt;l, aList)     # returns: [4, 5, 6]</PRE>

<P class="docText">As an alternative, you can always use a local <TT>def</TT>
statement that gives the function object a name. You can then use
this name as the argument or return value. Here's
the same <TT>filter</TT> example using a local
<TT>def</TT> statement:</P>

<PRE>aList = [1,2,3,4,5,6,7,8,9]
low = 3
high = 7
def test(value, l=low, h=high):
    return h&gt;value&gt;l
filter(test, aList)                             # returns: [4, 5, 6]</PRE>


<A NAME="pythonian-CHP-4-SECT-10.8"></A>
<H4 class="docSection2Title">4.10.8 Generators</H4>

<P class="docText"><A NAME="pythonian-CHP-4-ITERM-4175"></A>
<A NAME="pythonian-CHP-4-ITERM-4176"></A>
<A NAME="pythonian-CHP-4-ITERM-4177"></A>When the body
of a function contains one or more occurrences of the keyword
<TT>yield</TT>, the function is called a
<I>generator</I>. When a generator is called, the
function body does not execute. Instead, calling the generator
returns a special iterator object that wraps the function body, the
set of its local variables (including its parameters), and the
current point of execution, which is initially the start of the
function.</P>

<P class="docText">When the <TT>next</TT> method of this iterator object is
called, the function body executes up to the next
<TT>yield</TT> statement, which takes the form:</P>

<PRE>yield <TT><I>expression</I></TT></PRE>

<P class="docText">When a <TT>yield</TT> statement executes, the function is
frozen with its execution state and local variables intact, and the
expression following <TT>yield</TT> is returned as the
result of the <TT>next</TT> method. On the next call to
<TT>next</TT>, execution of the function body resumes where
it left off, again up to the next <TT>yield</TT> statement.
If the function body ends or executes a <TT>return</TT>
statement, the iterator raises a <TT>StopException</TT> to
indicate that the iterator is finished. Note that
<TT>return</TT> statements in a generator cannot contain
expressions, as that is a syntax error.</P>

<P class="docText"><TT>yield</TT> is always a keyword in Python 2.3 and later.
In Python 2.2, to make <TT>yield</TT> a keyword in a source
file, use the following line as the first statement in the file:</P>

<PRE>from _ _future_ _ import generators</PRE>

<P class="docText">In Python 2.1 and earlier, you cannot define generators.</P>

<P class="docText">Generators are often handy ways to build iterators. Since the most
common way to use an iterator is to loop on it with a
<TT>for</TT> statement, you typically call a generator like
this:</P>

<PRE>for <TT><I>avariable</I></TT> in <TT><I>somegenerator</I></TT>(<TT><I>arguments</I></TT>):</PRE>

<P class="docText">For example, say that you want a sequence of numbers counting up from
<TT>1</TT> to <TT><I>N</I></TT> and then down to
<TT>1</TT> again. A generator helps:</P>

<PRE>def updown(N):
    for x in xrange(1,N): yield x
    for x in xrange(N,0,-1): yield x
for i in updown(3): print i                   # prints: 1 2 3 2 1</PRE>

<P class="docText">Here is a generator that works somewhat like the built-in
<TT>xrange</TT> function, but returns a sequence of
floating-point values instead of a sequence of integers:</P>

<PRE>def frange(start, stop, step=1.0):
    while start &lt; stop:
        yield start
        start += step</PRE>

<P class="docText"><TT>frange</TT> is only somewhat like
<TT>xrange</TT>, because, for simplicity, it makes
arguments <TT>start</TT> and <TT>stop</TT>
mandatory, and silently assumes <TT>step</TT> is positive
(by default, like <TT>xrange</TT>,
<TT>frange</TT> makes <TT>step</TT> equal to
<TT>1</TT>).</P>

<P class="docText">Generators are more flexible than functions that return lists. A
generator may build an iterator that returns an infinite stream of
results that is usable only in loops that terminate by other means
(e.g., via a <TT>break</TT> statement). Further, the
generator-built iterator performs <span class="docEmphasis">lazy
evaluation</span>: the iterator computes each successive item
only when and if needed, just in time, while the equivalent function
does all computations in advance and may require large amounts of
memory to hold the results list. Therefore, in Python 2.2 and later,
if all you need is the ability to iterate on a computed sequence, it
is often best to compute the sequence in a generator, rather than in
a function that returns a list. If the caller needs a list that
contains all the items produced by a generator
<TT><I>G</I></TT><TT>(</TT><TT><I>arguments</I></TT><TT>)</TT>,
the caller can use the following code:</P>

<PRE><TT><I>resulting_list</I></TT> = list(<TT><I>G</I></TT>(<TT><I>arguments</I></TT>))</PRE>


<A NAME="pythonian-CHP-4-SECT-10.9"></A>
<H4 class="docSection2Title">4.10.9 Recursion</H4>

<P class="docText"><A NAME="pythonian-CHP-4-ITERM-4178"></A>
<A NAME="pythonian-CHP-4-ITERM-4179"></A>
<A NAME="pythonian-CHP-4-ITERM-4180"></A> <A NAME="pythonian-CHP-4-ITERM-4181"></A> <A NAME="pythonian-CHP-4-ITERM-4182"></A>Python supports recursion (i.e., a
Python function can call itself), but there is a limit to how deep
the recursion can be. By default, Python interrupts recursion and
raises a <TT>RecursionLimitExceeded</TT> exception (covered
in <A class="docLink" HREF="0596001886_pythonian-chp-6.html#pythonian-CHP-6">Chapter 6</A>) when it detects that the stack of
recursive calls has gone over a depth of 1,000. You can change the
recursion limit with function <TT>setrecursionlimit</TT> of
module <TT>sys</TT>, covered in <A class="docLink" HREF="0596001886_pythonian-chp-8.html#pythonian-CHP-8">Chapter 8</A>.</P>

<P class="docText">However, changing this limit will still not give you unlimited
recursion; the absolute maximum limit depends on the platform,
particularly on the underlying operating system and C runtime
library, but it's typically a few thousand. When
recursive calls get too deep, your program will crash. Runaway
recursion after a call to <TT>setrecursionlimit</TT> that
exceeds the platform's capabilities is one of the
very few ways a Python program can crash—really crash, hard,
without the usual safety net of Python's exception
mechanisms. Therefore, be wary of trying to fix a program that is
getting <TT>RecursionLimitExceeded</TT> exceptions by
raising the recursion limit too high with
<TT>setrecursionlimit</TT>. Most often,
you'd be better advised to look for ways to remove
the recursion or, at least, to limit the depth of recursion that your
program needs.<A NAME="pythonian-CHP-4-ITERM-4183"></A> <A NAME="pythonian-CHP-4-ITERM-4184"></A></P>



<ul></ul>
</td>
</tr>
</table>
<td></td>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<td class="tt1"><a href="NFO/lib.html">[ Team LiB ]</a></td><td valign="top" class="tt1" align="right">
          <a href="0596001886_pythonian-chp-4-sect-9.html"><img src="FILES/previous.gif" width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a>
          <a href="0596001886_pythonian-chp-5.html"><img src="FILES/next.gif" width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a>
</td></table>
</body></html>
