<html><head>
<META http-equiv="Content-Type" content="text/html">
<!--SafClassName="docSection1Title"--><!--SafTocEntry="4.3 Variables and Other References"-->
<link rel="STYLESHEET" type="text/css" href="FILES/style.css">
<link rel="STYLESHEET" type="text/css" href="FILES/docsafari.css">
<style type="text/css">	.tt1    {font-size: 10pt;}</style>
</head>
<body>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<td class="tt1"><a href="NFO/lib.html">[ Team LiB ]</a></td><td valign="top" class="tt1" align="right">
	<a href="0596001886_pythonian-chp-4-sect-2.html"><img src="FILES/previous.gif" width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a>
	<a href="0596001886_pythonian-chp-4-sect-4.html"><img src="FILES/next.gif" width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a>
</td></table>
<br>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<tr>
<td valign="top"><A NAME="pythonian-CHP-4-SECT-3"></A>
<H3 class="docSection1Title">4.3 Variables and Other References</H3>

<P class="docText"><A NAME="pythonian-CHP-4-ITERM-3841"></A>A
Python program accesses data values through references. A
<span class="docEmphasis">reference</span> is a name that refers to the specific
location in memory of a value (object). References take the form of
variables, attributes, and items. In Python, a variable or other
reference has no intrinsic type. The object to which a reference is
bound at a given time does have a type, however. Any given reference
may be bound to objects of different types during the execution of a
program.<A NAME="pythonian-CHP-4-ITERM-3842"></A></P>

<A NAME="pythonian-CHP-4-SECT-3.1"></A>
<H4 class="docSection2Title">4.3.1 Variables</H4>

<P class="docText"><A NAME="pythonian-CHP-4-ITERM-3843"></A>
<A NAME="pythonian-CHP-4-ITERM-3844"></A>
<A NAME="pythonian-CHP-4-ITERM-3845"></A>
<A NAME="pythonian-CHP-4-ITERM-3846"></A>
<A NAME="pythonian-CHP-4-ITERM-3847"></A>
<A NAME="pythonian-CHP-4-ITERM-3848"></A>
<A NAME="pythonian-CHP-4-ITERM-3849"></A>In
Python, there are no declarations. The existence of a variable
depends on a statement that <I>binds</I> the variable,
or, in other words, that sets a name to hold a reference to some
object. You can also <I>unbind</I> a variable by
resetting the name so it no longer holds a reference. Assignment
statements are the most common way to bind variables and other
references. The <TT>del</TT> statement unbinds
references.<A NAME="pythonian-CHP-4-ITERM-3850"></A></P>

<P class="docText"><A NAME="pythonian-CHP-4-ITERM-3851"></A>Binding
a reference that was already bound is also known as
<I>rebinding</I> it. Whenever binding is mentioned in
this book, rebinding is implicitly included except where it is
explicitly excluded. Rebinding or unbinding a reference has no effect
on the object to which the reference was bound, except that an object
disappears when nothing refers to it. The automatic cleanup of
objects to which there are no references is known as
<I>garbage</I>
<I>collection</I>.<A NAME="pythonian-CHP-4-ITERM-3852"></A>
<A NAME="pythonian-CHP-4-ITERM-3853"></A>
<A NAME="pythonian-CHP-4-ITERM-3854"></A></P>

<P class="docText"><A NAME="pythonian-CHP-4-ITERM-3855"></A>
<A NAME="pythonian-CHP-4-ITERM-3856"></A>You can name
a variable with any identifier except the 29 that are reserved as
Python's keywords (see
<A class="docLink" HREF="0596001886_pythonian-chp-4-sect-1.html#pythonian-CHP-4-SECT-1.2.2">Section 4.1.2.2</A> earlier in this
chapter). A variable can be global or local. A
<span class="docEmphasis">global</span> <span class="docEmphasis">variable</span> is an
attribute of a module object (<A class="docLink" HREF="0596001886_pythonian-chp-7.html#pythonian-CHP-7">Chapter 7</A> covers
modules). A <span class="docEmphasis">local</span> <span class="docEmphasis">variable</span>
lives in a function's local namespace (see
<A class="docLink" HREF="0596001886_pythonian-chp-4-sect-10.html#pythonian-CHP-4-SECT-10">Section 4.10</A> later in this chapter).</P>

<A NAME="pythonian-CHP-4-SECT-3.1.1"></A>
<H5 class="docSection3Title">4.3.1.1 Object attributes and items</H5>

<P class="docText"><A NAME="pythonian-CHP-4-ITERM-3857"></A>
<A NAME="pythonian-CHP-4-ITERM-3858"></A> <A NAME="pythonian-CHP-4-ITERM-3859"></A>
<A NAME="pythonian-CHP-4-ITERM-3860"></A>The
distinction between attributes and items of an object is in the
syntax you use to access them. An <I>attribute</I> of
an object is denoted by a reference to the object, followed by a
period (.), followed by an identifier called the
<I>attribute</I> <I>name</I> (i.e.,
<TT><I>x</I></TT>.<TT><I>y</I></TT>
refers to the attribute of object <TT><I>x</I></TT> that
is named <TT><I>y</I></TT>).</P>

<P class="docText"><A NAME="pythonian-CHP-4-ITERM-3861"></A> <A NAME="pythonian-CHP-4-ITERM-3862"></A>An
<I>item</I> of an object is denoted by a reference to
the object, followed by an expression within brackets (<TT>[
]</TT>). The expression in brackets is called the
<I>index</I> or <I>key</I> to the item,
and the object is called the <I>container</I> of the
item (i.e.,
<TT><I>x</I></TT><TT>[</TT><TT><I>y</I></TT><TT>]</TT>
refers to the item at key or index <TT><I>y</I></TT> in
container object <TT><I>x</I></TT>).</P>

<P class="docText"><A NAME="pythonian-CHP-4-ITERM-3863"></A>Attributes that are callable are also known
as <I>methods</I>. Python draws no strong distinction
between callable and non-callable attributes, as other languages do.
General rules about attributes also apply to callable attributes
(methods).</P>



<A NAME="pythonian-CHP-4-SECT-3.1.2"></A>
<H5 class="docSection3Title">4.3.1.2 Accessing nonexistent references</H5>

<P class="docText"><A NAME="pythonian-CHP-4-ITERM-3864"></A>A common programming error is
trying to access a reference that does not exist. For example, a
variable may be unbound, or an attribute name or item index may not
be valid for the object to which you apply it. The Python compiler,
when it analyzes and compiles source code, diagnoses only syntax
errors. Compilation does not diagnose semantic errors such as trying
to access an unbound attribute, item, or variable. Python diagnoses
semantic errors only when the errant code executes, i.e., at runtime.
When an operation is a Python semantic error, attempting it raises an
exception (see <A class="docLink" HREF="0596001886_pythonian-chp-6.html#pythonian-CHP-6">Chapter 6</A>). Accessing a nonexistent
variable, attribute, or item, just like any other semantic error,
raises an exception.</P>



<A NAME="pythonian-CHP-4-SECT-3.2"></A>
<H4 class="docSection2Title">4.3.2 Assignment Statements</H4>

<P class="docText"><A NAME="pythonian-CHP-4-ITERM-3865"></A> <A NAME="pythonian-CHP-4-ITERM-3866"></A> <A NAME="pythonian-CHP-4-ITERM-3867"></A> <A NAME="pythonian-CHP-4-ITERM-3868"></A>Assignment
statements can be plain or augmented. Plain assignment to a variable
(e.g.,
<TT><I>name</I></TT><TT>=</TT><TT><I>value</I></TT>)
is how you create a new variable or rebind an existing variable to a
new value. Plain assignment to an object attribute (e.g.,
<TT><I>obj</I></TT>.<TT><I>attr</I></TT><TT>=</TT><TT><I>value</I></TT>)
is a request to object <TT><I>obj</I></TT> to create or
rebind attribute <TT><I>attr</I></TT>. Plain assignment to
an item in a container (e.g.,
<TT><I>obj</I></TT><TT>[</TT><TT><I>key</I></TT><TT>]=</TT><TT><I>value</I></TT>)
is a request to container <TT><I>obj</I></TT> to create or
rebind the item with index <TT><I>key</I></TT>.</P>

<P class="docText">Augmented assignment (e.g.,
<TT><I>name</I></TT><TT>+=</TT><TT><I>value</I></TT>)
cannot, per se, create new references. Augmented assignment can
rebind a variable, ask an object to rebind one of its existing
attributes or items, or request the target object to modify itself
(an object may, of course, create arbitrary new references while
responding to requests). When you make a request to an object, it is
up to the object to decide whether to honor the request or raise an
exception.</P>

<A NAME="pythonian-CHP-4-SECT-3.2.1"></A>
<H5 class="docSection3Title">4.3.2.1 Plain assignment</H5>

<P class="docText"><A NAME="pythonian-CHP-4-ITERM-3869"></A>
<A NAME="pythonian-CHP-4-ITERM-3870"></A>A plain assignment statement in the
simplest form has the syntax:</P>

<PRE><TT><I>target</I></TT> = <TT><I>expression</I></TT></PRE>

<P class="docText">The target is also known as the left-hand side, and the expression as
the right-hand side. When the assignment statement executes, Python
evaluates the right-hand side expression, then binds the
expression's value to the left-hand side target. The
binding does not depend on the type of the value. In particular,
Python draws no strong distinction between callable and non-callable
objects, as some other languages do, so you can bind functions,
methods, types, and other callables to variables.</P>

<P class="docText"><A NAME="pythonian-CHP-4-ITERM-3871"></A>
<A NAME="pythonian-CHP-4-ITERM-3872"></A>
<A NAME="pythonian-CHP-4-ITERM-3873"></A>Details
of the binding do depend on the kind of target, however. The target
in an assignment may be an identifier, an attribute reference, an
indexing, or a slicing:</P>

<UL>
<LI><P class="docList">An identifier is a variable's name: assignment to an
identifier binds the variable with this name.</P></LI>
<LI><P class="docList">An attribute reference has the syntax
<TT><I>obj</I></TT>.<TT><I>name</I></TT>.
<TT><I>obj</I></TT> is an expression denoting an object,
and <TT><I>name</I></TT> is an identifier, called an
<I>attribute name</I> of the object. Assignment to an
attribute reference asks object <TT><I>obj</I></TT> to
bind its attribute named <TT><I>name</I></TT>.</P></LI>
<LI><P class="docList">An indexing has the syntax
<TT><I>obj</I></TT><TT>[</TT><TT><I>expr</I></TT><TT>]</TT>.
<TT><I>obj</I></TT> and <TT><I>expr</I></TT>
are expressions denoting any objects. Assignment to an indexing asks
container <TT><I>obj</I></TT> to bind its item selected by
the value of <TT><I>expr</I></TT>, also known as the index
or key of the item.</P></LI>
<LI><P class="docList">A slicing has the syntax
<TT><I>obj</I></TT><TT>[</TT><TT><I>start</I></TT>:<TT><I>stop</I></TT><TT>]</TT>
or
<TT><I>obj</I></TT><TT>[</TT><TT><I>start</I></TT>:<TT><I>stop</I></TT>:<TT><I>stride</I></TT><TT>]</TT>.
<TT><I>obj</I></TT>, <TT><I>start</I></TT>,
<TT><I>stop</I></TT>, and
<TT><I>stride</I></TT> are expressions denoting any
objects. <TT><I>start</I></TT>,
<TT><I>stop</I></TT>, and
<TT><I>stride</I></TT> are all optional (i.e.,
<TT><I>obj</I></TT><TT>[</TT>:<TT><I>stop</I></TT><TT>:]</TT>
is also a syntactically correct slicing, equivalent to
<TT><I>obj</I></TT><TT>[None</TT>:<TT><I>stop</I></TT><TT>:None]</TT>).
Assignment to a slicing asks container <TT><I>obj</I></TT>
to bind or unbind some of its items.</P></LI>
</UL>
<P class="docText">We'll come back to indexing and slicing targets
later in this chapter when we discuss operations on lists and
dictionaries.</P>

<P class="docText">When the target of the assignment is an identifier, the assignment
statement specifies the binding of a variable. This is never
disallowed: when you request it, it takes place. In all other cases,
the assignment statement specifies a request to an object to bind one
or more of its attributes or items. An object may refuse to create or
rebind some (or all) attributes or items, raising an exception if you
attempt a disallowed creation or rebinding.</P>

<P class="docText">There can be multiple targets and equals signs (<TT>=</TT>)
in a plain assignment. For example:</P>

<PRE>a = b = c = 0</PRE>

<P class="docText">binds variables <TT>a</TT>, <TT>b</TT>, and
<TT>c</TT> to the value <TT>0</TT>. Each time the
statement executes, the right-hand side expression is evaluated once.
Each target gets bound to the single object returned by the
expression, just as if several simple assignments executed one after
the other.</P>

<P class="docText"><A NAME="pythonian-CHP-4-ITERM-3874"></A> <A NAME="pythonian-CHP-4-ITERM-3875"></A> <A NAME="pythonian-CHP-4-ITERM-3876"></A> <A NAME="pythonian-CHP-4-ITERM-3877"></A>The target in a plain assignment
can list two or more references separated by commas, optionally
enclosed in parentheses or brackets. For
example:<A NAME="pythonian-CHP-4-ITERM-3878"></A> <A NAME="pythonian-CHP-4-ITERM-3879"></A></P>

<PRE>a, b, c = x</PRE>

<P class="docText">This requires <TT>x</TT> to be a sequence with three items,
and binds <TT>a</TT> to the first item,
<TT>b</TT> to the second, and <TT>c</TT> to the
third. This kind of assignment is called an unpacking assignment,
and, in general, the right-hand side expression must be a sequence
with exactly as many items as there are references in the target;
otherwise, an exception is raised. Each reference in the target is
bound to the corresponding item in the sequence. An unpacking
assignment can also swap references:</P>

<PRE>a, b = b, a</PRE>

<P class="docText">This rebinds <TT>a</TT> to refer to what
<TT>b</TT> was bound to, and vice versa.</P>



<A NAME="pythonian-CHP-4-SECT-3.2.2"></A>
<H5 class="docSection3Title">4.3.2.2 Augmented assignment</H5>

<P class="docText"><A NAME="pythonian-CHP-4-ITERM-3880"></A>
<A NAME="pythonian-CHP-4-ITERM-3881"></A>An augmented assignment differs from
a plain assignment in that, instead of an equals sign
(<TT>=</TT>) between the target and the expression, it uses
an <I>augmented</I> <I>operator</I>: a
binary operator followed by <TT>=</TT>. The augmented
operators are <TT>+=</TT>, <TT>-=</TT>,
<TT>*=</TT>, <TT>/=</TT>, <TT>//=</TT>,
<TT>%=</TT>, <TT>**=</TT>, <TT>|=</TT>,
<TT>&gt;&gt;=</TT>, <TT>&lt;&lt;=</TT>,
<TT>&amp;=</TT>, and <TT>^=</TT>. An augmented
assignment can have only one target on the left-hand side; that is,
augmented assignment doesn't support multiple
targets.</P>

<P class="docText">In an augmented assignment, just as in a plain one, Python first
evaluates the right-hand side expression. Then, if the left-hand side
refers to an object that has a special method for the appropriate
in-place version of the operator, Python calls the method with the
right-hand side value as its argument. It is up to the method to
modify the left-hand side object appropriately and return the
modified object (<A class="docLink" HREF="0596001886_pythonian-chp-5.html#pythonian-CHP-5">Chapter 5</A> covers special
methods). If the left-hand side object has no appropriate in-place
special method, Python applies the corresponding binary operator to
the left-hand side and right-hand side objects, then rebinds the
target reference to the operator's result. For
example,
<TT><I>x</I></TT><TT>+=</TT><TT><I>y</I></TT>
is like
<TT><I>x</I></TT><TT>=</TT><TT><I>x</I></TT><TT>._
_iadd_ _(</TT><TT><I>y</I></TT><TT>)</TT>
when <TT><I>x</I></TT> has special method <TT>_
_iadd_ _</TT>. Otherwise
<TT><I>x</I></TT><TT>+=</TT><TT><I>y</I></TT>
is like
<TT><I>x</I></TT><TT>=</TT><TT><I>x</I></TT><TT>+</TT><TT><I>y</I></TT>.</P>

<P class="docText">Augmented assignment never creates its target reference: the target
must already be bound when augmented assignment executes. Augmented
assignment can re-bind the target reference to a new object or modify
the same object to which the target reference was already bound.
Plain assignment, in contrast, can create or rebind the left-hand
side target reference, but it never modifies the object, if any, to
which the target reference was previously bound. The distinction
between objects and references to objects is crucial here. For
example,
<TT><I>x</I></TT><TT>=</TT><TT><I>x</I></TT><TT>+</TT><TT><I>y</I></TT>
does not modify the object to which name <TT><I>x</I></TT>
was originally bound. Rather, it rebinds the name
<TT><I>x</I></TT> to refer to a new object.
<TT><I>x</I></TT><TT>+=</TT><TT><I>y</I></TT>,
in contrast, modifies the object to which the name
<TT><I>x</I></TT> is bound when that object has special
method <TT>_ _iadd_ _</TT>; otherwise,
<TT><I>x</I></TT><TT>+=</TT><TT><I>y</I></TT>
rebinds the name <TT><I>x</I></TT>, just like
<TT><I>x</I></TT><TT>=</TT><TT><I>x</I></TT><TT>+</TT><TT><I>y</I></TT>.<A NAME="pythonian-CHP-4-ITERM-3882"></A> <A NAME="pythonian-CHP-4-ITERM-3883"></A> <A NAME="pythonian-CHP-4-ITERM-3884"></A></P>



<A NAME="pythonian-CHP-4-SECT-3.3"></A>
<H4 class="docSection2Title">4.3.3 del Statements</H4>

<P class="docText"><A NAME="pythonian-CHP-4-ITERM-3885"></A>
<A NAME="pythonian-CHP-4-ITERM-3886"></A>
<A NAME="pythonian-CHP-4-ITERM-3887"></A>Despite its name, a
<TT>del</TT> statement does not delete objects: rather, it
unbinds references. Object deletion may follow as a consequence, by
garbage collection, when no more references to an object exist.</P>

<P class="docText">A <TT>del</TT> statement consists of the keyword
<TT>del</TT>, followed by one or more target references
separated by commas (,). Each target can be a
variable, attribute reference, indexing, or slicing, just like for
assignment statements, and must be bound at the time
<TT>del</TT> executes. When a <TT>del</TT> target
is an identifier, the <TT>del</TT> statement specifies the
unbinding of the variable. As long as the identifier is bound,
unbinding it is never disallowed: when requested, it takes place.</P>

<P class="docText">In all other cases, the <TT>del</TT> statement specifies a
request to an object to unbind one or more of its attributes or
items. An object may refuse to unbind some (or all) attributes or
items, raising an exception if a disallowed unbinding is attempted
(see also <A class="docLink" HREF="0596001886_pythonian-chp-5-sect-3.html#ch05-77047">_ _delattr_ _</A> in <A class="docLink" HREF="0596001886_pythonian-chp-5.html#pythonian-CHP-5">Chapter 5</A>). Unbinding a slicing normally has the same
effect as assigning an empty sequence to that slice, but it is up to
the container object to implement this equivalence.<A NAME="pythonian-CHP-4-ITERM-3888"></A></P>



<a href="0596001886_"><img src="FILES/pixel.gif" width="1" height="1" border="0"></a><ul></ul>
</td>
</tr>
</table>
<td></td>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<td class="tt1"><a href="NFO/lib.html">[ Team LiB ]</a></td><td valign="top" class="tt1" align="right">
          <a href="0596001886_pythonian-chp-4-sect-2.html"><img src="FILES/previous.gif" width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a>
          <a href="0596001886_pythonian-chp-4-sect-4.html"><img src="FILES/next.gif" width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a>
</td></table>
</body></html>
