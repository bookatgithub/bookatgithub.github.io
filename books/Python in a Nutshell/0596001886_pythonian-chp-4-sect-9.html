<html><head>
<META http-equiv="Content-Type" content="text/html">
<!--SafClassName="docSection1Title"--><!--SafTocEntry="4.9 Control Flow Statements"-->
<link rel="STYLESHEET" type="text/css" href="FILES/style.css">
<link rel="STYLESHEET" type="text/css" href="FILES/docsafari.css">
<style type="text/css">	.tt1    {font-size: 10pt;}</style>
</head>
<body>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<td class="tt1"><a href="NFO/lib.html">[ Team LiB ]</a></td><td valign="top" class="tt1" align="right">
	<a href="0596001886_pythonian-chp-4-sect-8.html"><img src="FILES/previous.gif" width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a>
	<a href="0596001886_pythonian-chp-4-sect-10.html"><img src="FILES/next.gif" width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a>
</td></table>
<br>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<tr>
<td valign="top"><A NAME="pythonian-CHP-4-SECT-9"></A>
<H3 class="docSection1Title">4.9 Control Flow Statements</H3>

<P class="docText"><A NAME="pythonian-CHP-4-ITERM-4078"></A>A program's
<I>control</I> <I>flow</I> is the order
in which the program's code executes. The control
flow of a Python program is regulated by conditional statements,
loops, and function calls. This section covers the
<TT>if</TT> statement and <TT>for</TT> and
<TT>while</TT> loops; functions are covered later in this
chapter. Raising and handling exceptions also affects control flow;
exceptions are covered in <A class="docLink" HREF="0596001886_pythonian-chp-6.html#pythonian-CHP-6">Chapter 6</A>.</P>

<A NAME="pythonian-CHP-4-SECT-9.1"></A>
<H4 class="docSection2Title">4.9.1 The if Statement</H4>

<P class="docText"><A NAME="pythonian-CHP-4-ITERM-4079"></A> <A NAME="pythonian-CHP-4-ITERM-4080"></A>Often, you need to execute some
statements only if some condition holds, or choose statements to
execute depending on several mutually exclusive conditions. The
Python compound statement <TT>if</TT>, which uses
<TT>if</TT>, <TT>elif</TT>, and
<TT>else</TT> clauses, lets you conditionally execute
blocks of statements. Here's the syntax for the
<TT>if</TT> statement:</P>

<PRE>if <TT><I>expression</I></TT>:
    <TT><I>statement(s)</I></TT>
elif <TT><I>expression</I></TT>:
    <TT><I>statement(s)</I></TT>
elif <TT><I>expression</I></TT>:
    <TT><I>statement(s)</I></TT>
...
else <TT><I>expression</I></TT>:
    <TT><I>statement(s)</I></TT></PRE>

<P class="docText"><A NAME="pythonian-CHP-4-ITERM-4081"></A>
<A NAME="pythonian-CHP-4-ITERM-4082"></A>The
<TT>elif</TT> and <TT>else</TT> clauses are
optional. Note that unlike some languages, Python does not have a
<TT>switch</TT> statement, so you must use
<TT>if</TT>, <TT>elif</TT>, and
<TT>else</TT> for all conditional processing.</P>

<P class="docText">Here's a typical <TT>if</TT> statement:</P>

<PRE>if x &lt; 0: print "x is negative"
elif x % 2: print "x is positive and odd"
else: print "x is even and non-negative"</PRE>

<P class="docText"><A NAME="pythonian-CHP-4-ITERM-4083"></A>
<A NAME="pythonian-CHP-4-ITERM-4084"></A>When there are
multiple statements in a clause (i.e., the clause controls a block of
statements), the statements are placed on separate logical lines
after the line containing the clause's keyword
(known as the <span class="docEmphasis">header</span> <span class="docEmphasis">line</span>
of the clause) and indented rightward from the header line. The block
terminates when the indentation returns to that of the clause header
(or further left from there). When there is just a single simple
statement, as here, it can follow the : on the
same logical line as the header, but it can also be placed on a
separate logical line, immediately after the header line and indented
rightward from it. Many Python practitioners consider the
separate-line style more readable:</P>

<PRE>if x &lt; 0:
    print "x is negative"
elif x % 2:
    print "x is positive and odd"
else:
    print "x is even and non-negative"</PRE>

<P class="docText"><A NAME="pythonian-CHP-4-ITERM-4085"></A>
<A NAME="pythonian-CHP-4-ITERM-4086"></A>You can use any Python expression as
the condition in an <TT>if</TT> or <TT>elif</TT>
clause. When you use an expression this way, you are using it in a
<I>Boolean</I> <I>context</I>. In a
Boolean context, any value is taken as either true or false. As we
discussed earlier, any non-zero number or non-empty string, tuple,
list, or dictionary evaluates as true. Zero (of any numeric type),
<TT>None</TT>, and empty strings, tuples, lists, and
dictionaries evaluate as false. When you want to test a value
<TT><I>x</I></TT> in a Boolean context, use the following
coding style:</P>

<PRE>if <TT><I>x</I></TT>:</PRE>

<P class="docText">This is the clearest and most Pythonic form. Don't
use:</P>

<PRE>if <TT><I>x</I></TT> is True:
if <TT><I>x</I></TT> =  = True:
if bool(<TT><I>x</I></TT>):</PRE>

<P class="docText">There is a crucial difference between saying that an expression
"returns <TT>True</TT>"
(meaning the expression returns the value <TT>1</TT>
intended as a Boolean result) and saying that an expression
"evaluates as true" (meaning the
expression returns any result that is true in a Boolean context).
When testing an expression, you care about the latter condition, not
the former.</P>

<P class="docText">If the expression for the <TT>if</TT> clause evaluates as
true, the statements following the <TT>if</TT> clause
execute, and the entire <TT>if</TT> statement ends.
Otherwise, the expressions for any <TT>elif</TT> clauses
are evaluated in order. The statements following the first
<TT>elif</TT> clause whose condition is true, if any, are
executed, and the entire <TT>if</TT> statement ends.
Otherwise, if an <TT>else</TT> clause exists, the
statements following it are executed.</P>


<A NAME="pythonian-CHP-4-SECT-9.2"></A>
<H4 class="docSection2Title">4.9.2 The while Statement</H4>

<P class="docText"><A NAME="pythonian-CHP-4-ITERM-4087"></A> <A NAME="pythonian-CHP-4-ITERM-4088"></A>The <TT>while</TT>
statement in Python supports repeated execution of a statement or
block of statements that is controlled by a conditional expression.
Here's the syntax for the <TT>while</TT>
statement:</P>

<PRE>while <TT><I>expression</I></TT>:
    <TT><I>statement(s)</I></TT></PRE>

<P class="docText">A <TT>while</TT> statement can also include an
<TT>else</TT> clause and <TT>break</TT> and
<TT>continue</TT> statements, as we'll
discuss shortly.</P>

<P class="docText">Here's a typical <TT>while</TT> statement:</P>

<PRE>count = 0
while x &gt; 0:
    x = x // 2            # truncating division
    count += 1
print "The approximate log2 is", count</PRE>

<P class="docText">First, <TT><I>expression</I></TT>, which is known as the
<I>loop</I> <I>condition</I>, is
evaluated. If the condition is false, the <TT>while</TT>
statement ends. If the loop condition is satisfied, the statement or
statements that comprise the <I>loop</I>
<I>body</I> are executed. When the loop body finishes
executing, the loop condition is evaluated again, to see if another
iteration should be performed. This process continues until the loop
condition is false, at which point the <TT>while</TT>
statement ends.</P>

<P class="docText">The loop body should contain code that eventually makes the loop
condition false, or the loop will never end unless an exception is
raised or the loop body executes a <TT>break</TT>
statement. A loop that is in a function's body also
ends if a <TT>return</TT> statement executes in the loop
body, as the whole function ends in this case.</P>


<A NAME="pythonian-CHP-4-SECT-9.3"></A>
<H4 class="docSection2Title">4.9.3 The for Statement</H4>

<P class="docText"><A NAME="pythonian-CHP-4-ITERM-4089"></A>
<A NAME="pythonian-CHP-4-ITERM-4090"></A>The <TT>for</TT> statement
in Python supports repeated execution of a statement or block of
statements that is controlled by an iterable expression.
Here's the syntax for the <TT>for</TT>
statement:</P>

<PRE>for <TT><I>target</I></TT> in <TT><I>iterable</I></TT>:
    <TT><I>statement(s)</I></TT></PRE>

<P class="docText">Note that the <TT>in</TT> keyword is part of the syntax of
the <TT>for</TT> statement and is functionally unrelated to
the <TT>in</TT> operator used for membership testing. A
<TT>for</TT> statement can also include an
<TT>else</TT> clause and <TT>break</TT> and
<TT>continue</TT> statements, as we'll
discuss shortly.</P>

<P class="docText">Here's a typical <TT>for</TT> statement:</P>

<PRE>for letter in "ciao":
    print "give me a", letter, "..."</PRE>

<P class="docText"><TT><I>iterable</I></TT> may be any Python expression
suitable as an argument to built-in function <TT>iter</TT>,
which returns an iterator object (explained in detail in the next
section). <TT><I>target</I></TT> is normally an identifier
that names the <I>control</I>
<I>variable</I> of the loop; the <TT>for</TT>
statement successively rebinds this variable to each item of the
iterator, in order. The statement or statements that comprise the
<I>loop</I> <I>body</I> execute once for
each item in <TT><I>iterable</I></TT> (unless the loop
ends because an exception is raised or a <TT>break</TT> or
<TT>return</TT> statement is
executed).<A NAME="pythonian-CHP-4-ITERM-4091"></A></P>

<P class="docText">A target with multiple identifiers is also allowed, as with an
unpacking assignment. In this case, the iterator's
items must then be sequences, each with the same length, equal to the
number of identifiers in the target. For example, when
<TT><I>d</I></TT> is a dictionary, this is a typical way
to loop on the items in <TT><I>d</I></TT>:</P>

<PRE>for key, value in d.items(  ):
    if not key or not value: del d[key]    # keep only true keys and values</PRE>

<P class="docText">The <TT>items</TT> method returns a list of key/value
pairs, so we can use a <TT>for</TT> loop with two
identifiers in the target to unpack each item into
<TT>key</TT> and <TT>value</TT>.</P>

<P class="docText">If the iterator has a mutable underlying object, that object must not
be altered while a <TT>for</TT> loop is in progress on it.
For example, the previous example cannot use
<TT>iteritems</TT> instead of <TT>items</TT>.
<TT>iteritems</TT> returns an iterator whose underlying
object is <TT>d</TT>, so therefore the loop body cannot
mutate <TT>d</TT> (by <TT>del</TT>
<TT>d[key]</TT>). <TT>items</TT> returns a list,
though, so <TT>d</TT> is not the underlying object of the
iterator and the loop body can mutate <TT>d</TT>.</P>

<P class="docText">The control variable may be rebound in the loop body, but is rebound
again to the next item in the iterator at the next iteration of the
loop. The loop body does not execute at all if the iterator yields no
items. In this case, the control variable is not bound or rebound in
any way by the <TT>for</TT> statement. If the iterator
yields at least one item, however, when the loop statement
terminates, the control variable remains bound to the last value to
which the loop statement has bound it. The following code is thus
correct, as long as <TT>someseq</TT> is not empty:</P>

<PRE>for x in someseq:
    process(x)
print "Last item processed was", x</PRE>

<A NAME="pythonian-CHP-4-SECT-9.3.1"></A>
<H5 class="docSection3Title">4.9.3.1 Iterators</H5>

<P class="docText"><A NAME="pythonian-CHP-4-ITERM-4092"></A>
<A NAME="pythonian-CHP-4-ITERM-4093"></A>
<A NAME="pythonian-CHP-4-ITERM-4094"></A>
<A NAME="pythonian-CHP-4-ITERM-4095"></A>
<A NAME="pythonian-CHP-4-ITERM-4096"></A>An
<I>iterator</I> is any object
<TT><I>i</I></TT> such that you can call
<TT><I>i</I></TT><TT>.next( )</TT> without any
arguments. <TT><I>i</I></TT><TT>.next( )</TT>
returns the next item of iterator <TT><I>i</I></TT>, or,
when iterator <TT><I>i</I></TT> has no more items, raises
a <TT>StopIteration</TT> exception. When you write a class
(see <A class="docLink" HREF="0596001886_pythonian-chp-5.html#pythonian-CHP-5">Chapter 5</A>), you can allow instances of the
class to be iterators by defining such a method
<TT>next</TT>. Most iterators are built by implicit or
explicit calls to built-in function <TT>iter</TT>, covered
in <A class="docLink" HREF="0596001886_pythonian-chp-8.html#pythonian-CHP-8">Chapter 8</A>. Calling a generator also returns an
iterator, as we'll discuss later in this
chapter.<A NAME="pythonian-CHP-4-ITERM-4097"></A> <A NAME="pythonian-CHP-4-ITERM-4098"></A>
<A NAME="pythonian-CHP-4-ITERM-4099"></A></P>

<P class="docText">The <TT>for</TT> statement implicitly calls
<TT>iter</TT> to get an iterator. The following statement:</P>

<PRE>for x in c: 
    <TT><I>statement(s)</I></TT></PRE>

<P class="docText">is equivalent to:</P>

<PRE>_temporary_iterator = iter(c)
while True:
    try: x = _temporary_iterator.next(  )
    except StopIteration: break
    <TT><I>statement(s)</I></TT></PRE>

<P class="docText">Thus, if
<TT>iter(</TT><TT><I>c</I></TT><TT>)</TT>
returns an iterator <TT><I>i</I></TT> such that
<TT><I>i</I></TT><TT>.next( )</TT> never raises
<TT>StopIteration</TT> (an <I>infinite</I>
<I>iterator</I>), the loop <TT>for</TT>
<TT><I>x</I></TT> <TT>in</TT>
<TT><I>c</I></TT>: never terminates
(unless the statements in the loop body contain suitable
<TT>break</TT> or <TT>return</TT> statements or
propagate exceptions).
<TT>iter(</TT><TT><I>c</I></TT><TT>)</TT>,
in turn, calls special method <TT><I>c</I></TT><TT>._
_iter_ _( )</TT> to obtain and return an iterator on
<TT><I>c</I></TT>. We'll talk more about
the special method <TT>_ _iter_ _</TT> in <A class="docLink" HREF="0596001886_pythonian-chp-5.html#pythonian-CHP-5">Chapter 5</A>.</P>

<P class="docText">Iterators were first introduced in Python 2.2. In earlier versions,
<TT>for</TT> <TT><I>x</I></TT>
<TT>in</TT>
<TT><I>S</I></TT>: required
<TT><I>S</I></TT> to be a sequence that was indexable with
progressively larger indices <TT>0</TT>,
<TT>1</TT>, ..., and raised an
<TT>IndexError</TT> when indexed with a too-large index.
Thanks to iterators, the <TT>for</TT> statement can now be
used on a container that is not a sequence, such as a dictionary, as
long as the container is iterable (i.e., it defines an <TT>_
_iter_ _</TT> special method so that function
<TT>iter</TT> can accept the container as the argument and
return an iterator on the container). Built-in functions that used to
require a sequence argument now also accept any iterable.</P>



<A NAME="pythonian-CHP-4-SECT-9.3.2"></A>
<H5 class="docSection3Title">4.9.3.2 range and xrange</H5>

<P class="docText"><A NAME="pythonian-CHP-4-ITERM-4100"></A> <A NAME="pythonian-CHP-4-ITERM-4101"></A>Looping over a sequence of integers
is a common task, so Python provides built-in functions
<TT>range</TT> and <TT>xrange</TT> to generate
and return integer sequences. The simplest, most idiomatic way to
loop <span class="docEmphasis">n</span> times in Python
is:<A NAME="pythonian-CHP-4-ITERM-4102"></A> <A NAME="pythonian-CHP-4-ITERM-4103"></A> <A NAME="pythonian-CHP-4-ITERM-4104"></A>
<A NAME="pythonian-CHP-4-ITERM-4105"></A></P>

<PRE>for i in xrange(<TT><I>n</I></TT>):
    <TT><I>statement(s)</I></TT></PRE>

<P class="docText"><TT>range(</TT><TT><I>x</I></TT><TT>)</TT>
returns a list whose items are consecutive integers from
<TT>0</TT> (included) up to <TT><I>x</I></TT>
(excluded).
<TT>range(</TT><TT><I>x</I></TT>,<TT><I>y</I></TT><TT>)</TT>
returns a list whose items are consecutive integers from
<TT><I>x</I></TT> (included) up to
<TT><I>y</I></TT> (excluded). The result is the empty list
if <TT><I>x</I></TT> is greater than or equal to
<TT><I>y</I></TT>.
<TT>range(</TT><TT><I>x</I></TT>,<TT><I>y</I></TT>,<TT><I>step</I></TT><TT>)</TT>
returns a list of integers from <TT><I>x</I></TT>
(included) up to <TT><I>y</I></TT> (excluded), such that
the difference between each two adjacent items in the list is
<TT><I>step</I></TT>. If <TT><I>step</I></TT>
is less than <TT>0</TT>, <TT>range</TT> counts
down from <TT><I>x</I></TT> to
<TT><I>y</I></TT>. <TT>range</TT> returns the
empty list when <TT><I>x</I></TT> is greater than or equal
to <TT><I>y</I></TT> and step is greater than
<TT>0</TT>, or when <TT><I>x</I></TT> is less
than or equal to <TT><I>y</I></TT> and
<TT><I>step</I></TT> is less than <TT>0</TT>. If
<TT><I>step</I></TT> equals <TT>0</TT>,
<TT>range</TT> raises an exception.</P>

<P class="docText">While <TT>range</TT> returns a normal list object, usable
for all purposes, <TT>xrange</TT> returns a special-purpose
object, specifically intended to be used in iterations like the
<TT>for</TT> statement shown previously.
<TT>xrange</TT> consumes less memory than
<TT>range</TT> for this specific use. Leaving aside memory
consumption, you can use <TT>range</TT> wherever you could
use <TT>xrange</TT>.</P>



<A NAME="pythonian-CHP-4-SECT-9.3.3"></A>
<H5 class="docSection3Title">4.9.3.3 List comprehensions</H5>

<P class="docText"><A NAME="pythonian-CHP-4-ITERM-4106"></A> <A NAME="pythonian-CHP-4-ITERM-4107"></A> <A NAME="pythonian-CHP-4-ITERM-4108"></A>
<A NAME="pythonian-CHP-4-ITERM-4109"></A>A
common use of a <TT>for</TT> loop is to inspect each item
in a sequence and build a new list by appending the results of an
expression computed on some or all of the items inspected. The
expression form, called a <I>list</I>
<I>comprehension</I>, lets you code this common idiom
concisely and directly. Since a list comprehension is an expression
(rather than a block of statements), you can use it directly wherever
you need an expression (e.g., as an actual argument in a function
call, in a <TT>return</TT> statement, or as a subexpression
for some other expression).</P>

<P class="docText">A list comprehension has the following syntax:</P>

<PRE>[ <TT><I>expression</I></TT> for <TT><I>target</I></TT> in <TT><I>iterable</I></TT> <TT><I>lc-clauses</I></TT> ]</PRE>

<P class="docText"><TT><I>target</I></TT> and
<TT><I>iterable</I></TT> are the same as in a regular
<TT>for</TT> statement. You must enclose the
<TT><I>expression</I></TT> in parentheses if it indicates
a tuple.</P>

<P class="docText"><TT><I>lc-clauses</I></TT> is a series of zero or more
clauses, each with one of the following forms:</P>

<PRE>for <TT><I>target</I></TT> in <TT><I>iterable</I></TT>
if <TT><I>expression</I></TT></PRE>

<P class="docText"><TT><I>target</I></TT> and
<TT><I>iterable</I></TT> in each <TT>for</TT>
clause of a list comprehension have the same syntax as those in a
regular <TT>for</TT> statement, and the
<TT><I>expression</I></TT> in each <TT>if</TT>
clause of a list comprehension has the same syntax as the
<TT><I>expression</I></TT> in a regular
<TT>if</TT> statement.</P>

<P class="docText">A list comprehension is equivalent to a <TT>for</TT> loop
that builds the same list by repeated calls to the resulting
list's <TT>append</TT> method. For example
(assigning the list comprehension result to a variable for clarity):</P>

<PRE>result1 = [x+1 for x in some_sequence]</PRE>

<P class="docText">is the same as the <TT>for</TT> loop:</P>

<PRE>result2 = [  ]
for x in some_sequence:
    result2.append(x+1)</PRE>

<P class="docText">Here's a list comprehension that uses an
<TT>if</TT> clause:</P>

<PRE>result3 = [x+1 for x in some_sequence if x&gt;23]</PRE>

<P class="docText">which is the same as a <TT>for</TT> loop that contains an
<TT>if</TT> statement:</P>

<PRE>result4 = [  ]
for x in some_sequence:
    if x&gt;23:
        result4.append(x+1)</PRE>

<P class="docText">And here's a list comprehension that uses a
<TT>for</TT> clause:</P>

<PRE>result5 = [x+y for x in alist for y in another]</PRE>

<P class="docText">which is the same as a <TT>for</TT> loop with another
<TT>for</TT> loop nested inside:</P>

<PRE>result6 = [  ]
for x in alist:
    for y in another:
        result6.append(x+y)</PRE>

<P class="docText">As these examples show, the order of <TT>for</TT> and
<TT>if</TT> in a list comprehension is the same as in the
equivalent loop, but in the list comprehension the nesting stays
implicit.<A NAME="pythonian-CHP-4-ITERM-4110"></A>
<A NAME="pythonian-CHP-4-ITERM-4111"></A></P>



<A NAME="pythonian-CHP-4-SECT-9.4"></A>
<H4 class="docSection2Title">4.9.4 The break Statement</H4>

<P class="docText"><A NAME="pythonian-CHP-4-ITERM-4112"></A>
<A NAME="pythonian-CHP-4-ITERM-4113"></A>The <TT>break</TT>
statement is allowed only inside a loop body. When
<TT>break</TT> executes, the loop terminates. If a loop is
nested inside other loops, <TT>break</TT> terminates only
the innermost nested loop. In practical use, a
<TT>break</TT> statement is usually inside some clause of
an <TT>if</TT> statement in the loop body so that it
executes conditionally.</P>

<P class="docText">One common use of <TT>break</TT> is in the implementation
of a loop that decides if it should keep looping only in the middle
of each loop iteration:</P>

<PRE>while True:                     # this loop can never terminate naturally
    x = get_next(  )
    y = preprocess(x)
    if not keep_looping(x, y): break
    process(x, y)</PRE>


<A NAME="pythonian-CHP-4-SECT-9.5"></A>
<H4 class="docSection2Title">4.9.5 The continue Statement</H4>

<P class="docText"><A NAME="pythonian-CHP-4-ITERM-4114"></A>
<A NAME="pythonian-CHP-4-ITERM-4115"></A>The <TT>continue</TT>
statement is allowed only inside a loop body. When
<TT>continue</TT> executes, the current iteration of the
loop body terminates, and execution continues with the next iteration
of the loop. In practical use, a <TT>continue</TT>
statement is usually inside some clause of an <TT>if</TT>
statement in the loop body so that it executes conditionally.</P>

<P class="docText"><A NAME="pythonian-CHP-4-ITERM-4116"></A>The
<TT>continue</TT> statement can be used in place of deeply
nested <TT>if</TT> statements within a loop. For example:</P>

<PRE>for x in some_container:
    if not seems_ok(x): continue
    lowbound, highbound = bounds_to_test(  )
    if x&lt;lowbound or x&gt;=highbound: continue
    if final_check(x):
        do_processing(x)</PRE>

<P class="docText">This equivalent code does conditional processing without
<TT>continue</TT>:</P>

<PRE>for x in some_container:
    if seems_ok(x):
        lowbound, highbound = bounds_to_test(  )
        if lowbound&lt;=x&lt;highbound:
            if final_check(x):
                do_processing(x)</PRE>

<P class="docText">Both versions function identically, so which one you use is a matter
of personal preference.</P>


<A NAME="pythonian-CHP-4-SECT-9.6"></A>
<H4 class="docSection2Title">4.9.6 The else Clause on Loop Statements</H4>

<P class="docText"><A NAME="pythonian-CHP-4-ITERM-4117"></A>
<A NAME="pythonian-CHP-4-ITERM-4118"></A> <A NAME="pythonian-CHP-4-ITERM-4119"></A>Both
the <TT>while</TT> and <TT>for</TT> statements
may optionally have a trailing <TT>else</TT> clause. The
statement or statements after the <TT>else</TT> execute
when the loop terminates naturally (at the end of the
<TT>for</TT> iterator or when the <TT>while</TT>
loop condition becomes false), but not when the loop terminates
prematurely (via <TT>break</TT>, <TT>return</TT>,
or an exception). When a loop contains one or more
<TT>break</TT> statements, you often need to check whether
the loop terminates naturally or prematurely. You can use an
<TT>else</TT> clause on the loop for this purpose:</P>

<PRE>for x in some_container:
    if is_ok(x): break             # item x is satisfactory, terminate loop
else:
    print "Warning: no satisfactory item was found in container"
    x = None</PRE>


<A NAME="pythonian-CHP-4-SECT-9.7"></A>
<H4 class="docSection2Title">4.9.7 The pass Statement</H4>

<P class="docText"><A NAME="pythonian-CHP-4-ITERM-4120"></A>
<A NAME="pythonian-CHP-4-ITERM-4121"></A>The body of a Python compound
statement cannot be empty—it must contain at least one
statement. The <TT>pass</TT> statement, which performs no
action, can be used as a placeholder when a statement is
syntactically required but you have nothing specific to do.
Here's an example of using <TT>pass</TT>
in a conditional statement as a part of somewhat convoluted logic,
with mutually exclusive conditions being tested:</P>

<PRE>if condition1(x):
    process1(x)
elif x&gt;23 or condition2(x) and x&lt;5:
    pass                                # nothing to be done in this case
elif condition3(x):
    process3(x)
else:
    process_default(x)</PRE>


<A NAME="pythonian-CHP-4-SECT-9.8"></A>
<H4 class="docSection2Title">4.9.8 The try Statement</H4>

<P class="docText"><A NAME="pythonian-CHP-4-ITERM-4122"></A>
<A NAME="pythonian-CHP-4-ITERM-4123"></A>Python supports exception handling
with the <TT>try</TT> statement, which includes
<TT>try</TT>, <TT>except</TT>,
<TT>finally</TT>, and <TT>else</TT> clauses. A
program can explicitly raise an exception with the
<TT>raise</TT> statement. As we'll discuss
in detail in <A class="docLink" HREF="0596001886_pythonian-chp-6.html#pythonian-CHP-6">Chapter 6</A>, when an exception is
raised, normal control flow of the program stops and Python looks for
a suitable exception handler.<A NAME="pythonian-CHP-4-ITERM-4124"></A></P>



<ul></ul>
</td>
</tr>
</table>
<td></td>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<td class="tt1"><a href="NFO/lib.html">[ Team LiB ]</a></td><td valign="top" class="tt1" align="right">
          <a href="0596001886_pythonian-chp-4-sect-8.html"><img src="FILES/previous.gif" width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a>
          <a href="0596001886_pythonian-chp-4-sect-10.html"><img src="FILES/next.gif" width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a>
</td></table>
</body></html>
