<html><head>
<META http-equiv="Content-Type" content="text/html">
<!--SafClassName="docSection1Title"--><!--SafTocEntry="5.1 Classic Classes and Instances"-->
<link rel="STYLESHEET" type="text/css" href="FILES/style.css">
<link rel="STYLESHEET" type="text/css" href="FILES/docsafari.css">
<style type="text/css">	.tt1    {font-size: 10pt;}</style>
</head>
<body>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<td class="tt1"><a href="NFO/lib.html">[ Team LiB ]</a></td><td valign="top" class="tt1" align="right">
	<a href="0596001886_pythonian-chp-5.html"><img src="FILES/previous.gif" width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a>
	<a href="0596001886_pythonian-chp-5-sect-2.html"><img src="FILES/next.gif" width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a>
</td></table>
<br>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<tr>
<td valign="top"><A NAME="pythonian-CHP-5-SECT-1"></A>
<H3 class="docSection1Title">5.1 Classic Classes and Instances</H3>

<P class="docText"><A NAME="pythonian-CHP-5-ITERM-4192"></A> <A NAME="pythonian-CHP-5-ITERM-4193"></A> <A NAME="pythonian-CHP-5-ITERM-4194"></A>A
<span class="docEmphasis">classic class</span> is a Python object with several
characteristics:<A NAME="pythonian-CHP-5-ITERM-4195"></A></P>

<UL>
<LI><P class="docList">You can call a class object as if it were a function. The call
creates another object, known as an <I>instance</I> of
the class, that knows what class it belongs to.</P></LI>
<LI><P class="docList">A class has arbitrarily named attributes that you can bind and
reference.</P></LI>
<LI><P class="docList">The values of class attributes can be data objects or function
objects.</P></LI>
<LI><P class="docList">Class attributes bound to functions are known as
<I>methods</I> of the
class.<A NAME="pythonian-CHP-5-ITERM-4196"></A></P></LI>
<LI><P class="docList"><A NAME="pythonian-CHP-5-ITERM-4197"></A> <A NAME="pythonian-CHP-5-ITERM-4198"></A>
<A NAME="pythonian-CHP-5-ITERM-4199"></A>A
method can have a special Python-defined name with two leading and
two trailing underscores. Python invokes such <I>special
methods</I>, if they are present, when various kinds of
operations take place on class instances.</P></LI>
<LI><P class="docList">A class can <I>inherit</I> from other classes, meaning
it can delegate to other class objects the lookup of attributes that
are not found in the class
itself.<A NAME="pythonian-CHP-5-ITERM-4200"></A></P></LI>
</UL>
<P class="docText">An instance of a class is a Python object with arbitrarily named
attributes that you can bind and reference. An instance object
implicitly delegates to its class the lookup of attributes not found
in the instance itself. The class, in turn, may delegate the lookup
to the classes from which it inherits, if any.</P>

<P class="docText">In Python, classes are objects (values), and are handled like other
objects. Thus, you can pass a class as an argument in a call to a
function. Similarly, a function can return a class as the result of a
call. A class, just like any other object, can be bound to a variable
(local or global), an item in a container, or an attribute of an
object. Classes can also be keys into a dictionary. The fact that
classes are objects in Python is often expressed by saying that
classes are first-class
objects.<A NAME="pythonian-CHP-5-ITERM-4201"></A></P>

<A NAME="pythonian-CHP-5-SECT-1.1"></A>
<H4 class="docSection2Title">5.1.1 The class Statement</H4>

<P class="docText"><A NAME="pythonian-CHP-5-ITERM-4202"></A> <A NAME="pythonian-CHP-5-ITERM-4203"></A>The <TT>class</TT> statement
is the most common way to create a class object.
<TT>class</TT> is a single-clause compound statement with
the following syntax:<A NAME="pythonian-CHP-5-ITERM-4204"></A></P>

<PRE>class <TT><I>classname</I></TT>[(<TT><I>base-classes</I></TT>)]: 
    <TT><I>statement(s)</I></TT></PRE>

<P class="docText"><TT><I>classname</I></TT> is an identifier. It is a
variable that gets bound (or rebound) to the class object after the
<TT>class</TT> statement finishes executing.</P>

<P class="docText"><TT><I>base-classes</I></TT> is an optional
comma-delimited series of expressions whose values must be class
objects. These classes are known by different names in different
languages; you can think of them as the <I>base
classes</I>, <I>superclasses</I>, or
<I>parents</I> of the class being created. The class
being created is said to <span class="docEmphasis">inherit</span> from,
<span class="docEmphasis">derive</span> from, <span class="docEmphasis">extend</span>, or
<span class="docEmphasis">subclass</span> its base classes, depending on what
language you are familiar with. This class is also known as a
<span class="docEmphasis">direct subclass</span> or
<span class="docEmphasis">descendant</span> of its base
classes.<A NAME="pythonian-CHP-5-ITERM-4205"></A></P>

<P class="docText"><A NAME="pythonian-CHP-5-ITERM-4206"></A>
<A NAME="pythonian-CHP-5-ITERM-4207"></A>
<A NAME="pythonian-CHP-5-ITERM-4208"></A>The subclass relationship between
classes is transitive. If <TT><I>C1</I></TT> subclasses
<TT><I>C2</I></TT>, and <TT><I>C2</I></TT>
subclasses <TT><I>C3</I></TT>,
<TT><I>C1</I></TT> subclasses
<TT><I>C3</I></TT>. Built-in function
<TT>issubclass(</TT><TT><I>C1</I></TT>,
<TT><I>C2</I></TT><TT>)</TT> accepts two
arguments that are class objects: it returns <TT>True</TT>
if <TT><I>C1</I></TT> subclasses
<TT><I>C2</I></TT>, otherwise it returns
<TT>False</TT>. Any class is considered a subclass of
itself; therefore
<TT>issubclass(</TT><TT><I>C</I></TT>,
<TT><I>C</I></TT><TT>)</TT> returns
<TT>True</TT> for any class <TT><I>C</I></TT>.
The way in which the base classes of a class affect the functionality
of the class is covered later in this chapter.</P>

<P class="docText">The syntax of the <TT>class</TT> statement has a small,
tricky difference from that of the <TT>def</TT> statement
covered in <A class="docLink" HREF="0596001886_pythonian-chp-4.html#pythonian-CHP-4">Chapter 4</A>. In a <TT>def</TT>
statement, parentheses are mandatory between the
function's name and the colon. To define a function
without formal parameters, use a statement such
as:<A NAME="pythonian-CHP-5-ITERM-4209"></A></P>

<PRE>def <TT><I>name</I></TT>(  ): 
    <TT><I>statement(s)</I></TT></PRE>

<P class="docText"><A NAME="pythonian-CHP-5-ITERM-4210"></A> <A NAME="pythonian-CHP-5-ITERM-4211"></A>In a
<TT>class</TT> statement, the parentheses are mandatory if
the class has one or more base classes, but they are forbidden if the
class has no base classes. Thus, to define a class without base
classes, use a statement such as:</P>

<PRE>class <TT><I>name</I></TT>: 
    <TT><I>statement(s)</I></TT></PRE>

<P class="docText">The non-empty sequence of statements that follows the
<TT>class</TT> statement is known as the <I>class
body</I>. A class body executes immediately, as part of the
<TT>class</TT> statement's execution.
Until the body finishes executing, the new class object does not yet
exist and the <TT><I>classname</I></TT> identifier is not
yet bound (or rebound). <A class="docLink" HREF="0596001886_pythonian-chp-5-sect-4.html#pythonian-CHP-5-SECT-4">Section 5.4</A> later in this
chapter provides more details about what happens when a
<TT>class</TT> statement executes.</P>

<P class="docText">Finally, note that the <TT>class</TT> statement does not
create any instances of a class, but rather defines the set of
attributes that are shared by all instances when they are created.</P>


<A NAME="pythonian-CHP-5-SECT-1.2"></A>
<H4 class="docSection2Title">5.1.2 The Class Body</H4>

<P class="docText"><A NAME="pythonian-CHP-5-ITERM-4212"></A>
<A NAME="pythonian-CHP-5-ITERM-4213"></A>The body of a class is where you normally
specify the attributes of the class; these attributes can be data
objects or function objects.</P>

<A NAME="pythonian-CHP-5-SECT-1.2.1"></A>
<H5 class="docSection3Title">5.1.2.1 Attributes of class objects</H5>

<P class="docText"><A NAME="pythonian-CHP-5-ITERM-4214"></A>
<A NAME="pythonian-CHP-5-ITERM-4215"></A>You typically
specify an attribute of a class object by binding a value to an
identifier within the class body. For example:</P>

<PRE>class C1:
    x = 23
print C1.x                               # prints: 23</PRE>

<P class="docText">Class object <TT>C1</TT> now has an attribute named
<TT>x</TT>, bound to the value <TT>23</TT>, and
<TT>C1.x</TT> refers to that attribute.</P>

<P class="docText"><A NAME="pythonian-CHP-5-ITERM-4216"></A>
<A NAME="pythonian-CHP-5-ITERM-4217"></A>You can also bind or unbind class
attributes outside the class body. For example:</P>

<PRE>class C2: pass
C2.x = 23
print C2.x                               # prints: 23</PRE>

<P class="docText">However, your program is more readable if you bind, and thus create,
class attributes with statements inside the class body. Any class
attributes are implicitly shared by all instances of the class when
those instances are created, as we'll discuss
shortly.</P>

<P class="docText"><A NAME="pythonian-CHP-5-ITERM-4218"></A> <A NAME="pythonian-CHP-5-ITERM-4219"></A>The <TT>class</TT>
statement implicitly defines some class attributes. Attribute
<TT>_ _name_ _</TT> is the
<TT><I>classname</I></TT> identifier string used in the
<TT>class</TT> statement. Attribute <TT>_ _bases_
_</TT> is the tuple of class objects given as the base classes
in the <TT>class</TT> statement (or the empty tuple, if no
base classes are given). For example, using the class
<TT>C1</TT> we just created:<A NAME="pythonian-CHP-5-ITERM-4220"></A></P>

<PRE>print C1._ _name_ _, C1._ _bases_ _          # prints: C1, (  )</PRE>

<P class="docText"><A NAME="pythonian-CHP-5-ITERM-4221"></A>
<A NAME="pythonian-CHP-5-ITERM-4222"></A>A
class also has an attribute <TT>_ _dict_ _</TT>, which is
the dictionary object that the class uses to hold all of its other
attributes. For any class object <TT><I>C</I></TT>, any
object <TT><I>x</I></TT>, and any identifier
<TT><I>S</I></TT> (except <TT>_ _name_ _</TT>,
<TT>_ _bases_ _</TT>, and <TT>_ _dict_ _</TT>),
<TT><I>C</I></TT>.<TT><I>S</I></TT><TT>=</TT><TT><I>x</I></TT>
is equivalent to <TT><I>C</I></TT><TT>._ _dict_
_[</TT>'<TT><I>S</I></TT>'<TT>]=</TT><TT><I>x</I></TT>.
For example, again referring to the class <TT>C1</TT> we
just created:</P>

<PRE>C1.y = 45
C1._ _dict_ _['z'] = 67
print C1.x, C1.y, C1.z                   # prints: 23, 45, 67</PRE>

<P class="docText">There is no difference between class attributes created in the class
body, outside of the body by assigning an attribute, or outside of
the body by explicitly binding an entry in
<TT><I>C</I></TT><TT>._ _dict_ _</TT>.</P>

<P class="docText">In statements that are directly in a class's body,
references to attributes of the class must use a simple name, not a
fully qualified name. For example:</P>

<PRE>class C3:
    x = 23
    y = x + 22                         # must use just x, not C3.x</PRE>

<P class="docText">However, in statements that are in methods defined in a class body,
references to attributes of the class must use a fully qualified
name, not a simple name. For example:</P>

<PRE>class C4:
    x = 23
    def amethod(self):
        print C4.x                     # must use C4.x, not just x</PRE>

<P class="docText">Note that attribute references (i.e., an expression like
<TT><I>C</I></TT>.<TT><I>S</I></TT>)
have richer semantics than attribute binding. These references are
covered in detail later in this chapter.</P>



<A NAME="pythonian-CHP-5-SECT-1.2.2"></A>
<H5 class="docSection3Title">5.1.2.2 Function definitions in a class body</H5>

<P class="docText"><A NAME="pythonian-CHP-5-ITERM-4223"></A>
<A NAME="pythonian-CHP-5-ITERM-4224"></A>
<A NAME="pythonian-CHP-5-ITERM-4225"></A> <A NAME="pythonian-CHP-5-ITERM-4226"></A>Most class bodies include
<TT>def</TT> statements, as functions (called methods in
this context) are important attributes for class objects. A
<TT>def</TT> statement in a class body obeys the rules
presented in <A class="docLink" HREF="0596001886_pythonian-chp-4-sect-10.html#pythonian-CHP-4-SECT-10">Section 4.10</A>. In addition, a method
defined in a class body always has a mandatory first parameter,
conventionally named <TT>self</TT>, that refers to the
instance on which you call the method. The <TT>self</TT>
parameter plays a special role in method calls, as covered later in
this chapter.<A NAME="pythonian-CHP-5-ITERM-4227"></A></P>

<P class="docText">Here's an example of a class that includes a method
definition:</P>

<PRE>class C5:
    def hello(self):
        print "Hello"</PRE>

<P class="docText">A class can define a variety of special methods (methods with names
that have two leading and two trailing underscores) relating to
specific operations. We'll discuss special methods
in great detail later in this chapter.</P>



<A NAME="pythonian-CHP-5-SECT-1.2.3"></A>
<H5 class="docSection3Title">5.1.2.3 Class-private variables</H5>

<P class="docText"><A NAME="pythonian-CHP-5-ITERM-4228"></A> <A NAME="pythonian-CHP-5-ITERM-4229"></A>
<A NAME="pythonian-CHP-5-ITERM-4230"></A>When
a statement in a class body (or in a method in the body) uses an
identifier starting with two underscores (but not ending with
underscores), such as <TT><I>_ _ident</I></TT>, the Python
compiler implicitly changes the identifier into
<TT><I>_classname_ _ident</I></TT>, where
<TT><I>classname</I></TT> is the name of the class. This
lets a class use private names for attributes, methods, global
variables, and other purposes, without the risk of accidentally
duplicating names used elsewhere.<A NAME="pythonian-CHP-5-ITERM-4231"></A> <A NAME="pythonian-CHP-5-ITERM-4232"></A></P>

<P class="docText">By convention, all identifiers starting with a single underscore are
also intended as private to the scope that binds them, whether that
scope is or isn't a class. The Python compiler does
not enforce privacy conventions, however: it's up to
Python programmers to respect them.</P>



<A NAME="pythonian-CHP-5-SECT-1.2.4"></A>
<H5 class="docSection3Title">5.1.2.4 Class documentation strings</H5>

<P class="docText"><A NAME="pythonian-CHP-5-ITERM-4233"></A>
<A NAME="pythonian-CHP-5-ITERM-4234"></A>
<A NAME="pythonian-CHP-5-ITERM-4235"></A>
<A NAME="pythonian-CHP-5-ITERM-4236"></A>If the first
statement in the class body is a string literal, the compiler binds
that string as the documentation string attribute for the class. This
attribute is named <TT>_ _doc_ _</TT> and is known as the
<I>docstring</I> of the class. See <A class="docLink" HREF="0596001886_pythonian-chp-4-sect-10.html#pythonian-CHP-4-SECT-10.3">Section 4.10.3</A> for more information on docstrings.<A NAME="pythonian-CHP-5-ITERM-4237"></A> <A NAME="pythonian-CHP-5-ITERM-4238"></A></P>



<A NAME="pythonian-CHP-5-SECT-1.3"></A>
<H4 class="docSection2Title">5.1.3 Instances</H4>

<P class="docText"><A NAME="pythonian-CHP-5-ITERM-4239"></A>
<A NAME="pythonian-CHP-5-ITERM-4240"></A>When you want to create an instance of
a class, call the class object as if it were a function. Each call
returns a new instance object of that class:</P>

<PRE>anInstance = C5(  )</PRE>

<P class="docText">You can call built-in function
<TT>isinstance(</TT><TT><I>I</I></TT>,<TT><I>C</I></TT><TT>)</TT>
with a class object as argument <TT><I>C</I></TT>. In this
case, <TT>isinstance</TT> returns <TT>True</TT>
if object <TT><I>I</I></TT> is an instance of class
<TT><I>C</I></TT> or any subclass of
<TT><I>C</I></TT>. Otherwise,
<TT>isinstance</TT> returns
<TT>False</TT>.<A NAME="pythonian-CHP-5-ITERM-4241"></A> <A NAME="pythonian-CHP-5-ITERM-4242"></A></P>

<A NAME="pythonian-CHP-5-SECT-1.3.1"></A>
<H5 class="docSection3Title">5.1.3.1 _ _init_ _</H5>

<P class="docText"><A NAME="pythonian-CHP-5-ITERM-4243"></A> <A NAME="pythonian-CHP-5-ITERM-4244"></A>When a class has or
inherits a method named <TT>_ _init_ _</TT>, calling the
class object implicitly executes <TT>_ _init_ _</TT> on the
new instance to perform any instance-specific initialization that is
needed. Arguments passed in the call must correspond to the formal
parameters of <TT>_ _init_ _</TT>. For example, consider
the following class:<A NAME="pythonian-CHP-5-ITERM-4245"></A></P>

<PRE>class C6:
    def _ _init_ _(self,n):
        self.x = n</PRE>

<P class="docText">Here's how to create an instance of the
<TT>C6</TT> class:</P>

<PRE>anotherInstance = C6(42)</PRE>

<P class="docText">As shown in the <TT>C6</TT> class, the <TT>_ _init_
_</TT> method typically contains statements that bind instance
attributes. An <TT>_ _init_ _</TT> method must either not
return a value or return the value <TT>None</TT>; any other
return value raises a <TT>TypeError</TT> exception.</P>

<P class="docText">The main purpose of <TT>_ _init_ _</TT> is to bind, and
thus create, the attributes of a newly created instance. You may also
bind or unbind instance attributes outside <TT>_ _init_
_</TT>, as you'll see shortly. However, your
code will be more readable if you initially bind all attributes of a
class instance with statements in the <TT>_ _init_ _</TT>
method.</P>

<P class="docText">When <TT>_ _init_ _</TT> is absent, you must call the class
without arguments, and the newly generated instance has no
instance-specific attributes. See <A class="docLink" HREF="0596001886_pythonian-chp-5-sect-3.html#pythonian-CHP-5-SECT-3">Section 5.3</A> later in this chapter for
more details about <TT>_ _init_ _</TT>.</P>



<A NAME="pythonian-CHP-5-SECT-1.3.2"></A>
<H5 class="docSection3Title">5.1.3.2 Attributes of instance objects</H5>

<P class="docText"><A NAME="pythonian-CHP-5-ITERM-4246"></A>
<A NAME="pythonian-CHP-5-ITERM-4247"></A>
<A NAME="pythonian-CHP-5-ITERM-4248"></A>Once you have created an instance,
you can access its attributes (data and methods) using the dot
(.) operator. For example:<A NAME="pythonian-CHP-5-ITERM-4249"></A> <A NAME="pythonian-CHP-5-ITERM-4250"></A></P>

<PRE>anInstance.hello(  )                       # prints: Hello
print anotherInstance.x                    # prints: 42</PRE>

<P class="docText">Attribute references such as these have fairly rich semantics in
Python and are covered in detail later in this section.</P>

<P class="docText">You can give an instance object an arbitrary attribute by binding a
value to an attribute reference. For example:</P>

<PRE>class C7: pass
z = C7(  )
z.x = 23
print z.x                                   # prints: 23</PRE>

<P class="docText">Instance object <TT>z</TT> now has an attribute named
<TT>x</TT>, bound to the value <TT>23</TT>, and
<TT>z.x</TT> refers to that attribute. Note that the
<TT>_ _setattr_ _</TT> special method, if present,
intercepts every attempt to bind an attribute. <TT>_ _setattr_
_</TT> is covered in <A class="docLink" HREF="0596001886_pythonian-chp-5-sect-3.html#pythonian-CHP-5-SECT-3">Section 5.3</A> later in this chapter.</P>

<P class="docText">Creating an instance implicitly defines two instance attributes. For
any instance <TT><I>z</I></TT>,
<TT><I>z</I></TT><TT>._ _class_ _</TT> is the
class object to which <TT><I>z</I></TT> belongs, and
<TT><I>z</I></TT><TT>._ _dict_ _</TT> is the
dictionary that <TT><I>z</I></TT> uses to hold all of its
other attributes. For example, for the instance <TT>z</TT>
we just created:</P>

<PRE>print z._ _class_ _._ _name_ _, z._ _dict_ _     # prints: C7, {'x':23}</PRE>

<P class="docText">You may rebind (but not unbind) either or both of these attributes,
but this is rarely necessary.</P>

<P class="docText">For any instance object <TT><I>z</I></TT>, any object
<TT><I>x</I></TT>, and any identifier
<TT><I>S</I></TT> (except <TT>_ _class_ _</TT>
and <TT>_ _dict_ _</TT>),
<TT><I>z</I></TT>.<TT><I>S</I></TT><TT>=</TT><TT><I>x</I></TT>
is equivalent to <TT><I>z</I></TT><TT>._ _dict_
_[</TT>'<TT><I>S</I></TT>'<TT>]=</TT><TT><I>x</I></TT>
(unless a <TT>_ _setattr_ _</TT> special method intercepts
the binding attempt). For example, again referring to the instance
<TT><I>z</I></TT> we just created:</P>

<PRE>z.y = 45
z._ _dict_ _['z'] = 67
print z.x, z.y, z.z                         # prints: 23, 45, 67</PRE>

<P class="docText">There is no difference between instance attributes created in
<TT>_ _init_ _</TT>, by assigning to attributes, or by
explicitly binding an entry in
<TT><I>z</I></TT><TT>._ _dict_ _</TT>.</P>



<A NAME="pythonian-CHP-5-SECT-1.3.3"></A>
<H5 class="docSection3Title">5.1.3.3 The factory-function idiom</H5>

<P class="docText"><A NAME="pythonian-CHP-5-ITERM-4251"></A> <A NAME="pythonian-CHP-5-ITERM-4252"></A>It is common to want to create
instances of different classes depending upon some condition or to
want to avoid creating a new instance if an existing one is available
for reuse. You might consider implementing these needs by having
<TT>_ _init_ _</TT> return a particular object, but that
isn't possible because Python raises an exception
when <TT>_ _init_ _</TT> returns any value other than
<TT>None</TT>. The best way to implement flexible object
creation is by using an ordinary function, rather than by calling the
class object directly. A function used in this role is known as a
<I>factory function</I>.</P>

<P class="docText">Calling a factory function is a more flexible solution, as such a
function may return an existing reusable instance or create a new
instance by calling whatever class is appropriate. Say you have two
almost-interchangeable classes (<TT>SpecialCase</TT> and
<TT>NormalCase</TT>) and you want to flexibly generate
either one of them, depending on an argument. The following
<TT>appropriateCase</TT> factory function allows you to do
just that (the role of the <TT>self</TT> parameters is
covered in <A class="docLink" HREF="#pythonian-CHP-5-SECT-1.5">Section 5.1.5</A> later in
this chapter):</P>

<A NAME="pythonian-CHP-5-ITERM-4253"></A><A NAME="pythonian-CHP-5-ITERM-4254"></A><PRE>class SpecialCase:
    def amethod(self): print "special"
class NormalCase:
    def amethod(self): print "normal"
def appropriateCase(isnormal=1):
    if isnormal: return NormalCase(  )
    else: return SpecialCase(  )
aninstance = appropriateCase(isnormal=0)
aninstance.amethod(  )                        # prints "special", as desired</PRE>



<A NAME="pythonian-CHP-5-SECT-1.4"></A>
<H4 class="docSection2Title">5.1.4 Attribute Reference Basics</H4>

<P class="docText"><A NAME="pythonian-CHP-5-ITERM-4255"></A>
<A NAME="pythonian-CHP-5-ITERM-4256"></A>An
<I>attribute reference</I> is an expression of the form
<TT><I>x</I></TT>.<TT><I>name</I></TT>,
where <TT><I>x</I></TT> is any expression and
<TT><I>name</I></TT> is an identifier called the
<I>attribute name</I>. Many kinds of Python objects
have attributes, but an attribute reference has special rich
semantics when <TT><I>x</I></TT> refers to a class or
instance. Remember that methods are attributes too, so everything I
say about attributes in general also applies to attributes that are
callable (i.e.,
methods).<A NAME="pythonian-CHP-5-ITERM-4257"></A></P>

<P class="docText">Say that <TT>x</TT> is an instance of class
<TT>C</TT>, which inherits from base class
<TT>B</TT>. Both classes and the instance have several
attributes (data and methods) as follows:</P>

<PRE>class B:
    a = 23
    b = 45
    def f(self): print "method f in class B"
    def g(self): print "method g in class B"
class C(B):
    b = 67
    c = 89
    d = 123
    def g(self): print "method g in class C"
    def h(self): print "method h in class C"
x = C(  )
x.d = 77
x.e = 88</PRE>

<P class="docText">Some attribute names are special. For example, <TT>C._ _name_
_</TT> is the string '<TT>C</TT>', the class name.
<TT>C._ _bases_ _</TT> is the tuple
<TT>(B,)</TT>, the tuple of
<TT>C</TT>'s base classes. <TT>x._
_class_ _</TT> is the class <TT>C</TT>, the class to
which <TT>x</TT> belongs. When you refer to an attribute
with one of these special names, the attribute reference looks
directly into a special dedicated slot in the class or instance
object and fetches the value it finds there. Thus, you can never
unbind these attributes. Rebinding them is allowed, so you can change
the name or base classes of a class or the class of an instance on
the fly, but this is an advanced technique and rarely necessary.</P>

<P class="docText">Both class <TT>C</TT> and instance <TT>x</TT>
each have one other special attribute, a dictionary named <TT>_
_dict_ _</TT>. All other attributes of a class or instance,
except for the few special ones, are held as items in the <TT>_
_dict_ _</TT> attribute of the class or instance.</P>

<P class="docText">Apart from special names, when you use the syntax
<TT><I>x</I></TT>.<TT><I>name</I></TT>
to refer to an attribute of instance <TT><I>x</I></TT>,
the lookup proceeds in two steps:</P>

<span style="font-weight:bold"><OL class="docList" TYPE="1">
<LI><span style="font-weight:normal"><P class="docList">When
'<TT><I>name</I></TT>'
is a key in <TT><I>x</I></TT><TT>._ _dict_
_</TT>,
<TT><I>x</I></TT>.<TT><I>name</I></TT>
fetches and returns the value at
<TT><I>x</I></TT><TT>._ _dict_
_[</TT>'<TT><I>name</I></TT>'<TT>]</TT></P></span></LI>
<LI><span style="font-weight:normal"><P class="docList">Otherwise,
<TT><I>x</I></TT>.<TT><I>name</I></TT>
delegates the lookup to
<TT><I>x</I></TT>'s class (i.e., it works
just the same as <TT><I>x</I></TT><TT>._ _class_
_</TT>.<TT><I>name</I></TT>)</P></span></LI>
</OL></span>
<P class="docText">Similarly, lookup for an attribute reference
<TT><I>C</I></TT>.<TT><I>name</I></TT>
on a class object <TT><I>C</I></TT> also proceeds in two
steps:</P>

<span style="font-weight:bold"><OL class="docList" TYPE="1">
<LI><span style="font-weight:normal"><P class="docList">When
'<TT><I>name</I></TT>'
is a key in <TT><I>C</I></TT><TT>._ _dict_
_</TT>,
<TT><I>C</I></TT>.<TT><I>name</I></TT>
fetches and returns the value at
<TT><I>C</I></TT><TT>._ _dict_
_[</TT>'<TT><I>name</I></TT>'<TT>]</TT></P></span></LI>
<LI><span style="font-weight:normal"><P class="docList">Otherwise,
<TT><I>C</I></TT>.<TT><I>name</I></TT>
delegates the lookup to
<TT><I>C</I></TT>'s base classes, meaning
it loops on <TT><I>C</I></TT><TT>._ _bases_
_</TT> and tries the <TT><I>name</I></TT> lookup on
each</P></span></LI>
</OL></span>
<P class="docText"><A NAME="pythonian-CHP-5-ITERM-4258"></A>When these two lookup procedures do
not find an attribute, Python raises an
<TT>AttributeError</TT> exception. However, if
<TT><I>x</I></TT>'s class defines or
inherits special method <TT>_ _getattr_ _</TT>, Python
calls <TT><I>x</I></TT><TT>._ _getattr_
_(</TT>'<TT><I>name</I></TT>'<TT>)</TT>
rather than raising the exception.</P>

<P class="docText">Consider the following attribute references:</P>

<PRE>print x.e, x.d, x.c, x.b. x.a                 # prints: 88, 77, 89, 67, 23</PRE>

<P class="docText"><TT>x.e</TT> and <TT>x.d</TT> succeed in step 1
of the first lookup process, since '<TT>e</TT>' and
'<TT>d</TT>' are both keys in <TT>x._ _dict_
_</TT>. Therefore, the lookups go no further, but rather return
<TT>88</TT> and <TT>77</TT>. The other three
references must proceed to step 2 of the first process and look in
<TT>x._ _class_ _</TT> (i.e., <TT>C</TT>).
<TT>x.c</TT> and <TT>x.b</TT> succeed in step 1
of the second lookup process, since '<TT>c</TT>' and
'<TT>b</TT>' are both keys in <TT>C._ _dict_
_</TT>. Therefore, the lookups go no further, but rather return
<TT>89</TT> and <TT>67</TT>.
<TT>x.a</TT> gets all the way to step 2 of the second
process, looking in <TT>C._ _bases_ _[0]</TT> (i.e.,
<TT>B</TT>). '<TT>a</TT>' is a key in
<TT>B._ _dict_ _</TT>, therefore <TT>x.a</TT>
finally succeeds and returns <TT>23</TT>.</P>

<P class="docText">Note that the attribute lookup steps happen only when you refer to an
attribute, not when you bind an attribute. When you bind or unbind an
attribute whose name is not special, only the <TT>_ _dict_
_</TT> entry for the attribute is affected. In other words, in
the case of attribute binding, there is no lookup procedure involved.</P>


<A NAME="pythonian-CHP-5-SECT-1.5"></A>
<H4 class="docSection2Title">5.1.5 Bound and Unbound Methods</H4>

<P class="docText"><A NAME="pythonian-CHP-5-ITERM-4259"></A>
<A NAME="pythonian-CHP-5-ITERM-4260"></A>Step 1 of the class attribute
reference lookup process described in the previous section actually
performs an additional task when the value found is a function. In
this case, the attribute reference does not return the function
object directly, but rather wraps the function into an
<I>unbound method object </I>or a <I>bound
method object</I>. The key difference between unbound and
bound methods is that an unbound method is not associated with a
particular instance, while a bound method is.<A NAME="pythonian-CHP-5-ITERM-4261"></A>
<A NAME="pythonian-CHP-5-ITERM-4262"></A>
<A NAME="pythonian-CHP-5-ITERM-4263"></A> <A NAME="pythonian-CHP-5-ITERM-4264"></A></P>

<P class="docText">In the code in the previous section, attributes <TT>f</TT>,
<TT>g</TT>, and <TT>h</TT> are functions;
therefore an attribute reference to any one of them returns a method
object wrapping the respective function. Consider the
following:<A NAME="pythonian-CHP-5-ITERM-4265"></A> <A NAME="pythonian-CHP-5-ITERM-4266"></A></P>

<PRE>print x.h, x.g, x.f, C.h, C.g, C.f</PRE>

<P class="docText">This statement outputs three bound methods, represented as strings
like:</P>

<PRE>&lt;bound method C.h of &lt;_ _main_ _.C instance at 0x8156d5c&gt;&gt;</PRE>

<P class="docText">and then three unbound ones, represented as strings like:</P>

<PRE>&lt;unbound method C.h&gt;</PRE>

<P class="docText">We get bound methods when the attribute reference is on instance
<TT>x</TT>, and unbound methods when the attribute
reference is on class <TT>C</TT>.</P>

<P class="docText">Because a bound method is already associated with a specific
instance, you call the method as follows:</P>

<PRE>x.h(  )                      # prints: method h in class C</PRE>

<P class="docText"><A NAME="pythonian-CHP-5-ITERM-4267"></A>The key thing
to notice here is that you don't pass the
method's first argument, <TT>self</TT>, by
the usual argument-passing syntax. Rather, a bound method of instance
<TT>x</TT> implicitly binds the <TT>self</TT>
parameter to object <TT>x</TT>. Thus, the body of the
method can access the instance's attributes as
attributes of <TT>self</TT>, even though we
don't pass an explicit argument to the method.</P>

<P class="docText">An unbound method, however, is not associated with a specific
instance, so you must specify an appropriate instance as the first
argument when you invoke an unbound method. For example:</P>

<PRE>C.h(x)                     # prints: method h in class C</PRE>

<P class="docText">You call unbound methods far less frequently than you call bound
methods. The main use for unbound methods is for accessing overridden
methods, as discussed in <A class="docLink" HREF="#pythonian-CHP-5-SECT-1.6">Section 5.1.6</A> later in this chapter.</P>

<A NAME="pythonian-CHP-5-SECT-1.5.1"></A>
<H5 class="docSection3Title">5.1.5.1 Unbound method details</H5>

<P class="docText">As we've just discussed, when an attribute reference
on a class refers to a function, a reference to that attribute
returns an unbound method that wraps the function. An unbound method
has three attributes in addition to those of the function object it
wraps: <TT>im_class</TT> is the class object supplying the
method, <TT>im_func</TT> is the wrapped function, and
<TT>im_self</TT> is always <TT>None</TT>. These
attributes are all read-only, meaning that trying to rebind or unbind
any of them raises an exception.</P>

<P class="docText">You can call an unbound method just as you would call its
<TT>im_func</TT> function, but the first argument in any
call must be an instance of <TT>im_class</TT> or a
descendant. In other words, a call to an unbound method must have at
least one argument, which corresponds to the first formal parameter
(conventionally named <TT>self</TT>).</P>



<A NAME="pythonian-CHP-5-SECT-1.5.2"></A>
<H5 class="docSection3Title">5.1.5.2 Bound method details</H5>

<P class="docText">As covered earlier in <A class="docLink" HREF="#pythonian-CHP-5-SECT-1.4">Section 5.1.4</A>,
an attribute reference on an instance <TT><I>x</I></TT>,
such as
<TT><I>x</I></TT>.<TT><I>f</I></TT>,
delegates the lookup to
<TT><I>x</I></TT>'s class when
'<TT><I>f</I></TT>'
is not a key in <TT><I>x</I></TT><TT>._ _dict_
_</TT>. In this case, when the lookup finds a function object,
the attribute reference operation creates and returns a bound method
that wraps the function. Note that when the attribute reference finds
a function object in <TT><I>x</I></TT><TT>._ _dict_
_</TT> or any other kind of callable object by whatever route,
the attribute reference operation does not create a bound method. The
bound method is created only when a function object is found as an
attribute in the instance's class.</P>

<P class="docText">A bound method is similar an unbound method, in that it has three
read-only attributes in addition to those of the function object it
wraps. Like with an unbound method, <TT>im_class</TT> is
the class object supplying the method, and <TT>im_func</TT>
is the wrapped function. However, in a bound method object, attribute
<TT>im_self</TT> refers to <TT><I>x</I></TT>,
the instance from which the method was obtained.</P>

<P class="docText">A bound method is used like its <TT>im_func</TT> function,
but calls to a bound method do not explicitly supply an argument
corresponding to the first formal parameter (conventionally named
<TT>self</TT>). When you call a bound method, the bound
method passes <TT>im_self</TT> as the first argument to
<TT>im_func</TT>, before other arguments (if any) are
passed at the point of call.</P>

<P class="docText">Let's follow the conceptual steps in a typical
method call with the normal syntax
<TT><I>x</I></TT>.<TT><I>name</I></TT><TT>(</TT><TT><I>arg</I></TT><TT>)</TT>.
<TT><I>x</I></TT> is an instance object,
<TT><I>name</I></TT> is an identifier naming one of
<TT><I>x</I></TT>'s methods (a
function-valued attribute of
<TT><I>x</I></TT>'s class), and
<TT><I>arg</I></TT> is any expression. Python checks if
'<TT><I>name</I></TT>'
is a key in <TT><I>x</I></TT><TT>._ _dict_
_</TT>, but it isn't. So Python finds
<TT><I>name</I></TT> in
<TT><I>x</I></TT><TT>._ _class_ _</TT>
(possibly, by inheritance, in one of its <TT>_ _bases_
_</TT>). Python notices that the value is a function object, and
that the lookup is being done on instance
<TT><I>x</I></TT>. Therefore, Python creates a bound
method object whose <TT>im_self</TT> attribute refers to
<TT><I>x</I></TT>. Then, Python calls the bound method
object with <TT><I>arg</I></TT> as the only actual
argument. The bound method inserts <TT>im_self</TT> (i.e.,
<TT><I>x</I></TT>) as the first actual argument and
<TT><I>arg</I></TT> becomes the second one. The overall
effect is just like calling:</P>

<PRE><TT><I>x</I></TT>._ _class_ _._ _dict_ _['<TT><I>name</I></TT>'](<TT><I>x</I></TT>, <TT><I>arg</I></TT>)</PRE>

<P class="docText">When a bound method's function body executes, it has
no special namespace relationship to either its
<TT>self</TT> object or any class. Variables referenced are
local or global, just as for any other function, as covered in <A class="docLink" HREF="0596001886_pythonian-chp-4-sect-10.html#pythonian-CHP-4-SECT-10.6">Section 4.10.6</A>. Variables do not implicitly indicate
attributes in <TT>self</TT>, nor do they indicate
attributes in any class object. When the method needs to refer to,
bind, or unbind an attribute of its <TT>self</TT> object,
it does so by standard attribute-reference syntax (e.g.,
<TT>self</TT>.<TT><I>name</I></TT>). The lack of
implicit scoping may take some getting used to (since Python differs
in this respect from many other object-oriented languages), but it
results in clarity, simplicity, and the removal of potential
ambiguities.</P>

<P class="docText">Bound method objects are first-class objects, and you can use them
wherever you can use a callable object. Since a bound method holds
references to the function it wraps and to the
<TT>self</TT> object on which it executes,
it's a powerful and flexible alternative to a
closure (covered in <A class="docLink" HREF="0596001886_pythonian-chp-4-sect-10.html#pythonian-CHP-4-SECT-10.6.2">Section 4.10.6.2</A>). An instance object
with special method <TT>_ _call_ _</TT> (covered in <A class="docLink" HREF="0596001886_pythonian-chp-5-sect-3.html#pythonian-CHP-5-SECT-3">Section 5.3</A> later in this chapter)
offers another viable alternative. Each of these constructs lets you
bundle some behavior (code) and some state (data) into a single
callable object. Closures are simplest, but limited in their
applicability. Here's the closure from <A class="docLink" HREF="0596001886_pythonian-chp-4.html#pythonian-CHP-4">Chapter 4</A>:</P>

<PRE>def make_adder_as_closure(augend):
    def add(addend, _augend=augend): return addend+_augend
    return add</PRE>

<P class="docText">Bound methods and callable instances are richer and more flexible.
Here's how to implement the same functionality with
a bound method:</P>

<PRE>def make_adder_as_bound_method(augend):
    class Adder:
        def _ _init_ _(self, augend): self.augend = augend
        def add(self, addend): return addend+self.augend
    return Adder(augend).add</PRE>

<P class="docText">Here's how to implement it with a callable instance
(an instance with <TT>_ _call_ _</TT>):</P>

<A NAME="pythonian-CHP-5-ITERM-4268"></A><A NAME="pythonian-CHP-5-ITERM-4269"></A><A NAME="pythonian-CHP-5-ITERM-4270"></A><A NAME="pythonian-CHP-5-ITERM-4271"></A><PRE>def make_adder_as_callable_instance(augend):
    class Adder:
        def _ _init_ _(self, augend): self.augend = augend
        def _ _call_ _(self, addend): return addend+self.augend
    return Adder(augend)</PRE>

<P class="docText">From the viewpoint of the code that calls the functions, all of these
functions are interchangeable, since all return callable objects that
are polymorphic (i.e., usable in the same ways). In terms of
implementation, the closure is simplest; the bound method and
callable instance use more flexible and powerful mechanisms, but
there is really no need for that extra power in this case.<A NAME="pythonian-CHP-5-ITERM-4272"></A> <A NAME="pythonian-CHP-5-ITERM-4273"></A></P>



<A NAME="pythonian-CHP-5-SECT-1.6"></A>
<H4 class="docSection2Title">5.1.6 Inheritance</H4>

<P class="docText"><A NAME="pythonian-CHP-5-ITERM-4274"></A>
<A NAME="pythonian-CHP-5-ITERM-4275"></A> <A NAME="pythonian-CHP-5-ITERM-4276"></A>When you use an attribute reference
<TT><I>C</I></TT>.<TT><I>name</I></TT>
on a class object <TT><I>C</I></TT>, and
'<TT><I>name</I></TT>'
is not a key in <TT><I>C</I></TT><TT>._ _dict_
_</TT>, the lookup implicitly proceeds on each class object that
is in <TT><I>C</I></TT><TT>._ _bases_ _</TT>, in
order. <TT><I>C</I></TT>'s base classes
may in turn have their own base classes. In this case, the lookup
recursively proceeds up the inheritance tree, stopping when
'<TT><I>name</I></TT>'
is found. The search is depth-first, meaning that it examines the
ancestors of each base class of <TT><I>C</I></TT> before
considering the next base class of <TT><I>C</I></TT>.
Consider the following example:</P>

<PRE>class Base1:
    def amethod(self): print "Base1"
class Base2(Base1): pass
class Base3:
    def amethod(self): print "Base3"
class Derived(Base2, Base3): pass
aninstance = Derived(  )
aninstance.amethod(  )                    # prints: "Base1"</PRE>

<P class="docText">In this case, the lookup for <TT>amethod</TT> starts in
<TT>Derived</TT>. When it isn't found
there, lookup proceeds to <TT>Base2</TT>. Since the
attribute isn't found in <TT>Base2</TT>,
lookup then proceeds to <TT>Base2</TT>'s
ancestor, <TT>Base1</TT>, where the attribute is found.
Therefore, the lookup stops at this point and never considers
<TT>Base3</TT>, where it would also find an attribute with
the same name.</P>

<A NAME="pythonian-CHP-5-SECT-1.6.1"></A>
<H5 class="docSection3Title">5.1.6.1 Overriding attributes</H5>

<P class="docText"><A NAME="pythonian-CHP-5-ITERM-4277"></A>
<A NAME="pythonian-CHP-5-ITERM-4278"></A>As
we've just seen, the search for an attribute
proceeds up the inheritance tree and stops as soon as the attribute
is found. Descendent classes are examined before their ancestors,
meaning that when a subclass defines an attribute with the same name
as one in a superclass, the search finds the definition when it looks
at the subclass and stops there. This is known as the subclass
<I>overriding</I> the definition in the superclass.
Consider the following:</P>

<PRE>class B:
    a = 23
    b = 45
    def f(self): print "method f in class B"
    def g(self): print "method g in class B"
class C(B):
    b = 67
    c = 89
    d = 123
    def g(self): print "method g in class C"
    def h(self): print "method h in class C"</PRE>

<P class="docText">In this code, class <TT>C</TT> overrides attributes
<TT>b</TT> and <TT>g</TT> of its superclass
<TT>B</TT>.</P>



<A NAME="pythonian-CHP-5-SECT-1.6.2"></A>
<H5 class="docSection3Title">5.1.6.2 Delegating to superclass methods</H5>

<P class="docText"><A NAME="pythonian-CHP-5-ITERM-4279"></A> <A NAME="pythonian-CHP-5-ITERM-4280"></A>
<A NAME="pythonian-CHP-5-ITERM-4281"></A>When a subclass
<TT><I>C</I></TT> overrides a method
<TT><I>f</I></TT> of its superclass
<TT><I>B</I></TT>, the body of
<TT><I>C</I></TT>.<TT><I>f</I></TT>
often wants to delegate some part of its operation to the
superclass's implementation of the method. This can
be done using an unbound method, as follows:</P>

<PRE>class Base:
    def greet(self, name): print "Welcome ", name
class Sub(Base):
    def greet(self, name):
        print "Well Met and",
        Base.greet(self, name)
x = Sub(  )
x.greet('Alex')</PRE>

<P class="docText">The delegation to the superclass, in the body of
<TT>Sub.greet</TT>, uses an unbound method obtained by
attribute reference <TT>Base.greet</TT> on the superclass,
and therefore passes all attributes normally, including
<TT>self</TT>. Delegating to a superclass implementation is
the main use of unbound methods.</P>

<P class="docText">One very common use of such delegation occurs with special method
<TT>_ _init_ _</TT>. When an instance is created in Python,
the <TT>_ _init_ _</TT> methods of base classes are not
automatically invoked, as they are in some other object-oriented
languages. Thus, it is up to a subclass to perform the proper
initialization by using delegation if necessary. For example:</P>

<PRE>class Base:
    def _ _init_ _(self):
        self.anattribute = 23
class Derived(Base):
    def _ _init_ _(self):
        Base._ _init_ _(self)
        self.anotherattribute = 45</PRE>

<P class="docText">If the <TT>_ _init_ _</TT> method of class
<TT>Derived</TT> didn't explicitly call
that of class <TT>Base</TT>, instances of
<TT>Derived</TT> would miss that portion of their
initialization, and thus such instances would lack attribute
<TT>anattribute</TT>.</P>



<A NAME="pythonian-CHP-5-SECT-1.6.3"></A>
<H5 class="docSection3Title">5.1.6.3 "Deleting" class attributes</H5>

<P class="docText"><A NAME="pythonian-CHP-5-ITERM-4282"></A>
<A NAME="pythonian-CHP-5-ITERM-4283"></A>Inheritance and overriding
provide a simple and effective way to add or modify class attributes
(methods) non-invasively (i.e., without modifying the class in which
the attributes are defined), by adding or overriding the attributes
in subclasses. However, inheritance does not directly support similar
ways to delete (hide) base classes' attributes
non-invasively. If the subclass simply fails to define (override) an
attribute, Python finds the base class's definition.
If you need to perform such deletion, possibilities include:</P>

<UL>
<LI><P class="docList">Overriding the method and raising an exception in the
method's body</P></LI>
<LI><P class="docList">Eschewing inheritance, holding the attributes elsewhere than in the
subclass's <TT>_ _dict_ _</TT>, and
defining <TT>_ _getattr_ _</TT> for selective delegation</P></LI>
<LI><P class="docList">Using the new-style object model and overriding <TT>_
_getattribute_ _</TT> to similar effect</P></LI>
</UL>
<P class="docText">The last two techniques here are demonstrated in "_
_getattribute_ _" later in this chapter.<A NAME="pythonian-CHP-5-ITERM-4284"></A> <A NAME="pythonian-CHP-5-ITERM-4285"></A> <A NAME="pythonian-CHP-5-ITERM-4286"></A> <A NAME="pythonian-CHP-5-ITERM-4287"></A> <A NAME="pythonian-CHP-5-ITERM-4288"></A> <A NAME="pythonian-CHP-5-ITERM-4289"></A></P>




<a href="0596001886_"><img src="FILES/pixel.gif" width="1" height="1" border="0"></a><ul></ul>
</td>
</tr>
</table>
<td></td>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<td class="tt1"><a href="NFO/lib.html">[ Team LiB ]</a></td><td valign="top" class="tt1" align="right">
          <a href="0596001886_pythonian-chp-5.html"><img src="FILES/previous.gif" width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a>
          <a href="0596001886_pythonian-chp-5-sect-2.html"><img src="FILES/next.gif" width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a>
</td></table>
</body></html>
