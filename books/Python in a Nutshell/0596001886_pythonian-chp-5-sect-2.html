<html><head>
<META http-equiv="Content-Type" content="text/html">
<!--SafClassName="docSection1Title"--><!--SafTocEntry="5.2 New-Style Classes and Instances"-->
<link rel="STYLESHEET" type="text/css" href="FILES/style.css">
<link rel="STYLESHEET" type="text/css" href="FILES/docsafari.css">
<style type="text/css">	.tt1    {font-size: 10pt;}</style>
</head>
<body>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<td class="tt1"><a href="NFO/lib.html">[ Team LiB ]</a></td><td valign="top" class="tt1" align="right">
	<a href="0596001886_pythonian-chp-5-sect-1.html"><img src="FILES/previous.gif" width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a>
	<a href="0596001886_pythonian-chp-5-sect-3.html"><img src="FILES/next.gif" width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a>
</td></table>
<br>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<tr>
<td valign="top"><A NAME="pythonian-CHP-5-SECT-2"></A>
<H3 class="docSection1Title">5.2 New-Style Classes and Instances</H3>

<P class="docText"><A NAME="pythonian-CHP-5-ITERM-4290"></A> <A NAME="pythonian-CHP-5-ITERM-4291"></A>
<A NAME="pythonian-CHP-5-ITERM-4292"></A>Most of
what I have covered so far in this chapter also holds for the
new-style object model introduced in Python 2.2. New-style classes
and instances are first-class objects just like classic ones, both
can have arbitrary attributes, you call a class to create an instance
of the class, and so on. In this section, I'm going
to cover the few differences between the new-style and classic object
models.</P>

<P class="docText">In Python 2.2 and 2.3, a class is new-style if it inherits from
built-in type <TT>object</TT> directly or indirectly (i.e.,
if it subclasses any built-in type, such as <TT>list</TT>,
<TT>dict</TT>, <TT>file</TT>,
<TT>object</TT>, and so on). In Python 2.1 and earlier, a
class cannot inherit from a built-in type, and built-in type
<TT>object</TT> does not exist. In <A class="docLink" HREF="0596001886_pythonian-chp-5-sect-4.html#pythonian-CHP-5-SECT-4">Section 5.4</A> later in this chapter, I
cover other ways to make a class new-style, ways that you can use in
Python 2.2 or later whether a class has superclasses or not.</P>

<P class="docText">As I said at the beginning of this chapter, I suggest you get into
the habit of using new-style classes when you program in Python 2.2
or later. The new-style object model has small but measurable
advantages, and there are practically no compensating disadvantages.
It's simpler just to stick to the new-style object
model, rather than try to decide which model to use each time you
code a new class.</P>

<A NAME="pythonian-CHP-5-SECT-2.1"></A>
<H4 class="docSection2Title">5.2.1 The Built-in object Type</H4>

<P class="docText"><A NAME="pythonian-CHP-5-ITERM-4293"></A> <A NAME="pythonian-CHP-5-ITERM-4294"></A>
<A NAME="pythonian-CHP-5-ITERM-4295"></A>As of
Python 2.2, the built-in <TT>object</TT> type is the
ancestor of all built-in types and new-style classes. The
<TT>object</TT> type defines some special methods (as
documented in <A class="docLink" HREF="0596001886_pythonian-chp-5-sect-3.html#pythonian-CHP-5-SECT-3">Section 5.3</A> later in
this chapter) that implement the default semantics of objects:</P>

<A NAME="pythonian-CHP-5-ITERM-4296"></A><A NAME="pythonian-CHP-5-ITERM-4297"></A><A NAME="pythonian-CHP-5-ITERM-4298"></A><A NAME="pythonian-CHP-5-ITERM-4299"></A><A NAME="pythonian-CHP-5-ITERM-4300"></A><A NAME="pythonian-CHP-5-ITERM-4301"></A><A NAME="pythonian-CHP-5-ITERM-4302"></A><A NAME="pythonian-CHP-5-ITERM-4303"></A><A NAME="pythonian-CHP-5-ITERM-4304"></A><A NAME="pythonian-CHP-5-ITERM-4305"></A><A NAME="pythonian-CHP-5-ITERM-4306"></A><A NAME="pythonian-CHP-5-ITERM-4307"></A><A NAME="pythonian-CHP-5-ITERM-4308"></A><A NAME="pythonian-CHP-5-ITERM-4309"></A><DL class="docList">
<DT><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">_ _new_ _</span></span><A NAME="pythonian-CHP-5-ITERM-4296"></A>
<A NAME="pythonian-CHP-5-ITERM-4297"></A>, <span class="docPubcolor"><span class="docMonofont">_ _init_ _</span></span></span></DT>
<DD>
<P class="docList">You can create a direct instance of <TT>object</TT>, and
such creation implicitly uses the static method <TT>_ _new_
_</TT> of type <TT>object</TT> to create the new
instance, and then uses the new instance's
<TT>_ _init_ _</TT> method to initialize the new instance.
<TT>object._ _init_ _</TT> ignores its arguments and
performs no operation whatsoever, so you can pass arbitrary arguments
to type <TT>object</TT> when you call it to create an
instance of it: all such arguments will be ignored.</P>
</DD>
<DT><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">_ _delattr_ _</span></span><A NAME="pythonian-CHP-5-ITERM-4298"></A>
<A NAME="pythonian-CHP-5-ITERM-4299"></A>, <span class="docPubcolor"><span class="docMonofont">_ _getattribute_ _</span></span>, <span class="docPubcolor"><span class="docMonofont">_ _setattr_ _</span></span><A NAME="pythonian-CHP-5-ITERM-4300"></A>
<A NAME="pythonian-CHP-5-ITERM-4301"></A></span></DT>
<DD>
<P class="docList"><A NAME="pythonian-CHP-5-ITERM-4302"></A> <A NAME="pythonian-CHP-5-ITERM-4303"></A>By default, an
object handles attribute references as covered earlier in this
chapter, using these methods of <TT>object</TT>.</P>
</DD>
<DT><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">_ _hash_ _</span></span><A NAME="pythonian-CHP-5-ITERM-4304"></A>
<A NAME="pythonian-CHP-5-ITERM-4305"></A>, <span class="docPubcolor"><span class="docMonofont">_ _repr_ _</span></span>, <span class="docPubcolor"><span class="docMonofont">_ _str_ _</span></span><A NAME="pythonian-CHP-5-ITERM-4306"></A>
<A NAME="pythonian-CHP-5-ITERM-4307"></A></span></DT>
<DD>
<P class="docList"><A NAME="pythonian-CHP-5-ITERM-4308"></A> <A NAME="pythonian-CHP-5-ITERM-4309"></A>An object can be passed
to functions <TT>hash</TT> and <TT>repr</TT> and
to type <TT>str</TT>.</P>
</DD>
</DL>

<P class="docText">A subclass of <TT>object</TT> may override any of these
methods and/or add others.</P>


<A NAME="pythonian-CHP-5-SECT-2.2"></A>
<H4 class="docSection2Title">5.2.2 Class-Level Methods</H4>

<P class="docText"><A NAME="pythonian-CHP-5-ITERM-4310"></A> <A NAME="pythonian-CHP-5-ITERM-4311"></A>
<A NAME="pythonian-CHP-5-ITERM-4312"></A>The
new-style object model allows two kinds of class-level methods that
do not exist in the classic object model: static methods and class
methods. Class-level methods exist only in Python 2.2 and later, but
in these versions you can also have such methods in classic classes.
This is the only feature of the new-style object model that is also
fully functional with classic classes in Python 2.2 and later.</P>

<A NAME="pythonian-CHP-5-SECT-2.2.1"></A>
<H5 class="docSection3Title">5.2.2.1 Static methods</H5>

<P class="docText"><A NAME="pythonian-CHP-5-ITERM-4313"></A>
<A NAME="pythonian-CHP-5-ITERM-4314"></A>
<A NAME="pythonian-CHP-5-ITERM-4315"></A>A
<I>static method</I> is a method that you can call on a
class, or on any instance of the class, without the special behavior
and constraints of ordinary methods, bound and unbound, on the first
argument. A static method may have any signature: it may have no
arguments, and the first argument, if any, plays no special role. You
can think of a static method as an ordinary function that
you're able to call normally, despite the fact that
it happens to be bound to a class attribute. While it is never
necessary to define static methods (you could always define a
function instead), some programmers consider them to be an elegant
alternative to such functions whose purpose is tightly bound to some
specific class.<A NAME="pythonian-CHP-5-ITERM-4316"></A> <A NAME="pythonian-CHP-5-ITERM-4317"></A></P>

<P class="docText"><A NAME="pythonian-CHP-5-ITERM-4318"></A> <A NAME="pythonian-CHP-5-ITERM-4319"></A>You
build a static method by calling built-in type
<TT>staticmethod</TT> and binding its result to a class
attribute. Like all binding of class attributes, this is normally
done in the body of the class, but you may also choose to perform it
elsewhere. The only argument to <TT>staticmethod</TT> is
the function to invoke when Python calls the static method. The
following example shows how to define and call a static method:</P>

<PRE>class AClass(object):
    def astatic(  ): print 'a static method'
    astatic = staticmethod(astatic)
anInstance = AClass(  )
AClass.astatic(  )                    # prints: a static method
anInstance.astatic(  )                # prints: a static method</PRE>

<P class="docText">This example uses the same name for the function passed to
<TT>staticmethod</TT> and for the attribute bound to
<TT>staticmethod</TT>'s result. This style
is not mandatory, but it's a good idea, and I
recommend that you use it.</P>



<A NAME="pythonian-CHP-5-SECT-2.2.2"></A>
<H5 class="docSection3Title">5.2.2.2 Class methods</H5>

<P class="docText"><A NAME="pythonian-CHP-5-ITERM-4320"></A>
<A NAME="pythonian-CHP-5-ITERM-4321"></A>
<A NAME="pythonian-CHP-5-ITERM-4322"></A>A
<I>class method</I> is a method that you can call on a
class or on any instance of the class. Python binds the
method's first argument to the class on which you
call the method, or the class of the instance on which you call the
method; it does not bind it to the instance, as for normal bound
methods. There is no equivalent of unbound methods for class methods.
The first formal argument of a class method is conventionally named
<TT>cls</TT>. While it is never necessary to define class
methods (you could always alternatively define a function that takes
the class object as its first argument), some programmers consider
them to be an elegant alternative to such functions.</P>

<P class="docText"><A NAME="pythonian-CHP-5-ITERM-4323"></A>
<A NAME="pythonian-CHP-5-ITERM-4324"></A>You
build a class method by calling built-in type
<TT>classmethod</TT> and binding its result to a class
attribute. Like all binding of class attributes, this is normally
done in the body of the class, but you may also choose to perform it
elsewhere. The only argument to <TT>classmethod</TT> is the
function to invoke when Python calls the class method.
Here's how to define and call a class method:</P>

<PRE>class ABase(object):
    def aclassmet(cls): print 'a class method for', cls._ _name_ _
    aclassmet = classmethod(aclassmet)
class ADeriv(ABase): pass
bInstance = ABase(  )
dInstance = ADeriv(  )
ABase.aclassmet(  )               # prints: a class method for ABase
bInstance.aclassmet(  )           # prints: a class method for ABase
ADeriv.aclassmet(  )              # prints: a class method for ADeriv
dInstance.aclassmet(  )           # prints: a class method for ADeriv</PRE>

<P class="docText">This example uses the same name for the function passed to
<TT>classmethod</TT> and for the attribute bound to
<TT>classmethod</TT>'s result. This style
is not mandatory, but it's a good idea, and I
recommend that you use it.</P>



<A NAME="pythonian-CHP-5-SECT-2.3"></A>
<H4 class="docSection2Title">5.2.3 New-Style Classes</H4>

<P class="docText">All features of classic classes, covered earlier in this chapter,
also apply to new-style classes. New-style classes also have some
additional features with regard to the <TT>_ _init_ _</TT>
special method, and they all have a <TT>_ _new_ _</TT>
static method.</P>

<A NAME="pythonian-CHP-5-SECT-2.3.1"></A>
<H5 class="docSection3Title">5.2.3.1 _ _init_ _</H5>

<P class="docText"><A NAME="pythonian-CHP-5-ITERM-4325"></A> <A NAME="pythonian-CHP-5-ITERM-4326"></A>A new-style class
<TT><I>C</I></TT> that inherits <TT>_ _init_
_</TT> from <TT>object</TT> without overriding it lets
you pass arbitrary arguments when you call
<TT><I>C</I></TT>, but ignores all of those arguments.
This behavior can be somewhat surprising. I suggest you override
<TT>_ _init_ _</TT> in all new-style classes that directly
subclass <TT>object</TT>, even in those rare cases in which
your own class's <TT>_ _init_ _</TT> has
no task to perform. For example:</P>

<PRE>class C(object):
    def _ _init_ _(self): pass
    # rest of class body omitted</PRE>

<P class="docText">Now instantiating <TT>C( )</TT> without arguments works,
but mistakenly trying to pass an argument (e.g.,
<TT>C('xyz')</TT>) raises an exception. If class
<TT>C</TT> did not override <TT>_ _init_ _</TT>,
a call <TT>C('xyz')</TT> would silently ignore the
erroneous argument. It's generally best not to
silently ignore errors.</P>



<A NAME="pythonian-CHP-5-SECT-2.3.2"></A>
<H5 class="docSection3Title">5.2.3.2 _ _new_ _</H5>

<P class="docText"><A NAME="pythonian-CHP-5-ITERM-4327"></A>
<A NAME="pythonian-CHP-5-ITERM-4328"></A>Each new-style class
has a static method named <TT>_ _new_ _</TT>. When you call
<TT><I>C</I></TT><TT>(*</TT><TT><I>args</I></TT><TT>,**</TT><TT><I>kwds</I></TT><TT>)</TT>
to create a new instance of a new-style class
<TT><I>C</I></TT>, Python invokes
<TT><I>C</I></TT><TT>._ _new_
_(</TT><TT><I>C</I></TT><TT>,*</TT><TT><I>args</I></TT><TT>,**</TT><TT><I>kwds</I></TT><TT>)</TT>.
Python uses <TT>_ _new_ _</TT>'s return
value <TT><I>x</I></TT> as the newly created instance.
Then, Python calls <TT><I>C</I></TT><TT>._ _init_
_(</TT><TT><I>x</I></TT><TT>,*</TT><TT><I>args</I></TT><TT>,**</TT><TT><I>kwds</I></TT><TT>)</TT>,
but only when <TT><I>x</I></TT> is indeed an instance of
<TT><I>C</I></TT> (otherwise,
<TT><I>x</I></TT>'s state is as
<TT>_ _new_ _</TT> had left it). Thus, for a new-style
class <TT><I>C</I></TT>, the statement
<TT><I>x</I></TT><TT>=</TT><TT><I>C</I></TT><TT>(23)</TT>
is equivalent to the following code:</P>

<PRE><TT><I>x</I></TT> = <TT><I>C</I></TT>._ _new_ _(<TT><I>C</I></TT>, 23)
if isinstance(<TT><I>x</I></TT>, <TT><I>C</I></TT>): <TT><I>C</I></TT>._ _init_ _(<TT><I>x</I></TT>, 23)</PRE>

<P class="docText"><TT>object._ _new_ _</TT> creates a new, uninitialized
instance of the class it receives as its first argument, and ignores
any other arguments. When you override <TT>_ _new_ _</TT>
within the class body, you do not need to add <TT>_ _new_
_=staticmethod(_ _new_ _)</TT>, as you normally would: Python
recognizes the name <TT>_ _new_ _</TT> and treats it
specially in this context. In those rare cases in which you rebind
<TT><I>C</I></TT><TT>._ _new_ _</TT> later,
outside the body of class <TT><I>C</I></TT>, you do need
to use <TT><I>C</I></TT><TT>._ _new_
_=staticmethod(</TT><TT><I>whatever</I></TT><TT>)</TT>.</P>

<P class="docText"><TT>_ _new_ _</TT> has most of the flexibility of a factory
function, as covered earlier in this chapter. <TT>_ _new_
_</TT> may choose to return an existing instance or to make a
new one, as appropriate. When <TT>_ _new_ _</TT> does need
to create a new instance, it most often delegates creation by calling
<TT>object._ _new_ _</TT> or the <TT>_ _new_
_</TT> method of another built-in type that is a superclass of
<TT><I>C</I></TT>. The following example shows how to
override static method <TT>_ _new_ _</TT> in order to
implement a version of the Singleton design pattern:</P>

<PRE>class Singleton(object):
    _singletons = {  }
    def _ _new_ _(cls, *args, **kwds):
        if not cls._singletons.has_key(cls):
            cls._singletons[cls] = object._ _new_ _(cls)
        return cls._singletons[cls]</PRE>

<P class="docText">Any subclass of <TT>Singleton</TT> (that does not further
override <TT>_ _new_ _</TT>) has exactly one instance. If
the subclass defines an <TT>_ _init_ _</TT> method, the
subclass must ensure its <TT>_ _init_ _</TT> is safe when
called repeatedly (at each creation request) on the one and only
class instance.</P>



<A NAME="pythonian-CHP-5-SECT-2.4"></A>
<H4 class="docSection2Title">5.2.4 New-Style Instances</H4>

<P class="docText"><A NAME="pythonian-CHP-5-ITERM-4329"></A>
<A NAME="pythonian-CHP-5-ITERM-4330"></A>All features of instances of classic
classes, covered earlier in this chapter, also apply to instances of
new-style classes. In addition, new-style classes may define
attributes called properties and a special attribute named <TT>_
_slots_ _</TT> that affects access to instance attributes. The
new-style object model also adds a special method <TT>_
_getattribute_ _</TT> that is more general than the <TT>_
_getattr_ _</TT> special method present in both the classic and
new-style object models. It also has different semantics for
per-instance definition of special methods.</P>

<A NAME="pythonian-CHP-5-SECT-2.4.1"></A>
<H5 class="docSection3Title">5.2.4.1 Properties</H5>

<P class="docText"><A NAME="pythonian-CHP-5-ITERM-4331"></A>
<A NAME="pythonian-CHP-5-ITERM-4332"></A>A property
is an instance attribute with special functionality. You reference,
bind, or unbind the attribute with the normal syntax (e.g.,
<TT>print</TT>
<TT><I>x</I></TT><TT>.prop</TT>,
<TT><I>x</I></TT><TT>.prop=23</TT>, <TT>del</TT>
<TT><I>x</I></TT><TT>.prop</TT>).
However, rather than following the usual semantics for attribute
reference, binding, and unbinding, these accesses call methods on
instance <TT><I>x</I></TT> that you specify when defining
the property using the built-in type <TT>property</TT>.
Here's how to define a read-only property:</P>

<PRE>class Rectangle(object):
    def _ _init_ _(self, width, heigth):
        self.width = width
        self.heigth = heigth
    def getArea(self):
        return self.width * self.heigth
    area = property(getArea, doc='area of the rectangle')</PRE>

<P class="docText">Each instance <TT><I>r</I></TT> of class
<TT>Rectangle</TT> has a synthetic read-only attribute
<TT><I>r</I></TT><TT>.area</TT>, computed on the
fly in method <TT><I>r</I></TT><TT>.getArea(
)</TT> by multiplying the sides of the rectangle. The docstring
<TT>Rectangle.area._ _doc_ _</TT> is
'<TT>area</TT> <TT>of</TT> <TT>the</TT>
<TT>rectangle</TT>'. The property is read-only (attempts to
rebind or unbind it fail) because we only specify a
<TT>get</TT> method in the call to
<TT>property</TT>.</P>

<P class="docText">Properties perform tasks that are similar to those of special methods
<TT>_ _getattr_ _</TT>, <TT>_ _setattr_ _</TT>,
and <TT>_ _delattr_ _</TT> (covered in <A class="docLink" HREF="0596001886_pythonian-chp-5-sect-3.html#pythonian-CHP-5-SECT-3">Section 5.3</A> later in this chapter), but
in a faster and simpler way. You build a property by calling built-in
type <TT>property</TT> and binding its result to a class
attribute. Like all binding of class attributes, this is normally
done in the body of the class, but you may also choose to perform it
elsewhere. Within the body of a class <TT><I>C</I></TT>,
use the following syntax:</P>

<PRE><TT><I>attrib</I></TT> = property(<TT><I>fget</I></TT>=None, <TT><I>fset</I></TT>=None, <TT><I>fdel</I></TT>=None, <TT><I>doc</I></TT>=None)</PRE>

<P class="docText">When <TT><I>x</I></TT> is an instance
of <TT><I>C</I></TT> and you reference
<TT><I>x</I></TT>.<TT><I>attrib</I></TT>,
Python calls on <TT><I>x</I></TT> the method you passed as
argument <TT><I>fget</I></TT> to the property constructor,
without arguments. When you assign
<TT><I>x</I></TT>.<TT><I>attrib</I></TT> =
<TT><I>value</I></TT>, Python calls the method you passed
as argument <TT><I>fset</I></TT>, with
<TT><I>value</I></TT> as the only argument. When you
perform <TT>del</TT> <TT><I>x.attrib</I></TT>,
Python calls the method you passed as argument
<TT><I>fdel</I></TT>, without arguments. Python uses the
argument you passed as <TT><I>doc</I></TT> as the
docstring of the attribute. All arguments to
<TT>property</TT> are optional. When an argument is
missing, the corresponding operation is forbidden. For example, in
the <TT>Rectangle</TT> example, we made property
<TT>area</TT> read-only, because we passed only argument
<TT><I>fget</I></TT>, not arguments
<TT><I>fset</I></TT> and <TT><I>fdel</I></TT>.</P>

<P class="docText">To obtain similar results for a classic class in Python 2.1, we need
to define special methods <TT>_ _getattr_ _</TT> and
<TT>_ _setattr_ _</TT> and in each of them test for
attribute name '<TT>area</TT>' and handle it specifically.
The following example shows how to simulate a read-only property in
Python 2.1:</P>

<PRE>class Rectangle:
    def _ _init_ _(self, width, heigth):
        self.width = width
        self.heigth = heigth
    def getArea(self):
        return self.width * self.heigth
    def _ _getattr_ _(self, name):
        if name=  ='area': return self.getArea(  )
        raise AttributeError, name
    def _ _setattr_ _(self, name, value):
        if name=  ='area':
            raise AttributeError, "can't bind attribute"
        self._ _dict_ _[name] = value</PRE>



<A NAME="pythonian-CHP-5-SECT-2.4.2"></A>
<H5 class="docSection3Title">5.2.4.2 _ _slots_ _</H5>

<P class="docText">Normally, each instance object <TT><I>x</I></TT> of any
class <TT><I>C</I></TT> has a dictionary
<TT><I>x</I></TT><TT>._ _dict_ _</TT> that
Python uses to let you bind arbitrary attributes on
<TT><I>x</I></TT>. To save some memory (at the cost of
letting <TT><I>x</I></TT> have only a predefined set of
attribute names), you can define in class
<TT><I>C</I></TT> a class attribute named <TT>_
_slots_ _</TT>, which is a sequence (normally a tuple) of
strings (normally identifiers).When class
<TT><I>C</I></TT> has an attribute <TT>_ _slots_
_</TT>, a direct instance <TT><I>x</I></TT> of class
<TT><I>C</I></TT> has no
<TT><I>x</I></TT><TT>._ _dict_ _</TT>, and any
attempt to bind on <TT><I>x</I></TT> any attribute whose
name is not in <TT><I>C</I></TT><TT>._ _slots_
_</TT> raises an exception. Using <TT>_ _slots_ _</TT>
lets you reduce memory consumption for small instance objects that
can do without the ability to have arbitrarily named attributes. Note
that <TT>_ _slots_ _</TT> is worth adding only to classes
that can have so many instances that saving a few tens of bytes per
instance is important—typically classes that can have millions,
not mere thousands, of instances alive at the same time. Unlike most
other class attributes, <TT>_ _slots_ _</TT> works as
I've just described only if some statement in the
class body binds it as a class attribute. Any later alteration,
rebinding, or unbinding of <TT>_ _slots_ _</TT> has no
effect, nor does inheriting <TT>_ _slots_ _</TT> from a
base class. Here's how to add <TT>_ _slots_
_</TT> to the <TT>Rectangle</TT> class defined
earlier, to get smaller (though less flexible)
instances:<A NAME="pythonian-CHP-5-ITERM-4333"></A>
<A NAME="pythonian-CHP-5-ITERM-4334"></A></P>

<PRE>class OptimizedRectangle(Rectangle):
    _ _slots_ _ = 'width', 'heigth'</PRE>

<P class="docText">We do not need to define a slot for the <TT>area</TT>
property. <TT>_ _slots_ _</TT> does not constrain
properties, only ordinary instance attributes—the attributes
that would reside in the instance's <TT>_
_dict_ _</TT> if <TT>_ _slots_ _</TT>
wasn't defined.</P>



<A NAME="pythonian-CHP-5-SECT-2.4.3"></A>
<H5 class="docSection3Title">5.2.4.3 _ _getattribute_ _</H5>

<P class="docText"><A NAME="pythonian-CHP-5-ITERM-4335"></A>
<A NAME="pythonian-CHP-5-ITERM-4336"></A>All
references to instance attributes for new-style instances proceed
through special method <TT>_ _getattribute_ _</TT>. This
method is supplied by base class <TT>object</TT>, where it
implements all the details of object attribute reference semantics as
documented earlier in this chapter. However, you may override
<TT>_ _getattribute_ _</TT> for special purposes, such as
hiding inherited class attributes (e.g., methods) for your
subclass's instances. The following example shows
one way to implement a list without <TT>append</TT> in the
new-style object model:</P>

<PRE>class listNoAppend(list):
    def _ _getattribute_ _(self, name):
        if name =  = 'append': raise AttributeError, name
        return list._ _getattribute_ _(self, name)</PRE>

<P class="docText">An instance <TT><I>x</I></TT> of class
<TT>listNoAppend</TT> is almost indistinguishable from a
built-in list object, except that performance is substantially worse,
and any reference to
<TT><I>x</I></TT><TT>.append</TT> raises an
exception.</P>

<P class="docText">The following example shows how to implement <TT>_ _getattr_
_</TT>, <TT>_ _setattr_ _</TT>, and <TT>_
_delattr_ _</TT> so that <TT>_ _getattr_ _</TT> is
called on every attribute reference, just like <TT>_
_getattribute_ _</TT> is for new-style instances:</P>

<PRE>class AttributeWatcher:
    def _ _init_ _(self):
        # note the caution to avoid triggering _ _setattr_ _, and the
        # emulation of Python's name-mangling for a private attribute
        self._ _dict_ _['_AttributeWatcher_ _mydict']={  }
    def _ _getattr_ _(self, name):
        # as well as tracing every call, for demonstration purposes we
        # also fake "having" any requested attribute, EXCEPT special
        # methods (_ _getattr_ _ is also invoked to ask for them: check by
        # trying a few operations on an AttributeWatcher instance).
        print "getattr", name
        try: return self._ _mydict[name]
        except KeyError:
            if name.startswith('_ _') and name.endswith('_ _'):
                raise AttributeError, name
            else: return 'fake_'+name
    def _ _setattr_ _(self, name, value):
        print "setattr", name, value
        self._ _mydict[name] = value
    def _ _delattr_ _(self, name):
        print "delattr", name
        try: del self._ _mydict[name]
        except KeyError: pass</PRE>



<A NAME="pythonian-CHP-5-SECT-2.4.4"></A>
<H5 class="docSection3Title">5.2.4.4 Per-instance methods</H5>

<P class="docText"><A NAME="pythonian-CHP-5-ITERM-4337"></A> <A NAME="pythonian-CHP-5-ITERM-4338"></A>
<A NAME="pythonian-CHP-5-ITERM-4339"></A>Both
the classic and new-style object models allow an instance to have
instance-specific bindings for all attributes, including callable
attributes (methods). For a method, just like for any other
attribute, an instance-specific binding hides a class-level binding:
attribute lookup does not even look at the class if it finds a
binding directly in the instance. In both object models, an
instance-specific binding for a callable attribute does not perform
any of the transformations detailed in <A class="docLink" HREF="0596001886_pythonian-chp-5-sect-1.html#pythonian-CHP-5-SECT-1.5">Section 5.1.5</A> earlier in this chapter. In
other words, the attribute reference returns exactly the same
callable object that was earlier bound directly to the instance
attribute.<A NAME="pythonian-CHP-5-ITERM-4340"></A></P>

<P class="docText">Classic and new-style object models do differ on per-instance binding
of the special methods that Python invokes implicitly as a result of
various operations, as covered in <A class="docLink" HREF="0596001886_pythonian-chp-5-sect-3.html#pythonian-CHP-5-SECT-3">Section 5.3</A> later in this chapter. In
the classic object model, an instance may usefully override a special
method, and Python uses the per-instance binding even when invoking
the method implicitly. In the new-style object model, implicit use of
special methods always relies on the class-level binding of the
special method, if any. The following code shows this difference
between classic and new-style object models:</P>

<PRE>def fakeGetItem(idx): return idx
class Classic: pass
c = Classic(  )
c._ _getitem_ _ = fakeGetItem
print c[23]                       # prints: 23
class NewStyle(object): pass
n = NewStyle(  )
n._ _getitem_ _ = fakeGetItem
print n[23]                       # results in: 
# Traceback (most recent call last):
#   File "&lt;stdin&gt;", line 1, in ?
# TypeError: unindexable object</PRE>

<P class="docText">The semantics of the classic object model in this regard are
sometimes handy for tricky and somewhat obscure purposes. However,
the new-style object model's approach regularizes
and simplifies the relationship between classes and metaclasses,
covered in <A class="docLink" HREF="0596001886_pythonian-chp-5-sect-4.html#pythonian-CHP-5-SECT-4">Section 5.4</A> later in
this chapter.<A NAME="pythonian-CHP-5-ITERM-4341"></A> <A NAME="pythonian-CHP-5-ITERM-4342"></A></P>



<A NAME="pythonian-CHP-5-SECT-2.5"></A>
<H4 class="docSection2Title">5.2.5 Inheritance in the New-Style Object Model</H4>

<P class="docText"><A NAME="pythonian-CHP-5-ITERM-4343"></A> <A NAME="pythonian-CHP-5-ITERM-4344"></A> <A NAME="pythonian-CHP-5-ITERM-4345"></A>In
the new-style object model, inheritance works similarly to the way it
works in the classic object model. One key difference is that a
new-style class can inherit from a built-in type. The new-style
object model, like the classic one, supports multiple inheritance.
However, a class may directly or indirectly subclass multiple
built-in types only if those types are specifically designed to allow
this level of mutual compatibility. Python does not support
unconstrained inheritance from multiple arbitrary built-in types.
Normally, a new-style class only subclasses at most one substantial
built-in type; this means at most one built-in type in addition to
<TT>object</TT>, which is the superclass of all built-in
types and new-style classes and imposes no constraints on multiple
inheritance.</P>

<A NAME="pythonian-CHP-5-SECT-2.5.1"></A>
<H5 class="docSection3Title">5.2.5.1 Method resolution order</H5>

<P class="docText"><A NAME="pythonian-CHP-5-ITERM-4346"></A>
<A NAME="pythonian-CHP-5-ITERM-4347"></A>In the classic object
model, method and attribute lookup (also called
<I>resolution</I> <I>order</I>) among
direct and indirect base classes proceeds left-first, depth-first.
While very simple, this rule may produce undesired results when
multiple base classes inherit from the same common base class and
override different subsets of the common base
class's methods; in this case, the overrides of the
rightmost base class are hidden in the lookup. For example, if
<TT>A</TT> subclasses <TT>B</TT> and
<TT>C</TT> in that order, and <TT>B</TT> and
<TT>C</TT> each subclass <TT>D</TT>, the classic
lookup proceeds in the conceptual order <TT>A</TT>,
<TT>B</TT>, <TT>D</TT>, <TT>C</TT>,
<TT>D</TT>. Since Python looks up <TT>D</TT>
before <TT>C</TT>, any method defined in class
<TT>D</TT>, even if class <TT>C</TT> overrides
it, is therefore found only in the base class <TT>D</TT>
version. This issue causes few practical problems only because such
an inheritance pattern, also known as a diamond-shaped inheritance
graph, is rarely used in the classic Python object
model.<A NAME="pythonian-CHP-5-ITERM-4348"></A></P>

<P class="docText">In the new-style object model, however, all types directly or
indirectly subclass <TT>object</TT>. Therefore, any
multiple inheritance gives diamond-shaped inheritance graphs, and the
classic resolution order would often produce problems.
Python's new-style object model changes the
resolution order by leaving in the lookup sequence only the rightmost
occurrence of any given class. Using the example from the previous
paragraph, when class <TT>D</TT> is new-style (e.g.,
<TT>D</TT> directly subclasses <TT>object</TT>),
the resolution order for class <TT>A</TT> becomes
<TT>A</TT>, <TT>B</TT>, <TT>C</TT>,
<TT>D</TT>, <TT>object</TT>, and no anomalies
arise. <A class="docLink" HREF="#pythonian-CHP-5-FIG-1">Figure 5-1</A> shows the classic and new-style
method resolution orders for the case of a diamond-shaped inheritance
graph.</P>

<CENTER>
<H5 class="docFigureTitle"><A NAME="pythonian-CHP-5-FIG-1"></A>Figure 5-1. Classic and new-style method resolution order</H5>
<IMG BORDER="0" WIDTH="385" HEIGHT="261" src="FILES/pynut_0501.gif" ALT="figs/pynut_0501.gif"></CENTER>

<P class="docText">Each new-style class and built-in type has a special read-only class
attribute called <TT>_ _mro_ _</TT>, which is the tuple of
types used for method resolution, in order. You can reference
<TT>_ _mro_ _</TT> only on classes, not on instances, and,
since <TT>_ _mro_ _</TT> is a read-only attribute, you
cannot rebind or unbind it.</P>



<A NAME="pythonian-CHP-5-SECT-2.5.2"></A>
<H5 class="docSection3Title">5.2.5.2 Cooperative superclass method calling</H5>

<P class="docText"><A NAME="pythonian-CHP-5-ITERM-4349"></A>
<A NAME="pythonian-CHP-5-ITERM-4350"></A>As we saw earlier in this chapter,
when a subclass overrides a method, the overriding method often wants
to delegate part of its operation to the
superclass's implementation of the same method. The
simple solution that is idiomatic in Python's
classic object model (calling the superclass's
version directly with unbound method syntax) is imperfect in cases of
multiple inheritance with diamond-shaped graphs. Consider the
following definitions:<A NAME="pythonian-CHP-5-ITERM-4351"></A> <A NAME="pythonian-CHP-5-ITERM-4352"></A></P>

<A NAME="pythonian-CHP-5-ITERM-4353"></A><PRE>class A(object):
    def met(self): 
        print 'A.met'
class B(A):
    def met(self): 
        print 'B.met'
        A.met(self)
class C(A):
    def met(self): 
        print 'C.met'
        A.met(self)
class D(B,C):
    def met(self): 
        print 'D.met'
        B.met(self)
        C.met(self)</PRE>

<P class="docText">In this code, when we call <TT>D( ).met( )</TT>,
<TT>A.met</TT> ends up being called twice. How can we
ensure that each ancestor's implementation of the
method is called once, and only once? This problem turns out to be
rather hard to solve without some special help. The special help that
Python 2.2 provides is the new built-in type
<TT>super</TT>.
<TT>super(</TT><TT><I>aclass</I></TT>,
<TT><I>obj</I></TT><TT>)</TT> returns a special
superobject of object <TT><I>obj</I></TT>. When we look up
an attribute (e.g., a method) in this superobject, the lookup begins
after class <TT><I>aclass</I></TT> in
<TT><I>obj</I></TT>'s method resolution
order. We can therefore rewrite the previous code as:</P>

<PRE>class A(object):
    def met(self): 
        print 'A.met'
class B(A):
    def met(self): 
        print 'B.met'
        super(B,self).met(  )
class C(A):
    def met(self): 
        print 'C.met'
        super(C,self).met(  )
class D(B,C):
    def met(self): 
        print 'D.met'
        super(D,self).met(  )</PRE>

<P class="docText">Now, <TT>D( ).met( )</TT> results in exactly one call to
each class's version of <TT>met</TT>. If
you get into the habit of always coding superclass calls with
<TT>super</TT>, your classes will fit smoothly even in
complicated inheritance structures. There are no ill effects
whatsoever if the inheritance structure turns out to be simple
instead (as long as your code only runs on Python 2.2 and later, of
course).<A NAME="pythonian-CHP-5-ITERM-4354"></A>
<A NAME="pythonian-CHP-5-ITERM-4355"></A>
<A NAME="pythonian-CHP-5-ITERM-4356"></A>
<A NAME="pythonian-CHP-5-ITERM-4357"></A>
<A NAME="pythonian-CHP-5-ITERM-4358"></A>
<A NAME="pythonian-CHP-5-ITERM-4359"></A></P>




<ul></ul>
</td>
</tr>
</table>
<td></td>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<td class="tt1"><a href="NFO/lib.html">[ Team LiB ]</a></td><td valign="top" class="tt1" align="right">
          <a href="0596001886_pythonian-chp-5-sect-1.html"><img src="FILES/previous.gif" width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a>
          <a href="0596001886_pythonian-chp-5-sect-3.html"><img src="FILES/next.gif" width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a>
</td></table>
</body></html>
