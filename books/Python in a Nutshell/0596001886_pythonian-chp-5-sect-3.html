<html><head>
<META http-equiv="Content-Type" content="text/html">
<!--SafClassName="docSection1Title"--><!--SafTocEntry="5.3 Special Methods"-->
<link rel="STYLESHEET" type="text/css" href="FILES/style.css">
<link rel="STYLESHEET" type="text/css" href="FILES/docsafari.css">
<style type="text/css">	.tt1    {font-size: 10pt;}</style>
</head>
<body>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<td class="tt1"><a href="NFO/lib.html">[ Team LiB ]</a></td><td valign="top" class="tt1" align="right">
	<a href="0596001886_pythonian-chp-5-sect-2.html"><img src="FILES/previous.gif" width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a>
	<a href="0596001886_pythonian-chp-5-sect-4.html"><img src="FILES/next.gif" width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a>
</td></table>
<br>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<tr>
<td valign="top"><A NAME="pythonian-CHP-5-SECT-3"></A>
<H3 class="docSection1Title">5.3 Special Methods</H3>

<P class="docText"><A NAME="pythonian-CHP-5-ITERM-4360"></A>
<A NAME="pythonian-CHP-5-ITERM-4361"></A>A
class may define or inherit special methods (i.e., methods whose
names begin and end with double underscores). Each special method
relates to a specific operation. Python implicitly invokes a special
method whenever you perform the related operation on an instance
object. In most cases, the method's return value is
the operation's result, and attempting an operation
when its related method is not present raises an exception.
Throughout this section, I will point out the cases in which these
general rules do not apply. In the following,
<TT><I>x</I></TT> is the instance of class
<TT><I>C</I></TT> on which you perform the operation, and
<TT><I>y</I></TT> is the other operand, if any. The formal
argument <TT>self</TT> of each method also refers to
instance object
<TT><I>x</I></TT>.<A NAME="pythonian-CHP-5-ITERM-4362"></A></P>

<A NAME="pythonian-CHP-5-SECT-3.1"></A>
<H4 class="docSection2Title">5.3.1 General-Purpose Special Methods</H4>

<P class="docText"><A NAME="pythonian-CHP-5-ITERM-4363"></A>
<A NAME="pythonian-CHP-5-ITERM-4364"></A>Some special methods relate to
general-purpose operations. A class that defines or inherits these
methods allows its instances to control such operations. These
operations can be divided into the following categories:</P>

<DL class="docList">
<DT><I><span class="docPubcolor">Initialization and finalization</span></I></DT>
<DD>
<P class="docList">An instance can control its initialization (a frequent need) via
special method <TT>_ _init_ _</TT>, and/or its finalization
(a rare need) via <TT>_ _del_ _</TT>.</P>
</DD>
<DT><I><span class="docPubcolor">Representation as string</span></I></DT>
<DD>
<P class="docList">An instance can control how Python represents it as a string via
special methods <TT>_ _repr_ _</TT>, <TT>_ _str_
_</TT>, and <TT>_ _unicode_ _</TT>.</P>
</DD>
<DT><I><span class="docPubcolor">Comparison, hashing, and use in a Boolean context</span></I></DT>
<DD>
<P class="docList">An instance can control how it compares with other objects (methods
<TT>_ _lt_ _</TT> and <TT>_ _cmp_ _</TT>), how
dictionaries use it as a key (<TT>_ _hash_ _</TT>), and
whether it evaluates to true or false in Boolean contexts (<TT>_
_nonzero_ _</TT>).</P>
</DD>
<DT><I><span class="docPubcolor">Attribute reference, binding, and unbinding</span></I></DT>
<DD>
<P class="docList">An instance can control access to its attributes (reference, binding,
unbinding) by defining special methods <TT>_ _getattribute_
_</TT>, <TT>_ _getattr_ _</TT>, <TT>_ _setattr_
_</TT>, and <TT>_ _delattr_ _</TT>.</P>
</DD>
<DT><I><span class="docPubcolor">Callable instances</span></I></DT>
<DD>
<P class="docList">An instance is callable, just like a function object, if it has the
special method <TT>_ _call_ _</TT>.</P>
</DD>
</DL>

<P class="docText">The rest of this section documents the general-purpose special
methods.<A NAME="pythonian-CHP-5-ITERM-4365"></A></P>

<A NAME="ch05-77044"></A><A NAME="pythonian-CHP-5-ITERM-4366"></A><A NAME="pythonian-CHP-5-ITERM-4367"></A><table width="515" border="0" cellpadding="5">
<tr>
<td align="left"><b><i>_ _call_ _
</i></b></td>
<td align="right"></td>
</tr>
</table>
<hr width="515" size="3" noshade="true" align="left" color="black">
<table width="515" border="0" cellpadding="5">
<tr>
<td align="left">
<pre>_ _call_ _(self[,<TT><I>args</I></TT>...])</pre>
</td>
<td align="right"></td>
</tr>
</table>
<P class="docText">When you call
<TT><I>x</I></TT><TT>(</TT><TT><I>[args...]</I></TT><TT>)</TT>,
Python translates the operation into a call to
<TT><I>x</I></TT><TT>._ _call_
_(</TT><TT><I>[args...]</I></TT><TT>)</TT>.
The formal arguments for the call operation are the same as for the
<TT>_ _call_ _</TT> method, minus the first argument. The
first argument, conventionally called <TT>self</TT>, refers
to <TT><I>x</I></TT>, and Python supplies it implicitly
and automatically, just as in any other call to a bound method.</P>

<A NAME="ch05-77045"></A><A NAME="pythonian-CHP-5-ITERM-4368"></A><A NAME="pythonian-CHP-5-ITERM-4369"></A><A NAME="pythonian-CHP-5-ITERM-4370"></A><table width="515" border="0" cellpadding="5">
<tr>
<td align="left"><b><i>_ _cmp_ _

</i></b></td>
<td align="right"></td>
</tr>
</table>
<hr width="515" size="3" noshade="true" align="left" color="black">
<table width="515" border="0" cellpadding="5">
<tr>
<td align="left">
<pre>_ _cmp_ _(self,<TT><I>other</I></TT>)</pre>
</td>
<td align="right"></td>
</tr>
</table>
<P class="docText">Any comparison, when its specific special method (<TT>_ _lt_
_</TT>, <TT>_ _gt_ _</TT>, etc.) is absent or returns
<TT>NotImplemented</TT>, calls
<TT><I>x</I></TT><TT>._ _cmp_
_(</TT><TT><I>y</I></TT><TT>)</TT> instead,
as do built-in function
<TT>cmp(</TT><TT><I>x</I></TT>,<TT><I>y</I></TT><TT>)</TT>
and the <TT>sort</TT> method of list objects. <TT>_
_cmp_ _</TT> should return <TT>-1</TT> if
<TT><I>x</I></TT> is less than
<TT><I>y</I></TT>, <TT>0</TT> if
<TT><I>x</I></TT> is equal to
<TT><I>y</I></TT>, or <TT>1</TT> if
<TT><I>x</I></TT> is greater than
<TT><I>y</I></TT>. When <TT>_ _cmp_ _</TT> is
also absent, order comparisons (<TT>&lt;</TT>,
<TT>&lt;=</TT>, <TT>&gt;</TT>,
<TT>&gt;=</TT>) raise exceptions. Equality comparisons
(<TT>= =</TT>, <TT>!=</TT>), in this case, become
identity checks: <TT><I>x</I></TT><TT>=
=</TT><TT><I>y</I></TT> evaluates
<TT>id(</TT><TT><I>x</I></TT><TT>)=
=id(</TT><TT><I>y</I></TT><TT>)</TT> (i.e.,
<TT><I>x</I></TT> <TT>is</TT>
<TT><I>y</I></TT>).</P>

<A NAME="ch05-77046"></A><A NAME="pythonian-CHP-5-ITERM-4371"></A><A NAME="pythonian-CHP-5-ITERM-4372"></A><A NAME="pythonian-CHP-5-ITERM-4373"></A><table width="515" border="0" cellpadding="5">
<tr>
<td align="left"><b><i>_ _del_ _

</i></b></td>
<td align="right"></td>
</tr>
</table>
<hr width="515" size="3" noshade="true" align="left" color="black">
<table width="515" border="0" cellpadding="5">
<tr>
<td align="left">
<pre>_ _del_ _(self)</pre>
</td>
<td align="right"></td>
</tr>
</table>
<P class="docText">Just before <TT><I>x</I></TT> disappears because of
garbage collection, Python calls
<TT><I>x</I></TT><TT>._ _del_ _( )</TT> to let
<TT><I>x</I></TT> finalize itself. If <TT>_ _del_
_</TT> is absent, Python performs no special finalization upon
garbage-collecting <TT><I>x</I></TT> (this is the usual
case, as very few classes need to define <TT>_ _del_
_</TT>). Python ignores the return value of <TT>_ _del_
_</TT>. Python performs no implicit call to <TT>_ _del_
_</TT> methods of class
<TT><I>C</I></TT>'s superclasses.
<TT><I>C</I></TT><TT>._ _del_ _</TT> must
explicitly perform any needed finalization.</P>
<P class="docText">For example, when class <TT><I>C</I></TT> has a base class
<TT><I>B</I></TT> to finalize, the code in
<TT><I>C</I></TT><TT>._ _del_ _</TT> must call
<TT><I>B</I></TT><TT>._ _del_ _(self)</TT> (or
better, for new-style classes,
<TT>super(</TT><TT><I>C</I></TT>,
<TT>self)._ _del_ _( )</TT>). <TT>_ _del_ _</TT>
is generally not the best approach when you need timely and
guaranteed finalization. For such needs, use the
<TT>try</TT>/<TT>finally</TT> statement covered
in <A class="docLink" HREF="0596001886_pythonian-chp-6.html#pythonian-CHP-6">Chapter 6</A>.</P>

<A NAME="ch05-77047"></A><A NAME="pythonian-CHP-5-ITERM-4374"></A><A NAME="pythonian-CHP-5-ITERM-4375"></A><table width="515" border="0" cellpadding="5">
<tr>
<td align="left"><b><i>_ _delattr_ _
</i></b></td>
<td align="right"></td>
</tr>
</table>
<hr width="515" size="3" noshade="true" align="left" color="black">
<table width="515" border="0" cellpadding="5">
<tr>
<td align="left">
<pre>_ _delattr_ _(self,<TT><I>name</I></TT>)</pre>
</td>
<td align="right"></td>
</tr>
</table>
<P class="docText">At every request to unbind attribute
<TT><I>x</I></TT>.<TT><I>y</I></TT>
(typically, a <TT>del</TT> statement <TT>del</TT>
<TT><I>x</I></TT>.<TT><I>y</I></TT>),
Python calls <TT><I>x</I></TT><TT>._ _delattr_
_(</TT>'<TT><I>y</I></TT>'<TT>)</TT>. All
the considerations discussed for <TT>_ _setattr_ _</TT>
also apply to <TT>_ _delattr_ _</TT>. Python ignores the
return value of <TT>_ _delattr_ _</TT>. If <TT>_
_delattr_ _</TT> is absent, Python usually translates
<TT>del</TT>
<TT><I>x</I></TT>.<TT><I>y</I></TT>
into <TT>del</TT> <TT><I>x</I></TT><TT>._
_dict_
_[</TT>'<TT><I>y</I></TT>'<TT>]</TT>.</P>

<A NAME="ch05-77048"></A><A NAME="pythonian-CHP-5-ITERM-4376"></A><A NAME="pythonian-CHP-5-ITERM-4377"></A><A NAME="pythonian-CHP-5-ITERM-4378"></A><A NAME="pythonian-CHP-5-ITERM-4379"></A><A NAME="pythonian-CHP-5-ITERM-4380"></A><A NAME="pythonian-CHP-5-ITERM-4381"></A><A NAME="pythonian-CHP-5-ITERM-4382"></A><A NAME="pythonian-CHP-5-ITERM-4383"></A><A NAME="pythonian-CHP-5-ITERM-4384"></A><A NAME="pythonian-CHP-5-ITERM-4385"></A><A NAME="pythonian-CHP-5-ITERM-4386"></A><A NAME="pythonian-CHP-5-ITERM-4387"></A><table width="515" border="0" cellpadding="5">
<tr>
<td align="left"><b><i>_ _eq_ _, _ _ge_ _, _ _gt_ _, _ _le_ _, _ _lt_ _, _ _ne_ _</i></b></td>
<td align="right"></td>
</tr>
</table>
<hr width="515" size="3" noshade="true" align="left" color="black">
<table width="515" border="0" cellpadding="5">
<tr>
<td align="left">
<pre>_ _eq_ _(self,<TT><I>other</I></TT>)
_ _ge_ _(self,<TT><I>other</I></TT>)
_ _gt_ _(self,<TT><I>other</I></TT>)
_ _le_ _(self,<TT><I>other</I></TT>)
_ _lt_ _(self,<TT><I>other</I></TT>)
_ _ne_ _(self,<TT><I>other</I></TT>)</pre>
</td>
<td align="right"></td>
</tr>
</table>
<P class="docText">Comparisons <TT><I>x</I></TT><TT>=
=</TT><TT><I>y</I></TT>,
<TT><I>x</I></TT><TT>&gt;=</TT><TT><I>y</I></TT>, <TT><I>x</I></TT><TT>&gt;</TT><TT><I>y</I></TT>, <TT><I>x</I></TT><TT>&lt;=</TT><TT><I>y</I></TT>, <TT><I>x</I></TT><TT>&lt;</TT><TT><I>y</I></TT>, and
<TT><I>x</I></TT><TT>!=</TT><TT><I>y</I></TT>,
respectively, call the special methods listed here, which should
return <TT>False</TT> or <TT>True</TT> (in Python
2.2.1 and later; <TT>0</TT> or <TT>1</TT> in
Python 2.2, 2.1, and earlier). Each method may return
<TT>NotImplemented</TT> to tell Python to handle the
comparison in alternative ways (e.g., Python may then try
<TT><I>y</I></TT><TT>&gt;</TT><TT><I>x</I></TT>
in lieu of
<TT><I>x</I></TT><TT>&lt;</TT><TT><I>y</I></TT>).</P>

<A NAME="ch05-77049"></A><A NAME="pythonian-CHP-5-ITERM-4388"></A><A NAME="pythonian-CHP-5-ITERM-4389"></A><table width="515" border="0" cellpadding="5">
<tr>
<td align="left"><b><i>_ _getattr_ _


</i></b></td>
<td align="right"></td>
</tr>
</table>
<hr width="515" size="3" noshade="true" align="left" color="black">
<table width="515" border="0" cellpadding="5">
<tr>
<td align="left">
<pre>_ _getattr_ _(self,<TT><I>name</I></TT>)</pre>
</td>
<td align="right"></td>
</tr>
</table>
<P class="docText">When attribute
<TT><I>x</I></TT>.<TT><I>y</I></TT>
is accessed but not found by the usual procedure (i.e., where
<TT>AttributeError</TT> would normally be raised), Python
calls <TT><I>x</I></TT><TT>._ _getattr_
_(</TT>'<TT><I>y</I></TT>'<TT>)</TT>
instead. Python does not call <TT>_ _getattr_ _</TT> for
attributes found by normal means (i.e., as keys in
<TT><I>x</I></TT><TT>._ _dict_ _</TT> or via
<TT><I>x</I></TT><TT>._ _class_ _</TT>). If you
want Python to call <TT>_ _getattr_ _</TT> on every
attribute reference, keep the attributes elsewhere (e.g., in another
dictionary referenced by an attribute with a private name, as shown
earlier in this chapter), or else write a new-style class and
override <TT>_ _getattribute_ _</TT> instead. <TT>_
_getattr_ _</TT> should raise <TT>AttributeError</TT>
if it cannot find <TT><I>y</I></TT>.</P>

<A NAME="ch05-77050"></A><A NAME="pythonian-CHP-5-ITERM-4390"></A><A NAME="pythonian-CHP-5-ITERM-4391"></A><table width="515" border="0" cellpadding="5">
<tr>
<td align="left"><b><i>_ _getattribute_ _


</i></b></td>
<td align="right"><i>Python 2.2 and later</i></td>
</tr>
</table>
<hr width="515" size="3" noshade="true" align="left" color="black">
<table width="515" border="0" cellpadding="5">
<tr>
<td align="left">
<pre>_ _getattribute_ _(self,<TT><I>name</I></TT>)</pre>
</td>
<td align="right"></td>
</tr>
</table>
<P class="docText">At every request to access attribute
<TT><I>x</I></TT>.<TT><I>y</I></TT>,
if <TT><I>x</I></TT> is an instance of new-style class
<TT><I>C</I></TT>, Python calls
<TT><I>x</I></TT><TT>._ _getattribute_
_(</TT>'<TT><I>y</I></TT>'<TT>)</TT>, which
must obtain and return the attribute value or else raise
<TT>AttributeError</TT>. The normal semantics of attribute
access (using <TT><I>x</I></TT><TT>._ _dict_
_</TT>, <TT><I>C</I></TT><TT>._ _slots_
_</TT>, <TT><I>C</I></TT>'s class
attributes, <TT><I>x</I></TT><TT>._ _getattr_
_</TT>) are all due to <TT>object._ _getattribute_
_</TT>.</P>
<P class="docText">If class <TT><I>C</I></TT> overrides <TT>_
_getattribute_ _</TT>, it must implement all of the attribute
access semantics it wants to offer. Most often, the most convenient
way to implement attribute access semantics is by delegating (e.g.,
calling <TT>object._ _getattribute_ _(self</TT>,
<TT>...)</TT> as part of the operation of your override of
<TT>_ _getattribute_ _</TT>). Note that a class that
overrides <TT>_ _getattribute_ _</TT> makes attribute
access on instances of the class quite slow, since your overriding
code is called on every such attribute access.</P>

<A NAME="ch05-77051"></A><A NAME="pythonian-CHP-5-ITERM-4392"></A><A NAME="pythonian-CHP-5-ITERM-4393"></A><table width="515" border="0" cellpadding="5">
<tr>
<td align="left"><b><i>_ _hash_ _


</i></b></td>
<td align="right"></td>
</tr>
</table>
<hr width="515" size="3" noshade="true" align="left" color="black">
<table width="515" border="0" cellpadding="5">
<tr>
<td align="left">
<pre>_ _hash_ _(self)</pre>
</td>
<td align="right"></td>
</tr>
</table>
<P class="docText">The
<TT>hash(</TT><TT><I>x</I></TT><TT>)</TT>
built-in function call, and using <TT><I>x</I></TT> as a
dictionary key (typically,
<TT><I>D</I></TT><TT>[</TT><TT><I>x</I></TT><TT>]</TT>
where <TT><I>D</I></TT> is a dictionary), call
<TT><I>x</I></TT><TT>._ _hash_ _( )</TT>.
<TT>_ _hash_ _</TT> must return a 32-bit
<TT>int</TT> such that
<TT><I>x</I></TT><TT>=
=</TT><TT><I>y</I></TT> implies
<TT>hash(</TT><TT><I>x</I></TT><TT>)=
=hash(</TT><TT><I>y</I></TT><TT>)</TT>, and
must always return the same value for a given object.</P>
<P class="docText">When <TT>_ _hash_ _</TT> is absent,
<TT>hash(</TT><TT><I>x</I></TT><TT>)</TT>
and using <TT><I>x</I></TT> as a dictionary key call
<TT>id(</TT><TT><I>x</I></TT><TT>)</TT>
instead, as long as <TT>_ _cmp_ _</TT> and <TT>_ _eq_
_</TT> are also absent.</P>
<P class="docText">Any <TT><I>x</I></TT> such that
<TT>hash(</TT><TT><I>x</I></TT><TT>)</TT>
returns a result, rather than raising an exception, is known as a
<I>hashable</I> <I>object</I>. When
<TT>_ _hash_ _</TT> is absent, but <TT>_ _cmp_
_</TT> or <TT>_ _eq_ _</TT> is present,
<TT>hash(</TT><TT><I>x</I></TT><TT>)</TT>
and using <TT><I>x</I></TT> as a dictionary key raise an
exception. In this case, <TT><I>x</I></TT> is not hashable
and cannot be a dictionary key.</P>
<P class="docText">You normally define <TT>_ _hash_ _</TT> only for immutable
objects that also define <TT>_ _cmp_ _</TT> and/or
<TT>_ _eq_ _</TT>. Note that, if there exists any
<TT><I>y</I></TT> such that
<TT><I>x</I></TT><TT>=
=</TT><TT><I>y</I></TT>, even if
<TT><I>y</I></TT> is of a different type, and both
<TT><I>x</I></TT> and <TT><I>y</I></TT> are
hashable, you must ensure that
<TT>hash(</TT><TT><I>x</I></TT><TT>)=
=hash(</TT><TT><I>y</I></TT><TT>)</TT>.</P>

<A NAME="ch05-77052"></A><A NAME="pythonian-CHP-5-ITERM-4394"></A><A NAME="pythonian-CHP-5-ITERM-4395"></A><table width="515" border="0" cellpadding="5">
<tr>
<td align="left"><b><i>_ _init_ _


</i></b></td>
<td align="right"></td>
</tr>
</table>
<hr width="515" size="3" noshade="true" align="left" color="black">
<table width="515" border="0" cellpadding="5">
<tr>
<td align="left">
<pre>_ _init_ _(self[,<TT><I>args</I></TT>...])</pre>
</td>
<td align="right"></td>
</tr>
</table>
<P class="docText">When a call
<TT><I>C</I></TT><TT>(</TT><TT><I>[args...]</I></TT><TT>)</TT>
creates instance <TT><I>x</I></TT> of class
<TT><I>C</I></TT> Python calls
<TT><I>x</I></TT><TT>._ _init_
_(</TT><TT><I>[args...]</I></TT><TT>)</TT>
to let <TT><I>x</I></TT> initialize itself. If <TT>_
_init_ _</TT> is absent, you must call class
<TT><I>C</I></TT> without arguments,
<TT><I>C</I></TT><TT>( )</TT>, and
<TT><I>x</I></TT> has no instance-specific attributes upon
creation (note that <TT>_ _init_ _</TT> is never absent for
a new-style class, since such a class inherits <TT>_ _init_
_</TT> from <TT>object</TT> unless it redefines it).
<TT>_ _init_ _</TT> must return <TT>None</TT>.
Python performs no implicit call to <TT>_ _init_ _</TT>
methods of class <TT><I>C</I></TT>'s
superclasses. <TT><I>C</I></TT><TT>._ _init_
_</TT> must explicitly perform any needed initialization. For
example, when class <TT><I>C</I></TT> has a base class
<TT><I>B</I></TT> to initialize without arguments, the
code in <TT><I>C</I></TT><TT>._ _init_ _</TT>
must explicitly call <TT><I>B</I></TT><TT>._ _init_
_(self)</TT> (or better, for new-style classes, call
<TT>super(</TT><TT><I>C</I></TT>,
<TT>self)._ _init_ _( )</TT>).</P>

<A NAME="ch05-77053"></A><A NAME="pythonian-CHP-5-ITERM-4396"></A><A NAME="pythonian-CHP-5-ITERM-4397"></A><table width="515" border="0" cellpadding="5">
<tr>
<td align="left"><b><i>_ _new_ _


</i></b></td>
<td align="right"><i>Python 2.2 and later</i></td>
</tr>
</table>
<hr width="515" size="3" noshade="true" align="left" color="black">
<table width="515" border="0" cellpadding="5">
<tr>
<td align="left">
<pre>_ _new_ _(cls[,<TT><I>args</I></TT>...])</pre>
</td>
<td align="right"></td>
</tr>
</table>
<P class="docText">When you call
<TT><I>C</I></TT><TT>(</TT><TT><I>[args...]</I></TT><TT>)</TT>
and <TT><I>C</I></TT> is a new-style class, Python will
obtain the new instance <TT><I>x</I></TT> that you are
creating by invoking <TT><I>C</I></TT><TT>._ _new_
_(</TT><TT><I>C</I></TT>,<TT><I>[args...]</I></TT><TT>)</TT>.
<TT>_ _new_ _</TT> is a static method that every new-style
class has (often simply inheriting it from <TT>object</TT>)
and it can return any value <TT><I>x</I></TT>. In other
words, <TT>_ _new_ _</TT> is not constrained to returning a
new instance of <TT><I>C</I></TT>, although normally it is
expected to do so. If, and only if, the value
<TT><I>x</I></TT> that <TT>_ _new_ _</TT>
returns is indeed an instance of <TT><I>C</I></TT>
(whether a new or previously existing one), Python continues after
calling <TT>_ _new_ _</TT> by implicitly calling <TT>_
_init_ _</TT> on <TT><I>x</I></TT>.</P>

<A NAME="ch05-77054"></A><A NAME="pythonian-CHP-5-ITERM-4398"></A><A NAME="pythonian-CHP-5-ITERM-4399"></A><table width="515" border="0" cellpadding="5">
<tr>
<td align="left"><b><i>_ _nonzero_ _


</i></b></td>
<td align="right"></td>
</tr>
</table>
<hr width="515" size="3" noshade="true" align="left" color="black">
<table width="515" border="0" cellpadding="5">
<tr>
<td align="left">
<pre>_ _nonzero_ _(self)</pre>
</td>
<td align="right"></td>
</tr>
</table>
<P class="docText">When evaluating <TT>x</TT> as true or false (see <A class="docLink" HREF="0596001886_pythonian-chp-4-sect-2.html#pythonian-CHP-4-SECT-2.6">Section 4.2.6</A>), for example on a call to
<TT>bool(</TT><TT><I>x</I></TT><TT>)</TT>
in Python 2.2.1 and later, Python calls
<TT><I>x</I></TT><TT>._ _nonzero_ _( )</TT>,
which should return <TT>True</TT> or
<TT>False</TT>. When <TT>_ _nonzero_ _</TT> is
not present, Python calls <TT>_ _len_ _</TT> instead, and
takes <TT><I>x</I></TT> as false when
<TT><I>x</I></TT><TT>._ _len_ _( )</TT> returns
<TT>0</TT>. When neither <TT>_ _nonzero_ _</TT>
nor <TT>_ _len_ _</TT> is present, Python always takes
<TT><I>x</I></TT> as true.</P>

<A NAME="ch05-77055"></A><A NAME="pythonian-CHP-5-ITERM-4400"></A><A NAME="pythonian-CHP-5-ITERM-4401"></A><table width="515" border="0" cellpadding="5">
<tr>
<td align="left"><b><i>_ _repr_ _


</i></b></td>
<td align="right"></td>
</tr>
</table>
<hr width="515" size="3" noshade="true" align="left" color="black">
<table width="515" border="0" cellpadding="5">
<tr>
<td align="left">
<pre>_ _repr_ _(self)</pre>
</td>
<td align="right"></td>
</tr>
</table>
<P class="docText">The
<TT>repr(</TT><TT><I>x</I></TT><TT>)</TT>
built-in function call, the <TT>`x`</TT> expression form,
and the interactive interpreter (when <TT><I>x</I></TT> is
the result of an expression statement) call
<TT><I>x</I></TT>.<TT>_ _repr_ _( )</TT> to
obtain an official, complete string representation of
<TT><I>x</I></TT>. If <TT>_ _repr_ _</TT> is
absent, Python uses a default string representation. <TT>_
_repr_ _</TT> should return a string with unambiguous
information on <TT><I>x</I></TT>. Ideally, when feasible,
the string should be an expression such that
<TT>eval(repr(</TT><TT><I>x</I></TT><TT>))=
=</TT><TT><I>x</I></TT>.</P>

<A NAME="ch05-77056"></A><A NAME="pythonian-CHP-5-ITERM-4402"></A><A NAME="pythonian-CHP-5-ITERM-4403"></A><table width="515" border="0" cellpadding="5">
<tr>
<td align="left"><b><i>_ _setattr_ _


</i></b></td>
<td align="right"></td>
</tr>
</table>
<hr width="515" size="3" noshade="true" align="left" color="black">
<table width="515" border="0" cellpadding="5">
<tr>
<td align="left">
<pre>_ _setattr_ _(self, <TT><I>name</I></TT>, <TT><I>value</I></TT>)</pre>
</td>
<td align="right"></td>
</tr>
</table>
<P class="docText">At every request to bind attribute
<TT><I>x</I></TT>.<TT><I>y</I></TT>
(typically, an assignment statement
<TT><I>x</I></TT>.<TT><I>y</I></TT><TT>=</TT><TT><I>value</I></TT>),
Python calls <TT><I>x</I></TT><TT>._ _setattr_
_(</TT>'<TT><I>y</I></TT>',<TT><I>value</I></TT><TT>)</TT>.
Python always calls <TT>_ _setattr_ _</TT> for any
attribute binding on <TT><I>x</I></TT>; a major difference
from <TT>_ _getattr_ _</TT> (<TT>_ _setattr_
_</TT> is closer to new-style classes'
<TT>_ _getattribute_ _</TT> in this sense). To avoid
recursion, when <TT><I>x</I></TT><TT>._ _setattr_
_</TT> binds <TT><I>x</I></TT>'s
attributes, it must modify <TT><I>x</I></TT><TT>._
_dict_ _</TT> directly (e.g., by
<TT><I>x</I></TT><TT>._ _dict_
_[</TT><TT><I>name</I></TT><TT>]=</TT><TT><I>value</I></TT>),
or better, for a new-style class, delegate (e.g., call
<TT>super(C</TT>, <TT>x)._ _setattr_
_(</TT>'<TT><I>y</I></TT>',<TT><I>value</I></TT><TT>)</TT>).
Python ignores the return value of <TT>_ _setattr_ _</TT>.
If <TT>_ _setattr_ _</TT> is absent, Python usually
translates
<TT><I>x</I></TT>.<TT><I>y</I></TT><TT>=</TT><TT><I>z</I></TT>
into <TT><I>x</I></TT><TT>._ _dict_
_[</TT>'<TT><I>y</I></TT>'<TT>]=</TT><TT><I>z</I></TT>.</P>

<A NAME="ch05-77057"></A><A NAME="pythonian-CHP-5-ITERM-4404"></A><A NAME="pythonian-CHP-5-ITERM-4405"></A><table width="515" border="0" cellpadding="5">
<tr>
<td align="left"><b><i>_ _str_ _


</i></b></td>
<td align="right"></td>
</tr>
</table>
<hr width="515" size="3" noshade="true" align="left" color="black">
<table width="515" border="0" cellpadding="5">
<tr>
<td align="left">
<pre>_ _str_ _(self)</pre>
</td>
<td align="right"></td>
</tr>
</table>
<P class="docText">The
<TT>str(</TT><TT><I>x</I></TT><TT>)</TT>
built-in type and the <TT>print</TT>
<TT><I>x</I></TT> statement call
<TT><I>x</I></TT><TT>._ _str_ _( )</TT> to
obtain an informal, concise string representation of
<TT><I>x</I></TT>. If <TT>_ _str_ _</TT> is
absent, Python calls <TT><I>x</I></TT><TT>._ _repr_
_</TT> instead. <TT>_ _str_ _</TT> should return a
conveniently human-readable string, even if it entails some
approximation.</P>

<A NAME="ch05-77058"></A><A NAME="pythonian-CHP-5-ITERM-4406"></A><A NAME="pythonian-CHP-5-ITERM-4407"></A><A NAME="pythonian-CHP-5-ITERM-4408"></A><A NAME="pythonian-CHP-5-ITERM-4409"></A><table width="515" border="0" cellpadding="5">
<tr>
<td align="left"><b><i>_ _unicode_ _</i></b></td>
<td align="right"><i>Python 2.2 and later</i></td>
</tr>
</table>
<hr width="515" size="3" noshade="true" align="left" color="black">
<table width="515" border="0" cellpadding="5">
<tr>
<td align="left">
<pre>_ _unicode_ _(self)</pre>
</td>
<td align="right"></td>
</tr>
</table>
<P class="docText">The
<TT>unicode(</TT><TT><I>x</I></TT><TT>)</TT>
built-in type call, in Python 2.2 and later, invokes
<TT><I>x</I></TT><TT>._ _unicode_ _( )</TT>, if
present, in preference to <TT><I>x</I></TT><TT>._
_str_ _( )</TT>. If a class supplies both special methods
<TT>_ _unicode_ _</TT> and <TT>_ _str_ _</TT>,
the two should return equivalent strings (of Unicode and plain string
type respectively).<A NAME="pythonian-CHP-5-ITERM-4408"></A> <A NAME="pythonian-CHP-5-ITERM-4409"></A></P>



<A NAME="pythonian-CHP-5-SECT-3.2"></A>
<H4 class="docSection2Title">5.3.2 Special Methods for Containers</H4>

<P class="docText"><A NAME="pythonian-CHP-5-ITERM-4410"></A> <A NAME="pythonian-CHP-5-ITERM-4411"></A> <A NAME="pythonian-CHP-5-ITERM-4412"></A>An instance can be a
<span class="docEmphasis">container</span> (either a sequence or a mapping, but
not both, as they are mutually exclusive concepts). For maximum
usefulness, containers should provide not just special methods
<TT>_ _getitem_ _</TT>, <TT>_ _setitem_ _</TT>,
<TT>_ _delitem_ _</TT>, <TT>_ _len_ _</TT>,
<TT>_ _contains_ _</TT>, and <TT>_ _iter_ _</TT>,
but also a few non-special methods, as discussed in the following
sections.</P>

<A NAME="pythonian-CHP-5-SECT-3.2.1"></A>
<H5 class="docSection3Title">5.3.2.1 Sequences</H5>

<P class="docText"><A NAME="pythonian-CHP-5-ITERM-4413"></A>In each item access special method, a
sequence that has <TT><I>L</I></TT> items should accept
any integer <TT><I>key</I></TT>, such that
<TT>0&lt;=</TT><TT><I>key</I></TT><TT>&lt;</TT><TT><I>L</I></TT>.
For compatibility with built-in sequences, a negative index
<TT><I>key</I></TT>,
<TT>0&gt;</TT><TT><I>key</I></TT><TT>&gt;=-</TT><TT><I>L</I></TT>,
should be equivalent to
<TT><I>key</I></TT><TT>+</TT><TT><I>L</I></TT>.
When <TT><I>key</I></TT> has an invalid type, the method
should raise <TT>TypeError</TT>. When
<TT><I>key</I></TT> is a value of a valid type, but out of
range, the method should raise <TT>IndexError</TT>. In
Python 2.1, and also in later Python versions for classes that do not
define <TT>_ _iter_ _</TT>, the <TT>for</TT>
statement relies on these requirements, as do built-in functions that
take sequences as arguments.</P>

<P class="docText">A sequence should also allow concatenation by <TT>+</TT>
and repetition by <TT>*</TT>. A sequence should therefore
have special methods <TT>_ _add_ _</TT>, <TT>_ _mul_
_</TT>, <TT>_ _radd_ _</TT>, and <TT>_ _rmul_
_</TT>, covered in <A class="docLink" HREF="#pythonian-CHP-5-SECT-3.3">Section 5.3.3</A> later in this chapter.
Mutable sequences should also have <TT>_ _iadd_ _</TT> and
<TT>_ _imul_ _</TT>, and the non-special methods covered in
<A class="docLink" HREF="0596001886_pythonian-chp-4-sect-6.html#pythonian-CHP-4-SECT-6.4.3">Section 4.6.4.3</A>: <TT>append</TT>,
<TT>count</TT>, <TT>index</TT>,
<TT>insert</TT>, <TT>extend</TT>,
<TT>pop</TT>, <TT>remove</TT>,
<TT>reverse</TT>, and <TT>sort</TT>.</P>



<A NAME="pythonian-CHP-5-SECT-3.2.2"></A>
<H5 class="docSection3Title">5.3.2.2 Mappings</H5>

<P class="docText"><A NAME="pythonian-CHP-5-ITERM-4414"></A>A mapping's item access
special methods should raise <TT>KeyError</TT>, rather than
<TT>IndexError</TT>, when they receive an invalid
<TT><I>key</I></TT> argument value of a valid type. A
mapping should define the non-special methods covered in <A class="docLink" HREF="0596001886_pythonian-chp-4-sect-7.html#pythonian-CHP-4-SECT-7.3">Section 4.7.3</A>: <TT>copy</TT>,
<TT>get</TT>, <TT>has_key</TT>,
<TT>items</TT>, <TT>keys</TT>,
<TT>values</TT>, <TT>iteritems</TT>,
<TT>iterkeys</TT>, and <TT>itervalues</TT>.
Special method <TT>_ _iter_ _</TT> should be equivalent to
<TT>iterkeys</TT>. A mutable mapping should also define
methods <TT>clear</TT>, <TT>popitem</TT>,
<TT>setdefault</TT>, and <TT>update</TT>.</P>



<A NAME="pythonian-CHP-5-SECT-3.2.3"></A>
<H5 class="docSection3Title">5.3.2.3 Sets</H5>

<P class="docText"><A NAME="pythonian-CHP-5-ITERM-4415"></A>Sets, scheduled to be introduced in Python
2.3, can be seen as rather peculiar kinds of
containers—containers that are neither sequences nor mappings,
and cannot be indexed, but do have a length (number of elements) and
are iterable. Unfortunately, the interface of sets (and even the
final decision about introducing them in Python 2.3) is still not
stable as of this writing. Therefore, I do not consider sets in this
book.</P>



<A NAME="pythonian-CHP-5-SECT-3.2.4"></A>
<H5 class="docSection3Title">5.3.2.4 Container slicing</H5>

<P class="docText"><A NAME="pythonian-CHP-5-ITERM-4416"></A>
<A NAME="pythonian-CHP-5-ITERM-4417"></A>When you
reference, bind, or unbind a slicing such as
<TT><I>x</I></TT><TT>[</TT><TT><I>i</I></TT>:<TT><I>j</I></TT><TT>]</TT>
or
<TT><I>x</I></TT><TT>[</TT><TT><I>i</I></TT>:<TT><I>j</I></TT>:<TT><I>k</I></TT><TT>]</TT>
on a container <TT><I>x</I></TT>, Python calls
<TT><I>x</I></TT>'s applicable item
access special method, passing as <TT><I>key</I></TT> an
object of a built-in type called a <I>slice object</I>.
A slice object has attributes <TT>start</TT>,
<TT>stop</TT>, and <TT>step</TT>. Each attribute
is <TT>None</TT> if the corresponding value is omitted in
the slice syntax. For example, <TT>del</TT>
<TT><I>x</I></TT><TT>[:3]</TT> calls
<TT><I>x</I></TT><TT>._ _delitem_
_(</TT><TT><I>y</I></TT><TT>)</TT>, and
<TT><I>y</I></TT> is a slice object such that
<TT><I>y</I></TT><TT>.stop</TT> is
<TT>3</TT>,
<TT><I>y</I></TT><TT>.start</TT> is
<TT>None</TT>, and
<TT><I>y</I></TT><TT>.step</TT> is
<TT>None</TT>. It is up to container object
<TT><I>x</I></TT> to appropriately interpret the slice
object argument passed to
<TT><I>x</I></TT>'s special methods.</P>

<P class="docText">Some built-in types, such as <TT>list</TT> and
<TT>tuple</TT>, define now-deprecated special methods
<TT>_ _getslice_ _</TT>, <TT>_ _setslice_ _</TT>,
and <TT>_ _delslice_ _</TT>. For an instance
<TT><I>x</I></TT> of such a type, slicing
<TT><I>x</I></TT> with only one colon, as in
<TT><I>x</I></TT><TT>[</TT><TT><I>i</I></TT>:<TT><I>j</I></TT><TT>]</TT>,
calls a slice-specific special method. Slicing
<TT><I>x</I></TT> with two colons, as in
<TT><I>x</I></TT><TT>[</TT><TT><I>i</I></TT>:<TT><I>j</I></TT>:<TT><I>k</I></TT><TT>]</TT>,
calls an item access special method with a slice object argument. For
example:</P>

<PRE>class C:
    def _ _getslice_ _(self, i, j): print 'getslice', i, j
    def _ _getitem_ _(self, index): print 'getitem', index
x = C(  )
x[12:34]
x[56:78:9]</PRE>

<P class="docText">The first slicing calls <TT><I>x</I></TT><TT>._
_getslice_ _(12,34)</TT>, and the second calls
<TT><I>x</I></TT><TT>._ _getitem_
_(slice(56,78,9))</TT>. It's best to avoid
defining the slice-specific special methods in your classes, but you
may need to override them if your class subclasses
<TT>list</TT> or <TT>tuple</TT> and you want to
provide special functionality when an instance of your class is
sliced. Note that built-in sequences do not yet support slicing with
two colons up to Python 2.2: this functionality is scheduled to be
introduced in Python 2.3.</P>



<A NAME="pythonian-CHP-5-SECT-3.2.5"></A>
<H5 class="docSection3Title">5.3.2.5 Container methods</H5>

<P class="docText">Special methods <TT>_ _getitem_ _</TT>, <TT>_
_setitem_ _</TT>, <TT>_ _delitem_ _</TT>, <TT>_
_iter_ _</TT>, <TT>_ _len_ _</TT>, and <TT>_
_contains_ _</TT> expose container functionality.</P>


<A NAME="ch05-77065"></A><A NAME="pythonian-CHP-5-ITERM-4418"></A><A NAME="pythonian-CHP-5-ITERM-4419"></A><table width="515" border="0" cellpadding="5">
<tr>
<td align="left"><b><i>_ _contains_ _
</i></b></td>
<td align="right"></td>
</tr>
</table>
<hr width="515" size="3" noshade="true" align="left" color="black">
<table width="515" border="0" cellpadding="5">
<tr>
<td align="left">
<pre>_ _contains_ _(self,<TT><I>item</I></TT>)</pre>
</td>
<td align="right"></td>
</tr>
</table>
<P class="docText">The Boolean test <TT><I>y</I></TT> <TT>in</TT>
<TT><I>x</I></TT> calls
<TT><I>x</I></TT><TT>._ _contains_
_(</TT><TT><I>y</I></TT><TT>)</TT>. When
<TT><I>x</I></TT> is a sequence, <TT>_ _contains_
_</TT> should return <TT>True</TT> when
<TT><I>y</I></TT> equals the value of an item in the
sequence. When <TT><I>x</I></TT> is a mapping, <TT>_
_contains_ _</TT> should return <TT>True</TT> when
<TT><I>y</I></TT> equals the value of a key in the
mapping. Otherwise, <TT>_ _contains_ _</TT> should return
<TT>False</TT>. If <TT>_ _contains_ _</TT> is
absent, Python performs <TT><I>y</I></TT>
<TT>in</TT> <TT><I>x</I></TT> as follows, taking
time proportional to
<TT>len(</TT><TT><I>x</I></TT><TT>)</TT>:</P>
<PRE>for <TT><I>z</I></TT> in <TT><I>x</I></TT>:
    if <TT><I>y</I></TT>=  =<TT><I>z</I></TT>: return True
return False</PRE>

<A NAME="ch05-77066"></A><A NAME="pythonian-CHP-5-ITERM-4420"></A><A NAME="pythonian-CHP-5-ITERM-4421"></A><table width="515" border="0" cellpadding="5">
<tr>
<td align="left"><b><i>_ _delitem_ _
</i></b></td>
<td align="right"></td>
</tr>
</table>
<hr width="515" size="3" noshade="true" align="left" color="black">
<table width="515" border="0" cellpadding="5">
<tr>
<td align="left">
<pre>_ _delitem_ _(self,<TT><I>key</I></TT>)</pre>
</td>
<td align="right"></td>
</tr>
</table>
<P class="docText">For a request to unbind an item or slice of
<TT><I>x</I></TT> (typically <TT>del</TT>
<TT><I>x</I></TT><TT>[</TT><TT><I>key</I></TT><TT>]</TT>),
Python will call <TT><I>x</I></TT><TT>._ _delitem_
_(</TT><TT><I>key</I></TT><TT>)</TT>. A
container <TT><I>x</I></TT> should have <TT>_
_delitem_ _</TT> only if <TT><I>x</I></TT> is
mutable, so that items (and possibly slices) can be removed.</P>

<A NAME="ch05-77067"></A><A NAME="pythonian-CHP-5-ITERM-4422"></A><A NAME="pythonian-CHP-5-ITERM-4423"></A><table width="515" border="0" cellpadding="5">
<tr>
<td align="left"><b><i>_ _getitem_ _
</i></b></td>
<td align="right"></td>
</tr>
</table>
<hr width="515" size="3" noshade="true" align="left" color="black">
<table width="515" border="0" cellpadding="5">
<tr>
<td align="left">
<pre>_ _getitem_ _(self,<TT><I>key</I></TT>)</pre>
</td>
<td align="right"></td>
</tr>
</table>
<P class="docText">When
<TT><I>x</I></TT><TT>[</TT><TT><I>key</I></TT><TT>]</TT>
is accessed (i.e., when container <TT><I>x</I></TT> is
indexed or sliced), Python calls
<TT><I>x</I></TT><TT>._ _getitem_
_(</TT><TT><I>key</I></TT><TT>)</TT>. All
containers should have <TT>_ _getitem_ _</TT>.</P>

<A NAME="ch05-77068"></A><A NAME="pythonian-CHP-5-ITERM-4424"></A><A NAME="pythonian-CHP-5-ITERM-4425"></A><table width="515" border="0" cellpadding="5">
<tr>
<td align="left"><b><i>_ _iter_ _
</i></b></td>
<td align="right"></td>
</tr>
</table>
<hr width="515" size="3" noshade="true" align="left" color="black">
<table width="515" border="0" cellpadding="5">
<tr>
<td align="left">
<pre>_ _iter_ _(self)</pre>
</td>
<td align="right"></td>
</tr>
</table>
<P class="docText">For a request to loop on all items of <TT><I>x</I></TT>
(typically <TT>for</TT> <TT><I>item</I></TT>
<TT>in</TT> <TT><I>x</I></TT>), Python calls
<TT><I>x</I></TT><TT>._ _iter_ _( )</TT> to
obtain an iterator on <TT><I>x</I></TT>. The built-in
function
<TT>iter(</TT><TT><I>x</I></TT><TT>)</TT>
also calls <TT><I>x</I></TT><TT>._ _iter_ _(
)</TT>. If <TT>_ _iter_ _</TT> is absent and
<TT><I>x</I></TT> is a sequence,
<TT>iter(</TT><TT><I>x</I></TT><TT>)</TT>
synthesizes and returns an iterator object that wraps
<TT><I>x</I></TT> and returns
<TT><I>x</I></TT><TT>[0]</TT>,
<TT><I>x</I></TT><TT>[1]</TT>, and so on, until
one of these item accesses raises <TT>IndexError</TT> to
indicate the end of the sequence.</P>

<A NAME="ch05-77069"></A><A NAME="pythonian-CHP-5-ITERM-4426"></A><A NAME="pythonian-CHP-5-ITERM-4427"></A><table width="515" border="0" cellpadding="5">
<tr>
<td align="left"><b><i>_ _len_ _
</i></b></td>
<td align="right"></td>
</tr>
</table>
<hr width="515" size="3" noshade="true" align="left" color="black">
<table width="515" border="0" cellpadding="5">
<tr>
<td align="left">
<pre>_ _len_ _(self)</pre>
</td>
<td align="right"></td>
</tr>
</table>
<P class="docText">The
<TT>len(</TT><TT><I>x</I></TT><TT>)</TT>
built-in function call, and other built-in functions that need to
know how many items are in container <TT><I>x</I></TT>,
call <TT><I>x</I></TT><TT>._ _len_ _( )</TT>.
<TT>_ _len_ _</TT> should return an <TT>int</TT>,
the number of items in <TT><I>x</I></TT>. Python also
calls <TT><I>x</I></TT><TT>._ _len_ _( )</TT> to
evaluate <TT><I>x</I></TT> in a Boolean context, if
<TT>_ _nonzero_ _</TT> is absent. Absent <TT>_
_nonzero_ _</TT>, a container is taken as false if and only if
the container is empty (i.e., the container's length
is <TT>0</TT>).</P>

<A NAME="ch05-77070"></A><A NAME="pythonian-CHP-5-ITERM-4428"></A><A NAME="pythonian-CHP-5-ITERM-4429"></A><A NAME="pythonian-CHP-5-ITERM-4430"></A><A NAME="pythonian-CHP-5-ITERM-4431"></A><table width="515" border="0" cellpadding="5">
<tr>
<td align="left"><b><i>_ _setitem_ _
</i></b></td>
<td align="right"></td>
</tr>
</table>
<hr width="515" size="3" noshade="true" align="left" color="black">
<table width="515" border="0" cellpadding="5">
<tr>
<td align="left">
<pre>_ _setitem_ _(self,<TT><I>key</I></TT>,<TT><I>value</I></TT>)</pre>
</td>
<td align="right"></td>
</tr>
</table>
<P class="docText">For a request to bind an item or slice of
<TT><I>x</I></TT> (typically an assignment
<TT><I>x</I></TT><TT>[</TT><TT><I>key</I></TT><TT>]=</TT><TT><I>value</I></TT>),
Python calls <TT><I>x</I></TT><TT>._ _setitem_
_(</TT><TT><I>key</I></TT>,<TT><I>value</I></TT><TT>)</TT>.
A container <TT><I>x</I></TT> should have <TT>_
_setitem_ _</TT> only if <TT><I>x</I></TT> is
mutable, so that items, and possibly slices, can be added and/or
rebound.<A NAME="pythonian-CHP-5-ITERM-4430"></A>
<A NAME="pythonian-CHP-5-ITERM-4431"></A></P>



<A NAME="pythonian-CHP-5-SECT-3.3"></A>
<H4 class="docSection2Title">5.3.3 Special Methods for Numeric Objects</H4>

<P class="docText"><A NAME="pythonian-CHP-5-ITERM-4432"></A>
<A NAME="pythonian-CHP-5-ITERM-4433"></A>
<A NAME="pythonian-CHP-5-ITERM-4434"></A>An instance may support numeric operations
by means of many special methods. Some classes that are not numbers
also support some of the following special methods, in order to
overload operators such as <TT>+</TT> and
<TT>*</TT>. For example, sequences should have special
methods <TT>_ _add_ _</TT>, <TT>_ _mul_ _</TT>,
<TT>_ _radd_ _</TT>, and <TT>_ _rmul_ _</TT>, as
mentioned earlier in this chapter.</P>


<A NAME="ch05-77072"></A><A NAME="pythonian-CHP-5-ITERM-4435"></A><A NAME="pythonian-CHP-5-ITERM-4436"></A><A NAME="pythonian-CHP-5-ITERM-4437"></A><A NAME="pythonian-CHP-5-ITERM-4438"></A><A NAME="pythonian-CHP-5-ITERM-4439"></A><A NAME="pythonian-CHP-5-ITERM-4440"></A><A NAME="pythonian-CHP-5-ITERM-4441"></A><A NAME="pythonian-CHP-5-ITERM-4442"></A><table width="515" border="0" cellpadding="5">
<tr>
<td align="left"><b><i>_ _abs_ _, _ _invert_ _, _ _neg_ _, _ _pos_ _</i></b></td>
<td align="right"></td>
</tr>
</table>
<hr width="515" size="3" noshade="true" align="left" color="black">
<table width="515" border="0" cellpadding="5">
<tr>
<td align="left">
<pre>_ _abs_ _(self)
_ _invert_ _(self)
_ _neg_ _(self)
_ _pos_ _(self)</pre>
</td>
<td align="right"></td>
</tr>
</table>
<P class="docText">Unary operators
<TT>abs(</TT><TT><I>x</I></TT><TT>)</TT>,
<TT>~</TT><TT><I>x</I></TT>,
<TT>-</TT><TT><I>x</I></TT>, and
<TT>+</TT><TT><I>x</I></TT>, respectively, call
these methods.</P>

<A NAME="ch05-77073"></A><A NAME="pythonian-CHP-5-ITERM-4443"></A><A NAME="pythonian-CHP-5-ITERM-4444"></A><A NAME="pythonian-CHP-5-ITERM-4445"></A><A NAME="pythonian-CHP-5-ITERM-4446"></A><A NAME="pythonian-CHP-5-ITERM-4447"></A><A NAME="pythonian-CHP-5-ITERM-4448"></A><A NAME="pythonian-CHP-5-ITERM-4449"></A><A NAME="pythonian-CHP-5-ITERM-4450"></A><A NAME="pythonian-CHP-5-ITERM-4451"></A><A NAME="pythonian-CHP-5-ITERM-4452"></A><A NAME="pythonian-CHP-5-ITERM-4453"></A><A NAME="pythonian-CHP-5-ITERM-4454"></A><table width="515" border="0" cellpadding="5">
<tr>
<td align="left"><b><i>_ _add_ _, _ _div_ _, _ _floordiv_ _, _ _mod_ _, _ _mul_ _, _ _sub_ _,_ _truediv_ _</i></b></td>
<td align="right"></td>
</tr>
</table>
<hr width="515" size="3" noshade="true" align="left" color="black">
<table width="515" border="0" cellpadding="5">
<tr>
<td align="left">
<pre>_ _add_ _(self,<TT><I>other</I></TT>)
_ _div_ _(self,<TT><I>other</I></TT>)
_ _floordiv_ _(self,<TT><I>other</I></TT>)
_ _mod_ _(self,<TT><I>other</I></TT>)
_ _mul_ _(self,<TT><I>other</I></TT>)
_ _sub_ _(self,<TT><I>other</I></TT>)
_ _truediv_ _(self,<TT><I>other)</I></TT></pre>
</td>
<td align="right"></td>
</tr>
</table>
<P class="docText">Operators
<TT><I>x</I></TT><TT>+</TT><TT><I>y</I></TT>,
<TT><I>x</I></TT><TT>/</TT><TT><I>y</I></TT>,
<TT><I>x</I></TT><TT>//</TT><TT><I>y</I></TT>,
<TT><I>x</I></TT><TT>%</TT><TT><I>y</I></TT>,
<TT><I>x</I></TT><TT>*</TT><TT><I>y</I></TT>,
<TT><I>x</I></TT><TT>-</TT><TT><I>y</I></TT>,
and <TT><I>x</I></TT>/<TT><I>y</I></TT>,
respectively, call these methods. The operator <TT>/</TT>
calls <TT>_ _truediv_ _</TT>, if present, instead of
<TT>_ _div_ _</TT>, in the situations where division is
non-truncating, as covered in <A class="docLink" HREF="0596001886_pythonian-chp-4-sect-5.html#pythonian-CHP-4-SECT-5.2">Section 4.5.2</A>.</P>

<A NAME="ch05-77074"></A><A NAME="pythonian-CHP-5-ITERM-4455"></A><A NAME="pythonian-CHP-5-ITERM-4456"></A><A NAME="pythonian-CHP-5-ITERM-4457"></A><A NAME="pythonian-CHP-5-ITERM-4458"></A><A NAME="pythonian-CHP-5-ITERM-4459"></A><A NAME="pythonian-CHP-5-ITERM-4460"></A><A NAME="pythonian-CHP-5-ITERM-4461"></A><A NAME="pythonian-CHP-5-ITERM-4462"></A><A NAME="pythonian-CHP-5-ITERM-4463"></A><A NAME="pythonian-CHP-5-ITERM-4464"></A><table width="515" border="0" cellpadding="5">
<tr>
<td align="left"><b><i>_ _and_ _, _ _lshift_ _, _ _or_ _, _ _rshift_ _, _ _xor_ _</i></b></td>
<td align="right"></td>
</tr>
</table>
<hr width="515" size="3" noshade="true" align="left" color="black">
<table width="515" border="0" cellpadding="5">
<tr>
<td align="left">
<pre>_ _and_ _(self,<TT><I>other</I></TT>)
_ _lshift_ _(self,<TT><I>other</I></TT>)
_ _or_ _(self,<TT><I>other</I></TT>)
_ _rshift_ _(self,<TT><I>other</I></TT>)
_ _xor_ _(self,<TT><I>other</I></TT>)</pre>
</td>
<td align="right"></td>
</tr>
</table>
<P class="docText">Operators
<TT><I>x</I></TT><TT>&amp;</TT><TT><I>y</I></TT>,
<TT><I>x</I></TT><TT>&lt;&lt;</TT><TT><I>y</I></TT>,
<TT><I>x</I></TT><TT>|</TT><TT><I>y</I></TT>,
<TT><I>x</I></TT><TT>&gt;&gt;</TT><TT><I>y</I></TT>,
and
<TT><I>x</I></TT><TT>^</TT><TT><I>y</I></TT>,
respectively, call these methods.</P>

<A NAME="ch05-77075"></A><A NAME="pythonian-CHP-5-ITERM-4465"></A><A NAME="pythonian-CHP-5-ITERM-4466"></A><table width="515" border="0" cellpadding="5">
<tr>
<td align="left"><b><i>_ _coerce_ _


</i></b></td>
<td align="right"></td>
</tr>
</table>
<hr width="515" size="3" noshade="true" align="left" color="black">
<table width="515" border="0" cellpadding="5">
<tr>
<td align="left">
<pre>_ _coerce_ _(self,<TT><I>other</I></TT>)</pre>
</td>
<td align="right"></td>
</tr>
</table>
<P class="docText">For any numeric operation with two operands
<TT><I>x</I></TT> and <TT><I>y</I></TT>, Python
invokes <TT><I>x</I></TT><TT>._ _coerce_
_(</TT><TT><I>y</I></TT><TT>)</TT>.
<TT>_ _coerce_ _</TT> should return a pair with
<TT><I>x</I></TT> and <TT><I>y</I></TT>
converted to acceptable types. <TT>_ _coerce_ _</TT>
returns <TT>None</TT> when it cannot perform the
conversion. In such cases, Python will call
<TT><I>y</I></TT><TT>._ _coerce_
_(</TT><TT><I>x</I></TT><TT>)</TT>. This
special method is now deprecated: new Python classes should not
implement it, but instead deal with whatever types they can accept
directly in the special methods of the relevant numeric operations.
However, if a class does supply <TT>_ _coerce_ _</TT>,
Python still calls it for backward compatibility.</P>

<A NAME="ch05-77076"></A><A NAME="pythonian-CHP-5-ITERM-4467"></A><A NAME="pythonian-CHP-5-ITERM-4468"></A><A NAME="pythonian-CHP-5-ITERM-4469"></A><A NAME="pythonian-CHP-5-ITERM-4470"></A><A NAME="pythonian-CHP-5-ITERM-4471"></A><A NAME="pythonian-CHP-5-ITERM-4472"></A><A NAME="pythonian-CHP-5-ITERM-4473"></A><A NAME="pythonian-CHP-5-ITERM-4474"></A><table width="515" border="0" cellpadding="5">
<tr>
<td align="left"><b><i>_ _complex_ _, _ _float_ _, _ _int_ _, _ _long_ _</i></b></td>
<td align="right"></td>
</tr>
</table>
<hr width="515" size="3" noshade="true" align="left" color="black">
<table width="515" border="0" cellpadding="5">
<tr>
<td align="left">
<pre>_ _complex_ _(self)
_ _float_ _(self)
_ _int_ _(self)
_ _long_ _(self)</pre>
</td>
<td align="right"></td>
</tr>
</table>
<P class="docText">Built-in types
<TT>complex(</TT><TT><I>x</I></TT><TT>)</TT>,
<TT>float(</TT><TT><I>x</I></TT><TT>)</TT>,
<TT>int(</TT><TT><I>x</I></TT><TT>)</TT>,
and
<TT>long(</TT><TT><I>x</I></TT><TT>)</TT>,
respectively, call these methods.</P>

<A NAME="ch05-77077"></A><A NAME="pythonian-CHP-5-ITERM-4475"></A><A NAME="pythonian-CHP-5-ITERM-4476"></A><table width="515" border="0" cellpadding="5">
<tr>
<td align="left"><b><i>_ _divmod_ _


</i></b></td>
<td align="right"></td>
</tr>
</table>
<hr width="515" size="3" noshade="true" align="left" color="black">
<table width="515" border="0" cellpadding="5">
<tr>
<td align="left">
<pre>_ _divmod_ _(self,<TT><I>other</I></TT>)</pre>
</td>
<td align="right"></td>
</tr>
</table>
<P class="docText">Built-in function
<TT>divmod(</TT><TT><I>x</I></TT>,<TT><I>y</I></TT><TT>)</TT>
calls <TT><I>x</I></TT><TT>._ _divmod_
_(</TT><TT><I>y</I></TT><TT>)</TT>.
<TT>_ _divmod_ _</TT> should return a pair
<TT>(</TT><TT><I>quotient</I></TT>,<TT><I>remainder</I></TT><TT>)</TT>
equal to
<TT>(</TT><TT><I>x</I></TT><TT>//</TT><TT><I>y</I></TT>,<TT><I>x</I></TT><TT>%</TT><TT><I>y</I></TT><TT>)</TT>.</P>

<A NAME="ch05-77078"></A><A NAME="pythonian-CHP-5-ITERM-4477"></A><A NAME="pythonian-CHP-5-ITERM-4478"></A><A NAME="pythonian-CHP-5-ITERM-4479"></A><A NAME="pythonian-CHP-5-ITERM-4480"></A><table width="515" border="0" cellpadding="5">
<tr>
<td align="left"><b><i>_ _hex_ _, _ _oct_ _</i></b></td>
<td align="right"></td>
</tr>
</table>
<hr width="515" size="3" noshade="true" align="left" color="black">
<table width="515" border="0" cellpadding="5">
<tr>
<td align="left">
<pre>_ _hex_ _(self)
_ _oct_ _(self)</pre>
</td>
<td align="right"></td>
</tr>
</table>
<P class="docText">Built-in function
<TT>hex(</TT><TT><I>x</I></TT><TT>)</TT>
calls <TT><I>x</I></TT><TT>._ _hex_ _( )</TT>.
Built-in function
<TT>oct(</TT><TT><I>x</I></TT><TT>)</TT>
calls <TT><I>x</I></TT><TT>._ _oct_ _( )</TT>.
Each of these special methods should return a string representing the
value of <TT><I>x</I></TT>, in base 16 and 8 respectively.</P>

<A NAME="ch05-77079"></A><A NAME="pythonian-CHP-5-ITERM-4481"></A><A NAME="pythonian-CHP-5-ITERM-4482"></A><A NAME="pythonian-CHP-5-ITERM-4483"></A><A NAME="pythonian-CHP-5-ITERM-4484"></A><A NAME="pythonian-CHP-5-ITERM-4485"></A><A NAME="pythonian-CHP-5-ITERM-4486"></A><A NAME="pythonian-CHP-5-ITERM-4487"></A><A NAME="pythonian-CHP-5-ITERM-4488"></A><A NAME="pythonian-CHP-5-ITERM-4489"></A><A NAME="pythonian-CHP-5-ITERM-4490"></A><A NAME="pythonian-CHP-5-ITERM-4491"></A><A NAME="pythonian-CHP-5-ITERM-4492"></A><A NAME="pythonian-CHP-5-ITERM-4493"></A><A NAME="pythonian-CHP-5-ITERM-4494"></A><table width="515" border="0" cellpadding="5">
<tr>
<td align="left"><b><i>_ _iadd_ _, _ _idiv_ _, _ _ifloordiv_ _, _ _imod_ _, _ _imul_ _, _ _isub_ _, _ _itruediv_ _</i></b></td>
<td align="right"></td>
</tr>
</table>
<hr width="515" size="3" noshade="true" align="left" color="black">
<table width="515" border="0" cellpadding="5">
<tr>
<td align="left">
<pre>_ _iadd_ _(self,<TT><I>other</I></TT>)
_ _idiv_ _(self,<TT><I>other</I></TT>)
_ _ifloordiv_ _(self,<TT><I>other</I></TT>)
_ _imod_ _(self,<TT><I>other</I></TT>)
_ _imul_ _(self,<TT><I>other</I></TT>)
_ _isub_ _(self,<TT><I>other</I></TT>)
_ _itruediv_ _(self,<TT><I>other</I></TT>)</pre>
</td>
<td align="right"></td>
</tr>
</table>
<P class="docText">The augmented assignments
<TT><I>x</I></TT><TT>+=</TT><TT><I>y</I></TT>,
<TT><I>x</I></TT><TT>/=</TT><TT><I>y</I></TT>,
<TT><I>x</I></TT><TT>//=</TT><TT><I>y</I></TT>,
<TT><I>x</I></TT><TT>%=</TT><TT><I>y</I></TT>,
<TT><I>x</I></TT><TT>*=</TT><TT><I>y</I></TT>,
<TT><I>x</I></TT><TT>-=</TT><TT><I>y</I></TT>,
and
<TT><I>x</I></TT><TT>/=</TT><TT><I>y</I></TT>,
respectively, call these methods. Each method should modify
<TT><I>x</I></TT> in-place and return
<TT>self</TT>. Define these methods when
<TT><I>x</I></TT> is<I> </I>mutable (i.e.,
when <TT><I>x</I></TT> can change in-place).</P>

<A NAME="ch05-77080"></A><A NAME="pythonian-CHP-5-ITERM-4495"></A><A NAME="pythonian-CHP-5-ITERM-4496"></A><A NAME="pythonian-CHP-5-ITERM-4497"></A><A NAME="pythonian-CHP-5-ITERM-4498"></A><A NAME="pythonian-CHP-5-ITERM-4499"></A><A NAME="pythonian-CHP-5-ITERM-4500"></A><A NAME="pythonian-CHP-5-ITERM-4501"></A><A NAME="pythonian-CHP-5-ITERM-4502"></A><A NAME="pythonian-CHP-5-ITERM-4503"></A><A NAME="pythonian-CHP-5-ITERM-4504"></A><table width="515" border="0" cellpadding="5">
<tr>
<td align="left"><b><i>_ _iand_ _, _ _ilshift_ _, _ _ior_ _, _ _irshift_ _, _ _ixor_ _</i></b></td>
<td align="right"></td>
</tr>
</table>
<hr width="515" size="3" noshade="true" align="left" color="black">
<table width="515" border="0" cellpadding="5">
<tr>
<td align="left">
<pre>_ _iand_ _(self,<TT><I>other</I></TT>)
_ _ilshift_ _(self,<TT><I>other</I></TT>)
_ _ior_ _(self,<TT><I>other</I></TT>)
_ _irshift_ _(self,<TT><I>other</I></TT>)
_ _ixor_ _(self,<TT><I>other</I></TT>)</pre>
</td>
<td align="right"></td>
</tr>
</table>
<P class="docText">Augmented assignments
<TT><I>x</I></TT><TT>&amp;=</TT><TT><I>y</I></TT>,
<TT><I>x</I></TT><TT>&lt;&lt;=</TT><TT><I>y</I></TT>,
<TT><I>x</I></TT><TT>|=</TT><TT><I>y</I></TT>,
<TT><I>x</I></TT><TT>&gt;&gt;=</TT><TT><I>y</I></TT>,
and
<TT><I>x</I></TT><TT>^=</TT><TT><I>y</I></TT>,
respectively, call these methods. Each method should modify
<TT><I>x</I></TT> in-place and return
<TT>self</TT>.</P>

<A NAME="ch05-77081"></A><A NAME="pythonian-CHP-5-ITERM-4505"></A><A NAME="pythonian-CHP-5-ITERM-4506"></A><table width="515" border="0" cellpadding="5">
<tr>
<td align="left"><b><i>_ _ipow_ _</i></b></td>
<td align="right"></td>
</tr>
</table>
<hr width="515" size="3" noshade="true" align="left" color="black">
<table width="515" border="0" cellpadding="5">
<tr>
<td align="left">
<pre>_ _ipow_ _(self,<TT><I>other</I></TT>)</pre>
</td>
<td align="right"></td>
</tr>
</table>
<P class="docText">Augmented assignment
<TT><I>x</I></TT><TT>**=</TT><TT><I>y</I></TT>
calls <TT><I>x</I></TT><TT>._ _ipow_
_(</TT><TT><I>y</I></TT><TT>)</TT>.
<TT>_ _ipow_ _</TT> should modify
<TT><I>x</I></TT> in-place and return
<TT>self</TT>.</P>

<A NAME="ch05-77082"></A><A NAME="pythonian-CHP-5-ITERM-4507"></A><A NAME="pythonian-CHP-5-ITERM-4508"></A><table width="515" border="0" cellpadding="5">
<tr>
<td align="left"><b><i>_ _pow_ _


</i></b></td>
<td align="right"></td>
</tr>
</table>
<hr width="515" size="3" noshade="true" align="left" color="black">
<table width="515" border="0" cellpadding="5">
<tr>
<td align="left">
<pre>_ _pow_ _(self,<TT><I>other</I></TT>[,<TT><I>modulo</I></TT>])</pre>
</td>
<td align="right"></td>
</tr>
</table>
<P class="docText"><TT><I>x</I></TT><TT>**</TT><TT><I>y</I></TT>
and
<TT>pow(</TT><TT><I>x</I></TT>,<TT><I>y</I></TT><TT>)</TT>
both call <TT><I>x</I></TT><TT>._ _pow_
_(</TT><TT><I>y</I></TT><TT>)</TT>, while
<TT>pow(</TT><TT><I>x</I></TT>,<TT><I>y</I></TT>,<TT><I>z</I></TT><TT>)</TT>
calls <TT><I>x</I></TT><TT>._ _pow_
_(</TT><TT><I>y</I></TT>,<TT><I>z</I></TT><TT>)</TT>.
<TT><I>x</I></TT><TT>._ _pow_
_(</TT><TT><I>y</I></TT>,<TT><I>z</I></TT><TT>)</TT>
should return a value equal to the expression
<TT><I>x</I></TT><TT>._ _pow_
_(</TT><TT><I>y</I></TT><TT>)%</TT><TT><I>z</I></TT>.</P>

<A NAME="ch05-77083"></A><A NAME="pythonian-CHP-5-ITERM-4509"></A><A NAME="pythonian-CHP-5-ITERM-4510"></A><A NAME="pythonian-CHP-5-ITERM-4511"></A><A NAME="pythonian-CHP-5-ITERM-4512"></A><A NAME="pythonian-CHP-5-ITERM-4513"></A><A NAME="pythonian-CHP-5-ITERM-4514"></A><A NAME="pythonian-CHP-5-ITERM-4515"></A><A NAME="pythonian-CHP-5-ITERM-4516"></A><A NAME="pythonian-CHP-5-ITERM-4517"></A><A NAME="pythonian-CHP-5-ITERM-4518"></A><table width="515" border="0" cellpadding="5">
<tr>
<td align="left"><b><i>_ _radd_ _, _ _rdiv_ _, _ _rmod_ _, _ _rmul_ _, _ _rsub_ _</i></b></td>
<td align="right"></td>
</tr>
</table>
<hr width="515" size="3" noshade="true" align="left" color="black">
<table width="515" border="0" cellpadding="5">
<tr>
<td align="left">
<pre>_ _radd_ _(self,<TT><I>other</I></TT>)
_ _rdiv_ _(self,<TT><I>other</I></TT>)
_ _rmod_ _(self,<TT><I>other</I></TT>)
_ _rmul_ _(self,<TT><I>other</I></TT>)
_ _rsub_ _(self,<TT><I>other</I></TT>)</pre>
</td>
<td align="right"></td>
</tr>
</table>
<P class="docText">Operators
<TT><I>y</I></TT><TT>+</TT><TT><I>x</I></TT>,
<TT><I>y</I></TT><TT>/</TT><TT><I>x</I></TT>,
<TT><I>y</I></TT><TT>%</TT><TT><I>x</I></TT>,
<TT><I>y</I></TT><TT>*</TT><TT><I>x</I></TT>,
and
<TT><I>y</I></TT><TT>-</TT><TT><I>x</I></TT>,
respectively, call these methods when <TT><I>y</I></TT>
doesn't have a needed method <TT>_ _add_
_</TT>, <TT>_ _div_ _</TT>, and so on.</P>

<A NAME="ch05-77084"></A><A NAME="pythonian-CHP-5-ITERM-4519"></A><A NAME="pythonian-CHP-5-ITERM-4520"></A><A NAME="pythonian-CHP-5-ITERM-4521"></A><A NAME="pythonian-CHP-5-ITERM-4522"></A><A NAME="pythonian-CHP-5-ITERM-4523"></A><A NAME="pythonian-CHP-5-ITERM-4524"></A><A NAME="pythonian-CHP-5-ITERM-4525"></A><A NAME="pythonian-CHP-5-ITERM-4526"></A><A NAME="pythonian-CHP-5-ITERM-4527"></A><A NAME="pythonian-CHP-5-ITERM-4528"></A><table width="515" border="0" cellpadding="5">
<tr>
<td align="left"><b><i>_ _rand_ _, _ _rlshift_ _, _ _ror_ _, _ _rrshift_ _, _ _rxor_ _</i></b></td>
<td align="right"></td>
</tr>
</table>
<hr width="515" size="3" noshade="true" align="left" color="black">
<table width="515" border="0" cellpadding="5">
<tr>
<td align="left">
<pre>_ _rand_ _(self,<TT><I>other</I></TT>)
_ _rlshift_ _(self,<TT><I>other</I></TT>)
_ _ror_ _(self,<TT><I>other</I></TT>)
_ _rrshift_ _(self,<TT><I>other</I></TT>)
_ _rxor_ _(self,<TT><I>other</I></TT>)</pre>
</td>
<td align="right"></td>
</tr>
</table>
<P class="docText">Operators
<TT><I>y</I></TT><TT>&amp;</TT><TT><I>x</I></TT>,
<TT><I>y</I></TT><TT>&lt;&lt;</TT><TT><I>x</I></TT>,
<TT><I>y</I></TT><TT>|</TT><TT><I>x</I></TT>,
<TT><I>y</I></TT><TT>&gt;&gt;</TT><TT><I>x</I></TT>,
and
<TT><I>y</I></TT><TT>^</TT><TT><I>x</I></TT>,
respectively, call these methods when <TT><I>y</I></TT>
doesn't have needed method <TT>_ _and_
_</TT>, <TT>_ _lshift_ _</TT>, and so on.</P>

<A NAME="ch05-77085"></A><A NAME="pythonian-CHP-5-ITERM-4529"></A><A NAME="pythonian-CHP-5-ITERM-4530"></A><table width="515" border="0" cellpadding="5">
<tr>
<td align="left"><b><i>_ _rdivmod_ _


</i></b></td>
<td align="right"></td>
</tr>
</table>
<hr width="515" size="3" noshade="true" align="left" color="black">
<table width="515" border="0" cellpadding="5">
<tr>
<td align="left">
<pre>_ _rdivmod_ _(self,<TT><I>other</I></TT>)</pre>
</td>
<td align="right"></td>
</tr>
</table>
<P class="docText">Built-in function
<TT>divmod(</TT><TT><I>y</I></TT>,<TT><I>x</I></TT><TT>)</TT>
calls <TT><I>x</I></TT><TT>._ _rdivmod_
_(</TT><TT><I>y</I></TT><TT>)</TT> when
<TT><I>y</I></TT> doesn't have <TT>_
_divmod_ _</TT>. <TT>_ _rdivmod_ _</TT> should return
a pair
<TT>(</TT><TT><I>remainder</I></TT>,<TT><I>quotient</I></TT><TT>)</TT>.</P>

<A NAME="ch05-77086"></A><A NAME="pythonian-CHP-5-ITERM-4531"></A><A NAME="pythonian-CHP-5-ITERM-4532"></A><A NAME="pythonian-CHP-5-ITERM-4533"></A><A NAME="pythonian-CHP-5-ITERM-4534"></A><A NAME="pythonian-CHP-5-ITERM-4535"></A><A NAME="pythonian-CHP-5-ITERM-4536"></A><A NAME="pythonian-CHP-5-ITERM-4537"></A><table width="515" border="0" cellpadding="5">
<tr>
<td align="left"><b><i>_ _rpow_ _


</i></b></td>
<td align="right"></td>
</tr>
</table>
<hr width="515" size="3" noshade="true" align="left" color="black">
<table width="515" border="0" cellpadding="5">
<tr>
<td align="left">
<pre>_ _rpow_ _(self,<TT><I>other</I></TT>)</pre>
</td>
<td align="right"></td>
</tr>
</table>
<P class="docText"><TT><I>y</I></TT><TT>**</TT><TT><I>x</I></TT>
and
<TT>pow(</TT><TT><I>y</I></TT>,<TT><I>x</I></TT><TT>)</TT>
call <TT><I>x</I></TT><TT>._ _rpow_
_(</TT><TT><I>y</I></TT><TT>)</TT>, when
<TT><I>y</I></TT> doesn't have <TT>_
_pow_ _</TT>. There is no three-argument form in this
case.<A NAME="pythonian-CHP-5-ITERM-4536"></A>
<A NAME="pythonian-CHP-5-ITERM-4537"></A></P>



<ul></ul>
</td>
</tr>
</table>
<td></td>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<td class="tt1"><a href="NFO/lib.html">[ Team LiB ]</a></td><td valign="top" class="tt1" align="right">
          <a href="0596001886_pythonian-chp-5-sect-2.html"><img src="FILES/previous.gif" width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a>
          <a href="0596001886_pythonian-chp-5-sect-4.html"><img src="FILES/next.gif" width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a>
</td></table>
</body></html>
