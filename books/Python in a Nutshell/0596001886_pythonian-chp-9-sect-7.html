<html><head>
<META http-equiv="Content-Type" content="text/html">
<!--SafClassName="docSection1Title"--><!--SafTocEntry="9.7 Regular Expressions and the re Module"-->
<link rel="STYLESHEET" type="text/css" href="FILES/style.css">
<link rel="STYLESHEET" type="text/css" href="FILES/docsafari.css">
<style type="text/css">	.tt1    {font-size: 10pt;}</style>
</head>
<body>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<td class="tt1"><a href="NFO/lib.html">[ Team LiB ]</a></td><td valign="top" class="tt1" align="right">
	<a href="0596001886_pythonian-chp-9-sect-6.html"><img src="FILES/previous.gif" width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a>
	<a href="0596001886_pythonian-part-3.html"><img src="FILES/next.gif" width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a>
</td></table>
<br>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<tr>
<td valign="top"><A NAME="pythonian-CHP-9-SECT-7"></A>
<H3 class="docSection1Title">9.7 Regular Expressions and the re Module</H3>

<P class="docText"><A NAME="pythonian-CHP-9-ITERM-5248"></A>A <span class="docEmphasis">regular</span>
<span class="docEmphasis">expression</span> is a string that represents a
pattern. With regular expression functionality, you can compare that
pattern to another string and see if any part of the string matches
the pattern.</P>

<P class="docText"><A NAME="pythonian-CHP-9-ITERM-5249"></A>
<A NAME="pythonian-CHP-9-ITERM-5250"></A> <A NAME="pythonian-CHP-9-ITERM-5251"></A>The <TT>re</TT> module
supplies all of Python's regular expression
functionality. The <TT>compile</TT> function builds a
regular expression object from a pattern string and optional flags.
The methods of a regular expression object look for matches of the
regular expression in a string and/or perform substitutions. Module
<TT>re</TT> also exposes functions equivalent to a regular
expression's methods, but with the regular
expression's pattern string as their first argument.</P>

<P class="docText">Regular expressions can be difficult to master, and this book does
not purport to teach them—I cover only the ways in which you
can use them in Python. For general coverage of regular expressions,
I recommend the book <span class="docEmphasis">Mastering</span>
<span class="docEmphasis">Regular</span> <span class="docEmphasis">Expressions</span>, by
Jeffrey Friedl (O'Reilly). Friedl's
book offers thorough coverage of regular expressions at both the
tutorial and advanced levels.</P>

<A NAME="pythonian-CHP-9-SECT-7.1"></A>
<H4 class="docSection2Title">9.7.1 Pattern-String Syntax</H4>

<P class="docText"><A NAME="pythonian-CHP-9-ITERM-5252"></A>The pattern string representing a
regular expression follows a specific syntax:</P>

<UL>
<LI><P class="docList">Alphabetic and numeric characters stand for themselves. A regular
expression whose pattern is a string of letters and digits matches
the same string.</P></LI>
<LI><P class="docList">Many alphanumeric characters acquire special meaning in a pattern
when they are preceded by a backslash
(<TT>\</TT>).<A NAME="pythonian-CHP-9-ITERM-5253"></A> <A NAME="pythonian-CHP-9-ITERM-5254"></A></P></LI>
<LI><P class="docList">Punctuation works the other way around. A punctuation character is
self-matching when escaped, and has a special meaning when
unescaped.<A NAME="pythonian-CHP-9-ITERM-5255"></A></P></LI>
<LI><P class="docList">The backslash character itself is matched by a repeated backslash
(i.e., the pattern <TT>\\</TT>).</P></LI>
</UL>
<P class="docText">Since regular expression patterns often contain backslashes, you
generally want to specify them using raw-string syntax (covered in
<A class="docLink" HREF="0596001886_pythonian-chp-4.html#pythonian-CHP-4">Chapter 4</A>). Pattern elements (e.g.,
<TT>r'\t</TT>', which is equivalent to the non-raw string
literal '<TT>\\t</TT>') do match the corresponding special
characters (e.g., the tab character '<TT>\t</TT>').
Therefore, you can use raw-string syntax even when you do need a
literal match for some such special character.</P>

<P class="docText"><A class="docLink" HREF="#pythonian-CHP-9-TABLE-2">Table 9-2</A> lists the special elements in regular
expression pattern syntax. The exact meanings of some pattern
elements change when you use optional flags, together with the
pattern string, to build the regular expression object. The optional
flags are covered later in this chapter.</P>

<A NAME="pythonian-CHP-9-TABLE-2"></A><P><TABLE BORDER="1" CELLSPACING="0" CELLPADDING="1" WIDTH="100%">
<CAPTION><h5 class="docTableTitle">Table 9-2. Regular expression pattern syntax</h5></CAPTION><COLGROUP span="2">
<TR>
<TH class="docTableHeader">
<P class="docText">Element</P>
</TH>
<TH class="docTableHeader">
<P class="docText">Meaning</P>
</TH>
</TR>
<TR>
<TD class="docTableCell">
<A NAME="pythonian-CHP-9-ITERM-5256"></A><A NAME="pythonian-CHP-9-ITERM-5257"></A><PRE>.</PRE>
</TD>
<TD class="docTableCell">
<P class="docText">Matches any character except <TT>\n</TT> (if
<TT>DOTALL</TT>, also matches <TT>\n</TT>)</P>
</TD>
</TR>
<TR>
<TD class="docTableCell">
<A NAME="pythonian-CHP-9-ITERM-5258"></A><A NAME="pythonian-CHP-9-ITERM-5259"></A><PRE>^</PRE>
</TD>
<TD class="docTableCell">
<P class="docText">Matches start of string (if <TT>MULTILINE</TT>, also
matches after <TT>\n</TT>)</P>
</TD>
</TR>
<TR>
<TD class="docTableCell">
<A NAME="pythonian-CHP-9-ITERM-5260"></A><A NAME="pythonian-CHP-9-ITERM-5261"></A><PRE>$</PRE>
</TD>
<TD class="docTableCell">
<P class="docText">Matches end of string (if <TT>MULTILINE</TT>, also matches
before <TT>\n</TT>)</P>
</TD>
</TR>
<TR>
<TD class="docTableCell">
<A NAME="pythonian-CHP-9-ITERM-5262"></A><A NAME="pythonian-CHP-9-ITERM-5263"></A><PRE>*</PRE>
</TD>
<TD class="docTableCell">
<P class="docText">Matches zero or more cases of the previous regular expression; greedy
(match as many as possible)</P>
</TD>
</TR>
<TR>
<TD class="docTableCell">
<A NAME="pythonian-CHP-9-ITERM-5264"></A><A NAME="pythonian-CHP-9-ITERM-5265"></A><PRE>+</PRE>
</TD>
<TD class="docTableCell">
<P class="docText">Matches one or more cases of the previous regular expression; greedy
(match as many as possible)</P>
</TD>
</TR>
<TR>
<TD class="docTableCell">
<A NAME="pythonian-CHP-9-ITERM-5266"></A><A NAME="pythonian-CHP-9-ITERM-5267"></A><PRE>?</PRE>
</TD>
<TD class="docTableCell">
<P class="docText">Matches zero or one case of the previous regular expression; greedy
(match one if possible)</P>
</TD>
</TR>
<TR>
<TD class="docTableCell">
<P class="docText"><TT>*?</TT><A NAME="pythonian-CHP-9-ITERM-5268"></A>
<A NAME="pythonian-CHP-9-ITERM-5269"></A> <A NAME="pythonian-CHP-9-ITERM-5270"></A>
<A NAME="pythonian-CHP-9-ITERM-5271"></A>, <TT>+?</TT>,
<TT>??</TT></P>
</TD>
<TD class="docTableCell">
<P class="docText">Non-greedy versions of <TT>*</TT>, <TT>+</TT>,
and <TT>?</TT> (match as few as possible)</P>
</TD>
</TR>
<TR>
<TD class="docTableCell">
<PRE>{<TT><I>m</I></TT>,<TT><I>n</I></TT>}</PRE>
</TD>
<TD class="docTableCell">
<P class="docText">Matches <TT><I>m</I></TT> to <TT><I>n</I></TT>
cases of the previous regular expression (greedy)</P>
</TD>
</TR>
<TR>
<TD class="docTableCell">
<PRE>{<TT><I>m</I></TT>,<TT><I>n</I></TT>}?</PRE>
</TD>
<TD class="docTableCell">
<P class="docText">Matches <TT><I>m</I></TT> to <TT><I>n</I></TT>
cases of the previous regular expression (non-greedy)</P>
</TD>
</TR>
<TR>
<TD class="docTableCell">
<A NAME="pythonian-CHP-9-ITERM-5272"></A><A NAME="pythonian-CHP-9-ITERM-5273"></A><PRE>[...]</PRE>
</TD>
<TD class="docTableCell">
<P class="docText">Matches any one of a set of characters contained within the brackets</P>
</TD>
</TR>
<TR>
<TD class="docTableCell">
<A NAME="pythonian-CHP-9-ITERM-5274"></A><A NAME="pythonian-CHP-9-ITERM-5275"></A><PRE>|</PRE>
</TD>
<TD class="docTableCell">
<P class="docText">Matches expression either preceding it or following it</P>
</TD>
</TR>
<TR>
<TD class="docTableCell">
<A NAME="pythonian-CHP-9-ITERM-5276"></A><A NAME="pythonian-CHP-9-ITERM-5277"></A><PRE>(...)</PRE>
</TD>
<TD class="docTableCell">
<P class="docText">Matches the regular expression within the parentheses and also
indicates a group</P>
</TD>
</TR>
<TR>
<TD class="docTableCell">
<PRE>(?iLmsux)</PRE>
</TD>
<TD class="docTableCell">
<P class="docText">Alternate way to set optional flags; no effect on match</P>
</TD>
</TR>
<TR>
<TD class="docTableCell">
<PRE>(?:...)</PRE>
</TD>
<TD class="docTableCell">
<P class="docText">Like <TT>(...)</TT>, but does not indicate a group</P>
</TD>
</TR>
<TR>
<TD class="docTableCell">
<PRE>(?P&lt;<TT><I>id</I></TT>&gt;...)</PRE>
</TD>
<TD class="docTableCell">
<P class="docText">Like <TT>(...)</TT>, but the group also gets the name
<TT><I>id</I></TT></P>
</TD>
</TR>
<TR>
<TD class="docTableCell">
<PRE>(?P=<TT><I>id</I></TT>)</PRE>
</TD>
<TD class="docTableCell">
<P class="docText">Matches whatever was previously matched by group named
<TT><I>id</I></TT></P>
</TD>
</TR>
<TR>
<TD class="docTableCell">
<PRE>(?#...)</PRE>
</TD>
<TD class="docTableCell">
<P class="docText">Content of parentheses is just a comment; no effect on match</P>
</TD>
</TR>
<TR>
<TD class="docTableCell">
<PRE>(?=...)</PRE>
</TD>
<TD class="docTableCell">
<P class="docText">Lookahead assertion; matches if regular expression
<TT>..</TT>. matches what comes next, but does not consume
any part of the string</P>
</TD>
</TR>
<TR>
<TD class="docTableCell">
<PRE>(?!...)</PRE>
</TD>
<TD class="docTableCell">
<P class="docText">Negative lookahead assertion; matches if regular expression
<TT>..</TT>. does not match what comes next, and does not
consume any part of the string</P>
</TD>
</TR>
<TR>
<TD class="docTableCell">
<PRE>(?&lt;=...)</PRE>
</TD>
<TD class="docTableCell">
<P class="docText">Lookbehind assertion; matches if there is a match for regular
expression <TT>..</TT>. ending at the current position
(<TT>..</TT>. must match a fixed length)</P>
</TD>
</TR>
<TR>
<TD class="docTableCell">
<PRE>(?&lt;!...)</PRE>
</TD>
<TD class="docTableCell">
<P class="docText">Negative lookbehind assertion; matches if there is no match for
regular expression <TT>..</TT>. ending at the current
position (<TT>..</TT>. must match a fixed length)</P>
</TD>
</TR>
<TR>
<TD class="docTableCell">
<PRE>\<TT><I>number</I></TT></PRE>
</TD>
<TD class="docTableCell">
<P class="docText">Matches whatever was previously matched by group numbered
<TT><I>number</I></TT> (groups are automatically numbered
from 1 up to 99)</P>
</TD>
</TR>
<TR>
<TD class="docTableCell">
<PRE>\A</PRE>
</TD>
<TD class="docTableCell">
<P class="docText">Matches an empty string, but only at the start of the whole string</P>
</TD>
</TR>
<TR>
<TD class="docTableCell">
<PRE>\b</PRE>
</TD>
<TD class="docTableCell">
<P class="docText">Matches an empty string, but only at the start or end of a word (a
maximal sequence of alphanumeric characters; see also
<TT>\w</TT>)</P>
</TD>
</TR>
<TR>
<TD class="docTableCell">
<PRE>\B</PRE>
</TD>
<TD class="docTableCell">
<P class="docText">Matches an empty string, but not at the start or end of a word</P>
</TD>
</TR>
<TR>
<TD class="docTableCell">
<P class="docText">\d</P>
</TD>
<TD class="docTableCell">
<P class="docText">Matches one digit, like the set <TT>[0-9]</TT></P>
</TD>
</TR>
<TR>
<TD class="docTableCell">
<PRE>\D</PRE>
</TD>
<TD class="docTableCell">
<P class="docText">Matches one non-digit, like the set <TT>[^0-9]</TT></P>
</TD>
</TR>
<TR>
<TD class="docTableCell">
<PRE>\s</PRE>
</TD>
<TD class="docTableCell">
<P class="docText">Matches a whitespace character, like the set <TT>[</TT>
<TT>\t\n\r\f\v]</TT></P>
</TD>
</TR>
<TR>
<TD class="docTableCell">
<PRE>\S</PRE>
</TD>
<TD class="docTableCell">
<P class="docText">Matches a non-white character, like the set <TT>[^</TT>
<TT>\t\n\r\f\v]</TT></P>
</TD>
</TR>
<TR>
<TD class="docTableCell">
<PRE>\w</PRE>
</TD>
<TD class="docTableCell">
<P class="docText">Matches one alphanumeric character; unless <TT>LOCALE</TT>
or <TT>UNICODE</TT> is set, <TT>\w</TT> is like
<TT>[a-zA-Z0-9_]</TT></P>
</TD>
</TR>
<TR>
<TD class="docTableCell">
<PRE>\W</PRE>
</TD>
<TD class="docTableCell">
<P class="docText">Matches one non-alphanumeric character, the reverse of
<TT>\w</TT></P>
</TD>
</TR>
<TR>
<TD class="docTableCell">
<PRE>\Z</PRE>
</TD>
<TD class="docTableCell">
<P class="docText">Matches an empty string, but only at the end of the whole string</P>
</TD>
</TR>
<TR>
<TD class="docTableCell">
<PRE>\\</PRE>
</TD>
<TD class="docTableCell">
<P class="docText">Matches one backslash character</P>
</TD>
</TR>
</COLGROUP>
</TABLE></P>


<A NAME="pythonian-CHP-9-SECT-7.2"></A>
<H4 class="docSection2Title">9.7.2 Common Regular Expression Idioms</H4>

<P class="docText">'<TT>.*</TT>'<A NAME="pythonian-CHP-9-ITERM-5278"></A>
as a substring of a regular expression's pattern
string means "any number of repetitions (zero or
more) of any character." In other words,
'<TT>.*</TT>' matches any substring of a target string,
including the empty substring. '<TT>.+</TT>' is similar,
but it matches only a non-empty substring. For example:</P>

<PRE>'pre.*post'</PRE>

<P class="docText">matches a string containing a substring '<TT>pre</TT>'
followed by a later substring '<TT>post</TT>', even if the
latter is adjacent to the former (e.g., it matches both
'<TT>prepost</TT>' and '<TT>pre23post</TT>'). On
the other hand:</P>

<PRE>'pre.+post'</PRE>

<P class="docText">matches only if '<TT>pre</TT>' and
'<TT>post</TT>' are not adjacent (e.g., it matches
'<TT>pre23post</TT>' but does not match
'<TT>prepost</TT>'). Both patterns also match strings that
continue after the '<TT>post</TT>'.</P>

<P class="docText">To constrain a pattern to match only strings that end with
'<TT>post</TT>', end the pattern with
<TT>\Z</TT>. For example:</P>

<PRE>r'pre.*post\Z'</PRE>

<P class="docText">matches '<TT>prepost</TT>', but not
'<TT>preposterous</TT>'. Note that we need to express the
pattern with raw-string syntax (or escape the backslash
<TT>\</TT> by doubling it into <TT>\\</TT>), as
it contains a backslash. Using raw-string syntax for all regular
expression pattern literals is good practice in Python, as
it's the simplest way to ensure
you'll never fail to escape a backslash.</P>

<P class="docText">Another frequently used element in regular expression patterns is
<TT>\b</TT>, which matches a word boundary. If you want to
match the word '<TT>his</TT>' only as a whole word and not
its occurrences as a substring in such words as
'<TT>this</TT>' and '<TT>history</TT>', the
regular expression pattern is:</P>

<PRE> r'\bhis\b'</PRE>

<P class="docText">with word boundaries both before and after. To match the beginning of
any word starting with '<TT>her</TT>', such as
'<TT>her</TT>' itself but also
'<TT>hermetic</TT>', but not words that just contain
'<TT>her</TT>' elsewhere, such as
'<TT>ether</TT>', use:</P>

<PRE>r'\bher'</PRE>

<P class="docText">with a word boundary before, but not after, the relevant string. To
match the end of any word ending with '<TT>its</TT>', such
as '<TT>its</TT>' itself but also
'<TT>fits</TT>', but not words that contain
'<TT>its</TT>' elsewhere, such as
'<TT>itsy</TT>', use:</P>

<PRE>r'its\b'</PRE>

<P class="docText">with a word boundary after, but not before, the relevant string. To
match whole words thus constrained, rather than just their beginning
or end, add a pattern element <TT>\w*</TT> to match zero or
more word characters. For example, to match any full word starting
with '<TT>her</TT>', use:</P>

<PRE>r'\bher\w*'</PRE>

<P class="docText">And to match any full word ending with '<TT>its</TT>', use:</P>

<PRE>r'\w*its\b'</PRE>


<A NAME="pythonian-CHP-9-SECT-7.3"></A>
<H4 class="docSection2Title">9.7.3 Sets of Characters</H4>

<P class="docText"><A NAME="pythonian-CHP-9-ITERM-5279"></A> <A NAME="pythonian-CHP-9-ITERM-5280"></A> <A NAME="pythonian-CHP-9-ITERM-5281"></A> <A NAME="pythonian-CHP-9-ITERM-5282"></A> <A NAME="pythonian-CHP-9-ITERM-5283"></A>You denote sets of characters in a
pattern by listing the characters within brackets (<TT>[
]</TT>). In addition to listing single characters, you can
denote a range by giving the first and last characters of the range
separated by a hyphen (<TT>-</TT>). The last character of
the range is included in the set, which is different from other
Python ranges. Within a set, special characters stand for themselves,
except <TT>\</TT>, <TT>]</TT>, and
<TT>-</TT>, which you must escape (by preceding them with a
backslash) when their position is such that, unescaped, they would
form part of the set's syntax. In a set, you can
also denote a class of characters by escaped-letter notation, such as
<TT>\d</TT> or <TT>\S</TT>. However,
<TT>\b</TT> in a set denotes a backspace character, not a
word boundary. If the first character in the set's
pattern, right after the <TT>[</TT>, is a caret
(<TT>^</TT>), the set is <span class="docEmphasis">complemented</span>.
In other words, the set matches any character except those that
follow <TT>^</TT> in the set pattern
notation.<A NAME="pythonian-CHP-9-ITERM-5284"></A> <A NAME="pythonian-CHP-9-ITERM-5285"></A></P>

<P class="docText">A frequent use of character sets is to match a word, using a
definition of what characters can make up a word that differs from
<TT>\w</TT>'s default (letters and
digits). To match a word of one or more characters, each of which can
be a letter, an apostrophe, or a hyphen, but not a digit (e.g.,
'<TT>Finnegan-O'Hara</TT>'), use:</P>

<PRE>r"[a-zA-z'\-]+"</PRE>

<P class="docText">It's not strictly necessary to escape the hyphen
with a backslash in this case, since its position makes it
syntactically unambiguous. However, the backslash makes the pattern
somewhat more readable, by visually distinguishing the hyphen that
you want to have as a character in the set from those used to denote
ranges.</P>


<A NAME="pythonian-CHP-9-SECT-7.4"></A>
<H4 class="docSection2Title">9.7.4 Alternatives</H4>

<P class="docText"><A NAME="pythonian-CHP-9-ITERM-5286"></A>A
vertical bar (<TT>|</TT>) in a regular expression pattern,
used to specify alternatives, has low precedence. Unless parentheses
change the grouping, <TT>|</TT> applies to the whole
pattern on either side, up to the start or end of the string, or to
another <TT>|</TT>. A pattern can be made up of any number
of subpatterns joined by <TT>|</TT>. To match such a
regular expression, the first subpattern is tried first, and if it
matches, the others are skipped. If the first subpattern does not
match, the second subpattern is tried, and so on.
<TT>|</TT> is neither greedy nor non-greedy, as it
doesn't take into consideration the length of the
match.<A NAME="pythonian-CHP-9-ITERM-5287"></A>
<A NAME="pythonian-CHP-9-ITERM-5288"></A></P>

<P class="docText">If you have a list <TT><I>L</I></TT> of words, a regular
expression pattern that matches any of the words is:</P>

<PRE>'|'.join([r'\b%s\b' % word for word in L])</PRE>

<P class="docText">If the items of <TT><I>L</I></TT> can be more-general
strings, not just words, you need to escape each of them with
function <TT>re.escape</TT>, covered later in this chapter,
and you probably don't want the
<TT>\b</TT> word boundary markers on either side. In this
case, use the regular expression pattern:</P>

<PRE>'|'.join(map(re.escape,<TT><I>L</I></TT>))</PRE>


<A NAME="pythonian-CHP-9-SECT-7.5"></A>
<H4 class="docSection2Title">9.7.5 Groups</H4>

<P class="docText"><A NAME="pythonian-CHP-9-ITERM-5289"></A>A
regular expression can contain any number of groups, from none up to
99 (any number is allowed, but only the first 99 groups are fully
supported). Parentheses in a pattern string indicate a group. Element
<TT>(?P&lt;</TT><TT><I>id</I></TT><TT>&gt;...)</TT>
also indicates a group, and in addition gives the group a name,
<TT><I>id</I></TT>, that can be any Python identifier. All
groups, named and unnamed, are numbered from left to right, 1 to 99,
with group number 0 indicating the whole regular expression.</P>

<P class="docText">For any match of the regular expression with a string, each group
matches a substring (possibly an empty one). When the regular
expression uses <TT>|</TT>, some of the groups may not
match any substring, although the regular expression as a whole does
match the string. When a group doesn't match any
substring, we say that the group does not
<span class="docEmphasis">participate</span> in the match. An empty string
'' is used to represent the matching substring for
a group that does not participate in a match, except where otherwise
indicated later in this chapter.</P>

<P class="docText">For example:</P>

<PRE>r'(.+)\1+\Z'</PRE>

<P class="docText">matches a string made up of two or more repetitions of any non-empty
substring. The <TT>(.+)</TT> part of the pattern matches
any non-empty substring (any character, one or more times), and
defines a group thanks to the parentheses. The <TT>\1+</TT>
part of the pattern matches one or more repetitions of the group, and
the <TT>\Z</TT> anchors the match to end-of-string.</P>


<A NAME="pythonian-CHP-9-SECT-7.6"></A>
<H4 class="docSection2Title">9.7.6 Optional Flags</H4>

<P class="docText"><A NAME="pythonian-CHP-9-ITERM-5290"></A>A regular expression pattern element
with one or more of the letters
"<TT>iLmsux</TT>" between
<TT>(?</TT> and <TT>)</TT> lets you set regular
expression options within the regular expression's
pattern, rather than by the <TT><I>flags</I></TT> argument
to function <TT>compile</TT> of module
<TT>re</TT>. Options apply to the whole regular expression,
no matter where the options element occurs in the pattern. For
clarity, options should always be at the start of the pattern.
Placement at the start is mandatory if <TT>x</TT> is among
the options, since <TT>x</TT> changes the way Python parses
the pattern.</P>

<P class="docText"><A NAME="pythonian-CHP-9-ITERM-5291"></A>
<A NAME="pythonian-CHP-9-ITERM-5292"></A>
<A NAME="pythonian-CHP-9-ITERM-5293"></A>Using the explicit
<TT><I>flags</I></TT> argument is more readable than
placing an options element within the pattern. The
<TT><I>flags</I></TT> argument to function
<TT>compile</TT> is a coded integer, built by bitwise ORing
(with Python's bitwise OR operator,
<TT>|</TT>) one or more of the following attributes of
module <TT>re</TT>. Each attribute has both a short name
(one uppercase letter), for convenience, and a long name (an
uppercase multiletter identifier), which is more readable and thus
normally preferable:</P>

<A NAME="pythonian-CHP-9-ITERM-5294"></A><A NAME="pythonian-CHP-9-ITERM-5295"></A><A NAME="pythonian-CHP-9-ITERM-5296"></A><A NAME="pythonian-CHP-9-ITERM-5297"></A><A NAME="pythonian-CHP-9-ITERM-5298"></A><A NAME="pythonian-CHP-9-ITERM-5299"></A><A NAME="pythonian-CHP-9-ITERM-5300"></A><A NAME="pythonian-CHP-9-ITERM-5301"></A><A NAME="pythonian-CHP-9-ITERM-5302"></A><A NAME="pythonian-CHP-9-ITERM-5303"></A><A NAME="pythonian-CHP-9-ITERM-5304"></A><A NAME="pythonian-CHP-9-ITERM-5305"></A><A NAME="pythonian-CHP-9-ITERM-5306"></A><A NAME="pythonian-CHP-9-ITERM-5307"></A><A NAME="pythonian-CHP-9-ITERM-5308"></A><A NAME="pythonian-CHP-9-ITERM-5309"></A><A NAME="pythonian-CHP-9-ITERM-5310"></A><A NAME="pythonian-CHP-9-ITERM-5311"></A><A NAME="pythonian-CHP-9-ITERM-5312"></A><A NAME="pythonian-CHP-9-ITERM-5313"></A><A NAME="pythonian-CHP-9-ITERM-5314"></A><A NAME="pythonian-CHP-9-ITERM-5315"></A><A NAME="pythonian-CHP-9-ITERM-5316"></A><A NAME="pythonian-CHP-9-ITERM-5317"></A><A NAME="pythonian-CHP-9-ITERM-5318"></A><DL class="docList">
<DT><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">I</span></span><A NAME="pythonian-CHP-9-ITERM-5294"></A>
<A NAME="pythonian-CHP-9-ITERM-5295"></A>
<A NAME="pythonian-CHP-9-ITERM-5296"></A> or <span class="docPubcolor"><span class="docMonofont">IGNORECASE</span></span></span></DT>
<DD>
<P class="docList">Makes matching case-insensitive</P>
</DD>
<DT><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">L</span></span><A NAME="pythonian-CHP-9-ITERM-5297"></A>
<A NAME="pythonian-CHP-9-ITERM-5298"></A> or <span class="docPubcolor"><span class="docMonofont">LOCALE</span></span></span></DT>
<DD>
<P class="docList">Causes <TT>\w</TT>, <TT>\W</TT>,
<TT>\b</TT>, and <TT>\B</TT> matches to depend on
what the current locale deems alphanumeric</P>
</DD>
<DT><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">M</span></span> or <span class="docPubcolor"><span class="docMonofont">MULTILINE</span></span><A NAME="pythonian-CHP-9-ITERM-5299"></A>
<A NAME="pythonian-CHP-9-ITERM-5300"></A>
<A NAME="pythonian-CHP-9-ITERM-5301"></A>
<A NAME="pythonian-CHP-9-ITERM-5302"></A>
<A NAME="pythonian-CHP-9-ITERM-5303"></A>
<A NAME="pythonian-CHP-9-ITERM-5304"></A></span></DT>
<DD>
<P class="docList">Makes the special characters <TT>^</TT> and
<TT>$</TT> match at the start and end of each line (i.e.,
right after/before a newline), as well as at the start and end of the
whole string</P>
</DD>
<DT><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">S</span></span> or <span class="docPubcolor"><span class="docMonofont">DOTALL</span></span><A NAME="pythonian-CHP-9-ITERM-5305"></A>
<A NAME="pythonian-CHP-9-ITERM-5306"></A>
<A NAME="pythonian-CHP-9-ITERM-5307"></A>
<A NAME="pythonian-CHP-9-ITERM-5308"></A></span></DT>
<DD>
<P class="docList">Causes the special character . to match any
character, including a newline</P>
</DD>
<DT><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">U</span></span> or <span class="docPubcolor"><span class="docMonofont">UNICODE</span></span><A NAME="pythonian-CHP-9-ITERM-5309"></A>
<A NAME="pythonian-CHP-9-ITERM-5310"></A>
<A NAME="pythonian-CHP-9-ITERM-5311"></A></span></DT>
<DD>
<P class="docList">Makes <TT>\w</TT>, <TT>\W</TT>,
<TT>\b</TT>, and <TT>\B</TT> matches depend on
what Unicode deems alphanumeric</P>
</DD>
<DT><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">X</span></span> or <span class="docPubcolor"><span class="docMonofont">VERBOSE</span></span><A NAME="pythonian-CHP-9-ITERM-5312"></A>
<A NAME="pythonian-CHP-9-ITERM-5313"></A>
<A NAME="pythonian-CHP-9-ITERM-5314"></A>
<A NAME="pythonian-CHP-9-ITERM-5315"></A>
<A NAME="pythonian-CHP-9-ITERM-5316"></A>
<A NAME="pythonian-CHP-9-ITERM-5317"></A>
<A NAME="pythonian-CHP-9-ITERM-5318"></A></span></DT>
<DD>
<P class="docList">Causes whitespace in the pattern to be ignored, except when escaped
or in a character set, and makes a <TT>#</TT> character in
the pattern begin a comment that lasts until the end of the line</P>
</DD>
</DL>

<P class="docText">For example, here are three ways to define equivalent regular
expressions with function <TT>compile</TT>, covered later
in this chapter. Each of these regular expressions matches the word
"hello" in any mix of upper- and
lowercase letters:</P>

<PRE>import re
r1 = re.compile(r'(?i)hello')
r2 = re.compile(r'hello', re.I)
r3 = re.compile(r'hello', re.IGNORECASE)</PRE>

<P class="docText">The third approach is clearly the most readable, and thus the most
maintainable, even though it is slightly more verbose. Note that the
raw-string form is not necessary here, since the patterns do not
include backslashes. However, using raw strings is still innocuous,
and is the recommended style for clarity.</P>

<P class="docText">Option <TT>re.VERBOSE</TT> (or <TT>re.X</TT>)
lets you make patterns more readable and understandable by
appropriate use of whitespace and comments. Complicated and verbose
regular expression patterns are generally best represented by strings
that take up more than one line, and therefore you normally want to
use the triple-quoted raw-string format for such pattern strings. For
example:</P>

<PRE>repat_num1 = r'(0[0-7]*|0x[\da-fA-F]+|[1-9]\d*)L?\Z'
repat_num2 = r'''(?x)            # pattern matching integer numbers
              (0 [0-7]*        | # octal: leading 0, then 0+ octal digits
               0x [\da-f-A-F]+ | # hex: 0x, then 1+ hex digits
               [1-9] \d*       ) # decimal: leading non-0, then 0+ digits
               L?\Z              # optional trailing L, then end of string
              '''</PRE>

<P class="docText">The two patterns defined in this example are equivalent, but the
second one is made somewhat more readable by the comments and the
free use of whitespace to group portions of the pattern in logical
ways.</P>


<A NAME="pythonian-CHP-9-SECT-7.7"></A>
<H4 class="docSection2Title">9.7.7 Match Versus Search</H4>

<P class="docText"><A NAME="pythonian-CHP-9-ITERM-5319"></A>So far, we've
been using regular expressions to match strings. For example, the
regular expression with pattern <TT>r'box</TT>' matches
strings such as '<TT>box</TT>' and
'<TT>boxes</TT>', but not '<TT>inbox</TT>'. In
other words, a regular expression match can be considered as
implicitly anchored at the start of the target string, as if the
regular expression's pattern started with
<TT>\A</TT>.</P>

<P class="docText">Often, you're interested in locating possible
matches for a regular expression anywhere in the string, without any
anchoring (e.g., find the <TT>r'box</TT>' match inside such
strings as '<TT>inbox</TT>', as well as in
'<TT>box</TT>' and '<TT>boxes</TT>'). In this
case, the Python term for the operation is a
<span class="docEmphasis">search</span>, as opposed to a match. For such
searches, you use the <TT>search</TT> method of a regular
expression object, while the <TT>match</TT> method only
deals with matching from the start. For example:</P>

<PRE>import re
r1 = re.compile(r'box')
if r1.match('inbox'): print 'match succeeds'
else print 'match fails'                          # prints: match fails
if r1. search('inbox'): print 'search succeeds'   # prints: search succeeds
else print 'search fails'</PRE>


<A NAME="pythonian-CHP-9-SECT-7.8"></A>
<H4 class="docSection2Title">9.7.8 Anchoring at String Start and End</H4>

<P class="docText"><A NAME="pythonian-CHP-9-ITERM-5320"></A>The pattern elements
ensuring that a regular expression search (or match) is anchored at
string start and string end are <TT>\A</TT> and
<TT>\Z</TT> respectively. More traditionally, elements
<TT>^</TT> for start and <TT>$</TT> for end are
also used in similar roles. <TT>^</TT> is the same as
<TT>\A</TT>, and <TT>$</TT> is the same as
<TT>\Z</TT>, for regular expression objects that are not
multiline (i.e., that do not contain pattern element
<TT>(?m)</TT> and are not compiled with the flag
<TT>re.M</TT> or <TT>re.MULTILINE</TT>). For a
multiline regular expression object, however, <TT>^</TT>
anchors at the start of any line (i.e., either at the start of the
whole string or at the position right after a newline character
<TT>\n</TT>). Similarly, with a multiline regular
expression, <TT>$</TT> anchors at the end of any line
(i.e., either at the end of the whole string or at the position right
before <TT>\n</TT>). On the other hand,
<TT>\A</TT> and <TT>\Z</TT> anchor at the start
and end of the whole string whether the regular expression object is
multiline or not. For example, here's how to check
if a file has any lines that end with digits:</P>

<PRE>import re
digatend = re.compile(r'\d$', re.MULTILINE)
if re.search(open('afile.txt').read(  )): print "some lines end with digits"
else: print "no lines end with digits"</PRE>

<P class="docText">A pattern of <TT>r'\d\n</TT>' would be almost equivalent,
but in that case the search would fail if the very last character of
the file were a digit not followed by a terminating end-of-line
character. With the example above, the search succeeds if a digit is
at the very end of the file's contents, as well as
in the more usual case where a digit is followed by an end-of-line
character.</P>


<A NAME="pythonian-CHP-9-SECT-7.9"></A>
<H4 class="docSection2Title">9.7.9 Regular Expression Objects</H4>

<P class="docText"><A NAME="pythonian-CHP-9-ITERM-5321"></A>A regular expression object
<TT><I>r</I></TT> has the following read-only attributes
detailing how <TT><I>r</I></TT> was built (by function
<TT>compile</TT> of module <TT>re</TT>, covered
later in this chapter):</P>

<A NAME="pythonian-CHP-9-ITERM-5322"></A><A NAME="pythonian-CHP-9-ITERM-5323"></A><A NAME="pythonian-CHP-9-ITERM-5324"></A><A NAME="pythonian-CHP-9-ITERM-5325"></A><DL class="docList">
<DT><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">flags</span></span><A NAME="pythonian-CHP-9-ITERM-5322"></A>
<A NAME="pythonian-CHP-9-ITERM-5323"></A>
<A NAME="pythonian-CHP-9-ITERM-5324"></A>
<A NAME="pythonian-CHP-9-ITERM-5325"></A></span></DT>
<DD>
<P class="docList">The <TT><I>flags</I></TT> argument passed to
<TT>compile</TT>, or <TT>0</TT> when
<TT><I>flags</I></TT> is omitted</P>
</DD>
<DT><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">groupindex</span></span></span></DT>
<DD>
<P class="docList">A dictionary whose keys are group names as defined by elements
<TT>(?P&lt;</TT><TT><I>id</I></TT><TT>&gt;)</TT>;
the corresponding values are the named groups'
numbers</P>
</DD>
<DT><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">pattern</span></span></span></DT>
<DD>
<P class="docList">The pattern string from which <TT><I>r</I></TT> is compiled</P>
</DD>
</DL>

<P class="docText">These attributes make it easy to get back from a compiled regular
expression object to its pattern string and flags, so you never have
to store those separately.</P>

<P class="docText">A regular expression object <TT><I>r</I></TT> also
supplies methods to locate matches for
<TT><I>r</I></TT>'s regular expression
within a string, as well as to perform substitutions on such matches.
Matches are generally represented by special objects, covered in the
later <A class="docLink" HREF="#pythonian-CHP-9-SECT-7.10">Section 9.7.10</A>.</P>



<A NAME="ch09-77066"></A><A NAME="pythonian-CHP-9-ITERM-5326"></A><A NAME="pythonian-CHP-9-ITERM-5327"></A><table width="515" border="0" cellpadding="5">
<tr>
<td align="left"><b><i>findall 
</i></b></td>
<td align="right"></td>
</tr>
</table>
<hr width="515" size="3" noshade="true" align="left" color="black">
<table width="515" border="0" cellpadding="5">
<tr>
<td align="left">
<pre><TT><I>r</I></TT>.findall(<TT><I>s</I></TT>)</pre>
</td>
<td align="right"></td>
</tr>
</table>
<P class="docText">When <TT><I>r</I></TT> has no groups,
<TT>findall</TT> returns a list of strings, each a
substring of <TT><I>s</I></TT> that is a non-overlapping
match with <TT><I>r</I></TT>. For example,
here's how to print out all words in a file, one per
line:</P>
<PRE>import re
reword = re.compile(r'\w+')
for aword in reword.findall(open('afile.txt').read(  )):
    print aword</PRE><P class="docText">When <TT><I>r</I></TT> has one group,
<TT>findall</TT> also returns a list of strings, but each
is the substring of <TT><I>s</I></TT> matching
<TT><I>r</I></TT>'s group. For example,
if you want to print only words that are followed by whitespace (not
punctuation), you need to change only one statement in the previous
example:</P>
<PRE>reword = re.compile('(\w+)\s')</PRE><P class="docText">When <TT><I>r</I></TT> has <TT><I>n</I></TT>
groups (where <TT><I>n</I></TT> is greater than
<TT>1</TT>), <TT>findall</TT> returns a list of
tuples, one per non-overlapping match with
<TT><I>r</I></TT>. Each tuple has
<TT><I>n</I></TT> items, one per group of
<TT><I>r</I></TT>, the substring of
<TT><I>s</I></TT> matching the group. For example,
here's how to print the first and last word of each
line that has at least two words:</P>
<PRE>import re
first_last = re.compile(r'^\W*(\w+)\b.*\b(\w+)\W*$', 
                                      re.MULTILINE)
for first, last in \
first_last.findall(open('afile.txt').read(  )):
    print first, last</PRE>

<A NAME="ch09-77067"></A><A NAME="pythonian-CHP-9-ITERM-5328"></A><A NAME="pythonian-CHP-9-ITERM-5329"></A><table width="515" border="0" cellpadding="5">
<tr>
<td align="left"><b><i>match
</i></b></td>
<td align="right"></td>
</tr>
</table>
<hr width="515" size="3" noshade="true" align="left" color="black">
<table width="515" border="0" cellpadding="5">
<tr>
<td align="left">
<pre><TT><I>r</I></TT>.match(<TT><I>s</I></TT>,<TT><I>start</I></TT>=0,<TT><I>end</I></TT>=sys.maxint)</pre>
</td>
<td align="right"></td>
</tr>
</table>
<P class="docText">Returns an appropriate match object when a substring of
<TT><I>s</I></TT>, starting at index
<TT><I>start</I></TT> and not reaching as far as index
<TT><I>end</I></TT>, matches <TT><I>r</I></TT>.
Otherwise, <TT>match</TT> returns <TT>None</TT>.
Note that <TT>match</TT> is implicitly anchored at the
starting position <TT><I>start</I></TT> in
<TT><I>s</I></TT>. To search for a match with
<TT><I>r</I></TT> through <TT><I>s</I></TT>,
from <TT><I>start</I></TT> onwards, call
<TT><I>r</I></TT><TT>.search</TT>, not
<TT><I>r</I></TT><TT>.match</TT>. For example,
here's how to print all lines in a file that start
with digits:</P>
<PRE>import re
digs = re.compile(r'\d+')
for line in open('afile.txt'):
    if digs.match(line): print line,</PRE>

<A NAME="ch09-77068"></A><A NAME="pythonian-CHP-9-ITERM-5330"></A><A NAME="pythonian-CHP-9-ITERM-5331"></A><table width="515" border="0" cellpadding="5">
<tr>
<td align="left"><b><i>search
</i></b></td>
<td align="right"></td>
</tr>
</table>
<hr width="515" size="3" noshade="true" align="left" color="black">
<table width="515" border="0" cellpadding="5">
<tr>
<td align="left">
<pre><TT><I>r</I></TT>.search(<TT><I>s</I></TT>,<TT><I>start</I></TT>=0,<TT><I>end</I></TT>=sys.maxint)</pre>
</td>
<td align="right"></td>
</tr>
</table>
<P class="docText">Returns an appropriate match object for the leftmost substring of
<TT><I>s</I></TT>, starting not before index
<TT><I>start</I></TT> and not reaching as far as index
<TT><I>end</I></TT>, that matches
<TT><I>r</I></TT>. When no such substring exists,
<TT>search</TT> returns <TT>None</TT>. For
example, to print all lines containing digits, one simple approach is
as follows:</P>
<PRE>import re
digs = re.compile(r'\d+')
for line in open('afile.txt'):
    if digs.search(line): print line,</PRE>

<A NAME="ch09-77069"></A><A NAME="pythonian-CHP-9-ITERM-5332"></A><A NAME="pythonian-CHP-9-ITERM-5333"></A><table width="515" border="0" cellpadding="5">
<tr>
<td align="left"><b><i>split
</i></b></td>
<td align="right"></td>
</tr>
</table>
<hr width="515" size="3" noshade="true" align="left" color="black">
<table width="515" border="0" cellpadding="5">
<tr>
<td align="left">
<pre><TT><I>r</I></TT>.split(<TT><I>s</I></TT>,<TT><I>maxsplit</I></TT>=0)</pre>
</td>
<td align="right"></td>
</tr>
</table>
<P class="docText">Returns a list <TT><I>L</I></TT> of the splits of
<TT><I>s</I></TT> by <TT><I>r</I></TT> (i.e.,
the substrings of <TT><I>s</I></TT> that are separated by
non-overlapping, non-empty matches with
<TT><I>r</I></TT>). For example, to eliminate all
occurrences of substring '<TT>hello</TT>' from a string, in
any mix of lowercase and uppercase letters, one way is:</P>
<PRE>import re
rehello = re.compile(r'hello', re.IGNORECASE)
astring = ''.join(rehello.split(astring))</PRE><P class="docText">When <TT><I>r</I></TT> has <TT><I>n</I></TT>
groups, <TT><I>n</I></TT> more items are interleaved in
<TT><I>L</I></TT> between each pair of splits. Each of the
<TT><I>n</I></TT> extra items is the substring of
<TT><I>s</I></TT> matching
<TT><I>r</I></TT>'s corresponding group
in that match, or <TT>None</TT> if that group did not
participate in the match. For example, here's one
way to remove whitespace only when it occurs between a colon and a
digit:</P>
<PRE>import re
re_col_ws_dig = re.compile(r'(:)\s+(\d)')
astring = ''.join(re_col_ws_dig.split(astring))</PRE><P class="docText">If <TT><I>maxsplit</I></TT> is greater than
<TT><I>0</I></TT>, at most
<TT><I>maxsplit</I></TT> splits are in
<TT><I>L</I></TT>, each followed by
<TT><I>n</I></TT> items as above, while the trailing
substring of <TT><I>s</I></TT> after
<TT><I>maxsplit</I></TT> matches of
<TT><I>r</I></TT>, if any, is
<TT><I>L</I></TT>'s last item. For
example, to remove only the first occurrence of substring
'<TT>hello</TT>' rather than all of them, change the last
statement in the first example above to:</P>
<PRE>astring = ''.join(rehello.split(astring, 1))</PRE>

<A NAME="ch09-77070"></A><A NAME="pythonian-CHP-9-ITERM-5334"></A><A NAME="pythonian-CHP-9-ITERM-5335"></A><table width="515" border="0" cellpadding="5">
<tr>
<td align="left"><b><i>sub
</i></b></td>
<td align="right"></td>
</tr>
</table>
<hr width="515" size="3" noshade="true" align="left" color="black">
<table width="515" border="0" cellpadding="5">
<tr>
<td align="left">
<pre><TT><I>r</I></TT>.sub(<TT><I>repl</I></TT>,<TT><I>s</I></TT>,<TT><I>count</I></TT>=0)</pre>
</td>
<td align="right"></td>
</tr>
</table>
<P class="docText">Returns a copy of <TT><I>s</I></TT> where non-overlapping
matches with <TT><I>r</I></TT> are replaced by
<TT><I>repl</I></TT>, which can be either a string or a
callable object, such as a function. An empty match is replaced only
when not adjacent to the previous match. When
<TT><I>count</I></TT> is greater than
<TT>0</TT>, only the first <TT><I>count</I></TT>
matches of <TT><I>r</I></TT> within
<TT><I>s</I></TT> are replaced. When
<TT><I>count</I></TT> equals <TT>0</TT>, all
matches of <TT><I>r</I></TT> within
<TT><I>s</I></TT> are replaced. For example,
here's another way to remove only the first
occurrence of substring '<TT>hello</TT>' in any mix of
cases:</P>
<PRE>import re
rehello = re.compile(r'hello', re.IGNORECASE)
astring = rehello.sub('', astring, 1)</PRE><P class="docText">Without the final <TT>1</TT> argument to method
<TT>sub</TT>, this example would remove all occurrences of
'<TT>hello</TT>'.</P>
<P class="docText">When <TT><I>repl</I></TT> is a callable object,
<TT><I>repl</I></TT> must accept a single argument (a
match object) and return a string to use as the replacement for the
match. In this case, <TT>sub</TT> calls
<TT><I>repl</I></TT>, with a suitable match-object
argument, for each match with <TT><I>r</I></TT> that
<TT>sub</TT> is replacing. For example, to uppercase all
occurrences of words starting with '<TT>h</TT>' and ending
with '<TT>o</TT>' in any mix of cases, you can use the
following:</P>
<PRE>import re
h_word = re.compile(r'\bh\w+o\b', re.IGNORECASE)
def up(mo): return mo.group(0).upper(  )
astring = h_word.sub(up, astring)</PRE><P class="docText">Method <TT>sub</TT> is a good way to get a callback to a
callable you supply for every non-overlapping match of
<TT><I>r</I></TT> in <TT><I>s</I></TT>, without
an explicit loop, even when you don't need to
perform any substitution. The following example shows this by using
the <TT>sub</TT> method to build a function that works just
like method <TT>findall</TT> for a regular expression
without groups:</P>
<PRE>import re
def findall(r, s):
    result = [  ]
    def foundOne(mo): result.append(mo.group(  ))
    r.sub(foundOne, s)
    return result</PRE><P class="docText">The example needs Python 2.2, not just because it uses lexically
nested scopes, but because in Python 2.2 <TT>re</TT>
tolerates <TT><I>repl</I></TT> returning
<TT>None</TT> and treats it as if it returned
'', while in Python 2.1 <TT>re</TT> was
more pedantic and insisted on <TT><I>repl</I></TT>
returning a string.</P>
<P class="docText">When <TT><I>repl</I></TT> is a string,
<TT>sub</TT> uses <TT><I>repl</I></TT> itself as
the replacement, except that it expands back references. A
<span class="docEmphasis">back reference</span> is a substring of
<TT><I>repl</I></TT> of the form
<TT>\g&lt;</TT><TT><I>id</I></TT><TT>&gt;</TT>,
where <TT><I>id</I></TT> is the name of a group in
<TT><I>r</I></TT> (as established by syntax
<TT>(?P&lt;</TT><TT><I>id</I></TT><TT>&gt;)</TT>
in <TT><I>r</I></TT>'s pattern string),
or <TT>\</TT><TT><I>dd</I></TT>, where
<TT><I>dd</I></TT> is one or two digits, taken as a group
number. Each back reference, whether named or numbered, is replaced
with the substring of <TT><I>s</I></TT> matching the group
of <TT><I>r</I></TT> that the back reference indicates.
For example, here's how to enclose every word in
braces:</P>
<PRE>import re
grouped_word = re.compile('(\w+)')
astring = grouped_word.sub(r'{\1}', astring)</PRE>

<A NAME="ch09-77071"></A><A NAME="pythonian-CHP-9-ITERM-5336"></A><A NAME="pythonian-CHP-9-ITERM-5337"></A><A NAME="pythonian-CHP-9-ITERM-5338"></A><table width="515" border="0" cellpadding="5">
<tr>
<td align="left"><b><i>subn
</i></b></td>
<td align="right"></td>
</tr>
</table>
<hr width="515" size="3" noshade="true" align="left" color="black">
<table width="515" border="0" cellpadding="5">
<tr>
<td align="left">
<pre><TT><I>r</I></TT>.subn(<TT><I>repl</I></TT>,<TT><I>s</I></TT>,<TT><I>count</I></TT>=0)</pre>
</td>
<td align="right"></td>
</tr>
</table>
<P class="docText"><TT>subn</TT> is the same as <TT>sub</TT>, except
that <TT>subn</TT> returns a pair
<TT>(</TT><TT><I>new_string</I></TT>,
<TT><I>n</I></TT><TT>)</TT> where
<TT><I>n</I></TT> is the number of substitutions that
<TT>subn</TT> has performed. For example, to count the
number of occurrences of substring '<TT>hello</TT>' in any
mix of cases, one way is:</P>
<PRE>import re
rehello = re.compile(r'hello', re.IGNORECASE)
junk, count = rehello.subn('', astring)
print 'Found', count, 'occurrences of "hello"'</PRE>



<A NAME="pythonian-CHP-9-SECT-7.10"></A>
<H4 class="docSection2Title">9.7.10 Match Objects</H4>

<P class="docText"><A NAME="pythonian-CHP-9-ITERM-5339"></A>
<A NAME="pythonian-CHP-9-ITERM-5340"></A>Match objects are created and returned by
methods <TT>match</TT> and <TT>search</TT> of a
regular expression object. There are also implicitly created by
methods <TT>sub</TT> and <TT>subn</TT> when
argument <TT><I>repl</I></TT> is callable, since in that
case a suitable match object is passed as the actual argument on each
call to <TT><I>repl</I></TT>. A match object
<TT><I>m</I></TT> supplies the following attributes
detailing how <TT><I>m</I></TT> was
created:<A NAME="pythonian-CHP-9-ITERM-5341"></A> <A NAME="pythonian-CHP-9-ITERM-5342"></A>
<A NAME="pythonian-CHP-9-ITERM-5343"></A> <A NAME="pythonian-CHP-9-ITERM-5344"></A></P>

<A NAME="pythonian-CHP-9-ITERM-5345"></A><A NAME="pythonian-CHP-9-ITERM-5346"></A><A NAME="pythonian-CHP-9-ITERM-5347"></A><A NAME="pythonian-CHP-9-ITERM-5348"></A><A NAME="pythonian-CHP-9-ITERM-5349"></A><A NAME="pythonian-CHP-9-ITERM-5350"></A><A NAME="pythonian-CHP-9-ITERM-5351"></A><DL class="docList">
<DT><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">pos</span></span><A NAME="pythonian-CHP-9-ITERM-5345"></A>
<A NAME="pythonian-CHP-9-ITERM-5346"></A></span></DT>
<DD>
<P class="docList">The <TT><I>start</I></TT> argument that was passed to
<TT>search</TT> or <TT>match</TT> (i.e., the
index into <TT><I>s</I></TT> where the search for a match
began)</P>
</DD>
<DT><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">endpos</span></span><A NAME="pythonian-CHP-9-ITERM-5347"></A></span></DT>
<DD>
<P class="docList">The <TT><I>end</I></TT> argument that was passed to
<TT>search</TT> or <TT>match</TT> (i.e., the
index into <TT><I>s</I></TT> before which the matching
substring of <TT><I>s</I></TT> had to end)</P>
</DD>
<DT><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">lastgroup</span></span><A NAME="pythonian-CHP-9-ITERM-5348"></A></span></DT>
<DD>
<P class="docList">The name of the last-matched group (<TT>None</TT> if the
last-matched group has no name, or if no group participated in the
match)</P>
</DD>
<DT><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">lastindex</span></span><A NAME="pythonian-CHP-9-ITERM-5349"></A></span></DT>
<DD>
<P class="docList">The integer index (1 and up) of the last-matched group
(<TT>None</TT> if no group participated in the match)</P>
</DD>
<DT><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">re</span></span><A NAME="pythonian-CHP-9-ITERM-5350"></A></span></DT>
<DD>
<P class="docList">The regular expression object <TT><I>r</I></TT> whose
method created <TT><I>m</I></TT></P>
</DD>
<DT><span class="docPubcolor"><span class="docPubcolor"><span class="docMonofont">string</span></span><A NAME="pythonian-CHP-9-ITERM-5351"></A></span></DT>
<DD>
<P class="docList">The string <TT><I>s</I></TT> passed to
<TT>match</TT>, <TT>search</TT>,
<TT>sub</TT>, or <TT>subn</TT></P>
</DD>
</DL>

<P class="docText">A match object <TT><I>m</I></TT> also supplies several
methods.</P>



<A NAME="ch09-77073"></A><A NAME="pythonian-CHP-9-ITERM-5352"></A><A NAME="pythonian-CHP-9-ITERM-5353"></A><A NAME="pythonian-CHP-9-ITERM-5354"></A><A NAME="pythonian-CHP-9-ITERM-5355"></A><A NAME="pythonian-CHP-9-ITERM-5356"></A><A NAME="pythonian-CHP-9-ITERM-5357"></A><table width="515" border="0" cellpadding="5">
<tr>
<td align="left"><b><i>end, span, start</i></b></td>
<td align="right"></td>
</tr>
</table>
<hr width="515" size="3" noshade="true" align="left" color="black">
<table width="515" border="0" cellpadding="5">
<tr>
<td align="left">
<pre><TT><I>m</I></TT>.end(<TT><I>groupid</I></TT>=0)
<TT><I>m</I></TT>.span(<TT><I>groupid</I></TT>=0)
<TT><I>m</I></TT>.start(<TT><I>groupid</I></TT>=0)</pre>
</td>
<td align="right"></td>
</tr>
</table>
<P class="docText">These methods return the delimiting indices, within
<TT><I>m</I></TT><TT>.string</TT>, of the
substring matching the group identified by
<TT><I>groupid</I></TT>, where
<TT><I>groupid</I></TT> can be a group number or name.
When the matching substring is
<TT><I>m</I></TT><TT>.string[</TT><TT><I>i</I></TT>:<TT><I>j</I></TT><TT>]</TT>,
<TT><I>m</I></TT><TT>.start</TT> returns
<TT><I>i</I></TT>,
<TT><I>m</I></TT><TT>.end</TT> returns
<TT><I>j</I></TT>, and
<TT><I>m</I></TT><TT>.span</TT> returns
<TT>(</TT><TT><I>i</I></TT>,
<TT><I>j</I></TT><TT>)</TT>. When the group did
not participate in the match, <TT><I>i</I></TT> and
<TT><I>j</I></TT> are <TT>-1</TT>.</P>

<A NAME="ch09-77074"></A><A NAME="pythonian-CHP-9-ITERM-5358"></A><A NAME="pythonian-CHP-9-ITERM-5359"></A><table width="515" border="0" cellpadding="5">
<tr>
<td align="left"><b><i>expand</i></b></td>
<td align="right"></td>
</tr>
</table>
<hr width="515" size="3" noshade="true" align="left" color="black">
<table width="515" border="0" cellpadding="5">
<tr>
<td align="left">
<pre><TT><I>m</I></TT>.expand(<TT><I>s</I></TT>)</pre>
</td>
<td align="right"></td>
</tr>
</table>
<P class="docText">Returns a copy of <TT><I>s</I></TT> where escape sequences
and back references are replaced in the same way as for method
<TT><I>r</I></TT><TT>.sub</TT>, covered in the
previous section.</P>

<A NAME="ch09-77075"></A><A NAME="pythonian-CHP-9-ITERM-5360"></A><A NAME="pythonian-CHP-9-ITERM-5361"></A><table width="515" border="0" cellpadding="5">
<tr>
<td align="left"><b><i>group</i></b></td>
<td align="right"></td>
</tr>
</table>
<hr width="515" size="3" noshade="true" align="left" color="black">
<table width="515" border="0" cellpadding="5">
<tr>
<td align="left">
<pre><TT><I>m</I></TT>.group(<TT><I>groupid</I></TT>=0,*<TT><I>groupids</I></TT>)</pre>
</td>
<td align="right"></td>
</tr>
</table>
<P class="docText">When called with a single argument <TT><I>groupid</I></TT>
(a group number or name), <TT>group</TT> returns the
substring matching the group identified by
<TT><I>groupid</I></TT>, or <TT>None</TT> if
that group did not participate in the match. The common idiom
<TT><I>m</I></TT><TT>.group( )</TT>, also
spelled <TT><I>m</I></TT><TT>.group(0)</TT>,
returns the whole matched substring, since group number
<TT>0</TT> implicitly means the whole regular expression.</P>
<P class="docText">When <TT>group</TT> is called with multiple arguments, each
argument must be a group number or name. <TT>group</TT>
then returns a tuple with one item per argument, the substring
matching the corresponding group, or <TT>None</TT> if that
group did not participate in the match.</P>

<A NAME="ch09-77076"></A><A NAME="pythonian-CHP-9-ITERM-5362"></A><A NAME="pythonian-CHP-9-ITERM-5363"></A><table width="515" border="0" cellpadding="5">
<tr>
<td align="left"><b><i>groups
</i></b></td>
<td align="right"></td>
</tr>
</table>
<hr width="515" size="3" noshade="true" align="left" color="black">
<table width="515" border="0" cellpadding="5">
<tr>
<td align="left">
<pre><TT><I>m</I></TT>.groups(<TT><I>default</I></TT>=None)</pre>
</td>
<td align="right"></td>
</tr>
</table>
<P class="docText">Returns a tuple with one item per group in
<TT><I>r</I></TT>. Each item is the substring matching the
corresponding group, or <TT><I>default</I></TT> if that
group did not participate in the match.</P>

<A NAME="ch09-77077"></A><A NAME="pythonian-CHP-9-ITERM-5364"></A><A NAME="pythonian-CHP-9-ITERM-5365"></A><A NAME="pythonian-CHP-9-ITERM-5366"></A><A NAME="pythonian-CHP-9-ITERM-5367"></A><table width="515" border="0" cellpadding="5">
<tr>
<td align="left"><b><i>groupdict
</i></b></td>
<td align="right"></td>
</tr>
</table>
<hr width="515" size="3" noshade="true" align="left" color="black">
<table width="515" border="0" cellpadding="5">
<tr>
<td align="left">
<pre><TT><I>m</I></TT>.groupdict(<TT><I>default</I></TT>=None)</pre>
</td>
<td align="right"></td>
</tr>
</table>
<P class="docText">Returns a dictionary whose keys are the names of all named groups in
<TT><I>r</I></TT>. The value for each name is the
substring matching the corresponding group, or
<TT><I>default</I></TT> if that group did not participate
in the match.<A NAME="pythonian-CHP-9-ITERM-5366"></A> <A NAME="pythonian-CHP-9-ITERM-5367"></A></P>


<A NAME="pythonian-CHP-9-SECT-7.11"></A>
<H4 class="docSection2Title">9.7.11 Functions of Module re</H4>

<P class="docText"><A NAME="pythonian-CHP-9-ITERM-5368"></A> <A NAME="pythonian-CHP-9-ITERM-5369"></A>The <TT>re</TT> module supplies
the attributes listed in the earlier section <A class="docLink" HREF="#pythonian-CHP-9-SECT-7.6">Section 9.7.6</A>. It also provides a function
that corresponds to each method of a regular expression object
(<TT>findall</TT>, <TT>match</TT>,
<TT>search</TT>, <TT>split</TT>,
<TT>sub</TT>, and <TT>subn</TT>), each with an
additional first argument, a pattern string that the function
implicitly compiles into a regular expression object.
It's generally preferable to compile pattern strings
into regular expression objects explicitly and call the regular
expression object's methods, but sometimes, for a
one-off use of a regular expression pattern, calling functions of
module <TT>re</TT> can be slightly handier. For example, to
count the number of occurrences of substring
'<TT>hello</TT>' in any mix of cases, one function-based
way is:</P>

<PRE>import re
junk, count = re.subn(r'(?i)hello', '', astring)
print 'Found', count, 'occurrences of "hello"'</PRE>

<P class="docText">In cases such as this one, regular expression options (here, for
example, case insensitivity) must be encoded as regular expression
pattern elements (here, <TT>(?i)</TT>), since the functions
of module <TT>re</TT> do not accept a
<TT><I>flags</I></TT> argument.</P>

<P class="docText">Module <TT>re</TT> also supplies <TT>error</TT>,
the class of exceptions raised upon errors (generally, errors in the
syntax of a pattern string), and two additional functions.</P>


<A NAME="ch09-77079"></A><A NAME="pythonian-CHP-9-ITERM-5370"></A><A NAME="pythonian-CHP-9-ITERM-5371"></A><A NAME="pythonian-CHP-9-ITERM-5372"></A><A NAME="pythonian-CHP-9-ITERM-5373"></A><table width="515" border="0" cellpadding="5">
<tr>
<td align="left"><b><i>compile


</i></b></td>
<td align="right"></td>
</tr>
</table>
<hr width="515" size="3" noshade="true" align="left" color="black">
<table width="515" border="0" cellpadding="5">
<tr>
<td align="left">
<pre>compile(<TT><I>pattern</I></TT>,<TT><I>flags</I></TT>=0)</pre>
</td>
<td align="right"></td>
</tr>
</table>
<P class="docText">Creates and returns a regular expression object, parsing string
<TT><I>pattern</I></TT> as per the syntax covered in <A class="docLink" HREF="#pythonian-CHP-9-SECT-7.1">Section 9.7.1</A>, and using
integer <TT><I>flags</I></TT> as in the section <A class="docLink" HREF="#pythonian-CHP-9-SECT-7.6">Section 9.7.6</A>, both earlier in this
chapter.</P>

<A NAME="ch09-77080"></A><A NAME="pythonian-CHP-9-ITERM-5374"></A><table width="515" border="0" cellpadding="5">
<tr>
<td align="left"><b><i>escape</i></b></td>
<td align="right"></td>
</tr>
</table>
<hr width="515" size="3" noshade="true" align="left" color="black">
<table width="515" border="0" cellpadding="5">
<tr>
<td align="left">
<pre>escape(<TT><I>s</I></TT>)</pre>
</td>
<td align="right"></td>
</tr>
</table>
<P class="docText">Returns a copy of string <TT><I>s</I></TT> where each
non-alphanumeric character is escaped (i.e., preceded by a backslash
<TT>\</TT>). This is handy when you need to match string
<TT><I>s</I></TT> literally as part (or all) of a regular
expression pattern string.<A NAME="pythonian-CHP-9-ITERM-5374"></A></P>




<ul></ul>
</td>
</tr>
</table>
<td></td>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<td class="tt1"><a href="NFO/lib.html">[ Team LiB ]</a></td><td valign="top" class="tt1" align="right">
          <a href="0596001886_pythonian-chp-9-sect-6.html"><img src="FILES/previous.gif" width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a>
          <a href="0596001886_pythonian-part-3.html"><img src="FILES/next.gif" width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a>
</td></table>
</body></html>
