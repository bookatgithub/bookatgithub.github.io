<html>
<META http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<head>
<title>Introduction</title>
<link rel="STYLESHEET" type="text/css" href="images/style.css">
<link rel="STYLESHEET" type="text/css" href="images/docsafari.css">
</head>
<body>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<tr><td><div STYLE="MARGIN-LEFT: 0.15in;"><a href="toc.html"><img src="images/teamlib.gif" width="62" height="15" border="0" align="absmiddle"  alt="Team LiB"></a></div></td>
<td align="right"><div STYLE="MARGIN-LEFT: 0.15in;">
<a href=pythoncook2-chp-6.html><img src="images/previous.gif" width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a>
<a href=pythoncook2-chp-6-sect-1.html><img src="images/next.gif" width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a>
</div></td></tr></table>
<br><table width="100%" border="0" cellspacing="0" cellpadding="0"><TR><td valign="top"><a name="ch06-77005"></a><h3 class="docSection1Title">Introduction</h3>

<p class="docText"><span class="docEmphasis">Credit: Alex Martelli, author of</span>
<span class="docEmphasis">Python in a Nutshell</span>
<span class="docEmphasis">(O'Reilly)</span></p>

<p class="docText">Object-oriented programming (OOP) is among Python's
greatest strengths. Python's OOP features continue
to improve steadily and gradually, just like Python in general. You
could already write better object-oriented programs in Python 1.5.2
(the ancient, long-stable version that was new when I first began to
work with Python) than in any other popular language (excluding, of
course, Lisp and its variants: I doubt there's
anything you can't do well in Lisp-like languages,
as long as you can stomach parentheses-heavy concrete syntax). For a
few years now, since the release of Python 2.2, Python OOP has become
substantially better than it was with 1.5.2. I am constantly amazed
at the systematic progress Python achieves without sacrificing
solidity, stability, and backwards-compatibility.<a name="pythoncook2-CHP-6-ITERM-1984"></a> <a name="pythoncook2-CHP-6-ITERM-1985"></a><a name="pythoncook2-CHP-6-ITERM-1986"></a></p>

<p class="docText">To get the most out of Python's great OOP features,
you should use them the Python way, rather than trying to mimic C++,
Java, Smalltalk, or other languages you may be familiar with. You can
do a lot of mimicry, thanks to Python's power.
However, you'll get better mileage if you invest
time and energy in understanding the Python way. Most of the
investment is in increasing your understanding of OOP itself: what
<span class="docEmphasis">is</span> OOP, what does it buy you, and which
underlying mechanisms can your object-oriented programs use? The rest
of the investment is in understanding the specific mechanisms that
Python itself offers.<a name="pythoncook2-CHP-6-ITERM-1987"></a></p>

<p class="docText"><a name="pythoncook2-CHP-6-ITERM-1988"></a>One caveat is in order. For such a
high-level language, Python is quite explicit about the OOP
mechanisms it uses behind the curtains: they're
exposed and available for your exploration and tinkering. Exploration
and understanding are good, but beware the temptation to tinker. In
other words, don't use unnecessary black magic just
because you can. Specifically, don't use black magic
in production code. If you can meet your goals with simplicity (and
most often, in Python, you can), then keep your code simple.
Simplicity pays off in readability, maintainability, and, more often
than not, performance, too. To describe something as clever is
<span class="docEmphasis">not</span> considered a compliment in the Python
culture.</P>

<p class="docText"><a name="pythoncook2-CHP-6-ITERM-1989"></a>
<a name="pythoncook2-CHP-6-ITERM-1990"></a>So what is OOP all about? First of
all, it's about keeping some
<i>state</I> (data) and some
<i>behavior</I> (code) together in handy packets.
"Handy packets" is the key here.
Every program has state and behaviorprogramming paradigms
differ only in how you view, organize, and package them. If the
packaging is in terms of objects that typically comprise state and
behavior, you're using OOP. Some object-oriented
languages force you to use OOP for everything, so you end up with
many objects that lack either state or behavior. Python, however,
supports multiple paradigms. While everything in Python is an object,
you package things as OOP objects only when you want to. Other
languages try to force your programming style into a predefined mold
for your own good, while Python empowers you to make and express your
own design choices.</p>

<p class="docText">With OOP, once you have specified how an object is composed, you can
instantiate as many objects of that kind as you need. When you
don't want to create multiple objects, consider
using other Python constructs, such as modules. In this chapter,
you'll find recipes for Singleton, an
object-oriented design pattern that eliminates the multiplicity of
instantiation, and Borg, an idiom that makes multiple instances share
state. But if you want only one instance, in Python
it's often best to use a module, not an OOP
object.<a name="pythoncook2-CHP-6-ITERM-1991"></a>
<a name="pythoncook2-CHP-6-ITERM-1992"></a> <a name="pythoncook2-CHP-6-ITERM-1993"></a> <a name="pythoncook2-CHP-6-ITERM-1994"></a>
<a name="pythoncook2-CHP-6-ITERM-1995"></a></P>

<p class="docText"><a name="pythoncook2-CHP-6-ITERM-1996"></a>
<a name="pythoncook2-CHP-6-ITERM-1997"></a>To describe how an object is made, use the
<tt>class</tt> statement:</P>

<pre>class SomeName(object):
    """ You usually define data and code here (in the class body). """</pre><br>


<p class="docText"><I>SomeName</I><a name="pythoncook2-CHP-6-ITERM-1998"></a>
<a name="pythoncook2-CHP-6-ITERM-1999"></a>
<a name="pythoncook2-CHP-6-ITERM-2000"></a> is a
<span class="docEmphasis">class object</span>. It's a
<i>first-class</i> object, like every Python object,
meaning that you can put it in lists and dictionaries, pass it as an
argument to functions, and so on. You don't
<span class="docEmphasis">have to</span> include the <tt>(object)</tt>
part in the <tt>class</tt> header
clause<tt>class SomeName</tt>: by itself is also
valid Python syntaxbut normally you
<span class="docEmphasis">should</span> include that part, as
we'll see later.</p>

<p class="docText"><a name="pythoncook2-CHP-6-ITERM-2001"></a>
<a name="pythoncook2-CHP-6-ITERM-2002"></a>When you want a new instance of a
class, call the class object as if it were a function. Each call
returns a new instance object:</p>

<pre>anInstance = SomeName( )
another = SomeName( )</pre><BR>


<p class="docText"><tt>anInstance</tt><a name="pythoncook2-CHP-6-ITERM-2003"></a> <a name="pythoncook2-CHP-6-ITERM-2004"></a>
<a name="pythoncook2-CHP-6-ITERM-2005"></a> and
<tt>another</tt> are two distinct <span class="docEmphasis">instance
objects</span>, instances of the <i>SomeName</i> class.
(See <a class="docLink" href="pythoncook2-CHP-4-SECT-18.html#pythoncook2-CHP-4-SECT-18">Recipe 4.18</a> for a
class that does little more than this and yet is already quite
useful.) You can freely <I>bind</i> (i.e., assign or
set) and <I>access</i> (i.e., get)
<I>attributes</I> (i.e., state) of an instance
object:</p>

<pre>anInstance.someNumber = 23 * 45
print anInstance.someNumber                # emits: <b>1035</b></pre><br>


<p class="docText">Instances of an "empty" class like
<i>SomeName</i> have no behavior, but they may have state.
Most often, however, you want instances to have behavior. Specify the
behavior you want by defining <i>methods</i> (with
<tt>def</tt> statements, just like you define functions)
inside the class
body:<a name="pythoncook2-CHP-6-ITERM-2006"></a></p>

<pre>class Behave(object):
    def _ _init_ _(self, name):
        self.name = name
    def once(self):
        print "Hello,", self.name
    def rename(self, newName)
        self.name = newName
    def repeat(self, N):
        for i in range(N): self.once( )</pre><br>


<p class="docText"><a name="pythoncook2-CHP-6-ITERM-2007"></a>You define methods with the same
<tt>def</tt> statement Python uses to define functions,
exactly because methods <span class="docEmphasis">are</span> essentially
functions. However, a method is an attribute of a class object, and
its first formal argument is (by universal convention) named
<tt>self</tt>. <tt>self</tt> always refers to the
instance on which you call the method.</p>

<p class="docText"><a name="pythoncook2-CHP-6-ITERM-2008"></a> <a name="pythoncook2-CHP-6-ITERM-2009"></a>The method with the special name
<tt>_ _init_ _</tt> is also known as the
<i>constructor</i> (or more properly the
<i>initializer</I>) for instances of the class.
Python calls this special method to initialize each newly created
instance with the arguments that you passed when calling the class
(except for <tt>self</tt>, which you do not pass explicitly
since Python supplies it automatically). The body of <tt>_
_init_ _</tt> typically binds attributes on the newly created
<tt>self</tt> instance to appropriately initialize the
instance's state.</P>

<p class="docText">Other methods implement the behavior of instances of the class.
Typically, they do so by accessing instance attributes. Also, methods
often rebind instance attributes, and they may call other methods.
Within a class definition, these actions are always done with the
<i>self.something</i> syntax. Once you instantiate the
class, however, you call methods on the instance, access the
instance's attributes, and even rebind them, using
the <I>theobject.something</i>
syntax:<a name="pythoncook2-CHP-6-ITERM-2010"></a> <a name="pythoncook2-CHP-6-ITERM-2011"></a>
<a name="pythoncook2-CHP-6-ITERM-2012"></a></p>

<pre>beehive = Behave("Queen Bee")
beehive.repeat(3)
beehive.rename("Stinger")
beehive.once( )
print beehive.name
beehive.name = 'See, you can rebind it "from the outside" too, if you want'
beehive.repeat(2)</pre><br>


<a name="pythoncook2-CHP-6-SIDEBAR-1"></a><p><table cellspacing="0" width="90%" border="1" cellpadding="5"><tr><td>
<H2 class="docSidebarTitle">self</h2>

<p class="docText">No true difference exists between what I described as the
<I>self.something</i> syntax and the
<I>theobject.something</i> syntax: the former is simply a
special case of the latter, when the name of reference
<I>theobject</I> happens to be <i>self</I>!</P>
</td></tr></table></p><br>

<p class="docText">If you're new to OOP in Python, you should try, in
an interactive Python environment, the example snippets I have shown
so far and those I'm going to show in the rest of
this Introduction. One of the best interactive Python environments
for such exploration is the GUI shell supplied as part of the free
IDLE development environment that comes with
Python.<a name="pythoncook2-CHP-6-ITERM-2013"></a></P>

<p class="docText"><a name="pythoncook2-CHP-6-ITERM-2014"></a> <a name="pythoncook2-CHP-6-ITERM-2015"></a>In addition to the constructor
(<tt>_ _init_ _</tt>), your class may have other special
methods, meaning methods with names that start and end with two
underscores. Python calls the special methods of a class when
instances of the class are used in various operations and built-in
functions. For example, <tt>len(x)</tt> returns
<tt>x._ _len_ _( )</tt>; <tt>a+b</tt> normally
returns <tt>a._ _add_ _(b)</tt>; <tt>a[b]</tt>
returns <tt>a._ _getitem_ _(b)</tt>. Therefore, by defining
special methods in a class, you can make instances of that class
interchangeable with objects of built-in types, such as numbers,
lists, and dictionaries.<a name="pythoncook2-CHP-6-ITERM-2016"></a></p>


<p><table border="0" bgcolor="black" cellspacing="0" cellpadding="1" width="90%" align="center"><TR><td><table bgcolor="white" width="100%" border="0" cellspacing="0" cellpadding="6"><TR><td width="60" valign="top"><img src="images/tip_yellow.gif" width="50" height="54" alt=""></TD><TD valign="top">
<p class="docText">Each operation and built-in function can try several special methods
in some specific order. For example, <tt>a+b</tt>
<span class="docEmphasis">first</span> tries <tt>a._ _add_ _(b)</tt>,
but, if that doesn't pan out, the operation also
gives object <tt><i>b</i></tt> a say in the matter, by
next trying <tt>b._ _radd_ _(a)</tt>. This kind of
intrinsic structuring among special methods, that operations and
built-in functions can provide, is an important added value of such
functions and operations with respect to pure OO notation such as
<tt>someobject.somemethod(arguments)</tt>.<a name="pythoncook2-CHP-6-ITERM-2017"></a>
<a name="pythoncook2-CHP-6-ITERM-2018"></a>
<a name="pythoncook2-CHP-6-ITERM-2019"></a></p>
</td></tr></table></td></tr></table></p><br>

<p class="docText"><a name="pythoncook2-CHP-6-ITERM-2020"></a> <a name="pythoncook2-CHP-6-ITERM-2021"></a>The ability to handle different objects in
similar ways, known as <i>polymorphism</i>, is a
major advantage of OOP. Thanks to polymorphism, you can call the same
method on various objects, and each object can implement the method
appropriately. For example, in addition to the
<i>Behave</i> class, you might have another class that
implements a <I>repeat</I> method with rather different
behavior:</p>

<pre>class Repeater(object):
    def repeat(self, N): print N*"*-*"</pre><br>


<p class="docText">You can mix instances of <I>Behave</i> and
<i>Repeater</i> at will, as long as the only method you
call on each such instance is <i>repeat</i>:</p>

<pre>aMix = beehive, Behave('John'), Repeater( ), Behave('world')
for whatever in aMix: whatever.repeat(3)</pre><BR>


<p class="docText"><a name="pythoncook2-CHP-6-ITERM-2022"></a>
<a name="pythoncook2-CHP-6-ITERM-2023"></a>
<a name="pythoncook2-CHP-6-ITERM-2024"></a>
<a name="pythoncook2-CHP-6-ITERM-2025"></a>Other
languages require inheritance, or the formal definition and
implementation of interfaces, in order to enable such polymorphism.
In Python, all you need is to have methods with the same
<i>signature</I> (i.e., methods of the same name,
callable with the same arguments). This <i>signature-based
polymorphism</I> allows a style of programming
that's quite similar to <i>generic
programming</I> (e.g., as supported by C++'s
<tt>template</tt> classes and functions), without syntax
cruft and without conceptual complications.</P>

<p class="docText"><a name="pythoncook2-CHP-6-ITERM-2026"></a>
<a name="pythoncook2-CHP-6-ITERM-2027"></a>
<a name="pythoncook2-CHP-6-ITERM-2028"></a>
<a name="pythoncook2-CHP-6-ITERM-2029"></a>
<a name="pythoncook2-CHP-6-ITERM-2030"></a>
<a name="pythoncook2-CHP-6-ITERM-2031"></a>Python
also uses <span class="docEmphasis">inheritance</span>, which is mostly a handy,
elegant, structured way to reuse code. You can define a class by
inheriting from another (i.e., <i>subclassing</I> the
other class) and then adding or redefining (known as
<I>overriding</i>) some methods:</p>

<pre>class Subclass(Behave):
    def once(self): print '(%s)' % self.name
subInstance = Subclass("Queen Bee")
subInstance.repeat(3)</pre><br>


<p class="docText"><a name="pythoncook2-CHP-6-ITERM-2032"></a>
<a name="pythoncook2-CHP-6-ITERM-2033"></a> <a name="pythoncook2-CHP-6-ITERM-2034"></a>
<a name="pythoncook2-CHP-6-ITERM-2035"></a>The <i>Subclass</I>
class overrides only the <i>once</i> method, but you can
also call the <I>repeat</i> method on
<tt><I>subInstance</i></tt>, since
<I>Subclass</I> inherits that method from the
<i>Behave</i> superclass. The body of the
<i>repeat</i> method calls <i>once</i>
<span class="docEmphasis">n</span> times on the specific instance, using whatever
version of the <i>once</i> method the instance has. In this
case, each call uses the method from the <i>Subclass</i>
class, which prints the name in parentheses, not the original version
from the <i>Behave</i> class, which prints the name after a
greeting. The idea of a method calling other methods on the same
instance and getting the appropriately overridden version of each is
important in every object-oriented language, including Python. It is
also known as the Template Method Design
Pattern.<a name="pythoncook2-CHP-6-ITERM-2036"></a>
<a name="pythoncook2-CHP-6-ITERM-2037"></a>
<a name="pythoncook2-CHP-6-ITERM-2038"></a>
<a name="pythoncook2-CHP-6-ITERM-2039"></a></p>

<p class="docText"><a name="pythoncook2-CHP-6-ITERM-2040"></a>
<a name="pythoncook2-CHP-6-ITERM-2041"></a>The
method of a subclass often overrides a method from the superclass,
but also needs to call the method of the superclass as part of its
own operation. You can do this in Python by explicitly getting the
method as a class attribute and passing the instance as the first
argument:</P>

<pre>class OneMore(Behave):
    def repeat(self, N): Behave.repeat(self, N+1)
zealant = OneMore("Worker Bee")
zealant.repeat(3)</pre><BR>


<p class="docText"><a name="pythoncook2-CHP-6-ITERM-2042"></a>
<a name="pythoncook2-CHP-6-ITERM-2043"></a>
<a name="pythoncook2-CHP-6-ITERM-2044"></a>The <i>OneMore</i> class
implements its own <I>repeat</i> method in terms of the
method with the same name in its superclass, <i>Behave</i>,
with a slight change. This approach, known as
<i>delegation</i>, is pervasive in all programming.
Delegation involves implementing some functionality by letting
another existing piece of code do most of the work, often with some
slight variation. An overriding method often is best implemented by
delegating some of the work to the same method in the superclass. In
Python, the syntax <tt>Classname.method(self</tt>, . .
.<tt>)</tt> delegates to
<i>Classname</I>'s version of the method.
A <span class="docEmphasis">vastly</span> preferable way to perform superclass
delegation, however, is to use Python's built-in
<tt>super</tt>:<a name="pythoncook2-CHP-6-ITERM-2045"></a></p>

<pre>class OneMore(Behave):
    def repeat(self, N): super(OneMore, self).repeat(N+1)</pre><BR>


<p class="docText">This <tt>super</tt> construct is equivalent to the explicit
use of <tt>Behave.repeat</tt> in this simple case, but it
also allows class <i>OneMore</I> to be used smoothly with
<i>multiple inheritance</I>. Even if
you're not interested in multiple inheritance at
first, you should still get into the habit of using
<tt>super</tt> instead of explicit delegation to your base
class by name<tt>super</tt> costs nothing and it may
prove very useful to you in the future.</P>

<p class="docText"><a name="pythoncook2-CHP-6-ITERM-2046"></a>
<a name="pythoncook2-CHP-6-ITERM-2047"></a>
<a name="pythoncook2-CHP-6-ITERM-2048"></a>Python does fully support multiple
inheritance: one class can inherit from several other classes. In
terms of coding, this feature is sometimes just a minor one that lets
you use the mix-in class idiom, a convenient way to supply
functionality across a broad range of classes. (See <a class="docLink" href="pythoncook2-CHP-6-SECT-20.html#pythoncook2-CHP-6-SECT-20">Recipe 6.20</a> and <a class="docLink" href="pythoncook2-CHP-6-SECT-12.html#pythoncook2-CHP-6-SECT-12">Recipe 6.12</a>, for unusual but powerful
examples of using the mix-in idiom.) However, multiple inheritance is
particularly important because of its implications for
object-oriented analysisthe way you conceptualize your problem
and your solution in the first place. Single inheritance pushes you
to frame your problem space via taxonomy (i.e., mutually exclusive
classification). The real world doesn't work like
that. Rather, it resembles Jorge Luis Borges'
explanation in <span class="docEmphasis">The Analytical Language of John
Wilkins</span>, from a purported Chinese encyclopedia,
<span class="docEmphasis">The Celestial Emporium of Benevolent
Knowledge</span>. Borges explains that all animals are divided
into:</p>

<UL><LI><p class="docList">Those that belong to the Emperor</p></li><li><p class="docList">Embalmed ones</p></LI><li><p class="docList">Those that are trained</p></LI><li><p class="docList">Suckling pigs</P></li><LI><p class="docList">Mermaids</P></li><li><p class="docList">Fabulous ones</p></li><li><p class="docList">Stray dogs</p></li><li><p class="docList">Those included in the present classification</p></li><li><p class="docList">Those that tremble as if they were mad</p></li><LI><p class="docList">Innumerable ones</P></li><li><p class="docList">Those drawn with a very fine camelhair brush</P></li><li><p class="docList">Others</p></li><li><p class="docList">Those that have just broken a flower vase</p></LI><li><p class="docList">Those that from a long way off look like flies</P></li></UL>
<p class="docText">You get the point: taxonomy forces you to pigeonhole, fitting
everything into categories that aren't truly
mutually exclusive. Modeling aspects of the real world in your
programs is hard enough without buying into artificial constraints
such as taxonomy. Multiple inheritance frees you from these
constraints.</p>

<p class="docText"><a name="pythoncook2-CHP-6-ITERM-2049"></a>Ah, yes, that
<tt>(object)</tt> thingI <span class="docEmphasis">had</span>
promised to come back to it later. Now that you've
seen Python's notation for inheritance, you realize
that writing <tt>class</tt> <tt>X(object)</tt>
means that class <I>X</I> inherits from class
<tt>object</tt>. If you just write <tt>class
Y</tt>:, you're saying that <i>Y</I>
doesn't inherit from
anything<I>Y</i>, so to speak,
"stands on its own". For backwards
compatibility, Python allows you to request such a <span class="docEmphasis">rootless
class</span>, and, if you do, then Python makes class
<i>Y</i> an "old-style"
class, also known as a <i>classic</I> class, meaning
a class that works just like all classes used to work in the Python
versions of old. Python is very keen on backwards-compatibility.</p>

<p class="docText"><a name="pythoncook2-CHP-6-ITERM-2050"></a> <a name="pythoncook2-CHP-6-ITERM-2051"></a> <a name="pythoncook2-CHP-6-ITERM-2052"></a>For many elementary uses, you
won't notice the difference between classic classes
and the new-style classes that are recommended for all new Python
code you write. However, it's important to
underscore that classic classes are a <span class="docEmphasis">legacy</span>
feature, <span class="docEmphasis">not</span> recommended for new code. Even
within the limited compass of elementary OOP features that I cover in
this Introduction, you will already feel some of the limitations of
classic classes: for example, you cannot use <tt>super</tt>
within classic classes, and in practice, you should not do any
serious use of multiple inheritance with them. Many important
features of today's Python OOP, such as the
<tt>property</tt> built-in, can't work
completely, if they even work at all, with old-style classes.</p>

<p class="docText"><a name="pythoncook2-CHP-6-ITERM-2053"></a>
<a name="pythoncook2-CHP-6-ITERM-2054"></a>In
practice, even if you're maintaining a large body of
legacy Python code, the next time you need to do any substantial
maintenance on that code, you should take the little effort required
to ensure all classes are new style: it's a small
job, and it will ease your future maintenance burden quite a bit.
Instead of explicitly having all your classes inherit from
<tt>object</tt>, an equivalent alternative is to add the
following assignment statement close to the start of every module
that defines any
classes:<a name="pythoncook2-CHP-6-ITERM-2055"></a></P>

<pre>_ _metaclass_ _ = type</pre><br>


<p class="docText"><a name="pythoncook2-CHP-6-ITERM-2056"></a>The built-in <tt>type</tt>
is the metaclass of <tt>object</tt> and of every other
new-style class and built-in <tt>type</tt>.
That's why inheriting from <tt>object</tt>
or any built-in <tt>type</tt> makes a class new style: the
class you're coding gets the same metaclass as its
base. A class without bases can get its metaclass from the
module-global <tt>_ _metaclass_ _</tt> variable, which is
why the "state"ment I suggest
suffices to ensure that any classes without explicit bases are made
new-style. Even if you never make any other use of explicit
metaclasses (a rather advanced subject that is, nevertheless,
mentioned in several of this chapter's recipes),
this one simple use of them will stand you in good stead.</P>

<a name="pythoncook2-CHP-6-SIDEBAR-2"></a><p><table cellspacing="0" width="90%" border="1" cellpadding="5"><TR><TD>
<h2 class="docSidebarTitle">What Is a Metaclass?</h2>

<p class="docText"><a name="pythoncook2-CHP-6-ITERM-2057"></a>
<a name="pythoncook2-CHP-6-ITERM-2058"></a>
<a name="pythoncook2-CHP-6-ITERM-2059"></a>Metaclasses do not mean
"deep, dark black magic". When you
execute any <tt>class</tt> statement, Python performs the
following steps:</p>

<p class="docText">Remember the class name as a string, say
<tt><i>n</i></tt>, and the class bases as a tuple, say
<tt><i>b</i></tt>.</p>

<p class="docText">Execute the body of the class, recording all names that the body
binds as keys in a new dictionary <tt><i>d</i></tt>, each
with its associated value (e.g., each statement such as <tt>def
f(self)</tt> just sets <tt>d['f']</tt> to the function
object the <tt>def</tt> statement builds).</p>

<p class="docText">Determine the appropriate metaclass, say
<tt><i>M</i></tt>, by inheritance or by looking for name
<tt>_ _metaclass_ _</tt> in <tt><I>d</I></tt>
and in the globals:</p>

<pre>if '_ _metaclass_ _' in d: M = d['_ _metaclass_ _']
elif b: M = type(b[0])
elif '_ _metaclass_ _' in globals( ): M = globals( )['_ _metaclass_ _']
else: M = types.ClassType</pre><br>


<p class="docText"><tt>types.ClassType</tt> is the metaclass of old-style
classes, so this code implies that a class without bases is old style
if the name '<tt>_ _metaclass_ _</tt>' is not set in the
class body nor among the global variables of the current module.</P>

<p class="docText">Call <tt>M(n, b, d)</tt> and record the result as a
variable with name <tt><i>n</i></tt> in whatever scope the
<tt>class</tt> statement executed.</p>

<p class="docText">So, some metaclass <tt><i>M</i></tt> is
<span class="docEmphasis">always</span> involved in the execution of any
<tt>class</tt> statement. The metaclass is normally
<tt>type</tt> for new-style classes,
<tt>types.ClassType</tt> for old-style classes. You can set
it up to use your own <i>custom</I> metaclass
(normally a subclass of <tt>type</tt>), and
<span class="docEmphasis">that</span> is where you may reasonably feel that
things are getting a bit too advanced. However, understanding that a
<tt>class</tt> statement, such as:</p>

<pre>class Someclass(Somebase):
    _ _metaclass_ _ = type
    x = 23</pre><BR>


<p class="docText">is exactly equivalent to the assignment statement:</p>

<pre>Someclass = type('Someclass', (Somebase,), {'x': 23})</pre><BR>


<p class="docText">does help a lot in understanding the exact semantics of the
<tt>class</tt> statement.</p>
</TD></TR></table></p><BR>


<a href="5991535.html"><img src="images/pixel.gif" alt="" width="1" height="1" border="0"></a><UL></ul></td></tr></table>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<tr><td><div STYLE="MARGIN-LEFT: 0.15in;"><a href="toc.html"><img src="images/teamlib.gif" width="62" height="15" border="0" align="absmiddle"  alt="Team LiB"></a></div></td>
<td align="right"><div STYLE="MARGIN-LEFT: 0.15in;">
<a href=pythoncook2-chp-6.html><img src="images/previous.gif" width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a>
<a href=pythoncook2-chp-6-sect-1.html><img src="images/next.gif" width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a>
</div></td></tr></table>
</body></html>