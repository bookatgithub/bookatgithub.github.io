<HTML
><HEAD
>
<TITLE>[Appendix B] B.3 Command Summary for awk</TITLE>
<META
NAME="DC.title"
CONTENT="sed &amp; awk"><META
NAME="DC.creator"
CONTENT="Dale Dougherty &amp; Arnold Robbins"><META
NAME="DC.publisher"
CONTENT="O'Reilly &amp; Associates, Inc."><META
NAME="DC.date"
CONTENT="1998-08-03T21:06:51Z"><META
NAME="DC.type"
CONTENT="Text.Monograph"><META
NAME="DC.format"
CONTENT="text/html"
SCHEME="MIME"><META
NAME="DC.source"
CONTENT="1-56592-225-5"
SCHEME="ISBN"><META
NAME="DC.language"
CONTENT="en-US"><META
NAME="generator"
CONTENT="Jade 1.1/O'Reilly DocBook 3.0 to HTML 4.0"><LINK
REV="made"
HREF="mailto:online-books@oreilly.com"
TITLE="Online Books Comments"><LINK
REL="up"
HREF="appb_01.htm"
TITLE="B. Quick Reference for awk"><LINK
REL="prev"
HREF="appb_02.htm"
TITLE="B.2 Language Summary for awk"><LINK
REL="next"
HREF="appc_01.htm"
TITLE="C. Supplement for Chapter 12"></HEAD
><BODY
BGCOLOR="#FFFFFF"
TEXT="#000000"
><DIV
CLASS="htmlnav"
><H1
><IMG
SRC="gifs/smbanner.gif"
ALT="sed &amp; awk"
USEMAP="#srchmap"
BORDER="0"></H1
><MAP
NAME="srchmap"
><AREA
SHAPE="RECT"
COORDS="0,0,466,65"
HREF="index.htm"
ALT="sed &amp; awk"><AREA
SHAPE="RECT"
COORDS="467,0,514,18"
HREF="../search/ssrch.htm"
ALT="Search this book"></MAP
><TABLE
WIDTH="515"
BORDER="0"
CELLSPACING="0"
CELLPADDING="0"
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="172"
><A
CLASS="SECT1"
HREF="appb_02.htm"
TITLE="B.2 Language Summary for awk"
><IMG
SRC="../gifs/txtpreva.gif"
ALT="Previous: B.2 Language Summary for awk"
BORDER="0"></A
></TD
><TD
ALIGN="CENTER"
VALIGN="TOP"
WIDTH="171"
><B
><FONT
FACE="ARIEL,HELVETICA,HELV,SANSERIF"
SIZE="-1"
>Appendix B<BR>Quick Reference for awk</FONT
></B
></TD
><TD
ALIGN="RIGHT"
VALIGN="TOP"
WIDTH="172"
><A
CLASS="APPENDIX"
HREF="appc_01.htm"
TITLE="C. Supplement for Chapter 12"
><IMG
SRC="../gifs/txtnexta.gif"
ALT="Next: C. Supplement for Chapter 12"
BORDER="0"></A
></TD
></TR
></TABLE
>&nbsp;<HR
ALIGN="LEFT"
WIDTH="515"
TITLE="footer"></DIV
><DIV
CLASS="SECT1"
><H2
CLASS="sect1"
><A
CLASS="title"
NAME="SEDAWK-APP-B-SECT-3"
>B.3 Command Summary for awk</A
></H2
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="B.AWK2"
></A
><A
CLASS="indexterm"
NAME="B.AWK3"
></A
>The following alphabetical list of statements and functions includes
all that are available in POSIX awk, nawk, or gawk.  See 
<A
CLASS="xref"
HREF="ch11_01.htm"
TITLE="A Flock of awks"
>Chapter 11, A Flock of awks</A
>, for extensions available in different
implementations.</P
><DL
CLASS="variablelist"
><DT
CLASS="term"
><KBD
CLASS="command"
>atan2()</KBD
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
><KBD
CLASS="command"
>atan2</KBD
>(<EM
CLASS="emphasis"
>y</EM
>, <EM
CLASS="emphasis"
>x</EM
>)</P
><P
CLASS="para"
>Returns the arctangent of
<EM
CLASS="emphasis"
>y</EM
>/<EM
CLASS="emphasis"
>x</EM
> in radians.</P
></DD
><DT
CLASS="term"
><KBD
CLASS="command"
>break</KBD
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
>Exit from a <KBD
CLASS="command"
>while</KBD
>, <KBD
CLASS="command"
>for</KBD
>, or
<KBD
CLASS="command"
>do</KBD
> loop.</P
></DD
><DT
CLASS="term"
><KBD
CLASS="command"
>close()</KBD
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
><KBD
CLASS="command"
>close</KBD
>(<EM
CLASS="emphasis"
>filename-expr</EM
>)</P
><P
CLASS="para"
><KBD
CLASS="command"
>close</KBD
>(<EM
CLASS="emphasis"
>command-expr</EM
>)</P
><P
CLASS="para"
>In most implementations of awk, you can only have a limited number of
files and/or pipes open simultaneously.  Therefore, awk provides a
<KBD
CLASS="command"
>close()</KBD
> function that allows you to close a
file or a pipe.  It takes as an argument the same expression that
opened the pipe or file.  This expression must be identical, character
by character, to the one that opened the file or pipe&nbsp;- even whitespace
is significant.</P
></DD
><DT
CLASS="term"
><KBD
CLASS="command"
>continue</KBD
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
>Begin next iteration of <KBD
CLASS="command"
>while</KBD
>,
<KBD
CLASS="command"
>for</KBD
>, or <KBD
CLASS="command"
>do</KBD
> loop.</P
></DD
><DT
CLASS="term"
><KBD
CLASS="command"
>cos()</KBD
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
><KBD
CLASS="command"
>cos</KBD
>(<EM
CLASS="emphasis"
>x</EM
>)</P
><P
CLASS="para"
>Return cosine of <EM
CLASS="emphasis"
>x</EM
> in radians. </P
></DD
><DT
CLASS="term"
><KBD
CLASS="command"
>delete</KBD
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
><KBD
CLASS="command"
>delete</KBD
> <EM
CLASS="emphasis"
>array</EM
>[<EM
CLASS="emphasis"
>element</EM
>]</P
><P
CLASS="para"
>Delete element of an array.</P
></DD
><DT
CLASS="term"
><KBD
CLASS="command"
>do</KBD
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
><KBD
CLASS="command"
>do</KBD
></P
><P
CLASS="para"
> <EM
CLASS="emphasis"
>body</EM
></P
><P
CLASS="para"
><KBD
CLASS="command"
>while</KBD
> (<EM
CLASS="emphasis"
>expr</EM
>) </P
><P
CLASS="para"
>Looping statement.  Execute statements in
<EM
CLASS="emphasis"
>body</EM
> then evaluate
<EM
CLASS="emphasis"
>expr</EM
> and if true, execute
<EM
CLASS="emphasis"
>body</EM
> again.</P
></DD
><DT
CLASS="term"
><KBD
CLASS="command"
>exit</KBD
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
><KBD
CLASS="command"
>exit</KBD
> [<EM
CLASS="emphasis"
>expr</EM
>]</P
><P
CLASS="para"
>Exit from script, reading no new input.  The <KBD
CLASS="command"
>END</KBD
> rule,
if it exists, will be executed. An optional <EM
CLASS="emphasis"
>expr</EM
>
becomes awk's return value.</P
></DD
><DT
CLASS="term"
><KBD
CLASS="command"
>exp()</KBD
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
><KBD
CLASS="command"
>exp</KBD
>(<EM
CLASS="emphasis"
>x</EM
>)</P
><P
CLASS="para"
>Return exponential of <EM
CLASS="emphasis"
>x</EM
>
(<EM
CLASS="emphasis"
>e</EM
> ^ <EM
CLASS="emphasis"
>x</EM
>).</P
></DD
><DT
CLASS="term"
><KBD
CLASS="command"
>for</KBD
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
><KBD
CLASS="command"
>for</KBD
> (<EM
CLASS="emphasis"
>init-expr</EM
>; <EM
CLASS="emphasis"
>test-expr</EM
>; <EM
CLASS="emphasis"
>incr-expr</EM
>) <EM
CLASS="emphasis"
>statement</EM
></P
><P
CLASS="para"
>C-style looping construct.  <EM
CLASS="emphasis"
>init-expr</EM
>
assigns the initial value of the counter
variable. <EM
CLASS="emphasis"
>test-expr</EM
> is a relational
expression that is evaluated each time before executing the
statement. When <EM
CLASS="emphasis"
>test-expr</EM
> is false, the
loop is exited. <EM
CLASS="emphasis"
>incr-expr</EM
> is used to
increment the counter variable after each pass.</P
><P
CLASS="para"
><KBD
CLASS="command"
>for</KBD
> (<EM
CLASS="emphasis"
>item</EM
> <KBD
CLASS="command"
>in</KBD
> <EM
CLASS="emphasis"
>array</EM
>) <EM
CLASS="emphasis"
>statement</EM
></P
><P
CLASS="para"
>Special loop designed for reading associative arrays.  For each
element of the array, the <EM
CLASS="emphasis"
>statement</EM
> is
executed; the element can be referenced by
<EM
CLASS="emphasis"
>array</EM
>[<EM
CLASS="emphasis"
>item</EM
>].</P
></DD
><DT
CLASS="term"
><KBD
CLASS="command"
>getline</KBD
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
>Read next line of input.</P
><P
CLASS="para"
><KBD
CLASS="command"
>getline</KBD
> [<EM
CLASS="emphasis"
>var</EM
>] [&lt;<EM
CLASS="emphasis"
>file</EM
>]</P
><P
CLASS="para"
><EM
CLASS="emphasis"
>command</EM
> | <KBD
CLASS="command"
>getline</KBD
> [<EM
CLASS="emphasis"
>var</EM
>] </P
><P
CLASS="para"
>The first form reads input from <EM
CLASS="emphasis"
>file</EM
> and the
second form reads the output of <EM
CLASS="emphasis"
>command</EM
>.  Both
forms read one line at a time, and each time the statement is executed
it gets the next line of input.  The line of input is assigned to $0
and it is parsed into fields, setting <KBD
CLASS="command"
>NF</KBD
>,
<KBD
CLASS="command"
>NR</KBD
>, and <KBD
CLASS="command"
>FNR</KBD
>.  If
<EM
CLASS="emphasis"
>var</EM
> is specified, the result is assigned to
<EM
CLASS="emphasis"
>var</EM
> and the $0 is not changed.  Thus, if the
result is assigned to a variable, the current line does not change.
<KBD
CLASS="command"
>getline</KBD
> is actually a function and it returns 1 if
it reads a record successfully, 0 if end-of-line is encountered, and
-1 if for some reason it is otherwise unsuccessful.</P
></DD
><DT
CLASS="term"
><KBD
CLASS="command"
>gsub()</KBD
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
><KBD
CLASS="command"
>gsub</KBD
>(<EM
CLASS="emphasis"
>r</EM
>, <EM
CLASS="emphasis"
>s</EM
>, <EM
CLASS="emphasis"
>t</EM
>)</P
><P
CLASS="para"
>Globally substitute <EM
CLASS="emphasis"
>s</EM
> for each match of the
regular expression <EM
CLASS="emphasis"
>r</EM
> in the string
<EM
CLASS="emphasis"
>t</EM
>.  Return the number of substitutions.  If
<EM
CLASS="emphasis"
>t</EM
> is not supplied, defaults to $0.</P
></DD
><DT
CLASS="term"
><KBD
CLASS="command"
>if</KBD
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
><KBD
CLASS="command"
>if</KBD
> (<EM
CLASS="emphasis"
>expr</EM
>) <EM
CLASS="emphasis"
>statement1</EM
></P
><P
CLASS="para"
>[ <KBD
CLASS="command"
>else</KBD
> <EM
CLASS="emphasis"
>statement2</EM
> ]</P
><P
CLASS="para"
>Conditional statement.  Evaluate <EM
CLASS="emphasis"
>expr</EM
> and,
if true, execute <EM
CLASS="emphasis"
>statement1</EM
>; if
<KBD
CLASS="command"
>else</KBD
> clause is supplied, execute
<EM
CLASS="emphasis"
>statement2</EM
> if
<EM
CLASS="emphasis"
>expr</EM
> is false.</P
></DD
><DT
CLASS="term"
><KBD
CLASS="command"
>index()</KBD
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
><KBD
CLASS="command"
>index</KBD
>(<EM
CLASS="emphasis"
>str</EM
>, <EM
CLASS="emphasis"
>substr</EM
>)</P
><P
CLASS="para"
>Return position (starting at 1) of substring in string.</P
></DD
><DT
CLASS="term"
><KBD
CLASS="command"
>int()</KBD
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
><KBD
CLASS="command"
>int</KBD
>(<EM
CLASS="emphasis"
>x</EM
>)</P
><P
CLASS="para"
>Return integer value of <EM
CLASS="emphasis"
>x</EM
> by truncating any
digits following a decimal point.</P
></DD
><DT
CLASS="term"
><KBD
CLASS="command"
>length()</KBD
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
><KBD
CLASS="command"
>length</KBD
>(<EM
CLASS="emphasis"
>str</EM
>)</P
><P
CLASS="para"
>Return length of string, or the length of $0 if no argument.</P
></DD
><DT
CLASS="term"
><KBD
CLASS="command"
>log()</KBD
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
><KBD
CLASS="command"
>log</KBD
>(<EM
CLASS="emphasis"
>x</EM
>)</P
><P
CLASS="para"
>Return natural logarithm (base <EM
CLASS="emphasis"
>e</EM
>) of
<EM
CLASS="emphasis"
>x</EM
>.</P
></DD
><DT
CLASS="term"
><KBD
CLASS="command"
>match()</KBD
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
><KBD
CLASS="command"
>match</KBD
>(<EM
CLASS="emphasis"
>s</EM
>, <EM
CLASS="emphasis"
>r</EM
>)</P
><P
CLASS="para"
>Function that matches the pattern, specified by the regular expression
<EM
CLASS="emphasis"
>r</EM
>, in the string
<EM
CLASS="emphasis"
>s</EM
> and returns either the position in
<EM
CLASS="emphasis"
>s</EM
> where the match begins, or 0 if no
occurrences are found.  Sets the values of <KBD
CLASS="command"
>RSTART</KBD
>
and <KBD
CLASS="command"
>RLENGTH</KBD
> to the start and length of the match,
respectively.</P
></DD
><DT
CLASS="term"
><KBD
CLASS="command"
>next</KBD
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
>Read next input line and begin executing script at first rule.</P
></DD
><DT
CLASS="term"
><KBD
CLASS="command"
>print</KBD
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
><KBD
CLASS="command"
>print</KBD
> [ <EM
CLASS="emphasis"
>output-expr</EM
> ] [ <EM
CLASS="emphasis"
>dest-expr</EM
> ]</P
><P
CLASS="para"
>Evaluate the <EM
CLASS="emphasis"
>output-expr</EM
> and direct it to
standard output followed by the value of <KBD
CLASS="command"
>ORS</KBD
>.  Each
<EM
CLASS="emphasis"
>output-expr</EM
> is separated by the value of
<KBD
CLASS="command"
>OFS</KBD
>.  <EM
CLASS="emphasis"
>dest-expr</EM
> is an
optional expression that directs the output to a file or pipe.  &quot;&gt;
<EM
CLASS="emphasis"
>file</EM
>&quot; directs the output to a file,
overwriting its previous contents.  &quot;&gt;&gt;
<EM
CLASS="emphasis"
>file</EM
>&quot; appends the output to a file,
preserving its previous contents.  In both of these cases, the file will be
created if it does not already exist.  &quot;| <EM
CLASS="emphasis"
>command</EM
>&quot;
directs the output as the input to a system command.</P
></DD
><DT
CLASS="term"
><KBD
CLASS="command"
>printf</KBD
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
><KBD
CLASS="command"
>printf</KBD
> (<EM
CLASS="emphasis"
>format-expr</EM
> [, <EM
CLASS="emphasis"
>expr-list</EM
> ]) [ <EM
CLASS="emphasis"
>dest-expr</EM
> ]</P
><P
CLASS="para"
>An alternative output statement borrowed from the C language.  It has
the ability to produce formatted output.  It can also be used to
output data without automatically producing a newline.
<EM
CLASS="emphasis"
>format-expr</EM
> is a string of format
specifications and constants; see next section for a list of format
specifiers.  <EM
CLASS="emphasis"
>expr-list</EM
> is a list of
arguments corresponding to format specifiers.  See the
<KBD
CLASS="command"
>print</KBD
> statement for a description of
<EM
CLASS="emphasis"
>dest-expr</EM
>.</P
></DD
><DT
CLASS="term"
><KBD
CLASS="command"
>rand()</KBD
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
><KBD
CLASS="command"
>rand()</KBD
></P
><P
CLASS="para"
>Generate a random number between 0 and 1.  This function returns the
same series of numbers each time the script is executed, unless the
random number generator is seeded using the
<KBD
CLASS="command"
>srand()</KBD
> function.</P
></DD
><DT
CLASS="term"
><KBD
CLASS="command"
>return</KBD
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
><KBD
CLASS="command"
>return</KBD
> [<EM
CLASS="emphasis"
>expr</EM
>]</P
><P
CLASS="para"
>Used at end of user-defined functions to exit function, returning
value of expression.</P
></DD
><DT
CLASS="term"
><KBD
CLASS="command"
>sin()</KBD
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
><KBD
CLASS="command"
>sin</KBD
>(<EM
CLASS="emphasis"
>x</EM
>)</P
><P
CLASS="para"
>Return sine of <EM
CLASS="emphasis"
>x</EM
> in radians.</P
></DD
><DT
CLASS="term"
><KBD
CLASS="command"
>split()</KBD
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
><KBD
CLASS="command"
>split</KBD
>(<EM
CLASS="emphasis"
>str</EM
>, <EM
CLASS="emphasis"
>array</EM
>, <EM
CLASS="emphasis"
>sep</EM
>)</P
><P
CLASS="para"
>Function that parses string into elements of array using field
separator, returning number of elements in array.  Value of
<KBD
CLASS="command"
>FS</KBD
> is used if no field separator is specified.
Array splitting works the same as field splitting.</P
></DD
><DT
CLASS="term"
><KBD
CLASS="command"
>sprintf()</KBD
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
><KBD
CLASS="command"
>sprintf</KBD
> (<EM
CLASS="emphasis"
>format-expr</EM
> [, <EM
CLASS="emphasis"
>expr-list</EM
> ] )</P
><P
CLASS="para"
>Function that returns string formatted according to
<KBD
CLASS="command"
>printf</KBD
> format specification. It formats data but
does not output it.  <EM
CLASS="emphasis"
>format-expr</EM
> is a
string of format specifications and constants; see the next section for a
list of format specifiers.  <EM
CLASS="emphasis"
>expr-list</EM
> is a
list of arguments corresponding to format specifiers.</P
></DD
><DT
CLASS="term"
><KBD
CLASS="command"
>sqrt()</KBD
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
><KBD
CLASS="command"
>sqrt</KBD
>(<EM
CLASS="emphasis"
>x</EM
>)</P
><P
CLASS="para"
>Return square root of <EM
CLASS="emphasis"
>x</EM
>.</P
></DD
><DT
CLASS="term"
><KBD
CLASS="command"
>srand()</KBD
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
><KBD
CLASS="command"
>srand</KBD
>(<EM
CLASS="emphasis"
>expr</EM
>)</P
><P
CLASS="para"
>Use <EM
CLASS="emphasis"
>expr</EM
> to set a new seed for random
number generator.  Default is time of day.  Return value is the old
seed.</P
></DD
><DT
CLASS="term"
><KBD
CLASS="command"
>sub()</KBD
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
><KBD
CLASS="command"
>sub</KBD
>(<EM
CLASS="emphasis"
>r</EM
>, <EM
CLASS="emphasis"
>s</EM
>, <EM
CLASS="emphasis"
>t</EM
>)</P
><P
CLASS="para"
>Substitute <EM
CLASS="emphasis"
>s</EM
> for first match of the regular
expression <EM
CLASS="emphasis"
>r</EM
> in the string
<EM
CLASS="emphasis"
>t</EM
>.  Return 1 if successful; 0 otherwise.
If <EM
CLASS="emphasis"
>t</EM
> is not supplied, defaults to $0.</P
></DD
><DT
CLASS="term"
><KBD
CLASS="command"
>substr()</KBD
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
><KBD
CLASS="command"
>substr</KBD
>(<EM
CLASS="emphasis"
>str</EM
>, <EM
CLASS="emphasis"
>beg</EM
>, <EM
CLASS="emphasis"
>len</EM
>)</P
><P
CLASS="para"
>Return substring of string <EM
CLASS="emphasis"
>str</EM
> at beginning
position <EM
CLASS="emphasis"
>beg</EM
>, and the characters that
follow to maximum specified length <EM
CLASS="emphasis"
>len</EM
>.  If
no length is given, use the rest of the string.</P
></DD
><DT
CLASS="term"
><KBD
CLASS="command"
>system()</KBD
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
><KBD
CLASS="command"
>system</KBD
>(<EM
CLASS="emphasis"
>command</EM
>)</P
><P
CLASS="para"
>Function that executes the specified
<EM
CLASS="emphasis"
>command</EM
> and returns its status.  The status
of the executed command typically indicates success or failure.  A
value of 0 means that the command executed successfully. A non-zero
value, whether positive or negative, indicates a failure of some sort.
The documentation for the command you're running will give you the
details.  The output of the command is not available for processing
within the awk script.  Use &quot;<EM
CLASS="emphasis"
>command</EM
>
<KBD
CLASS="command"
>| getline</KBD
>&quot; to read the output of a command into
the script.</P
></DD
><DT
CLASS="term"
><KBD
CLASS="command"
>tolower()</KBD
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
><KBD
CLASS="command"
>tolower</KBD
>(<EM
CLASS="emphasis"
>str</EM
>)</P
><P
CLASS="para"
>Translate all uppercase characters in <EM
CLASS="emphasis"
>str</EM
>
to lowercase and return the new string.[3]</P
><BLOCKQUOTE
CLASS="footnote"
><P
CLASS="para"
>[3] Very early versions of nawk, such as that in SunOS 4.1.x, don't
support <KBD
CLASS="command"
>tolower()</KBD
> and
<KBD
CLASS="command"
>toupper()</KBD
>. However, they are now part of
the POSIX specification for awk.  </P
></BLOCKQUOTE
></DD
><DT
CLASS="term"
><KBD
CLASS="command"
>toupper()</KBD
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
><KBD
CLASS="command"
>toupper</KBD
>(<EM
CLASS="emphasis"
>str</EM
>)</P
><P
CLASS="para"
>Translate all lowercase characters in <EM
CLASS="emphasis"
>str</EM
>
to uppercase and return the new string.</P
></DD
><DT
CLASS="term"
><KBD
CLASS="command"
>while</KBD
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
><KBD
CLASS="command"
>while</KBD
> (<EM
CLASS="emphasis"
>expr</EM
>)
   <EM
CLASS="emphasis"
>statement</EM
></P
><P
CLASS="para"
>Looping construct.  While <EM
CLASS="emphasis"
>expr</EM
> is true,
execute <EM
CLASS="emphasis"
>statement</EM
>.</P
></DD
></DL
><DIV
CLASS="sect2"
><H3
CLASS="sect2"
><A
CLASS="title"
NAME="SEDAWK-APP-B-SECT-3.1.1"
>B.3.1 Format Expressions Used in printf and sprintf</A
></H3
><P
CLASS="para"
>A format expression can take three optional modifiers following &quot;%&quot;
and preceding the format specifier:</P
><BLOCKQUOTE
CLASS="literallayout"
><P
CLASS="literallayout"
><KBD
CLASS="command"
>%-</KBD
><EM
CLASS="emphasis"
>width</EM
>.<EM
CLASS="emphasis"
>precision format-specifier</EM
></P
></BLOCKQUOTE
><P
CLASS="para"
>The <EM
CLASS="emphasis"
>width</EM
> of the output field is a numeric
value.  When you specify a field width, the contents of the field will
be right-justified by default.  You must specify &quot;-&quot; to get
left-justification.  Thus, &quot;%-20s&quot; outputs a string left-justified in
a field 20 characters wide.  If the string is less than 20 characters,
the field will be padded with spaces to fill.</P
><P
CLASS="para"
>The <EM
CLASS="emphasis"
>precision</EM
> modifier, used for decimal or
floating-point values, controls the number of digits that appear to
the right of the decimal point.  For string formats, it controls the
number of characters from the string to print.</P
><P
CLASS="para"
>You can specify both the <EM
CLASS="emphasis"
>width</EM
> and
<EM
CLASS="emphasis"
>precision</EM
> dynamically, via values in the
<KBD
CLASS="command"
>printf</KBD
> or <KBD
CLASS="command"
>sprintf</KBD
> argument list.
You do this by specifying asterisks, instead of specifying literal values.</P
><P
CLASS="para"
><BLOCKQUOTE
CLASS="screen"
><PRE
CLASS="screen"
>printf(&quot;%*.*g\n&quot;, 5, 3, myvar);</PRE
></BLOCKQUOTE
></P
><P
CLASS="para"
>In this example, the width is 5, the precision is 3, and the value to
print will come from <KBD
CLASS="command"
>myvar</KBD
>.  Older versions of nawk
may not support this.</P
><P
CLASS="para"
>Note that the default precision for the output of numeric values is
&quot;%.6g.&quot;  The default can be changed by setting the system variable
<KBD
CLASS="command"
>OFMT</KBD
>.  This affects the precision used by the
<KBD
CLASS="command"
>print</KBD
> statement when outputting numbers.  For
instance, if you are using awk to write reports that contain dollar
values, you might prefer to change <KBD
CLASS="command"
>OFMT</KBD
> to &quot;%.2f.&quot;</P
><P
CLASS="para"
>The format specifiers, shown in <A
CLASS="xref"
HREF="appb_03.htm#SEDAWK-APP-B-TAB-6"
TITLE="Format Specifiers Used in printf"
>Table 13.7</A
>, 
are used with
<KBD
CLASS="command"
>printf</KBD
> and <KBD
CLASS="command"
>sprintf</KBD
> statements.</P
><TABLE
CLASS="table"
><CAPTION
CLASS="table"
><A
CLASS="title"
NAME="SEDAWK-APP-B-TAB-6"
>Table B.6: Format Specifiers Used in printf</A
></CAPTION
><THEAD
CLASS="thead"
><TR
CLASS="row"
VALIGN="TOP"
><TH
CLASS="entry"
ALIGN="LEFT"
ROWSPAN="1"
COLSPAN="1"
>Character</TH
><TH
CLASS="entry"
ALIGN="LEFT"
ROWSPAN="1"
COLSPAN="1"
>Description</TH
></TR
></THEAD
><TBODY
CLASS="tbody"
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><B
CLASS="emphasis.bold"
>c</B
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
>ASCII character.</TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><B
CLASS="emphasis.bold"
>d</B
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
>Decimal integer.</TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><B
CLASS="emphasis.bold"
>i</B
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
>Decimal integer. Added in POSIX.</TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><B
CLASS="emphasis.bold"
>e</B
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Floating-point format
([-]<EM
CLASS="emphasis"
>d</EM
>.<EM
CLASS="emphasis"
>precision</EM
><KBD
CLASS="command"
>e</KBD
>[+-]<EM
CLASS="emphasis"
>dd</EM
>).</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><B
CLASS="emphasis.bold"
>E</B
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Floating-point format ([-]<EM
CLASS="emphasis"
>d</EM
>.<EM
CLASS="emphasis"
>precision</EM
><KBD
CLASS="command"
>E</KBD
>[+-]<EM
CLASS="emphasis"
>dd</EM
>).</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><B
CLASS="emphasis.bold"
>f</B
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Floating-point format ([-]<EM
CLASS="emphasis"
>ddd</EM
>.<EM
CLASS="emphasis"
>precision</EM
>).</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><B
CLASS="emphasis.bold"
>g</B
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
><KBD
CLASS="command"
>e</KBD
> or <KBD
CLASS="command"
>f</KBD
> conversion, whichever is
shortest, with trailing zeros removed.</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><B
CLASS="emphasis.bold"
>G</B
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
><KBD
CLASS="command"
>E</KBD
> or <KBD
CLASS="command"
>f</KBD
> conversion, whichever is
shortest, with trailing zeros removed.</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><B
CLASS="emphasis.bold"
>o</B
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
>Unsigned octal value.</TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><B
CLASS="emphasis.bold"
>s</B
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
>String.</TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><B
CLASS="emphasis.bold"
>x</B
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Unsigned hexadecimal number. Uses
<KBD
CLASS="command"
>a</KBD
>-<KBD
CLASS="command"
>f</KBD
> for 10 to 15.</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><B
CLASS="emphasis.bold"
>X</B
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Unsigned hexadecimal number. Uses
<KBD
CLASS="command"
>A</KBD
>-<KBD
CLASS="command"
>F</KBD
> for 10 to 15.</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><B
CLASS="emphasis.bold"
>%</B
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
>Literal %.</TD
></TR
></TBODY
></TABLE
><P
CLASS="para"
>Often, whatever format specifiers are available in the system's
<EM
CLASS="emphasis"
>sprintf</EM
>(3) subroutine are available in awk.</P
><P
CLASS="para"
>The way <KBD
CLASS="command"
>printf</KBD
> and
<KBD
CLASS="command"
>sprintf()</KBD
> do rounding will often depend
upon the system's C <EM
CLASS="emphasis"
>sprintf</EM
>(3) subroutine.
On many machines, <EM
CLASS="emphasis"
>sprintf</EM
> rounding is
&quot;unbiased,&quot; which means it doesn't always round a trailing &quot;.5&quot; up,
contrary to naive expectations.  In unbiased rounding, &quot;.5&quot; rounds to
even, rather than always up, so 1.5 rounds to 2 but 4.5 rounds to 4.
The result is that if you are using a format that does rounding (e.g.,
<KBD
CLASS="command"
>&quot;%.0f&quot;</KBD
>) you should check what your system does.
The following function does traditional rounding; it might be useful
if your awk's <KBD
CLASS="command"
>printf</KBD
> does unbiased rounding.</P
><P
CLASS="para"
><BLOCKQUOTE
CLASS="screen"
><PRE
CLASS="screen"
># round --- do normal rounding
#	Arnold Robbins, arnold@gnu.ai.mit.edu
#	Public Domain
function round(x,       ival, aval, fraction)
{
        ival = int(x)	# integer part, int() truncates
	# see if fractional part
	if (ival == x)	# no fraction
		return x
	if (x &lt; 0) {
		aval = -x	# absolute value
		ival = int(aval)
		fraction = aval - ival
		if (fraction &gt;= .5)
			return int(x) - 1		# -2.5 --&gt; -3
		else
			return int(x)		# -2.3 --&gt; -2
	} else {
		fraction = x - ival
		if (fraction &gt;= .5)
			return ival + 1
		else
			return ival
	}
}</PRE
></BLOCKQUOTE
></P
></DIV
><A
CLASS="indexterm"
NAME="AUTOID-13365"
></A
><A
CLASS="indexterm"
NAME="AUTOID-13366"
></A
><A
CLASS="indexterm"
NAME="AUTOID-13367"
></A
></DIV
><DIV
CLASS="htmlnav"
><P
></P
><HR
ALIGN="LEFT"
WIDTH="515"
TITLE="footer"><TABLE
WIDTH="515"
BORDER="0"
CELLSPACING="0"
CELLPADDING="0"
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="172"
><A
CLASS="SECT1"
HREF="appb_02.htm"
TITLE="B.2 Language Summary for awk"
><IMG
SRC="../gifs/txtpreva.gif"
ALT="Previous: B.2 Language Summary for awk"
BORDER="0"></A
></TD
><TD
ALIGN="CENTER"
VALIGN="TOP"
WIDTH="171"
><A
CLASS="book"
HREF="index.htm"
TITLE="sed &amp; awk"
><IMG
SRC="../gifs/txthome.gif"
ALT="sed &amp; awk"
BORDER="0"></A
></TD
><TD
ALIGN="RIGHT"
VALIGN="TOP"
WIDTH="172"
><A
CLASS="APPENDIX"
HREF="appc_01.htm"
TITLE="C. Supplement for Chapter 12"
><IMG
SRC="../gifs/txtnexta.gif"
ALT="Next: C. Supplement for Chapter 12"
BORDER="0"></A
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="172"
>B.2 Language Summary for awk</TD
><TD
ALIGN="CENTER"
VALIGN="TOP"
WIDTH="171"
><A
CLASS="index"
HREF="index/idx_0.htm"
TITLE="Book Index"
><IMG
SRC="../gifs/index.gif"
ALT="Book Index"
BORDER="0"></A
></TD
><TD
ALIGN="RIGHT"
VALIGN="TOP"
WIDTH="172"
>C. Supplement for Chapter 12</TD
></TR
></TABLE
><HR
ALIGN="LEFT"
WIDTH="515"
TITLE="footer"><IMG
SRC="../gifs/smnavbar.gif"
USEMAP="#map"
BORDER="0"
ALT="The UNIX CD Bookshelf Navigation"><MAP
NAME="map"
><AREA
SHAPE="RECT"
COORDS="0,0,73,21"
HREF="../index.htm"
ALT="The UNIX CD Bookshelf"><AREA
SHAPE="RECT"
COORDS="74,0,163,21"
HREF="../upt/index.htm"
ALT="UNIX Power Tools"><AREA
SHAPE="RECT"
COORDS="164,0,257,21"
HREF="../unixnut/index.htm"
ALT="UNIX in a Nutshell"><AREA
SHAPE="RECT"
COORDS="258,0,321,21"
HREF="../vi/index.htm"
ALT="Learning the vi Editor"><AREA
SHAPE="RECT"
COORDS="322,0,378,21"
HREF="index.htm"
ALT="sed &amp; awk"><AREA
SHAPE="RECT"
COORDS="379,0,438,21"
HREF="../ksh/index.htm"
ALT="Learning the Korn Shell"><AREA
SHAPE="RECT"
COORDS="439,0,514,21"
HREF="../lrnunix/index.htm"
ALT="Learning the UNIX Operating System"></MAP
></DIV
></BODY
></HTML
>
