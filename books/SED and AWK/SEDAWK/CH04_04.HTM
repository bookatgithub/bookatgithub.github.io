<HTML
><HEAD
>
<TITLE>[Chapter 4] 4.4 Four Types of sed Scripts</TITLE>
<META
NAME="DC.title"
CONTENT="sed &amp; awk"><META
NAME="DC.creator"
CONTENT="Dale Dougherty &amp; Arnold Robbins"><META
NAME="DC.publisher"
CONTENT="O'Reilly &amp; Associates, Inc."><META
NAME="DC.date"
CONTENT="1998-08-03T20:53:03Z"><META
NAME="DC.type"
CONTENT="Text.Monograph"><META
NAME="DC.format"
CONTENT="text/html"
SCHEME="MIME"><META
NAME="DC.source"
CONTENT="1-56592-225-5"
SCHEME="ISBN"><META
NAME="DC.language"
CONTENT="en-US"><META
NAME="generator"
CONTENT="Jade 1.1/O'Reilly DocBook 3.0 to HTML 4.0"><LINK
REV="made"
HREF="mailto:online-books@oreilly.com"
TITLE="Online Books Comments"><LINK
REL="up"
HREF="ch04_01.htm"
TITLE="4. Writing sed Scripts"><LINK
REL="prev"
HREF="ch04_03.htm"
TITLE="4.3 Testing and Saving Output"><LINK
REL="next"
HREF="ch04_05.htm"
TITLE="4.5 Getting to the PromiSed Land"></HEAD
><BODY
BGCOLOR="#FFFFFF"
TEXT="#000000"
><DIV
CLASS="htmlnav"
><H1
><IMG
SRC="gifs/smbanner.gif"
ALT="sed &amp; awk"
USEMAP="#srchmap"
BORDER="0"></H1
><MAP
NAME="srchmap"
><AREA
SHAPE="RECT"
COORDS="0,0,466,65"
HREF="index.htm"
ALT="sed &amp; awk"><AREA
SHAPE="RECT"
COORDS="467,0,514,18"
HREF="../search/ssrch.htm"
ALT="Search this book"></MAP
><TABLE
WIDTH="515"
BORDER="0"
CELLSPACING="0"
CELLPADDING="0"
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="172"
><A
CLASS="SECT1"
HREF="ch04_03.htm"
TITLE="4.3 Testing and Saving Output"
><IMG
SRC="../gifs/txtpreva.gif"
ALT="Previous: 4.3 Testing and Saving Output"
BORDER="0"></A
></TD
><TD
ALIGN="CENTER"
VALIGN="TOP"
WIDTH="171"
><B
><FONT
FACE="ARIEL,HELVETICA,HELV,SANSERIF"
SIZE="-1"
>Chapter 4<BR>Writing sed Scripts</FONT
></B
></TD
><TD
ALIGN="RIGHT"
VALIGN="TOP"
WIDTH="172"
><A
CLASS="SECT1"
HREF="ch04_05.htm"
TITLE="4.5 Getting to the PromiSed Land"
><IMG
SRC="../gifs/txtnexta.gif"
ALT="Next: 4.5 Getting to the PromiSed Land"
BORDER="0"></A
></TD
></TR
></TABLE
>&nbsp;<HR
ALIGN="LEFT"
WIDTH="515"
TITLE="footer"></DIV
><DIV
CLASS="SECT1"
><H2
CLASS="sect1"
><A
CLASS="title"
NAME="SEDAWK-CH-4-SECT-4"
>4.4 Four Types of sed Scripts</A
></H2
><P
CLASS="para"
>In this section, we are going to look at four types of scripts, each one
illustrating a typical sed application. </P
><DIV
CLASS="sect2"
><H3
CLASS="sect2"
><A
CLASS="title"
NAME="SEDAWK-CH-4-SECT-4.1"
>4.4.1 Multiple Edits to the Same File</A
></H3
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="CH04.MULT1"
></A
><A
CLASS="indexterm"
NAME="CH04.MULT2"
></A
>The first type of sed script demonstrates making a series of edits in
a file.  The example we use is a script that converts a file created
by a word processing program into a file coded for
<KBD
CLASS="command"
>troff</KBD
>.</P
><P
CLASS="para"
>One of the authors once did a writing project for a computer company,
here referred to as BigOne Computer. The document had to include a
product bulletin for &quot;Horsefeathers Software.&quot; The company promised
that the product bulletin was online and that they would send it.
Unfortunately, when the file arrived, it contained the formatted
output for a line printer, the only way they could provide it.  A
portion of that file (saved for testing in a file named
<EM
CLASS="emphasis"
>horsefeathers</EM
>) follows.</P
><BLOCKQUOTE
CLASS="screen"
><PRE
CLASS="screen"
>                  HORSEFEATHERS SOFTWARE PRODUCT BULLETIN

  DESCRIPTION
+   ___________

  BigOne Computer  offers three  software packages from the  suite  
  of Horsefeathers  software products  --  Horsefeathers  Business
  BASIC, BASIC  Librarian,  and LIDO.  These software products can
  fill  your    requirements    for    powerful,    sophisticated,
  general-purpose business  software providing you with a base for
  software customization or development.

  Horsefeathers  BASIC is  BASIC optimized for use on  the  BigOne  
  machine with UNIX  or MS-DOS operating systems.  BASIC Librarian
  is a full screen program editor, which also provides the ability</PRE
></BLOCKQUOTE
><P
CLASS="para"
>Note that the text has been justified with spaces added between words.
There are also spaces added to create a left margin.</P
><P
CLASS="para"
>We find that when we begin to tackle a problem using sed, we do best if we
make a mental list of all the things we want to do.  When we begin
coding, we write a script containing a single command that does one
thing. We test that it works, then we add another command, repeating
this cycle until we've done all that's obvious to do. (&quot;All that's
obvious&quot; because the list is not always complete, and the cycle of
implement-and-test often adds other items to the list.)</P
><P
CLASS="para"
>It may seem to be a rather tedious process to work this way and indeed
there are a number of scripts where it's fine to take a crack at
writing the whole script in one pass and then begin testing it.
However, the one-step-at-a-time technique is highly recommended for beginners
because you isolate each command and get to easily see what is working
and what is not.  When you try to do several commands at once, you
might find that when problems arise you end up recreating the
recommended process in reverse; that is, removing commands one by one
until you locate the problem.</P
><P
CLASS="para"
>Here is a list of the obvious edits that need to be made to the
Horsefeathers Software bulletin:</P
><OL
CLASS="orderedlist"
><LI
CLASS="listitem"
><P
CLASS="para"
>Replace all blank lines with a paragraph macro (.LP).</P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>Remove all leading spaces from each line.</P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>Remove the printer underscore line, the one that begins with a &quot;+&quot;.</P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>Remove multiple blank spaces that were added between words. </P
></LI
></OL
><P
CLASS="para"
>The first edit requires that we match blank lines.  However, in
looking at the input file, it wasn't obvious whether the blank lines
had leading spaces or not.  As it turns out, they do not, so blank
lines can be matched using the pattern &quot;^$&quot;.  (If there were spaces on
the line, the pattern could be written &quot;^<IMG
SRC="../chars/squ.gif"
ALT=" ">*$&quot;.)  Thus, the first
edit is fairly straightforward to accomplish:</P
><BLOCKQUOTE
CLASS="screen"
><PRE
CLASS="screen"
>s/^$/.LP/</PRE
></BLOCKQUOTE
><P
CLASS="para"
>It replaces each blank line with &quot;.LP&quot;.  Note that you do not escape
the literal period in the replacement section of the substitute
command. We can put this command in a file named
<I
CLASS="filename"
>sedscr</I
> and test the command as follows:</P
><BLOCKQUOTE
CLASS="screen"
><PRE
CLASS="screen"
>$ <CODE
CLASS="userinput"
><B
>sed -f sedscr horsefeathers</B
></CODE
>
                  HORSEFEATHERS SOFTWARE PRODUCT BULLETIN
.LP
  DESCRIPTION
+   ___________
.LP
  BigOne Computer  offers three  software packages from the  suite
  of Horsefeathers  software products  --  Horsefeathers  Business
  BASIC, BASIC  Librarian,  and LIDO.  These software products can
  fill  your    requirements    for    powerful,    sophisticated,
  general-purpose business  software providing you with a base for
  software customization or development.
.LP
  Horsefeathers  BASIC is  BASIC optimized for use on  the  BigOne
  machine with UNIX  or MS-DOS operating systems.  BASIC Librarian
  is a full screen program editor, which also provides the ability</PRE
></BLOCKQUOTE
><P
CLASS="para"
>It is pretty obvious which lines have changed.  (It is frequently
helpful to cut out a portion of a file to use for testing.  It works
best if the portion is small enough to fit on the screen yet is large
enough to include different examples of what you want to change.
After all edits have been applied successfully to the test file, a
second level of testing occurs when you apply them to the complete,
original file.)</P
><P
CLASS="para"
>The next edit that we make is to remove the line that begins with a
&quot;+&quot; and contains a line-printer underscore.  We can simply delete this
line using the delete command, <KBD
CLASS="command"
>d</KBD
>.  In writing a
pattern to match this line, we have a number of choices.  Each of the
following would match that line:</P
><BLOCKQUOTE
CLASS="screen"
><PRE
CLASS="screen"
>/^+/
/^+<IMG
SRC="../chars/squ.gif"
ALT=" ">/
/^+<IMG
SRC="../chars/squ.gif"
ALT=" "><IMG
SRC="../chars/squ.gif"
ALT=" ">*/
/^+<IMG
SRC="../chars/squ.gif"
ALT=" "><IMG
SRC="../chars/squ.gif"
ALT=" ">*__*/</PRE
></BLOCKQUOTE
><P
CLASS="para"
>As you can see, each successive regular expression matches a greater
number of characters.  Only through testing can you determine how
complex the expression needs to be to match a specific line and not
others.  The longer the pattern that you define in a regular
expression, the more comfort you have in knowing that it won't produce
unwanted matches.  For this script, we'll choose the third expression:</P
><BLOCKQUOTE
CLASS="screen"
><PRE
CLASS="screen"
>/^+<IMG
SRC="../chars/squ.gif"
ALT=" "><IMG
SRC="../chars/squ.gif"
ALT=" ">*/d</PRE
></BLOCKQUOTE
><P
CLASS="para"
>This command will delete any line that begins with a plus sign and is
followed by at least one space.  The pattern specifies two spaces, but
the second is modified by &quot;*&quot;, which means that the second space might
or might not be there.</P
><P
CLASS="para"
>This command was added to the sed script and tested but since it only
affects one line, we'll omit showing the results and move on.  The
next edit needs to remove the spaces that pad the beginning of a line.
The pattern for matching that sequence is very similar to the address
for the previous command.</P
><BLOCKQUOTE
CLASS="screen"
><PRE
CLASS="screen"
>s/^<IMG
SRC="../chars/squ.gif"
ALT=" "><IMG
SRC="../chars/squ.gif"
ALT=" ">*//</PRE
></BLOCKQUOTE
><P
CLASS="para"
>This command removes any sequence of spaces found at the beginning of
a line.  The replacement portion of the substitute command is empty,
meaning that the matched string is removed.</P
><P
CLASS="para"
>We can add this command to the script and test it. </P
><BLOCKQUOTE
CLASS="screen"
><PRE
CLASS="screen"
>$ <CODE
CLASS="userinput"
><B
>sed -f sedscr horsefeathers</B
></CODE
>
HORSEFEATHERS SOFTWARE PRODUCT BULLETIN
.LP
DESCRIPTION
.LP
BigOne Computer  offers three  software packages from the  suite
of Horsefeathers  software products  --  Horsefeathers  Business
BASIC, BASIC  Librarian,  and LIDO.  These software products can
fill  your    requirements    for    powerful,    sophisticated,
general-purpose business  software providing you with a base for
software customization or development.
.LP
Horsefeathers  BASIC is  BASIC optimized for use on  the  BigOne
machine with UNIX  or MS-DOS operating systems.  BASIC Librarian
is a full screen program editor, which also provides the ability</PRE
></BLOCKQUOTE
><P
CLASS="para"
>The next edit attempts to deal with the extra spaces added to justify
each line.  We can write a substitute command to match any string of
consecutive spaces and replace it with a single space.</P
><BLOCKQUOTE
CLASS="screen"
><PRE
CLASS="screen"
>s/<IMG
SRC="../chars/squ.gif"
ALT=" "><IMG
SRC="../chars/squ.gif"
ALT=" ">*/<IMG
SRC="../chars/squ.gif"
ALT=" ">/g</PRE
></BLOCKQUOTE
><P
CLASS="para"
>We add the global flag at the end of the command so that all
occurrences, not just the first, are replaced.  Note that, like
previous regular expressions, we are not specifying how many spaces
are there, just that one or more be found.  There might be two, three,
or four consecutive spaces.  No matter how many, we want to reduce
them to one.[3]</P
><BLOCKQUOTE
CLASS="footnote"
><P
CLASS="para"
>[3] This command will also match just a single space. But since the
replacement is also a single space, such a case is effectively a
&quot;no-op.&quot;  </P
></BLOCKQUOTE
><P
CLASS="para"
>Let's test the new script:</P
><BLOCKQUOTE
CLASS="screen"
><PRE
CLASS="screen"
>$ <CODE
CLASS="userinput"
><B
>sed -f sedscr horsefeathers</B
></CODE
>
HORSEFEATHERS SOFTWARE PRODUCT BULLETIN
.LP
DESCRIPTION
.LP
BigOne Computer offers three software packages from the suite
of Horsefeathers software products -- Horsefeathers Business
BASIC, BASIC Librarian, and LIDO. These software products can
fill your requirements for powerful, sophisticated,
general-purpose business software providing you with a base for
software customization or development.
.LP
Horsefeathers BASIC is BASIC optimized for use on the BigOne
machine with UNIX or MS-DOS operating systems. BASIC Librarian
is a full screen program editor, which also provides the ability</PRE
></BLOCKQUOTE
><P
CLASS="para"
>It works as advertised, reducing two or more spaces to one. 
On closer inspection, though, you might notice that the script removes a
sequence of two spaces following a period, a place where they might belong.</P
><P
CLASS="para"
>We could perfect our substitute
command such that it does not make the replacement for spaces
following a period.  The problem is that there are cases when
three spaces follow a period and we'd like to reduce that to two.
The best way seems to be to write a separate command that
deals with the special case of a period followed by spaces. </P
><BLOCKQUOTE
CLASS="screen"
><PRE
CLASS="screen"
>s/\.<IMG
SRC="../chars/squ.gif"
ALT=" "><IMG
SRC="../chars/squ.gif"
ALT=" ">*/.<IMG
SRC="../chars/squ.gif"
ALT=" "><IMG
SRC="../chars/squ.gif"
ALT=" ">/g</PRE
></BLOCKQUOTE
><P
CLASS="para"
>This command replaces a period followed by any number of
spaces with a period followed by two spaces.  It should be
noted that the previous command reduces multiple 
spaces to one, so that only one space will be found following
a period.[4]
Nonetheless, this pattern works regardless of how
many spaces follow the period, as long as there is at least one. 
(It would not, for instance, affect a filename of the form <EM
CLASS="emphasis"
>test.ext</EM
> 
if it appeared in the document.)  This command is placed at the end 
of the script and tested: </P
><BLOCKQUOTE
CLASS="footnote"
><P
CLASS="para"
>[4] The command could therefore be simplified to:

<BLOCKQUOTE
CLASS="screen"
><PRE
CLASS="screen"
>s/\.<IMG
SRC="../chars/squ.gif"
ALT=" ">/.<IMG
SRC="../chars/squ.gif"
ALT=" "><IMG
SRC="../chars/squ.gif"
ALT=" ">/g</PRE
></BLOCKQUOTE
>&#13;</P
></BLOCKQUOTE
><BLOCKQUOTE
CLASS="screen"
><PRE
CLASS="screen"
>$ <CODE
CLASS="userinput"
><B
>sed -f sedscr horsefeathers</B
></CODE
>
HORSEFEATHERS SOFTWARE PRODUCT BULLETIN
.LP
DESCRIPTION
.LP
BigOne Computer offers three software packages from the suite 
of Horsefeathers software products -- Horsefeathers Business 
BASIC, BASIC Librarian, and LIDO.  These software products can
fill your requirements for powerful, sophisticated,
general-purpose business software providing you with a base for
software customization or development.
.LP
Horsefeathers BASIC is BASIC optimized for use on the BigOne 
machine with UNIX or MS-DOS operating systems.  BASIC Librarian
is a full screen program editor, which also provides the ability</PRE
></BLOCKQUOTE
><P
CLASS="para"
>It works.  Here's the completed script:</P
><BLOCKQUOTE
CLASS="screen"
><PRE
CLASS="screen"
>s/^$/.LP/
/^+<IMG
SRC="../chars/squ.gif"
ALT=" "><IMG
SRC="../chars/squ.gif"
ALT=" ">*/d
s/^<IMG
SRC="../chars/squ.gif"
ALT=" "><IMG
SRC="../chars/squ.gif"
ALT=" ">*//
s/<IMG
SRC="../chars/squ.gif"
ALT=" "><IMG
SRC="../chars/squ.gif"
ALT=" ">*/<IMG
SRC="../chars/squ.gif"
ALT=" ">/g
s/\.<IMG
SRC="../chars/squ.gif"
ALT=" "><IMG
SRC="../chars/squ.gif"
ALT=" ">*/.<IMG
SRC="../chars/squ.gif"
ALT=" "><IMG
SRC="../chars/squ.gif"
ALT=" ">/g</PRE
></BLOCKQUOTE
><P
CLASS="para"
>As we said earlier, the next stage would be to test the script on the
complete file (<I
CLASS="filename"
>hf.product.bulletin</I
>),
using <KBD
CLASS="command"
>testsed</KBD
>, and examine the results thoroughly.
When we are satisfied with the results, we can use
<KBD
CLASS="command"
>runsed</KBD
> to make the changes permanent:</P
><BLOCKQUOTE
CLASS="screen"
><PRE
CLASS="screen"
>$ <CODE
CLASS="userinput"
><B
>runsed hf.product.bulletin</B
></CODE
>
done</PRE
></BLOCKQUOTE
><P
CLASS="para"
>By executing <KBD
CLASS="command"
>runsed</KBD
>, we have overwritten the
original file.</P
><P
CLASS="para"
>Before leaving this script, it is instructive to point out that
although the script was written to process a specific file, each of
the commands in the script is one that you might expect to use again,
even if you don't use the entire script again.  In other words, you
may well write other scripts that delete blank lines or check for two
spaces following a period.  Recognizing how commands can be reused in
other situations reduces the time it takes to develop and test new
scripts.  It's like a singer learning a song and adding it to his or
her repetoire.</P
><A
CLASS="indexterm"
NAME="AUTOID-2931"
></A
><A
CLASS="indexterm"
NAME="AUTOID-2932"
></A
></DIV
><DIV
CLASS="sect2"
><H3
CLASS="sect2"
><A
CLASS="title"
NAME="SEDAWK-CH-4-SECT-4.2"
>4.4.2 Making Changes Across a Set of Files</A
></H3
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-2936"
></A
><A
CLASS="indexterm"
NAME="AUTOID-2939"
></A
>The most common use of sed is in making a set of
search-and-replacement edits across a set of files.  Many times these
scripts aren't very unusual or interesting, just a list of substitute
commands that change one word or phrase to another.  Of course, such
scripts don't need to be interesting as long as they are useful and
save doing the work manually.</P
><P
CLASS="para"
>The example we look at in this section is a conversion script,
designed to modify various &quot;machine-specific&quot; terms in a UNIX
documentation set.  One person went through the documentation set and
made a list of things that needed to be changed.  Another person
worked from the list to create the following list of substitutions.</P
><BLOCKQUOTE
CLASS="screen"
><PRE
CLASS="screen"
>s/ON switch/START switch/g
s/ON button/START switch/g
s/STANDBY switch/STOP switch/g
s/STANDBY button/STOP switch/g
s/STANDBY/STOP/g
s/[cC]abinet [Ll]ight/control panel light/g
s/core system diskettes/core system tape/g
s/TERM=542[05] /TERM=PT200 /g
s/Teletype 542[05]/BigOne PT200/g
s/542[05] terminal/PT200 terminal/g
s/Documentation Road Map/Documentation Directory/g
s/Owner\/Operator Guide/Installation and Operation Guide/g
s/AT&amp;T 3B20 [cC]omputer/BigOne XL Computer/g
s/AT&amp;T 3B2 [cC]omputer/BigOne XL Computer/g
s/3B2 [cC]omputer/BigOne XL Computer/g
s/3B2/BigOne XL Computer/g</PRE
></BLOCKQUOTE
><P
CLASS="para"
>The script is straightforward.  The beauty is not in the script itself
but in sed's ability to apply this script to the hundreds of files
comprising the documentation set.  Once this script is tested, it can
be executed using <KBD
CLASS="command"
>runsed</KBD
> to process as many files
as there are at once.</P
><P
CLASS="para"
>Such a script can be a tremendous time-saver, but it can also be an
opportunity to make big-time mistakes.  What sometimes happens is that
a person writes the script, tests it on one or two out of the hundreds
of files and concludes from that test that the script works fine.
While it may not be practical to test each file, it is important that
the test files you do choose be both representative and exceptional.
Remember that text is extremely variable and you cannot typically
trust that what is true for a particular occurrence is true for all
occurrences.</P
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-2948"
></A
>Using <KBD
CLASS="command"
>grep</KBD
> to examine large amounts of input can be
very helpful.  For instance, if you wanted to determine how &quot;core
system diskettes&quot; appears in the documents, you could
<KBD
CLASS="command"
>grep</KBD
> for it everywhere and pore over the listing.
To be thorough, you should also <KBD
CLASS="command"
>grep</KBD
> for &quot;core,&quot;
&quot;core system,&quot; &quot;system diskettes,&quot; and &quot;diskettes&quot; to look for
occurrences split over multiple lines.  (You could also use the
<KBD
CLASS="command"
>phrase</KBD
> script in Chapter 6 to look for occurrences
of multiple words over consecutive lines.)  Examining the input is the
best way to know what your script must do.</P
><P
CLASS="para"
>In some ways, writing a script is like devising a hypothesis, given a
certain set of facts.  You try to prove the validity of the hypothesis
by increasing the amount of data that you test it against.  If you are
going to be running a script on multiple files, use
<KBD
CLASS="command"
>testsed</KBD
> to run the script on several dozen files
after you've tested it on a smaller sample.  Then compare the
temporary files to the originals to see if your assumptions were
correct.  The script might be off slightly and you can revise it.  The
more time you spend testing, which is actually rather interesting
work, the less chance you will spend your time unraveling problems
caused by a botched script.</P
></DIV
><DIV
CLASS="sect2"
><H3
CLASS="sect2"
><A
CLASS="title"
NAME="SEDAWK-CH-4-SECT-4.3"
>4.4.3 Extracting Contents of a File</A
></H3
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="CH04.EXT1"
></A
><A
CLASS="indexterm"
NAME="CH04.EXT2"
></A
>One type of sed application is used for extracting relevant material
from a file.  In this way, sed functions like <B
CLASS="emphasis.bold"
>grep</B
>, with the
additional advantage that the input can be modified prior to output.
This type of script is a good candidate for a shell script.</P
><P
CLASS="para"
>Here are two examples: extracting a macro definition from a macro
package and displaying the outline of a document.</P
><DIV
CLASS="sect3"
><H4
CLASS="sect3"
><A
CLASS="title"
NAME="SEDAWK-CH-4-SECT-4.3.1"
>4.4.3.1 Extracting a macro definition</A
></H4
><P
CLASS="para"
><KBD
CLASS="command"
>troff</KBD
> macros are defined in a macro package, often
a single file that's located in a directory such as
<I
CLASS="filename"
>/usr/lib/macros</I
>.  A <KBD
CLASS="command"
>troff</KBD
>
macro definition always begins with the string &quot;.de&quot;, followed by an
optional space and the one- or two-letter name of the macro.  The
definition ends with a line beginning with two dots
(..).  The script we show in this section extracts a
particular macro definition from a macro package.  (It saves you
from having to locate and open the file with an editor and search for
the lines that you want to examine.)</P
><P
CLASS="para"
>The first step in designing this script is to write one that extracts
a specific macro, in this case, the BL (Bulleted List) macro in the
<KBD
CLASS="command"
>-mm</KBD
> package.[5]</P
><BLOCKQUOTE
CLASS="footnote"
><P
CLASS="para"
>[5] We happen to know that the <KBD
CLASS="command"
>-mm</KBD
> macros don't have a
space after the &quot;.de&quot; command.  </P
></BLOCKQUOTE
><BLOCKQUOTE
CLASS="screen"
><PRE
CLASS="screen"
>$<CODE
CLASS="userinput"
><B
> sed -n  &quot;/^\.deBL/,/^\.\.$/p&quot; /usr/lib/macros/mmt</B
></CODE
>
.deBL
.if\\n(.$&lt;1 .)L \\n(Pin 0 1n 0 \\*(BU
.if\\n(.$=1 .LB 0\\$1 0 1 0 \\*(BU
.if\\n(.$&gt;1 \{.ie !\w^G\\$1^G .)L \\n(Pin 0 1n 0 \\*(BU 0 1
.el.LB 0\\$1 0 1 0 \\*(BU 0 1 \}
..</PRE
></BLOCKQUOTE
><P
CLASS="para"
>Sed is invoked with the <I
CLASS="option"
>-n</I
> option to keep it from
printing out the entire file.  With this option, sed will print only
the lines it is explicitly told to print via the print command.  The
sed script contains two addresses: the first matches the start of the
macro definition &quot;.deBL&quot; and the second matches its termination, &quot;..&quot;
on a line by itself.  Note that dots appear literally in the two
patterns and are escaped using the backslash.</P
><P
CLASS="para"
>The two addresses specify a range of lines for the print command,
<KBD
CLASS="command"
>p</KBD
>.  It is this capability that distinguishes this
kind of search script from <KBD
CLASS="command"
>grep</KBD
>, which cannot match
a range of lines.</P
><P
CLASS="para"
>We can take this command line and make it more general by placing it
in a shell script.  One obvious advantage of creating a shell script
is that it saves typing.  Another advantage is that a shell script can
be designed for more general usage.  For instance, we can allow the
user to supply information from the command line.  In this case,
rather than hard-code the name of the macro in the sed script, we can
use a command-line argument to supply it.  You can refer to each
argument on the command line in a shell script by positional notation:
the first argument is $1, the second is $2, and so on.  Here's the
<KBD
CLASS="command"
>getmac</KBD
> script:</P
><BLOCKQUOTE
CLASS="screen"
><PRE
CLASS="screen"
>#! /bin/sh
# getmac -- print mm macro definition for $1 
sed -n &quot;/^\.de$1/,/^\.\.$/p&quot; /usr/lib/macros/mmt</PRE
></BLOCKQUOTE
><P
CLASS="para"
>The first line of the shell script forces interpretation of the script
by the Bourne shell, using the &quot;#!&quot; executable interpreter mechanism
available on all modern UNIX systems.  The second line is a comment
that describes the name and purpose of the script.  The sed command,
on the third line, is identical to the previous example, except that
&quot;BL&quot; is replaced by &quot;$1&quot;, a variable representing the first
command-line argument.  Note that the double quotes surrounding the
sed script are necessary.  Single quotes would not allow
interpretation of &quot;$1&quot; by the shell.</P
><P
CLASS="para"
>This script, <KBD
CLASS="command"
>getmac</KBD
>, can be executed as follows:</P
><BLOCKQUOTE
CLASS="screen"
><PRE
CLASS="screen"
>$ <CODE
CLASS="userinput"
><B
>getmac BL</B
></CODE
></PRE
></BLOCKQUOTE
><P
CLASS="para"
>where &quot;BL&quot; is the first command-line argument.
It produces the same output as the previous example.</P
><P
CLASS="para"
>This script can be adapted to work with any of several macro packages.
The following version of <KBD
CLASS="command"
>getmac</KBD
> allows the user to
specify the name of a macro package as the second command-line
argument.</P
><BLOCKQUOTE
CLASS="screen"
><PRE
CLASS="screen"
>#! /bin/sh
# getmac - read macro definition for $1 from package $2
file=/usr/lib/macros/mmt
mac=&quot;$1&quot;
case $2 in
 -ms) file=&quot;/work/macros/current/tmac.s&quot;;;
 -mm) file=&quot;/usr/lib/macros/mmt&quot;;;
 -man) file=&quot;/usr/lib/macros/an&quot;;;
esac
sed -n &quot;/^\.de *$mac/,/^\.\.$/p&quot; $file</PRE
></BLOCKQUOTE
><P
CLASS="para"
>What is new here is a <KBD
CLASS="command"
>case</KBD
> statement that tests the
value of $2 and then assigns a value to the variable
<KBD
CLASS="command"
>file</KBD
>.  Notice that we assign a default value to
<KBD
CLASS="command"
>file</KBD
> so if the user does not designate a macro
package, the <KBD
CLASS="command"
>-mm</KBD
> macro package is searched.  Also,
for clarity and readability, the value of $1 is assigned to the
variable <KBD
CLASS="command"
>mac</KBD
>.</P
><P
CLASS="para"
>In creating this script, we discovered a difference among macro
packages in the first line of the macro definition.  The
<KBD
CLASS="command"
>-ms</KBD
> macros include a space between &quot;.de&quot; and the
name of the macro, while <KBD
CLASS="command"
>-mm</KBD
> and
<KBD
CLASS="command"
>-man</KBD
> do not.  Fortunately, we are able to modify
the pattern to accommodate both cases.</P
><BLOCKQUOTE
CLASS="screen"
><PRE
CLASS="screen"
>/^\.de *$mac/</PRE
></BLOCKQUOTE
><P
CLASS="para"
>Following &quot;.de&quot;, we specify a space followed by an asterisk, which
means the space is optional.</P
><P
CLASS="para"
>The script prints the result on standard output, but it can easily be
redirected into a file, where it can become the basis for the
redefinition of a macro.</P
></DIV
><DIV
CLASS="sect3"
><H4
CLASS="sect3"
><A
CLASS="title"
NAME="SEDAWK-CH-4-SECT-4.3.2"
>4.4.3.2 Generating an outline</A
></H4
><P
CLASS="para"
>Our next example not only extracts information; it modifies it to make
it easier to read.  We create a shell script named
<KBD
CLASS="command"
>do.outline</KBD
> that uses sed to give an outline view of
a document.  It processes lines containing coded section headings,
such as the following:</P
><BLOCKQUOTE
CLASS="screen"
><PRE
CLASS="screen"
>.Ah &quot;Shell Programming&quot;</PRE
></BLOCKQUOTE
><P
CLASS="para"
>The macro package we use has a chapter heading macro named &quot;Se&quot; and
hierarchical headings named &quot;Ah&quot;, &quot;Bh&quot;, and &quot;Ch&quot;.  In the
<KBD
CLASS="command"
>-mm</KBD
> macro package, these macros might be &quot;H&quot;, &quot;H1&quot;,
&quot;H2&quot;, &quot;H3&quot;, etc.  You can adapt the script to whatever macros or tags
identify the structure of a document.  The purpose of the
<KBD
CLASS="command"
>do.outline</KBD
> script is to make the structure more
apparent by printing the headings in an indented outline format.</P
><P
CLASS="para"
>The result of <KBD
CLASS="command"
>do.outline</KBD
> is shown below:</P
><BLOCKQUOTE
CLASS="screen"
><PRE
CLASS="screen"
>$ <CODE
CLASS="userinput"
><B
>do.outline ch13/sect1</B
></CODE
>
CHAPTER  13 Let the Computer Do the Dirty Work
     A.  Shell Programming 
          B.  Stored Commands
          B.  Passing Arguments to Shell Scripts
          B.  Conditional Execution
          B.  Discarding Used Arguments
          B.  Repetitive Execution
          B.  Setting Default Values
          B.  What We've Accomplished</PRE
></BLOCKQUOTE
><P
CLASS="para"
>It prints the result to standard output (without, of course, making
any changes within the files themselves). </P
><P
CLASS="para"
>Let's look at how to put together this script.  The script needs to
match lines that begin with the macros for:</P
><UL
CLASS="itemizedlist"
><LI
CLASS="listitem"
><P
CLASS="para"
>Chapter title (.Se) </P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>Section heading (.Ah)</P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>Subsection heading (.Bh) </P
></LI
></UL
><P
CLASS="para"
>We need to make substitutions on those lines, replacing macros with a
text marker (A, B, for instance) and adding the appropriate amount of
spacing (using tabs) to indent each heading. (Remember, the &quot;<IMG
SRC="../chars/bull.gif"
ALT="&#183;">&quot;
denotes a tab character.)</P
><P
CLASS="para"
>Here's the basic script: </P
><BLOCKQUOTE
CLASS="screen"
><PRE
CLASS="screen"
>sed -n '
s/^\.Se /CHAPTER /p
s/^\.Ah /<IMG
SRC="../chars/bull.gif"
ALT="&#183;">A. /p
s/^\.Bh /<IMG
SRC="../chars/bull.gif"
ALT="&#183;"><IMG
SRC="../chars/bull.gif"
ALT="&#183;">B.  /p' $*</PRE
></BLOCKQUOTE
><P
CLASS="para"
>&#13;<KBD
CLASS="command"
>do.outline</KBD
> operates on all files specified on the
command line (&quot;$*&quot;).  The <I
CLASS="option"
>-n</I
> option
suppresses the default output of the program.  The sed script contains
three substitute commands that replace the codes with the letters and
indent each line.  Each substitute command is modified by the
<B
CLASS="emphasis.bold"
>p</B
> flag that indicates the line should be printed.</P
><P
CLASS="para"
>When we test this script, the following results are produced:</P
><BLOCKQUOTE
CLASS="screen"
><PRE
CLASS="screen"
>CHAPTER  &quot;13&quot; &quot;Let the Computer Do the Dirty Work&quot;
     A.  &quot;Shell Programming&quot; 
          B.  &quot;Stored Commands&quot;
          B.  &quot;Passing Arguments to Shell Scripts&quot;</PRE
></BLOCKQUOTE
><P
CLASS="para"
>The quotation marks that surround the arguments to a macro are passed
through.  We can write a substitute command to remove the quotation
marks.</P
><BLOCKQUOTE
CLASS="screen"
><PRE
CLASS="screen"
>s/&quot;//g</PRE
></BLOCKQUOTE
><P
CLASS="para"
>It is necessary to specify the global flag, <KBD
CLASS="command"
>g</KBD
>, to
catch all occurrences on a single line.  However, the key decision is
where to put this command in the script.  If we put it at the end of
the script, it will remove the quotation marks after the line has
already been output.  We have to put it at the top of the script and
perform this edit for all lines, regardless of whether or not they are
output later in the script.</P
><BLOCKQUOTE
CLASS="screen"
><PRE
CLASS="screen"
>sed -n '
s/&quot;//g
s/^\.Se /CHAPTER /p
s/^\.Ah /<IMG
SRC="../chars/bull.gif"
ALT="&#183;">A. /p
s/^\.Bh /<IMG
SRC="../chars/bull.gif"
ALT="&#183;"><IMG
SRC="../chars/bull.gif"
ALT="&#183;">B.  /p' $*</PRE
></BLOCKQUOTE
><P
CLASS="para"
>This script now produces the results that were shown earlier.</P
><P
CLASS="para"
>You can modify this script to search for almost any kind of coded format.
For instance, here's a rough version for a LaTeX file:</P
><BLOCKQUOTE
CLASS="screen"
><PRE
CLASS="screen"
>sed -n '
s/[{}]//g
s/\\section/<IMG
SRC="../chars/bull.gif"
ALT="&#183;">A. /p
s/\\subsection/<IMG
SRC="../chars/bull.gif"
ALT="&#183;"><IMG
SRC="../chars/bull.gif"
ALT="&#183;">B.  /p' $*</PRE
></BLOCKQUOTE
></DIV
><A
CLASS="indexterm"
NAME="AUTOID-3047"
></A
><A
CLASS="indexterm"
NAME="AUTOID-3048"
></A
></DIV
><DIV
CLASS="sect2"
><H3
CLASS="sect2"
><A
CLASS="title"
NAME="SEDAWK-CH-4-SECT-4.4"
>4.4.4 Edits To Go</A
></H3
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="CH04.ON2"
></A
><A
CLASS="indexterm"
NAME="CH04.ON3"
></A
><A
CLASS="indexterm"
NAME="CH04.ON4"
></A
><A
CLASS="indexterm"
NAME="AUTOID-3058"
></A
>Let's consider an application that shows sed in its role as a true
stream editor, making edits in a pipeline&nbsp;- edits that are never
written back into a file.</P
><P
CLASS="para"
>On a typewriter-like device (including a CRT), an em-dash is typed as
a pair of hyphens (--).  In typesetting, it is printed as a single,
long dash (&nbsp;- ).  <KBD
CLASS="command"
>troff</KBD
> provides a special
character name for the em-dash, but it is inconvenient to type
&quot;\(em&quot;.</P
><P
CLASS="para"
>The following command changes two consecutive dashes into an em-dash.</P
><BLOCKQUOTE
CLASS="screen"
><PRE
CLASS="screen"
>s/--/\\(em/g</PRE
></BLOCKQUOTE
><P
CLASS="para"
>We double the backslashes in the replacement string for \(em, since
the backslash has a special meaning to sed.</P
><P
CLASS="para"
>Perhaps there are cases in which we don't want this substitute command
to be applied.  What if someone is using hyphens to draw a horizontal
line?  We can refine this command to exclude lines containing three or
more consecutive hyphens.  To do this, we use the ! address modifier:</P
><BLOCKQUOTE
CLASS="screen"
><PRE
CLASS="screen"
>/---/!s/--/\\(em/g</PRE
></BLOCKQUOTE
><P
CLASS="para"
>It may take a moment to penetrate this syntax.  What's different is
that we use a pattern address to restrict the lines that are affected
by the substitute command, and we use ! to reverse the sense of the
pattern match.  It says, simply, &quot;If you find a line containing three
consecutive hyphens, don't apply the edit.&quot;  On all other lines, the
substitute command will be applied.</P
><P
CLASS="para"
>We can use this command in a script that automatically inserts
em-dashes for us.  To do that, we will use sed as a preprocessor for
a <KBD
CLASS="command"
>troff</KBD
> file.  The file will be processed by sed
and then piped to <KBD
CLASS="command"
>troff</KBD
>.</P
><BLOCKQUOTE
CLASS="screen"
><PRE
CLASS="screen"
>sed '/---/!s/--/\\(em/g' file | troff</PRE
></BLOCKQUOTE
><P
CLASS="para"
>In other words, sed changes the input file and passes the output
directly to <KBD
CLASS="command"
>troff</KBD
>, without creating an intermediate
file.  The edits are made on-the-go, and do not affect the input file.
You might wonder why not just make the changes permanently in the
original file?  One reason is simply that it's not necessary&nbsp;- the
input remains consistent with what the user typed but
<KBD
CLASS="command"
>troff</KBD
> still produces what looks best for
typeset-quality output.  Furthermore, because it is embedded in a
larger shell script, the transformation of hyphens to em-dashes is
invisible to the user, and not an additional step in the formatting
process.</P
><P
CLASS="para"
>We use a shell script named <KBD
CLASS="command"
>format</KBD
> that uses sed
for this purpose.  Here's what the shell script looks like:</P
><BLOCKQUOTE
CLASS="screen"
><PRE
CLASS="screen"
>#! /bin/sh
eqn=  pic=  col=
files=  options=  roff=&quot;ditroff -Tps&quot;
sed=&quot;| sed '/---/!s/--/\\(em/g'&quot;
while [ $# -gt 0 ]
do
   case $1 in
     -E) eqn=&quot;| eqn&quot;;;
     -P) pic=&quot;| pic&quot;;;
     -N) roff=&quot;nroff&quot;  col=&quot;| col&quot;  sed= ;;
     -*) options=&quot;$options $1&quot;;;
      *) if [ -f $1 ]
         then files=&quot;$files $1&quot;
         else echo &quot;format: $1: file not found&quot;; exit 1
         fi;;
   esac
   shift
done
eval &quot;cat $files $sed | tbl $eqn $pic | $roff $options $col | lp&quot;</PRE
></BLOCKQUOTE
><P
CLASS="para"
>This script assigns and evaluates a number of variables (prefixed by a
dollar sign) that construct the command line that is submitted to
format and print a document.  (Notice that we've set up the
<I
CLASS="option"
>-N</I
> option for <KBD
CLASS="command"
>nroff</KBD
> so that it
sets the sed variable to the empty string, since we only want to make
this change if we are using <KBD
CLASS="command"
>troff</KBD
>. Even though
<KBD
CLASS="command"
>nroff</KBD
> understands the \(em special character,
making this change would have no actual effect on the output.)</P
><P
CLASS="para"
>Changing hyphens to em-dashes is not the only &quot;prettying up&quot; edit we
might want to make when typesetting a document.  For example, most
keyboards do not allow you to type open 



and close quotation marks (&quot; and &quot; as opposed to
&quot;and&quot;).  In <KBD
CLASS="command"
>troff</KBD
>, you can indicate a open
quotation mark by typing two consecutive grave accents, or
&quot;backquotes&quot; (<CODE
CLASS="literal"
>``</CODE
>), and a close quotation mark
by typing two consecutive single quotes (<CODE
CLASS="literal"
>''</CODE
>).
We can use sed to change each doublequote character to a pair of
single open-quotes or close-quotes (depending on context), which, when
typeset, will produce the appearance of a proper &quot;double quote.&quot;</P
><P
CLASS="para"
>This is a considerably more difficult edit to make, since there are
many separate cases involving punctuation marks, space, and tabs. 
Our script might look like this:</P
><BLOCKQUOTE
CLASS="screen"
><PRE
CLASS="screen"
>s/^&quot;/``/
s/&quot;$/''/
s/&quot;?<IMG
SRC="../chars/squ.gif"
ALT=" ">/''?<IMG
SRC="../chars/squ.gif"
ALT=" ">/g
s/&quot;?$/''?/g
s/<IMG
SRC="../chars/squ.gif"
ALT=" ">&quot;/<IMG
SRC="../chars/squ.gif"
ALT=" ">``/g
s/&quot;<IMG
SRC="../chars/squ.gif"
ALT=" ">/''<IMG
SRC="../chars/squ.gif"
ALT=" ">/g
s/<IMG
SRC="../chars/bull.gif"
ALT="&#183;">&quot;/<IMG
SRC="../chars/bull.gif"
ALT="&#183;">``/g
s/&quot;<IMG
SRC="../chars/bull.gif"
ALT="&#183;">/''<IMG
SRC="../chars/bull.gif"
ALT="&#183;">/g
s/&quot;)/'')/g
s/&quot;]/'']/g
s/(&quot;/(``/g
s/\[&quot;/\[``/g
s/&quot;;/'';/g
s/&quot;:/'':/g
s/,&quot;/,''/g
s/&quot;,/'',/g
s/\.&quot;/.\\\&amp;''/g
s/&quot;\./''.\\\&amp;/g
s/\\(em\\^&quot;/\\(em``/g
s/&quot;\\(em/''\\(em/g
s/\\(em&quot;/\\(em``/g
s/@DQ@/&quot;/g</PRE
></BLOCKQUOTE
><P
CLASS="para"
>The first substitute command looks for a quotation mark at the beginning
of a line and changes it to an open-quote.  The second command looks
for a quotation mark at the end of a line and changes it to a close-quote.
The remaining commands look for the quotation mark in different contexts,
before or after a punctuation mark, a space, a tab, or an em-dash.
The last command allows us to get a real doublequote (<CODE
CLASS="literal"
>@DQ@</CODE
>)
into the <KBD
CLASS="command"
>troff</KBD
> input if we need it.
We put these commands in a &quot;cleanup&quot; script, along with the command changing
hyphens to dashes, and invoke it in the pipeline that formats and prints
documents using <KBD
CLASS="command"
>troff</KBD
>.</P
><A
CLASS="indexterm"
NAME="AUTOID-3093"
></A
><A
CLASS="indexterm"
NAME="AUTOID-3094"
></A
><A
CLASS="indexterm"
NAME="AUTOID-3095"
></A
></DIV
></DIV
><DIV
CLASS="htmlnav"
><P
></P
><HR
ALIGN="LEFT"
WIDTH="515"
TITLE="footer"><TABLE
WIDTH="515"
BORDER="0"
CELLSPACING="0"
CELLPADDING="0"
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="172"
><A
CLASS="SECT1"
HREF="ch04_03.htm"
TITLE="4.3 Testing and Saving Output"
><IMG
SRC="../gifs/txtpreva.gif"
ALT="Previous: 4.3 Testing and Saving Output"
BORDER="0"></A
></TD
><TD
ALIGN="CENTER"
VALIGN="TOP"
WIDTH="171"
><A
CLASS="book"
HREF="index.htm"
TITLE="sed &amp; awk"
><IMG
SRC="../gifs/txthome.gif"
ALT="sed &amp; awk"
BORDER="0"></A
></TD
><TD
ALIGN="RIGHT"
VALIGN="TOP"
WIDTH="172"
><A
CLASS="SECT1"
HREF="ch04_05.htm"
TITLE="4.5 Getting to the PromiSed Land"
><IMG
SRC="../gifs/txtnexta.gif"
ALT="Next: 4.5 Getting to the PromiSed Land"
BORDER="0"></A
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="172"
>4.3 Testing and Saving Output</TD
><TD
ALIGN="CENTER"
VALIGN="TOP"
WIDTH="171"
><A
CLASS="index"
HREF="index/idx_0.htm"
TITLE="Book Index"
><IMG
SRC="../gifs/index.gif"
ALT="Book Index"
BORDER="0"></A
></TD
><TD
ALIGN="RIGHT"
VALIGN="TOP"
WIDTH="172"
>4.5 Getting to the PromiSed Land</TD
></TR
></TABLE
><HR
ALIGN="LEFT"
WIDTH="515"
TITLE="footer"><IMG
SRC="../gifs/smnavbar.gif"
USEMAP="#map"
BORDER="0"
ALT="The UNIX CD Bookshelf Navigation"><MAP
NAME="map"
><AREA
SHAPE="RECT"
COORDS="0,0,73,21"
HREF="../index.htm"
ALT="The UNIX CD Bookshelf"><AREA
SHAPE="RECT"
COORDS="74,0,163,21"
HREF="../upt/index.htm"
ALT="UNIX Power Tools"><AREA
SHAPE="RECT"
COORDS="164,0,257,21"
HREF="../unixnut/index.htm"
ALT="UNIX in a Nutshell"><AREA
SHAPE="RECT"
COORDS="258,0,321,21"
HREF="../vi/index.htm"
ALT="Learning the vi Editor"><AREA
SHAPE="RECT"
COORDS="322,0,378,21"
HREF="index.htm"
ALT="sed &amp; awk"><AREA
SHAPE="RECT"
COORDS="379,0,438,21"
HREF="../ksh/index.htm"
ALT="Learning the Korn Shell"><AREA
SHAPE="RECT"
COORDS="439,0,514,21"
HREF="../lrnunix/index.htm"
ALT="Learning the UNIX Operating System"></MAP
></DIV
></BODY
></HTML
>
