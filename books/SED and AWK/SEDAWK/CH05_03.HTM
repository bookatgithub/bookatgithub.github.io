<HTML
><HEAD
>
<TITLE>[Chapter 5] 5.3 Substitution</TITLE>
<META
NAME="DC.title"
CONTENT="sed &amp; awk"><META
NAME="DC.creator"
CONTENT="Dale Dougherty &amp; Arnold Robbins"><META
NAME="DC.publisher"
CONTENT="O'Reilly &amp; Associates, Inc."><META
NAME="DC.date"
CONTENT="1998-08-03T20:53:31Z"><META
NAME="DC.type"
CONTENT="Text.Monograph"><META
NAME="DC.format"
CONTENT="text/html"
SCHEME="MIME"><META
NAME="DC.source"
CONTENT="1-56592-225-5"
SCHEME="ISBN"><META
NAME="DC.language"
CONTENT="en-US"><META
NAME="generator"
CONTENT="Jade 1.1/O'Reilly DocBook 3.0 to HTML 4.0"><LINK
REV="made"
HREF="mailto:online-books@oreilly.com"
TITLE="Online Books Comments"><LINK
REL="up"
HREF="ch05_01.htm"
TITLE="5. Basic sed Commands"><LINK
REL="prev"
HREF="ch05_02.htm"
TITLE="5.2 Comment"><LINK
REL="next"
HREF="ch05_04.htm"
TITLE="5.4 Delete"></HEAD
><BODY
BGCOLOR="#FFFFFF"
TEXT="#000000"
><DIV
CLASS="htmlnav"
><H1
><IMG
SRC="gifs/smbanner.gif"
ALT="sed &amp; awk"
USEMAP="#srchmap"
BORDER="0"></H1
><MAP
NAME="srchmap"
><AREA
SHAPE="RECT"
COORDS="0,0,466,65"
HREF="index.htm"
ALT="sed &amp; awk"><AREA
SHAPE="RECT"
COORDS="467,0,514,18"
HREF="../search/ssrch.htm"
ALT="Search this book"></MAP
><TABLE
WIDTH="515"
BORDER="0"
CELLSPACING="0"
CELLPADDING="0"
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="172"
><A
CLASS="SECT1"
HREF="ch05_02.htm"
TITLE="5.2 Comment"
><IMG
SRC="../gifs/txtpreva.gif"
ALT="Previous: 5.2 Comment"
BORDER="0"></A
></TD
><TD
ALIGN="CENTER"
VALIGN="TOP"
WIDTH="171"
><B
><FONT
FACE="ARIEL,HELVETICA,HELV,SANSERIF"
SIZE="-1"
>Chapter 5<BR>Basic sed Commands</FONT
></B
></TD
><TD
ALIGN="RIGHT"
VALIGN="TOP"
WIDTH="172"
><A
CLASS="SECT1"
HREF="ch05_04.htm"
TITLE="5.4 Delete"
><IMG
SRC="../gifs/txtnexta.gif"
ALT="Next: 5.4 Delete"
BORDER="0"></A
></TD
></TR
></TABLE
>&nbsp;<HR
ALIGN="LEFT"
WIDTH="515"
TITLE="footer"></DIV
><DIV
CLASS="SECT1"
><H2
CLASS="sect1"
><A
CLASS="title"
NAME="SEDAWK-CH-5-SECT-3"
>5.3 Substitution</A
></H2
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="CH05.SUB1"
></A
><A
CLASS="indexterm"
NAME="CH05.SUB2"
></A
><A
CLASS="indexterm"
NAME="AUTOID-3245"
></A
>We have already demonstrated many uses of the substitute command.
Let's look carefully at its syntax:</P
><BLOCKQUOTE
CLASS="literallayout"
><P
CLASS="literallayout"
>[<CODE
CLASS="replaceable"
><I
>address</I
></CODE
>]<KBD
CLASS="command"
>s</KBD
>/<CODE
CLASS="replaceable"
><I
>pattern</I
></CODE
>/<CODE
CLASS="replaceable"
><I
>replacement</I
></CODE
>/<CODE
CLASS="replaceable"
><I
>flags</I
></CODE
></P
></BLOCKQUOTE
><P
CLASS="para"
>where the <EM
CLASS="emphasis"
>flags</EM
> that modify the substitution are:</P
><DL
CLASS="variablelist"
><DT
CLASS="term"
><KBD
CLASS="command"
>n</KBD
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
>A number (1 to 512) indicating that a replacement should be made for
only the <EM
CLASS="emphasis"
>n</EM
>th occurrence of the<A
CLASS="indexterm"
NAME="AUTOID-3263"
></A
><A
CLASS="indexterm"
NAME="AUTOID-3265"
></A
>
<EM
CLASS="emphasis"
>pattern</EM
>.</P
></DD
><DT
CLASS="term"
><KBD
CLASS="command"
>g</KBD
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
>Make changes globally on all occurrences in the pattern space.  Normally
only the first occurrence is replaced.<A
CLASS="indexterm"
NAME="AUTOID-3274"
></A
><A
CLASS="indexterm"
NAME="AUTOID-3276"
></A
></P
></DD
><DT
CLASS="term"
><KBD
CLASS="command"
>p</KBD
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
>Print the contents of the pattern space.<A
CLASS="indexterm"
NAME="AUTOID-3284"
></A
><A
CLASS="indexterm"
NAME="AUTOID-3286"
></A
></P
></DD
><DT
CLASS="term"
><KBD
CLASS="command"
>w</KBD
> <EM
CLASS="emphasis"
>file</EM
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
>Write the contents of the pattern space to <EM
CLASS="emphasis"
>file</EM
>.<A
CLASS="indexterm"
NAME="AUTOID-3296"
></A
><A
CLASS="indexterm"
NAME="AUTOID-3298"
></A
></P
></DD
></DL
><P
CLASS="para"
>The substitute command is applied to the lines matching the
<EM
CLASS="emphasis"
>address</EM
>.  If no address is specified, it is
applied to all lines that match the <EM
CLASS="emphasis"
>pattern</EM
>, a
regular expression.  If a regular expression is supplied as an
address, and no <EM
CLASS="emphasis"
>pattern</EM
> is specified, the
substitute command matches what is matched by the address.  This can
be useful when the substitute command is one of multiple commands
applied at the same address.  For an example,
see the section &quot;Checking Out Reference Pages&quot; later in this chapter.</P
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-3306"
></A
><A
CLASS="indexterm"
NAME="AUTOID-3309"
></A
><A
CLASS="indexterm"
NAME="AUTOID-3312"
></A
><A
CLASS="indexterm"
NAME="AUTOID-3315"
></A
><A
CLASS="indexterm"
NAME="AUTOID-3318"
></A
>Unlike addresses, which require a slash (/) as a delimiter,
the regular expression can be delimited by any character except
a newline.  Thus, if the pattern contained slashes, you could
choose another character, such as an exclamation mark, as the
delimiter.</P
><BLOCKQUOTE
CLASS="screen"
><PRE
CLASS="screen"
>s!/usr/mail!/usr2/mail!</PRE
></BLOCKQUOTE
><P
CLASS="para"
>Note that the delimiter appears three times and is required after the
<EM
CLASS="emphasis"
>replacement</EM
>.  Regardless of which delimiter
you use, if it does appear in the regular expression, or in the
replacement text, use a backslash (\) to escape it.</P
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-3325"
></A
>Once upon a time, computers stored text in fixed-length records.  A
line ended after so many characters (typically 80), and then the next
line started. There was no explicit character in the data to mark the
end of one line and the beginning of the next; every line had the same
(fixed) number of characters.  Modern systems are more flexible; they
use a special character (referred to as <EM
CLASS="emphasis"
>newline</EM
>)
to mark the end of the line.  This allows lines to be of arbitrary[3]
length.</P
><BLOCKQUOTE
CLASS="footnote"
><P
CLASS="para"
>[3] Well, more or less. Many UNIX programs have internal limits on the
length of the lines that they will process. Most GNU programs, though,
do not have such limits.</P
></BLOCKQUOTE
><P
CLASS="para"
>Since newline is just another character when stored internally, a
regular expression can use &quot;\n&quot; to match an
<EM
CLASS="emphasis"
>embedded</EM
> newline.  This occurs, as you will see
in the next chapter, in the special case when another line is appended
to the current line in the pattern space.  (See
<A
CLASS="xref"
HREF="ch02_01.htm"
TITLE="Understanding Basic Operations"
>Chapter 2, Understanding Basic Operations</A
>, for a discussion of line addressing and 
<A
CLASS="xref"
HREF="ch03_01.htm"
TITLE="Understanding Regular Expression Syntax"
>Chapter 3, Understanding Regular Expression Syntax</A
>, for a discussion of regular expression syntax.)</P
><P
CLASS="para"
>The <EM
CLASS="emphasis"
>replacement</EM
> is a string of characters that
will replace what is matched by the regular expression.  (See
the section &quot;The Extent of the Match&quot; in Chapter 3.)  In the
<CODE
CLASS="replaceable"
><I
>replacement</I
></CODE
> section, only the following
characters have special meaning:</P
><DL
CLASS="variablelist"
><DT
CLASS="term"
>&amp;</DT
><DD
CLASS="listitem"
><P
CLASS="para"
>Replaced by the string matched by the regular expression. <A
CLASS="indexterm"
NAME="AUTOID-3342"
></A
><A
CLASS="indexterm"
NAME="AUTOID-3345"
></A
></P
></DD
><DT
CLASS="term"
>\<EM
CLASS="emphasis"
>n</EM
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
>Matches the <EM
CLASS="emphasis"
>n</EM
>th substring
(<EM
CLASS="emphasis"
>n</EM
> is a single digit) previously specified
in the <CODE
CLASS="replaceable"
><I
>pattern</I
></CODE
> using &quot;\(&quot; and &quot;\)&quot;.</P
></DD
><DT
CLASS="term"
>\</DT
><DD
CLASS="listitem"
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-3360"
></A
><A
CLASS="indexterm"
NAME="AUTOID-3363"
></A
>Used to escape the ampersand (&amp;), the backslash (\), and the
substitution command's delimiter when they are used literally in the
replacement section.  In addition, it can be used to escape the
newline and create a multiline <EM
CLASS="emphasis"
>replacement</EM
>
string.</P
></DD
></DL
><P
CLASS="para"
>Thus, besides metacharacters in regular expressions, sed also has
metacharacters in the replacement.  See
the next section, &quot;Replacement Metacharacters,&quot; for examples of using them.</P
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-3369"
></A
><EM
CLASS="emphasis"
>Flags</EM
> can be used in combination where it
makes sense.  For instance, <KBD
CLASS="command"
>gp</KBD
> makes the
substitution globally on the line and prints the line.  The global
flag is by far the most commonly used.  Without it, the replacement is
made only for the first occurrence on the line.  The print flag and
the write flag both provide the same functionality as the print and
write commands (which are discussed later in this chapter) with one
important difference.  These actions are contingent upon a successful<A
CLASS="indexterm"
NAME="AUTOID-3373"
></A
><A
CLASS="indexterm"
NAME="AUTOID-3376"
></A
><A
CLASS="indexterm"
NAME="AUTOID-3379"
></A
><A
CLASS="indexterm"
NAME="AUTOID-3382"
></A
><A
CLASS="indexterm"
NAME="AUTOID-3384"
></A
><A
CLASS="indexterm"
NAME="AUTOID-3386"
></A
>
substitution occurring.  In other words, if the replacement is made,
the line is printed or written to file.  Because the default action is
to pass through all lines, regardless of whether any action is taken,
the print and write flags are typically used when the default output
is suppressed (the <I
CLASS="option"
>-n</I
> option).  In addition, if a
script contains multiple substitute commands that match the same line,
multiple copies of that line will be printed or written to file.</P
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-3390"
></A
><A
CLASS="indexterm"
NAME="AUTOID-3392"
></A
>The numeric flag can be used in the rare instances where the
regular expression repeats itself on a line and the replacement must
be made for only one of those occurrences by position.  For instance,
a line, perhaps containing <KBD
CLASS="command"
>tbl</KBD
> input, might contain
multiple tabs.  Let's say that there are three tabs per line, and
you'd like to replace the second tab with &quot;&gt;&quot;.  The
following substitute command would do it:</P
><BLOCKQUOTE
CLASS="screen"
><PRE
CLASS="screen"
>s/<IMG
SRC="../chars/bull.gif"
ALT="&#183;">/&gt;/2</PRE
></BLOCKQUOTE
><P
CLASS="para"
>&quot;<IMG
SRC="../chars/bull.gif"
ALT="&#183;">&quot; represents an actual tab character, which is otherwise
invisible on the screen.  If the input is a one-line file such as the
following:</P
><BLOCKQUOTE
CLASS="screen"
><PRE
CLASS="screen"
>Column1<IMG
SRC="../chars/bull.gif"
ALT="&#183;">Column2<IMG
SRC="../chars/bull.gif"
ALT="&#183;">Column3<IMG
SRC="../chars/bull.gif"
ALT="&#183;">Column4</PRE
></BLOCKQUOTE
><P
CLASS="para"
>the output produced by running the script on this file will be:</P
><BLOCKQUOTE
CLASS="screen"
><PRE
CLASS="screen"
>Column1<IMG
SRC="../chars/bull.gif"
ALT="&#183;">Column2&gt;Column3<IMG
SRC="../chars/bull.gif"
ALT="&#183;">Column4</PRE
></BLOCKQUOTE
><P
CLASS="para"
>Note that without the numeric flag, the substitute command would
replace only the first tab.  (Therefore &quot;1&quot; can be considered the
default numeric flag.)</P
><DIV
CLASS="sect2"
><H3
CLASS="sect2"
><A
CLASS="title"
NAME="SEDAWK-CH-5-SECT-3.1"
>5.3.1 Replacement Metacharacters</A
></H3
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="CH05.REP1"
></A
><A
CLASS="indexterm"
NAME="CH05.REP2"
></A
><A
CLASS="indexterm"
NAME="CH05.REP3"
></A
>The replacement metacharacters are backslash (\), ampersand (&amp;),
and \<EM
CLASS="emphasis"
>n</EM
>.  The backslash is generally
used to escape the other metacharacters but it is also used to include
a newline in a replacement string.<A
CLASS="indexterm"
NAME="AUTOID-3414"
></A
><A
CLASS="indexterm"
NAME="AUTOID-3417"
></A
><A
CLASS="indexterm"
NAME="AUTOID-3420"
></A
></P
><P
CLASS="para"
>We can do a variation on the previous example to replace the second
tab on each line with a newline.</P
><BLOCKQUOTE
CLASS="screen"
><PRE
CLASS="screen"
>s/<IMG
SRC="../chars/bull.gif"
ALT="&#183;">/\
/2</PRE
></BLOCKQUOTE
><P
CLASS="para"
>Note that no spaces are permitted after the backslash.  This script
produces the following result:</P
><BLOCKQUOTE
CLASS="screen"
><PRE
CLASS="screen"
>Column1<IMG
SRC="../chars/bull.gif"
ALT="&#183;">Column2
Column3<IMG
SRC="../chars/bull.gif"
ALT="&#183;">Column4</PRE
></BLOCKQUOTE
><P
CLASS="para"
>Another example comes from the conversion of a file for
<KBD
CLASS="command"
>troff</KBD
> to an ASCII input format for Ventura
Publisher.  It converts the following line for
<KBD
CLASS="command"
>troff</KBD
>:</P
><BLOCKQUOTE
CLASS="screen"
><PRE
CLASS="screen"
>.Ah &quot;Major Heading&quot;</PRE
></BLOCKQUOTE
><P
CLASS="para"
>to a similar line for Ventura Publisher:</P
><BLOCKQUOTE
CLASS="screen"
><PRE
CLASS="screen"
>@A HEAD = Major Heading</PRE
></BLOCKQUOTE
><P
CLASS="para"
>The twist in this problem is that the line needs to be preceded and followed
by blank lines.  It is an example of writing a multiline replacement
string.</P
><BLOCKQUOTE
CLASS="screen"
><PRE
CLASS="screen"
>/^\.Ah/{
s/\.Ah */\
\
@A HEAD = /
s/&quot;//g
s/$/\
/    
}</PRE
></BLOCKQUOTE
><P
CLASS="para"
>The first substitute command replaces &quot;.Ah&quot; with two newlines
and &quot;@A HEAD =&quot;.  A backslash at the end of the line is necessary to escape
the newline.  The second substitution removes the quotation marks.
The last command matches the end of line in the pattern space (not the
embedded newlines) and adds a newline after it.</P
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-3437"
></A
><A
CLASS="indexterm"
NAME="AUTOID-3440"
></A
>In the next example, the backslash is used to escape the ampersand,
which appears literally in the replacement section.</P
><BLOCKQUOTE
CLASS="screen"
><PRE
CLASS="screen"
>s/ORA/O'Reilly \&amp; Associates, Inc./g</PRE
></BLOCKQUOTE
><P
CLASS="para"
>It's easy to forget about the ampersand appearing literally in the
replacement string.  If we had not escaped it in this example, the
output would have been &quot;O'Reilly ORA Associates, Inc.&quot;</P
><P
CLASS="para"
>As a metacharacter, the ampersand (&amp;) represents the extent of the
pattern match, not the line that was matched.  You might use the
ampersand to match a word and surround it by <KBD
CLASS="command"
>troff</KBD
>
requests.  The following example surrounds a word with point-size
requests:</P
><BLOCKQUOTE
CLASS="screen"
><PRE
CLASS="screen"
>s/UNIX/\\s-2&amp;\\s0/g</PRE
></BLOCKQUOTE
><P
CLASS="para"
>Because backslashes are also replacement metacharacters, two
backslashes are necessary to output a single backslash.  The &quot;&amp;&quot;
in the replacement string refers to &quot;UNIX.&quot;  If the input line is:</P
><BLOCKQUOTE
CLASS="screen"
><PRE
CLASS="screen"
>on the UNIX Operating System.</PRE
></BLOCKQUOTE
><P
CLASS="para"
>then the substitute command produces:</P
><BLOCKQUOTE
CLASS="screen"
><PRE
CLASS="screen"
>on the \s-2UNIX\s0 Operating System.</PRE
></BLOCKQUOTE
><P
CLASS="para"
>The ampersand is particularly useful when the regular expression
matches variations of a word.  It allows you to specify a variable
replacement string that corresponds to what was actually matched.  For
instance, let's say that you wanted to surround with parentheses any
cross reference to a numbered section in a document.  In other words,
any reference such as &quot;See Section 1.4&quot; or &quot;See Section 12.9&quot; should
appear in parentheses, as &quot;(See Section 12.9).&quot;  A regular expression
can match the different combination of numbers, so we use &quot;&amp;&quot; in
the replacement string and surround whatever was matched.</P
><BLOCKQUOTE
CLASS="screen"
><PRE
CLASS="screen"
>s/See Section [1-9][0-9]*\.[1-9][0-9]*/(&amp;)/</PRE
></BLOCKQUOTE
><P
CLASS="para"
>The ampersand makes it possible to reference the entire match in the
replacement string.</P
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-3456"
></A
><A
CLASS="indexterm"
NAME="AUTOID-3459"
></A
><A
CLASS="indexterm"
NAME="AUTOID-3462"
></A
><A
CLASS="indexterm"
NAME="AUTOID-3465"
></A
><A
CLASS="indexterm"
NAME="AUTOID-3468"
></A
>Now let's look at the metacharacters that allow us to select any
individual portion of a string that is matched and recall it in the
replacement string.  A pair of escaped parentheses are used in sed to
enclose any part of a regular expression and save it for recall.  Up
to nine &quot;saves&quot; are permitted for a single line.
&quot;<EM
CLASS="emphasis"
>\n</EM
>&quot; is used to recall the portion of the
match that was saved, where <EM
CLASS="emphasis"
>n</EM
> is a number
from 1 to 9 referencing a particular &quot;saved&quot; string in order of use.</P
><P
CLASS="para"
>For example, to put the section numbers in boldface when they appeared as a
cross reference, we could write the following substitution:</P
><BLOCKQUOTE
CLASS="screen"
><PRE
CLASS="screen"
>s/\(See Section \)\([1-9][0-9]*\.[1-9][0-9]*\)/\1\\fB\2\\fP/</PRE
></BLOCKQUOTE
><P
CLASS="para"
>Two pairs of escaped parentheses are specified.  The first captures
&quot;See Section<IMG
SRC="../chars/squ.gif"
ALT=" ">&quot; (because this is a fixed string, it could have been
simply retyped in the replacement string).  The second captures the
section number.  The replacement string recalls the first saved
substring as &quot;\1&quot; and the second as &quot;\2,&quot; which is surrounded by
bold-font requests.</P
><P
CLASS="para"
>We can use a similar technique to match parts of a line and swap them.
For instance, let's say there are two parts of a line separated by a
colon.  We can match each part, putting them within escaped
parentheses and swapping them in the replacement.</P
><BLOCKQUOTE
CLASS="screen"
><PRE
CLASS="screen"
>$<CODE
CLASS="userinput"
><B
> cat test1</B
></CODE
>
first:second
one:two
$ <CODE
CLASS="userinput"
><B
>sed  's/\(.*\):\(.*\)/\2:\1/' test1</B
></CODE
>
second:first
two:one</PRE
></BLOCKQUOTE
><P
CLASS="para"
>The larger point is that you can recall a saved substring in any order,
and multiple times, as you'll see in the next example. </P
><DIV
CLASS="sect3"
><H4
CLASS="sect3"
><A
CLASS="title"
NAME="SEDAWK-CH-5-SECT-3.1.1"
>5.3.1.1 Correcting index entries</A
></H4
><P
CLASS="para"
>Later, in the awk section of this book, we will present a program for
formatting an index, such as the one for this book.  The first step in
creating an index is to place index codes in the document files.  We
use an index macro named .XX, which takes a single argument, the index
entry.  A sample index entry might be:</P
><BLOCKQUOTE
CLASS="screen"
><PRE
CLASS="screen"
>.XX &quot;sed, substitution command&quot;</PRE
></BLOCKQUOTE
><P
CLASS="para"
>Each index entry appears on a line by itself.  When you run an index,
you get a collection of index entries with page numbers that are then
sorted and merged in a list.  An editor poring over that list will
typically find errors and inconsistencies that need to be corrected.
It is, in short, a pain to have to track down the file where an index
entry resides and then make the correction, particularly when there
are dozens of entries to be corrected.</P
><P
CLASS="para"
>Sed can be a great help in making these edits across a group of files.
One can simply create a list of edits in a sed script and then run it
on all the files.  A key point is that the substitute command needs an
address that limits it to lines beginning &quot;.XX&quot;.  Your script should
not make changes in the text itself.</P
><P
CLASS="para"
>Let's say that we wanted to change the index entry above to &quot;sed,
substitute command.&quot;  The following command would do it:</P
><BLOCKQUOTE
CLASS="screen"
><PRE
CLASS="screen"
>/^\.XX /s/sed, substitution command/sed, substitute command/</PRE
></BLOCKQUOTE
><P
CLASS="para"
>The address matches all lines that begin with &quot;.XX &quot; and only on those
lines does it attempt to make the replacement.  You might wonder, why
not specify a shorter regular expression?  For example:</P
><BLOCKQUOTE
CLASS="screen"
><PRE
CLASS="screen"
>/^\.XX /s/substitution/substitute/</PRE
></BLOCKQUOTE
><P
CLASS="para"
>The answer is simply that there could be other entries which use the
word &quot;substitution&quot; correctly and which we would not want to change.</P
><P
CLASS="para"
>We can go a step further and provide a shell script that creates a
list of index entries prepared for editing as a series of sed
substitute commands.</P
><BLOCKQUOTE
CLASS="screen"
><PRE
CLASS="screen"
>#! /bin/sh
# index.edit -- compile list of index entries for editing.
grep &quot;^\.XX&quot; $* | sort -u |
sed '
s/^\.XX \(.*\)$/\/^\\.XX \/s\/\1\/\1\//'</PRE
></BLOCKQUOTE
><P
CLASS="para"
>The <KBD
CLASS="command"
>index.edit</KBD
> shell script
uses <B
CLASS="emphasis.bold"
>grep</B
> to extract
all lines containing index entries from any number of files specified
on the command line.  It passes this list through
<KBD
CLASS="command"
>sort</KBD
> which, with the <I
CLASS="option"
>-u</I
> option,
sorts and removes duplicate entries.  The list is then piped to sed,
and the one-line sed script builds a substitution command.</P
><P
CLASS="para"
>Let's look at it more closely.  Here's just the regular expression:</P
><BLOCKQUOTE
CLASS="screen"
><PRE
CLASS="screen"
>^\.XX \(.*\)$</PRE
></BLOCKQUOTE
><P
CLASS="para"
>It matches the entire line, saving the index entry for recall.  Here's
just the replacement string:</P
><BLOCKQUOTE
CLASS="screen"
><PRE
CLASS="screen"
>\/^\\.XX \/s\/\1\/\1\/</PRE
></BLOCKQUOTE
><P
CLASS="para"
>It generates a substitute command beginning with an address: a slash,
followed by two backslashes&nbsp;- to output one backslash to protect
the dot in the &quot;.XX&quot; that follows&nbsp;- then comes a space, then
another slash to complete the address.  Next we output an &quot;s&quot; followed
by a slash, and then recall the saved portion to be used as a regular
expression.  That is followed by another slash and again we
recall the saved substring as the replacement string.  A slash finally
ends the command.</P
><P
CLASS="para"
>When the <KBD
CLASS="command"
>index.edit</KBD
> script is run on a file, it
creates a listing similar to this:</P
><BLOCKQUOTE
CLASS="screen"
><PRE
CLASS="screen"
>$ <CODE
CLASS="userinput"
><B
>index.edit ch05</B
></CODE
>
/^\.XX /s/&quot;append command(a)&quot;/&quot;append command(a)&quot;/
/^\.XX /s/&quot;change command&quot;/&quot;change command&quot;/
/^\.XX /s/&quot;change command(c)&quot;/&quot;change command(c)&quot;/
/^\.XX /s/&quot;commands:sed, summary of&quot;/&quot;commands:sed, summary of&quot;/
/^\.XX /s/&quot;delete command(d)&quot;/&quot;delete command(d)&quot;/
/^\.XX /s/&quot;insert command(i)&quot;/&quot;insert command(i)&quot;/
/^\.XX /s/&quot;line numbers:printing&quot;/&quot;line numbers:printing&quot;/
/^\.XX /s/&quot;list command(l)&quot;/&quot;list command(l)&quot;/</PRE
></BLOCKQUOTE
><P
CLASS="para"
>This output could be captured in a file.  Then you can delete the
entries that don't need to change and you can make changes by editing
the replacement string.  At that point, you can use this file as a sed
script to correct the index entries in all document files.</P
><P
CLASS="para"
>When doing a large book with lots of entries, you
might use <KBD
CLASS="command"
>grep</KBD
> again to extract particular entries
from the output of <KBD
CLASS="command"
>index.edit</KBD
> and direct them into
their own file for editing.  This saves you from having to wade through
numerous entries.</P
><P
CLASS="para"
>There is one small failing in this program.  It should look for
metacharacters that might appear literally in index entries and
protect them in regular expressions.  For instance, if an index entry
contains an asterisk, it will not be interpreted as such, but as a
metacharacter.  To make that change effectively requires the use of
several advanced commands, so we'll put off improving this script until
the next chapter.</P
></DIV
><A
CLASS="indexterm"
NAME="AUTOID-3512"
></A
><A
CLASS="indexterm"
NAME="AUTOID-3513"
></A
><A
CLASS="indexterm"
NAME="AUTOID-3514"
></A
></DIV
><A
CLASS="indexterm"
NAME="AUTOID-3515"
></A
><A
CLASS="indexterm"
NAME="AUTOID-3516"
></A
></DIV
><DIV
CLASS="htmlnav"
><P
></P
><HR
ALIGN="LEFT"
WIDTH="515"
TITLE="footer"><TABLE
WIDTH="515"
BORDER="0"
CELLSPACING="0"
CELLPADDING="0"
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="172"
><A
CLASS="SECT1"
HREF="ch05_02.htm"
TITLE="5.2 Comment"
><IMG
SRC="../gifs/txtpreva.gif"
ALT="Previous: 5.2 Comment"
BORDER="0"></A
></TD
><TD
ALIGN="CENTER"
VALIGN="TOP"
WIDTH="171"
><A
CLASS="book"
HREF="index.htm"
TITLE="sed &amp; awk"
><IMG
SRC="../gifs/txthome.gif"
ALT="sed &amp; awk"
BORDER="0"></A
></TD
><TD
ALIGN="RIGHT"
VALIGN="TOP"
WIDTH="172"
><A
CLASS="SECT1"
HREF="ch05_04.htm"
TITLE="5.4 Delete"
><IMG
SRC="../gifs/txtnexta.gif"
ALT="Next: 5.4 Delete"
BORDER="0"></A
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="172"
>5.2 Comment</TD
><TD
ALIGN="CENTER"
VALIGN="TOP"
WIDTH="171"
><A
CLASS="index"
HREF="index/idx_0.htm"
TITLE="Book Index"
><IMG
SRC="../gifs/index.gif"
ALT="Book Index"
BORDER="0"></A
></TD
><TD
ALIGN="RIGHT"
VALIGN="TOP"
WIDTH="172"
>5.4 Delete</TD
></TR
></TABLE
><HR
ALIGN="LEFT"
WIDTH="515"
TITLE="footer"><IMG
SRC="../gifs/smnavbar.gif"
USEMAP="#map"
BORDER="0"
ALT="The UNIX CD Bookshelf Navigation"><MAP
NAME="map"
><AREA
SHAPE="RECT"
COORDS="0,0,73,21"
HREF="../index.htm"
ALT="The UNIX CD Bookshelf"><AREA
SHAPE="RECT"
COORDS="74,0,163,21"
HREF="../upt/index.htm"
ALT="UNIX Power Tools"><AREA
SHAPE="RECT"
COORDS="164,0,257,21"
HREF="../unixnut/index.htm"
ALT="UNIX in a Nutshell"><AREA
SHAPE="RECT"
COORDS="258,0,321,21"
HREF="../vi/index.htm"
ALT="Learning the vi Editor"><AREA
SHAPE="RECT"
COORDS="322,0,378,21"
HREF="index.htm"
ALT="sed &amp; awk"><AREA
SHAPE="RECT"
COORDS="379,0,438,21"
HREF="../ksh/index.htm"
ALT="Learning the Korn Shell"><AREA
SHAPE="RECT"
COORDS="439,0,514,21"
HREF="../lrnunix/index.htm"
ALT="Learning the UNIX Operating System"></MAP
></DIV
></BODY
></HTML
>
