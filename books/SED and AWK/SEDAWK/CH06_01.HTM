<HTML
><HEAD
>
<TITLE>[Chapter 6] Advanced sed Commands</TITLE>
<META
NAME="DC.title"
CONTENT="sed &amp; awk"><META
NAME="DC.creator"
CONTENT="Dale Dougherty &amp; Arnold Robbins"><META
NAME="DC.publisher"
CONTENT="O'Reilly &amp; Associates, Inc."><META
NAME="DC.date"
CONTENT="1998-08-03T20:55:02Z"><META
NAME="DC.type"
CONTENT="Text.Monograph"><META
NAME="DC.format"
CONTENT="text/html"
SCHEME="MIME"><META
NAME="DC.source"
CONTENT="1-56592-225-5"
SCHEME="ISBN"><META
NAME="DC.language"
CONTENT="en-US"><META
NAME="generator"
CONTENT="Jade 1.1/O'Reilly DocBook 3.0 to HTML 4.0"><LINK
REV="made"
HREF="mailto:online-books@oreilly.com"
TITLE="Online Books Comments"><LINK
REL="up"
HREF="index.htm"
TITLE="sed &amp; awk"><LINK
REL="prev"
HREF="ch05_12.htm"
TITLE="5.12 Quit"><LINK
REL="next"
HREF="ch06_02.htm"
TITLE="6.2 A Case for Study"></HEAD
><BODY
BGCOLOR="#FFFFFF"
TEXT="#000000"
><DIV
CLASS="htmlnav"
><H1
><IMG
SRC="gifs/smbanner.gif"
ALT="sed &amp; awk"
USEMAP="#srchmap"
BORDER="0"></H1
><MAP
NAME="srchmap"
><AREA
SHAPE="RECT"
COORDS="0,0,466,65"
HREF="index.htm"
ALT="sed &amp; awk"><AREA
SHAPE="RECT"
COORDS="467,0,514,18"
HREF="../search/ssrch.htm"
ALT="Search this book"></MAP
><TABLE
WIDTH="515"
BORDER="0"
CELLSPACING="0"
CELLPADDING="0"
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="172"
><A
CLASS="SECT1"
HREF="ch05_12.htm"
TITLE="5.12 Quit"
><IMG
SRC="../gifs/txtpreva.gif"
ALT="Previous: 5.12 Quit"
BORDER="0"></A
></TD
><TD
ALIGN="CENTER"
VALIGN="TOP"
WIDTH="171"
><B
><FONT
FACE="ARIEL,HELVETICA,HELV,SANSERIF"
SIZE="-1"
>Chapter 6</FONT
></B
></TD
><TD
ALIGN="RIGHT"
VALIGN="TOP"
WIDTH="172"
><A
CLASS="SECT1"
HREF="ch06_02.htm"
TITLE="6.2 A Case for Study"
><IMG
SRC="../gifs/txtnexta.gif"
ALT="Next: 6.2 A Case for Study"
BORDER="0"></A
></TD
></TR
></TABLE
>&nbsp;<HR
ALIGN="LEFT"
WIDTH="515"
TITLE="footer"></DIV
><DIV
CLASS="CHAPTER"
><H1
CLASS="chapter"
><A
CLASS="title"
NAME="SEDAWK-CH-6"
>6. Advanced sed Commands</A
></H1
><DIV
CLASS="htmltoc"
><P
><B
>Contents:</B
><BR><A
CLASS="sect1"
HREF="#SEDAWK-CH-6-SECT-1"
TITLE="6.1 Multiline Pattern Space"
>Multiline Pattern Space</A
><BR><A
CLASS="sect1"
HREF="ch06_02.htm"
TITLE="6.2 A Case for Study"
>A Case for Study</A
><BR><A
CLASS="sect1"
HREF="ch06_03.htm"
TITLE="6.3 Hold That Line"
>Hold That Line</A
><BR><A
CLASS="sect1"
HREF="ch06_04.htm"
TITLE="6.4 Advanced Flow Control Commands"
>Advanced Flow Control Commands</A
><BR><A
CLASS="sect1"
HREF="ch06_05.htm"
TITLE="6.5 To Join a Phrase"
>To Join a Phrase</A
></P
><P
></P
></DIV
><P
CLASS="para"
>In this chapter, we cover the remaining sed commands.  These commands
require more determination to master and are more difficult to learn
from the standard documentation than any of the basic commands.  You
can consider yourself a true sed-master once you understand the
commands presented here.</P
><P
CLASS="para"
>The advanced commands fall into three groupings:<A
CLASS="indexterm"
NAME="AUTOID-4009"
></A
><A
CLASS="indexterm"
NAME="AUTOID-4012"
></A
></P
><OL
CLASS="orderedlist"
><LI
CLASS="listitem"
><P
CLASS="para"
> 
Working with a multiline pattern space
(<KBD
CLASS="command"
>N</KBD
>,<KBD
CLASS="command"
>D</KBD
>,<KBD
CLASS="command"
>P</KBD
>).</P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>Using the <EM
CLASS="emphasis"
>hold space</EM
> to preserve the contents of the
pattern space and make it available for subsequent commands
(<KBD
CLASS="command"
>H</KBD
>,<KBD
CLASS="command"
>h</KBD
>,<KBD
CLASS="command"
>G</KBD
>,<KBD
CLASS="command"
>g</KBD
>,<KBD
CLASS="command"
>x</KBD
>).</P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>Writing scripts that use branching and conditional instructions
to change the flow of control (:,<KBD
CLASS="command"
>b</KBD
>,<KBD
CLASS="command"
>t</KBD
>).</P
></LI
></OL
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-4034"
></A
>If the advanced scripts in this chapter have one thing in common, it
is that they alter the sequential flow of execution or control.
Normally, a line is read into the pattern space and each command in
the script, one right after the other, is applied to that line.  When
the bottom of the script is reached, the line is output and the
pattern space is cleared.  Then a new line is read into the pattern
space and control passes back to the top of the script.  That is
the normal flow of control in a sed script.</P
><P
CLASS="para"
>The scripts in this chapter interrupt or break the normal flow of
control for various reasons.  They might want to prevent commands in
the script from executing except under certain circumstances, or to
prevent the contents of the pattern space from being cleared out.
Altering the flow of control makes a script much more difficult to
read and understand.  In fact, the scripts may be easier to write than
they are to read.  When you are writing a difficult script, you have
the benefit of testing it to see how and why commands work.</P
><P
CLASS="para"
>We'd recommend that you test the scripts presented in this chapter and
experiment by adding or removing commands to understand how the script
is working.  Seeing the results for yourself will help you understand
the script much better than simply reading about it.</P
><DIV
CLASS="sect1"
><H2
CLASS="sect1"
><A
CLASS="title"
NAME="SEDAWK-CH-6-SECT-1"
>6.1 Multiline Pattern Space</A
></H2
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="CH06.PATT1"
></A
><A
CLASS="indexterm"
NAME="CH06.PATT2"
></A
><A
CLASS="indexterm"
NAME="CH06.PATT3"
></A
>We have emphasized in previous discussions of regular expressions that
pattern matching is line-oriented.  A program like
<KBD
CLASS="command"
>grep</KBD
> attempts to match a pattern on a single line
of input.  This makes it difficult to match a phrase, for instance,
which can start at the end of one line and finish at the beginning of
the next line.  Other patterns might be significant only when repeated
on multiple lines.</P
><P
CLASS="para"
>Sed has the ability to look at more than one line in the pattern
space.  This allows you to match patterns that extend over multiple
lines.  In this section, we will look at commands that create a
multiline pattern space and manipulate its contents.  The three
multiline commands
(<KBD
CLASS="command"
>N</KBD
>,<KBD
CLASS="command"
>D</KBD
>,<KBD
CLASS="command"
>P</KBD
>) all
correspond to lowercase basic commands
(<KBD
CLASS="command"
>n</KBD
>,<KBD
CLASS="command"
>d</KBD
>,<KBD
CLASS="command"
>p</KBD
>) that
were presented in the previous chapter.  The Delete
(<KBD
CLASS="command"
>D</KBD
>) command, for instance, is a multiline version
of the delete command (<KBD
CLASS="command"
>d</KBD
>).  The difference is that
while <KBD
CLASS="command"
>d</KBD
> deletes the contents of the pattern space,
<KBD
CLASS="command"
>D</KBD
> deletes only the first line of a multiline
pattern space.</P
><DIV
CLASS="sect2"
><H3
CLASS="sect2"
><A
CLASS="title"
NAME="SEDAWK-CH-6-SECT-1.1"
>6.1.1 Append Next Line</A
></H3
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="CH06.N"
></A
>The multiline Next (<KBD
CLASS="command"
>N</KBD
>) command creates a
multiline pattern space by reading a new line of input and appending
it to the contents of the pattern space.  The original contents of
pattern space and the new input line are separated by a newline.  The
embedded newline character can be matched in patterns by the escape
sequence &quot;\n&quot;.  In a multiline pattern space, the metacharacter &quot;^&quot;
<A
CLASS="indexterm"
NAME="AUTOID-4068"
></A
><A
CLASS="indexterm"
NAME="AUTOID-4070"
></A
><A
CLASS="indexterm"
NAME="AUTOID-4073"
></A
><A
CLASS="indexterm"
NAME="AUTOID-4076"
></A
><A
CLASS="indexterm"
NAME="AUTOID-4079"
></A
>

matches the very first character of the pattern space, and not the
character(s) following any embedded newline(s). Similarly, &quot;$&quot; matches
only the final newline in the pattern space, and not any embedded
newline(s).  After the Next command is executed, control is then
passed to subsequent commands in the script.</P
><P
CLASS="para"
>The Next command differs from the next command, which outputs the
contents of the pattern space and then reads a new line of input.  The
next command does not create a multiline pattern space.</P
><P
CLASS="para"
>For our first example, let's suppose that we wanted to change &quot;Owner
and Operator Guide&quot; to &quot;Installation Guide&quot; but we found that it
appears in the file on two lines, splitting between &quot;Operator&quot; and
&quot;Guide.&quot;</P
><P
CLASS="para"
>For instance, here are a few lines of sample text:</P
><BLOCKQUOTE
CLASS="screen"
><PRE
CLASS="screen"
>Consult Section 3.1 in the Owner and Operator
Guide for a description of the tape drives
available on your system.</PRE
></BLOCKQUOTE
><P
CLASS="para"
>The following script looks for &quot;Operator&quot; at the end of a line, reads
the next line of input and then makes the replacement.</P
><BLOCKQUOTE
CLASS="screen"
><PRE
CLASS="screen"
>/Operator$/{
N
s/Owner and Operator\nGuide/Installation Guide/
}</PRE
></BLOCKQUOTE
><P
CLASS="para"
>In this example, we know where the two lines split and where to
specify the embedded newline.  When the script is run on the sample
file, it produces the two lines of output, one of which combines the
first and second lines and is too long to show here.  This happens
because the substitute command matches the embedded newline but does
not replace it.  Unfortunately, you cannot use &quot;\n&quot; to
insert a newline in the replacement string.  You must use
a backslash to escape the newline, as follows:</P
><BLOCKQUOTE
CLASS="screen"
><PRE
CLASS="screen"
>s/Owner and Operator\nGuide /Installation Guide\
/</PRE
></BLOCKQUOTE
><P
CLASS="para"
>This command restores the newline after &quot;Installation Guide&quot;. It is
also necessary to match a space following &quot;Guide&quot; so the new
line won't begin with a space.  Now we can show the output:</P
><BLOCKQUOTE
CLASS="screen"
><PRE
CLASS="screen"
>Consult Section 3.1 in the Installation Guide 
for a description of the tape drives
available on your system.</PRE
></BLOCKQUOTE
><P
CLASS="para"
>Remember, you don't have to replace the newline but if you don't it
can make for some long lines.</P
><P
CLASS="para"
>What if there are other occurrences of &quot;Owner and Operator Guide&quot; that
break over multiple lines in different places?  You could modify the
regular expression to look for a space or a newline between words, as
shown below:</P
><BLOCKQUOTE
CLASS="screen"
><PRE
CLASS="screen"
>/Owner/{
N
s/Owner *\n*and *\n*Operator *\n*Guide/Installation Guide/
}</PRE
></BLOCKQUOTE
><P
CLASS="para"
>The asterisk indicates that the space or newline is optional.  This
seems like hard work, though, and indeed there is a more general way.
We have also changed the address to match &quot;Owner,&quot; the first word in
the pattern instead of the last.  We can read the newline into the
pattern space and then use a substitute command to remove the embedded
newline, wherever it is.</P
><BLOCKQUOTE
CLASS="screen"
><PRE
CLASS="screen"
>s/Owner and Operator Guide/Installation Guide/
/Owner/{
N
s/ *\n/ /
s/Owner and Operator Guide */Installation Guide\
/
}</PRE
></BLOCKQUOTE
><P
CLASS="para"
>The first line matches &quot;Owner and Operator Guide&quot; when it appears on a
line by itself.  (See the discussion after the example about why this
is necessary.)  If we match the string &quot;Owner,&quot; we read the next line
into the pattern space, and replace the embedded newline with a space.
Then we attempt to match the whole pattern and make the replacement
followed by a newline.  This script will match &quot;Owner and Operator
Guide&quot; regardless of how it is broken across two lines.  Here's our
expanded test file:</P
><BLOCKQUOTE
CLASS="screen"
><PRE
CLASS="screen"
>Consult Section 3.1 in the Owner and Operator
Guide for a description of the tape drives
available on your system.

Look in the Owner and Operator Guide shipped with your system.

Two manuals are provided including the Owner and
Operator Guide and the User Guide.

The Owner and Operator Guide is shipped with your system.</PRE
></BLOCKQUOTE
><P
CLASS="para"
>Running the above script on the sample file produces the following
result:</P
><BLOCKQUOTE
CLASS="screen"
><PRE
CLASS="screen"
>$ <CODE
CLASS="userinput"
><B
>sed -f sedscr sample</B
></CODE
>
Consult Section 3.1 in the Installation Guide
for a description of the tape drives
available on your system.

Look in the Installation Guide shipped with your system.

Two manuals are provided including the Installation Guide
and the User Guide.

The Installation Guide is shipped with your system.</PRE
></BLOCKQUOTE
><P
CLASS="para"
>In this sample script, it might seem redundant to have two substitute
commands that match the pattern.  The first one matches it when the
pattern is found already on one line and the second matches the
pattern after two lines have been read into the pattern space.  Why
the first command is necessary is perhaps best demonstrated by
removing that command from the script and running it on the sample
file:</P
><BLOCKQUOTE
CLASS="screen"
><PRE
CLASS="screen"
>$ <CODE
CLASS="userinput"
><B
>sed -f sedscr2 sample</B
></CODE
>
Consult Section 3.1 in the Installation Guide
for a description of the tape drives
available on your system.

Look in the Installation Guide
shipped with your system.
Two manuals are provided including the Installation Guide
and the User Guide.</PRE
></BLOCKQUOTE
><P
CLASS="para"
>Do you see the two problems?  The most obvious problem is that the
last line did not print.  The last line matches &quot;Owner&quot; and when
<KBD
CLASS="command"
>N</KBD
> is executed, there is not another input line to
read, so sed quits (immediately, without even outputting the line).  To
fix this, the Next command should be used as follows to be safe:</P
><BLOCKQUOTE
CLASS="screen"
><PRE
CLASS="screen"
>$!N</PRE
></BLOCKQUOTE
><P
CLASS="para"
>It excludes the last line ($) from the Next command.  As it is in our
script, by matching &quot;Owner and Operator Guide&quot; on the last line, we
avoid matching &quot;Owner&quot; and applying the <KBD
CLASS="command"
>N</KBD
> command.
However, if the word &quot;Owner&quot; appeared on the last line we'd have the
same problem unless we use the &quot;$!N&quot; syntax.</P
><P
CLASS="para"
>The second problem is a little less conspicuous.  It has to do with
the occurrence of &quot;Owner and Operator Guide&quot; in the second paragraph.
In the input file, it is found on a line by itself:</P
><BLOCKQUOTE
CLASS="screen"
><PRE
CLASS="screen"
>Look in the Owner and Operator Guide shipped with your system.</PRE
></BLOCKQUOTE
><P
CLASS="para"
>In the output shown above, the blank line following &quot;shipped with your
system.&quot; is missing.  The reason for this is that this line matches
&quot;Owner&quot; and the next line, a blank line, is appended to the pattern
space.  The substitute command removes the embedded newline and the
blank line has in effect vanished.  (If the line were not blank, the
newline would still be removed but the text would appear on the same
line with &quot;shipped with your system.&quot;)  The best solution seems to be
to avoid reading the next line when the pattern can be matched on one
line.  So, that is why the first instruction attempts to match the
case where the string appears all on one line.</P
><DIV
CLASS="sect3"
><H4
CLASS="sect3"
><A
CLASS="title"
NAME="SEDAWK-CH-6-SECT-1.1.1"
>6.1.1.1 Converting an Interleaf file</A
></H4
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="CH06.LEAF1"
></A
><A
CLASS="indexterm"
NAME="CH06.LEAF2"
></A
>FrameMaker and Interleaf make WYSIWYG technical publishing packages.  Both
of them have the ability to read and save the contents of a document
in an ASCII-coded format as opposed to their normal binary file
format.  In this example, we convert an Interleaf file into
<KBD
CLASS="command"
>troff</KBD
>; however, the same kind of script could be
applied to convert a <KBD
CLASS="command"
>troff</KBD
>-coded file to Interleaf
format.  The same is true of FrameMaker.  Both place coding tags in the
file, surrounded by angle brackets.</P
><P
CLASS="para"
>In this example, our conversion demonstrates the effect of the change
command on a multiline pattern space.  In the Interleaf file,
&quot;&lt;para&gt;&quot; marks a paragraph.  Before and after the tag are blank
lines.  Look at the sample file:</P
><BLOCKQUOTE
CLASS="screen"
><PRE
CLASS="screen"
>&lt;para&gt;

This is a test paragraph in Interleaf style ASCII.  Another line 
in a paragraph.  Yet another. 

&lt;Figure Begin&gt;

v.1111111111111111111111100000000000000000001111111111111000000
100001000100100010001000001000000000000000000000000000000000000
000000

&lt;Figure End&gt;

&lt;para&gt;

More lines of text to be found after the figure.
These lines should print.</PRE
></BLOCKQUOTE
><P
CLASS="para"
>This file also contains a bitmap figure, printed as a series of 1s and
0s.  To convert this file to <KBD
CLASS="command"
>troff</KBD
> macros, we must
replace the &quot;&lt;para&gt;&quot; code with a macro (.LP).  However, there's
a bit more to do because we need to remove the blank line that follows
the code.  There are several ways to do it, but we will use the Next
command to create a multiline pattern space, consisting of
&quot;&lt;para&gt;&quot; and the blank line, and then use the change command to
replace what's in the pattern space with a paragraph macro.  Here's
the part of the script that does it:</P
><BLOCKQUOTE
CLASS="screen"
><PRE
CLASS="screen"
>/&lt;para&gt;/{
	N
	c\
.LP
}</PRE
></BLOCKQUOTE
><P
CLASS="para"
>The address matches lines with the paragraph tag.  The Next command
appends the next line, which should be blank, to the pattern space.
We use the Next command (<KBD
CLASS="command"
>N</KBD
>) instead of next
(<KBD
CLASS="command"
>n</KBD
>) because we don't want to output the contents of
the pattern space.  The change command overwrites the previous
contents (&quot;&lt;para&gt;&quot; followed by a newline) of the pattern space,
even when it contains multiple lines.</P
><P
CLASS="para"
>In this conversion script, we'd like to extract the bitmapped figure
data and write it to a separate file.  In its place, we insert figure
macros that mark the figure in the file.</P
><BLOCKQUOTE
CLASS="screen"
><PRE
CLASS="screen"
>/&lt;Figure Begin&gt;/,/&lt;Figure End&gt;/{
	w fig.interleaf
	/&lt;Figure End&gt;/i\
.FG\
&lt;insert figure here&gt;\
.FE
	d
}</PRE
></BLOCKQUOTE
><P
CLASS="para"
>This procedure matches the lines between &quot;&lt;Figure Begin&gt;&quot; and
&quot;&lt;Figure End&gt;&quot; and writes them to the file named
<I
CLASS="filename"
>fig.interleaf</I
>.  Each time this instruction is
matched, the delete command will be executed, deleting the lines that
have been written to file.  When &quot;&lt;Figure End&gt;&quot; is matched, a
pair of macros are inserted in place of the figure in the output.
Notice that the subsequent delete command does not affect the text
output by the insert command.  It does, however, delete &quot;&lt;Figure
End&gt;&quot; from the pattern space.</P
><P
CLASS="para"
>Here's the entire script:</P
><BLOCKQUOTE
CLASS="screen"
><PRE
CLASS="screen"
>/&lt;para&gt;/{
	N
	c\
.LP
}
/&lt;Figure Begin&gt;/,/&lt;Figure End&gt;/{
	w fig.interleaf
	/&lt;Figure End&gt;/i\
.FG\
&lt;insert figure here&gt;\
.FE
	d
}
/^$/d</PRE
></BLOCKQUOTE
><P
CLASS="para"
>The third instruction simply removes unnecessary blank lines.  (Note
that this instruction could be depended upon to delete the blank line
following the &quot;&lt;para&gt;&quot; tag; but you don't always want to remove
all blank lines, and we wanted to demonstrate the change command across
a multiline pattern space.)</P
><P
CLASS="para"
>The result of running this script on the test file produces:</P
><BLOCKQUOTE
CLASS="screen"
><PRE
CLASS="screen"
>$ <CODE
CLASS="userinput"
><B
>sed -f sed.interleaf test.interleaf</B
></CODE
>
.LP
This is a test paragraph in Interleaf style ASCII.  Another line 
in a paragraph.  Yet another. 
.FG
&lt;insert figure here&gt;
.FE
.LP
More lines of text to be found after the figure.
These lines should print.</PRE
></BLOCKQUOTE
><A
CLASS="indexterm"
NAME="AUTOID-4141"
></A
><A
CLASS="indexterm"
NAME="AUTOID-4142"
></A
></DIV
><A
CLASS="indexterm"
NAME="AUTOID-4143"
></A
></DIV
><DIV
CLASS="sect2"
><H3
CLASS="sect2"
><A
CLASS="title"
NAME="SEDAWK-CH-6-SECT-1.2"
>6.1.2 Multiline Delete</A
></H3
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-4147"
></A
><A
CLASS="indexterm"
NAME="AUTOID-4150"
></A
>The delete command (<KBD
CLASS="command"
>d</KBD
>) deletes the contents of the
pattern space and causes a new line of input to be read with editing
resuming at the top of the script.  The Delete command
(<KBD
CLASS="command"
>D</KBD
>) works slightly differently: it deletes a
portion of the pattern space, up to the first embedded newline.  It
does not cause a new line of input to be read; instead, it returns to
the top of the script, applying these instructions to what remains in
the pattern space.  We can see the difference by writing a script that
looks for a series of blank lines and outputs a single blank line.
The version below uses the delete command:</P
><BLOCKQUOTE
CLASS="screen"
><PRE
CLASS="screen"
># reduce multiple blank lines to one; version using d command
/^$/{
	N
	/^\n$/d
}</PRE
></BLOCKQUOTE
><P
CLASS="para"
>When a blank line is encountered, the next line is appended to the
pattern space.  Then we try to match the embedded newline.  Note that
the positional metacharacters, ^ and $, match the beginning and the
end of the pattern space, respectively.  Here's a test file:</P
><BLOCKQUOTE
CLASS="screen"
><PRE
CLASS="screen"
>This line is followed by 1 blank line.

This line is followed by 2 blank lines.


This line is followed by 3 blank lines.



This line is followed by 4 blank lines.




This is the end.</PRE
></BLOCKQUOTE
><P
CLASS="para"
>Running the script on the test file produces the following result:</P
><BLOCKQUOTE
CLASS="screen"
><PRE
CLASS="screen"
>$ <CODE
CLASS="userinput"
><B
>sed -f sed.blank test.blank</B
></CODE
>
This line is followed by 1 blank line.

This line is followed by 2 blank lines.
This line is followed by 3 blank lines.

This line is followed by 4 blank lines.
This is the end.</PRE
></BLOCKQUOTE
><P
CLASS="para"
>Where there was an even number of blank lines, all the blank lines
were removed.  Only when there was an odd number was a single blank
line preserved.  That is because the delete command clears the entire
pattern space.  Once the first blank line is encountered, the next
line is read in, and both are deleted.  If a third blank line is
encountered, and the next line is not blank, the delete command is not
applied, and
thus a blank line is output.  If we use the multiline
Delete command (<KBD
CLASS="command"
>D</KBD
> rather than
<KBD
CLASS="command"
>d</KBD
>), we get the result we want:</P
><BLOCKQUOTE
CLASS="screen"
><PRE
CLASS="screen"
>$ <CODE
CLASS="userinput"
><B
>sed -f sed2.blank test.blank</B
></CODE
>
This line is followed by 1 blank line.

This line is followed by 2 blank lines.

This line is followed by 3 blank lines.

This line is followed by 4 blank lines.

This is the end.</PRE
></BLOCKQUOTE
><P
CLASS="para"
>The reason the multiline Delete command gets the job done is that
when we encounter two blank lines, the Delete command removes only the
first of the two.  The next time through the script, the blank line
will cause another line to be read into the pattern space.  If that
line is not blank, then both lines are output, thus ensuring that a
single blank line will be output.  In other words, when there are two
blank lines in the pattern space, only the first one is deleted.  When
there is a blank line followed by text, the pattern space is output
normally.</P
></DIV
><DIV
CLASS="sect2"
><H3
CLASS="sect2"
><A
CLASS="title"
NAME="SEDAWK-CH-6-SECT-1.3"
>6.1.3 Multiline Print</A
></H3
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-4169"
></A
><A
CLASS="indexterm"
NAME="CH06.PRINT1"
></A
>The multiline Print command differs slightly from its lowercase
cousin.  This command outputs the first portion of a multiline
pattern space, up to the first embedded newline.  After the last
command in a script is executed, the contents of the pattern space are
automatically output.  (The <I
CLASS="option"
>-n</I
> option or
<KBD
CLASS="command"
>#n</KBD
> suppresses this default action.)  Therefore, print
commands (<KBD
CLASS="command"
>P</KBD
> or <KBD
CLASS="command"
>p</KBD
>) are used when
the default output is suppressed or when flow of control in a script
changes such that the bottom of the script is not reached.  The Print
command frequently appears after the Next command and before the
Delete command.  These three commands can set up an input/output loop
that maintains a two-line pattern space yet outputs only one line at a
time.  The purpose of this loop is to output only the first line in
the pattern space, then return to the top of the script to apply all
commands to what had been the second line in the pattern space.
Without this loop, when the last command in the script was executed,
both lines in the pattern space would be output.  The flow through a
script that sets up an input/output loop using the Next, Print, and
Delete commands is illustrated in <A
CLASS="xref"
HREF="ch06_01.htm#SEDAWK-CH-6-FIG-1"
TITLE="The Next, Print, and Delete commands used to set up an input/output loop"
>Figure 6.1</A
>.
A multiline pattern space is created to match &quot;UNIX&quot; at the end of
the first line and &quot;System&quot; at the beginning of the second line.  If
&quot;UNIX System&quot; is found across two lines, we change it to &quot;UNIX
Operating System&quot;.  The loop is set up to return to the top of the
script and look for &quot;UNIX&quot; at the end of the second line.<A
CLASS="indexterm"
NAME="AUTOID-4180"
></A
><A
CLASS="indexterm"
NAME="AUTOID-4183"
></A
><A
CLASS="indexterm"
NAME="AUTOID-4186"
></A
></P
><H4
CLASS="figure"
><A
CLASS="title"
NAME="SEDAWK-CH-6-FIG-1"
>Figure 6.1: The Next, Print, and Delete commands used to set up an input/output loop</A
></H4
><IMG
CLASS="graphic"
SRC="figs/sed_0601.gif"
ALT="Figure 6.1"><P
CLASS="para"
>The Next command appends a new input line to the current line in the
pattern space.  After the substitute command is applied to the
multiline pattern space, the first part of the pattern space is
output by the Print command and then removed by the Delete command.
That means the current line is output and the new line becomes the
current line.  The Delete command prevents the script from reaching
bottom, which would output both lines and clear the contents of the
pattern space.  The Delete command lets us preserve the second portion
of the pattern space and pass control to the top of the script where
all the editing commands can now be applied to that line.  One of
those commands is the Next command which reads another new line into
the pattern space.</P
><P
CLASS="para"
>The following script implements the same loop:</P
><BLOCKQUOTE
CLASS="screen"
><PRE
CLASS="screen"
>/UNIX$/{
        N
        /\nSystem/{
        s// Operating &amp;/
        P
        D
        }
}</PRE
></BLOCKQUOTE
><P
CLASS="para"
>The substitute command matches &quot;\nSystem&quot; and replaces it with
&quot;Operating \nSystem.&quot;  It is important that the newline be
maintained, or else there will be only a single line in the pattern
space.  Note the order of the Print and Delete commands.  Here's our
test file:</P
><BLOCKQUOTE
CLASS="screen"
><PRE
CLASS="screen"
>Here are examples of the UNIX
System.  Where UNIX
System appears, it should be the UNIX
Operating System.</PRE
></BLOCKQUOTE
><P
CLASS="para"
>Running the script on the test file produces:</P
><BLOCKQUOTE
CLASS="screen"
><PRE
CLASS="screen"
>$ <CODE
CLASS="userinput"
><B
>sed -f sed.Print test.Print</B
></CODE
>
Here are examples of the UNIX Operating
System.  Where UNIX Operating
System appears, it should be the UNIX
Operating System.</PRE
></BLOCKQUOTE
><P
CLASS="para"
>The input/output loop lets us match the occurrence of UNIX at the end
of the second line.  It would be missed if the two-line pattern space
was output normally.</P
><P
CLASS="para"
>If the relationship between the <KBD
CLASS="command"
>P</KBD
> and
<KBD
CLASS="command"
>D</KBD
> commands remains unclear to you, we'll have
another go at it in the next example.  You can also experiment by
removing either command from the above script, or try using their
lowercase cousins.</P
><A
CLASS="indexterm"
NAME="AUTOID-4204"
></A
></DIV
><A
CLASS="indexterm"
NAME="AUTOID-4205"
></A
><A
CLASS="indexterm"
NAME="AUTOID-4206"
></A
><A
CLASS="indexterm"
NAME="AUTOID-4207"
></A
></DIV
></DIV
><DIV
CLASS="htmlnav"
><P
></P
><HR
ALIGN="LEFT"
WIDTH="515"
TITLE="footer"><TABLE
WIDTH="515"
BORDER="0"
CELLSPACING="0"
CELLPADDING="0"
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="172"
><A
CLASS="SECT1"
HREF="ch05_12.htm"
TITLE="5.12 Quit"
><IMG
SRC="../gifs/txtpreva.gif"
ALT="Previous: 5.12 Quit"
BORDER="0"></A
></TD
><TD
ALIGN="CENTER"
VALIGN="TOP"
WIDTH="171"
><A
CLASS="book"
HREF="index.htm"
TITLE="sed &amp; awk"
><IMG
SRC="../gifs/txthome.gif"
ALT="sed &amp; awk"
BORDER="0"></A
></TD
><TD
ALIGN="RIGHT"
VALIGN="TOP"
WIDTH="172"
><A
CLASS="SECT1"
HREF="ch06_02.htm"
TITLE="6.2 A Case for Study"
><IMG
SRC="../gifs/txtnexta.gif"
ALT="Next: 6.2 A Case for Study"
BORDER="0"></A
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="172"
>5.12 Quit</TD
><TD
ALIGN="CENTER"
VALIGN="TOP"
WIDTH="171"
><A
CLASS="index"
HREF="index/idx_0.htm"
TITLE="Book Index"
><IMG
SRC="../gifs/index.gif"
ALT="Book Index"
BORDER="0"></A
></TD
><TD
ALIGN="RIGHT"
VALIGN="TOP"
WIDTH="172"
>6.2 A Case for Study</TD
></TR
></TABLE
><HR
ALIGN="LEFT"
WIDTH="515"
TITLE="footer"><IMG
SRC="../gifs/smnavbar.gif"
USEMAP="#map"
BORDER="0"
ALT="The UNIX CD Bookshelf Navigation"><MAP
NAME="map"
><AREA
SHAPE="RECT"
COORDS="0,0,73,21"
HREF="../index.htm"
ALT="The UNIX CD Bookshelf"><AREA
SHAPE="RECT"
COORDS="74,0,163,21"
HREF="../upt/index.htm"
ALT="UNIX Power Tools"><AREA
SHAPE="RECT"
COORDS="164,0,257,21"
HREF="../unixnut/index.htm"
ALT="UNIX in a Nutshell"><AREA
SHAPE="RECT"
COORDS="258,0,321,21"
HREF="../vi/index.htm"
ALT="Learning the vi Editor"><AREA
SHAPE="RECT"
COORDS="322,0,378,21"
HREF="index.htm"
ALT="sed &amp; awk"><AREA
SHAPE="RECT"
COORDS="379,0,438,21"
HREF="../ksh/index.htm"
ALT="Learning the Korn Shell"><AREA
SHAPE="RECT"
COORDS="439,0,514,21"
HREF="../lrnunix/index.htm"
ALT="Learning the UNIX Operating System"></MAP
></DIV
></BODY
></HTML
>
