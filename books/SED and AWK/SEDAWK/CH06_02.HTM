<HTML
><HEAD
>
<TITLE>[Chapter 6] 6.2 A Case for Study</TITLE>
<META
NAME="DC.title"
CONTENT="sed &amp; awk"><META
NAME="DC.creator"
CONTENT="Dale Dougherty &amp; Arnold Robbins"><META
NAME="DC.publisher"
CONTENT="O'Reilly &amp; Associates, Inc."><META
NAME="DC.date"
CONTENT="1998-08-03T20:55:08Z"><META
NAME="DC.type"
CONTENT="Text.Monograph"><META
NAME="DC.format"
CONTENT="text/html"
SCHEME="MIME"><META
NAME="DC.source"
CONTENT="1-56592-225-5"
SCHEME="ISBN"><META
NAME="DC.language"
CONTENT="en-US"><META
NAME="generator"
CONTENT="Jade 1.1/O'Reilly DocBook 3.0 to HTML 4.0"><LINK
REV="made"
HREF="mailto:online-books@oreilly.com"
TITLE="Online Books Comments"><LINK
REL="up"
HREF="ch06_01.htm"
TITLE="6. Advanced sed Commands"><LINK
REL="prev"
HREF="ch06_01.htm"
TITLE="6.1 Multiline Pattern Space"><LINK
REL="next"
HREF="ch06_03.htm"
TITLE="6.3 Hold That Line"></HEAD
><BODY
BGCOLOR="#FFFFFF"
TEXT="#000000"
><DIV
CLASS="htmlnav"
><H1
><IMG
SRC="gifs/smbanner.gif"
ALT="sed &amp; awk"
USEMAP="#srchmap"
BORDER="0"></H1
><MAP
NAME="srchmap"
><AREA
SHAPE="RECT"
COORDS="0,0,466,65"
HREF="index.htm"
ALT="sed &amp; awk"><AREA
SHAPE="RECT"
COORDS="467,0,514,18"
HREF="../search/ssrch.htm"
ALT="Search this book"></MAP
><TABLE
WIDTH="515"
BORDER="0"
CELLSPACING="0"
CELLPADDING="0"
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="172"
><A
CLASS="SECT1"
HREF="ch06_01.htm"
TITLE="6.1 Multiline Pattern Space"
><IMG
SRC="../gifs/txtpreva.gif"
ALT="Previous: 6.1 Multiline Pattern Space"
BORDER="0"></A
></TD
><TD
ALIGN="CENTER"
VALIGN="TOP"
WIDTH="171"
><B
><FONT
FACE="ARIEL,HELVETICA,HELV,SANSERIF"
SIZE="-1"
>Chapter 6<BR>Advanced sed Commands</FONT
></B
></TD
><TD
ALIGN="RIGHT"
VALIGN="TOP"
WIDTH="172"
><A
CLASS="SECT1"
HREF="ch06_03.htm"
TITLE="6.3 Hold That Line"
><IMG
SRC="../gifs/txtnexta.gif"
ALT="Next: 6.3 Hold That Line"
BORDER="0"></A
></TD
></TR
></TABLE
>&nbsp;<HR
ALIGN="LEFT"
WIDTH="515"
TITLE="footer"></DIV
><DIV
CLASS="SECT1"
><H2
CLASS="sect1"
><A
CLASS="title"
NAME="SEDAWK-CH-6-SECT-2"
>6.2 A Case for Study</A
></H2
><P
CLASS="para"
>Lenny, on our staff, was having difficulty converting a document coded
for Scribe to our <KBD
CLASS="command"
>troff</KBD
> macro package, because of
font changes.  The problems he encountered are quite interesting,
apart from the task he was trying to do.</P
><P
CLASS="para"
>The Scribe convention for putting text in a bold font is:</P
><BLOCKQUOTE
CLASS="screen"
><PRE
CLASS="screen"
>@f1(put this in bold)</PRE
></BLOCKQUOTE
><P
CLASS="para"
>This font change command can appear in-line and may begin on one line
and end on a subsequent line.  It can also appear more than once on a
line.  Here's a sample file that shows several different occurrences:</P
><BLOCKQUOTE
CLASS="screen"
><PRE
CLASS="screen"
>$ <CODE
CLASS="userinput"
><B
>cat test</B
></CODE
>
I want to see @f1(what will happen) if we put the
font change commands @f1(on a set of lines).  If I understand
things (correctly), the @f1(third) line causes problems. (No?).
Is this really the case, or is it (maybe) just something else?

Let's test having two on a line @f1(here) and @f1(there) as
well as one that begins on one line and ends @f1(somewhere 
on another line).  What if @f1(it is here) on the line?
Another @f1(one).</PRE
></BLOCKQUOTE
><P
CLASS="para"
>The sample file shows the different contexts in which the font-change
commands appear.  The script must match &quot;@f1(anything)&quot; when it occurs
on a single line or multiple times on the same line or when it extends
across more than one line.</P
><P
CLASS="para"
>The easiest way to make a single match is:</P
><BLOCKQUOTE
CLASS="screen"
><PRE
CLASS="screen"
>s/@f1(\(.*\))/\\fB\1\\fR/g</PRE
></BLOCKQUOTE
><P
CLASS="para"
>The regular expression matches &quot;@f1(.*)&quot; and saves anything inside
parentheses using \( and \).  In the replacement section, the saved
portion of the match is recalled as &quot;\1&quot;.</P
><P
CLASS="para"
>Putting this command in a sed script, we will run it on our sample file.</P
><BLOCKQUOTE
CLASS="screen"
><PRE
CLASS="screen"
>$ <CODE
CLASS="userinput"
><B
>sed -f sed.len test</B
></CODE
>
I want to see \fBwhat will happen\fR if we put the
font change commands \fBon a set of lines\fR.  If I understand
things (correctly), the \fBthird) line causes problems. (No?\fR.
Is this really the case, or is it (maybe) just something else?

Let's test having two on a line \fBhere) and @f1(there\fR as
well as one that begins on one line and ends @f1(somewhere 
on another line).  What if \fBit is here\fR on the line?
Another \fBone\fR.</PRE
></BLOCKQUOTE
><P
CLASS="para"
>The substitute command works properly in the first two lines.  It
fails on the third line.  It also fails in the first line of the
second paragraph where there are multiple occurrences on the same
line.</P
><P
CLASS="para"
>Because a regular expression always makes the longest match possible,
&quot;.*&quot; matches all the characters from &quot;@f1(&quot; to the
<EM
CLASS="emphasis"
>last</EM
> closing parenthesis on the line.  In other
words, the span indicated by &quot;.*&quot; ends with the last close parenthesis
it finds, not the first.</P
><P
CLASS="para"
>We can fix this problem by modifying the regular expression &quot;.*&quot; to
zero or more occurrences of any character except &quot;)&quot;.</P
><BLOCKQUOTE
CLASS="screen"
><PRE
CLASS="screen"
>[^)]*</PRE
></BLOCKQUOTE
><P
CLASS="para"
>In a character class, the caret (^) reverses the sense of the
operation so it matches all characters except those specified in the
brackets.  Here's how the revised command looks:</P
><BLOCKQUOTE
CLASS="screen"
><PRE
CLASS="screen"
>s/@f1(\([^)]*\))/\\fB\1\\fR/g</PRE
></BLOCKQUOTE
><P
CLASS="para"
>Now we have a command that handles one or more occurrences on a
single line.  </P
><BLOCKQUOTE
CLASS="screen"
><PRE
CLASS="screen"
>I want to see \fBwhat will happen\fR if we put the
font change commands \fBon a set of lines\fR.  If I understand
things (correctly), the \fBthird\fR line causes problems. (No?).
Is this really the case, or is it (maybe) just something else?

Let's test having two on a line \fBhere\fR and \fBthere\fR as
well as one that begins on one line and ends @f1(somewhere 
on another line).  What if \fBit is here\fR on the line?
Another \fBone\fR.</PRE
></BLOCKQUOTE
><P
CLASS="para"
>This command gets all instances except the one in the second paragraph
that extends over two lines.  Before solving this problem, it is
interesting to look at Lenny's first solution to it and why it fails.
Here's Lenny's first script:</P
><BLOCKQUOTE
CLASS="screen"
><PRE
CLASS="screen"
>/@f1(/,/)/{
	s/@f1(/\\fB/g
	s/)/\\fR/g
}</PRE
></BLOCKQUOTE
><P
CLASS="para"
>He tried to attack the problem of matching an occurrence over
multiple lines by specifying a range of lines. 
Here's the result of running the script on the test file:</P
><BLOCKQUOTE
CLASS="screen"
><PRE
CLASS="screen"
>$ <CODE
CLASS="userinput"
><B
>sed -f sed.len test.len</B
></CODE
>
I want to see \fBwhat will happen\fR if we put the
font change commands \fBon a set of lines\fR.  If I understand
things (correctly, the \fBthird) line causes problems. (No?\fR.
Is this really the case, or is it (maybe) just something else?

Let's test having two on a line \fBhere) and (there\fR as
well as one that begins on one line and ends \fBsomewhere 
on another line\fR.  What if \fBit is here\fR on the line?
Another \fBone\fR.</PRE
></BLOCKQUOTE
><P
CLASS="para"
>Matching lines containing &quot;)&quot; makes unwanted matches on lines
containing only parentheses.
The solution to matching the pattern over more than one line is to
create a multiline pattern space.  If we match &quot;@f1(&quot; and no closing
parenthesis is found, we need to read (<KBD
CLASS="command"
>N</KBD
>) another
line into the buffer and try to make the same kind of match as the
first case (the \n represents the newline).</P
><BLOCKQUOTE
CLASS="screen"
><PRE
CLASS="screen"
>s/@f1(\([^)]*\))/\\fB\1\\fR/g
/@f1(.*/{
	N
	s/@f1(\(.*\n[^)]*\))/\\fB\1\\fR/g
}</PRE
></BLOCKQUOTE
><P
CLASS="para"
>We can test it out:</P
><BLOCKQUOTE
CLASS="screen"
><PRE
CLASS="screen"
>$ <CODE
CLASS="userinput"
><B
>sed -f sednew test</B
></CODE
>
I want to see \fBwhat will happen\fR if we put the
font change commands \fBon a set of lines\fR.  If I understand
things (correctly), the \fBthird\fR line causes problems. (No?).
Is this really the case, or is it (maybe) just something else?

Let's test having two on a line \fBhere\fR and \fBthere\fR as
well as one that begins on one line and ends \fBsomewhere 
on another line\fR.  What if @f1(it is here) on the line?
Another \fBone\fR.</PRE
></BLOCKQUOTE
><P
CLASS="para"
>As you can see, we have caught all but the next to last font change.  The
<KBD
CLASS="command"
>N</KBD
> command reads a second line into the pattern
space.  The script matches the pattern across two lines and then
outputs <EM
CLASS="emphasis"
>both</EM
> lines from the pattern space.  What
about the second line?  It needs a chance to have all the commands in
the script applied to it from top to bottom.  Now, perhaps you
understand why we need to set up a multiline input/output loop like
the one discussed in the previous section.  We add the multiline
Print and multiline Delete to the script.</P
><BLOCKQUOTE
CLASS="screen"
><PRE
CLASS="screen"
># Scribe font change script.
s/@f1(\([^)]*\))/\\fB\1\\fR/g
/@f1(.*/{
	N
	s/@f1(\(.*\n[^)]*\))/\\fB\1\\fR/g
	P
	D
}</PRE
></BLOCKQUOTE
><P
CLASS="para"
>This can be translated as: Once making a substitution across two
lines, print the first line and then delete it from the pattern space.
With the second portion remaining in the pattern space, control passes
to the top of the script where we see if there is an &quot;@f1(&quot; remaining
on the line.</P
><P
CLASS="para"
>The revised script matches all occurrences in the sample file.
However, it's not perfect, so we'll hear from Lenny again.</P
></DIV
><DIV
CLASS="htmlnav"
><P
></P
><HR
ALIGN="LEFT"
WIDTH="515"
TITLE="footer"><TABLE
WIDTH="515"
BORDER="0"
CELLSPACING="0"
CELLPADDING="0"
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="172"
><A
CLASS="SECT1"
HREF="ch06_01.htm"
TITLE="6.1 Multiline Pattern Space"
><IMG
SRC="../gifs/txtpreva.gif"
ALT="Previous: 6.1 Multiline Pattern Space"
BORDER="0"></A
></TD
><TD
ALIGN="CENTER"
VALIGN="TOP"
WIDTH="171"
><A
CLASS="book"
HREF="index.htm"
TITLE="sed &amp; awk"
><IMG
SRC="../gifs/txthome.gif"
ALT="sed &amp; awk"
BORDER="0"></A
></TD
><TD
ALIGN="RIGHT"
VALIGN="TOP"
WIDTH="172"
><A
CLASS="SECT1"
HREF="ch06_03.htm"
TITLE="6.3 Hold That Line"
><IMG
SRC="../gifs/txtnexta.gif"
ALT="Next: 6.3 Hold That Line"
BORDER="0"></A
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="172"
>6.1 Multiline Pattern Space</TD
><TD
ALIGN="CENTER"
VALIGN="TOP"
WIDTH="171"
><A
CLASS="index"
HREF="index/idx_0.htm"
TITLE="Book Index"
><IMG
SRC="../gifs/index.gif"
ALT="Book Index"
BORDER="0"></A
></TD
><TD
ALIGN="RIGHT"
VALIGN="TOP"
WIDTH="172"
>6.3 Hold That Line</TD
></TR
></TABLE
><HR
ALIGN="LEFT"
WIDTH="515"
TITLE="footer"><IMG
SRC="../gifs/smnavbar.gif"
USEMAP="#map"
BORDER="0"
ALT="The UNIX CD Bookshelf Navigation"><MAP
NAME="map"
><AREA
SHAPE="RECT"
COORDS="0,0,73,21"
HREF="../index.htm"
ALT="The UNIX CD Bookshelf"><AREA
SHAPE="RECT"
COORDS="74,0,163,21"
HREF="../upt/index.htm"
ALT="UNIX Power Tools"><AREA
SHAPE="RECT"
COORDS="164,0,257,21"
HREF="../unixnut/index.htm"
ALT="UNIX in a Nutshell"><AREA
SHAPE="RECT"
COORDS="258,0,321,21"
HREF="../vi/index.htm"
ALT="Learning the vi Editor"><AREA
SHAPE="RECT"
COORDS="322,0,378,21"
HREF="index.htm"
ALT="sed &amp; awk"><AREA
SHAPE="RECT"
COORDS="379,0,438,21"
HREF="../ksh/index.htm"
ALT="Learning the Korn Shell"><AREA
SHAPE="RECT"
COORDS="439,0,514,21"
HREF="../lrnunix/index.htm"
ALT="Learning the UNIX Operating System"></MAP
></DIV
></BODY
></HTML
>
