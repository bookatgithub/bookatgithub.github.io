<HTML
><HEAD
>
<TITLE>[Chapter 6] 6.3 Hold That Line</TITLE>
<META
NAME="DC.title"
CONTENT="sed &amp; awk"><META
NAME="DC.creator"
CONTENT="Dale Dougherty &amp; Arnold Robbins"><META
NAME="DC.publisher"
CONTENT="O'Reilly &amp; Associates, Inc."><META
NAME="DC.date"
CONTENT="1998-08-03T20:55:10Z"><META
NAME="DC.type"
CONTENT="Text.Monograph"><META
NAME="DC.format"
CONTENT="text/html"
SCHEME="MIME"><META
NAME="DC.source"
CONTENT="1-56592-225-5"
SCHEME="ISBN"><META
NAME="DC.language"
CONTENT="en-US"><META
NAME="generator"
CONTENT="Jade 1.1/O'Reilly DocBook 3.0 to HTML 4.0"><LINK
REV="made"
HREF="mailto:online-books@oreilly.com"
TITLE="Online Books Comments"><LINK
REL="up"
HREF="ch06_01.htm"
TITLE="6. Advanced sed Commands"><LINK
REL="prev"
HREF="ch06_02.htm"
TITLE="6.2 A Case for Study"><LINK
REL="next"
HREF="ch06_04.htm"
TITLE="6.4 Advanced Flow Control Commands"></HEAD
><BODY
BGCOLOR="#FFFFFF"
TEXT="#000000"
><DIV
CLASS="htmlnav"
><H1
><IMG
SRC="gifs/smbanner.gif"
ALT="sed &amp; awk"
USEMAP="#srchmap"
BORDER="0"></H1
><MAP
NAME="srchmap"
><AREA
SHAPE="RECT"
COORDS="0,0,466,65"
HREF="index.htm"
ALT="sed &amp; awk"><AREA
SHAPE="RECT"
COORDS="467,0,514,18"
HREF="../search/ssrch.htm"
ALT="Search this book"></MAP
><TABLE
WIDTH="515"
BORDER="0"
CELLSPACING="0"
CELLPADDING="0"
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="172"
><A
CLASS="SECT1"
HREF="ch06_02.htm"
TITLE="6.2 A Case for Study"
><IMG
SRC="../gifs/txtpreva.gif"
ALT="Previous: 6.2 A Case for Study"
BORDER="0"></A
></TD
><TD
ALIGN="CENTER"
VALIGN="TOP"
WIDTH="171"
><B
><FONT
FACE="ARIEL,HELVETICA,HELV,SANSERIF"
SIZE="-1"
>Chapter 6<BR>Advanced sed Commands</FONT
></B
></TD
><TD
ALIGN="RIGHT"
VALIGN="TOP"
WIDTH="172"
><A
CLASS="SECT1"
HREF="ch06_04.htm"
TITLE="6.4 Advanced Flow Control Commands"
><IMG
SRC="../gifs/txtnexta.gif"
ALT="Next: 6.4 Advanced Flow Control Commands"
BORDER="0"></A
></TD
></TR
></TABLE
>&nbsp;<HR
ALIGN="LEFT"
WIDTH="515"
TITLE="footer"></DIV
><DIV
CLASS="SECT1"
><H2
CLASS="sect1"
><A
CLASS="title"
NAME="SEDAWK-CH-6-SECT-3"
>6.3 Hold That Line</A
></H2
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="CH06.HOLD"
></A
><A
CLASS="indexterm"
NAME="AUTOID-4255"
></A
><A
CLASS="indexterm"
NAME="AUTOID-4258"
></A
>The pattern space is a buffer that contains the current input line.
There is also a set-aside buffer called the <EM
CLASS="emphasis"
>hold
space</EM
>.  The contents of the pattern space can be copied to
the hold space and the contents of the hold space can be copied to the
pattern space.  A group of commands allows you to move data between
the hold space and the pattern space.  The hold space is used for
temporary storage, and that's it.  Individual commands can't address
the hold space or alter its contents.</P
><P
CLASS="para"
>The most frequent use of the hold space is to have it retain a
duplicate of the current input line while you change the original in
the pattern space.  The commands that affect the pattern space are:</P
><TABLE
CLASS="informaltable"
><THEAD
CLASS="thead"
><TR
CLASS="row"
VALIGN="TOP"
><TH
CLASS="entry"
ALIGN="LEFT"
ROWSPAN="1"
COLSPAN="1"
>Command</TH
><TH
CLASS="entry"
ALIGN="LEFT"
ROWSPAN="1"
COLSPAN="1"
>Abbreviation</TH
><TH
CLASS="entry"
ALIGN="LEFT"
ROWSPAN="1"
COLSPAN="1"
>Function</TH
></TR
></THEAD
><TBODY
CLASS="tbody"
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
>Hold</TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><KBD
CLASS="command"
>h</KBD
> or <KBD
CLASS="command"
>H</KBD
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Copy or append contents of pattern space to hold space.</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
>Get</TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><KBD
CLASS="command"
>g</KBD
> or <KBD
CLASS="command"
>G</KBD
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Copy or append contents of hold space to pattern space.</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
>Exchange</TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><KBD
CLASS="command"
>x</KBD
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Swap contents of hold space and pattern space.</P
></TD
></TR
></TBODY
></TABLE
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="CH06.H1"
></A
><A
CLASS="indexterm"
NAME="AUTOID-4295"
></A
><A
CLASS="indexterm"
NAME="AUTOID-4297"
></A
><A
CLASS="indexterm"
NAME="AUTOID-4300"
></A
><A
CLASS="indexterm"
NAME="AUTOID-4302"
></A
>Each of these commands can take an address that specifies a single
line or a range of lines.  The hold
(<KBD
CLASS="command"
>h</KBD
>,<KBD
CLASS="command"
>H</KBD
>) commands move data into
the hold space and the get (<KBD
CLASS="command"
>g</KBD
>,<KBD
CLASS="command"
>G</KBD
>)
commands move data from the hold space back into the pattern space.
The difference between the lowercase and uppercase versions of the
same command is that the lowercase command overwrites the contents of
the target buffer, while the uppercase command appends to the buffer's existing
contents.</P
><P
CLASS="para"
>The hold command replaces the contents of the hold space with the
contents of the pattern space.  The get command replaces the contents
of the pattern space with the contents of the hold space.</P
><P
CLASS="para"
>The Hold command puts a newline followed by the contents of the
pattern space after the contents of the hold space.  (The newline is
appended to the hold space even if the hold space is empty.)  The Get
command puts a newline followed by the contents of the hold space
after the contents of the pattern space.</P
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-4312"
></A
><A
CLASS="indexterm"
NAME="AUTOID-4314"
></A
>The exchange command swaps the contents of the two buffers.  It has no
side effects on either buffer.</P
><P
CLASS="para"
>Let's use a trivial example to illustrate putting lines into the hold
space and retrieving them later.  We are going to write a script that
reverses pairs of lines.  For a sample file, we'll use a list of
numbers:</P
><BLOCKQUOTE
CLASS="screen"
><PRE
CLASS="screen"
>1
2
11
22
111
222</PRE
></BLOCKQUOTE
><P
CLASS="para"
>The object is to reverse the order of the lines beginning with 1 and
the lines beginning with 2.  Here's how we use the hold space: we copy
the first line to the hold space&nbsp;- and hold on to it&nbsp;- while
we clear the pattern space.  Then sed reads the second line into the
pattern space and we append the line from the hold space to the end of
the pattern space.  Look at the script:</P
><BLOCKQUOTE
CLASS="screen"
><PRE
CLASS="screen"
># Reverse flip
/1/{
h
d
}
/2/{
G
}</PRE
></BLOCKQUOTE
><P
CLASS="para"
>Any line matching a &quot;1&quot; is copied to the hold space and deleted from
the pattern space.  Control passes to the top of the script and the
line is not printed.  When the next line is read, it matches the
pattern &quot;2&quot; and the line that had been copied to the hold space is
now appended to the pattern space.  Then both lines are printed.  In
other words, we save the first line of the pair and don't output it
until we match the second line.</P
><P
CLASS="para"
>Here's the result of running the script on the sample file:</P
><BLOCKQUOTE
CLASS="screen"
><PRE
CLASS="screen"
>$ <CODE
CLASS="userinput"
><B
>sed -f sed.flip test.flip</B
></CODE
>
2
1
22
11
222
111</PRE
></BLOCKQUOTE
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-4326"
></A
>The hold command followed by the delete command is a fairly common
pairing.  Without the delete command, control would reach the bottom
of the script and the contents of the pattern space would be output.
If the script used the next (<KBD
CLASS="command"
>n</KBD
>) command instead of
the delete command, the contents of the pattern space would also be
output.  You can experiment with this script by removing the delete
command altogether or by putting a next command in its place.  You
could also see what happens if you use <KBD
CLASS="command"
>g</KBD
> instead of
<KBD
CLASS="command"
>G</KBD
>.<A
CLASS="indexterm"
NAME="AUTOID-4332"
></A
></P
><P
CLASS="para"
>Note that the logic of this script is poor, though the script is
useful for demonstration purposes.  If a line matches the first
instruction and the next line fails to match the second instruction,
the first line will not be output.  This is a hole down which lines
disappear.</P
><DIV
CLASS="sect2"
><H3
CLASS="sect2"
><A
CLASS="title"
NAME="SEDAWK-CH-6-SECT-3.1"
>6.3.1 A Capital Transformation</A
></H3
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-4337"
></A
>In the previous chapter, we introduced the transform command
(<KBD
CLASS="command"
>y</KBD
>) and described how it can exchange lowercase
letters for uppercase letters on a line.  Since this command acts on
the entire contents of the pattern space, it is something of a chore
to do a letter-by-letter transformation of a portion of the line.  But
it is possible, though convoluted, as the following example will
demonstrate.</P
><P
CLASS="para"
>While working on a programming guide, we found that the names of
statements were entered inconsistently.  They needed to be uppercase,
but some were lowercase while others had an initial capital letter.
While the task was simple&nbsp;- to capitalize the name of the
statement&nbsp;- there were nearly 100 statements and it seemed a
tedious project to write that many explicit substitutions of the form:</P
><BLOCKQUOTE
CLASS="screen"
><PRE
CLASS="screen"
>s/find the Match statement/find the MATCH statement/g</PRE
></BLOCKQUOTE
><P
CLASS="para"
>The transform command could do the lowercase-to-uppercase conversion
but it applies the conversion to the entire line.  The hold space
makes this task possible because we use it to store a copy of the
input line while we isolate and convert the statement name in the
pattern space.  Look at the script first:</P
><BLOCKQUOTE
CLASS="screen"
><PRE
CLASS="screen"
># capitalize statement names
/the .* statement/{
h
s/.*the \(.*\) statement.*/\1/
y/abcdefghijklmnopqrstuvwxyz/ABCDEFGHIJKLMNOPQRSTUVWXYZ/
G
s/\(.*\)\n\(.*the \).*\( statement.*\)/\2\1\3/
}</PRE
></BLOCKQUOTE
><P
CLASS="para"
>The address limits the procedure to lines that match &quot;the .* statement&quot;.
Let's look at what each command does:</P
><DL
CLASS="variablelist"
><DT
CLASS="term"
><CODE
CLASS="literal"
>h</CODE
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
>The hold command copies the current input line into the hold space.<A
CLASS="indexterm"
NAME="AUTOID-4351"
></A
>
Using the sample line &quot;find the Match statement,&quot; we'll show the
contents of the pattern space and of the hold space.  After 
the <KBD
CLASS="command"
>h</KBD
> command, both the pattern space and 
the hold space are identical.</P
><TABLE
CLASS="informaltable"
><TBODY
CLASS="tbody"
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><CODE
CLASS="replaceable"
><I
>Pattern Space:</I
></CODE
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><CODE
CLASS="literal"
>find the Match statement</CODE
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><CODE
CLASS="replaceable"
><I
>Hold Space:</I
></CODE
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><CODE
CLASS="literal"
>find the Match statement</CODE
></TD
></TR
></TBODY
></TABLE
></DD
><DT
CLASS="term"
><CODE
CLASS="literal"
>s/.*the \(.*\) statement.*/\1/</CODE
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
>The substitute command extracts the name of the statement from the
line and replaces the entire line with it.</P
><TABLE
CLASS="informaltable"
><TBODY
CLASS="tbody"
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><CODE
CLASS="replaceable"
><I
>Pattern Space:</I
></CODE
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><CODE
CLASS="literal"
>Match</CODE
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><CODE
CLASS="replaceable"
><I
>Hold Space:</I
></CODE
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><CODE
CLASS="literal"
>find the Match statement</CODE
></TD
></TR
></TBODY
></TABLE
></DD
><DT
CLASS="term"
><CODE
CLASS="literal"
>y/abcdefghijklmnopqrstuvwxyz/ABCDEFGHIJKLMNOPQRSTUVWXYZ/</CODE
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
>The transform command changes each lowercase letter to an uppercase
letter.</P
><TABLE
CLASS="informaltable"
><TBODY
CLASS="tbody"
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><CODE
CLASS="replaceable"
><I
>Pattern Space:</I
></CODE
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><CODE
CLASS="literal"
>MATCH</CODE
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><CODE
CLASS="replaceable"
><I
>Hold Space:</I
></CODE
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><CODE
CLASS="literal"
>find the Match statement</CODE
></TD
></TR
></TBODY
></TABLE
></DD
><DT
CLASS="term"
><CODE
CLASS="literal"
>G</CODE
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
>The Get command appends the line saved in the hold space to the
pattern space.</P
><TABLE
CLASS="informaltable"
><TBODY
CLASS="tbody"
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><CODE
CLASS="replaceable"
><I
>Pattern Space:</I
></CODE
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><CODE
CLASS="literal"
>MATCH\nfind the Match statement</CODE
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><CODE
CLASS="replaceable"
><I
>Hold Space:</I
></CODE
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><CODE
CLASS="literal"
>find the Match statement</CODE
></TD
></TR
></TBODY
></TABLE
></DD
><DT
CLASS="term"
><CODE
CLASS="literal"
>s/\(.*\)\n\(.*the \).*\( statement.*\)/\2\1\3/</CODE
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
>The substitute command matches three different parts of the pattern
space: 1) all characters up to the embedded newline, 2) all characters
following the embedded newline and up to and including &quot;the&quot; followed
by a space, and 3) all characters beginning with a space and followed
by &quot;statement&quot; up to the end of the pattern space.  The name of the
statement as it appeared in the original line is matched but not
saved.  The replacement section of this command recalls the saved
portions and reassembles them in a different order, putting the
capitalized name of the command in between &quot;the&quot; and &quot;statement.&quot;</P
><TABLE
CLASS="informaltable"
><TBODY
CLASS="tbody"
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><CODE
CLASS="replaceable"
><I
>Pattern Space:</I
></CODE
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><CODE
CLASS="literal"
>find the MATCH statement</CODE
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><CODE
CLASS="replaceable"
><I
>Hold Space:</I
></CODE
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><CODE
CLASS="literal"
>find the Match statement</CODE
></TD
></TR
></TBODY
></TABLE
></DD
></DL
><P
CLASS="para"
>Let's look at a test run.  Here's our sample file:</P
><BLOCKQUOTE
CLASS="screen"
><PRE
CLASS="screen"
>find the Match statement
Consult the Get statement.
using the Read statement to retrieve data</PRE
></BLOCKQUOTE
><P
CLASS="para"
>Running the script on the sample file produces:</P
><BLOCKQUOTE
CLASS="screen"
><PRE
CLASS="screen"
>find the MATCH statement
Consult the GET statement.
using the READ statement to retrieve data</PRE
></BLOCKQUOTE
><P
CLASS="para"
>As you can see from this script, skillful use of the hold space can
aid in isolating and manipulating portions of the input line.</P
></DIV
><DIV
CLASS="sect2"
><H3
CLASS="sect2"
><A
CLASS="title"
NAME="SEDAWK-CH-6-SECT-3.2"
>6.3.2 Correcting Index Entries (Part II)</A
></H3
><P
CLASS="para"
>In the previous chapter, we looked at a shell script named
<KBD
CLASS="command"
>index.edit</KBD
>.  This script extracts index entries
from one or more files and automatically generates a sed script
consisting of a substitute command for each index entry.  We mentioned
that a small failing of the script was that it did not look out for regular
expression metacharacters that appeared as literals in an index entry,
such as the following:</P
><BLOCKQUOTE
CLASS="screen"
><PRE
CLASS="screen"
>.XX &quot;asterisk (*) metacharacter&quot;</PRE
></BLOCKQUOTE
><P
CLASS="para"
>After processing this entry, the original <KBD
CLASS="command"
>index.edit</KBD
> 
generated the following substitute command:</P
><BLOCKQUOTE
CLASS="screen"
><PRE
CLASS="screen"
>/^\.XX /s/asterisk (*) metacharacter/asterisk (*) metacharacter/</PRE
></BLOCKQUOTE
><P
CLASS="para"
>While it &quot;knows&quot; to escape the period before &quot;.XX&quot;, it doesn't protect
the metacharacter &quot;*&quot;.  The problem is that the pattern &quot;(*)&quot; does not
match &quot;(*)&quot; and the substitute command would fail to be applied.  The
solution is to modify <KBD
CLASS="command"
>index.edit</KBD
> so
it looks for metacharacters and escapes them.  There's one more
twist: a different set of metacharacters is recognized in the
replacement string.</P
><P
CLASS="para"
>We have to maintain two copies of the index entry.  The first copy we
edit to escape regular expression metacharacters and then use for the
pattern.  The second copy we edit to escape the metacharacters special
to the replacement string.  The hold space keeps the second copy while
we edit the first copy, then we swap the two and edit the second copy.
Here's the script:</P
><BLOCKQUOTE
CLASS="screen"
><PRE
CLASS="screen"
>#! /bin/sh
# index.edit -- compile list of index entries for editing
#		new version that matches metacharacters
grep &quot;^\.XX&quot; $* | sort -u |
sed '
h
s/[][\\*.]/\\&amp;/g
x
s/[\\&amp;]/\\&amp;/g
s/^\.XX //
s/$/\//
x
s/^\\\.XX \(.*\)$/\/^\\.XX \/s\/\1\//
G
s/\n//'</PRE
></BLOCKQUOTE
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-4457"
></A
>The hold command puts a copy of the current index entry into the hold
space.  Then the substitute command looks for any of the following
metacharacters: &quot;]&quot;, &quot;[&quot;, &quot;\&quot;, &quot;*&quot; or &quot;.&quot;.  This regular
expression is rather interesting: 1) if the close bracket is the first
character in a character class, it is interpreted literally, not as
the closing delimiter of the class; and 2) of the metacharacters
specified, only the backslash has a special meaning in a character
class and must be escaped.  Also, there is no need to escape the
metacharacters &quot;^&quot; and &quot;$&quot; because they only have special meaning if
in the first or last positions in a regular expression, respectively,
which is impossible given the structure of the index entry.  After
escaping the metacharacters, the exchange command swaps the contents
of the pattern space and the hold space.</P
><P
CLASS="para"
>Starting with a new copy of the line, the substitute command adds a
backslash to escape either a backslash or an ampersand for the
replacement string.  Then another substitute command removes the &quot;.XX&quot; from the line and the one after that appends a slash (/) to
the end of the line, preparing a replacement string that looks like:</P
><BLOCKQUOTE
CLASS="screen"
><PRE
CLASS="screen"
>&quot;asterisk (*) metacharacter&quot;/</PRE
></BLOCKQUOTE
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-4462"
></A
>Once again, the exchange command swaps the pattern space and the hold
space.  With the first copy in the pattern space, we need to prepare
the pattern address and the substitute pattern.  The substitute
command saves the index entry, and replaces the line with the first
part of the syntax for the substitute command:</P
><BLOCKQUOTE
CLASS="screen"
><PRE
CLASS="screen"
>\/^\\.XX \/s\/\1\//</PRE
></BLOCKQUOTE
><P
CLASS="para"
>Using the sample entry, the pattern space would have the following
contents:</P
><BLOCKQUOTE
CLASS="screen"
><PRE
CLASS="screen"
>/^\.XX /s/&quot;asterisk (\*) metacharacter&quot;/</PRE
></BLOCKQUOTE
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-4468"
></A
>Then the Get command takes the replacement string in the hold space
and appends it to the pattern space.  Because Get also
inserts a newline, the substitute command is necessary to remove it.
The following line is output at the end:</P
><BLOCKQUOTE
CLASS="screen"
><PRE
CLASS="screen"
>/^\.XX /s/&quot;asterisk (\*) metacharacter&quot;/&quot;asterisk (*) metacharacter&quot;/</PRE
></BLOCKQUOTE
></DIV
><DIV
CLASS="sect2"
><H3
CLASS="sect2"
><A
CLASS="title"
NAME="SEDAWK-CH-6-SECT-3.3"
>6.3.3 Building Blocks of Text</A
></H3
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="CH06.BLOCK1"
></A
><A
CLASS="indexterm"
NAME="CH06.BLOCK2"
></A
>The hold space can be used to collect a block of lines before
outputting them.  Some <KBD
CLASS="command"
>troff</KBD
> requests and macros
are block-oriented, in that commands must surround a block of text.
Usually a code at the beginning enables the format and one at the end
disables the format.  HTML-coded documents also contain many
block-oriented constructs.  For instance, &quot;&lt;p&gt;&quot; begins a
paragraph and &quot;&lt;/p&gt;&quot; ends it.  In the next example, we'll look
at placing HTML-style paragraph tags in a plain text file.  For this
example, the input is a file containing variable-length lines that
form paragraphs; each paragraph is separated from the next one by a
blank line.  Therefore, the script must collect all lines in the hold
space until a blank line is encountered.  The contents of the hold
space are retrieved and surrounded with the paragraph tags.</P
><P
CLASS="para"
>Here's the script:</P
><BLOCKQUOTE
CLASS="screen"
><PRE
CLASS="screen"
>/^$/!{
     H
     d
     }
/^$/{
	x
	s/^\n/&lt;p&gt;/
	s/$/&lt;\/p&gt;/
	G
	}</PRE
></BLOCKQUOTE
><P
CLASS="para"
>Running the script on a sample file produces:</P
><BLOCKQUOTE
CLASS="screen"
><PRE
CLASS="screen"
>&lt;p&gt;My wife won't let me buy a power saw.  She is afraid of an
accident if I use one.
So I rely on a hand saw for a variety of weekend projects like
building shelves.
However, if I made my living as a carpenter, I would
have to use a power
saw.  The speed and efficiency provided by power tools
would be essential to being productive.&lt;/p&gt;

&lt;p&gt;For people who create and modify text files,
sed and awk are power tools for editing.&lt;/p&gt;

&lt;p&gt;Most of the things that you can do with these programs
can be done interactively with a text editor.  However,
using these programs can save many hours of repetitive
work in achieving the same result.&lt;/p&gt;</PRE
></BLOCKQUOTE
><P
CLASS="para"
>The script has basically two parts, corresponding to each address.
Either we do one thing if the input line is <EM
CLASS="emphasis"
>not</EM
>
blank or a different thing if it is.  If the input line is not blank,
it is appended to the hold space (with <KBD
CLASS="command"
>H</KBD
>), and then
deleted from the pattern space.  The delete command prevents the line
from being output and clears the pattern space.  Control passes back
to the top of the script and a new line is read.  The general idea is
that we don't output any line of text; it is collected in the hold
space.</P
><P
CLASS="para"
>If the input line is blank, we process the contents of the hold space.
To illustrate what the second procedure does, let's use the second
paragraph in the previous sample file and show what happens.  After a
blank line has been read, the pattern space and the hold space have
the following contents:</P
><TABLE
CLASS="informaltable"
><TBODY
CLASS="tbody"
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><CODE
CLASS="replaceable"
><I
>Pattern Space:</I
></CODE
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><CODE
CLASS="literal"
>^$</CODE
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><CODE
CLASS="replaceable"
><I
>Hold Space:</I
></CODE
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
><CODE
CLASS="literal"
>\nFor people who create and modify text files,
\nsed and awk are power tools for editing.</CODE
></P
></TD
></TR
></TBODY
></TABLE
><P
CLASS="para"
>A blank line in the pattern space is represented as &quot;^$&quot;, the regular
expression that matches it.  The embedded newlines are represented in
the hold space by &quot;\n&quot;.  Note that the Hold command puts a newline in
the hold space and then appends the current line to the hold space.
Even when the hold space is empty, the Hold command places a newline
before the contents of the pattern space.</P
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-4503"
></A
>The exchange command (<KBD
CLASS="command"
>x</KBD
>) swaps the contents of the
hold space and the pattern space.  The blank line is saved in the hold
space so we can retrieve it at the end of the procedure.  (We could
insert a newline in other ways, also.)</P
><TABLE
CLASS="informaltable"
><TBODY
CLASS="tbody"
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><CODE
CLASS="replaceable"
><I
>Pattern Space:</I
></CODE
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
><CODE
CLASS="literal"
>\nFor people who create and modify text files,
\nsed and awk are power tools for editing.</CODE
></P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><CODE
CLASS="replaceable"
><I
>Hold Space:</I
></CODE
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><CODE
CLASS="literal"
>^$</CODE
></TD
></TR
></TBODY
></TABLE
><P
CLASS="para"
>Now we make two substitutions: placing &quot;&lt;p&gt;&quot; at the beginning of
the pattern space and &quot;&lt;/p&gt;&quot; at the end.  The first substitute
command matches &quot;^\n&quot; because a newline is at the beginning of the
line as a consequence of the Hold command.  The second substitute
command matches the end of the pattern space (&quot;$&quot; does not match any
embedded newlines but only the terminal newline.)</P
><TABLE
CLASS="informaltable"
><TBODY
CLASS="tbody"
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><CODE
CLASS="replaceable"
><I
>Pattern Space:</I
></CODE
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
><CODE
CLASS="literal"
>&lt;p&gt;For people who create and modify text files,
\nsed and awk are power tools for editing.&lt;/p&gt;</CODE
></P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><CODE
CLASS="replaceable"
><I
>Hold Space:</I
></CODE
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><CODE
CLASS="literal"
>^$</CODE
></TD
></TR
></TBODY
></TABLE
><P
CLASS="para"
>Note that the embedded newline is preserved in the pattern space.  The
last command, <KBD
CLASS="command"
>G</KBD
>, appends the blank line in the hold
space to the pattern space.  Upon reaching the bottom of the script,
sed outputs the paragraph we had collected in the hold space and coded
in the pattern space.</P
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-4538"
></A
>This script illustrates the mechanics of collecting input and holding
on to it until another pattern is matched.  It's important to pay
attention to flow control in the script.  The first procedure in the
script does not reach bottom because we don't want any output
<EM
CLASS="emphasis"
>yet</EM
>.  The second procedure does reach bottom,
clearing the pattern space and the hold space before we begin
collecting lines for the next paragraph.</P
><P
CLASS="para"
>This script also illustrates how to use addressing to set up exclusive
addresses, in which a line must match one or the other address.  You
can also set up addresses to handle various exceptions in the input
and thereby improve the reliability of a script.  For instance, in the
previous script, what happens if the last line in the input file is
<EM
CLASS="emphasis"
>not</EM
> blank?  All the lines collected since the
last blank line will not be output.  There are several ways to handle
this, but a rather clever one is to manufacture a blank line that the
blank-line procedure will match later in the script.  In other words,
if the last line contains a line of text, we will copy the text to the
hold space and clear the contents of the pattern space with the
substitute command.  We make the current line blank so that it matches
the procedure that outputs what has been collected in the hold space.
Here's the procedure:</P
><BLOCKQUOTE
CLASS="screen"
><PRE
CLASS="screen"
>${
/^$/!{
     H
     s/.*//
     }
}</PRE
></BLOCKQUOTE
><P
CLASS="para"
>This procedure must be placed in the script
<EM
CLASS="emphasis"
>before</EM
> the two procedures shown earlier.  The
addressing symbol &quot;$&quot; matches only the last line in the file.  Inside
this procedure, we test for lines that are not blank.  If the line
is blank, we don't have to do anything with it.  If the current line is
not blank, then we append it to the hold space.  This is what we do in
the other procedure that matches a non-blank line.  Then we use the
substitute command to create a blank line in the pattern space.</P
><P
CLASS="para"
>Upon exiting this procedure, there is a blank line in the pattern
space.  It matches the subsequent procedure for blank lines that adds
the HTML paragraph codes and outputs the paragraph.</P
><A
CLASS="indexterm"
NAME="AUTOID-4547"
></A
><A
CLASS="indexterm"
NAME="AUTOID-4548"
></A
></DIV
><A
CLASS="indexterm"
NAME="AUTOID-4549"
></A
></DIV
><DIV
CLASS="htmlnav"
><P
></P
><HR
ALIGN="LEFT"
WIDTH="515"
TITLE="footer"><TABLE
WIDTH="515"
BORDER="0"
CELLSPACING="0"
CELLPADDING="0"
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="172"
><A
CLASS="SECT1"
HREF="ch06_02.htm"
TITLE="6.2 A Case for Study"
><IMG
SRC="../gifs/txtpreva.gif"
ALT="Previous: 6.2 A Case for Study"
BORDER="0"></A
></TD
><TD
ALIGN="CENTER"
VALIGN="TOP"
WIDTH="171"
><A
CLASS="book"
HREF="index.htm"
TITLE="sed &amp; awk"
><IMG
SRC="../gifs/txthome.gif"
ALT="sed &amp; awk"
BORDER="0"></A
></TD
><TD
ALIGN="RIGHT"
VALIGN="TOP"
WIDTH="172"
><A
CLASS="SECT1"
HREF="ch06_04.htm"
TITLE="6.4 Advanced Flow Control Commands"
><IMG
SRC="../gifs/txtnexta.gif"
ALT="Next: 6.4 Advanced Flow Control Commands"
BORDER="0"></A
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="172"
>6.2 A Case for Study</TD
><TD
ALIGN="CENTER"
VALIGN="TOP"
WIDTH="171"
><A
CLASS="index"
HREF="index/idx_0.htm"
TITLE="Book Index"
><IMG
SRC="../gifs/index.gif"
ALT="Book Index"
BORDER="0"></A
></TD
><TD
ALIGN="RIGHT"
VALIGN="TOP"
WIDTH="172"
>6.4 Advanced Flow Control Commands</TD
></TR
></TABLE
><HR
ALIGN="LEFT"
WIDTH="515"
TITLE="footer"><IMG
SRC="../gifs/smnavbar.gif"
USEMAP="#map"
BORDER="0"
ALT="The UNIX CD Bookshelf Navigation"><MAP
NAME="map"
><AREA
SHAPE="RECT"
COORDS="0,0,73,21"
HREF="../index.htm"
ALT="The UNIX CD Bookshelf"><AREA
SHAPE="RECT"
COORDS="74,0,163,21"
HREF="../upt/index.htm"
ALT="UNIX Power Tools"><AREA
SHAPE="RECT"
COORDS="164,0,257,21"
HREF="../unixnut/index.htm"
ALT="UNIX in a Nutshell"><AREA
SHAPE="RECT"
COORDS="258,0,321,21"
HREF="../vi/index.htm"
ALT="Learning the vi Editor"><AREA
SHAPE="RECT"
COORDS="322,0,378,21"
HREF="index.htm"
ALT="sed &amp; awk"><AREA
SHAPE="RECT"
COORDS="379,0,438,21"
HREF="../ksh/index.htm"
ALT="Learning the Korn Shell"><AREA
SHAPE="RECT"
COORDS="439,0,514,21"
HREF="../lrnunix/index.htm"
ALT="Learning the UNIX Operating System"></MAP
></DIV
></BODY
></HTML
>
