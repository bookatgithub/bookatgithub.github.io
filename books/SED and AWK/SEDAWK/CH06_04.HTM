<HTML
><HEAD
>
<TITLE>[Chapter 6] 6.4 Advanced Flow Control Commands</TITLE>
<META
NAME="DC.title"
CONTENT="sed &amp; awk"><META
NAME="DC.creator"
CONTENT="Dale Dougherty &amp; Arnold Robbins"><META
NAME="DC.publisher"
CONTENT="O'Reilly &amp; Associates, Inc."><META
NAME="DC.date"
CONTENT="1998-08-03T20:55:17Z"><META
NAME="DC.type"
CONTENT="Text.Monograph"><META
NAME="DC.format"
CONTENT="text/html"
SCHEME="MIME"><META
NAME="DC.source"
CONTENT="1-56592-225-5"
SCHEME="ISBN"><META
NAME="DC.language"
CONTENT="en-US"><META
NAME="generator"
CONTENT="Jade 1.1/O'Reilly DocBook 3.0 to HTML 4.0"><LINK
REV="made"
HREF="mailto:online-books@oreilly.com"
TITLE="Online Books Comments"><LINK
REL="up"
HREF="ch06_01.htm"
TITLE="6. Advanced sed Commands"><LINK
REL="prev"
HREF="ch06_03.htm"
TITLE="6.3 Hold That Line"><LINK
REL="next"
HREF="ch06_05.htm"
TITLE="6.5 To Join a Phrase"></HEAD
><BODY
BGCOLOR="#FFFFFF"
TEXT="#000000"
><DIV
CLASS="htmlnav"
><H1
><IMG
SRC="gifs/smbanner.gif"
ALT="sed &amp; awk"
USEMAP="#srchmap"
BORDER="0"></H1
><MAP
NAME="srchmap"
><AREA
SHAPE="RECT"
COORDS="0,0,466,65"
HREF="index.htm"
ALT="sed &amp; awk"><AREA
SHAPE="RECT"
COORDS="467,0,514,18"
HREF="../search/ssrch.htm"
ALT="Search this book"></MAP
><TABLE
WIDTH="515"
BORDER="0"
CELLSPACING="0"
CELLPADDING="0"
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="172"
><A
CLASS="SECT1"
HREF="ch06_03.htm"
TITLE="6.3 Hold That Line"
><IMG
SRC="../gifs/txtpreva.gif"
ALT="Previous: 6.3 Hold That Line"
BORDER="0"></A
></TD
><TD
ALIGN="CENTER"
VALIGN="TOP"
WIDTH="171"
><B
><FONT
FACE="ARIEL,HELVETICA,HELV,SANSERIF"
SIZE="-1"
>Chapter 6<BR>Advanced sed Commands</FONT
></B
></TD
><TD
ALIGN="RIGHT"
VALIGN="TOP"
WIDTH="172"
><A
CLASS="SECT1"
HREF="ch06_05.htm"
TITLE="6.5 To Join a Phrase"
><IMG
SRC="../gifs/txtnexta.gif"
ALT="Next: 6.5 To Join a Phrase"
BORDER="0"></A
></TD
></TR
></TABLE
>&nbsp;<HR
ALIGN="LEFT"
WIDTH="515"
TITLE="footer"></DIV
><DIV
CLASS="SECT1"
><H2
CLASS="sect1"
><A
CLASS="title"
NAME="SEDAWK-CH-6-SECT-4"
>6.4 Advanced Flow Control Commands</A
></H2
><P
CLASS="para"
>You have already seen several examples of changes in sed's normal flow
control.  In this section, we'll look at two commands that allow you
to direct which portions of the script get executed and when.  The
branch (<KBD
CLASS="command"
>b</KBD
>) and test (<KBD
CLASS="command"
>t</KBD
>) commands
transfer control in a script to a line containing a specified label.
If no label is specified, control passes to the end of the script.
The branch command transfers control unconditionally while the test
command is a conditional transfer, occurring only if a substitute
command has changed the current line.</P
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-4556"
></A
><A
CLASS="indexterm"
NAME="AUTOID-4558"
></A
><A
CLASS="indexterm"
NAME="AUTOID-4560"
></A
>A label is any sequence of up to seven characters.[1]  
A label is put on a line by itself that begins with a colon:</P
><BLOCKQUOTE
CLASS="footnote"
><P
CLASS="para"
>[1] The POSIX standard says that an
implementation can allow longer labels if it wishes to. GNU sed
allows labels to be of any length.  <A
CLASS="indexterm"
NAME="AUTOID-4564"
></A
></P
></BLOCKQUOTE
><BLOCKQUOTE
CLASS="screen"
><PRE
CLASS="screen"
>:mylabel</PRE
></BLOCKQUOTE
><P
CLASS="para"
>There are no spaces permitted between the colon and the label.  Spaces
at the end of the line will be considered part of the label.  When you
specify the label in a branch or test command, a space is permitted
between the command and the label itself:</P
><BLOCKQUOTE
CLASS="screen"
><PRE
CLASS="screen"
>b mylabel</PRE
></BLOCKQUOTE
><P
CLASS="para"
>Be sure you don't put a space after the label.</P
><DIV
CLASS="sect2"
><H3
CLASS="sect2"
><A
CLASS="title"
NAME="SEDAWK-CH-6-SECT-4.1"
>6.4.1 Branching</A
></H3
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-4574"
></A
><A
CLASS="indexterm"
NAME="CH06.BRANCH1"
></A
><A
CLASS="indexterm"
NAME="CH06.BRANCH2"
></A
><A
CLASS="indexterm"
NAME="CH06.BRANCH3"
></A
>The branch command allows you to transfer control to another line in
the script.</P
><BLOCKQUOTE
CLASS="literallayout"
><P
CLASS="literallayout"
>[<CODE
CLASS="replaceable"
><I
>address</I
></CODE
>]<KBD
CLASS="command"
>b</KBD
>[<CODE
CLASS="replaceable"
><I
>label</I
></CODE
>]</P
></BLOCKQUOTE
><P
CLASS="para"
>The <EM
CLASS="emphasis"
>label</EM
> is optional, and if not supplied,
control is transferred to the end of the script.  If a label is
supplied, execution resumes at the line following the label.</P
><P
CLASS="para"
>In <A
CLASS="xref"
HREF="ch04_01.htm"
TITLE="Writing sed Scripts"
>Chapter 4, Writing sed Scripts</A
>, we looked at a typesetting script
that transformed quotation marks and hyphens into their typesetting
counterparts.  If we wanted to avoid making these changes on certain
lines, then we could use the branch command to skip that portion of
the script.  For instance, text inside computer-generated examples
marked by the .ES and .EE macros should not be changed.  Thus, we
could write the previous script like this:</P
><BLOCKQUOTE
CLASS="screen"
><PRE
CLASS="screen"
>/^\.ES/,/^\.EE/b
s/^&quot;/``/
s/&quot;$/''/
s/&quot;?<IMG
SRC="../chars/squ.gif"
ALT=" ">/''?<IMG
SRC="../chars/squ.gif"
ALT=" ">/g
.<BR>.<BR>.<BR>s/\\(em\\^&quot;/\\(em``/g
s/&quot;\\(em/''\\(em/g
s/\\(em&quot;/\\(em``/g
s/@DQ@/&quot;/g</PRE
></BLOCKQUOTE
><P
CLASS="para"
>Because no label is supplied, the branch command branches to the end of the
script, skipping all subsequent commands.  </P
><P
CLASS="para"
>The branch command can be used to execute a set of commands as a
procedure, one that can be called repeatedly from the main body of the
script.  As in the case above, it also allows you to avoid executing
the procedure at all based on matching a pattern in the input.</P
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-4596"
></A
>You can have a similar effect by using <KBD
CLASS="command"
>!</KBD
> and
grouping a set of commands.  The advantage of the branch command over
<KBD
CLASS="command"
>!</KBD
> for our application is that we can more easily
specify multiple conditions to avoid.  The <KBD
CLASS="command"
>!</KBD
> symbol
can apply to a single command, or it can apply to a set of commands
enclosed in braces that immediately follows.  The branch command, on
the other hand, gives you almost unlimited control over movement
around the script.</P
><P
CLASS="para"
>For example, if we are using multiple macro packages, there may be
other macro pairs besides .ES and .EE that define a range of lines
that we want to avoid altogether.  So, for example, we can write:</P
><BLOCKQUOTE
CLASS="screen"
><PRE
CLASS="screen"
>/^\.ES/,/^\.EE/b
/^\.PS/,/^\.PE/b
/^\.G1/,/^\.G2/b</PRE
></BLOCKQUOTE
><P
CLASS="para"
>To get a good idea of the types of flow control possible in a sed
script, let's look at some simple but abstract examples.  The first
example shows you how to use the branch command to create a loop.
Once an input line is read, command1 and command2 will be applied to
the line; afterwards, if the contents of the pattern space match the
pattern, then control will be passed to the line following the label
&quot;top,&quot; which means command1 then command2 will be executed again.</P
><BLOCKQUOTE
CLASS="screen"
><PRE
CLASS="screen"
>:top
command1
command2
/pattern/b top
command3</PRE
></BLOCKQUOTE
><P
CLASS="para"
>The script executes command3 only if the pattern doesn't match.  All
three commands will be executed, although the first two may be
executed multiple times.</P
><P
CLASS="para"
>In the next example, command1 is executed.  If the pattern is matched,
control passes to the line following the label &quot;end.&quot; This means
command2 is skipped.</P
><BLOCKQUOTE
CLASS="screen"
><PRE
CLASS="screen"
>command1
/pattern/b end
command2
:end
command3</PRE
></BLOCKQUOTE
><P
CLASS="para"
>In all cases, command1 and command3 are executed.</P
><P
CLASS="para"
>Now let's look at
how to specify that either command2 or command3 are executed, but not
both.  In the next script, there are two branch commands.</P
><BLOCKQUOTE
CLASS="screen"
><PRE
CLASS="screen"
>command1
/pattern/b dothree
command2
b
:dothree
command3</PRE
></BLOCKQUOTE
><P
CLASS="para"
>The first branch command transfers control to command3.  If that
pattern is not matched, then command2 is executed.  The branch command
following command2 sends control to the end of the script, bypassing
command3.  The first of the branch commands is conditional upon
matching the pattern; the second is not. We will look at a
&quot;real-world&quot; example after looking at the test command.</P
><A
CLASS="indexterm"
NAME="AUTOID-4613"
></A
><A
CLASS="indexterm"
NAME="AUTOID-4614"
></A
></DIV
><DIV
CLASS="sect2"
><H3
CLASS="sect2"
><A
CLASS="title"
NAME="SEDAWK-CH-6-SECT-4.2"
>6.4.2 The Test Command</A
></H3
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-4618"
></A
><A
CLASS="indexterm"
NAME="AUTOID-4621"
></A
>The test command branches to a label (or the end of the script) if a
successful substitution has been made on the currently addressed line.
Thus, it implies a conditional branch.  Its syntax follows:</P
><BLOCKQUOTE
CLASS="literallayout"
><P
CLASS="literallayout"
>[<CODE
CLASS="replaceable"
><I
>address</I
></CODE
>]<KBD
CLASS="command"
>t</KBD
>[<CODE
CLASS="replaceable"
><I
>label</I
></CODE
>]</P
></BLOCKQUOTE
><P
CLASS="para"
>If no <EM
CLASS="emphasis"
>label</EM
> is supplied, control falls
through to the end of the script.  If the label is supplied, then
execution resumes at the line following the label.</P
><P
CLASS="para"
>Let's look at an example from Tim O'Reilly.  He was trying to generate
automatic index entries based on evaluating the arguments in a macro
that produced the top of a command reference page.  If there were
three quoted arguments, he wanted to do something different than if
there were two or only one. The task was to try to match each of
these cases in succession (3,2,1) and when a successful substitution
was made, avoid making any further matches.  Here's Tim's script:</P
><BLOCKQUOTE
CLASS="screen"
><PRE
CLASS="screen"
>/\.Rh 0/{
s/&quot;\(.*\)&quot; &quot;\(.*\)&quot; &quot;\(.*\)&quot;/&quot;\1&quot; &quot;\2&quot; &quot;\3&quot;/
t
s/&quot;\(.*\)&quot; &quot;\(.*\)&quot;/&quot;\1&quot; &quot;\2&quot;/
t
s/&quot;\(.*\)&quot;/&quot;\1&quot;/
}</PRE
></BLOCKQUOTE
><P
CLASS="para"
>The test command allows us to drop to the end of the script once a
substitution has been made.  If there are three arguments on the .Rh
line, the test command after the first substitute command will be
true, and sed will go on to the next input line.  If there are fewer
than three arguments, no substitution will be made, the test command
will be evaluated false, and the next substitute command will be
tried.  This will be repeated until all the possibilities are used up.</P
><P
CLASS="para"
>The test command provides functionality similar to a case statement in
the C programming language or the shell programming languages.  You
can test each case and when a case proves true, then you exit the
construct.</P
><P
CLASS="para"
>If the above script were part of a larger script, we could use a
label, perhaps tellingly named &quot;break,&quot; to drop to the end of the
command grouping where additional commands can be applied.</P
><BLOCKQUOTE
CLASS="screen"
><PRE
CLASS="screen"
>/\.Rh 0/{
s/&quot;\(.*\)&quot; &quot;\(.*\)&quot; &quot;\(.*\)&quot;/&quot;\1&quot; &quot;\2&quot; &quot;\3&quot;/
t break
.<BR>.<BR>.<BR>}
:break
<I
CLASS="lineannotation"
>more commands</I
></PRE
></BLOCKQUOTE
><P
CLASS="para"
>The next section gives a full example of the test command and the use
of labels.</P
><A
CLASS="indexterm"
NAME="AUTOID-4637"
></A
></DIV
><DIV
CLASS="sect2"
><H3
CLASS="sect2"
><A
CLASS="title"
NAME="SEDAWK-CH-6-SECT-4.3"
>6.4.3 One More Case</A
></H3
><P
CLASS="para"
>Remember Lenny?  He was the fellow given the task of converting Scribe
documents to <KBD
CLASS="command"
>troff</KBD
>.  We had sent him the following
script:</P
><BLOCKQUOTE
CLASS="screen"
><PRE
CLASS="screen"
># Scribe font change script. 
s/@f1(\([^)]*\))/\\fB\1\\fR/g
/@f1(.*/{
N
s/@f1(\(.*\n[^)]*\))/\\fB\1\\fR/g
P
D
}</PRE
></BLOCKQUOTE
><P
CLASS="para"
>He sent the following mail after using the script:</P
><BLOCKQUOTE
CLASS="screen"
><PRE
CLASS="screen"
>Thank you so much!  You've not only fixed the script but shown me
where I was confused about the way it works.  I can repair the
conversion script so that it works with what you've done, but to be
optimal it should do two more things that I can't seem to get working
at all&nbsp;- maybe it's hopeless and I should be content with what's
there.  

First, I'd like to reduce multiple blank lines down to one.
Second, I'd like to make sed match the pattern over more than two
(say, even only three) lines.  

Thanks again.  

Lenny</PRE
></BLOCKQUOTE
><P
CLASS="para"
>The first request to reduce a series of blank lines to one has already
been shown in this chapter.  The following four lines perform this
function:</P
><BLOCKQUOTE
CLASS="screen"
><PRE
CLASS="screen"
>/^$/{
N
/^\n$/D
}</PRE
></BLOCKQUOTE
><P
CLASS="para"
>We want to look mainly at accomplishing the second request.  Our
previous font-change script created a two-line pattern space, tried to
make the match across those lines, and then output the first line.
The second line became the first line in the pattern space and control
passed to the top of the script where another line was read in.</P
><P
CLASS="para"
>We can use labels to set up a loop that reads multiple lines and makes
it possible to match a pattern across multiple lines.  The following
script sets up two labels: <KBD
CLASS="command"
>begin</KBD
> at the top of the
script and <KBD
CLASS="command"
>again</KBD
> near the bottom.  Look at the
improved script:</P
><BLOCKQUOTE
CLASS="screen"
><PRE
CLASS="screen"
># Scribe font change script.  New and Improved.
:begin
/@f1(\([^)]*\))/{
s//\\fB\1\\fR/g
b begin
}
/@f1(.*/{
N
s/@f1(\([^)]*\n[^)]*\))/\\fB\1\\fR/g
t again
b begin
}
:again
P
D</PRE
></BLOCKQUOTE
><P
CLASS="para"
>Let's look more closely at this script, which has three parts.
Beginning with the line that follows <KBD
CLASS="command"
>:begin</KBD
>, the
first part attempts to match the font change syntax if it is found
completely on one line.  After making the substitution, the branch
command transfers control back to the label <KBD
CLASS="command"
>begin</KBD
>.
In other words, once we have made a match, we want to go back to the
top and look for other possible matches, including the instruction
that has already been applied&nbsp;- there could be multiple
occurrences on the line.</P
><P
CLASS="para"
>The second part attempts to match the pattern over multiple lines.
The Next command builds a multiple line pattern space.  The
substitution command attempts to locate the pattern with an embedded
newline.  If it succeeds, the test command passes control to the line
following the <KBD
CLASS="command"
>again</KBD
> label.  If no substitution is
made, control is passed to the line following the label
<KBD
CLASS="command"
>begin</KBD
> so that we can read in another line.  This is
a loop that goes into effect when we've matched the beginning sequence
of a font change request but have not yet found the ending sequence.
Sed will loop back and keep appending lines into the pattern space
until a match has been found.</P
><P
CLASS="para"
>The third part is the procedure following the label
<KBD
CLASS="command"
>again</KBD
>.  The first line in the pattern space is
output and then deleted.  Like the previous version of this script, we
deal with multiple lines in succession.  Control never reaches the
bottom of the script but is redirected by the Delete command to the
top of the script.</P
></DIV
></DIV
><DIV
CLASS="htmlnav"
><P
></P
><HR
ALIGN="LEFT"
WIDTH="515"
TITLE="footer"><TABLE
WIDTH="515"
BORDER="0"
CELLSPACING="0"
CELLPADDING="0"
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="172"
><A
CLASS="SECT1"
HREF="ch06_03.htm"
TITLE="6.3 Hold That Line"
><IMG
SRC="../gifs/txtpreva.gif"
ALT="Previous: 6.3 Hold That Line"
BORDER="0"></A
></TD
><TD
ALIGN="CENTER"
VALIGN="TOP"
WIDTH="171"
><A
CLASS="book"
HREF="index.htm"
TITLE="sed &amp; awk"
><IMG
SRC="../gifs/txthome.gif"
ALT="sed &amp; awk"
BORDER="0"></A
></TD
><TD
ALIGN="RIGHT"
VALIGN="TOP"
WIDTH="172"
><A
CLASS="SECT1"
HREF="ch06_05.htm"
TITLE="6.5 To Join a Phrase"
><IMG
SRC="../gifs/txtnexta.gif"
ALT="Next: 6.5 To Join a Phrase"
BORDER="0"></A
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="172"
>6.3 Hold That Line</TD
><TD
ALIGN="CENTER"
VALIGN="TOP"
WIDTH="171"
><A
CLASS="index"
HREF="index/idx_0.htm"
TITLE="Book Index"
><IMG
SRC="../gifs/index.gif"
ALT="Book Index"
BORDER="0"></A
></TD
><TD
ALIGN="RIGHT"
VALIGN="TOP"
WIDTH="172"
>6.5 To Join a Phrase</TD
></TR
></TABLE
><HR
ALIGN="LEFT"
WIDTH="515"
TITLE="footer"><IMG
SRC="../gifs/smnavbar.gif"
USEMAP="#map"
BORDER="0"
ALT="The UNIX CD Bookshelf Navigation"><MAP
NAME="map"
><AREA
SHAPE="RECT"
COORDS="0,0,73,21"
HREF="../index.htm"
ALT="The UNIX CD Bookshelf"><AREA
SHAPE="RECT"
COORDS="74,0,163,21"
HREF="../upt/index.htm"
ALT="UNIX Power Tools"><AREA
SHAPE="RECT"
COORDS="164,0,257,21"
HREF="../unixnut/index.htm"
ALT="UNIX in a Nutshell"><AREA
SHAPE="RECT"
COORDS="258,0,321,21"
HREF="../vi/index.htm"
ALT="Learning the vi Editor"><AREA
SHAPE="RECT"
COORDS="322,0,378,21"
HREF="index.htm"
ALT="sed &amp; awk"><AREA
SHAPE="RECT"
COORDS="379,0,438,21"
HREF="../ksh/index.htm"
ALT="Learning the Korn Shell"><AREA
SHAPE="RECT"
COORDS="439,0,514,21"
HREF="../lrnunix/index.htm"
ALT="Learning the UNIX Operating System"></MAP
></DIV
></BODY
></HTML
>
