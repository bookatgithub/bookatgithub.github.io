<HTML
><HEAD
>
<TITLE>[Chapter 7] 7.8 Relational and Boolean Operators</TITLE>
<META
NAME="DC.title"
CONTENT="sed &amp; awk"><META
NAME="DC.creator"
CONTENT="Dale Dougherty &amp; Arnold Robbins"><META
NAME="DC.publisher"
CONTENT="O'Reilly &amp; Associates, Inc."><META
NAME="DC.date"
CONTENT="1998-08-03T20:57:36Z"><META
NAME="DC.type"
CONTENT="Text.Monograph"><META
NAME="DC.format"
CONTENT="text/html"
SCHEME="MIME"><META
NAME="DC.source"
CONTENT="1-56592-225-5"
SCHEME="ISBN"><META
NAME="DC.language"
CONTENT="en-US"><META
NAME="generator"
CONTENT="Jade 1.1/O'Reilly DocBook 3.0 to HTML 4.0"><LINK
REV="made"
HREF="mailto:online-books@oreilly.com"
TITLE="Online Books Comments"><LINK
REL="up"
HREF="ch07_01.htm"
TITLE="7. Writing Scripts for awk"><LINK
REL="prev"
HREF="ch07_07.htm"
TITLE="7.7 System Variables"><LINK
REL="next"
HREF="ch07_09.htm"
TITLE="7.9 Formatted Printing"></HEAD
><BODY
BGCOLOR="#FFFFFF"
TEXT="#000000"
><DIV
CLASS="htmlnav"
><H1
><IMG
SRC="gifs/smbanner.gif"
ALT="sed &amp; awk"
USEMAP="#srchmap"
BORDER="0"></H1
><MAP
NAME="srchmap"
><AREA
SHAPE="RECT"
COORDS="0,0,466,65"
HREF="index.htm"
ALT="sed &amp; awk"><AREA
SHAPE="RECT"
COORDS="467,0,514,18"
HREF="../search/ssrch.htm"
ALT="Search this book"></MAP
><TABLE
WIDTH="515"
BORDER="0"
CELLSPACING="0"
CELLPADDING="0"
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="172"
><A
CLASS="SECT1"
HREF="ch07_07.htm"
TITLE="7.7 System Variables"
><IMG
SRC="../gifs/txtpreva.gif"
ALT="Previous: 7.7 System Variables"
BORDER="0"></A
></TD
><TD
ALIGN="CENTER"
VALIGN="TOP"
WIDTH="171"
><B
><FONT
FACE="ARIEL,HELVETICA,HELV,SANSERIF"
SIZE="-1"
>Chapter 7<BR>Writing Scripts for awk</FONT
></B
></TD
><TD
ALIGN="RIGHT"
VALIGN="TOP"
WIDTH="172"
><A
CLASS="SECT1"
HREF="ch07_09.htm"
TITLE="7.9 Formatted Printing"
><IMG
SRC="../gifs/txtnexta.gif"
ALT="Next: 7.9 Formatted Printing"
BORDER="0"></A
></TD
></TR
></TABLE
>&nbsp;<HR
ALIGN="LEFT"
WIDTH="515"
TITLE="footer"></DIV
><DIV
CLASS="SECT1"
><H2
CLASS="sect1"
><A
CLASS="title"
NAME="SEDAWK-CH-7-SECT-8"
>7.8 Relational and Boolean Operators</A
></H2
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="CH07.RELAT1"
></A
><A
CLASS="indexterm"
NAME="CH07.RELAT3"
></A
><A
CLASS="indexterm"
NAME="CH07.RELAT4"
></A
><A
CLASS="indexterm"
NAME="CH07.RELAT5"
></A
>Relational and Boolean operators allow you to make comparisons
between two expressions.
The relational operators are found in <A
CLASS="xref"
HREF="ch07_08.htm#SEDAWK-CH-7-TAB-4"
TITLE="Relational Operators"
>Table 7.4</A
>.</P
><TABLE
CLASS="table"
><CAPTION
CLASS="table"
><A
CLASS="title"
NAME="SEDAWK-CH-7-TAB-4"
>Table 7.4: Relational Operators</A
></CAPTION
><THEAD
CLASS="thead"
><TR
CLASS="row"
VALIGN="TOP"
><TH
CLASS="entry"
ALIGN="LEFT"
ROWSPAN="1"
COLSPAN="1"
>Operator</TH
><TH
CLASS="entry"
ALIGN="LEFT"
ROWSPAN="1"
COLSPAN="1"
>Description</TH
></TR
></THEAD
><TBODY
CLASS="tbody"
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
>&lt;</TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
>Less than<A
CLASS="indexterm"
NAME="AUTOID-5670"
></A
><A
CLASS="indexterm"
NAME="AUTOID-5673"
></A
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
>&gt;</TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
>Greater than<A
CLASS="indexterm"
NAME="AUTOID-5679"
></A
><A
CLASS="indexterm"
NAME="AUTOID-5682"
></A
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
>&lt;=</TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
>Less than or equal to<A
CLASS="indexterm"
NAME="AUTOID-5688"
></A
><A
CLASS="indexterm"
NAME="AUTOID-5691"
></A
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
>&gt;=</TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
>Greater than or equal to<A
CLASS="indexterm"
NAME="AUTOID-5697"
></A
><A
CLASS="indexterm"
NAME="AUTOID-5700"
></A
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
>==</TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
>Equal to<A
CLASS="indexterm"
NAME="AUTOID-5706"
></A
><A
CLASS="indexterm"
NAME="AUTOID-5709"
></A
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
>!=</TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
>Not equal to<A
CLASS="indexterm"
NAME="AUTOID-5715"
></A
><A
CLASS="indexterm"
NAME="AUTOID-5718"
></A
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
>~</TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
>Matches<A
CLASS="indexterm"
NAME="AUTOID-5724"
></A
><A
CLASS="indexterm"
NAME="AUTOID-5726"
></A
><A
CLASS="indexterm"
NAME="AUTOID-5728"
></A
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
>!~</TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
>Does not match<A
CLASS="indexterm"
NAME="AUTOID-5733"
></A
><A
CLASS="indexterm"
NAME="AUTOID-5736"
></A
></TD
></TR
></TBODY
></TABLE
><P
CLASS="para"
>A relational expression can be used in place of a pattern
to control a particular action.
For instance, if we wanted to limit
the records selected
for processing to those that have five fields, we could
use the following expression:</P
><BLOCKQUOTE
CLASS="screen"
><PRE
CLASS="screen"
>NF == 5</PRE
></BLOCKQUOTE
><P
CLASS="para"
>This relational expression compares 
the value of <B
CLASS="emphasis.bold"
>NF</B
> (the number of fields for each input
record) to five.  If it is true, the action will be executed;
otherwise, it will not.</P
><BLOCKQUOTE
CLASS="note"
><P
CLASS="para"
><STRONG
>NOTE:</STRONG
> Make sure you notice that the relational operator &quot;==&quot; (&quot;is equal to&quot;) 
is not the same as the assignment operator &quot;=&quot; (&quot;equals&quot;).  
It is a common error to use &quot;=&quot; instead of &quot;==&quot; to test for equality.</P
></BLOCKQUOTE
><P
CLASS="para"
>We can use a relational expression to validate the <I
CLASS="filename"
>phonelist</I
>
database before attempting to print out the record. </P
><BLOCKQUOTE
CLASS="screen"
><PRE
CLASS="screen"
>NF == 6 { print $1, $6 }</PRE
></BLOCKQUOTE
><P
CLASS="para"
>Then only lines with six fields will be printed.</P
><P
CLASS="para"
>The opposite of &quot;==&quot; is &quot;!=&quot; (&quot;is not equal to&quot;).
Similarly, you can compare one expression to another
to see if it is greater than (&gt;) or less than (&lt;)
or greater than or equal to (&gt;=) or less than or equal
to (&lt;=).
The expression</P
><BLOCKQUOTE
CLASS="screen"
><PRE
CLASS="screen"
>NR &gt; 1</PRE
></BLOCKQUOTE
><P
CLASS="para"
>tests whether the number of the current record is greater than 1.
As we'll see in the next chapter, relational expressions are typically
used in conditional (<KBD
CLASS="command"
>if</KBD
>) statements and
are evaluated to
determine whether or not a particular statement should be executed.  </P
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-5754"
></A
>Regular expressions are usually written enclosed in slashes.  These
can be thought of as regular expression <EM
CLASS="emphasis"
>constants</EM
>, much as
<B
CLASS="emphasis.bold"
>&quot;hello&quot;</B
> is a string constant.  We've seen many examples
so far:</P
><BLOCKQUOTE
CLASS="screen"
><PRE
CLASS="screen"
>/^$/ { print &quot;This is a blank line.&quot; }</PRE
></BLOCKQUOTE
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-5761"
></A
><A
CLASS="indexterm"
NAME="AUTOID-5763"
></A
><A
CLASS="indexterm"
NAME="AUTOID-5765"
></A
><A
CLASS="indexterm"
NAME="AUTOID-5767"
></A
><A
CLASS="indexterm"
NAME="AUTOID-5770"
></A
>However, you are not limited to regular expression constants.
When used with the relational operators
<KBD
CLASS="command"
>~</KBD
> (&quot;match&quot;) and <KBD
CLASS="command"
>!~</KBD
> (&quot;no match&quot;),
the right-hand side of the expression can be any awk expression;
awk treats it as a string that
specifies a regular expression.[9]
We've already seen an example of the <KBD
CLASS="command"
>~</KBD
> operator used in a
pattern-matching rule for the phone database:</P
><BLOCKQUOTE
CLASS="footnote"
><P
CLASS="para"
>[9] You may also use strings instead of regular expression constants
when calling the <KBD
CLASS="command"
>match()</KBD
>, <KBD
CLASS="command"
>split()</KBD
>, <KBD
CLASS="command"
>sub()</KBD
>,
and <KBD
CLASS="command"
>gsub()</KBD
> functions.</P
></BLOCKQUOTE
><BLOCKQUOTE
CLASS="screen"
><PRE
CLASS="screen"
>$5 ~ /MA/   { print $1 &quot;, &quot; $6 }</PRE
></BLOCKQUOTE
><P
CLASS="para"
>where the value of field 5 is compared against the regular expression
&quot;MA.&quot;</P
><P
CLASS="para"
>Since any expression can be used with <KBD
CLASS="command"
>~</KBD
> and <KBD
CLASS="command"
>!~</KBD
>,
regular expressions can be supplied through variables.
For instance, in the <I
CLASS="filename"
>phonelist</I
>
script, we could replace &quot;/MA/&quot; with <B
CLASS="emphasis.bold"
>state</B
>
and have a procedure that defines the value of state. </P
><BLOCKQUOTE
CLASS="screen"
><PRE
CLASS="screen"
>$5 ~ state  { print $1 &quot;, &quot; $6 }</PRE
></BLOCKQUOTE
><P
CLASS="para"
>This makes the script much more general to use because
<EM
CLASS="emphasis"
>a pattern can change dynamically</EM
> during execution of the
script.  For instance, it allows us to get the value of <B
CLASS="emphasis.bold"
>state</B
> 
from a command-line parameter.
We will talk about passing command-line parameters
into a script later in this chapter.<A
CLASS="indexterm"
NAME="AUTOID-5793"
></A
><A
CLASS="indexterm"
NAME="AUTOID-5794"
></A
><A
CLASS="indexterm"
NAME="AUTOID-5795"
></A
><A
CLASS="indexterm"
NAME="AUTOID-5796"
></A
></P
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-5798"
></A
><A
CLASS="indexterm"
NAME="AUTOID-5800"
></A
>Boolean operators allow you to combine a series of comparisons.  
They are listed in <A
CLASS="xref"
HREF="ch07_08.htm#SEDAWK-CH-7-TAB-5"
TITLE="Boolean Operators"
>Table 7.5</A
>.</P
><TABLE
CLASS="table"
><CAPTION
CLASS="table"
><A
CLASS="title"
NAME="SEDAWK-CH-7-TAB-5"
>Table 7.5: Boolean Operators</A
></CAPTION
><THEAD
CLASS="thead"
><TR
CLASS="row"
VALIGN="TOP"
><TH
CLASS="entry"
ALIGN="LEFT"
ROWSPAN="1"
COLSPAN="1"
>Operator</TH
><TH
CLASS="entry"
ALIGN="LEFT"
ROWSPAN="1"
COLSPAN="1"
>Description</TH
></TR
></THEAD
><TBODY
CLASS="tbody"
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
>||</TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
>Logical OR<A
CLASS="indexterm"
NAME="AUTOID-5815"
></A
><A
CLASS="indexterm"
NAME="AUTOID-5818"
></A
><A
CLASS="indexterm"
NAME="AUTOID-5820"
></A
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
>&amp;&amp;</TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
>Logical AND<A
CLASS="indexterm"
NAME="AUTOID-5825"
></A
><A
CLASS="indexterm"
NAME="AUTOID-5828"
></A
><A
CLASS="indexterm"
NAME="AUTOID-5831"
></A
><A
CLASS="indexterm"
NAME="AUTOID-5833"
></A
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
>!</TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
>Logical NOT<A
CLASS="indexterm"
NAME="AUTOID-5838"
></A
><A
CLASS="indexterm"
NAME="AUTOID-5841"
></A
><A
CLASS="indexterm"
NAME="AUTOID-5844"
></A
><A
CLASS="indexterm"
NAME="AUTOID-5846"
></A
></TD
></TR
></TBODY
></TABLE
><P
CLASS="para"
>Given two or more expressions, <KBD
CLASS="command"
>||</KBD
> specifies that
one of them must evaluate to true (non-zero or non-empty)
for the whole expression to be true.  
<KBD
CLASS="command"
>&amp;&amp;</KBD
> specifies that <EM
CLASS="emphasis"
>both</EM
> of the expressions must be true to 
return true.</P
><P
CLASS="para"
>The following expression:</P
><BLOCKQUOTE
CLASS="screen"
><PRE
CLASS="screen"
>NF == 6 &amp;&amp; NR &gt; 1</PRE
></BLOCKQUOTE
><P
CLASS="para"
>states that the number of fields must be equal to 6 <EM
CLASS="emphasis"
>and</EM
> that
the number of the record must be greater than 1.</P
><P
CLASS="para"
><KBD
CLASS="command"
>&amp;&amp;</KBD
> has higher precedence than <KBD
CLASS="command"
>||</KBD
>.  Can you
tell how the following expression will be evaluated?</P
><BLOCKQUOTE
CLASS="screen"
><PRE
CLASS="screen"
>NR &gt; 1 &amp;&amp; NF &gt;= 2 || $1 ~ /\t/</PRE
></BLOCKQUOTE
><P
CLASS="para"
>The parentheses in the next example show which expression would
be evaluated first based on the rules of precedence.</P
><BLOCKQUOTE
CLASS="screen"
><PRE
CLASS="screen"
>(NR &gt; 1 &amp;&amp; NF &gt;= 2) || $1 ~ /\t/</PRE
></BLOCKQUOTE
><P
CLASS="para"
>In other words, both of the expressions in parentheses must be
true <EM
CLASS="emphasis"
>or</EM
> the 
right hand side must be true.  You can use parentheses to override
the rules of precedence, as in the following example which
specifies that two conditions must be true.</P
><BLOCKQUOTE
CLASS="screen"
><PRE
CLASS="screen"
>NR &gt; 1 &amp;&amp; (NF &gt;= 2 || $1 ~ /\t/)</PRE
></BLOCKQUOTE
><P
CLASS="para"
>The first condition must be true <EM
CLASS="emphasis"
>and</EM
> either of two other conditions
must be true.</P
><P
CLASS="para"
>Given an expression that is either true or false, the
<KBD
CLASS="command"
>!</KBD
> operator inverts the sense of the expression.</P
><BLOCKQUOTE
CLASS="screen"
><PRE
CLASS="screen"
>! (NR &gt; 1 &amp;&amp; NF &gt; 3)</PRE
></BLOCKQUOTE
><P
CLASS="para"
>This expression is true if the parenthesized expression is false.
This operator is most useful with awk's <KBD
CLASS="command"
>in</KBD
> operator to see if
an index is not in an array (as we shall see later), although it has
other uses as well.</P
><DIV
CLASS="sect2"
><H3
CLASS="sect2"
><A
CLASS="title"
NAME="SEDAWK-CH-7-SECT-8.1"
>7.8.1 Getting Information About Files</A
></H3
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="CH07.FILE1"
></A
><A
CLASS="indexterm"
NAME="CH07.FILE2"
></A
>Now we are going to look at a couple of
scripts that process the output
of a UNIX command, <KBD
CLASS="command"
>ls</KBD
>.   The following
is a sample of the long listing produced by the command <KBD
CLASS="command"
>ls -l</KBD
>:[10]</P
><BLOCKQUOTE
CLASS="footnote"
><P
CLASS="para"
>[10] Note that on a Berkeley 4.3BSD-derived UNIX system
such as Ultrix or SunOS 4.1.x, <KBD
CLASS="command"
>ls -l</KBD
> produces
an eight-column report; use <KBD
CLASS="command"
>ls -lg</KBD
> to get the same
report format shown here.</P
></BLOCKQUOTE
><BLOCKQUOTE
CLASS="screen"
><PRE
CLASS="screen"
>$ <CODE
CLASS="userinput"
><B
>ls -l</B
></CODE
>
-rw-rw-rw-   1 dale     project   6041 Jan  1 12:31 com.tmp
-rwxrwxrwx   1 dale     project   1778 Jan  1 11:55 combine.idx
-rw-rw-rw-   1 dale     project   1446 Feb 15 22:32 dang
-rwxrwxrwx   1 dale     project   1202 Jan  2 23:06 format.idx</PRE
></BLOCKQUOTE
><P
CLASS="para"
>This listing is a report in which data is presented in rows
and columns.  Each file is presented across a single row.
The file listing consists of nine columns.
The file's permissions appear in the first column,
the size of the file in bytes in
the fifth column, and the filename is found in
the last column.  Because
one or more spaces separate the data in columns,
we can treat each column as a field.</P
><P
CLASS="para"
>In our first example,
we're going to pipe the output of this command to an awk
script that prints selected fields from the
file listing.  
To do this, we'll create a 
shell script so that we can make the pipe transparent to the user. 
Thus, the structure of the shell script is:</P
><BLOCKQUOTE
CLASS="screen"
><PRE
CLASS="screen"
>ls -l $* | awk '<I
CLASS="filename"
>script</I
>'</PRE
></BLOCKQUOTE
><P
CLASS="para"
>The $* variable is used by the shell and expands to
all arguments passed from the command line.  (We could use
$1 here, which would pass the first argument, but passing
<EM
CLASS="emphasis"
>all</EM
> the arguments provides greater flexibility.) 
These arguments can be the names of files or directories
or additional options to the <KBD
CLASS="command"
>ls</KBD
> command.
If no arguments are specified, the &quot;$*&quot; will be empty
and the current directory will be listed.
Thus, the output of the <KBD
CLASS="command"
>ls</KBD
> command will be directed to
awk, which will automatically read standard input, since
no filenames have been given.</P
><P
CLASS="para"
>We'd like our awk script to print the size and name of the file.
That is, print field 5 ($5) and field 9 ($9).</P
><BLOCKQUOTE
CLASS="screen"
><PRE
CLASS="screen"
>ls -l $* | awk '{ 
	print $5, &quot;\t&quot;, $9
}'</PRE
></BLOCKQUOTE
><P
CLASS="para"
>If we put the above lines in a file named <I
CLASS="filename"
>fls</I
>
and make that file executable, we can enter <KBD
CLASS="command"
>fls</KBD
>
as a command.</P
><BLOCKQUOTE
CLASS="screen"
><PRE
CLASS="screen"
>$ <CODE
CLASS="userinput"
><B
>fls</B
></CODE
>
6041     com.tmp
1778     combine.idx
1446     dang
1202     format.idx
$ <CODE
CLASS="userinput"
><B
>fls com*</B
></CODE
>
6041     com.tmp
1778     combine.idx</PRE
></BLOCKQUOTE
><P
CLASS="para"
>So what our program does is take the long listing and reduce it
to two fields.  Now, let's add new functionality to our report
by producing some information that the <KBD
CLASS="command"
>ls -l</KBD
> listing does not provide. 
We add each file's size to a running total, to produce
the total number of bytes used by all files in the listing.
We can also keep track of the number of files and produce
that total.
There are two parts to adding this functionality.  The first is
to accumulate the totals for each input line.  We create the variable
<B
CLASS="emphasis.bold"
>sum</B
> to accumulate the size of files and the variable
<B
CLASS="emphasis.bold"
>filenum</B
> to accumulate the number of files in the listing.</P
><BLOCKQUOTE
CLASS="screen"
><PRE
CLASS="screen"
>{
	sum += $5
	++filenum
	print $5, &quot;\t&quot;, $9 
}</PRE
></BLOCKQUOTE
><P
CLASS="para"
>The first expression uses the assignment operator
<KBD
CLASS="command"
>+=</KBD
>.  It adds the value of field 5 to the present value of the variable
<B
CLASS="emphasis.bold"
>sum</B
>.  
The second expression increments the present value of 
the variable <B
CLASS="emphasis.bold"
>filenum</B
>.
This variable is used as a <EM
CLASS="emphasis"
>counter</EM
>, and each 
time the expression is evaluated, 
1 is added to the count.  </P
><P
CLASS="para"
>The action we've written will be applied to all input lines.
The totals that are accumulated in this action must
be printed after awk has read all the input lines.
Therefore, we write an action that is controlled by the
<KBD
CLASS="command"
>END</KBD
> rule.</P
><BLOCKQUOTE
CLASS="screen"
><PRE
CLASS="screen"
>END { print &quot;Total: &quot;, sum, &quot;bytes (&quot; filenum &quot; files)&quot; }</PRE
></BLOCKQUOTE
><P
CLASS="para"
>We can also use the <KBD
CLASS="command"
>BEGIN</KBD
> rule to add column headings to the
report.  </P
><BLOCKQUOTE
CLASS="screen"
><PRE
CLASS="screen"
>BEGIN { print &quot;BYTES&quot;, &quot;\t&quot;, &quot;FILE&quot; }</PRE
></BLOCKQUOTE
><P
CLASS="para"
>Now we can put this script in an executable file named <I
CLASS="filename"
>filesum</I
>
and execute it as a single-word command.</P
><BLOCKQUOTE
CLASS="screen"
><PRE
CLASS="screen"
>$ <CODE
CLASS="userinput"
><B
>filesum c* </B
></CODE
>
BYTES    FILE
882      ch01
1771     ch03
1987     ch04
6041     com.tmp
1778     combine.idx
Total:  12459 bytes (5 files)</PRE
></BLOCKQUOTE
><P
CLASS="para"
>What's nice about this command is that it allows you to determine
the size of all files in a directory or any group of files.  </P
><P
CLASS="para"
>While the basic mechanism works, there are a few problems to
be taken care of.
The first problem occurs when you list the entire directory
using the <KBD
CLASS="command"
>ls -l</KBD
> command.  
The listing contains
a line that specifies the total number of blocks in the directory.
The partial listing (all files beginning with &quot;c&quot;) in the previous
example does not have this line.
But the following line would be included in the output if the
full directory was listed:</P
><BLOCKQUOTE
CLASS="screen"
><PRE
CLASS="screen"
>total 555</PRE
></BLOCKQUOTE
><P
CLASS="para"
>The block total does not interest us because
the program displays the total file size in bytes.
Currently, <KBD
CLASS="command"
>filesum</KBD
> does not print this line; however,
it does read this line and cause the <KBD
CLASS="command"
>filenum</KBD
> counter to be incremented.</P
><P
CLASS="para"
>There is also a problem with this script in how
it handles subdirectories.  Look at the following
line from an <KBD
CLASS="command"
>ls -l</KBD
>: </P
><BLOCKQUOTE
CLASS="screen"
><PRE
CLASS="screen"
>drwxrwxrwx   3 dale     project         960 Feb  1 15:47 sed</PRE
></BLOCKQUOTE
><P
CLASS="para"
>A &quot;d&quot; as the first character in column 1 (file permissions) indicates that
the file is a subdirectory.  The size of this file (960 bytes) does not
indicate the size of files in that subdirectory and therefore, it
is slightly misleading to add it to the file size totals.  Also, it might be
helpful to indicate that it is a directory.</P
><P
CLASS="para"
>If you want to list the
files in subdirectories, supply the <I
CLASS="option"
>-R</I
> (recursive)
option on the command line. 
It will be passed to the <KBD
CLASS="command"
>ls</KBD
> command.
However, the listing is slightly different as it
identifies each directory.   
For instance, to identify the subdirectory <I
CLASS="filename"
>old</I
>, the
<KBD
CLASS="command"
>ls -lR</KBD
> listing produces a blank line followed
by:</P
><BLOCKQUOTE
CLASS="screen"
><PRE
CLASS="screen"
>./old:</PRE
></BLOCKQUOTE
><P
CLASS="para"
>Our script ignores that
line and a blank line preceding it but nonetheless they increment
the file counter.
Fortunately, we can devise rules 
to handle these cases. 
Let's look at the revised, commented script:</P
><BLOCKQUOTE
CLASS="screen"
><PRE
CLASS="screen"
>ls -l $* | awk '
# filesum: list files and total size in bytes
# input: long listing produced by &quot;ls -l&quot;

#1 output column headers
BEGIN { print &quot;BYTES&quot;, &quot;\t&quot;, &quot;FILE&quot; }

#2 test for 9 fields; files begin with &quot;-&quot;
NF == 9 &amp;&amp; /^-/ {
        sum += $5       # accumulate size of file
        ++filenum       # count number of files
        print $5, &quot;\t&quot;, $9       # print size and filename
}

#3 test for 9 fields; directory begins with &quot;d&quot;
NF == 9 &amp;&amp; /^d/ {
        print &quot;&lt;dir&gt;&quot;, &quot;\t&quot;, $9  # print &lt;dir&gt; and name
}

#4 test for ls -lR line ./dir:
$1 ~ /^\..*:$/ {
        print &quot;\t&quot; $0 # print that line preceded by tab
}

#5 once all is done,
END {
	# print total file size and number of files
	print &quot;Total: &quot;, sum, &quot;bytes (&quot; filenum &quot; files)&quot;
}'</PRE
></BLOCKQUOTE
><P
CLASS="para"
>The rules and their associated actions have been numbered
to make it easier to discuss them.  The listing
produced by <KBD
CLASS="command"
>ls -l</KBD
> contains nine fields for
a file.  Awk supplies the number of fields
for a record in the system variable <B
CLASS="emphasis.bold"
>NF</B
>.  
Therefore, rules 2 and 3 test that <B
CLASS="emphasis.bold"
>NF</B
> is equal to 9.
This helps us avoid matching odd blank lines 
or the line stating the block total. 
Because we want to handle directories and files differently,
we use another pattern to match the first character of
the line.  In rule 2 we test for &quot;-&quot; in the first position
on the line, which indicates a file.
The associated action increments
the file counter and adds the file size to the previous
total.  In rule 3, we test for a directory, indicated by &quot;d&quot; as
the first character.  The associated action
prints &quot;&lt;dir&gt;&quot; in place of the file size.   
Rules 2 and 3 are <EM
CLASS="emphasis"
>compound</EM
> expressions, 
specifying two patterns that are
combined using the <KBD
CLASS="command"
>&amp;&amp;</KBD
> operator. 
Both patterns must be matched for the expression to
be true. </P
><P
CLASS="para"
>Rule 4 tests for the special case produced by the <KBD
CLASS="command"
>ls -lR</KBD
>
listing (&quot;./old:&quot;).
There are a number of patterns that we can write to match
that line, using regular expressions or relational expressions:</P
><BLOCKQUOTE
CLASS="screen"
><PRE
CLASS="screen"
>NF == 1			<I
CLASS="lineannotation"
>If the number of fields equals 1 ...</I
>
/^\..*:$/		<I
CLASS="lineannotation"
>If the line begins with a period followed by any number of
                                                   characters and ends in a colon...</I
>
$1 ~ /^\..*:$/		<I
CLASS="lineannotation"
>If field 1 matches the regular expression...</I
></PRE
></BLOCKQUOTE
><P
CLASS="para"
>We used the latter expression because it seems to be the most
specific.  It employs the match operator (~) to test the first
field against a regular expression.  The associated action
consists of only a <KBD
CLASS="command"
>print</KBD
> statement.</P
><P
CLASS="para"
>Rule 5 is the <B
CLASS="emphasis.bold"
>END</B
> pattern and its action is only executed once, 
printing the sum of file sizes as well as the number of files.</P
><P
CLASS="para"
>The <KBD
CLASS="command"
>filesum</KBD
> program demonstrates many of the
basic constructs used in awk.  What's more, it gives
you a pretty good idea of the process of developing a
program (although syntax errors produced by typos
and hasty thinking have been gracefully omitted).
If you wish to tinker with this program, you might add a counter
for a directories, or a rule that handles symbolic links.</P
><A
CLASS="indexterm"
NAME="AUTOID-5961"
></A
><A
CLASS="indexterm"
NAME="AUTOID-5962"
></A
></DIV
></DIV
><DIV
CLASS="htmlnav"
><P
></P
><HR
ALIGN="LEFT"
WIDTH="515"
TITLE="footer"><TABLE
WIDTH="515"
BORDER="0"
CELLSPACING="0"
CELLPADDING="0"
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="172"
><A
CLASS="SECT1"
HREF="ch07_07.htm"
TITLE="7.7 System Variables"
><IMG
SRC="../gifs/txtpreva.gif"
ALT="Previous: 7.7 System Variables"
BORDER="0"></A
></TD
><TD
ALIGN="CENTER"
VALIGN="TOP"
WIDTH="171"
><A
CLASS="book"
HREF="index.htm"
TITLE="sed &amp; awk"
><IMG
SRC="../gifs/txthome.gif"
ALT="sed &amp; awk"
BORDER="0"></A
></TD
><TD
ALIGN="RIGHT"
VALIGN="TOP"
WIDTH="172"
><A
CLASS="SECT1"
HREF="ch07_09.htm"
TITLE="7.9 Formatted Printing"
><IMG
SRC="../gifs/txtnexta.gif"
ALT="Next: 7.9 Formatted Printing"
BORDER="0"></A
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="172"
>7.7 System Variables</TD
><TD
ALIGN="CENTER"
VALIGN="TOP"
WIDTH="171"
><A
CLASS="index"
HREF="index/idx_0.htm"
TITLE="Book Index"
><IMG
SRC="../gifs/index.gif"
ALT="Book Index"
BORDER="0"></A
></TD
><TD
ALIGN="RIGHT"
VALIGN="TOP"
WIDTH="172"
>7.9 Formatted Printing</TD
></TR
></TABLE
><HR
ALIGN="LEFT"
WIDTH="515"
TITLE="footer"><IMG
SRC="../gifs/smnavbar.gif"
USEMAP="#map"
BORDER="0"
ALT="The UNIX CD Bookshelf Navigation"><MAP
NAME="map"
><AREA
SHAPE="RECT"
COORDS="0,0,73,21"
HREF="../index.htm"
ALT="The UNIX CD Bookshelf"><AREA
SHAPE="RECT"
COORDS="74,0,163,21"
HREF="../upt/index.htm"
ALT="UNIX Power Tools"><AREA
SHAPE="RECT"
COORDS="164,0,257,21"
HREF="../unixnut/index.htm"
ALT="UNIX in a Nutshell"><AREA
SHAPE="RECT"
COORDS="258,0,321,21"
HREF="../vi/index.htm"
ALT="Learning the vi Editor"><AREA
SHAPE="RECT"
COORDS="322,0,378,21"
HREF="index.htm"
ALT="sed &amp; awk"><AREA
SHAPE="RECT"
COORDS="379,0,438,21"
HREF="../ksh/index.htm"
ALT="Learning the Korn Shell"><AREA
SHAPE="RECT"
COORDS="439,0,514,21"
HREF="../lrnunix/index.htm"
ALT="Learning the UNIX Operating System"></MAP
></DIV
></BODY
></HTML
>
