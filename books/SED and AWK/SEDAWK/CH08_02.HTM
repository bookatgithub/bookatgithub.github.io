<HTML
><HEAD
>
<TITLE>[Chapter 8] 8.2 Looping</TITLE>
<META
NAME="DC.title"
CONTENT="sed &amp; awk"><META
NAME="DC.creator"
CONTENT="Dale Dougherty &amp; Arnold Robbins"><META
NAME="DC.publisher"
CONTENT="O'Reilly &amp; Associates, Inc."><META
NAME="DC.date"
CONTENT="1998-08-03T20:58:45Z"><META
NAME="DC.type"
CONTENT="Text.Monograph"><META
NAME="DC.format"
CONTENT="text/html"
SCHEME="MIME"><META
NAME="DC.source"
CONTENT="1-56592-225-5"
SCHEME="ISBN"><META
NAME="DC.language"
CONTENT="en-US"><META
NAME="generator"
CONTENT="Jade 1.1/O'Reilly DocBook 3.0 to HTML 4.0"><LINK
REV="made"
HREF="mailto:online-books@oreilly.com"
TITLE="Online Books Comments"><LINK
REL="up"
HREF="ch08_01.htm"
TITLE="8. Conditionals, Loops, and Arrays"><LINK
REL="prev"
HREF="ch08_01.htm"
TITLE="8.1 Conditional Statements"><LINK
REL="next"
HREF="ch08_03.htm"
TITLE="8.3 Other Statements That Affect Flow Control"></HEAD
><BODY
BGCOLOR="#FFFFFF"
TEXT="#000000"
><DIV
CLASS="htmlnav"
><H1
><IMG
SRC="gifs/smbanner.gif"
ALT="sed &amp; awk"
USEMAP="#srchmap"
BORDER="0"></H1
><MAP
NAME="srchmap"
><AREA
SHAPE="RECT"
COORDS="0,0,466,65"
HREF="index.htm"
ALT="sed &amp; awk"><AREA
SHAPE="RECT"
COORDS="467,0,514,18"
HREF="../search/ssrch.htm"
ALT="Search this book"></MAP
><TABLE
WIDTH="515"
BORDER="0"
CELLSPACING="0"
CELLPADDING="0"
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="172"
><A
CLASS="SECT1"
HREF="ch08_01.htm"
TITLE="8.1 Conditional Statements"
><IMG
SRC="../gifs/txtpreva.gif"
ALT="Previous: 8.1 Conditional Statements"
BORDER="0"></A
></TD
><TD
ALIGN="CENTER"
VALIGN="TOP"
WIDTH="171"
><B
><FONT
FACE="ARIEL,HELVETICA,HELV,SANSERIF"
SIZE="-1"
>Chapter 8<BR>Conditionals, Loops, and Arrays</FONT
></B
></TD
><TD
ALIGN="RIGHT"
VALIGN="TOP"
WIDTH="172"
><A
CLASS="SECT1"
HREF="ch08_03.htm"
TITLE="8.3 Other Statements That Affect Flow Control"
><IMG
SRC="../gifs/txtnexta.gif"
ALT="Next: 8.3 Other Statements That Affect Flow Control"
BORDER="0"></A
></TD
></TR
></TABLE
>&nbsp;<HR
ALIGN="LEFT"
WIDTH="515"
TITLE="footer"></DIV
><DIV
CLASS="SECT1"
><H2
CLASS="sect1"
><A
CLASS="title"
NAME="SEDAWK-CH-8-SECT-2"
>8.2 Looping</A
></H2
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="CH08.LOOP"
></A
>A loop is a construct that allows us to perform one or more actions
again and again.  In awk, a loop can be specified using a
<KBD
CLASS="command"
>while</KBD
>, <KBD
CLASS="command"
>do</KBD
>, or
<KBD
CLASS="command"
>for</KBD
> statement.</P
><DIV
CLASS="sect2"
><H3
CLASS="sect2"
><A
CLASS="title"
NAME="SEDAWK-CH-8-SECT-2.1"
>8.2.1 While Loop</A
></H3
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-6412"
></A
>The syntax of a <KBD
CLASS="command"
>while</KBD
> loop is:</P
><BLOCKQUOTE
CLASS="literallayout"
><P
CLASS="literallayout"
><KBD
CLASS="command"
>while</KBD
> (<CODE
CLASS="replaceable"
><I
>condition</I
></CODE
>) <BR>	<CODE
CLASS="replaceable"
><I
>action</I
></CODE
></P
></BLOCKQUOTE
><P
CLASS="para"
>The newline is optional after the right parenthesis.  The conditional
expression is evaluated at the top of the loop and, if true, the
action is performed.  If the expression is never true, the action is
not performed.  Typically, the conditional expression evaluates to
true and the action changes a value such that the conditional
expression eventually returns false and the loop is exited.  For
instance, if you wanted to perform an action four times, you could
write the following loop:</P
><P
CLASS="para"
><BLOCKQUOTE
CLASS="screen"
><PRE
CLASS="screen"
>i = 1
while ( i &lt;= 4 ) {
	print $i
	++i 
}</PRE
></BLOCKQUOTE
></P
><P
CLASS="para"
>As in an <KBD
CLASS="command"
>if</KBD
> statement, an action consisting of more
than one statement must be enclosed in braces.  Note the role of each
statement.  The first statement assigns an initial value to
<KBD
CLASS="command"
>i</KBD
>.  The expression &quot;i &lt;= 4&quot; compares
<KBD
CLASS="command"
>i</KBD
> to 4 to determine if the action should be
executed.  The action consists of two statements, one that simply
prints the value of a field referenced as &quot;$i&quot; and another that
increments <KBD
CLASS="command"
>i</KBD
>.  <KBD
CLASS="command"
>i</KBD
> is a counter
variable and is used to keep track of how many times we go through the
loop.  If we did not increment the counter variable or if the
comparison would never evaluate to false (e.g., i &gt; 0), then the
action would be repeated without end.</P
></DIV
><DIV
CLASS="sect2"
><H3
CLASS="sect2"
><A
CLASS="title"
NAME="SEDAWK-CH-8-SECT-2.2"
>8.2.2 Do Loop</A
></H3
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="CH08.DO"
></A
>The <KBD
CLASS="command"
>do</KBD
> loop is a variation of the
<KBD
CLASS="command"
>while</KBD
> loop.  The syntax of a <KBD
CLASS="command"
>do</KBD
>
loop is:</P
><BLOCKQUOTE
CLASS="literallayout"
><P
CLASS="literallayout"
><KBD
CLASS="command"
>do</KBD
><BR>	<CODE
CLASS="replaceable"
><I
>action</I
></CODE
><BR><KBD
CLASS="command"
>while</KBD
> (<CODE
CLASS="replaceable"
><I
>condition</I
></CODE
>)</P
></BLOCKQUOTE
><P
CLASS="para"
>The newline is optional after <KBD
CLASS="command"
>do</KBD
>.  It is also optional
after <CODE
CLASS="replaceable"
><I
>action</I
></CODE
> providing the statement is terminated
by a semicolon. The main feature of this loop is that the conditional
expression appears <EM
CLASS="emphasis"
>after</EM
> the action.  Thus, the action is
performed at least once. Look at the following <KBD
CLASS="command"
>do</KBD
> loop.</P
><P
CLASS="para"
><BLOCKQUOTE
CLASS="screen"
><PRE
CLASS="screen"
>BEGIN {
	do {
		++x
		print x
	} while ( x &lt;= 4 )
}</PRE
></BLOCKQUOTE
></P
><P
CLASS="para"
>In this example, the value of <KBD
CLASS="command"
>x</KBD
> is set in the body
of the loop using the auto-increment operator.  The body of the loop
is executed once and the expression is evaluated.  In the previous
example of a <KBD
CLASS="command"
>while</KBD
> loop, the initial value of
<KBD
CLASS="command"
>i</KBD
> was set before the loop.  The expression was
evaluated first, then the body of the loop was executed once.  Note
the value of <KBD
CLASS="command"
>x</KBD
> when we run this example:</P
><P
CLASS="para"
><BLOCKQUOTE
CLASS="screen"
><PRE
CLASS="screen"
>$ <CODE
CLASS="userinput"
><B
>awk -f do.awk</B
></CODE
>
1
2
3
4
5</PRE
></BLOCKQUOTE
></P
><P
CLASS="para"
>Before the conditional expression is first evaluated,
<KBD
CLASS="command"
>x</KBD
> is incremented to 1. (This relies on the fact
that all awk variables are initialized to zero.)  The body of the loop
is executed five times, not four; when <KBD
CLASS="command"
>x</KBD
> equals 4,
the conditional expression is true and the body of the loop is
executed again, incrementing <KBD
CLASS="command"
>x</KBD
> to 5 and printing
its value.  Only then is the conditional expression evaluated to false
and the loop exited.  By changing the operator from &quot;&lt;=&quot; to &quot;&lt;&quot;,
or less than, the body of the loop will be executed four times.</P
><P
CLASS="para"
>To keep in mind the difference between the <KBD
CLASS="command"
>do</KBD
> loop
and the <KBD
CLASS="command"
>while</KBD
> loop, remember that the
<KBD
CLASS="command"
>do</KBD
> loop always executes the body of the loop
<EM
CLASS="emphasis"
>at least once</EM
>.  At the bottom of the procedure,
you decide if you need to execute it again.</P
><P
CLASS="para"
>For an example, let's look at a program that loops through the fields
of a record, referencing as many fields as necessary until their
cumulative value exceeds 100.  The reason we use a
<KBD
CLASS="command"
>do</KBD
> loop is that we will reference at least one of
the fields.  We add the value of the field to the total, and if the
total exceeds 100 we don't reference any other fields.  We reference
the second field only if the first field is less than 100.  Its value
is added to the total and if the total exceeds 100 then we exit the
loop.  If it is still less than 100, we execute the loop once again.</P
><P
CLASS="para"
><BLOCKQUOTE
CLASS="screen"
><PRE
CLASS="screen"
>{
	total = i = 0
	do {
		++i
		total += $i
	} while ( total &lt;= 100 )
	print i, &quot;:&quot;, total
}</PRE
></BLOCKQUOTE
></P
><P
CLASS="para"
>The first line of the script initializes the values of two variables:
<KBD
CLASS="command"
>total</KBD
> and <KBD
CLASS="command"
>i</KBD
>.  The loop
increments the value of <KBD
CLASS="command"
>i</KBD
> and uses the field
operator to reference a particular field.  Each time through the loop,
it refers to a different field.  When the loop is executed for the
first time, the field reference gets the value of field one and
assigns it to the variable <KBD
CLASS="command"
>total</KBD
>.  The conditional
expression at the end of the loop evaluates whether
<KBD
CLASS="command"
>total</KBD
> exceeds 100.  If it does, the loop is exited.
Then the value of <KBD
CLASS="command"
>i</KBD
>, the number of fields that
we've referred to, and the total are printed.  (This script assumes
that each record totals at least 100; otherwise, we'd have to check
that <KBD
CLASS="command"
>i</KBD
> does not exceed the number of fields for the
record.  We construct such a test in the example presented in next
section to show the <KBD
CLASS="command"
>for</KBD
> loop.)</P
><P
CLASS="para"
>Here's a test file containing a series of numbers:</P
><P
CLASS="para"
><BLOCKQUOTE
CLASS="screen"
><PRE
CLASS="screen"
>$ <CODE
CLASS="userinput"
><B
>cat test.do</B
></CODE
>
45 25 60 20
10 105 50 40
33 5 9 67
108 3 5 4</PRE
></BLOCKQUOTE
></P
><P
CLASS="para"
>Running the script on the test file produces the following:</P
><P
CLASS="para"
><BLOCKQUOTE
CLASS="screen"
><PRE
CLASS="screen"
>$ <CODE
CLASS="userinput"
><B
>awk -f do.awk test.do</B
></CODE
>
3 : 130
2 : 115
4 : 114
1 : 108</PRE
></BLOCKQUOTE
></P
><P
CLASS="para"
>For each record, only as many fields are referenced as needed for the total
to exceed 100.</P
><A
CLASS="indexterm"
NAME="AUTOID-6487"
></A
></DIV
><DIV
CLASS="sect2"
><H3
CLASS="sect2"
><A
CLASS="title"
NAME="SEDAWK-CH-8-SECT-2.3"
>8.2.3 For Loop</A
></H3
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="CH08.FOR"
></A
>The <KBD
CLASS="command"
>for</KBD
> statement offers a more compact syntax that
achieves the same result as a <KBD
CLASS="command"
>while</KBD
> loop.  Although
it looks more difficult, this syntax is much easier to use and makes
sure that you provide all the required elements of a loop.  The syntax
of a <KBD
CLASS="command"
>for</KBD
> loop is:</P
><BLOCKQUOTE
CLASS="literallayout"
><P
CLASS="literallayout"
><KBD
CLASS="command"
>for</KBD
> ( <CODE
CLASS="replaceable"
><I
>set_counter</I
></CODE
> ; <CODE
CLASS="replaceable"
><I
>test_counter</I
></CODE
> ; <CODE
CLASS="replaceable"
><I
>increment_counter</I
></CODE
> ) <BR>    <CODE
CLASS="replaceable"
><I
>action</I
></CODE
></P
></BLOCKQUOTE
><P
CLASS="para"
>The newline after the right parenthesis is optional.  The
<KBD
CLASS="command"
>for</KBD
> loop consists of three expressions:</P
><DL
CLASS="variablelist"
><DT
CLASS="term"
><EM
CLASS="emphasis"
>set_counter</EM
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
>Sets the initial value for a counter variable.  <A
CLASS="indexterm"
NAME="AUTOID-6510"
></A
></P
></DD
><DT
CLASS="term"
><EM
CLASS="emphasis"
>test_counter</EM
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
>States a condition that is tested at the top of the loop.  </P
></DD
><DT
CLASS="term"
><EM
CLASS="emphasis"
>increment_counter</EM
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
>Increments the counter each time at the bottom of the loop,
right before testing the <EM
CLASS="emphasis"
>test_counter</EM
> again. </P
></DD
></DL
><P
CLASS="para"
>Look at this rather common <KBD
CLASS="command"
>for</KBD
> loop that prints
each field on the input line.</P
><P
CLASS="para"
><BLOCKQUOTE
CLASS="screen"
><PRE
CLASS="screen"
>for ( i = 1; i &lt;= NF; i++ )
	print $i</PRE
></BLOCKQUOTE
></P
><P
CLASS="para"
>As in the previous example, <KBD
CLASS="command"
>i</KBD
> is a variable that is
used to reference a field using the field operator.  The system
variable <KBD
CLASS="command"
>NF</KBD
> contains the number of fields for the
current input record, and we test it to determine if
<KBD
CLASS="command"
>i</KBD
> has reached the last field on the line.  The
value of <KBD
CLASS="command"
>NF</KBD
> is the maximum number of times to go
through the loop.  Inside the loop, the <KBD
CLASS="command"
>print</KBD
>
statement is executed, printing each field on its own line.  A script
using this construct can print each word on a line by itself, which
can then be run through <KBD
CLASS="command"
>sort | uniq -c</KBD
> to get word
distribution statistics for a file.</P
><P
CLASS="para"
>You can also write a loop to print from the last field to the first.</P
><P
CLASS="para"
><BLOCKQUOTE
CLASS="screen"
><PRE
CLASS="screen"
>for ( i = NF; i &gt;= 1; i-- )
	print $i</PRE
></BLOCKQUOTE
></P
><P
CLASS="para"
>Each time through the loop the counter is decremented.  You could use
this to reverse the order of fields.</P
><P
CLASS="para"
>The <KBD
CLASS="command"
>grades.awk</KBD
> script that we showed earlier
determined the average of five grades.  We can make the script much
more useful by averaging any number of grades.  That is, if you were
to run this script throughout the school year, the number of grades to
average would increase.  Rather than revising the script to
accommodate the specific number of fields, we can write a generalized
script that loops to read however many fields there are.  Our
earlier version of the program calculated the average of 5 grades
using these two statements:</P
><P
CLASS="para"
><BLOCKQUOTE
CLASS="screen"
><PRE
CLASS="screen"
>total = $2 + $3 + $4 + $5 + $6
avg = total / 5</PRE
></BLOCKQUOTE
></P
><P
CLASS="para"
>We can revise that using a <KBD
CLASS="command"
>for</KBD
> loop to sum each
field in the record.</P
><P
CLASS="para"
><BLOCKQUOTE
CLASS="screen"
><PRE
CLASS="screen"
>total = 0
for (i = 2; i &lt;= NF; ++i)
      total += $i
avg = total / (NF - 1)</PRE
></BLOCKQUOTE
></P
><P
CLASS="para"
>We initialize the variable <KBD
CLASS="command"
>total</KBD
> each time because
we don't want its value to accumulate from one record to the next.  At
the beginning of the <KBD
CLASS="command"
>for</KBD
> loop, the counter
<KBD
CLASS="command"
>i</KBD
> is initialized to 2 because the first numeric
field is field 2.  Each time through the loop the value of the current
field is added to <KBD
CLASS="command"
>total</KBD
>.  When the last field has
been referenced (<KBD
CLASS="command"
>i</KBD
> is greater than
<KBD
CLASS="command"
>NF</KBD
>), we break out of the loop and calculate the
average.  For instance, if the record consists of 4 fields, the first
time through the loop, we assign the value of $2 to
<KBD
CLASS="command"
>total</KBD
>.  At the bottom of the loop,
<KBD
CLASS="command"
>i</KBD
> is incremented by 1, then compared to
<KBD
CLASS="command"
>NF</KBD
>, which is 4.  The expression evaluates to true
and <KBD
CLASS="command"
>total</KBD
> is incremented by the value of $3.</P
><P
CLASS="para"
>Notice how we divide the total by the number of fields minus 1 to
remove the student name from the count.  The parentheses are required
around &quot;NF - 1&quot; because the precedence of operators would otherwise
divide <KBD
CLASS="command"
>total</KBD
> by <KBD
CLASS="command"
>NF</KBD
> and then
subtract 1, instead of subtracting 1 from <KBD
CLASS="command"
>NF</KBD
> first.</P
><A
CLASS="indexterm"
NAME="AUTOID-6561"
></A
></DIV
><DIV
CLASS="sect2"
><H3
CLASS="sect2"
><A
CLASS="title"
NAME="SEDAWK-CH-8-SECT-2.4"
>8.2.4 Deriving Factorials</A
></H3
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="CH08.FACT"
></A
><A
CLASS="indexterm"
NAME="CH08.FACT2"
></A
>The factorial of a number is the product of successively multiplying
that number by one less than that number.  The factorial of 4 is 4
&#215; 3 &#215; 2 &#215; 1, or 24.  The factorial of 5 is 5 times
the factorial of 4 or 5 &#215; 24, or 120.  Deriving a factorial for a
given number can be expressed using a loop as follows:</P
><P
CLASS="para"
><BLOCKQUOTE
CLASS="screen"
><PRE
CLASS="screen"
>fact = number
for (x = number - 1 ; x &gt; 1; x--)
	fact *= x</PRE
></BLOCKQUOTE
></P
><P
CLASS="para"
>where <KBD
CLASS="command"
>number</KBD
> is the number for which we will derive
the factorial <KBD
CLASS="command"
>fact</KBD
>.  Let's say that
<KBD
CLASS="command"
>number</KBD
> equals 5.  The first time through the loop
<KBD
CLASS="command"
>x</KBD
> is equal to 4.  The action evaluates &quot;5 * 4&quot; and
assigns the value to <KBD
CLASS="command"
>fact</KBD
>.  The next time through
the loop, <KBD
CLASS="command"
>x</KBD
> is 3 and 20 is multiplied by it.  We go
through the loop until <KBD
CLASS="command"
>x</KBD
> equals 1.</P
><P
CLASS="para"
>Here is the above fragment incorporated into a standalone script
that prompts the user for a number and then prints the factorial
of that number.</P
><P
CLASS="para"
><BLOCKQUOTE
CLASS="screen"
><PRE
CLASS="screen"
>awk '# factorial: return factorial of user-supplied number
BEGIN {
	# prompt user; use printf, not print, to avoid the newline
	printf(&quot;Enter number: &quot;)
}

# check that user enters a number
$1 ~ /^[0-9]+$/ { 
	# assign value of $1 to number &amp; fact
	number = $1
	if (number == 0)
		fact = 1
	else
		fact = number
	# loop to multiply fact*x until x = 1
	for (x = number - 1; x &gt; 1; x--)
		fact *= x
	printf(&quot;The factorial of %d is %g\n&quot;, number, fact)
	# exit -- saves user from typing CRTL-D.
	exit
}

# if not a number, prompt again.
{ printf(&quot;\nInvalid entry. Enter a number: &quot;) 
}' -</PRE
></BLOCKQUOTE
></P
><P
CLASS="para"
>This is an interesting example of a main input loop that prompts for
input and reads the reply from standard input.  The
<KBD
CLASS="command"
>BEGIN</KBD
> rule is used to prompt the user to enter a
number.  Because we have specified that input is to come not from a
file but from standard input, the program will halt after putting out
the prompt and then wait for the user to type a number.  The first
rule checks that a number has been entered.  If not, the second rule
will be applied, prompting the user again to re-enter a number.  We
set up an input loop that will continue to read from standard input
until a valid entry is found.  See the <KBD
CLASS="command"
>lookup</KBD
>
program in the next section for another example of constructing an
input loop.</P
><P
CLASS="para"
>Here's an example of how the <KBD
CLASS="command"
>factorial</KBD
> program works:</P
><P
CLASS="para"
><BLOCKQUOTE
CLASS="screen"
><PRE
CLASS="screen"
>$ <CODE
CLASS="userinput"
><B
>factorial</B
></CODE
>
Enter number: <CODE
CLASS="userinput"
><B
>5</B
></CODE
>
The factorial of 5 is 120</PRE
></BLOCKQUOTE
></P
><P
CLASS="para"
>Note that the result uses &quot;%g&quot; as the conversion specification format
in the <KBD
CLASS="command"
>printf</KBD
> statement.  This permits floating
point notation to be used to express very large numbers.  Look at the
following example:</P
><P
CLASS="para"
><BLOCKQUOTE
CLASS="screen"
><PRE
CLASS="screen"
>$<CODE
CLASS="userinput"
><B
> factorial</B
></CODE
>
Enter number: <CODE
CLASS="userinput"
><B
>33</B
></CODE
>
The factorial of 33 is 8.68332e+36</PRE
></BLOCKQUOTE
></P
><A
CLASS="indexterm"
NAME="AUTOID-6598"
></A
><A
CLASS="indexterm"
NAME="AUTOID-6599"
></A
></DIV
><A
CLASS="indexterm"
NAME="AUTOID-6600"
></A
></DIV
><DIV
CLASS="htmlnav"
><P
></P
><HR
ALIGN="LEFT"
WIDTH="515"
TITLE="footer"><TABLE
WIDTH="515"
BORDER="0"
CELLSPACING="0"
CELLPADDING="0"
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="172"
><A
CLASS="SECT1"
HREF="ch08_01.htm"
TITLE="8.1 Conditional Statements"
><IMG
SRC="../gifs/txtpreva.gif"
ALT="Previous: 8.1 Conditional Statements"
BORDER="0"></A
></TD
><TD
ALIGN="CENTER"
VALIGN="TOP"
WIDTH="171"
><A
CLASS="book"
HREF="index.htm"
TITLE="sed &amp; awk"
><IMG
SRC="../gifs/txthome.gif"
ALT="sed &amp; awk"
BORDER="0"></A
></TD
><TD
ALIGN="RIGHT"
VALIGN="TOP"
WIDTH="172"
><A
CLASS="SECT1"
HREF="ch08_03.htm"
TITLE="8.3 Other Statements That Affect Flow Control"
><IMG
SRC="../gifs/txtnexta.gif"
ALT="Next: 8.3 Other Statements That Affect Flow Control"
BORDER="0"></A
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="172"
>8.1 Conditional Statements</TD
><TD
ALIGN="CENTER"
VALIGN="TOP"
WIDTH="171"
><A
CLASS="index"
HREF="index/idx_0.htm"
TITLE="Book Index"
><IMG
SRC="../gifs/index.gif"
ALT="Book Index"
BORDER="0"></A
></TD
><TD
ALIGN="RIGHT"
VALIGN="TOP"
WIDTH="172"
>8.3 Other Statements That Affect Flow Control</TD
></TR
></TABLE
><HR
ALIGN="LEFT"
WIDTH="515"
TITLE="footer"><IMG
SRC="../gifs/smnavbar.gif"
USEMAP="#map"
BORDER="0"
ALT="The UNIX CD Bookshelf Navigation"><MAP
NAME="map"
><AREA
SHAPE="RECT"
COORDS="0,0,73,21"
HREF="../index.htm"
ALT="The UNIX CD Bookshelf"><AREA
SHAPE="RECT"
COORDS="74,0,163,21"
HREF="../upt/index.htm"
ALT="UNIX Power Tools"><AREA
SHAPE="RECT"
COORDS="164,0,257,21"
HREF="../unixnut/index.htm"
ALT="UNIX in a Nutshell"><AREA
SHAPE="RECT"
COORDS="258,0,321,21"
HREF="../vi/index.htm"
ALT="Learning the vi Editor"><AREA
SHAPE="RECT"
COORDS="322,0,378,21"
HREF="index.htm"
ALT="sed &amp; awk"><AREA
SHAPE="RECT"
COORDS="379,0,438,21"
HREF="../ksh/index.htm"
ALT="Learning the Korn Shell"><AREA
SHAPE="RECT"
COORDS="439,0,514,21"
HREF="../lrnunix/index.htm"
ALT="Learning the UNIX Operating System"></MAP
></DIV
></BODY
></HTML
>
