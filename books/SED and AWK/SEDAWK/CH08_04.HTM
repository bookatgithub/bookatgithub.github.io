<HTML
><HEAD
>
<TITLE>[Chapter 8] 8.4 Arrays</TITLE>
<META
NAME="DC.title"
CONTENT="sed &amp; awk"><META
NAME="DC.creator"
CONTENT="Dale Dougherty &amp; Arnold Robbins"><META
NAME="DC.publisher"
CONTENT="O'Reilly &amp; Associates, Inc."><META
NAME="DC.date"
CONTENT="1998-08-03T20:58:54Z"><META
NAME="DC.type"
CONTENT="Text.Monograph"><META
NAME="DC.format"
CONTENT="text/html"
SCHEME="MIME"><META
NAME="DC.source"
CONTENT="1-56592-225-5"
SCHEME="ISBN"><META
NAME="DC.language"
CONTENT="en-US"><META
NAME="generator"
CONTENT="Jade 1.1/O'Reilly DocBook 3.0 to HTML 4.0"><LINK
REV="made"
HREF="mailto:online-books@oreilly.com"
TITLE="Online Books Comments"><LINK
REL="up"
HREF="ch08_01.htm"
TITLE="8. Conditionals, Loops, and Arrays"><LINK
REL="prev"
HREF="ch08_03.htm"
TITLE="8.3 Other Statements That Affect Flow Control"><LINK
REL="next"
HREF="ch08_05.htm"
TITLE="8.5 An Acronym Processor"></HEAD
><BODY
BGCOLOR="#FFFFFF"
TEXT="#000000"
><DIV
CLASS="htmlnav"
><H1
><IMG
SRC="gifs/smbanner.gif"
ALT="sed &amp; awk"
USEMAP="#srchmap"
BORDER="0"></H1
><MAP
NAME="srchmap"
><AREA
SHAPE="RECT"
COORDS="0,0,466,65"
HREF="index.htm"
ALT="sed &amp; awk"><AREA
SHAPE="RECT"
COORDS="467,0,514,18"
HREF="../search/ssrch.htm"
ALT="Search this book"></MAP
><TABLE
WIDTH="515"
BORDER="0"
CELLSPACING="0"
CELLPADDING="0"
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="172"
><A
CLASS="SECT1"
HREF="ch08_03.htm"
TITLE="8.3 Other Statements That Affect Flow Control"
><IMG
SRC="../gifs/txtpreva.gif"
ALT="Previous: 8.3 Other Statements That Affect Flow Control"
BORDER="0"></A
></TD
><TD
ALIGN="CENTER"
VALIGN="TOP"
WIDTH="171"
><B
><FONT
FACE="ARIEL,HELVETICA,HELV,SANSERIF"
SIZE="-1"
>Chapter 8<BR>Conditionals, Loops, and Arrays</FONT
></B
></TD
><TD
ALIGN="RIGHT"
VALIGN="TOP"
WIDTH="172"
><A
CLASS="SECT1"
HREF="ch08_05.htm"
TITLE="8.5 An Acronym Processor"
><IMG
SRC="../gifs/txtnexta.gif"
ALT="Next: 8.5 An Acronym Processor"
BORDER="0"></A
></TD
></TR
></TABLE
>&nbsp;<HR
ALIGN="LEFT"
WIDTH="515"
TITLE="footer"></DIV
><DIV
CLASS="SECT1"
><H2
CLASS="sect1"
><A
CLASS="title"
NAME="SEDAWK-CH-8-SECT-4"
>8.4 Arrays</A
></H2
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="CH08.ARRAY"
></A
><A
CLASS="indexterm"
NAME="AUTOID-6677"
></A
>An array is a variable that can be used to store a set of values.
Usually the values are related in some way.  Individual elements are
accessed by their <EM
CLASS="emphasis"
>index</EM
> in the array. Each index
is enclosed in square brackets.  The following statement assigns a
value to an element of an array:</P
><BLOCKQUOTE
CLASS="literallayout"
><P
CLASS="literallayout"
><CODE
CLASS="replaceable"
><I
>array</I
></CODE
>[<CODE
CLASS="replaceable"
><I
>subscript</I
></CODE
>] = <CODE
CLASS="replaceable"
><I
>value</I
></CODE
></P
></BLOCKQUOTE
><P
CLASS="para"
>In awk, you don't have to declare the size of the array; you only have
to use the identifier as an array.  This is best done by assigning a
value to an array element.  For instance, the following example
assigns the string <CODE
CLASS="literal"
>&quot;</CODE
><B
CLASS="emphasis.bold"
>cherry</B
><CODE
CLASS="literal"
>&quot;</CODE
> to an element of the array named
<KBD
CLASS="command"
>flavor</KBD
>.</P
><P
CLASS="para"
><BLOCKQUOTE
CLASS="screen"
><PRE
CLASS="screen"
>flavor[1] = &quot;cherry&quot;</PRE
></BLOCKQUOTE
></P
><P
CLASS="para"
>The index or subscript of this element of the array is &quot;1&quot;.  The
following statement prints the string &quot;cherry&quot;:</P
><P
CLASS="para"
><BLOCKQUOTE
CLASS="screen"
><PRE
CLASS="screen"
>print flavor[1]</PRE
></BLOCKQUOTE
></P
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-6695"
></A
>Loops can be used to load and extract elements from arrays.  For
instance, if the array <KBD
CLASS="command"
>flavor</KBD
> has five elements,
you can write a loop to print each element:</P
><P
CLASS="para"
><BLOCKQUOTE
CLASS="screen"
><PRE
CLASS="screen"
>flavor_count = 5
for (x = 1; x &lt;= flavor_count; ++x)
	print flavor[x]</PRE
></BLOCKQUOTE
></P
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-6702"
></A
>One way that arrays are used in awk is to store a value from each
record, using the record number as the index to the array.
Let's suppose we wanted to keep track of the averages calculated for each
student and come up with a class average.  Each time a record is read
we make the following assignment.</P
><P
CLASS="para"
><BLOCKQUOTE
CLASS="screen"
><PRE
CLASS="screen"
>student_avg[NR] = avg</PRE
></BLOCKQUOTE
></P
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-6708"
></A
><A
CLASS="indexterm"
NAME="AUTOID-6710"
></A
>The system variable <KBD
CLASS="command"
>NR</KBD
> is used as the subscript for
the array because it is incremented for each record.  When the first
record is read, the value of <KBD
CLASS="command"
>avg</KBD
> is placed in
<KBD
CLASS="command"
>student_avg[1]</KBD
>; for the second record, the value is
placed in <KBD
CLASS="command"
>student_avg[2]</KBD
>, and so on.  After we have
read all of the records, we have a list of averages in the array
<KBD
CLASS="command"
>student_avg</KBD
>.  In an <KBD
CLASS="command"
>END</KBD
> rule, we
can average all of these grades by writing a loop to get the total of
the grades and then dividing it by the value of <KBD
CLASS="command"
>NR</KBD
>.
Then we can compare each student average to the class average to
collect totals for the number of students at or above average and the
number below.</P
><P
CLASS="para"
><BLOCKQUOTE
CLASS="screen"
><PRE
CLASS="screen"
>END {
	for ( x = 1; x &lt;= NR; x++ ) 
		class_avg_total += student_avg[x]
	
	class_average = class_avg_total / NR
	
	for ( x = 1; x &lt;= NR; x++ )
		if (student_avg[x] &gt;= class_average)
			++above_average
		else
			++below_average
	
	print &quot;Class Average: &quot;, class_average
	print &quot;At or Above Average: &quot;, above_average
	print &quot;Below Average: &quot;, below_average
}</PRE
></BLOCKQUOTE
></P
><P
CLASS="para"
>There are two <KBD
CLASS="command"
>for</KBD
> loops for accessing the elements
of the array.  The first one totals the averages so that it can be
divided by the number of student records.  The next loop retrieves
each student average so that it can be compared to the class average.
If it is at or above average, we increment the variable
<KBD
CLASS="command"
>above_average</KBD
>; otherwise, we increment
<KBD
CLASS="command"
>below_average</KBD
>.</P
><DIV
CLASS="sect2"
><H3
CLASS="sect2"
><A
CLASS="title"
NAME="SEDAWK-CH-8-SECT-4.1"
>8.4.1 Associative Arrays</A
></H3
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="CH08.ASSOC1"
></A
>In awk, all arrays are <EM
CLASS="emphasis"
>associative</EM
> arrays.  What
makes an associative array unique is that its index can be a string or
a number.</P
><P
CLASS="para"
>In most programming languages, the indices of arrays are exclusively
numeric.  In these implementations, an array is a sequence of
locations where values are stored.  The indices of the array are
derived from the order in which the values are stored.  There is no
need to keep track of indices.  For instance, the index of the first
element of an array is &quot;1&quot; or the first location in the array.</P
><P
CLASS="para"
>An associative array makes an &quot;association&quot; between the indices and
the elements of an array.  For each element of the array, a pair of
values is maintained: the index of the element and the value of the
element.  The elements are not stored in any particular order as in a
conventional array.  Thus, even though you can use numeric subscripts
in awk, the numbers do not have the same meaning that they do in other
programming languages&nbsp;- they do not necessarily refer to
sequential locations.  However, with numeric indices, you can still
access all the elements of an array in sequence, as we did in previous
examples.  You can create a loop to increment a counter that
references the elements of the array in order.</P
><P
CLASS="para"
>Sometimes, the distinction between numeric and string indices is
important.  For instance, if you use &quot;04&quot; as the index to an element
of the array, you cannot reference that element using &quot;4&quot; as its
subscript.  You'll see how to handle this problem in a sample program
<KBD
CLASS="command"
>date-month</KBD
>, shown later in this chapter.</P
><P
CLASS="para"
>Associative arrays are a distinctive feature of awk, and a very
powerful one that allows you to use a string as an index to another
value.  For instance, you could use a word as the index to its
definition.  If you know the word, you can retrieve the definition.</P
><P
CLASS="para"
>For example, you could use the first field of the input line as the
index to the second field with the following assignment:</P
><P
CLASS="para"
><BLOCKQUOTE
CLASS="screen"
><PRE
CLASS="screen"
>array[$1] = $2</PRE
></BLOCKQUOTE
></P
><P
CLASS="para"
>Using this technique, we could take our list of acronyms and load it
into an array named <KBD
CLASS="command"
>acro</KBD
>.</P
><P
CLASS="para"
><BLOCKQUOTE
CLASS="screen"
><PRE
CLASS="screen"
>acro[$1] = $2</PRE
></BLOCKQUOTE
></P
><P
CLASS="para"
>Each element of the array would be the description of an acronym and
the subscript used to retrieve the element would be the acronym
itself.  The following expression:</P
><P
CLASS="para"
><BLOCKQUOTE
CLASS="screen"
><PRE
CLASS="screen"
>acro[&quot;BASIC&quot;]</PRE
></BLOCKQUOTE
></P
><P
CLASS="para"
>produces:</P
><P
CLASS="para"
><BLOCKQUOTE
CLASS="screen"
><PRE
CLASS="screen"
>Beginner's All-Purpose Symbolic Instruction Code</PRE
></BLOCKQUOTE
></P
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-6751"
></A
>There is a special looping syntax for accessing all the elements of an
associative array.  It is a version of the <KBD
CLASS="command"
>for</KBD
>
loop.</P
><BLOCKQUOTE
CLASS="literallayout"
><P
CLASS="literallayout"
><KBD
CLASS="command"
>for</KBD
> ( <CODE
CLASS="replaceable"
><I
>variable</I
></CODE
> <KBD
CLASS="command"
>in</KBD
> <CODE
CLASS="replaceable"
><I
>array</I
></CODE
> )<BR>     <CODE
CLASS="replaceable"
><I
>do something with array</I
></CODE
>[<CODE
CLASS="replaceable"
><I
>variable</I
></CODE
>]</P
></BLOCKQUOTE
><P
CLASS="para"
>The <EM
CLASS="emphasis"
>array</EM
> is the name of an array, as it
was defined.  The <EM
CLASS="emphasis"
>variable</EM
> is any variable,
which you can think of as a temporary variable similar to a counter
that is incremented in a conventional <KBD
CLASS="command"
>for</KBD
> loop.
This variable is set to a particular subscript each time through the
loop.  (Because <CODE
CLASS="replaceable"
><I
>variable</I
></CODE
> is an arbitrary
name, you often see <KBD
CLASS="command"
>item</KBD
> used, regardless of what
variable name was used for the subscript when the array was loaded.)
For example, the following <KBD
CLASS="command"
>for</KBD
> loop prints the name
of the acronym <B
CLASS="emphasis.bold"
>item</B
> and the definition referenced by that name,
<B
CLASS="emphasis.bold"
>acro[item]</B
>.</P
><P
CLASS="para"
><BLOCKQUOTE
CLASS="screen"
><PRE
CLASS="screen"
>for ( item in acro )
	print item, acro[item]</PRE
></BLOCKQUOTE
></P
><P
CLASS="para"
>In this example, the print statement prints the current subscript
(&quot;BASIC,&quot; for instance) followed by the element of the
<KBD
CLASS="command"
>acro</KBD
> array referenced by the subscript (&quot;Beginner's
All-Purpose Symbolic Instruction Code&quot;).</P
><P
CLASS="para"
>This syntax can be applied to arrays with numeric subscripts.
However, the order in which the items are retrieved is somewhat
random.[2]
The order is very likely to vary among awk implementations; be careful
to write your programs so that they don't depend on any one version of
awk.</P
><BLOCKQUOTE
CLASS="footnote"
><P
CLASS="para"
>[2] The technical term used in <CITE
CLASS="citetitle"
>The AWK Programming
Language</CITE
> is &quot;implementation dependent.&quot;  </P
></BLOCKQUOTE
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-6779"
></A
>It is important to remember that all array indices in awk are strings.
Even when you use a number as an index, awk automatically converts it
to a string first.  You don't have to worry about this when you use
integer indices, since they get converted to strings as integers, no
matter what the value may be of <KBD
CLASS="command"
>OFMT</KBD
> (original awk
and earlier versions of new awk) or <KBD
CLASS="command"
>CONVFMT</KBD
> (POSIX
awk).  But if you use a real number as an index, the number to string
conversion might affect you.  For instance:<A
CLASS="indexterm"
NAME="AUTOID-6783"
></A
></P
><P
CLASS="para"
><BLOCKQUOTE
CLASS="screen"
><PRE
CLASS="screen"
>$ <KBD
CLASS="command"
>gawk 'BEGIN { data[1.23] = &quot;3.21&quot;; CONVFMT = &quot;%d&quot;</KBD
>
&gt; <KBD
CLASS="command"
>printf &quot;&lt;%s&gt;\n&quot;, data[1.23] }'</KBD
>
&lt;&gt;</PRE
></BLOCKQUOTE
></P
><P
CLASS="para"
>Here, nothing was printed between the angle brackets, since the second
time, <KBD
CLASS="command"
>1.23</KBD
> was converted to just
<KBD
CLASS="command"
>1</KBD
>, and <KBD
CLASS="command"
>data[&quot;1&quot;]</KBD
> has the empty
string as its value.  </P
><BLOCKQUOTE
CLASS="note"
><P
CLASS="para"
><STRONG
>NOTE:</STRONG
> Not all implementations of awk get the number to
string conversion right when <KBD
CLASS="command"
>CONVFMT</KBD
> has changed
between one use of a number and the next.  Test the above example with
your awk to be sure it works correctly.</P
></BLOCKQUOTE
><P
CLASS="para"
>Now let's return to our student grade program for an example.  Let's
say that we wanted to report how many students got an &quot;A,&quot; how many
got a &quot;B,&quot; and so on.  Once we determine the grade, we could increment
a counter for that grade.  We could set up individual variables for
each letter grade and then test which one to increment.</P
><P
CLASS="para"
><BLOCKQUOTE
CLASS="screen"
><PRE
CLASS="screen"
>if ( grade == &quot;A&quot; )
	++gradeA
else if (grade == &quot;B&quot; )
	++gradeB
.<BR>.<BR>.<BR></PRE
></BLOCKQUOTE
></P
><P
CLASS="para"
>However, an array makes this task much easier.  We can define an array
called <KBD
CLASS="command"
>class_grade</KBD
>, and simply use the letter grade
(A through F) as the index to the array.</P
><P
CLASS="para"
><BLOCKQUOTE
CLASS="screen"
><PRE
CLASS="screen"
>++class_grade[grade]</PRE
></BLOCKQUOTE
></P
><P
CLASS="para"
>Thus, if the grade is an &quot;A&quot; then the value of
<KBD
CLASS="command"
>class_grade[&quot;A&quot;]</KBD
> is incremented by one.  At the end
of the program, we can print out these values in the
<KBD
CLASS="command"
>END</KBD
> rule using the special <KBD
CLASS="command"
>for</KBD
>
loop:</P
><P
CLASS="para"
><BLOCKQUOTE
CLASS="screen"
><PRE
CLASS="screen"
>for (letter_grade in class_grade)
     print letter_grade &quot;:&quot;, class_grade[letter_grade] | &quot;sort&quot;</PRE
></BLOCKQUOTE
></P
><P
CLASS="para"
>The variable <KBD
CLASS="command"
>letter_grade</KBD
> references a single
subscript of the array <KBD
CLASS="command"
>class_grade</KBD
> each time
through the loop.  The output is piped to <KBD
CLASS="command"
>sort</KBD
>, to
make sure the grades come out in the proper order.  (Piping output to
programs is discussed in <A
CLASS="xref"
HREF="ch10_01.htm"
TITLE="The Bottom Drawer"
>Chapter 10, The Bottom Drawer</A
>.)  Since this
is the last addition we make to the <KBD
CLASS="command"
>grades.awk</KBD
>
script, we can look at the full listing.</P
><P
CLASS="para"
><BLOCKQUOTE
CLASS="screen"
><PRE
CLASS="screen"
># grades.awk -- average student grades and determine 
# letter grade as well as class averages.
# $1 = student name; $2 - $NF = test scores.

# set output field separator to tab.
BEGIN { OFS = &quot;\t&quot; }

# action applied to all input lines
{ 
  # add up grades
	total = 0
	for (i = 2; i &lt;= NF; ++i)
		total += $i 
  # calculate average
	avg = total / (NF - 1)
  # assign student's average to element of array
	student_avg[NR] = avg
  # determine letter grade
	if (avg &gt;= 90)  grade = &quot;A&quot;
	else if (avg &gt;= 80) grade = &quot;B&quot;
	else if (avg &gt;= 70) grade = &quot;C&quot;
	else if (avg &gt;= 60) grade = &quot;D&quot;
	else grade = &quot;F&quot;	
  # increment counter for letter grade array
	++class_grade[grade]
  # print student name, average and letter grade
	print $1, avg, grade 
}
# print out class statistics
END {
  # calculate class average
	for (x = 1; x &lt;= NR; x++)
		class_avg_total += student_avg[x]
	class_average = class_avg_total / NR
  # determine how many above/below average
	for (x = 1; x &lt;= NR; x++)
		if (student_avg[x] &gt;= class_average)
			++above_average
		else
			++below_average
  # print results
	print &quot;&quot;
	print &quot;Class Average: &quot;, class_average
	print &quot;At or Above Average: &quot;, above_average
	print &quot;Below Average: &quot;, below_average     
  # print number of students per letter grade
	for (letter_grade in class_grade)
		print letter_grade &quot;:&quot;, class_grade[letter_grade] | &quot;sort&quot;
}</PRE
></BLOCKQUOTE
></P
><P
CLASS="para"
>Here's a sample run:</P
><P
CLASS="para"
><BLOCKQUOTE
CLASS="screen"
><PRE
CLASS="screen"
>$ <CODE
CLASS="userinput"
><B
>cat grades.test</B
></CODE
>
mona 70 77 85 83 70 89
john 85 92 78 94 88 91
andrea 89 90 85 94 90 95
jasper 84 88 80 92 84 82
dunce 64 80 60 60 61 62
ellis 90 98 89 96 96 92
$<CODE
CLASS="userinput"
><B
> awk -f grades.awk grades.test</B
></CODE
>
mona    79      C
john    88      B
andrea  90.5    A
jasper  85      B
dunce   64.5    D
ellis   93.5    A

Class Average:  83.4167
At or Above Average:    4
Below Average:  2
A:      2
B:      2
C:      1
D:      1</PRE
></BLOCKQUOTE
></P
><A
CLASS="indexterm"
NAME="AUTOID-6822"
></A
></DIV
><DIV
CLASS="sect2"
><H3
CLASS="sect2"
><A
CLASS="title"
NAME="SEDAWK-CH-8-SECT-4.2"
>8.4.2 Testing for Membership in an Array</A
></H3
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-6826"
></A
><A
CLASS="indexterm"
NAME="AUTOID-6828"
></A
><A
CLASS="indexterm"
NAME="AUTOID-6830"
></A
><A
CLASS="indexterm"
NAME="AUTOID-6833"
></A
>The keyword <KBD
CLASS="command"
>in</KBD
> is also an operator that can be used
in a conditional expression to test that a subscript is a
<EM
CLASS="emphasis"
>member</EM
> of an array.  The expression:</P
><P
CLASS="para"
><BLOCKQUOTE
CLASS="screen"
><PRE
CLASS="screen"
>item in array</PRE
></BLOCKQUOTE
></P
><P
CLASS="para"
>returns 1 if <KBD
CLASS="command"
>array[item]</KBD
> exists and 0 if it does
not.  For example, the following conditional statement is true if the
string &quot;BASIC&quot; is a subscript of the array <KBD
CLASS="command"
>acro</KBD
>.</P
><P
CLASS="para"
><BLOCKQUOTE
CLASS="screen"
><PRE
CLASS="screen"
>if ( &quot;BASIC&quot; in acro )
	print &quot;Found BASIC&quot;</PRE
></BLOCKQUOTE
></P
><P
CLASS="para"
>This is true if &quot;BASIC&quot; is a subscript used to access an element of
<KBD
CLASS="command"
>acro</KBD
>.  This syntax cannot tell you whether &quot;BASIC&quot;
is the value of an element of <KBD
CLASS="command"
>acro</KBD
>.  This
expression is the same as writing a loop to check that such a
subscript exists, although the above expression is much easier to
write, and much more efficient to execute.</P
></DIV
><DIV
CLASS="sect2"
><H3
CLASS="sect2"
><A
CLASS="title"
NAME="SEDAWK-CH-8-SECT-4.3"
>8.4.3 A Glossary Lookup Script</A
></H3
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-6851"
></A
>This program reads a series of glossary entries from a file named
<EM
CLASS="emphasis"
>glossary</EM
> and puts them into an array.  The user
is prompted to enter a glossary term and if it is found, the
definition of the term is printed.</P
><P
CLASS="para"
>Here's the <KBD
CLASS="command"
>lookup</KBD
> program:</P
><P
CLASS="para"
><BLOCKQUOTE
CLASS="screen"
><PRE
CLASS="screen"
>awk '# lookup -- reads local glossary file and prompts user for query

#0
BEGIN { FS = &quot;\t&quot;; OFS = &quot;\t&quot;
	# prompt user
	printf(&quot;Enter a glossary term: &quot;)
} 

#1 read local file named glossary
FILENAME == &quot;glossary&quot; {
	# load each glossary entry into an array
	entry[$1] = $2
	next
} 

#2 scan for command to exit program
$0 ~ /^(quit|[qQ]|exit|[Xx])$/ { exit }

#3 process any non-empty line 
$0 != &quot;&quot; {
	if ( $0 in entry ) {
		# it is there, print definition
		print entry[$0]
	} else
		print $0 &quot; not found&quot;
}

#4 prompt user again for another term
{
	printf(&quot;Enter another glossary term (q to quit): &quot;)
}' glossary -</PRE
></BLOCKQUOTE
></P
><P
CLASS="para"
>The pattern-matching rules are numbered to make this discussion
easier.  As we look at the individual rules, we'll discuss them in the
order in which they are encountered in the flow of the script.  Rule
#0 is the <KBD
CLASS="command"
>BEGIN</KBD
> rule, which is performed only once
before any input is read.  It sets <KBD
CLASS="command"
>FS</KBD
> and
<KBD
CLASS="command"
>OFS</KBD
> to a tab and then prompts the user to enter a
glossary item.  The response will come from standard input, but that
is read after the <I
CLASS="filename"
>glossary</I
> file.</P
><P
CLASS="para"
>Rule #1 tests to see if the current filename (the value of
<KBD
CLASS="command"
>FILENAME</KBD
>) is &quot;glossary&quot; and is therefore only
applied while reading input from this file.  This rule loads the
glossary entries into an array:</P
><P
CLASS="para"
><BLOCKQUOTE
CLASS="screen"
><PRE
CLASS="screen"
>entry[term] = definition</PRE
></BLOCKQUOTE
></P
><P
CLASS="para"
>where $1 is the term and $2 is the definition.  The
<KBD
CLASS="command"
>next</KBD
> statement at the end of rule #1 is used to
skip other rules in the script and causes a new line of input to be
read.  So, until all the entries in the <I
CLASS="filename"
>glossary</I
>
file are read, no other rule is evaluated.</P
><P
CLASS="para"
>Once input from <I
CLASS="filename"
>glossary</I
> is exhausted, awk reads
from standard input because &quot;-&quot; is specified on the command line.
Standard input is where the user's response comes from.  Rule #3 tests
that the input line ($0) is not empty.  This rule should match
whatever the user types.  The action uses <KBD
CLASS="command"
>in</KBD
> to see
if the input line is an index in the array.  If it is, it simply
prints out the corresponding value. Otherwise, we tell the user that
no valid entry was found.</P
><P
CLASS="para"
>After rule #3, rule #4 will be evaluated.  This rule simply prompts
the user for another entry.  Note that regardless of whether a valid
entry was processed in rule #3, rule #4 is executed.  The prompt also
tells the user how to quit the program.  After this rule, awk looks
for the next line of input.</P
><P
CLASS="para"
>If the user chooses to quit by entering &quot;q&quot; as the next line of input,
rule #2 will be matched.  The pattern looks for a complete line
consisting of alternative words or single letters that the user might
enter to quit.  The &quot;^&quot; and &quot;$&quot; are important, signifying that the
input line contains no other characters but these; otherwise a &quot;q&quot;
appearing in a glossary entry would be matched.  Note that the
placement of this rule in the sequence of rules is significant.  It
must appear before rules #3 and #4 because these rules will match
anything, including the words &quot;quit&quot; and &quot;exit.&quot;</P
><P
CLASS="para"
>Let's look at how the program works.  For this example, we will make a
copy of the <I
CLASS="filename"
>acronyms</I
> file and use it as the
<I
CLASS="filename"
>glossary</I
> file.</P
><P
CLASS="para"
><BLOCKQUOTE
CLASS="screen"
><PRE
CLASS="screen"
>$ <CODE
CLASS="userinput"
><B
>cp acronyms glossary</B
></CODE
>
$ <CODE
CLASS="userinput"
><B
>lookup</B
></CODE
>
Enter a glossary term: <CODE
CLASS="userinput"
><B
>GIGO</B
></CODE
>
Garbage in, garbage out
Enter another glossary term (q to quit): <CODE
CLASS="userinput"
><B
>BASIC</B
></CODE
>
Beginner's All-Purpose Symbolic Instruction Code
Enter another glossary term (q to quit): <CODE
CLASS="userinput"
><B
>q </B
></CODE
></PRE
></BLOCKQUOTE
></P
><P
CLASS="para"
>As you can see, the program is set up to prompt the user for
additional items until the user enters &quot;q&quot;.</P
><P
CLASS="para"
>Note that this program can be easily revised to read a glossary
anywhere on the file system, including the user's home directory.  The
shell script that invokes awk could handle command-line options that
allow the user to specify the glossary filename.  You could also read
a shared glossary file and then read a local one by writing separate
rules to process the entries.</P
></DIV
><DIV
CLASS="sect2"
><H3
CLASS="sect2"
><A
CLASS="title"
NAME="SEDAWK-CH-8-SECT-4.4"
>8.4.4 Using split() to Create Arrays</A
></H3
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-6890"
></A
><A
CLASS="indexterm"
NAME="AUTOID-6892"
></A
><A
CLASS="indexterm"
NAME="AUTOID-6895"
></A
><A
CLASS="indexterm"
NAME="AUTOID-6898"
></A
>The built-in function <KBD
CLASS="command"
>split()</KBD
> can parse any
string into elements of an array.  This function can be useful to
extract &quot;subfields&quot; from a field.  The syntax of the
<KBD
CLASS="command"
>split()</KBD
> function is:</P
><BLOCKQUOTE
CLASS="literallayout"
><P
CLASS="literallayout"
><CODE
CLASS="literal"
>n = split</CODE
>(<CODE
CLASS="replaceable"
><I
>string</I
></CODE
>, <CODE
CLASS="replaceable"
><I
>array</I
></CODE
>, <CODE
CLASS="replaceable"
><I
>separator</I
></CODE
>)</P
></BLOCKQUOTE
><P
CLASS="para"
><EM
CLASS="emphasis"
>string</EM
> is the input string to be parsed
into elements of the named <EM
CLASS="emphasis"
>array</EM
>.  The
array's indices start at 1 and go to <CODE
CLASS="replaceable"
><I
>n</I
></CODE
>, the
number of elements in the array.  The elements will be split based on
the specified <EM
CLASS="emphasis"
>separator</EM
> character.  If a
separator is not specified, then the field separator
(<KBD
CLASS="command"
>FS</KBD
>) is used.  The
<EM
CLASS="emphasis"
>separator</EM
> can be a full regular expression,
not just a single character.  Array splitting behaves identically to
field splitting; see the section &quot;Referencing and Separating Fields&quot; in Chapter 7.</P
><P
CLASS="para"
>For example, if you had a record in which the first field consisted of
the person's full name, you could use the
<KBD
CLASS="command"
>split()</KBD
> function to extract the person's
first and last names.  The following statement breaks up the first
field into elements of the array <KBD
CLASS="command"
>fullname</KBD
>:</P
><P
CLASS="para"
><BLOCKQUOTE
CLASS="screen"
><PRE
CLASS="screen"
>z = split($1, fullname, &quot; &quot;)</PRE
></BLOCKQUOTE
></P
><P
CLASS="para"
>A space is specified as the delimiter.  The person's first name
can be referenced as:</P
><P
CLASS="para"
><BLOCKQUOTE
CLASS="screen"
><PRE
CLASS="screen"
>fullname[1]</PRE
></BLOCKQUOTE
></P
><P
CLASS="para"
>and the person's last name can be referenced as:</P
><P
CLASS="para"
><BLOCKQUOTE
CLASS="screen"
><PRE
CLASS="screen"
>fullname[z]</PRE
></BLOCKQUOTE
></P
><P
CLASS="para"
>because <KBD
CLASS="command"
>z</KBD
> contains the number of elements in the
array.  This works, regardless of whether the person's full name
contains a middle name.  If <KBD
CLASS="command"
>z</KBD
> is the value returned
by <KBD
CLASS="command"
>split()</KBD
>, you can write a loop to read
all the elements of this array.</P
><P
CLASS="para"
><BLOCKQUOTE
CLASS="screen"
><PRE
CLASS="screen"
>z = split($1, array, &quot; &quot;)
for (i = 1; i &lt;= z; ++i)
	print i, array[i]</PRE
></BLOCKQUOTE
></P
><P
CLASS="para"
>The next section contains additional examples of using the
<KBD
CLASS="command"
>split()</KBD
> function.</P
></DIV
><DIV
CLASS="sect2"
><H3
CLASS="sect2"
><A
CLASS="title"
NAME="SEDAWK-CH-8-SECT-4.5"
>8.4.5 Making Conversions</A
></H3
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="CH08.CONV"
></A
>This section looks at two examples that demonstrate similar methods of
converting output from one format to another.</P
><P
CLASS="para"
>When working on the index program shown in 
<A
CLASS="xref"
HREF="ch12_01.htm"
TITLE="Full-Featured Applications"
>Chapter 12, Full-Featured Applications</A
>, we needed a quick way to assign roman
numerals to volume numbers.  In other words, volume 4 needed to be
identified as &quot;IV&quot; in the index.  Since there was no immediate
prospect of the number of volumes exceeding 10, we wrote a script that
took as input a number between 1 and 10 and converted it to a roman
numeral.</P
><P
CLASS="para"
>This shell script takes the first argument from the command
line and echoes it as input to the awk program.</P
><P
CLASS="para"
><BLOCKQUOTE
CLASS="screen"
><PRE
CLASS="screen"
>echo $1 | 
awk '# romanum -- convert number 1-10 to roman numeral

# define numerals as list of roman numerals 1-10
BEGIN { 
	# create array named numerals from list of roman numerals
	split(&quot;I,II,III,IV,V,VI,VII,VIII,IX,X&quot;, numerals, &quot;,&quot;)
}

# look for number between 1 and 10
$1 &gt; 0 &amp;&amp; $1 &lt;= 10 {
	# print specified element
	print numerals[$1]
	exit
}

{ 	print &quot;invalid number&quot;
  	exit
}'</PRE
></BLOCKQUOTE
></P
><P
CLASS="para"
>This script defines a list of 10 roman numerals, then uses
<KBD
CLASS="command"
>split()</KBD
> to load them into an array named
<KBD
CLASS="command"
>numerals</KBD
>.  This is done in the
<KBD
CLASS="command"
>BEGIN</KBD
> action because it only needs to be done once.</P
><P
CLASS="para"
>The second rule checks that the first field of the input line contains
a number between 1 and 10.  If it does, this number is used as the
index to the <KBD
CLASS="command"
>numerals</KBD
> array, retrieving the
corresponding element.  The <KBD
CLASS="command"
>exit</KBD
> statement
terminates the program.  The last rule is executed only if there is no
valid entry.</P
><P
CLASS="para"
>Here's an example of how it works:</P
><P
CLASS="para"
><BLOCKQUOTE
CLASS="screen"
><PRE
CLASS="screen"
>$ <CODE
CLASS="userinput"
><B
>romanum 4</B
></CODE
>
IV</PRE
></BLOCKQUOTE
></P
><P
CLASS="para"
>Following along on the same idea, here's a script that converts dates
in the form &quot;mm-dd-yy&quot; or &quot;mm/dd/yy&quot; to &quot;month day, year.&quot;</P
><P
CLASS="para"
><BLOCKQUOTE
CLASS="screen"
><PRE
CLASS="screen"
>awk '
# date-month -- convert mm/dd/yy or mm-dd-yy to month day, year

# build list of months and put in array. 
BEGIN { 
	# the 3-step assignment is done for printing in book
	listmonths = &quot;January,February,March,April,May,June,&quot;
	listmonths = listmonths &quot;July,August,September,&quot;
	listmonths = listmonths &quot;October,November,December&quot; 
	split(listmonths, month, &quot;,&quot;)
}

# check that there is input
$1 != &quot;&quot; {

# split on &quot;/&quot; the first input field into elements of array
	sizeOfArray = split($1, date, &quot;/&quot;)

# check that only one field is returned
	if (sizeOfArray == 1)
		# try to split on &quot;-&quot;
		sizeOfArray = split($1, date, &quot;-&quot;)

# must be invalid
	if (sizeOfArray == 1)
		exit

# add 0 to number of month to coerce numeric type 
	date[1] += 0

# print month day, year
	print month[date[1]], (date[2] &quot;, 19&quot; date[3])
}'</PRE
></BLOCKQUOTE
></P
><P
CLASS="para"
>This script reads from standard input.  The <KBD
CLASS="command"
>BEGIN</KBD
>
action creates an array named <KBD
CLASS="command"
>month</KBD
> whose elements
are the names of the months of the year.  The second rule verifies
that we have a non-empty input line.  The first statement in the
associated action splits the first field of input looking for
&quot;/&quot; as the delimiter.  <KBD
CLASS="command"
>sizeOfArray</KBD
> contains
the number of elements in the array.  If awk was unable to parse the
string, it creates the array with only one element.  Thus, we can test
the value of <KBD
CLASS="command"
>sizeOfArray</KBD
> to determine if we have
several elements.  If we do not, we assume that perhaps &quot;-&quot; was used
as the delimiter.  If that fails to produce an array with multiple
elements, we assume the input is invalid, and exit.  If we have
successfully parsed the input, <KBD
CLASS="command"
>date[1]</KBD
> contains the
number of the month.  This value can be used as the index to the array
<KBD
CLASS="command"
>month</KBD
>, nesting one array inside another.  However,
before using <KBD
CLASS="command"
>date[1]</KBD
>, we coerce the type of
<KBD
CLASS="command"
>date[1]</KBD
> by adding 0 to it.  While awk will
correctly interpret &quot;11&quot; as a number, leading zeros may cause a number
to be treated as a string.  Thus, &quot;06&quot; might not be recognized properly
without type coercion. The element referenced by
<KBD
CLASS="command"
>date[1]</KBD
> is used as the subscript for
<KBD
CLASS="command"
>month</KBD
>.</P
><P
CLASS="para"
>Here's a sample run:</P
><P
CLASS="para"
><BLOCKQUOTE
CLASS="screen"
><PRE
CLASS="screen"
>$ <CODE
CLASS="userinput"
><B
>echo &quot;5/11/55&quot; | date-month</B
></CODE
>
May 11, 1955</PRE
></BLOCKQUOTE
></P
><A
CLASS="indexterm"
NAME="AUTOID-6973"
></A
></DIV
><DIV
CLASS="sect2"
><H3
CLASS="sect2"
><A
CLASS="title"
NAME="SEDAWK-CH-8-SECT-4.6"
>8.4.6 Deleting Elements of an Array</A
></H3
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-6977"
></A
><A
CLASS="indexterm"
NAME="AUTOID-6980"
></A
><A
CLASS="indexterm"
NAME="AUTOID-6982"
></A
>Awk provides a statement for deleting an element of an array.  The
syntax is:</P
><BLOCKQUOTE
CLASS="literallayout"
><P
CLASS="literallayout"
><KBD
CLASS="command"
>delete</KBD
> <CODE
CLASS="replaceable"
><I
>array</I
></CODE
>[<CODE
CLASS="replaceable"
><I
>subscript</I
></CODE
>]</P
></BLOCKQUOTE
><P
CLASS="para"
>The brackets are required.  This statement removes the element indexed
by <EM
CLASS="emphasis"
>subscript</EM
> from
<EM
CLASS="emphasis"
>array</EM
>. In particular, the
<KBD
CLASS="command"
>in</KBD
> test for <EM
CLASS="emphasis"
>subscript</EM
>
will now return false.  This is different than just assigning the
empty string to that element; in that case <KBD
CLASS="command"
>in</KBD
> would
still be true.  See the <KBD
CLASS="command"
>lotto</KBD
> script in the next
chapter for an example of using the <KBD
CLASS="command"
>delete</KBD
>
statement.</P
></DIV
><A
CLASS="indexterm"
NAME="AUTOID-6997"
></A
></DIV
><DIV
CLASS="htmlnav"
><P
></P
><HR
ALIGN="LEFT"
WIDTH="515"
TITLE="footer"><TABLE
WIDTH="515"
BORDER="0"
CELLSPACING="0"
CELLPADDING="0"
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="172"
><A
CLASS="SECT1"
HREF="ch08_03.htm"
TITLE="8.3 Other Statements That Affect Flow Control"
><IMG
SRC="../gifs/txtpreva.gif"
ALT="Previous: 8.3 Other Statements That Affect Flow Control"
BORDER="0"></A
></TD
><TD
ALIGN="CENTER"
VALIGN="TOP"
WIDTH="171"
><A
CLASS="book"
HREF="index.htm"
TITLE="sed &amp; awk"
><IMG
SRC="../gifs/txthome.gif"
ALT="sed &amp; awk"
BORDER="0"></A
></TD
><TD
ALIGN="RIGHT"
VALIGN="TOP"
WIDTH="172"
><A
CLASS="SECT1"
HREF="ch08_05.htm"
TITLE="8.5 An Acronym Processor"
><IMG
SRC="../gifs/txtnexta.gif"
ALT="Next: 8.5 An Acronym Processor"
BORDER="0"></A
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="172"
>8.3 Other Statements That Affect Flow Control</TD
><TD
ALIGN="CENTER"
VALIGN="TOP"
WIDTH="171"
><A
CLASS="index"
HREF="index/idx_0.htm"
TITLE="Book Index"
><IMG
SRC="../gifs/index.gif"
ALT="Book Index"
BORDER="0"></A
></TD
><TD
ALIGN="RIGHT"
VALIGN="TOP"
WIDTH="172"
>8.5 An Acronym Processor</TD
></TR
></TABLE
><HR
ALIGN="LEFT"
WIDTH="515"
TITLE="footer"><IMG
SRC="../gifs/smnavbar.gif"
USEMAP="#map"
BORDER="0"
ALT="The UNIX CD Bookshelf Navigation"><MAP
NAME="map"
><AREA
SHAPE="RECT"
COORDS="0,0,73,21"
HREF="../index.htm"
ALT="The UNIX CD Bookshelf"><AREA
SHAPE="RECT"
COORDS="74,0,163,21"
HREF="../upt/index.htm"
ALT="UNIX Power Tools"><AREA
SHAPE="RECT"
COORDS="164,0,257,21"
HREF="../unixnut/index.htm"
ALT="UNIX in a Nutshell"><AREA
SHAPE="RECT"
COORDS="258,0,321,21"
HREF="../vi/index.htm"
ALT="Learning the vi Editor"><AREA
SHAPE="RECT"
COORDS="322,0,378,21"
HREF="index.htm"
ALT="sed &amp; awk"><AREA
SHAPE="RECT"
COORDS="379,0,438,21"
HREF="../ksh/index.htm"
ALT="Learning the Korn Shell"><AREA
SHAPE="RECT"
COORDS="439,0,514,21"
HREF="../lrnunix/index.htm"
ALT="Learning the UNIX Operating System"></MAP
></DIV
></BODY
></HTML
>
