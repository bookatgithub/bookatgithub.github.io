<HTML
><HEAD
>
<TITLE>[Chapter 8] 8.5 An Acronym Processor</TITLE>
<META
NAME="DC.title"
CONTENT="sed &amp; awk"><META
NAME="DC.creator"
CONTENT="Dale Dougherty &amp; Arnold Robbins"><META
NAME="DC.publisher"
CONTENT="O'Reilly &amp; Associates, Inc."><META
NAME="DC.date"
CONTENT="1998-08-03T20:59:26Z"><META
NAME="DC.type"
CONTENT="Text.Monograph"><META
NAME="DC.format"
CONTENT="text/html"
SCHEME="MIME"><META
NAME="DC.source"
CONTENT="1-56592-225-5"
SCHEME="ISBN"><META
NAME="DC.language"
CONTENT="en-US"><META
NAME="generator"
CONTENT="Jade 1.1/O'Reilly DocBook 3.0 to HTML 4.0"><LINK
REV="made"
HREF="mailto:online-books@oreilly.com"
TITLE="Online Books Comments"><LINK
REL="up"
HREF="ch08_01.htm"
TITLE="8. Conditionals, Loops, and Arrays"><LINK
REL="prev"
HREF="ch08_04.htm"
TITLE="8.4 Arrays"><LINK
REL="next"
HREF="ch08_06.htm"
TITLE="8.6 System Variables That Are Arrays"></HEAD
><BODY
BGCOLOR="#FFFFFF"
TEXT="#000000"
><DIV
CLASS="htmlnav"
><H1
><IMG
SRC="gifs/smbanner.gif"
ALT="sed &amp; awk"
USEMAP="#srchmap"
BORDER="0"></H1
><MAP
NAME="srchmap"
><AREA
SHAPE="RECT"
COORDS="0,0,466,65"
HREF="index.htm"
ALT="sed &amp; awk"><AREA
SHAPE="RECT"
COORDS="467,0,514,18"
HREF="../search/ssrch.htm"
ALT="Search this book"></MAP
><TABLE
WIDTH="515"
BORDER="0"
CELLSPACING="0"
CELLPADDING="0"
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="172"
><A
CLASS="SECT1"
HREF="ch08_04.htm"
TITLE="8.4 Arrays"
><IMG
SRC="../gifs/txtpreva.gif"
ALT="Previous: 8.4 Arrays"
BORDER="0"></A
></TD
><TD
ALIGN="CENTER"
VALIGN="TOP"
WIDTH="171"
><B
><FONT
FACE="ARIEL,HELVETICA,HELV,SANSERIF"
SIZE="-1"
>Chapter 8<BR>Conditionals, Loops, and Arrays</FONT
></B
></TD
><TD
ALIGN="RIGHT"
VALIGN="TOP"
WIDTH="172"
><A
CLASS="SECT1"
HREF="ch08_06.htm"
TITLE="8.6 System Variables That Are Arrays"
><IMG
SRC="../gifs/txtnexta.gif"
ALT="Next: 8.6 System Variables That Are Arrays"
BORDER="0"></A
></TD
></TR
></TABLE
>&nbsp;<HR
ALIGN="LEFT"
WIDTH="515"
TITLE="footer"></DIV
><DIV
CLASS="SECT1"
><H2
CLASS="sect1"
><A
CLASS="title"
NAME="SEDAWK-CH-8-SECT-5"
>8.5 An Acronym Processor</A
></H2
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="CH08.ACRO1"
></A
><A
CLASS="indexterm"
NAME="CH08.ACRO2"
></A
>Now let's look at a program that scans a file for acronyms.  Each
acronym is replaced with a full text description, and the acronym in
parentheses.  If a line refers to &quot;BASIC,&quot; we'd like to replace it
with the description &quot;Beginner's All-Purpose Symbolic Instruction
Code&quot; and put the acronym in parentheses afterwards.  (This is probably not
a useful program in and of itself, but the techniques used in the
program are general and have many such uses.)</P
><P
CLASS="para"
>We can design this program for use as a <EM
CLASS="emphasis"
>filter</EM
>
that prints all lines, regardless of whether a change has been made.
We'll call it <KBD
CLASS="command"
>awkro</KBD
>.</P
><P
CLASS="para"
><BLOCKQUOTE
CLASS="screen"
><PRE
CLASS="screen"
>awk '# awkro - expand acronyms 
# load acronyms file into array &quot;acro&quot;
FILENAME == &quot;acronyms&quot; {
	split($0, entry, &quot;\t&quot;)
	acro[entry[1]] = entry[2]
	next
} 

# process any input line containing caps 
/[A-Z][A-Z]+/ {
	# see if any field is an acronym
	for (i = 1; i &lt;= NF; i++)
		if ( $i in acro ) {
			# if it matches, add description 
			$i = acro[$i] &quot; (&quot; $i &quot;)&quot;
		}
}

{
	# print all lines
	print $0
}' acronyms  $*</PRE
></BLOCKQUOTE
></P
><P
CLASS="para"
>Let's first see it in action.  Here's a sample input file.</P
><P
CLASS="para"
><BLOCKQUOTE
CLASS="screen"
><PRE
CLASS="screen"
>$ <CODE
CLASS="userinput"
><B
>cat sample</B
></CODE
>
The USGCRP is a comprehensive 
research effort that includes applied 
as well as basic research.
The NASA program Mission to Planet Earth 
represents the principal space-based component
of the USGCRP and includes new initiatives
such as EOS and Earthprobes.</PRE
></BLOCKQUOTE
></P
><P
CLASS="para"
>And here is the file <EM
CLASS="emphasis"
>acronyms</EM
>:</P
><P
CLASS="para"
><BLOCKQUOTE
CLASS="screen"
><PRE
CLASS="screen"
>$ <CODE
CLASS="userinput"
><B
>cat acronyms</B
></CODE
>
USGCRP	U.S. Global Change Research Program
NASA	National Aeronautic and Space Administration
EOS	Earth Observing System</PRE
></BLOCKQUOTE
></P
><P
CLASS="para"
>Now we run the program on the sample file.</P
><P
CLASS="para"
><BLOCKQUOTE
CLASS="screen"
><PRE
CLASS="screen"
>$ <CODE
CLASS="userinput"
><B
>awkro sample</B
></CODE
>
The U.S. Global Change Research Program (USGCRP) is a comprehensive
research effort that includes applied
as well as basic research.
The National Aeronautic and Space Administration (NASA) program
Mission to Planet Earth
represents the principal space-based component
of the U.S. Global Change Research Program (USGCRP) and includes new
initiatives
such as Earth Observing System (EOS) and Earthprobes.</PRE
></BLOCKQUOTE
></P
><P
CLASS="para"
>We'll look at this program in two parts.  The first part reads records
from the <I
CLASS="filename"
>acronyms</I
> file.</P
><P
CLASS="para"
><BLOCKQUOTE
CLASS="screen"
><PRE
CLASS="screen"
># load acronyms file into array &quot;acro&quot;
FILENAME == &quot;acronyms&quot; {
	split($0, entry, &quot;\t&quot;)
	acro[entry[1]] = entry[2]
	next
}</PRE
></BLOCKQUOTE
></P
><P
CLASS="para"
>The two fields from these records are loaded into an array using the
first field as the subscript and assigning the second field to an
element of the array.  In other words, the acronym itself is the index
to its description.</P
><P
CLASS="para"
>Note that we did not change the field separator, but instead used the
<KBD
CLASS="command"
>split()</KBD
> function to create the array
<KBD
CLASS="command"
>entry</KBD
>.  This array is then used in creating an
array named <KBD
CLASS="command"
>acro</KBD
>.</P
><P
CLASS="para"
>Here is the second half of the program:</P
><P
CLASS="para"
><BLOCKQUOTE
CLASS="screen"
><PRE
CLASS="screen"
># process any input line containing caps 
/[A-Z][A-Z]+/ {
	# see if any field is an acronym
	for (i = 1; i &lt;= NF; i++)
		if ( $i in acro ) {
			# if it matches, add description 
			$i = acro[$i] &quot; (&quot; $i &quot;)&quot;
		}
}

{
	# print all lines
	print $0
}</PRE
></BLOCKQUOTE
></P
><P
CLASS="para"
>Only lines that contain more than one consecutive capital letter are
processed by the first of the two actions shown here.  This action
loops through each field of the record.  At the heart of this section
is the conditional statement that tests if the current field
(<KBD
CLASS="command"
>$i</KBD
>) is a subscript of the array
(<KBD
CLASS="command"
>acro</KBD
>).  If the field is a subscript, we replace
the original value of the field with the array element and the
original value in parentheses.  (Fields can be assigned new values,
just like regular variables.)  Note that the insertion of the
description of the acronym results in lines that may be too long.  See
the next chapter for a discussion of the
<KBD
CLASS="command"
>length()</KBD
> function, which can be used to
determine the length of a string so you can divide it up if it is too
long.</P
><P
CLASS="para"
>Now we're going to change the program so it makes a replacement only
the first time an acronym appears.  After we've found it, we don't
want to search for that acronym any more.  This is easy to do; we
simply delete that acronym from the array.</P
><P
CLASS="para"
><BLOCKQUOTE
CLASS="screen"
><PRE
CLASS="screen"
>if ( $i in acro ) {
	# if it matches, add description 
	$i = acro[$i] &quot; (&quot; $i &quot;)&quot;
	# only expand the acronym once
	delete acro[acronym]
}</PRE
></BLOCKQUOTE
></P
><P
CLASS="para"
>There are other changes that would be good to make.  In running the
<KBD
CLASS="command"
>awkro</KBD
> program, we
soon discovered that it failed to
match the acronym if it was followed by a punctuation mark. Our
initial solution was not to handle it in awk at all. Instead, we used
two sed scripts, one before processing:</P
><P
CLASS="para"
><BLOCKQUOTE
CLASS="screen"
><PRE
CLASS="screen"
>sed 's/\([^.,;:!][^.,;:!]*\)\([.,;:!]\)/\1 @@@\2/g'</PRE
></BLOCKQUOTE
></P
><P
CLASS="para"
>and one after:</P
><P
CLASS="para"
><BLOCKQUOTE
CLASS="screen"
><PRE
CLASS="screen"
>sed 's/ @@@\([.,;:!]\)/\1/g'</PRE
></BLOCKQUOTE
></P
><P
CLASS="para"
>A sed script, run prior to invoking awk, could simply insert a
space before any punctuation mark, causing it to be interpreted as a
separate field.  A string of garbage characters
(<KBD
CLASS="command"
>@@@</KBD
>) was also added so we'd be able to easily
identify and restore the punctuation mark.  (The complicated
expression used in the first sed command makes sure that we catch the
case of more than one punctuation mark on a line.)</P
><P
CLASS="para"
>This kind of solution, using another tool in the UNIX toolbox,
demonstrates that not everything needs to be done as an awk procedure.
Awk is all the more valuable because it is situated in the UNIX
environment.</P
><P
CLASS="para"
>However, with POSIX awk, we can implement a different solution, one
that uses a regular expression to match the acronym.  Such a solution
can be implemented with the <KBD
CLASS="command"
>match()</KBD
> and
<KBD
CLASS="command"
>sub()</KBD
> functions described in the next
chapter.</P
><DIV
CLASS="sect2"
><H3
CLASS="sect2"
><A
CLASS="title"
NAME="SEDAWK-CH-8-SECT-5.1"
>8.5.1 Multidimensional Arrays</A
></H3
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="CH08.MULTI"
></A
><A
CLASS="indexterm"
NAME="CH08.MULTI2"
></A
>Awk supports linear arrays in which the index to each element of the
array is a single subscript.  If you imagine a linear array as a row
of numbers, a two-dimensional array represents rows and columns of
numbers.  You might refer to the element in the second column of the
third row as &quot;array[3, 2].&quot;  Two- and three-dimensional
arrays are examples of multidimensional arrays.  Awk does not support
multidimensional arrays but instead offers a syntax for subscripts
that simulate a reference to a multidimensional array.
For instance, you could write the following expression:</P
><P
CLASS="para"
><BLOCKQUOTE
CLASS="screen"
><PRE
CLASS="screen"
>file_array[NR, i] = $i</PRE
></BLOCKQUOTE
></P
><P
CLASS="para"
>where each field of an input record is indexed by its record number
and field number.  Thus, the following reference:</P
><P
CLASS="para"
><BLOCKQUOTE
CLASS="screen"
><PRE
CLASS="screen"
>file_array[2, 4]</PRE
></BLOCKQUOTE
></P
><P
CLASS="para"
>would produce the value of the fourth field of the second record.</P
><P
CLASS="para"
>This syntax does not create a multidimensional array.  It is
converted into a string that uniquely identifies the element in a
linear array.  The components of a multidimensional subscript are
interpreted as individual strings (&quot;2&quot; and &quot;4,&quot; for instance) and
concatenated together separated by the value of the system variable<A
CLASS="indexterm"
NAME="AUTOID-7071"
></A
><A
CLASS="indexterm"
NAME="AUTOID-7073"
></A
>
<KBD
CLASS="command"
>SUBSEP</KBD
>.  The subscript-component separator is
defined as
<CODE
CLASS="literal"
>&quot;</CODE
><B
CLASS="emphasis.bold"
>\034</B
><CODE
CLASS="literal"
>&quot;</CODE
>
by default, 
an unprintable character rarely
found in ASCII text.  Thus, awk maintains a one-dimensional array and
the subscript for our previous example would actually
be <CODE
CLASS="literal"
>&quot;</CODE
>2\0344<CODE
CLASS="literal"
>&quot;</CODE
> (the
concatenation of &quot;<KBD
CLASS="command"
>2</KBD
>,&quot; the value of
<KBD
CLASS="command"
>SUBSEP</KBD
>, and &quot;<KBD
CLASS="command"
>4</KBD
>&quot;).  The main
consequence of this simulation of multidimensional arrays is that the
larger the array, the slower it is to access individual elements.
However, you should time this, using your own application, with
different awk implementations (see <A
CLASS="xref"
HREF="ch11_01.htm"
TITLE="A Flock of awks"
>Chapter 11, A Flock of awks</A
>).</P
><P
CLASS="para"
>Here is a sample awk script named <KBD
CLASS="command"
>bitmap.awk</KBD
> that
shows how to load and output the elements of a multidimensional
array.  This array represents a two-dimensional bitmap that is 12
characters in width and height.</P
><P
CLASS="para"
><BLOCKQUOTE
CLASS="screen"
><PRE
CLASS="screen"
>BEGIN { FS = &quot;,&quot;   # comma-separated fields
	# assign width and height of bitmap
	WIDTH = 12
	HEIGHT = 12
	# loop to load entire array with &quot;O&quot;
	for (i = 1; i &lt;= WIDTH; ++i)
		for (j = 1; j &lt;= HEIGHT; ++j)
			bitmap[i, j] = &quot;O&quot;
}
# read input of the form x,y. 
{
	# assign &quot;X&quot; to that element of array 
	bitmap[$1, $2] = &quot;X&quot;
}
# at end output multidimensional array
END {
	for (i = 1; i &lt;= WIDTH; ++i){
		for (j = 1; j &lt;= HEIGHT; ++j)
			printf(&quot;%s&quot;, bitmap[i, j] )
		# after each row, print newline
		printf(&quot;\n&quot;)	
	}
}</PRE
></BLOCKQUOTE
></P
><P
CLASS="para"
>Before any input is read, the <KBD
CLASS="command"
>bitmap</KBD
> array is
loaded with O's.  This array has 144 elements.  The input to this
program is a series of coordinates, one per line.</P
><P
CLASS="para"
><BLOCKQUOTE
CLASS="screen"
><PRE
CLASS="screen"
>$ <CODE
CLASS="userinput"
><B
>cat bitmap.test</B
></CODE
>
1,1
2,2
3,3
4,4
5,5
6,6
7,7
8,8
9,9
10,10
11,11
12,12
1,12
2,11
3,10
4,9
5,8
6,7
7,6
8,5
9,4
10,3
11,2
12,1</PRE
></BLOCKQUOTE
></P
><P
CLASS="para"
>For each coordinate, the program will put an &quot;X&quot; in place of an &quot;O&quot; as
that element of the array. At the end of the script, the same kind of
loop that loaded the array, now outputs it. The following example
reads the input from the file <I
CLASS="filename"
>bitmap.test</I
>.</P
><P
CLASS="para"
><BLOCKQUOTE
CLASS="screen"
><PRE
CLASS="screen"
>$ <CODE
CLASS="userinput"
><B
>awk -f bitmap.awk bitmap.test</B
></CODE
>
XOOOOOOOOOOX
OXOOOOOOOOXO
OOXOOOOOOXOO
OOOXOOOOXOOO
OOOOXOOXOOOO
OOOOOXXOOOOO
OOOOOXXOOOOO
OOOOXOOXOOOO
OOOXOOOOXOOO
OOXOOOOOOXOO
OXOOOOOOOOXO
XOOOOOOOOOOX</PRE
></BLOCKQUOTE
></P
><P
CLASS="para"
>The multidimensional array syntax is also supported in testing for
array membership.  The subscripts must be placed inside parentheses.</P
><P
CLASS="para"
><BLOCKQUOTE
CLASS="screen"
><PRE
CLASS="screen"
>if ((i, j) in array)</PRE
></BLOCKQUOTE
></P
><P
CLASS="para"
>This tests whether the subscript <KBD
CLASS="command"
>i,j</KBD
> (actually,
<KBD
CLASS="command"
>i SUBSEP j</KBD
>) exists in the specified array.</P
><P
CLASS="para"
>Looping over a multidimensional array is the same as with
one-dimensional arrays. </P
><P
CLASS="para"
><BLOCKQUOTE
CLASS="screen"
><PRE
CLASS="screen"
>for (item in array)</PRE
></BLOCKQUOTE
></P
><P
CLASS="para"
>You must use the <KBD
CLASS="command"
>split()</KBD
> function to access
individual subscript components.  Thus:</P
><P
CLASS="para"
><BLOCKQUOTE
CLASS="screen"
><PRE
CLASS="screen"
>split(item, subscr, SUBSEP)</PRE
></BLOCKQUOTE
></P
><P
CLASS="para"
>creates the array <KBD
CLASS="command"
>subscr</KBD
> from the subscript
<KBD
CLASS="command"
>item</KBD
>.</P
><P
CLASS="para"
>Note that we needed to use the loop-within-a-loop to output the 
two-dimensional bitmap array in the previous example because
we needed to maintain rows and columns.</P
><A
CLASS="indexterm"
NAME="AUTOID-7117"
></A
><A
CLASS="indexterm"
NAME="AUTOID-7118"
></A
></DIV
><A
CLASS="indexterm"
NAME="AUTOID-7119"
></A
><A
CLASS="indexterm"
NAME="AUTOID-7120"
></A
></DIV
><DIV
CLASS="htmlnav"
><P
></P
><HR
ALIGN="LEFT"
WIDTH="515"
TITLE="footer"><TABLE
WIDTH="515"
BORDER="0"
CELLSPACING="0"
CELLPADDING="0"
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="172"
><A
CLASS="SECT1"
HREF="ch08_04.htm"
TITLE="8.4 Arrays"
><IMG
SRC="../gifs/txtpreva.gif"
ALT="Previous: 8.4 Arrays"
BORDER="0"></A
></TD
><TD
ALIGN="CENTER"
VALIGN="TOP"
WIDTH="171"
><A
CLASS="book"
HREF="index.htm"
TITLE="sed &amp; awk"
><IMG
SRC="../gifs/txthome.gif"
ALT="sed &amp; awk"
BORDER="0"></A
></TD
><TD
ALIGN="RIGHT"
VALIGN="TOP"
WIDTH="172"
><A
CLASS="SECT1"
HREF="ch08_06.htm"
TITLE="8.6 System Variables That Are Arrays"
><IMG
SRC="../gifs/txtnexta.gif"
ALT="Next: 8.6 System Variables That Are Arrays"
BORDER="0"></A
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="172"
>8.4 Arrays</TD
><TD
ALIGN="CENTER"
VALIGN="TOP"
WIDTH="171"
><A
CLASS="index"
HREF="index/idx_0.htm"
TITLE="Book Index"
><IMG
SRC="../gifs/index.gif"
ALT="Book Index"
BORDER="0"></A
></TD
><TD
ALIGN="RIGHT"
VALIGN="TOP"
WIDTH="172"
>8.6 System Variables That Are Arrays</TD
></TR
></TABLE
><HR
ALIGN="LEFT"
WIDTH="515"
TITLE="footer"><IMG
SRC="../gifs/smnavbar.gif"
USEMAP="#map"
BORDER="0"
ALT="The UNIX CD Bookshelf Navigation"><MAP
NAME="map"
><AREA
SHAPE="RECT"
COORDS="0,0,73,21"
HREF="../index.htm"
ALT="The UNIX CD Bookshelf"><AREA
SHAPE="RECT"
COORDS="74,0,163,21"
HREF="../upt/index.htm"
ALT="UNIX Power Tools"><AREA
SHAPE="RECT"
COORDS="164,0,257,21"
HREF="../unixnut/index.htm"
ALT="UNIX in a Nutshell"><AREA
SHAPE="RECT"
COORDS="258,0,321,21"
HREF="../vi/index.htm"
ALT="Learning the vi Editor"><AREA
SHAPE="RECT"
COORDS="322,0,378,21"
HREF="index.htm"
ALT="sed &amp; awk"><AREA
SHAPE="RECT"
COORDS="379,0,438,21"
HREF="../ksh/index.htm"
ALT="Learning the Korn Shell"><AREA
SHAPE="RECT"
COORDS="439,0,514,21"
HREF="../lrnunix/index.htm"
ALT="Learning the UNIX Operating System"></MAP
></DIV
></BODY
></HTML
>
