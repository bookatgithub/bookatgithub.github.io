<HTML
><HEAD
>
<TITLE>[Chapter 9] 9.2 String Functions</TITLE>
<META
NAME="DC.title"
CONTENT="sed &amp; awk"><META
NAME="DC.creator"
CONTENT="Dale Dougherty &amp; Arnold Robbins"><META
NAME="DC.publisher"
CONTENT="O'Reilly &amp; Associates, Inc."><META
NAME="DC.date"
CONTENT="1998-08-03T21:00:25Z"><META
NAME="DC.type"
CONTENT="Text.Monograph"><META
NAME="DC.format"
CONTENT="text/html"
SCHEME="MIME"><META
NAME="DC.source"
CONTENT="1-56592-225-5"
SCHEME="ISBN"><META
NAME="DC.language"
CONTENT="en-US"><META
NAME="generator"
CONTENT="Jade 1.1/O'Reilly DocBook 3.0 to HTML 4.0"><LINK
REV="made"
HREF="mailto:online-books@oreilly.com"
TITLE="Online Books Comments"><LINK
REL="up"
HREF="ch09_01.htm"
TITLE="9. Functions"><LINK
REL="prev"
HREF="ch09_01.htm"
TITLE="9.1 Arithmetic Functions"><LINK
REL="next"
HREF="ch09_03.htm"
TITLE="9.3 Writing Your Own Functions"></HEAD
><BODY
BGCOLOR="#FFFFFF"
TEXT="#000000"
><DIV
CLASS="htmlnav"
><H1
><IMG
SRC="gifs/smbanner.gif"
ALT="sed &amp; awk"
USEMAP="#srchmap"
BORDER="0"></H1
><MAP
NAME="srchmap"
><AREA
SHAPE="RECT"
COORDS="0,0,466,65"
HREF="index.htm"
ALT="sed &amp; awk"><AREA
SHAPE="RECT"
COORDS="467,0,514,18"
HREF="../search/ssrch.htm"
ALT="Search this book"></MAP
><TABLE
WIDTH="515"
BORDER="0"
CELLSPACING="0"
CELLPADDING="0"
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="172"
><A
CLASS="SECT1"
HREF="ch09_01.htm"
TITLE="9.1 Arithmetic Functions"
><IMG
SRC="../gifs/txtpreva.gif"
ALT="Previous: 9.1 Arithmetic Functions"
BORDER="0"></A
></TD
><TD
ALIGN="CENTER"
VALIGN="TOP"
WIDTH="171"
><B
><FONT
FACE="ARIEL,HELVETICA,HELV,SANSERIF"
SIZE="-1"
>Chapter 9<BR>Functions</FONT
></B
></TD
><TD
ALIGN="RIGHT"
VALIGN="TOP"
WIDTH="172"
><A
CLASS="SECT1"
HREF="ch09_03.htm"
TITLE="9.3 Writing Your Own Functions"
><IMG
SRC="../gifs/txtnexta.gif"
ALT="Next: 9.3 Writing Your Own Functions"
BORDER="0"></A
></TD
></TR
></TABLE
>&nbsp;<HR
ALIGN="LEFT"
WIDTH="515"
TITLE="footer"></DIV
><DIV
CLASS="SECT1"
><H2
CLASS="sect1"
><A
CLASS="title"
NAME="SEDAWK-CH-9-SECT-2"
>9.2 String Functions</A
></H2
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="CH09.FUN5"
></A
><A
CLASS="indexterm"
NAME="CH09.FUN6"
></A
>The built-in string functions are much more significant and
interesting than the numeric functions.  Because awk is essentially
designed as a string-processing language, a lot of its power
derives from these functions. 
<A
CLASS="xref"
HREF="ch09_02.htm#SEDAWK-CH-9-TAB-2"
TITLE="Awk's Built-In String Functions"
>Table 9.2</A
> lists the string functions found in awk.</P
><TABLE
CLASS="table"
><CAPTION
CLASS="table"
><A
CLASS="title"
NAME="SEDAWK-CH-9-TAB-2"
>Table 9.2: Awk's Built-In String Functions</A
></CAPTION
><THEAD
CLASS="thead"
><TR
CLASS="row"
VALIGN="TOP"
><TH
CLASS="entry"
ALIGN="LEFT"
ROWSPAN="1"
COLSPAN="1"
>Awk Function</TH
><TH
CLASS="entry"
ALIGN="LEFT"
ROWSPAN="1"
COLSPAN="1"
>Description</TH
></TR
></THEAD
><TBODY
CLASS="tbody"
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><KBD
CLASS="command"
>gsub</KBD
>(<EM
CLASS="emphasis"
>r</EM
>,<EM
CLASS="emphasis"
>s</EM
>,<EM
CLASS="emphasis"
>t</EM
>)</TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Globally substitutes <EM
CLASS="emphasis"
>s</EM
> for each match of the regular 
expression <EM
CLASS="emphasis"
>r</EM
> in the string <EM
CLASS="emphasis"
>t</EM
>.  Returns the number 
of substitutions.  If <EM
CLASS="emphasis"
>t</EM
> is not supplied, defaults to <B
CLASS="emphasis.bold"
>$0</B
>.<A
CLASS="indexterm"
NAME="AUTOID-7554"
></A
></P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><KBD
CLASS="command"
>index</KBD
>(<EM
CLASS="emphasis"
>s</EM
>,<EM
CLASS="emphasis"
>t</EM
>)</TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Returns position of substring <EM
CLASS="emphasis"
>t</EM
> in string <EM
CLASS="emphasis"
>s</EM
> or 
zero if not present.  <A
CLASS="indexterm"
NAME="AUTOID-7565"
></A
><A
CLASS="indexterm"
NAME="AUTOID-7567"
></A
></P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><KBD
CLASS="command"
>length</KBD
>(<EM
CLASS="emphasis"
>s</EM
>)</TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Returns length of string <EM
CLASS="emphasis"
>s</EM
> or length of <B
CLASS="emphasis.bold"
>$0</B
> 
if no string is supplied.<A
CLASS="indexterm"
NAME="AUTOID-7578"
></A
></P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><KBD
CLASS="command"
>match</KBD
>(<EM
CLASS="emphasis"
>s</EM
>,<EM
CLASS="emphasis"
>r</EM
>)</TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Returns either the position in <EM
CLASS="emphasis"
>s</EM
> where the regular expression
<EM
CLASS="emphasis"
>r</EM
> begins, or 0 if no occurrences are found.  Sets the values
of <B
CLASS="emphasis.bold"
>RSTART</B
> and <B
CLASS="emphasis.bold"
>RLENGTH</B
>.<A
CLASS="indexterm"
NAME="AUTOID-7591"
></A
></P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><KBD
CLASS="command"
>split</KBD
>(<EM
CLASS="emphasis"
>s</EM
>,<EM
CLASS="emphasis"
>a</EM
>,<EM
CLASS="emphasis"
>sep</EM
>)</TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Parses string <EM
CLASS="emphasis"
>s</EM
> into elements of array <EM
CLASS="emphasis"
>a</EM
>
using field separator <EM
CLASS="emphasis"
>sep</EM
>; returns number of elements.  
If <EM
CLASS="emphasis"
>sep</EM
> is not supplied, <B
CLASS="emphasis.bold"
>FS</B
> is used.
Array splitting works the same way as field splitting.<A
CLASS="indexterm"
NAME="AUTOID-7606"
></A
></P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><KBD
CLASS="command"
>sprintf</KBD
>(&quot;<EM
CLASS="emphasis"
>fmt</EM
>&quot;,<EM
CLASS="emphasis"
>expr</EM
>)</TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Uses <KBD
CLASS="command"
>printf</KBD
> format specification for <B
CLASS="emphasis.bold"
>expr</B
>.<A
CLASS="indexterm"
NAME="AUTOID-7617"
></A
></P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><KBD
CLASS="command"
>sub</KBD
>(<EM
CLASS="emphasis"
>r</EM
>,<EM
CLASS="emphasis"
>s</EM
>,<EM
CLASS="emphasis"
>t</EM
>)</TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Substitutes <EM
CLASS="emphasis"
>s</EM
> for first match of the regular expression 
<EM
CLASS="emphasis"
>r</EM
> in the string <EM
CLASS="emphasis"
>t</EM
>.  Returns 1 if successful; 0 
otherwise.  If <EM
CLASS="emphasis"
>t</EM
> is not supplied, defaults to <B
CLASS="emphasis.bold"
>$0</B
>.<A
CLASS="indexterm"
NAME="AUTOID-7632"
></A
></P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><KBD
CLASS="command"
>substr</KBD
>(<EM
CLASS="emphasis"
>s</EM
>,<EM
CLASS="emphasis"
>p</EM
>,<EM
CLASS="emphasis"
>n</EM
>)</TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Returns substring of string <EM
CLASS="emphasis"
>s</EM
> at beginning position 
<EM
CLASS="emphasis"
>p</EM
> up to a maximum length of <EM
CLASS="emphasis"
>n</EM
>.  If <EM
CLASS="emphasis"
>n</EM
> is 
not supplied, the rest of the string from <EM
CLASS="emphasis"
>p</EM
> is used. <A
CLASS="indexterm"
NAME="AUTOID-7647"
></A
></P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><KBD
CLASS="command"
>tolower</KBD
>(<EM
CLASS="emphasis"
>s</EM
>)</TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Translates all uppercase characters in string <EM
CLASS="emphasis"
>s</EM
> to 
lowercase and returns the new string.<A
CLASS="indexterm"
NAME="AUTOID-7656"
></A
><A
CLASS="indexterm"
NAME="AUTOID-7658"
></A
></P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><KBD
CLASS="command"
>toupper</KBD
>(<EM
CLASS="emphasis"
>s</EM
>)</TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Translates all lowercase characters in string <EM
CLASS="emphasis"
>s</EM
> to 
uppercase and returns the new string.<A
CLASS="indexterm"
NAME="AUTOID-7667"
></A
></P
></TD
></TR
></TBODY
></TABLE
><P
CLASS="para"
>The <KBD
CLASS="command"
>split()</KBD
> function was introduced in the previous chapter
in the discussion on arrays. </P
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-7672"
></A
>The <KBD
CLASS="command"
>sprintf()</KBD
> function 
uses the same format specifications as <KBD
CLASS="command"
>printf()</KBD
>, which is 
discussed in <A
CLASS="xref"
HREF="ch07_01.htm"
TITLE="Writing Scripts for awk"
>Chapter 7, Writing Scripts for awk</A
>.  It allows you to apply the format specifications
on a string.  Instead of printing the result, <KBD
CLASS="command"
>sprintf()</KBD
> returns
a string that can be assigned to a variable.  It can do
specialized processing of input records or fields,
such as performing character conversions.
For instance, the following example uses the <KBD
CLASS="command"
>sprintf()</KBD
>
function to convert a number into an ASCII character.   </P
><BLOCKQUOTE
CLASS="screen"
><PRE
CLASS="screen"
>for (i = 97; i &lt;= 122; ++i) {
	nextletter = sprintf(&quot;%c&quot;, i)
	...
}</PRE
></BLOCKQUOTE
><P
CLASS="para"
>A loop supplies numbers from 97 to 122, which produce
ASCII characters from <B
CLASS="emphasis.bold"
>a</B
> to
<B
CLASS="emphasis.bold"
>z</B
>. </P
><P
CLASS="para"
>That leaves us with three basic built-in
string functions to discuss: <KBD
CLASS="command"
>index()</KBD
>,
<KBD
CLASS="command"
>substr()</KBD
>, and <KBD
CLASS="command"
>length()</KBD
>. </P
><DIV
CLASS="sect2"
><H3
CLASS="sect2"
><A
CLASS="title"
NAME="SEDAWK-CH-9-SECT-2.1"
>9.2.1 Substrings</A
></H3
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-7690"
></A
><A
CLASS="indexterm"
NAME="AUTOID-7693"
></A
>The <KBD
CLASS="command"
>index()</KBD
> and <KBD
CLASS="command"
>substr()</KBD
> functions both deal with
substrings.  
Given a string <EM
CLASS="emphasis"
>s</EM
>, 
<KBD
CLASS="command"
>index</KBD
>(<EM
CLASS="emphasis"
>s</EM
>,<EM
CLASS="emphasis"
>t</EM
>) returns 
the leftmost position where string <EM
CLASS="emphasis"
>t</EM
> 
is found in <EM
CLASS="emphasis"
>s</EM
>. 
The beginning of the string is position 1 (which is different
from the C language, where the first character in a string is at position 0).
Look at the following example:</P
><BLOCKQUOTE
CLASS="screen"
><PRE
CLASS="screen"
>pos = index(&quot;Mississippi&quot;, &quot;is&quot;)</PRE
></BLOCKQUOTE
><P
CLASS="para"
>The value of <B
CLASS="emphasis.bold"
>pos</B
> is 2.
If the substring is not found, the <KBD
CLASS="command"
>index()</KBD
> function returns
0.</P
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-7708"
></A
>Given a string <EM
CLASS="emphasis"
>s</EM
>, 
<KBD
CLASS="command"
>substr</KBD
>(<EM
CLASS="emphasis"
>s</EM
>,<EM
CLASS="emphasis"
>p</EM
>) returns 
the characters beginning at position <EM
CLASS="emphasis"
>p</EM
>. 
The following example creates a phone number 
without an area code. </P
><BLOCKQUOTE
CLASS="screen"
><PRE
CLASS="screen"
>phone = substr(&quot;707-555-1111&quot;, 5)</PRE
></BLOCKQUOTE
><P
CLASS="para"
>You can also supply a third argument which is the number of
characters to return.  The next example returns just
the area code:</P
><BLOCKQUOTE
CLASS="screen"
><PRE
CLASS="screen"
>area_code = substr(&quot;707-555-1111&quot;, 1, 3)</PRE
></BLOCKQUOTE
><P
CLASS="para"
>The two functions can be and often are used together, as in the next
example.  This example capitalizes the first letter of the first
word for each input record.</P
><BLOCKQUOTE
CLASS="screen"
><PRE
CLASS="screen"
>awk '# caps - capitalize 1st letter of 1st word
# initialize strings
BEGIN { upper = &quot;ABCDEFGHIJKLMNOPQRSTUVWXYZ&quot;
        lower = &quot;abcdefghijklmnopqrstuvwxyz&quot; 
}

# for each input line
{
# get first character of first word
	FIRSTCHAR = substr($1, 1, 1)
# get position of FIRSTCHAR in lowercase array; if 0, ignore
	if (CHAR = index(lower, FIRSTCHAR)) 
		# change $1, using position to retrieve
		# uppercase character 
		$1 = substr(upper, CHAR, 1) substr($1, 2)
# print record
	print $0
}'</PRE
></BLOCKQUOTE
><P
CLASS="para"
>This script creates two variables, <B
CLASS="emphasis.bold"
>upper</B
> and <B
CLASS="emphasis.bold"
>lower</B
>,
consisting of uppercase and lowercase letters.  
Any character that we find in <B
CLASS="emphasis.bold"
>lower</B
> 
can be found at the same position in <B
CLASS="emphasis.bold"
>upper</B
>. 
The first
statement of the main procedure extracts a single character,
the first one, from the first field. 
The conditional statement tests to see if that character can
be found in <B
CLASS="emphasis.bold"
>lower</B
> using the <KBD
CLASS="command"
>index()</KBD
> function.  If
<B
CLASS="emphasis.bold"
>CHAR</B
> is not 0, then <B
CLASS="emphasis.bold"
>CHAR</B
> can be used to 
extract the uppercase character from <B
CLASS="emphasis.bold"
>upper</B
>.
There are two <KBD
CLASS="command"
>substr()</KBD
> function calls:  the first
one retrieves the capitalized letter and the second call
gets the rest of the first field, extracting
all characters, beginning with the second character.
The values returned by both <KBD
CLASS="command"
>substr()</KBD
> functions 
are concatenated and assigned
to $1.  
Making an assignment to a field
as we do here is a new twist, but it has the added benefit 
that the record can be output normally.  (If the assignment
was made to a variable, you'd have to output the variable
and then output the record's remaining fields.) 
The <KBD
CLASS="command"
>print</KBD
> statement prints the changed record.
Let's see it in action:</P
><BLOCKQUOTE
CLASS="screen"
><PRE
CLASS="screen"
>$ <CODE
CLASS="userinput"
><B
>caps</B
></CODE
>
<CODE
CLASS="userinput"
><B
>root user</B
></CODE
>
Root user
<CODE
CLASS="userinput"
><B
>dale</B
></CODE
>
Dale
<CODE
CLASS="userinput"
><B
>Tom</B
></CODE
>
Tom</PRE
></BLOCKQUOTE
><P
CLASS="para"
>In a little bit, we'll see how to
revise this program to change all
characters in a string from lower- to uppercase or vice versa.</P
></DIV
><DIV
CLASS="sect2"
><H3
CLASS="sect2"
><A
CLASS="title"
NAME="SEDAWK-CH-9-SECT-2.2"
>9.2.2 String Length</A
></H3
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-7742"
></A
><A
CLASS="indexterm"
NAME="AUTOID-7744"
></A
><A
CLASS="indexterm"
NAME="AUTOID-7746"
></A
>When presenting the <KBD
CLASS="command"
>awkro</KBD
> program in the previous chapter, we
noted that the program was likely to
produce lines that exceed 80 characters.  
After all, the descriptions are quite
long.  We can find out how many characters are in a string
using the built-in function <KBD
CLASS="command"
>length()</KBD
>.  
For instance, to evaluate the length of the current input
record, we specify <KBD
CLASS="command"
>length($0)</KBD
>.
(As it happens, if <KBD
CLASS="command"
>length()</KBD
> is called without
an argument, it returns the length of $0.)</P
><P
CLASS="para"
>The <KBD
CLASS="command"
>length()</KBD
> function is often used to find
the length of the current input record, in order to determine
if we need to break the line.</P
><P
CLASS="para"
>One way to handle the line break, perhaps
more efficiently, is to use the <KBD
CLASS="command"
>length()</KBD
> function
to get the length of each field.  By accumulating those lengths,
we could specify a line break when a new field causes the total to exceed 
a certain number.</P
><P
CLASS="para"
><A
CLASS="xref"
HREF="ch13_01.htm"
TITLE="A Miscellany of Scripts"
>Chapter 13, A Miscellany of Scripts</A
>,
contains a script that uses the <KBD
CLASS="command"
>length()</KBD
>
function to break lines greater than 80 columns wide.</P
></DIV
><DIV
CLASS="sect2"
><H3
CLASS="sect2"
><A
CLASS="title"
NAME="SEDAWK-CH-9-SECT-2.3"
>9.2.3 Substitution Functions</A
></H3
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="CH09.SUB1"
></A
><A
CLASS="indexterm"
NAME="CH09.SUB2"
></A
><A
CLASS="indexterm"
NAME="CH09.SUB3"
></A
><A
CLASS="indexterm"
NAME="CH09.SUB4"
></A
>Awk provides two substitution functions: <KBD
CLASS="command"
>sub()</KBD
> and
<KBD
CLASS="command"
>gsub()</KBD
>.  The difference between them is that <KBD
CLASS="command"
>gsub()</KBD
>
performs its substitution globally on the input string whereas
<KBD
CLASS="command"
>sub()</KBD
> makes only the first possible substitution.
This makes <KBD
CLASS="command"
>gsub()</KBD
> equivalent to the sed substitution
command with the <B
CLASS="emphasis.bold"
>g</B
> (global) flag. </P
><P
CLASS="para"
>Both functions take at least two arguments.  The first is a
regular expression (surrounded by slashes) that matches
a pattern and the second argument is a string that replaces what 
the pattern matches. 
The regular expression
can be supplied by a variable, in which case the slashes
are omitted.  An optional
third argument specifies the string that is the target of
the substitution.  If there is no third
argument, the substitution is made for the current
input record ($0).  </P
><P
CLASS="para"
>The substitution functions change the specified string directly.
You might expect, given the way functions work, that the function returns
the new string created when the substitution is made.
The substitution functions actually return 
the <EM
CLASS="emphasis"
>number</EM
> of substitutions made.  <KBD
CLASS="command"
>sub()</KBD
>
will always return 1 if successful; both return 0 if not
successful.  Thus, you can test the result to see if a substitution
was made.</P
><P
CLASS="para"
>For example, the following example uses <KBD
CLASS="command"
>gsub()</KBD
>
to replace all occurrences
of &quot;UNIX&quot; with &quot;POSIX&quot;.  </P
><BLOCKQUOTE
CLASS="screen"
><PRE
CLASS="screen"
>if (gsub(/UNIX/, &quot;POSIX&quot;))
	print</PRE
></BLOCKQUOTE
><P
CLASS="para"
>The conditional statement tests the return
value of <KBD
CLASS="command"
>gsub()</KBD
> such that the current input line is printed
only if a change is made.</P
><P
CLASS="para"
>As with sed, if an &quot;&amp;&quot; appears in the substitution string, it will
be replaced by the string matched by the regular expression.
Use &quot;\&amp;&quot; to output an ampersand.
(Remember that to get a literal &quot;\&quot; into a string, you have
to type two of them.)
Also, note that awk does not &quot;remember&quot; the previous regular
expression, as does sed, so you cannot use the syntax
&quot;//&quot; to refer to the last regular expression.</P
><P
CLASS="para"
>The following example surrounds any occurrence of &quot;UNIX&quot; with 
the <KBD
CLASS="command"
>troff</KBD
> font-change escape sequences.</P
><BLOCKQUOTE
CLASS="screen"
><PRE
CLASS="screen"
>gsub(/UNIX/, &quot;\\fB&amp;\\fR&quot;)</PRE
></BLOCKQUOTE
><P
CLASS="para"
>If the input is &quot;the UNIX operating system&quot;, the
output is &quot;the \fBUNIX\fR operating system&quot;.</P
><P
CLASS="para"
>In <A
CLASS="xref"
HREF="ch04_01.htm"
TITLE="Writing sed Scripts"
>Chapter 4, Writing sed Scripts</A
>, we presented the 
following sed script named <KBD
CLASS="command"
>do.outline</KBD
>:</P
><BLOCKQUOTE
CLASS="screen"
><PRE
CLASS="screen"
>sed -n '
s/&quot;//g
s/^\.Se /Chapter /p
s/^\.Ah /<IMG
SRC="../chars/bull.gif"
ALT="&#183;">A. /p
s/^\.Bh /<IMG
SRC="../chars/bull.gif"
ALT="&#183;"><IMG
SRC="../chars/bull.gif"
ALT="&#183;">B.  /p' $*</PRE
></BLOCKQUOTE
><P
CLASS="para"
>Now here's that script rewritten using the substitution
functions:</P
><BLOCKQUOTE
CLASS="screen"
><PRE
CLASS="screen"
>awk '
{
gsub(/&quot;/, &quot;&quot;)
if (sub(/^\.Se /, &quot;Chapter &quot;)) print
if (sub(/^\.Ah /, &quot;\tA. &quot;)) print
if (sub(/^\.Bh /, &quot;\t\tB.  &quot;)) print
}' $*</PRE
></BLOCKQUOTE
><P
CLASS="para"
>The two scripts are exactly equivalent, printing out
only those lines that are changed.
For the first edition of this book, Dale
compared the run-time of both scripts and, as he expected,
the awk script was slower. 
For the second edition, new timings showed that performance
varies by implementation, and in fact, all tested versions
of new awk were faster than sed!
This is nice, since
we have the capabilities in awk to make
the script do more things.  For instance, instead of
using letters of the alphabet, we could number the headings. 
Here's the revised awk script:</P
><BLOCKQUOTE
CLASS="screen"
><PRE
CLASS="screen"
>awk '# do.outline -- number headings in chapter.
{
gsub(/&quot;/, &quot;&quot;)
}
/^\.Se/ {
	sub(/^\.Se /, &quot;Chapter &quot;) 
	ch = $2
	ah = 0
	bh = 0
	print
	next
}
/^\.Ah/ {
	sub(/^\.Ah /, &quot;\t &quot; ch &quot;.&quot; ++ah &quot; &quot;) 
	bh = 0
	print
	next
}
/^\.Bh/ {
	sub(/^\.Bh /, &quot;\t\t &quot; ch &quot;.&quot;  ah &quot;.&quot; ++bh &quot; &quot;)
	print
}' $*</PRE
></BLOCKQUOTE
><P
CLASS="para"
>In this version, we break out each heading into its own
pattern-matching rule.  This is not necessary but seems
more efficient since we know that once a rule is applied,
we don't need to look at the others.
Note the use of the <KBD
CLASS="command"
>next</KBD
> statement to bypass further
examination of a line that has already been identified.</P
><P
CLASS="para"
>The chapter number 
is read as the first argument to the &quot;.Se&quot; macro
and is thus the second field on that line. 
The numbering scheme is done by incrementing a variable
each time the substitution is made.  
The action associated with the chapter-level heading
initializes the section-heading counters to zero.
The action associated with the top-level heading &quot;.Ah&quot;
zeroes the second-level heading counter.
Obviously, you can create as many levels of heading
as you need.
Note how we can specify a concatenation of 
strings and variables as a single
argument to the <KBD
CLASS="command"
>sub()</KBD
> function. </P
><BLOCKQUOTE
CLASS="screen"
><PRE
CLASS="screen"
>$ <CODE
CLASS="userinput"
><B
>do.outline ch02</B
></CODE
>
Chapter 2 Understanding Basic Operations
         2.1 Awk, by Sed and Grep, out of Ed 
         2.2 Command-line Syntax
                 2.2.1 Scripting
                 2.2.2 Sample Mailing List
         2.3 Using Sed
                 2.3.1 Specifying Simple Instructions
                 2.3.2 Script Files
         2.4 Using Awk
         2.5 Using Sed and Awk Together</PRE
></BLOCKQUOTE
><P
CLASS="para"
>If you wanted the option of choosing either numbers or letters, you
could maintain both programs and construct a shell wrapper that uses 
some flag to determine which program should be invoked.</P
><A
CLASS="indexterm"
NAME="AUTOID-7807"
></A
><A
CLASS="indexterm"
NAME="AUTOID-7808"
></A
><A
CLASS="indexterm"
NAME="AUTOID-7809"
></A
><A
CLASS="indexterm"
NAME="AUTOID-7810"
></A
></DIV
><DIV
CLASS="sect2"
><H3
CLASS="sect2"
><A
CLASS="title"
NAME="SEDAWK-CH-9-SECT-2.4"
>9.2.4 Converting Case</A
></H3
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-7814"
></A
><A
CLASS="indexterm"
NAME="AUTOID-7817"
></A
><A
CLASS="indexterm"
NAME="AUTOID-7819"
></A
><A
CLASS="indexterm"
NAME="AUTOID-7822"
></A
><A
CLASS="indexterm"
NAME="AUTOID-7824"
></A
>POSIX awk provides two functions for converting the case of characters
within a string.  The functions are <KBD
CLASS="command"
>tolower()</KBD
> and <KBD
CLASS="command"
>toupper()</KBD
>.
Each takes a single string argument, and returns a copy of that string,
with all the characters of one case converted to the other (upper to
lower and lower to upper, respectively).
Their use is straightforward:</P
><BLOCKQUOTE
CLASS="screen"
><PRE
CLASS="screen"
>$ <CODE
CLASS="userinput"
><B
>cat test</B
></CODE
>
Hello, World!
Good-bye CRUEL world!
1, 2, 3, and away we GO!
$ <CODE
CLASS="userinput"
><B
>awk '{ printf(&quot;&lt;%s&gt;, &lt;%s&gt;\n&quot;, tolower($0), toupper($0)) }' test</B
></CODE
>
&lt;hello, world!&gt;, &lt;HELLO, WORLD!&gt;
&lt;good-bye cruel world!&gt;, &lt;GOOD-BYE CRUEL WORLD!&gt;
&lt;1, 2, 3, and away we go!&gt;, &lt;1, 2, 3, AND AWAY WE GO!&gt;</PRE
></BLOCKQUOTE
><P
CLASS="para"
>Note that nonalphabetic characters are left unchanged.</P
></DIV
><DIV
CLASS="sect2"
><H3
CLASS="sect2"
><A
CLASS="title"
NAME="SEDAWK-CH-9-SECT-2.5"
>9.2.5 The match() Function</A
></H3
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="CH09.MATCH1"
></A
><A
CLASS="indexterm"
NAME="CH09.MATCH2"
></A
><A
CLASS="indexterm"
NAME="CH09.MATCH3"
></A
>The <KBD
CLASS="command"
>match()</KBD
> function 
allows you to determine if a regular expression matches a specified
string.  
It takes two arguments, the string and the regular
expression.  (This function is confusing because the regular
expression is in the second position, whereas
it is in the first position for the substitution functions.)</P
><P
CLASS="para"
>The <KBD
CLASS="command"
>match()</KBD
> function returns the starting position
of the substring that was matched by the regular expression.
You might consider it a close relation to the <KBD
CLASS="command"
>index()</KBD
>
function. 
In the following example, the regular expression matches  
any sequence of capital letters in the string &quot;the
UNIX operating system&quot;.</P
><BLOCKQUOTE
CLASS="screen"
><PRE
CLASS="screen"
>match(&quot;the UNIX operating system&quot;, /[A-Z]+/)</PRE
></BLOCKQUOTE
><P
CLASS="para"
>The value returned by this function is 5, the character position
of &quot;U,&quot; the first capital letter in the string.</P
><P
CLASS="para"
>The <KBD
CLASS="command"
>match()</KBD
> function also sets two system variables:
<B
CLASS="emphasis.bold"
>RSTART</B
> and <B
CLASS="emphasis.bold"
>RLENGTH</B
>. 
<B
CLASS="emphasis.bold"
>RSTART</B
> contains the same value returned by the function,
the starting position of the substring.  <B
CLASS="emphasis.bold"
>RLENGTH</B
> 
contains the length of the string in characters (not the ending
position of the substring).
When the pattern does not match, <B
CLASS="emphasis.bold"
>RSTART</B
> is set to 0
and <B
CLASS="emphasis.bold"
>RLENGTH</B
> is set to -1.
In the previous example, <B
CLASS="emphasis.bold"
>RSTART</B
> is equal to 5
and <B
CLASS="emphasis.bold"
>RLENGTH</B
> is equal to 4.  (Adding them together gives
you the position of the first character after the match.)</P
><P
CLASS="para"
>Let's look at a rather simple example 
that prints out 
a string matched by a specified regular expression, demonstrating the
&quot;extent of the match,&quot; as discussed in <A
CLASS="xref"
HREF="ch03_01.htm"
TITLE="Understanding Regular Expression Syntax"
>Chapter 3, Understanding Regular Expression Syntax</A
>.
The following shell script takes 
two command-line arguments:  the regular expression, which should
be specified in quotes, and the name of the file to search.</P
><BLOCKQUOTE
CLASS="screen"
><PRE
CLASS="screen"
>awk '# match -- print string that matches line
# for lines match pattern 
match($0, pattern) {
	# extract string matching pattern using
	# starting position and length of string in $0 
	# print string
	print substr($0, RSTART, RLENGTH)
}' pattern=&quot;$1&quot; $2</PRE
></BLOCKQUOTE
><P
CLASS="para"
>The first command-line parameter is passed as the value
of <B
CLASS="emphasis.bold"
>pattern</B
>. 
Note that $1 is surrounded by quotes, necessary to 
protect any spaces that might appear in the regular expression.
The <KBD
CLASS="command"
>match()</KBD
> function appears in a conditional expression
that controls execution of the only procedure in this awk
script. 
The <KBD
CLASS="command"
>match()</KBD
> function returns 0 if the pattern 
is not found, and a non-zero value (<B
CLASS="emphasis.bold"
>RSTART</B
>) if it is found,
allowing the return value to be used as a condition.
If the current record matches the pattern, then
the string is extracted from $0, using
the values of <B
CLASS="emphasis.bold"
>RSTART</B
> and <B
CLASS="emphasis.bold"
>RLENGTH</B
> in the <KBD
CLASS="command"
>substr()</KBD
>
function to specify the starting position of the substring to be
extracted and its length.  The substring
is printed.  This procedure only matches the first occurrence in $0.</P
><P
CLASS="para"
>Here's a trial run, given a regular expression that matches
&quot;emp&quot; and any number of characters up to a blank space: </P
><BLOCKQUOTE
CLASS="screen"
><PRE
CLASS="screen"
>$ <CODE
CLASS="userinput"
><B
>match &quot;emp[^ ]*&quot; personnel.txt</B
></CODE
>
employees
employee
employee.
employment,
employer
employment
employee's
employee</PRE
></BLOCKQUOTE
><P
CLASS="para"
>The <KBD
CLASS="command"
>match</KBD
> script could be a useful tool in
improving your understanding of regular expressions.</P
><P
CLASS="para"
>The next script uses the <KBD
CLASS="command"
>match()</KBD
> function to locate
any sequence of uppercase letters so that they can be converted
to lowercase.  Compare it to the <KBD
CLASS="command"
>caps</KBD
> program shown
earlier in the chapter.</P
><BLOCKQUOTE
CLASS="screen"
><PRE
CLASS="screen"
>awk '# lower - change upper case to lower case 
# initialize strings
BEGIN { upper = &quot;ABCDEFGHIJKLMNOPQRSTUVWXYZ&quot;
        lower = &quot;abcdefghijklmnopqrstuvwxyz&quot; 
}

# for each input line
{
# see if there is a match for all caps 
	 while (match($0, /[A-Z]+/))  
		# get each cap letter
		for (x = RSTART; x &lt; RSTART+RLENGTH; ++x) { 
			CAP = substr($0, x, 1)
			CHAR = index(upper, CAP)
			# substitute lowercase for upper 
			gsub(CAP, substr(lower, CHAR, 1))
		}
		
# print record
       print $0
}' $*</PRE
></BLOCKQUOTE
><P
CLASS="para"
>In this script, the <KBD
CLASS="command"
>match()</KBD
> function appears in
a conditional expression that determines whether
a <KBD
CLASS="command"
>while</KBD
> loop will be executed.
By placing this function in a loop, we apply the body
of the loop as many times as the pattern occurs 
in the current input record.</P
><P
CLASS="para"
>The regular expression matches any sequence of uppercase letters in
$0.  If a match is made,
a <KBD
CLASS="command"
>for</KBD
> loop does the lookup of each character in the
substring that was matched, similar to what we did in
the <KBD
CLASS="command"
>caps</KBD
> sample program, shown earlier in this chapter.  
What's different here is how we use the system variables
<B
CLASS="emphasis.bold"
>RSTART</B
> and <B
CLASS="emphasis.bold"
>RLENGTH</B
>.
<B
CLASS="emphasis.bold"
>RSTART</B
> initializes the counter variable <B
CLASS="emphasis.bold"
>x</B
>.  It
is used in the <KBD
CLASS="command"
>substr()</KBD
> function to extract one character
at a time from $0, beginning with the first character that
matched the pattern.  By
adding <B
CLASS="emphasis.bold"
>RLENGTH</B
> to <B
CLASS="emphasis.bold"
>RSTART</B
>, we get
the position of the first character after the ones that matched the pattern.
That is why the loop uses &quot;&lt;&quot; instead of &quot;&lt;=&quot;.
At the end, we use <KBD
CLASS="command"
>gsub()</KBD
> to replace the uppercase letter
with the corresponding lowercase letter.[2]
Notice that we use <KBD
CLASS="command"
>gsub()</KBD
> instead of <KBD
CLASS="command"
>sub()</KBD
>
because it offers us the advantage of making several substitutions
if there are multiple instances of the same letter
on the line.</P
><BLOCKQUOTE
CLASS="footnote"
><P
CLASS="para"
>[2] You may be wondering, &quot;why not just use
<B
CLASS="emphasis.bold"
>tolower()</B
>?&quot; Good question.
Some early versions of <B
CLASS="emphasis.bold"
>nawk</B
>,
including the one on SunOS 4.1.x systems, don't have
<B
CLASS="emphasis.bold"
>tolower()</B
> and
<B
CLASS="emphasis.bold"
>toupper()</B
>; thus it's useful
to know how to do it yourself.</P
></BLOCKQUOTE
><BLOCKQUOTE
CLASS="screen"
><PRE
CLASS="screen"
>$ <CODE
CLASS="userinput"
><B
>cat test</B
></CODE
>
Every NOW and then, a WORD I type appears in CAPS.
$ <CODE
CLASS="userinput"
><B
>lower test</B
></CODE
>
every now and then, a word i type appears in caps.</PRE
></BLOCKQUOTE
><P
CLASS="para"
>Note that you could change the regular expression to avoid
matching individual capital letters by matching
a sequence of two or more uppercase characters, by using:  &quot;/[A-Z][A-Z]+/.&quot;  
This would also require revising the way the lowercase
conversion was made using <KBD
CLASS="command"
>gsub()</KBD
>, since it matches
a single character on the line.</P
><P
CLASS="para"
>In our discussion of the sed substitution command, you saw
how to save and recall a portion of a string matched by
a pattern, using \( and \) to surround
the pattern to be saved and \<EM
CLASS="emphasis"
>n</EM
> to recall the saved string
in the replacement pattern.  Unfortunately, awk's standard substitution
functions offer no equivalent syntax.  The <KBD
CLASS="command"
>match()</KBD
> function can
solve many such problems, though.</P
><P
CLASS="para"
>For instance, if you match a string using the <KBD
CLASS="command"
>match()</KBD
> function,
you can single out characters or a substring at the head
or tail of the string.  
Given the values of <B
CLASS="emphasis.bold"
>RSTART</B
> and <B
CLASS="emphasis.bold"
>RLENGTH</B
>,  
you can use the <KBD
CLASS="command"
>substr()</KBD
> function to extract the characters.
In the following example, we replace the second of
two colons with a semicolon.  We can't use <KBD
CLASS="command"
>gsub()</KBD
> to make the replacement
because &quot;/:/&quot; matches the first colon and &quot;/:[^:]*:/&quot; matches the
whole string of characters. 
We can use <KBD
CLASS="command"
>match()</KBD
> to match the string of characters
and to extract the last character of the string.</P
><BLOCKQUOTE
CLASS="screen"
><PRE
CLASS="screen"
># replace 2nd colon with semicolon using match, substr
if (match($1, /:[^:]*:/)) {
	before = substr($1, 1, (RSTART + RLENGTH - 2))
	after = substr($1, (RSTART + RLENGTH))
	$1 = before &quot;;&quot; after
}</PRE
></BLOCKQUOTE
><P
CLASS="para"
>The <KBD
CLASS="command"
>match()</KBD
> function is placed within a conditional statement
that tests that a match was found.   
If there is a match, we use the <KBD
CLASS="command"
>substr()</KBD
> function to extract
the substring before the second colon as well as the substring 
after it.  Then we concatenate <B
CLASS="emphasis.bold"
>before</B
>, the literal &quot;;&quot;, and
<B
CLASS="emphasis.bold"
>after</B
>, assigning it to $1.</P
><P
CLASS="para"
>You can see examples of the <KBD
CLASS="command"
>match()</KBD
> function in use
in <A
CLASS="xref"
HREF="ch12_01.htm"
TITLE="Full-Featured Applications"
>Chapter 12, Full-Featured Applications</A
>.</P
><A
CLASS="indexterm"
NAME="AUTOID-7925"
></A
><A
CLASS="indexterm"
NAME="AUTOID-7926"
></A
><A
CLASS="indexterm"
NAME="AUTOID-7927"
></A
></DIV
><A
CLASS="indexterm"
NAME="AUTOID-7928"
></A
><A
CLASS="indexterm"
NAME="AUTOID-7929"
></A
></DIV
><DIV
CLASS="htmlnav"
><P
></P
><HR
ALIGN="LEFT"
WIDTH="515"
TITLE="footer"><TABLE
WIDTH="515"
BORDER="0"
CELLSPACING="0"
CELLPADDING="0"
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="172"
><A
CLASS="SECT1"
HREF="ch09_01.htm"
TITLE="9.1 Arithmetic Functions"
><IMG
SRC="../gifs/txtpreva.gif"
ALT="Previous: 9.1 Arithmetic Functions"
BORDER="0"></A
></TD
><TD
ALIGN="CENTER"
VALIGN="TOP"
WIDTH="171"
><A
CLASS="book"
HREF="index.htm"
TITLE="sed &amp; awk"
><IMG
SRC="../gifs/txthome.gif"
ALT="sed &amp; awk"
BORDER="0"></A
></TD
><TD
ALIGN="RIGHT"
VALIGN="TOP"
WIDTH="172"
><A
CLASS="SECT1"
HREF="ch09_03.htm"
TITLE="9.3 Writing Your Own Functions"
><IMG
SRC="../gifs/txtnexta.gif"
ALT="Next: 9.3 Writing Your Own Functions"
BORDER="0"></A
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="172"
>9.1 Arithmetic Functions</TD
><TD
ALIGN="CENTER"
VALIGN="TOP"
WIDTH="171"
><A
CLASS="index"
HREF="index/idx_0.htm"
TITLE="Book Index"
><IMG
SRC="../gifs/index.gif"
ALT="Book Index"
BORDER="0"></A
></TD
><TD
ALIGN="RIGHT"
VALIGN="TOP"
WIDTH="172"
>9.3 Writing Your Own Functions</TD
></TR
></TABLE
><HR
ALIGN="LEFT"
WIDTH="515"
TITLE="footer"><IMG
SRC="../gifs/smnavbar.gif"
USEMAP="#map"
BORDER="0"
ALT="The UNIX CD Bookshelf Navigation"><MAP
NAME="map"
><AREA
SHAPE="RECT"
COORDS="0,0,73,21"
HREF="../index.htm"
ALT="The UNIX CD Bookshelf"><AREA
SHAPE="RECT"
COORDS="74,0,163,21"
HREF="../upt/index.htm"
ALT="UNIX Power Tools"><AREA
SHAPE="RECT"
COORDS="164,0,257,21"
HREF="../unixnut/index.htm"
ALT="UNIX in a Nutshell"><AREA
SHAPE="RECT"
COORDS="258,0,321,21"
HREF="../vi/index.htm"
ALT="Learning the vi Editor"><AREA
SHAPE="RECT"
COORDS="322,0,378,21"
HREF="index.htm"
ALT="sed &amp; awk"><AREA
SHAPE="RECT"
COORDS="379,0,438,21"
HREF="../ksh/index.htm"
ALT="Learning the Korn Shell"><AREA
SHAPE="RECT"
COORDS="439,0,514,21"
HREF="../lrnunix/index.htm"
ALT="Learning the UNIX Operating System"></MAP
></DIV
></BODY
></HTML
>
