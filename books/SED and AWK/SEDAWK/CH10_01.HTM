<HTML
><HEAD
>
<TITLE>[Chapter 10] The Bottom Drawer</TITLE>
<META
NAME="DC.title"
CONTENT="sed &amp; awk"><META
NAME="DC.creator"
CONTENT="Dale Dougherty &amp; Arnold Robbins"><META
NAME="DC.publisher"
CONTENT="O'Reilly &amp; Associates, Inc."><META
NAME="DC.date"
CONTENT="1998-08-03T21:01:25Z"><META
NAME="DC.type"
CONTENT="Text.Monograph"><META
NAME="DC.format"
CONTENT="text/html"
SCHEME="MIME"><META
NAME="DC.source"
CONTENT="1-56592-225-5"
SCHEME="ISBN"><META
NAME="DC.language"
CONTENT="en-US"><META
NAME="generator"
CONTENT="Jade 1.1/O'Reilly DocBook 3.0 to HTML 4.0"><LINK
REV="made"
HREF="mailto:online-books@oreilly.com"
TITLE="Online Books Comments"><LINK
REL="up"
HREF="index.htm"
TITLE="sed &amp; awk"><LINK
REL="prev"
HREF="ch09_03.htm"
TITLE="9.3 Writing Your Own Functions"><LINK
REL="next"
HREF="ch10_02.htm"
TITLE="10.2 The close() Function"></HEAD
><BODY
BGCOLOR="#FFFFFF"
TEXT="#000000"
><DIV
CLASS="htmlnav"
><H1
><IMG
SRC="gifs/smbanner.gif"
ALT="sed &amp; awk"
USEMAP="#srchmap"
BORDER="0"></H1
><MAP
NAME="srchmap"
><AREA
SHAPE="RECT"
COORDS="0,0,466,65"
HREF="index.htm"
ALT="sed &amp; awk"><AREA
SHAPE="RECT"
COORDS="467,0,514,18"
HREF="../search/ssrch.htm"
ALT="Search this book"></MAP
><TABLE
WIDTH="515"
BORDER="0"
CELLSPACING="0"
CELLPADDING="0"
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="172"
><A
CLASS="SECT1"
HREF="ch09_03.htm"
TITLE="9.3 Writing Your Own Functions"
><IMG
SRC="../gifs/txtpreva.gif"
ALT="Previous: 9.3 Writing Your Own Functions"
BORDER="0"></A
></TD
><TD
ALIGN="CENTER"
VALIGN="TOP"
WIDTH="171"
><B
><FONT
FACE="ARIEL,HELVETICA,HELV,SANSERIF"
SIZE="-1"
>Chapter 10</FONT
></B
></TD
><TD
ALIGN="RIGHT"
VALIGN="TOP"
WIDTH="172"
><A
CLASS="SECT1"
HREF="ch10_02.htm"
TITLE="10.2 The close() Function"
><IMG
SRC="../gifs/txtnexta.gif"
ALT="Next: 10.2 The close() Function"
BORDER="0"></A
></TD
></TR
></TABLE
>&nbsp;<HR
ALIGN="LEFT"
WIDTH="515"
TITLE="footer"></DIV
><DIV
CLASS="CHAPTER"
><H1
CLASS="chapter"
><A
CLASS="title"
NAME="SEDAWK-CH-10"
>10. The Bottom Drawer</A
></H1
><DIV
CLASS="htmltoc"
><P
><B
>Contents:</B
><BR><A
CLASS="sect1"
HREF="#SEDAWK-CH-10-SECT-1"
TITLE="10.1 The getline Function"
>The getline Function</A
><BR><A
CLASS="sect1"
HREF="ch10_02.htm"
TITLE="10.2 The close() Function"
>The close() Function</A
><BR><A
CLASS="sect1"
HREF="ch10_03.htm"
TITLE="10.3 The system() Function"
>The system() Function</A
><BR><A
CLASS="sect1"
HREF="ch10_04.htm"
TITLE="10.4 A Menu-Based Command Generator"
>A Menu-Based Command Generator</A
><BR><A
CLASS="sect1"
HREF="ch10_05.htm"
TITLE="10.5 Directing Output to Files and Pipes"
>Directing Output to Files and Pipes</A
><BR><A
CLASS="sect1"
HREF="ch10_06.htm"
TITLE="10.6 Generating Columnar Reports"
>Generating Columnar Reports</A
><BR><A
CLASS="sect1"
HREF="ch10_07.htm"
TITLE="10.7 Debugging"
>Debugging</A
><BR><A
CLASS="sect1"
HREF="ch10_08.htm"
TITLE="10.8 Limitations"
>Limitations</A
><BR><A
CLASS="sect1"
HREF="ch10_09.htm"
TITLE="10.9 Invoking awk Using the #! Syntax"
>Invoking awk Using the #! Syntax</A
></P
><P
></P
></DIV
><P
CLASS="para"
>This chapter is proof that not everything has its place.  Some things
just don't seem to fit, no matter how you organize them.  This chapter
is a collection of such things. It is tempting to label it &quot;Advanced
Topics,&quot; as if to explain its organization (or lack thereof), but some
readers might feel they need to make more progress before reading
it. We have therefore called it &quot;The Bottom Drawer,&quot; thinking of the
organization of a chest of drawers, with underwear, socks, and other
day-to-day things in the top drawers and heavier things that are less frequently used, like
sweaters, in the bottom drawers.  All of
it is equally accessible, but you have to bend over to get things in
the bottom drawer.  It requires a little more effort to get something,
that's all.</P
><P
CLASS="para"
>In this chapter we cover a number of topics, including the
following:</P
><UL
CLASS="itemizedlist"
><LI
CLASS="listitem"
><P
CLASS="para"
>The <KBD
CLASS="command"
>getline</KBD
> function</P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>The <KBD
CLASS="command"
>system()</KBD
> function</P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>Directing output to files and pipes</P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>Debugging awk scripts</P
></LI
></UL
><DIV
CLASS="sect1"
><H2
CLASS="sect1"
><A
CLASS="title"
NAME="SEDAWK-CH-10-SECT-1"
>10.1 The getline Function</A
></H2
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="CH10.GET1"
></A
><A
CLASS="indexterm"
NAME="CH10.GET2"
></A
><A
CLASS="indexterm"
NAME="CH10.GET3"
></A
><A
CLASS="indexterm"
NAME="CH10.GET4"
></A
>The <KBD
CLASS="command"
>getline</KBD
> function is used to read another line
of input.  Not only can <KBD
CLASS="command"
>getline</KBD
> read from the
regular input data stream, it can also handle input from files and
pipes.</P
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-8173"
></A
>The <KBD
CLASS="command"
>getline</KBD
> function
is similar to awk's <KBD
CLASS="command"
>next</KBD
> statement.  While both
cause the next input line to be read, the <KBD
CLASS="command"
>next</KBD
> statement passes 
control back to the top of the script.  The <KBD
CLASS="command"
>getline</KBD
>
function gets the next line without changing control in the script. 
Possible return values are: </P
><TABLE
CLASS="informaltable"
><TBODY
CLASS="tbody"
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
>1</TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>If it was able to read a line.</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
>0</TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>If it encounters the end-of-file.</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
>-1</TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>If it encounters an error.</P
></TD
></TR
></TBODY
></TABLE
><BLOCKQUOTE
CLASS="note"
><P
CLASS="para"
><STRONG
>NOTE:</STRONG
> Although <KBD
CLASS="command"
>getline</KBD
> is called a function and it does
return a value, its syntax resembles a statement.  Do not write
<KBD
CLASS="command"
>getline()</KBD
>; its syntax does not permit
parentheses.</P
></BLOCKQUOTE
><P
CLASS="para"
>In the previous chapter, we used a manual page source file as an
example.  The <KBD
CLASS="command"
>-man</KBD
> macros typically place the text
argument on the next line.  Although the macro is the pattern that you
use to find the line, it is actually the next line that you process.
For instance, to extract the name of the command from the manpage,
the following example matches the heading &quot;Name,&quot; reads the
next line, and prints the first field of it:</P
><P
CLASS="para"
><BLOCKQUOTE
CLASS="screen"
><PRE
CLASS="screen"
># getline.awk -- test getline function
/^\.SH &quot;?Name&quot;?/ { 
	getline # get next line
	print $1 # print $1 of new line.
}</PRE
></BLOCKQUOTE
></P
><P
CLASS="para"
>The pattern matches any line with &quot;.SH&quot; followed by &quot;Name,&quot; which
might be enclosed in quotes.  Once this line is matched, we use
<KBD
CLASS="command"
>getline</KBD
> to read the next input line.  When the new
line is read, <KBD
CLASS="command"
>getline</KBD
> assigns it $0 and parses it
into fields.  The system variables <KBD
CLASS="command"
>NF</KBD
>,
<KBD
CLASS="command"
>NR</KBD
>, and <KBD
CLASS="command"
>FNR</KBD
> are also set.  Thus,
the new line becomes the current line, and we are able to refer to
&quot;$1&quot; and retrieve the first field.  Note that the previous line is no
longer available as $0.  However, if necessary, you can assign the
line read by <KBD
CLASS="command"
>getline</KBD
> to a variable and avoid
changing $0, as we'll see shortly.</P
><P
CLASS="para"
>Here's an example that shows how the previous script works, printing
out the first field of the line following &quot;.SH Name.&quot;</P
><P
CLASS="para"
><BLOCKQUOTE
CLASS="screen"
><PRE
CLASS="screen"
>$ <CODE
CLASS="userinput"
><B
>awk -f getline.awk test</B
></CODE
>
XSubImage</PRE
></BLOCKQUOTE
></P
><P
CLASS="para"
>The <KBD
CLASS="command"
>sorter.awk</KBD
> program that we demonstrated at the
end of <A
CLASS="xref"
HREF="ch09_01.htm"
TITLE="Functions"
>Chapter 9, Functions</A
>, could have used <KBD
CLASS="command"
>getline</KBD
>
to read all the lines after the heading &quot;Related Commands.&quot;  We can
test the return value of <KBD
CLASS="command"
>getline</KBD
> in a
<KBD
CLASS="command"
>while</KBD
> loop to read a number of lines from the
input.  The following procedure replaces the first two procedures in
the <KBD
CLASS="command"
>sorter</KBD
> program:</P
><P
CLASS="para"
><BLOCKQUOTE
CLASS="screen"
><PRE
CLASS="screen"
># Match &quot;Related Commands&quot; and collect them
/^\.SH &quot;?Related Commands&quot;?/ {
	print
	while (getline &gt; 0)
		commandList = commandList $0
}</PRE
></BLOCKQUOTE
></P
><P
CLASS="para"
>The expression &quot;getline &gt; 0&quot; will be true as long as
<KBD
CLASS="command"
>getline</KBD
> successfully reads an input line.  When it
gets to the end-of-file, <KBD
CLASS="command"
>getline</KBD
> returns 0 and the
loop is exited.</P
><DIV
CLASS="sect2"
><H3
CLASS="sect2"
><A
CLASS="title"
NAME="SEDAWK-CH-10-SECT-1.1"
>10.1.1 Reading Input from Files</A
></H3
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-8229"
></A
><A
CLASS="indexterm"
NAME="AUTOID-8232"
></A
>Besides reading from the regular input stream, the
<KBD
CLASS="command"
>getline</KBD
> function allows you to read input from a
file or a pipe.  For instance, the following statement reads the next
line from the file <I
CLASS="filename"
>data</I
>:</P
><P
CLASS="para"
><BLOCKQUOTE
CLASS="screen"
><PRE
CLASS="screen"
>getline &lt; &quot;data&quot;</PRE
></BLOCKQUOTE
></P
><P
CLASS="para"
>Although the filename can be supplied through a variable, it is
typically specified as a string constant, which must be enclosed in
quotes.  The symbol &quot;&lt;&quot; is the same as the shell's input
redirection symbol and will not be interpreted as the &quot;less than&quot;
symbol.  We can use a <KBD
CLASS="command"
>while</KBD
> loop to read all the
lines from a file, testing for an end-of-file to exit the loop.  The
following example opens the file <EM
CLASS="emphasis"
>data</EM
> and prints
all of its lines:</P
><P
CLASS="para"
><BLOCKQUOTE
CLASS="screen"
><PRE
CLASS="screen"
>while ( (getline &lt; &quot;data&quot;) &gt; 0 )
	print</PRE
></BLOCKQUOTE
></P
><P
CLASS="para"
>(We parenthesize to avoid confusion; the &quot;&lt;&quot; is a redirection,
while the &quot;&gt;&quot; is a comparison of the return value.)  The input can
also come from standard input.  You can use <KBD
CLASS="command"
>getline</KBD
>
following a prompt for the user to enter information:</P
><P
CLASS="para"
><BLOCKQUOTE
CLASS="screen"
><PRE
CLASS="screen"
>BEGIN { printf &quot;Enter your name: &quot;
	getline &lt; &quot;-&quot;
	print  
}</PRE
></BLOCKQUOTE
></P
><P
CLASS="para"
>This sample code prints the prompt &quot;Enter your name:&quot;
(<KBD
CLASS="command"
>printf</KBD
> is used because we don't want a carriage
return after the prompt), and then calls <KBD
CLASS="command"
>getline</KBD
> to
gather the user's response.[1]
The response is assigned to $0, and the <KBD
CLASS="command"
>print</KBD
>
statement outputs that value.</P
><BLOCKQUOTE
CLASS="footnote"
><P
CLASS="para"
>[1] At least at one time, SGI
versions of nawk did not support the use of &quot;-&quot; with
<KBD
CLASS="command"
>getline</KBD
> to read from standard input. Caveat emptor.  </P
></BLOCKQUOTE
></DIV
><DIV
CLASS="sect2"
><H3
CLASS="sect2"
><A
CLASS="title"
NAME="SEDAWK-CH-10-SECT-1.2"
>10.1.2 Assigning the Input to a Variable</A
></H3
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-8258"
></A
><A
CLASS="indexterm"
NAME="AUTOID-8260"
></A
><A
CLASS="indexterm"
NAME="AUTOID-8263"
></A
>The <KBD
CLASS="command"
>getline</KBD
> function allows you to assign the input
record to a variable.  The name of the variable is supplied as an
argument.  Thus, the following statement reads the next line of input
into the variable <KBD
CLASS="command"
>input</KBD
>:</P
><P
CLASS="para"
><BLOCKQUOTE
CLASS="screen"
><PRE
CLASS="screen"
>getline input</PRE
></BLOCKQUOTE
></P
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-8271"
></A
><A
CLASS="indexterm"
NAME="AUTOID-8273"
></A
><A
CLASS="indexterm"
NAME="AUTOID-8275"
></A
><A
CLASS="indexterm"
NAME="AUTOID-8277"
></A
>Assigning the input to a variable does not affect the current input
line; that is, $0 is not affected.  The new input line is not split
into fields, and thus the variable <KBD
CLASS="command"
>NF</KBD
> is also
unaffected.  It does increment the record counters,
<KBD
CLASS="command"
>NR</KBD
> and <KBD
CLASS="command"
>FNR</KBD
>.</P
><P
CLASS="para"
>The previous example demonstrated how to prompt the user.  That
example could be written as follows, assigning the user's response to
the variable <KBD
CLASS="command"
>name</KBD
>.</P
><P
CLASS="para"
><BLOCKQUOTE
CLASS="screen"
><PRE
CLASS="screen"
>BEGIN { printf &quot;Enter your name: &quot;
	getline name &lt; &quot;-&quot;
	print name
}</PRE
></BLOCKQUOTE
></P
><P
CLASS="para"
>Study the syntax for assigning the input data to a variable because it
is a common mistake to instead write:</P
><P
CLASS="para"
><BLOCKQUOTE
CLASS="screen"
><PRE
CLASS="screen"
>name = getline     # wrong</PRE
></BLOCKQUOTE
></P
><P
CLASS="para"
>which assigns the return value of <KBD
CLASS="command"
>getline</KBD
> to the
variable <KBD
CLASS="command"
>name</KBD
>.</P
></DIV
><DIV
CLASS="sect2"
><H3
CLASS="sect2"
><A
CLASS="title"
NAME="SEDAWK-CH-10-SECT-1.3"
>10.1.3 Reading Input from a Pipe</A
></H3
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="CH10.PIPE1"
></A
><A
CLASS="indexterm"
NAME="CH10.PIPE2"
></A
>You can execute a command and pipe the output into
<KBD
CLASS="command"
>getline</KBD
>.  For example, look at the following
expression:</P
><P
CLASS="para"
><BLOCKQUOTE
CLASS="screen"
><PRE
CLASS="screen"
>&quot;who am i&quot; | getline</PRE
></BLOCKQUOTE
></P
><P
CLASS="para"
>That expression sets &quot;$0&quot; to the output of the <KBD
CLASS="command"
>who am
i</KBD
> command.</P
><P
CLASS="para"
><BLOCKQUOTE
CLASS="screen"
><PRE
CLASS="screen"
>dale       ttyC3        Jul 18 13:37</PRE
></BLOCKQUOTE
></P
><P
CLASS="para"
>The line is parsed into fields and the system variable <KBD
CLASS="command"
>NF</KBD
>
is set.  Similarly, you can assign the result to a variable:</P
><P
CLASS="para"
><BLOCKQUOTE
CLASS="screen"
><PRE
CLASS="screen"
>&quot;who am i&quot; | getline me</PRE
></BLOCKQUOTE
></P
><P
CLASS="para"
>By assigning the output to a variable, you avoid
setting $0 and <B
CLASS="emphasis.bold"
>NF</B
>, but
the line is not split into fields.</P
><P
CLASS="para"
>The following script is a fairly simple example of piping the output
of a command to <KBD
CLASS="command"
>getline</KBD
>.  It uses the output from the
<KBD
CLASS="command"
>who am i</KBD
> command to get the user's name. It then looks up
the name in <I
CLASS="filename"
>/etc/passwd</I
>, printing out the fifth
field of that file, the user's full name:</P
><P
CLASS="para"
><BLOCKQUOTE
CLASS="screen"
><PRE
CLASS="screen"
>awk '# getname - print users fullname from /etc/passwd
BEGIN { &quot;who am i&quot; | getline 
	name = $1
	FS = &quot;:&quot;
}
name ~ $1 { print $5 }
' /etc/passwd</PRE
></BLOCKQUOTE
></P
><P
CLASS="para"
>The command is executed from the <KBD
CLASS="command"
>BEGIN</KBD
> procedure,
and it provides us with the name of the user that will be used to find
the user's entry in <I
CLASS="filename"
>/etc/passwd</I
>.  As explained
above, <KBD
CLASS="command"
>who am i</KBD
> outputs a single line, which
<KBD
CLASS="command"
>getline</KBD
> assigns to $0.  $1, the first field of that
output, is then assigned to <KBD
CLASS="command"
>name</KBD
>.</P
><P
CLASS="para"
>The field separator is set to a colon (:) to allow us to access
individual fields in entries in the <I
CLASS="filename"
>/etc/passwd</I
>
file.  Notice that <KBD
CLASS="command"
>FS</KBD
> is set after
<KBD
CLASS="command"
>getline</KBD
> or else the parsing of the command's output
would be affected.</P
><P
CLASS="para"
>Finally, the main procedure is designed to test that the
first field matches <KBD
CLASS="command"
>name</KBD
>.  If it does, the fifth
field of the entry is printed.  For instance, when Dale runs
this script, it prints &quot;Dale Dougherty.&quot;</P
><P
CLASS="para"
>When the output of a command is piped to <KBD
CLASS="command"
>getline</KBD
>
and it contains multiple lines, <KBD
CLASS="command"
>getline</KBD
> reads a
line at a time.  The first time <KBD
CLASS="command"
>getline</KBD
> is called
it reads the first line of output.  If you call it again, it reads the
second line.  To read all the lines of output, you must set up a loop
that executes <KBD
CLASS="command"
>getline</KBD
> until there is no more
output.  For instance, the following example uses a
<KBD
CLASS="command"
>while</KBD
> loop to read each line of output and assign
it to the next element of the array, <KBD
CLASS="command"
>who_out</KBD
>:</P
><P
CLASS="para"
><BLOCKQUOTE
CLASS="screen"
><PRE
CLASS="screen"
>while (&quot;who&quot; | getline)
	who_out[++i] = $0</PRE
></BLOCKQUOTE
></P
><P
CLASS="para"
>Each time the <KBD
CLASS="command"
>getline</KBD
> function is called, it reads
the next line of output.  The <KBD
CLASS="command"
>who</KBD
> command, however,
is executed only once.</P
><P
CLASS="para"
>The next example looks for &quot;@date&quot; in a document and replaces it with
today's date:</P
><P
CLASS="para"
><BLOCKQUOTE
CLASS="screen"
><PRE
CLASS="screen"
># subdate.awk -- replace @date with todays date
/@date/ {
	&quot;date +'%a., %h %d, %Y'&quot; | getline today
	gsub(/@date/, today)
}
{ print }</PRE
></BLOCKQUOTE
></P
><P
CLASS="para"
>The <KBD
CLASS="command"
>date</KBD
> command, using its formatting options,[2] 
provides the date and <KBD
CLASS="command"
>getline</KBD
> assigns it to the
variable <KBD
CLASS="command"
>today</KBD
>.  The
<KBD
CLASS="command"
>gsub()</KBD
> function replaces each instance of
&quot;@date&quot; with today's date.</P
><BLOCKQUOTE
CLASS="footnote"
><P
CLASS="para"
>[2] Older versions of <KBD
CLASS="command"
>date</KBD
> don't support formatting
options.  Particularly the one on SunOS 4.1.x systems; there you have
to use <I
CLASS="filename"
>/usr/5bin/date</I
>. Check your local
documentation.  </P
></BLOCKQUOTE
><P
CLASS="para"
>This script might be used to insert the
date in a form letter:</P
><P
CLASS="para"
><BLOCKQUOTE
CLASS="screen"
><PRE
CLASS="screen"
>To: Peabody
From: Sherman 
Date: @date

I am writing you on @date to 
remind you about our special offer.</PRE
></BLOCKQUOTE
></P
><P
CLASS="para"
>All lines of the input file would be passed through as is, except
the lines containing &quot;@date&quot;, which are replaced with
today's date:</P
><P
CLASS="para"
><BLOCKQUOTE
CLASS="screen"
><PRE
CLASS="screen"
>$ <CODE
CLASS="userinput"
><B
>awk -f subdate.awk subdate.test</B
></CODE
>
To: Peabody
From: Sherman
Date: Sun., May 05, 1996

I am writing you on Sun., May 05, 1996 to
remind you about our special offer.</PRE
></BLOCKQUOTE
></P
><A
CLASS="indexterm"
NAME="AUTOID-8364"
></A
><A
CLASS="indexterm"
NAME="AUTOID-8365"
></A
></DIV
><A
CLASS="indexterm"
NAME="AUTOID-8366"
></A
><A
CLASS="indexterm"
NAME="AUTOID-8367"
></A
><A
CLASS="indexterm"
NAME="AUTOID-8368"
></A
><A
CLASS="indexterm"
NAME="AUTOID-8369"
></A
></DIV
></DIV
><DIV
CLASS="htmlnav"
><P
></P
><HR
ALIGN="LEFT"
WIDTH="515"
TITLE="footer"><TABLE
WIDTH="515"
BORDER="0"
CELLSPACING="0"
CELLPADDING="0"
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="172"
><A
CLASS="SECT1"
HREF="ch09_03.htm"
TITLE="9.3 Writing Your Own Functions"
><IMG
SRC="../gifs/txtpreva.gif"
ALT="Previous: 9.3 Writing Your Own Functions"
BORDER="0"></A
></TD
><TD
ALIGN="CENTER"
VALIGN="TOP"
WIDTH="171"
><A
CLASS="book"
HREF="index.htm"
TITLE="sed &amp; awk"
><IMG
SRC="../gifs/txthome.gif"
ALT="sed &amp; awk"
BORDER="0"></A
></TD
><TD
ALIGN="RIGHT"
VALIGN="TOP"
WIDTH="172"
><A
CLASS="SECT1"
HREF="ch10_02.htm"
TITLE="10.2 The close() Function"
><IMG
SRC="../gifs/txtnexta.gif"
ALT="Next: 10.2 The close() Function"
BORDER="0"></A
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="172"
>9.3 Writing Your Own Functions</TD
><TD
ALIGN="CENTER"
VALIGN="TOP"
WIDTH="171"
><A
CLASS="index"
HREF="index/idx_0.htm"
TITLE="Book Index"
><IMG
SRC="../gifs/index.gif"
ALT="Book Index"
BORDER="0"></A
></TD
><TD
ALIGN="RIGHT"
VALIGN="TOP"
WIDTH="172"
>10.2 The close() Function</TD
></TR
></TABLE
><HR
ALIGN="LEFT"
WIDTH="515"
TITLE="footer"><IMG
SRC="../gifs/smnavbar.gif"
USEMAP="#map"
BORDER="0"
ALT="The UNIX CD Bookshelf Navigation"><MAP
NAME="map"
><AREA
SHAPE="RECT"
COORDS="0,0,73,21"
HREF="../index.htm"
ALT="The UNIX CD Bookshelf"><AREA
SHAPE="RECT"
COORDS="74,0,163,21"
HREF="../upt/index.htm"
ALT="UNIX Power Tools"><AREA
SHAPE="RECT"
COORDS="164,0,257,21"
HREF="../unixnut/index.htm"
ALT="UNIX in a Nutshell"><AREA
SHAPE="RECT"
COORDS="258,0,321,21"
HREF="../vi/index.htm"
ALT="Learning the vi Editor"><AREA
SHAPE="RECT"
COORDS="322,0,378,21"
HREF="index.htm"
ALT="sed &amp; awk"><AREA
SHAPE="RECT"
COORDS="379,0,438,21"
HREF="../ksh/index.htm"
ALT="Learning the Korn Shell"><AREA
SHAPE="RECT"
COORDS="439,0,514,21"
HREF="../lrnunix/index.htm"
ALT="Learning the UNIX Operating System"></MAP
></DIV
></BODY
></HTML
>
