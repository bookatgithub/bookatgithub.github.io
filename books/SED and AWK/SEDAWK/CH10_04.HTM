<HTML
><HEAD
>
<TITLE>[Chapter 10] 10.4 A Menu-Based Command Generator</TITLE>
<META
NAME="DC.title"
CONTENT="sed &amp; awk"><META
NAME="DC.creator"
CONTENT="Dale Dougherty &amp; Arnold Robbins"><META
NAME="DC.publisher"
CONTENT="O'Reilly &amp; Associates, Inc."><META
NAME="DC.date"
CONTENT="1998-08-03T21:01:42Z"><META
NAME="DC.type"
CONTENT="Text.Monograph"><META
NAME="DC.format"
CONTENT="text/html"
SCHEME="MIME"><META
NAME="DC.source"
CONTENT="1-56592-225-5"
SCHEME="ISBN"><META
NAME="DC.language"
CONTENT="en-US"><META
NAME="generator"
CONTENT="Jade 1.1/O'Reilly DocBook 3.0 to HTML 4.0"><LINK
REV="made"
HREF="mailto:online-books@oreilly.com"
TITLE="Online Books Comments"><LINK
REL="up"
HREF="ch10_01.htm"
TITLE="10. The Bottom Drawer"><LINK
REL="prev"
HREF="ch10_03.htm"
TITLE="10.3 The system() Function"><LINK
REL="next"
HREF="ch10_05.htm"
TITLE="10.5 Directing Output to Files and Pipes"></HEAD
><BODY
BGCOLOR="#FFFFFF"
TEXT="#000000"
><DIV
CLASS="htmlnav"
><H1
><IMG
SRC="gifs/smbanner.gif"
ALT="sed &amp; awk"
USEMAP="#srchmap"
BORDER="0"></H1
><MAP
NAME="srchmap"
><AREA
SHAPE="RECT"
COORDS="0,0,466,65"
HREF="index.htm"
ALT="sed &amp; awk"><AREA
SHAPE="RECT"
COORDS="467,0,514,18"
HREF="../search/ssrch.htm"
ALT="Search this book"></MAP
><TABLE
WIDTH="515"
BORDER="0"
CELLSPACING="0"
CELLPADDING="0"
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="172"
><A
CLASS="SECT1"
HREF="ch10_03.htm"
TITLE="10.3 The system() Function"
><IMG
SRC="../gifs/txtpreva.gif"
ALT="Previous: 10.3 The system() Function"
BORDER="0"></A
></TD
><TD
ALIGN="CENTER"
VALIGN="TOP"
WIDTH="171"
><B
><FONT
FACE="ARIEL,HELVETICA,HELV,SANSERIF"
SIZE="-1"
>Chapter 10<BR>The Bottom Drawer</FONT
></B
></TD
><TD
ALIGN="RIGHT"
VALIGN="TOP"
WIDTH="172"
><A
CLASS="SECT1"
HREF="ch10_05.htm"
TITLE="10.5 Directing Output to Files and Pipes"
><IMG
SRC="../gifs/txtnexta.gif"
ALT="Next: 10.5 Directing Output to Files and Pipes"
BORDER="0"></A
></TD
></TR
></TABLE
>&nbsp;<HR
ALIGN="LEFT"
WIDTH="515"
TITLE="footer"></DIV
><DIV
CLASS="SECT1"
><H2
CLASS="sect1"
><A
CLASS="title"
NAME="SEDAWK-CH-10-SECT-4"
>10.4 A Menu-Based Command Generator</A
></H2
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="CH10.GET8"
></A
><A
CLASS="indexterm"
NAME="CH10.COMM1"
></A
><A
CLASS="indexterm"
NAME="CH10.COMM2"
></A
>In this section, we look at a general use of the
<KBD
CLASS="command"
>system()</KBD
> and <KBD
CLASS="command"
>getline</KBD
>
functions to implement a menu-based command generator.  The object of
this program is to give unsophisticated users a simple way to execute
long or complex UNIX commands.  A menu is used to prompt the user with
a description of the task to be performed, allowing the user to choose
by number any selection of the menu to execute.</P
><P
CLASS="para"
>This program is designed as a kind of interpreter that reads from a
file the descriptions that appear in the menu and the actual command
lines that are executed.  That way, multiple menu-command files can be
used, and they can be easily modified by awk-less users without
changing the program.</P
><P
CLASS="para"
>The format of a menu-command file contains the menu title as the first
line in the file.  Subsequent lines contain two fields: the first is
the description of the action to be performed and the second is the
command line that performs it.  An example is shown below:</P
><P
CLASS="para"
><BLOCKQUOTE
CLASS="screen"
><PRE
CLASS="screen"
>$ <CODE
CLASS="userinput"
><B
>cat uucp_commands</B
></CODE
>
UUCP Status Menu
Look at files in PUBDIR:find /var/spool/uucppublic -print
Look at recent status in LOGFILE:tail /var/spool/uucp/LOGFILE
Look for lock files:ls /var/spool/uucp/*.LCK</PRE
></BLOCKQUOTE
></P
><P
CLASS="para"
>The first step in implementing the menu-based command generator is to
read the menu-command file.  We read the first line of this file and
assign it to a variable named <KBD
CLASS="command"
>title</KBD
>.  The rest of
the lines contain two fields and are read into two arrays, one for the
menu items and one for the commands to be executed.  A
<KBD
CLASS="command"
>while</KBD
> loop is used, along with
<KBD
CLASS="command"
>getline</KBD
>, to read one line at a time from the file.</P
><P
CLASS="para"
><BLOCKQUOTE
CLASS="screen"
><PRE
CLASS="screen"
>BEGIN { FS = &quot;:&quot;
if ((getline &lt; CMDFILE) &gt; 0)
	title = $1
else
	exit 1
while ((getline &lt; CMDFILE) &gt; 0) {
	# load array
	++sizeOfArray
	# array of menu items
	menu[sizeOfArray] = $1
	# array of commands associated with items
	command[sizeOfArray] = $2
	} 
...
}</PRE
></BLOCKQUOTE
></P
><P
CLASS="para"
>Look carefully at the syntax of the expression tested by the
<KBD
CLASS="command"
>if</KBD
> statement and the <KBD
CLASS="command"
>while</KBD
> loop.</P
><P
CLASS="para"
><BLOCKQUOTE
CLASS="screen"
><PRE
CLASS="screen"
>(getline &lt; CMDFILE) &gt; 0</PRE
></BLOCKQUOTE
></P
><P
CLASS="para"
>The variable <KBD
CLASS="command"
>CMDFILE</KBD
> is the name of the
menu-command file, which is passed as a command-line parameter.  The
two angle-bracket symbols have completely different functions.  The
&quot;&lt;&quot; symbol is interpreted by <KBD
CLASS="command"
>getline</KBD
> as the
input redirection operator.  Then the value returned by
<KBD
CLASS="command"
>getline</KBD
> is tested to see if it is greater than
(&quot;&gt;&quot;) 0.  It is parenthesized on purpose, in order to make this
clear.  In other words, &quot;getline &lt; <KBD
CLASS="command"
>CMDFILE</KBD
>&quot; is
evaluated first and then its return value is compared to 0.</P
><P
CLASS="para"
>This procedure is placed in the <KBD
CLASS="command"
>BEGIN</KBD
> pattern.
However, there is one catch.  Because we intended to pass the name of
the menu file as a command-line parameter, the variable
<KBD
CLASS="command"
>CMDFILE</KBD
> would not normally be defined and available
in the <KBD
CLASS="command"
>BEGIN</KBD
> pattern.  In other words, the
following command will <EM
CLASS="emphasis"
>not</EM
> work:</P
><BLOCKQUOTE
CLASS="literallayout"
><P
CLASS="literallayout"
><CODE
CLASS="literal"
>awk</CODE
> <CODE
CLASS="replaceable"
><I
>script</I
></CODE
> <CODE
CLASS="literal"
>CMDFILE=&quot;uucp_commands&quot;</CODE
> <CODE
CLASS="literal"
>-</CODE
></P
></BLOCKQUOTE
><P
CLASS="para"
>because <KBD
CLASS="command"
>CMDFILE</KBD
> variable won't be defined until the
first line of input is read. </P
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-8511"
></A
>Fortunately, awk provides the <I
CLASS="option"
>-v</I
> option to handle
just such a case.  Using the <I
CLASS="option"
>-v</I
> option makes sure
that the variable is set immediately and thus available in the
<KBD
CLASS="command"
>BEGIN</KBD
> pattern.</P
><BLOCKQUOTE
CLASS="literallayout"
><P
CLASS="literallayout"
><CODE
CLASS="literal"
>awk -v CMDFILE=&quot;uucp_commands&quot;</CODE
> <CODE
CLASS="replaceable"
><I
>script</I
></CODE
></P
></BLOCKQUOTE
><P
CLASS="para"
>If your version of awk doesn't have the <I
CLASS="option"
>-v</I
> option,
you can pass the value of <KBD
CLASS="command"
>CMDFILE</KBD
> as a shell
variable.  Create a shell script to execute awk and in it define
<KBD
CLASS="command"
>CMDFILE</KBD
>.  Then change the line that reads
<KBD
CLASS="command"
>CMDFILE</KBD
> in the <KBD
CLASS="command"
>invoke</KBD
> script
(see below) as follows:</P
><BLOCKQUOTE
CLASS="screen"
><PRE
CLASS="screen"
>while ((getline &lt; '&quot;$CMDFILE&quot;') &gt; 0 ) {</PRE
></BLOCKQUOTE
><P
CLASS="para"
>Once the menu-command file is loaded, the program must display the
menu and prompt the user.  This is implemented as a function because
we need to call it in two places: from the <KBD
CLASS="command"
>BEGIN</KBD
>
pattern to prompt the user initially, and after we have processed the
user's response so that another choice can be made.  Here's the
<KBD
CLASS="command"
>display_menu()</KBD
> function:</P
><P
CLASS="para"
><BLOCKQUOTE
CLASS="screen"
><PRE
CLASS="screen"
>function display_menu() {
	# clear screen -- comment out if clear does not work
	system(&quot;clear&quot;)
	# print title, list of items, exit item, and prompt
	print &quot;\t&quot; title
	for (i = 1; i &lt;= sizeOfArray; ++i)
		printf &quot;\t%d. %s\n&quot;, i, menu[i]
	printf &quot;\t%d. Exit\n&quot;, i
	printf(&quot;Choose one: &quot;)
}</PRE
></BLOCKQUOTE
></P
><P
CLASS="para"
>The first thing we do is use the <KBD
CLASS="command"
>system()</KBD
>
function to call a command to clear the screen. (On my system,
<KBD
CLASS="command"
>clear</KBD
> does this; on others it may be
<KBD
CLASS="command"
>cls</KBD
> or some other command. Comment out the line if
you cannot find such a command.)  Then we print the title and each of
the items in a numbered list.  The last item is always &quot;Exit.&quot;
Finally, we prompt the user for a choice.</P
><P
CLASS="para"
>The program will take standard input so that the user's answer to the
prompt will be the first line of input.  Our reading of the
menu-command file was done within the program and not as part of the
input stream.  Thus, the main procedure of the program is to respond
to the user's choice and execute a command.  Here's that part of the
program:</P
><P
CLASS="para"
><BLOCKQUOTE
CLASS="screen"
><PRE
CLASS="screen"
># Applies the user response to prompt
{
   # test value of user response
   if ($1 &gt; 0 &amp;&amp; $1 &lt;= sizeOfArray) {
	# print command that is executed
	printf(&quot;Executing ... %s\n&quot;, command[$1]) 
	# then execute it. 
	system(command[$1])
	printf(&quot;&lt;Press RETURN to continue&gt;&quot;)
 	# wait for input before displaying menu again
	getline
   }
   else 
	exit	
   # re-display menu 
   display_menu()
}</PRE
></BLOCKQUOTE
></P
><P
CLASS="para"
>First, we test the range of the user's response.  If the response
falls outside the range, we simply exit the program.  If it is a valid
response, then we retrieve the command from the array
<KBD
CLASS="command"
>command</KBD
>, display it, and then execute it using the
<KBD
CLASS="command"
>system()</KBD
> function.  The user sees the
result of the command on the screen followed by the message &quot;&lt;Press
RETURN to continue&gt;.&quot;  The purpose of this message is to wait for
the user to finish before clearing the screen and redisplaying the
menu.  The <KBD
CLASS="command"
>getline</KBD
> function causes the program to
wait for a response.  Note that we don't do anything with the
response.  The <KBD
CLASS="command"
>display_menu()</KBD
> function is
called at the end of this procedure to redisplay the menu and prompt
for another line of input.</P
><P
CLASS="para"
>Here's the <KBD
CLASS="command"
>invoke</KBD
> program in full:</P
><P
CLASS="para"
><BLOCKQUOTE
CLASS="screen"
><PRE
CLASS="screen"
>awk -v CMDFILE=&quot;uucp_commands&quot;  '# invoke -- menu-based
                                  # command generator
# first line in CMDFILE is the title of the menu
# subsequent lines contain: $1 - Description;
# $2 Command to execute
BEGIN { FS = &quot;:&quot; 
# process CMDFILE, reading items into menu array 
  if ((getline &lt; CMDFILE) &gt; 0)
	title = $1
  else
	exit 1
  while ((getline &lt; CMDFILE) &gt; 0) {
	# load array
	++sizeOfArray
	# array of menu items
	menu[sizeOfArray] = $1
	# array of commands associated with items
	command[sizeOfArray] = $2
  } 
  # call function to display menu items and prompt
  display_menu()
}
# Applies the user response to prompt
{
   # test value of user response
   if ($1 &gt; 0 &amp;&amp; $1 &lt;= sizeOfArray) {
	# print command that is executed
	printf(&quot;Executing ... %s\n&quot;, command[$1]) 
	# then execute it. 
	system(command[$1])
	printf(&quot;&lt;Press RETURN to continue&gt;&quot;)
 	# wait for input before displaying menu again
	getline
   }
   else 
	exit	
   # re-display menu 
   display_menu()
}
function display_menu() {
	# clear screen -- if clear does not work, try &quot;cls&quot;
	system(&quot;clear&quot;)
	# print title, list of items, exit item, and prompt
	print &quot;\t&quot; title
	for (i = 1; i &lt;= sizeOfArray; ++i)
		printf &quot;\t%d. %s\n&quot;, i, menu[i]
	printf &quot;\t%d. Exit\n&quot;, i
	printf(&quot;Choose one: &quot;)
}' -</PRE
></BLOCKQUOTE
></P
><P
CLASS="para"
>When a user runs the program, the following output is displayed:</P
><P
CLASS="para"
><BLOCKQUOTE
CLASS="screen"
><PRE
CLASS="screen"
>UUCP Status Menu
        1. Look at files in PUBDIR
        2. Look at recent status in LOGFILE
        3. Look for lock files
        4. Exit
Choose one:</PRE
></BLOCKQUOTE
></P
><P
CLASS="para"
>The user is prompted to enter the number of a menu selection.
Anything other than a number between 1 and 3 exits the menu.  For
instance, if the user enters &quot;1&quot; to see a list of files in
<EM
CLASS="emphasis"
>uucp</EM
>'s public directory, then the following
result is displayed on the screen:</P
><P
CLASS="para"
><BLOCKQUOTE
CLASS="screen"
><PRE
CLASS="screen"
>Executing ...find /var/spool/uucppublic -print
/var/spool/uucppublic
/var/spool/uucppublic/dale
/var/spool/uucppublic/HyperBugs
&lt;Press RETURN to continue&gt;</PRE
></BLOCKQUOTE
></P
><P
CLASS="para"
>When the user presses the RETURN key, the menu is
redisplayed on the screen.  The user can quit from the program by
choosing &quot;4&quot;.</P
><P
CLASS="para"
>This program is really a shell for executing commands.  Any sequence
of commands (even other awk programs) can be executed by modifying the
menu-command file.  In other words, the part of the program that might
change the most is extracted from the program itself and maintained in
a separate file.  This allows the menu list to be changed and extended
very easily by a nontechnical user.</P
><A
CLASS="indexterm"
NAME="AUTOID-8556"
></A
><A
CLASS="indexterm"
NAME="AUTOID-8557"
></A
><A
CLASS="indexterm"
NAME="AUTOID-8558"
></A
><A
CLASS="indexterm"
NAME="AUTOID-8559"
></A
></DIV
><DIV
CLASS="htmlnav"
><P
></P
><HR
ALIGN="LEFT"
WIDTH="515"
TITLE="footer"><TABLE
WIDTH="515"
BORDER="0"
CELLSPACING="0"
CELLPADDING="0"
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="172"
><A
CLASS="SECT1"
HREF="ch10_03.htm"
TITLE="10.3 The system() Function"
><IMG
SRC="../gifs/txtpreva.gif"
ALT="Previous: 10.3 The system() Function"
BORDER="0"></A
></TD
><TD
ALIGN="CENTER"
VALIGN="TOP"
WIDTH="171"
><A
CLASS="book"
HREF="index.htm"
TITLE="sed &amp; awk"
><IMG
SRC="../gifs/txthome.gif"
ALT="sed &amp; awk"
BORDER="0"></A
></TD
><TD
ALIGN="RIGHT"
VALIGN="TOP"
WIDTH="172"
><A
CLASS="SECT1"
HREF="ch10_05.htm"
TITLE="10.5 Directing Output to Files and Pipes"
><IMG
SRC="../gifs/txtnexta.gif"
ALT="Next: 10.5 Directing Output to Files and Pipes"
BORDER="0"></A
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="172"
>10.3 The system() Function</TD
><TD
ALIGN="CENTER"
VALIGN="TOP"
WIDTH="171"
><A
CLASS="index"
HREF="index/idx_0.htm"
TITLE="Book Index"
><IMG
SRC="../gifs/index.gif"
ALT="Book Index"
BORDER="0"></A
></TD
><TD
ALIGN="RIGHT"
VALIGN="TOP"
WIDTH="172"
>10.5 Directing Output to Files and Pipes</TD
></TR
></TABLE
><HR
ALIGN="LEFT"
WIDTH="515"
TITLE="footer"><IMG
SRC="../gifs/smnavbar.gif"
USEMAP="#map"
BORDER="0"
ALT="The UNIX CD Bookshelf Navigation"><MAP
NAME="map"
><AREA
SHAPE="RECT"
COORDS="0,0,73,21"
HREF="../index.htm"
ALT="The UNIX CD Bookshelf"><AREA
SHAPE="RECT"
COORDS="74,0,163,21"
HREF="../upt/index.htm"
ALT="UNIX Power Tools"><AREA
SHAPE="RECT"
COORDS="164,0,257,21"
HREF="../unixnut/index.htm"
ALT="UNIX in a Nutshell"><AREA
SHAPE="RECT"
COORDS="258,0,321,21"
HREF="../vi/index.htm"
ALT="Learning the vi Editor"><AREA
SHAPE="RECT"
COORDS="322,0,378,21"
HREF="index.htm"
ALT="sed &amp; awk"><AREA
SHAPE="RECT"
COORDS="379,0,438,21"
HREF="../ksh/index.htm"
ALT="Learning the Korn Shell"><AREA
SHAPE="RECT"
COORDS="439,0,514,21"
HREF="../lrnunix/index.htm"
ALT="Learning the UNIX Operating System"></MAP
></DIV
></BODY
></HTML
>
