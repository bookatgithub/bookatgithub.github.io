<HTML
><HEAD
>
<TITLE>[Chapter 12] Full-Featured Applications</TITLE>
<META
NAME="DC.title"
CONTENT="sed &amp; awk"><META
NAME="DC.creator"
CONTENT="Dale Dougherty &amp; Arnold Robbins"><META
NAME="DC.publisher"
CONTENT="O'Reilly &amp; Associates, Inc."><META
NAME="DC.date"
CONTENT="1998-08-03T21:03:37Z"><META
NAME="DC.type"
CONTENT="Text.Monograph"><META
NAME="DC.format"
CONTENT="text/html"
SCHEME="MIME"><META
NAME="DC.source"
CONTENT="1-56592-225-5"
SCHEME="ISBN"><META
NAME="DC.language"
CONTENT="en-US"><META
NAME="generator"
CONTENT="Jade 1.1/O'Reilly DocBook 3.0 to HTML 4.0"><LINK
REV="made"
HREF="mailto:online-books@oreilly.com"
TITLE="Online Books Comments"><LINK
REL="up"
HREF="index.htm"
TITLE="sed &amp; awk"><LINK
REL="prev"
HREF="ch11_04.htm"
TITLE="11.4 Epilogue"><LINK
REL="next"
HREF="ch12_02.htm"
TITLE="12.2 Generating a Formatted Index"></HEAD
><BODY
BGCOLOR="#FFFFFF"
TEXT="#000000"
><DIV
CLASS="htmlnav"
><H1
><IMG
SRC="gifs/smbanner.gif"
ALT="sed &amp; awk"
USEMAP="#srchmap"
BORDER="0"></H1
><MAP
NAME="srchmap"
><AREA
SHAPE="RECT"
COORDS="0,0,466,65"
HREF="index.htm"
ALT="sed &amp; awk"><AREA
SHAPE="RECT"
COORDS="467,0,514,18"
HREF="../search/ssrch.htm"
ALT="Search this book"></MAP
><TABLE
WIDTH="515"
BORDER="0"
CELLSPACING="0"
CELLPADDING="0"
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="172"
><A
CLASS="SECT1"
HREF="ch11_04.htm"
TITLE="11.4 Epilogue"
><IMG
SRC="../gifs/txtpreva.gif"
ALT="Previous: 11.4 Epilogue"
BORDER="0"></A
></TD
><TD
ALIGN="CENTER"
VALIGN="TOP"
WIDTH="171"
><B
><FONT
FACE="ARIEL,HELVETICA,HELV,SANSERIF"
SIZE="-1"
>Chapter 12</FONT
></B
></TD
><TD
ALIGN="RIGHT"
VALIGN="TOP"
WIDTH="172"
><A
CLASS="SECT1"
HREF="ch12_02.htm"
TITLE="12.2 Generating a Formatted Index"
><IMG
SRC="../gifs/txtnexta.gif"
ALT="Next: 12.2 Generating a Formatted Index"
BORDER="0"></A
></TD
></TR
></TABLE
>&nbsp;<HR
ALIGN="LEFT"
WIDTH="515"
TITLE="footer"></DIV
><DIV
CLASS="CHAPTER"
><H1
CLASS="chapter"
><A
CLASS="title"
NAME="SEDAWK-CH-12"
>12. Full-Featured Applications</A
></H1
><DIV
CLASS="htmltoc"
><P
><B
>Contents:</B
><BR><A
CLASS="sect1"
HREF="#SEDAWK-CH-12-SECT-1"
TITLE="12.1 An Interactive Spelling Checker"
>An Interactive Spelling Checker</A
><BR><A
CLASS="sect1"
HREF="ch12_02.htm"
TITLE="12.2 Generating a Formatted Index"
>Generating a Formatted Index</A
><BR><A
CLASS="sect1"
HREF="ch12_03.htm"
TITLE="12.3 Spare Details of the masterindex Program"
>Spare Details of the masterindex Program</A
></P
><P
></P
></DIV
><P
CLASS="para"
>This chapter presents two complex applications that integrate most
features of the awk programming language.  The first program,
<KBD
CLASS="command"
>spellcheck</KBD
>, provides an interactive interface to
the UNIX <KBD
CLASS="command"
>spell</KBD
> program.  The second application,
<KBD
CLASS="command"
>masterindex</KBD
>, is a batch program for generating an
index for a book or a set of books.  Even if you are not interested in
the particular application, you should study these larger programs to
get a feel for the scope of the problems that an awk program can
solve.</P
><DIV
CLASS="sect1"
><H2
CLASS="sect1"
><A
CLASS="title"
NAME="SEDAWK-CH-12-SECT-1"
>12.1 An Interactive Spelling Checker</A
></H2
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="CH12.SPELL"
></A
><A
CLASS="indexterm"
NAME="CH12.SPELL2"
></A
>The UNIX <KBD
CLASS="command"
>spell</KBD
> program does an adequate job of
catching spelling errors in a document.  For most people, however, it
only does half the job.  It doesn't help you correct the misspelled
words.  First-time users of <KBD
CLASS="command"
>spell</KBD
> find themselves
jotting down the misspelled words and then using the text editor to
change the document.  More skilled users build a sed script to make
the changes automatically.</P
><P
CLASS="para"
>The <KBD
CLASS="command"
>spellcheck</KBD
> program
offers another way&nbsp;- it shows you each word that
<KBD
CLASS="command"
>spell</KBD
> has found and asks if you want to correct the
word.  You can change each occurrence of the word after seeing the
line on which it occurs, or you can correct the spelling error
globally.  You can also choose to add any word that
<KBD
CLASS="command"
>spell</KBD
> turns up to a local dictionary file.</P
><P
CLASS="para"
>Before describing the program, let's have a demonstration of how it
works.  The user enters <KBD
CLASS="command"
>spellcheck</KBD
>, a shell script
that invokes awk, and the name of the document file.</P
><P
CLASS="para"
><BLOCKQUOTE
CLASS="screen"
><PRE
CLASS="screen"
>$ <CODE
CLASS="userinput"
><B
>spellcheck ch00</B
></CODE
>
Use local dict file? (y/n)<CODE
CLASS="userinput"
><B
>y</B
></CODE
></PRE
></BLOCKQUOTE
></P
><P
CLASS="para"
>If a dictionary file is not specified on the command line, and a file
named <I
CLASS="filename"
>dict</I
> exists in the current directory, then
the user is asked if the local dictionary should be used.
<KBD
CLASS="command"
>spellcheck</KBD
> then runs <KBD
CLASS="command"
>spell</KBD
> using
the local dictionary.</P
><P
CLASS="para"
><BLOCKQUOTE
CLASS="screen"
><PRE
CLASS="screen"
>Running spell checker ...</PRE
></BLOCKQUOTE
></P
><P
CLASS="para"
>Using the list of &quot;misspelled&quot; words turned up by
<KBD
CLASS="command"
>spell</KBD
>, <KBD
CLASS="command"
>spellcheck</KBD
> prompts the
user to correct them.  Before the first word is displayed, a list of
responses is shown that describes what actions are possible.</P
><P
CLASS="para"
><BLOCKQUOTE
CLASS="screen"
><PRE
CLASS="screen"
>Responses: 
	Change each occurrence, 
	Global change, 
	Add to Dict, 
	Help, 
	Quit 
	CR to ignore: 
1 - Found SparcStation (C/G/A/H/Q/):<KBD
CLASS="command"
>a</KBD
></PRE
></BLOCKQUOTE
></P
><P
CLASS="para"
>The first word found by <KBD
CLASS="command"
>spell</KBD
> is &quot;SparcStation.&quot;  A
response of &quot;a&quot; (followed by a carriage return) adds this word to a
list that will be used to update the dictionary.  The second word is
clearly a misspelling and a response of &quot;g&quot; is entered to make the
change globally:</P
><P
CLASS="para"
><BLOCKQUOTE
CLASS="screen"
><PRE
CLASS="screen"
>2 - Found languauge (C/G/A/H/Q/):<CODE
CLASS="userinput"
><B
>g</B
></CODE
>
Globally change to:<CODE
CLASS="userinput"
><B
>language</B
></CODE
>
Globally change languauge to language? (y/n):<CODE
CLASS="userinput"
><B
>y</B
></CODE
>
&gt; and a full description of its scripting language. 
1 lines changed. Save changes? (y/n)<CODE
CLASS="userinput"
><B
>y</B
></CODE
></PRE
></BLOCKQUOTE
></P
><P
CLASS="para"
>After prompting the user to enter the correct spelling and confirming
the entry, the change is made and each line affected is displayed,
preceded by a &quot;&gt;&quot;.  The user is then asked to approve these changes
before they are saved.  The third word is also added to the
dictionary:</P
><P
CLASS="para"
><BLOCKQUOTE
CLASS="screen"
><PRE
CLASS="screen"
>3 - Found nawk (C/G/A/H/Q/):<CODE
CLASS="userinput"
><B
>a</B
></CODE
></PRE
></BLOCKQUOTE
></P
><P
CLASS="para"
>The fourth word is a misspelling of &quot;utilities.&quot;  </P
><P
CLASS="para"
><BLOCKQUOTE
CLASS="screen"
><PRE
CLASS="screen"
>4 - Found utlitities (C/G/A/H/Q/):<CODE
CLASS="userinput"
><B
>c</B
></CODE
>
These utlitities have many things in common, including
      ^^^^^^^^^^
Change to:<CODE
CLASS="userinput"
><B
>utilities</B
></CODE
>
Change utlitities to utilities? (y/n):<CODE
CLASS="userinput"
><B
>y</B
></CODE
>
Two other utlitities that are found on the UNIX system
          ^^^^^^^^^^
Change utlitities to utilities? (y/n):<CODE
CLASS="userinput"
><B
>y</B
></CODE
>
&gt;These utilities have many things in common, including
&gt;Two other utilities that are found on the UNIX system
2 lines changed. Save changes? (y/n)<CODE
CLASS="userinput"
><B
>y</B
></CODE
></PRE
></BLOCKQUOTE
></P
><P
CLASS="para"
>The user enters &quot;c&quot; to change each occurrence.  This response allows
the user to see the line containing the misspelling and then make the
change.  After the user has made each change, the changed lines are
displayed and the user is asked to confirm saving the changes.</P
><P
CLASS="para"
>It is unclear whether the fifth word is a misspelling or not, so the
user enters &quot;c&quot; to view the line.</P
><P
CLASS="para"
><BLOCKQUOTE
CLASS="screen"
><PRE
CLASS="screen"
>5 - Found xvf (C/G/A/H/Q/):<CODE
CLASS="userinput"
><B
>c</B
></CODE
>
tar xvf filename
    ^^^
Change to:<CODE
CLASS="userinput"
><B
>RETURN</B
></CODE
></PRE
></BLOCKQUOTE
></P
><P
CLASS="para"
>After determining that it is not a misspelling, the user enters a
carriage return to ignore the word.  Generally,
<KBD
CLASS="command"
>spell</KBD
> turns up a lot of words that are not
misspellings so a carriage return means to ignore the word.</P
><P
CLASS="para"
>After all the words in the list have been processed, or if the user
quits before then, the user is prompted to save the changes made to
the document and the dictionary.</P
><P
CLASS="para"
><BLOCKQUOTE
CLASS="screen"
><PRE
CLASS="screen"
>Save corrections in ch00 (y/n)? <CODE
CLASS="userinput"
><B
>y</B
></CODE
>
Make changes to dictionary (y/n)? <CODE
CLASS="userinput"
><B
>y</B
></CODE
></PRE
></BLOCKQUOTE
></P
><P
CLASS="para"
>If the user answers &quot;n,&quot; the original file and the dictionary are left
unchanged.</P
><P
CLASS="para"
>Now let's look at the <KBD
CLASS="command"
>spellcheck.awk</KBD
> script, which
can be divided into four sections:</P
><UL
CLASS="itemizedlist"
><LI
CLASS="listitem"
><P
CLASS="para"
> The <KBD
CLASS="command"
>BEGIN</KBD
> procedure, that
processes the command-line arguments and executes the
<KBD
CLASS="command"
>spell</KBD
> command to create a word list.</P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>The main procedure, that reads one word at a time from the list and
prompts the user to make a correction.</P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>The <KBD
CLASS="command"
>END</KBD
> procedure, that saves the working copy of
the file, overwriting the original.  It also appends words from the
exception list to the current dictionary.  </P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>Supporting functions, that are called to make changes in the file.</P
></LI
></UL
><P
CLASS="para"
>We will look at each of these sections of the program.</P
><DIV
CLASS="sect2"
><H3
CLASS="sect2"
><A
CLASS="title"
NAME="SEDAWK-CH-12-SECT-1.1"
>12.1.1 BEGIN Procedure</A
></H3
><P
CLASS="para"
>The <KBD
CLASS="command"
>BEGIN</KBD
> procedure for
<KBD
CLASS="command"
>spellcheck.awk</KBD
> is large.  It is also somewhat
unusual.</P
><P
CLASS="para"
><BLOCKQUOTE
CLASS="screen"
><PRE
CLASS="screen"
># spellcheck.awk -- interactive spell checker
#
# AUTHOR: Dale Dougherty
#
# Usage: nawk -f spellcheck.awk [+dict] file 
# (Use spellcheck as name of shell program) 
# SPELLDICT = &quot;dict&quot; 
# SPELLFILE = &quot;file&quot;

# BEGIN actions perform the following tasks: 
#	1) process command-line arguments
#	2) create temporary filenames
#	3) execute spell program to create wordlist file
#	4) display list of user responses

BEGIN { 
# Process command-line arguments
# Must be at least two args -- nawk and filename
	if (ARGC &gt; 1) {
	# if more than two args, second arg is dict 
		if (ARGC &gt; 2) {
		# test to see if dict is specified with &quot;+&quot;  
		# and assign ARGV[1] to SPELLDICT
			if (ARGV[1] ~ /^\+.*/) 
				SPELLDICT = ARGV[1]
			else 
				SPELLDICT = &quot;+&quot; ARGV[1]
		# assign file ARGV[2] to SPELLFILE 
			SPELLFILE = ARGV[2]
		# delete args so awk does not open them as files
			delete ARGV[1]
			delete ARGV[2]
		}
	# not more than two args
		else {
		# assign file ARGV[1] to SPELLFILE 
			SPELLFILE = ARGV[1]
		# test to see if local dict file exists
			if (! system (&quot;test -r dict&quot;)) {
			# if it does, ask if we should use it
				printf (&quot;Use local dict file? (y/n)&quot;)	
				getline reply &lt; &quot;-&quot;
			# if reply is yes, use &quot;dict&quot; 
				if (reply ~ /[yY](es)?/){
					SPELLDICT = &quot;+dict&quot;
				}
			}
		}
	} # end of processing args &gt; 1 
	# if args not &gt; 1, then print shell-command usage 
	else {
		print &quot;Usage: spellcheck [+dict] file&quot;
		exit 1
	}
# end of processing command line arguments
# create temporary file names, each begin with sp_
	wordlist = &quot;sp_wordlist&quot;
	spellsource = &quot;sp_input&quot;
	spellout = &quot;sp_out&quot;

# copy SPELLFILE to temporary input file
	system(&quot;cp &quot; SPELLFILE &quot; &quot; spellsource)

# now run spell program; output sent to wordlist
	print &quot;Running spell checker ...&quot;
	if (SPELLDICT)
		SPELLCMD = &quot;spell &quot; SPELLDICT &quot; &quot;
	else
		SPELLCMD = &quot;spell &quot;
	system(SPELLCMD spellsource &quot; &gt; &quot; wordlist )

# test wordlist to see if misspelled words turned up
	if ( system(&quot;test -s &quot; wordlist ) ) {
	# if wordlist is empty (or spell command failed), exit
		print &quot;No misspelled words found.&quot;
		system(&quot;rm &quot; spellsource &quot; &quot; wordlist)
		exit
	}	

# assign wordlist file to ARGV[1] so that awk will read it.	
	ARGV[1] = wordlist

# display list of user responses 
	responseList = &quot;Responses: \n\tChange each occurrence,&quot; 
	responseList = responseList &quot;\n\tGlobal change,&quot; 
	responseList = responseList &quot;\n\tAdd to Dict,&quot;  
	responseList = responseList &quot;\n\tHelp,&quot; 
	responseList = responseList &quot;\n\tQuit&quot; 
	responseList = responseList &quot;\n\tCR to ignore: &quot;
	printf(&quot;%s&quot;, responseList)

} # end of BEGIN procedure</PRE
></BLOCKQUOTE
></P
><P
CLASS="para"
>The first part of the <KBD
CLASS="command"
>BEGIN</KBD
> procedure processes the
command-line arguments.  It checks that <KBD
CLASS="command"
>ARGC</KBD
> is
greater than one for the program to continue.  That is, in addition to
&quot;nawk,&quot; a filename must be specified.  This file specifies the
document that <KBD
CLASS="command"
>spell</KBD
> will analyze.  An optional
dictionary filename can be specified as the second argument.  The
<KBD
CLASS="command"
>spellcheck</KBD
> script follows the command-line
interface of <KBD
CLASS="command"
>spell</KBD
>, although none of the obscure
<KBD
CLASS="command"
>spell</KBD
> options can be invoked from the
<KBD
CLASS="command"
>spellcheck</KBD
> command line.  If a dictionary is not
specified, then the script executes a <KBD
CLASS="command"
>test</KBD
> command
to see if the file <I
CLASS="filename"
>dict</I
> exists.  If it does, the
prompt asks the user to approve using it as the dictionary file.</P
><P
CLASS="para"
>Once we've processed the arguments, we delete them from the
<KBD
CLASS="command"
>ARGV</KBD
> array.  This is to prevent their being
interpreted as filename arguments.</P
><P
CLASS="para"
>The second part of the <KBD
CLASS="command"
>BEGIN</KBD
> procedure sets up some
temporary files, because we do not want to work directly with the
original file.  At the end of the program, the user will have the
option of saving or discarding the work done in the temporary files.
The temporary files all begin with &quot;sp_&quot; and are removed before
exiting the program.</P
><P
CLASS="para"
>The third part of the procedure executes <KBD
CLASS="command"
>spell</KBD
> and
creates a word list.  We test to see that this file exists and that
there is something in it before proceeding.  If for some reason the
<KBD
CLASS="command"
>spell</KBD
> program fails, or there are no misspelled
words found, the <KBD
CLASS="command"
>wordlist</KBD
> file will be empty.  If
this file does exist, then we assign the filename as the second
element in the <KBD
CLASS="command"
>ARGV</KBD
> array.  This is an unusual but
valid way of supplying the name of the input file that awk will
process.  Note that this file did not exist when awk was invoked!  The
name of the document file, which was specified on the command line, is
no longer in the <KBD
CLASS="command"
>ARGV</KBD
> array.  We will not read the
document file using awk's main input loop.  Instead, a
<KBD
CLASS="command"
>while</KBD
> loop reads the file to find and correct
misspelled words.</P
><P
CLASS="para"
>The last task in the <KBD
CLASS="command"
>BEGIN</KBD
> procedure is to define
and display a list of responses that the user can enter when a
misspelled word is displayed.  This list is displayed once at the
beginning of the program as well as when the user enters &quot;Help&quot; at the
main prompt.  Putting this list in a variable allows us to access it
from different points in the program, if necessary, without
maintaining duplicates.  The assignment of
<KBD
CLASS="command"
>responseList</KBD
> could be done more simply, but the
long string would not be printable in this book.  (You can't break a
string over two lines.)</P
></DIV
><DIV
CLASS="sect2"
><H3
CLASS="sect2"
><A
CLASS="title"
NAME="SEDAWK-CH-12-SECT-1.2"
>12.1.2 Main Procedure</A
></H3
><P
CLASS="para"
>The main procedure is rather small, merely displaying a misspelled
word and prompting the user to enter an appropriate response.
This procedure is executed for each misspelled word. </P
><P
CLASS="para"
>One reason this procedure is short is because the central
action&nbsp;- correcting a misspelled word&nbsp;- is handled by two
larger user-defined functions, which we'll see in the last section.</P
><P
CLASS="para"
><BLOCKQUOTE
CLASS="screen"
><PRE
CLASS="screen"
># main procedure, executed for each line in wordlist.
#	Purpose is to show misspelled word and prompt user
#	for appropriate action.

{
# assign word to misspelling
	misspelling = $1 
	response = 1
	++word
# print misspelling and prompt for response
	while (response !~ /(^[cCgGaAhHqQ])|^$/ ) {
		printf(&quot;\n%d - Found %s (C/G/A/H/Q/):&quot;, word, misspelling)
		getline response &lt; &quot;-&quot;
	}
# now process the user's response
# CR - carriage return ignores current word 
# Help
	if (response ~ /[Hh](elp)?/) {
	# Display list of responses and prompt again.
		printf(&quot;%s&quot;, responseList)
		printf(&quot;\n%d - Found %s (C/G/A/Q/):&quot;, word, misspelling)
		getline response &lt; &quot;-&quot;
	}
# Quit
	if (response ~ /[Qq](uit)?/) exit
# Add to dictionary
	if ( response ~ /[Aa](dd)?/) { 
		dict[++dictEntry] = misspelling
	}
# Change each occurrence
	if ( response ~ /[cC](hange)?/) {
	# read each line of the file we are correcting
		newspelling = &quot;&quot;; changes = &quot;&quot;
		while( (getline &lt; spellsource) &gt; 0){
		# call function to show line with misspelled word
		# and prompt user to make each correction 
			make_change($0)
		# all lines go to temp output file
			print &gt; spellout
		}	
	# all lines have been read 
	# close temp input and temp output file
		close(spellout)
		close(spellsource)
	# if change was made
		if (changes){ 
		# show changed lines
			for (j = 1; j &lt;= changes; ++j)
				print changedLines[j]
			printf (&quot;%d lines changed. &quot;, changes) 
		# function to confirm before saving changes
			confirm_changes()
		}
	}
# Globally change
	if ( response ~ /[gG](lobal)?/) {
	# call function to prompt for correction
	# and display each line that is changed.
	# Ask user to approve all changes before saving.
		make_global_change()
	}	
} # end of Main procedure</PRE
></BLOCKQUOTE
></P
><P
CLASS="para"
>The first field of each input line from <KBD
CLASS="command"
>wordlist</KBD
>
contains the misspelled word and it is assigned to
<KBD
CLASS="command"
>misspelling</KBD
>.  We construct a
<KBD
CLASS="command"
>while</KBD
> loop inside which we display the misspelled
word to the user and prompt for a response.  Look closely at the
regular expression that tests the value of
<KBD
CLASS="command"
>response</KBD
>:</P
><P
CLASS="para"
><BLOCKQUOTE
CLASS="screen"
><PRE
CLASS="screen"
>while (response !~ /(^[cCgGaAhHqQ])|^$/)</PRE
></BLOCKQUOTE
></P
><P
CLASS="para"
>The user can only get out of this loop by entering any of the
specified letters <EM
CLASS="emphasis"
>or</EM
> by entering a carriage
return&nbsp;- an empty line.  The use of regular expressions for
testing user input helps tremendously in writing a simple but flexible
program.  The user can enter a single letter &quot;c&quot; in lower- or uppercase
or a word beginning with &quot;c&quot; such as &quot;Change.&quot;</P
><P
CLASS="para"
>The rest of the main procedure consists of conditional statements that
test for a specific response and perform a corresponding action.  The
first response is &quot;help,&quot; which displays the list of responses again
and then redisplays the prompt.</P
><P
CLASS="para"
>The next response is &quot;quit.&quot;  The action associated with quit is
<KBD
CLASS="command"
>exit</KBD
>, which drops out of the main procedure and
goes to the <KBD
CLASS="command"
>END</KBD
> procedure.</P
><P
CLASS="para"
>If the user enters &quot;add,&quot; the misspelled word is put in the array
<KBD
CLASS="command"
>dict</KBD
> and will be added as an exception in a local
dictionary.</P
><P
CLASS="para"
>The &quot;Change&quot; and &quot;Global&quot; responses cause the program's real work to
begin.  It's important to understand how they differ.  When the user
enters &quot;c&quot; or &quot;change,&quot; the first occurrence of the misspelled word in
the document is displayed.  Then the user is prompted to make the
change.  This happens for each occurrence in the document.  When the
user enters &quot;g&quot; or &quot;global,&quot; the user is prompted to make the change
right away, and all the changes are made at once without prompting the
user to confirm each one.  This work is largely handled by two
functions, <KBD
CLASS="command"
>make_change()</KBD
> and
<KBD
CLASS="command"
>make_global_change()</KBD
>, which we'll look at
in the last section.  These are all the valid responses, except one.
A carriage return means to ignore the misspelled word and get the next
word in the list.  This is the default action of the main input loop,
so no conditional need be set up for it.</P
></DIV
><DIV
CLASS="sect2"
><H3
CLASS="sect2"
><A
CLASS="title"
NAME="SEDAWK-CH-12-SECT-1.3"
>12.1.3 END Procedure</A
></H3
><P
CLASS="para"
>The <KBD
CLASS="command"
>END</KBD
> procedure, of course, is 
reached in one of the following circumstances:</P
><UL
CLASS="itemizedlist"
><LI
CLASS="listitem"
><P
CLASS="para"
>The <KBD
CLASS="command"
>spell</KBD
> command failed or did not turn up any misspellings.</P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>The list of misspelled words is exhausted.</P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>The user has entered &quot;quit&quot; at a prompt.</P
></LI
></UL
><P
CLASS="para"
>The purpose of the <KBD
CLASS="command"
>END</KBD
> procedure is to allow the
user to confirm any permanent change to the document or the
dictionary.</P
><P
CLASS="para"
><BLOCKQUOTE
CLASS="screen"
><PRE
CLASS="screen"
># END procedure makes changes permanent.
# It overwrites the original file, and adds words
# to the dictionary.
# It also removes the temporary files.

END {
# if we got here after reading only one record, 
# no changes were made, so exit.
	if (NR &lt;= 1) exit
# user must confirm saving corrections to file
	while (saveAnswer !~ /([yY](es)?)|([nN]o?)/ ) {
		printf &quot;Save corrections in %s (y/n)? &quot;, SPELLFILE
		getline saveAnswer &lt; &quot;-&quot;
	}
# if answer is yes then mv temporary input file to SPELLFILE
# save old SPELLFILE, just in case
	if (saveAnswer ~ /^[yY]/) {
		system(&quot;cp &quot; SPELLFILE &quot; &quot; SPELLFILE &quot;.orig&quot;)
		system(&quot;mv &quot; spellsource &quot; &quot; SPELLFILE)
	}
# if answer is no then rm temporary input file
	if (saveAnswer ~ /^[nN]/)
		system(&quot;rm &quot; spellsource) 

# if words have been added to dictionary array, then prompt
# to confirm saving in current dictionary. 
	if (dictEntry) {
		printf &quot;Make changes to dictionary (y/n)? &quot;
		getline response &lt; &quot;-&quot;
		if (response ~ /^[yY]/){
		# if no dictionary defined, then use &quot;dict&quot;
			if (! SPELLDICT) SPELLDICT = &quot;dict&quot;
		
		# loop through array and append words to dictionary
			sub(/^\+/, &quot;&quot;, SPELLDICT)
			for ( item in dict )
				print dict[item] &gt;&gt; SPELLDICT
			close(SPELLDICT)
		# sort dictionary file 
			system(&quot;sort &quot; SPELLDICT &quot;&gt; tmp_dict&quot;)
			system(&quot;mv &quot; &quot;tmp_dict &quot; SPELLDICT)
		}
	}
# remove word list
	system(&quot;rm sp_wordlist&quot;)
} # end of END procedure</PRE
></BLOCKQUOTE
></P
><P
CLASS="para"
>The <KBD
CLASS="command"
>END</KBD
> procedure begins with a conditional
statement that tests that the number of records is less than or equal
to 1.  This occurs when the <KBD
CLASS="command"
>spell</KBD
> program does not
generate a word list or when the user enters &quot;quit&quot; after seeing just
the first record.  If so, the <KBD
CLASS="command"
>END</KBD
> procedure is
exited as there is no work to save.</P
><P
CLASS="para"
>Next, we create a <KBD
CLASS="command"
>while</KBD
> loop to ask the user about
saving the changes made to the document.  It requires the user to
respond &quot;y&quot; or &quot;n&quot; to the prompt.  If the answer is &quot;y,&quot; the temporary
input file replaces the original document file.  If the answer is &quot;n,&quot;
the temporary file is removed.  No other responses are accepted.</P
><P
CLASS="para"
>Next, we test to see if the <KBD
CLASS="command"
>dict</KBD
> array has
something in it.  Its elements are the words to be added to the
dictionary.  If the user approves adding them to the dictionary, these
words are appended to the current dictionary, as defined above, or if
not, to a local <I
CLASS="filename"
>dict</I
> file.  Because the
dictionary must be sorted to be read by <KBD
CLASS="command"
>spell</KBD
>, a
<KBD
CLASS="command"
>sort</KBD
> command is executed with the output sent to a
temporary file that is afterwards copied over the original file.</P
></DIV
><DIV
CLASS="sect2"
><H3
CLASS="sect2"
><A
CLASS="title"
NAME="SEDAWK-CH-12-SECT-1.4"
>12.1.4 Supporting Functions</A
></H3
><P
CLASS="para"
>There are three supporting functions, two of which are large and do
the bulk of the work of making changes in the document.  The third
function supports that work by confirming that the user wants to save
the changes that were made.</P
><P
CLASS="para"
>When the user wants to &quot;Change each occurrence&quot; in the document, the
main procedure has a <KBD
CLASS="command"
>while</KBD
> loop that reads the
document one line at a time.  (This line becomes $0.) It calls the
<KBD
CLASS="command"
>make_change()</KBD
> function to see if the line contains
the misspelled word.  If it does, the line is displayed and the user
is prompted to enter the correct spelling of the word.</P
><P
CLASS="para"
><BLOCKQUOTE
CLASS="screen"
><PRE
CLASS="screen"
># make_change -- prompt user to correct misspelling 
#		 for current input line.  Calls itself
# 		 to find other occurrences in string.
# 	stringToChange -- initially $0; then unmatched substring of $0
# 	len -- length from beginning of $0 to end of matched string 
# Assumes that misspelling is defined. 

function make_change (stringToChange, len,	# parameters
	line, OKmakechange, printstring, carets)	# locals
{
# match misspelling in stringToChange; otherwise do nothing 
  if ( match(stringToChange, misspelling) ) {
  # Display matched line 
	printstring = $0
	gsub(/\t/, &quot; &quot;, printstring)
	print printstring
	carets = &quot;^&quot;
	for (i = 1; i &lt; RLENGTH; ++i)
		carets = carets &quot;^&quot;
	if (len)
		FMT = &quot;%&quot; len+RSTART+RLENGTH-2 &quot;s\n&quot;
	else
		FMT = &quot;%&quot; RSTART+RLENGTH-1 &quot;s\n&quot;
	printf(FMT, carets)
  # Prompt user for correction, if not already defined
	if (! newspelling) {
		printf &quot;Change to:&quot;
		getline newspelling &lt; &quot;-&quot;
	}
  # A carriage return falls through
  # If user enters correction, confirm  
	while (newspelling &amp;&amp; ! OKmakechange) {
		printf (&quot;Change %s to %s? (y/n):&quot;, misspelling, newspelling)
		getline OKmakechange &lt; &quot;-&quot;
		madechg = &quot;&quot;
	# test response
		if (OKmakechange ~ /[yY](es)?/ ) {
		# make change (first occurrence only)
			madechg = sub(misspelling, newspelling, stringToChange)
		}
		else if ( OKmakechange ~ /[nN]o?/ ) {
			# offer chance to re-enter correction 
			printf &quot;Change to:&quot;
			getline newspelling &lt; &quot;-&quot;
			OKmakechange = &quot;&quot;
		}
	} # end of while loop

   # if len, we are working with substring of $0
	if (len) {
	# assemble it
		line = substr($0,1,len-1)
		$0 = line stringToChange
	}
	else {
		$0 = stringToChange
		if (madechg) ++changes
	}

   # put changed line in array for display
	if (madechg) 
		changedLines[changes] = &quot;&gt;&quot; $0

   # create substring so we can try to match other occurrences
	len += RSTART + RLENGTH
	part1 = substr($0, 1, len-1)
	part2 = substr($0, len)
   # calls itself to see if misspelling is found in remaining part 
	make_change(part2, len) 

  } # end of if

} # end of make_change()</PRE
></BLOCKQUOTE
></P
><P
CLASS="para"
>If the misspelled word is not found in the current input line, nothing
is done.  If it is found, this function shows the line containing the
misspelling and asks the user if it should be corrected.
Underneath the display of the current line is a row of carets
that indicates the misspelled word.</P
><P
CLASS="para"
><BLOCKQUOTE
CLASS="screen"
><PRE
CLASS="screen"
>Two other utlitities that are found on the UNIX system
          ^^^^^^^^^^</PRE
></BLOCKQUOTE
></P
><P
CLASS="para"
>The current input line is copied to <KBD
CLASS="command"
>printstring</KBD
>
because it is necessary to change the line for display purposes.  If
the line contains any tabs, each tab in this copy of the line is
temporarily replaced by a single space.  This solves a problem of
aligning the carets when tabs were present.  (A tab counts as a single
character when determining the length of a line but actually occupies
greater space when displayed, usually five to eight characters long.)</P
><P
CLASS="para"
>After displaying the line, the function prompts the user to enter a
correction.  It then follows up by displaying what the user has
entered and asks for confirmation.  If the correction is approved, the
<KBD
CLASS="command"
>sub()</KBD
> function is called to make the
change.  If not approved, the user is given another chance to enter
the correct word.</P
><P
CLASS="para"
>Remember that the <KBD
CLASS="command"
>sub()</KBD
> function only
changes the first occurrence on a line.  The
<KBD
CLASS="command"
>gsub()</KBD
> function changes all occurrences on
a line, but we want to allow the user to confirm
<EM
CLASS="emphasis"
>each</EM
> change.  Therefore, we have to try to match
the misspelled word against the remaining part of the line.  And we
have to be able to match the next occurrence regardless of whether or
not the first occurrence was changed.</P
><P
CLASS="para"
>To do this, <KBD
CLASS="command"
>make_change()</KBD
> is designed as a
recursive function; it calls itself to look for additional occurrences
on the same line.  In other words, the first time
<KBD
CLASS="command"
>make_change()</KBD
> is called, it looks at all of
$0 and matches the first misspelled word on that line.  Then it splits
the line into two parts&nbsp;- the first part contains the characters
up to the end of the first occurrence and the second part contains the
characters that immediately follow up to the end of the line.  Then it
calls itself to try and match the misspelled word in the second part.
When called recursively, the function takes two arguments.</P
><P
CLASS="para"
><BLOCKQUOTE
CLASS="screen"
><PRE
CLASS="screen"
>make_change(part2, len)</PRE
></BLOCKQUOTE
></P
><P
CLASS="para"
>The first is the string to be changed, which is initially $0 when
called from the main procedure but each time thereafter is the
remaining part of $0.  The second argument is <KBD
CLASS="command"
>len</KBD
>
or the length of the first part, which we use to extract the substring
and reassemble the two parts at the end.</P
><P
CLASS="para"
>The <KBD
CLASS="command"
>make_change()</KBD
> function also collects an
array of lines that were changed.</P
><P
CLASS="para"
><BLOCKQUOTE
CLASS="screen"
><PRE
CLASS="screen"
># put changed line in array for display
        if (madechg)
                changedLines[changes] = &quot;&gt;&quot; $0</PRE
></BLOCKQUOTE
></P
><P
CLASS="para"
>The variable <KBD
CLASS="command"
>madechg</KBD
> will have a value if the
<KBD
CLASS="command"
>sub()</KBD
> function was successful.  $0 (the two
parts have been rejoined) is assigned to an element of the array.
When all of the lines of the document have been read, the main
procedure loops through this array to display all the changed lines.
Then it calls the <KBD
CLASS="command"
>confirm_changes()</KBD
>
function to ask if these changes should be saved.  It copies the
temporary output file over the temporary input file, keeping intact
the corrections made for the current misspelled word.</P
><P
CLASS="para"
>If a user decides to make a &quot;Global change,&quot; the
<KBD
CLASS="command"
>make_global_change()</KBD
> function is called to
do it.  This function is similar to the
<KBD
CLASS="command"
>make_change()</KBD
> function, but is simpler
because we can make the change globally on each line.</P
><P
CLASS="para"
><BLOCKQUOTE
CLASS="screen"
><PRE
CLASS="screen"
># make_global_change --
#		prompt user to correct misspelling 
#		for all lines globally.  
#		Has no arguments
# Assumes that misspelling is defined. 

function make_global_change(    newspelling, OKmakechange, changes)
{
# prompt user to correct misspelled word
   printf &quot;Globally change to:&quot;
   getline newspelling &lt; &quot;-&quot;

# carriage return falls through
# if there is an answer, confirm 
   while (newspelling &amp;&amp; ! OKmakechange) {
		printf (&quot;Globally change %s to %s? (y/n):&quot;, misspelling,
				newspelling)
		getline OKmakechange &lt; &quot;-&quot;
	# test response and make change
		if (OKmakechange ~ /[yY](es)?/ ) {
		# open file, read all lines 
			while( (getline &lt; spellsource) &gt; 0){
			# if match is found, make change using gsub
			# and print each changed line.
				if ($0 ~ misspelling) {
					madechg = gsub(misspelling, newspelling)
					print &quot;&gt;&quot;, $0
					changes += 1  # counter for line changes
				}
			# write all lines to temp output file
				print &gt; spellout
			} # end of while loop for reading file

		# close temporary files
			close(spellout)
			close(spellsource)
		# report the number of changes	
			printf (&quot;%d lines changed. &quot;, changes) 
		# function to confirm before saving changes
			confirm_changes()
		} # end of if (OKmakechange ~ y) 

	# if correction not confirmed,  prompt for new word
		else if ( OKmakechange ~ /[nN]o?/ ){
			printf &quot;Globally change to:&quot;
			getline newspelling &lt; &quot;-&quot;
			OKmakechange = &quot;&quot;
		}

  } # end of while loop for prompting user for correction

} # end of make_global_change()</PRE
></BLOCKQUOTE
></P
><P
CLASS="para"
>This function prompts the user to enter a correction.  A
<KBD
CLASS="command"
>while</KBD
> loop is set up to read all the lines of the
document and apply the <KBD
CLASS="command"
>gsub()</KBD
> function to
make the changes.  The main difference is that all the changes are
made at once&nbsp;- the user is not prompted to confirm them.  When all
lines have been read, the function displays the lines that were
changed and calls <KBD
CLASS="command"
>confirm_changes()</KBD
> to get
the user to approve this batch of changes before saving them.</P
><P
CLASS="para"
>The <KBD
CLASS="command"
>confirm_changes()</KBD
> function is a routine
called to get approval of the changes made when the
<KBD
CLASS="command"
>make_change()</KBD
> or
<KBD
CLASS="command"
>make_global_change()</KBD
> function is called.</P
><P
CLASS="para"
><BLOCKQUOTE
CLASS="screen"
><PRE
CLASS="screen"
># confirm_changes --  
#		confirm before saving changes

function confirm_changes(  savechanges) {
# prompt to confirm saving changes
	while (! savechanges ) {
		printf (&quot;Save changes? (y/n)&quot;)
		getline savechanges &lt; &quot;-&quot;
	}
# if confirmed, mv output to input
	if (savechanges ~ /[yY](es)?/)
		system(&quot;mv &quot; spellout &quot; &quot; spellsource) 
}</PRE
></BLOCKQUOTE
></P
><P
CLASS="para"
>The reason for creating this function is to prevent the duplication of
code.  Its purpose is simply to require the user to acknowledge the
changes before replacing the old version of the document file
(<KBD
CLASS="command"
>spellsource</KBD
>) with the new version
(<KBD
CLASS="command"
>spellout</KBD
>).</P
></DIV
><DIV
CLASS="sect2"
><H3
CLASS="sect2"
><A
CLASS="title"
NAME="SEDAWK-CH-12-SECT-1.5"
>12.1.5 The spellcheck Shell Script</A
></H3
><P
CLASS="para"
>To make it easy to invoke this awk script, we create the
<KBD
CLASS="command"
>spellcheck</KBD
> shell script (say
<EM
CLASS="emphasis"
>that</EM
> three times fast).  It contains the following
lines:</P
><P
CLASS="para"
><BLOCKQUOTE
CLASS="screen"
><PRE
CLASS="screen"
>AWKLIB=/usr/local/awklib
nawk -f $AWKLIB/spellcheck.awk $*</PRE
></BLOCKQUOTE
></P
><P
CLASS="para"
>This script sets up a shell variable <KBD
CLASS="command"
>AWKLIB</KBD
> that
specifies the location of the <KBD
CLASS="command"
>spellcheck.awk</KBD
>
script. The symbol &quot;$*&quot; expands to all command-line parameters
following the name of the script.  These parameters are then available
to awk.</P
><P
CLASS="para"
>One of the interesting things about this spell checker
is how little is done in the shell script.[1]

All of the work is done in the awk programming language, including
executing 10 UNIX commands.  We're using a consistent syntax and the
same constructs by doing it all in awk.  When you have to do some of
your work in the shell and some in awk, it can get confusing.  For
instance, you have to remember the differences in the syntax of
<KBD
CLASS="command"
>if</KBD
> conditionals and how to reference variables.
Modern versions of awk provide a true alternative to the shell for
executing commands and interacting with a user.
The full listing for <KBD
CLASS="command"
>spellcheck.awk</KBD
> is found in
<A
CLASS="xref"
HREF="appc_01.htm"
TITLE="Supplement for Chapter 12"
>Appendix C, Supplement for Chapter 12</A
>.</P
><BLOCKQUOTE
CLASS="footnote"
><P
CLASS="para"
>[1] <CITE
CLASS="citetitle"
>UNIX Text Processing</CITE
> (Dougherty and O'Reilly,
Howard W.  Sams, 1987) presents a sed-based spell checker that relies
heavily upon the shell.  It is interesting to compare the two
versions.</P
></BLOCKQUOTE
></DIV
><A
CLASS="indexterm"
NAME="AUTOID-10646"
></A
><A
CLASS="indexterm"
NAME="AUTOID-10647"
></A
></DIV
></DIV
><DIV
CLASS="htmlnav"
><P
></P
><HR
ALIGN="LEFT"
WIDTH="515"
TITLE="footer"><TABLE
WIDTH="515"
BORDER="0"
CELLSPACING="0"
CELLPADDING="0"
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="172"
><A
CLASS="SECT1"
HREF="ch11_04.htm"
TITLE="11.4 Epilogue"
><IMG
SRC="../gifs/txtpreva.gif"
ALT="Previous: 11.4 Epilogue"
BORDER="0"></A
></TD
><TD
ALIGN="CENTER"
VALIGN="TOP"
WIDTH="171"
><A
CLASS="book"
HREF="index.htm"
TITLE="sed &amp; awk"
><IMG
SRC="../gifs/txthome.gif"
ALT="sed &amp; awk"
BORDER="0"></A
></TD
><TD
ALIGN="RIGHT"
VALIGN="TOP"
WIDTH="172"
><A
CLASS="SECT1"
HREF="ch12_02.htm"
TITLE="12.2 Generating a Formatted Index"
><IMG
SRC="../gifs/txtnexta.gif"
ALT="Next: 12.2 Generating a Formatted Index"
BORDER="0"></A
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="172"
>11.4 Epilogue</TD
><TD
ALIGN="CENTER"
VALIGN="TOP"
WIDTH="171"
><A
CLASS="index"
HREF="index/idx_0.htm"
TITLE="Book Index"
><IMG
SRC="../gifs/index.gif"
ALT="Book Index"
BORDER="0"></A
></TD
><TD
ALIGN="RIGHT"
VALIGN="TOP"
WIDTH="172"
>12.2 Generating a Formatted Index</TD
></TR
></TABLE
><HR
ALIGN="LEFT"
WIDTH="515"
TITLE="footer"><IMG
SRC="../gifs/smnavbar.gif"
USEMAP="#map"
BORDER="0"
ALT="The UNIX CD Bookshelf Navigation"><MAP
NAME="map"
><AREA
SHAPE="RECT"
COORDS="0,0,73,21"
HREF="../index.htm"
ALT="The UNIX CD Bookshelf"><AREA
SHAPE="RECT"
COORDS="74,0,163,21"
HREF="../upt/index.htm"
ALT="UNIX Power Tools"><AREA
SHAPE="RECT"
COORDS="164,0,257,21"
HREF="../unixnut/index.htm"
ALT="UNIX in a Nutshell"><AREA
SHAPE="RECT"
COORDS="258,0,321,21"
HREF="../vi/index.htm"
ALT="Learning the vi Editor"><AREA
SHAPE="RECT"
COORDS="322,0,378,21"
HREF="index.htm"
ALT="sed &amp; awk"><AREA
SHAPE="RECT"
COORDS="379,0,438,21"
HREF="../ksh/index.htm"
ALT="Learning the Korn Shell"><AREA
SHAPE="RECT"
COORDS="439,0,514,21"
HREF="../lrnunix/index.htm"
ALT="Learning the UNIX Operating System"></MAP
></DIV
></BODY
></HTML
>
