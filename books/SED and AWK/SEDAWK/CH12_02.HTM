<HTML
><HEAD
>
<TITLE>[Chapter 12] 12.2 Generating a Formatted Index</TITLE>
<META
NAME="DC.title"
CONTENT="sed &amp; awk"><META
NAME="DC.creator"
CONTENT="Dale Dougherty &amp; Arnold Robbins"><META
NAME="DC.publisher"
CONTENT="O'Reilly &amp; Associates, Inc."><META
NAME="DC.date"
CONTENT="1998-08-03T21:04:03Z"><META
NAME="DC.type"
CONTENT="Text.Monograph"><META
NAME="DC.format"
CONTENT="text/html"
SCHEME="MIME"><META
NAME="DC.source"
CONTENT="1-56592-225-5"
SCHEME="ISBN"><META
NAME="DC.language"
CONTENT="en-US"><META
NAME="generator"
CONTENT="Jade 1.1/O'Reilly DocBook 3.0 to HTML 4.0"><LINK
REV="made"
HREF="mailto:online-books@oreilly.com"
TITLE="Online Books Comments"><LINK
REL="up"
HREF="ch12_01.htm"
TITLE="12. Full-Featured Applications"><LINK
REL="prev"
HREF="ch12_01.htm"
TITLE="12.1 An Interactive Spelling Checker"><LINK
REL="next"
HREF="ch12_03.htm"
TITLE="12.3 Spare Details of the masterindex Program"></HEAD
><BODY
BGCOLOR="#FFFFFF"
TEXT="#000000"
><DIV
CLASS="htmlnav"
><H1
><IMG
SRC="gifs/smbanner.gif"
ALT="sed &amp; awk"
USEMAP="#srchmap"
BORDER="0"></H1
><MAP
NAME="srchmap"
><AREA
SHAPE="RECT"
COORDS="0,0,466,65"
HREF="index.htm"
ALT="sed &amp; awk"><AREA
SHAPE="RECT"
COORDS="467,0,514,18"
HREF="../search/ssrch.htm"
ALT="Search this book"></MAP
><TABLE
WIDTH="515"
BORDER="0"
CELLSPACING="0"
CELLPADDING="0"
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="172"
><A
CLASS="SECT1"
HREF="ch12_01.htm"
TITLE="12.1 An Interactive Spelling Checker"
><IMG
SRC="../gifs/txtpreva.gif"
ALT="Previous: 12.1 An Interactive Spelling Checker"
BORDER="0"></A
></TD
><TD
ALIGN="CENTER"
VALIGN="TOP"
WIDTH="171"
><B
><FONT
FACE="ARIEL,HELVETICA,HELV,SANSERIF"
SIZE="-1"
>Chapter 12<BR>Full-Featured Applications</FONT
></B
></TD
><TD
ALIGN="RIGHT"
VALIGN="TOP"
WIDTH="172"
><A
CLASS="SECT1"
HREF="ch12_03.htm"
TITLE="12.3 Spare Details of the masterindex Program"
><IMG
SRC="../gifs/txtnexta.gif"
ALT="Next: 12.3 Spare Details of the masterindex Program"
BORDER="0"></A
></TD
></TR
></TABLE
>&nbsp;<HR
ALIGN="LEFT"
WIDTH="515"
TITLE="footer"></DIV
><DIV
CLASS="SECT1"
><H2
CLASS="sect1"
><A
CLASS="title"
NAME="SEDAWK-CH-12-SECT-2"
>12.2 Generating a Formatted Index</A
></H2
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="CH12.INDEX1"
></A
><A
CLASS="indexterm"
NAME="CH12.INDEX2"
></A
>The process of generating an index usually involves three steps:</P
><UL
CLASS="itemizedlist"
><LI
CLASS="listitem"
><P
CLASS="para"
>Code the index entries in the document.</P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>Format the document, producing index entries with page numbers.</P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>Process the index entries to sort them, combining entries that
differ only in page number, and then preparing the formatted index. </P
></LI
></UL
><P
CLASS="para"
>This process remains pretty much the same whether using
<KBD
CLASS="command"
>troff</KBD
>, other coded batch formatters, or a WYSIWYG
formatter such as <EM
CLASS="emphasis"
>FrameMaker</EM
>, although the steps are
not as clearly separated with the latter.  However, I will be
describing how we use <KBD
CLASS="command"
>troff</KBD
> to generate an index
such as the one for this book.
We code the index using the following macros:</P
><TABLE
CLASS="informaltable"
><THEAD
CLASS="thead"
><TR
CLASS="row"
VALIGN="TOP"
><TH
CLASS="entry"
ALIGN="LEFT"
ROWSPAN="1"
COLSPAN="1"
>Macro</TH
><TH
CLASS="entry"
ALIGN="LEFT"
ROWSPAN="1"
COLSPAN="1"
>Description</TH
></TR
></THEAD
><TBODY
CLASS="tbody"
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
>.XX</TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
>Produces general index entries.</TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
>.XN</TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
>Creates &quot;see&quot; or &quot;see also&quot; cross references.</TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
>.XB</TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
>Creates bold page entry indicating primary reference.</TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
>.XS</TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
>Begins range of pages for entry.</TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
>.XE</TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
>Ends range of pages for entry.</TD
></TR
></TBODY
></TABLE
><P
CLASS="para"
>These macros take a single quoted argument, which
can have one of several forms, indicating
primary, secondary, or tertiary keys: </P
><BLOCKQUOTE
CLASS="literallayout"
><P
CLASS="literallayout"
>&quot;<CODE
CLASS="replaceable"
><I
>primary</I
></CODE
> [ : <CODE
CLASS="replaceable"
><I
>secondary</I
></CODE
> [ ; <CODE
CLASS="replaceable"
><I
>tertiary</I
></CODE
> ]]&quot;</P
></BLOCKQUOTE
><P
CLASS="para"
>A colon is used as the separator between the primary and secondary
keys.  To support an earlier coding convention, the first comma is
interpreted as the separator if no colon is used.  A semicolon
indicates the presence of a tertiary key.  The page number is always
associated with the last key.</P
><P
CLASS="para"
>Here is an entry with only a primary key:</P
><P
CLASS="para"
><BLOCKQUOTE
CLASS="screen"
><PRE
CLASS="screen"
>.XX &quot;XView&quot;</PRE
></BLOCKQUOTE
></P
><P
CLASS="para"
>The next two entries specify a secondary key:</P
><P
CLASS="para"
><BLOCKQUOTE
CLASS="screen"
><PRE
CLASS="screen"
>.XX &quot;XView: reserved names&quot;
.XX &quot;XView, packages&quot;</PRE
></BLOCKQUOTE
></P
><P
CLASS="para"
>The most complex entries contain tertiary keys:</P
><P
CLASS="para"
><BLOCKQUOTE
CLASS="screen"
><PRE
CLASS="screen"
>.XX &quot;XView: objects; list&quot;
.XX &quot;XView: objects; hierarchy of&quot;</PRE
></BLOCKQUOTE
></P
><P
CLASS="para"
>Finally, there are two types of cross references:</P
><P
CLASS="para"
><BLOCKQUOTE
CLASS="screen"
><PRE
CLASS="screen"
>.XN &quot;error recovery: (see error handling)&quot; 
.XX &quot;mh mailer: (see also xmh mailer)&quot;</PRE
></BLOCKQUOTE
></P
><P
CLASS="para"
>The &quot;see&quot; entry refers a person to another index entry.  The &quot;see
also&quot; is typically used when there are entries for, in this case, &quot;mh
mailer,&quot; but there is relevant information catalogued under another
name.  Only &quot;see&quot; entries do not have page numbers associated with
them.</P
><P
CLASS="para"
>When the document is processed by <KBD
CLASS="command"
>troff</KBD
>, the
following index entries are produced:</P
><P
CLASS="para"
><BLOCKQUOTE
CLASS="screen"
><PRE
CLASS="screen"
>XView    42
XView: reserved names   43
XView, packages 43
XView: objects; list of 43
XView: objects; hierarchy of    44
XView, packages 45
error recovery: (See error handling) 
mh mailer: (see also xmh mailer)    46</PRE
></BLOCKQUOTE
></P
><P
CLASS="para"
>These entries serve as input to the indexing program.  Each entry
(except for &quot;see&quot; entries) consists of the key and a page number.  In
other words, the entry is divided into two parts and the first part,
the key, can also be divided into three parts.  When these entries are
processed by the indexing program and the output is formatted, the
entries for &quot;XView&quot; are combined as follows:</P
><P
CLASS="para"
><BLOCKQUOTE
CLASS="screen"
><PRE
CLASS="screen"
>XView, 42
	objects; hierarchy of, 44; 
	   list of, 43
	packages, 43,45
	reserved names, 43</PRE
></BLOCKQUOTE
></P
><P
CLASS="para"
>To accomplish this, the indexing program must:</P
><UL
CLASS="itemizedlist"
><LI
CLASS="listitem"
><P
CLASS="para"
>Sort the index by key and page number.</P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>Merge entries that differ only in the page number. </P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>Merge entries that have the same primary and/or secondary keys.</P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>Look for consecutive page numbers and combine as a range.</P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>Prepare the index in a format for display on screen or for printing.</P
></LI
></UL
><P
CLASS="para"
>This is what the index program does if you are processing the index
entries for a single book.  It also allows you to create a master
index, an overall index for a set of volumes.  To do that, an awk
script appends either a roman numeral or an abbreviation after the
page number.  Each file then contains the entries for a particular
book and those entries are uniquely identified.  If we chose to use
roman numerals to identify the volume, then the above entries would be
changed to:</P
><P
CLASS="para"
><BLOCKQUOTE
CLASS="screen"
><PRE
CLASS="screen"
>XView	42:I
XView: reserved names   43:I
XView: objects; list of 43:I</PRE
></BLOCKQUOTE
></P
><P
CLASS="para"
>With multivolume entries, the final index that is generated might look
like this:</P
><P
CLASS="para"
><BLOCKQUOTE
CLASS="screen"
><PRE
CLASS="screen"
>XView, I:42; II:55,69,75
	objects; hierarchy of, I:44; 
          list of, I:43; II: 56 
	packages, I:43,45
	reserved names, I:43</PRE
></BLOCKQUOTE
></P
><P
CLASS="para"
>For now, it's only important to recognize that the index entry used as
input to the awk program can have a page number or a page number
followed by a volume identifier.</P
><DIV
CLASS="sect2"
><H3
CLASS="sect2"
><A
CLASS="title"
NAME="SEDAWK-CH-12-SECT-2.1"
>12.2.1 The masterindex Program</A
></H3
><P
CLASS="para"
>Because of the length and complexity of
this indexing application,[2]
our description presents the larger structure of the program.  Use the
comments in the program itself to understand what is happening in the
program line by line.</P
><BLOCKQUOTE
CLASS="footnote"
><P
CLASS="para"
>[2] The origins of this
indexing program are traced back to a copy of an
indexing program written in awk by Steve Talbott.  I learned this
program by taking it apart, and made some changes to it to support
consecutive page numbering in addition to section-page numbering.
That was the program I described in <CITE
CLASS="citetitle"
>UNIX Text
Processing</CITE
>.  Knowing that program, I wrote an indexing
program that could deal with index entries produced by Microsoft Word
and generate an index using section-page numbering.  Later, we needed
a master index for several books in our X Window System Series.  I
took it as an opportunity to rethink our indexing program, and rewrite
it using nawk, so that it supports both single-book and multiple-book
indices.  <CITE
CLASS="citetitle"
>The AWK Programming Language</CITE
> contains
an example of an index program that is smaller than the one shown
here and might be a place to start if you find this one too
complicated.  It does not, however, deal with keys.  That indexing
program is a simplified version of the one described in Bell Labs
Computing Science Technical Report 128, <CITE
CLASS="citetitle"
>Tools for Printing
Indexes</CITE
>, October 1986, by Brian Kernighan and Jon Bentley. [D.D.]</P
></BLOCKQUOTE
><P
CLASS="para"
>After descriptions of each of the program modules, a final section
discusses a few remaining details.  For the most part, these are code
fragments that deal with nitty-gritty, input-related problems that had
to be solved along the way.
The shell script <KBD
CLASS="command"
>masterindex</KBD
>[3] 

allows the user to specify a number of different command-line options
to specify what kind of index to make and it invokes the necessary awk
programs to do the job.  The operations of the
<KBD
CLASS="command"
>masterindex</KBD
> program can be broken into five
separate programs or modules that form a single pipe.</P
><BLOCKQUOTE
CLASS="footnote"
><P
CLASS="para"
>[3] This shell
script and the documentation for the program are
presented in <A
CLASS="xref"
HREF="appc_01.htm"
TITLE="Supplement for Chapter 12"
>Appendix C</A
>.  You might want to first
read the documentation for a basic understanding of using the program.</P
></BLOCKQUOTE
><P
CLASS="para"
><BLOCKQUOTE
CLASS="screen"
><PRE
CLASS="screen"
>input.idx | sort | pagenums.idx | combine.idx | format.idx</PRE
></BLOCKQUOTE
></P
><P
CLASS="para"
>All but one of the programs are written using awk.  For sorting the
entries, we rely upon <KBD
CLASS="command"
>sort</KBD
>, a standard UNIX
utility.  Here's a brief summary of what each of these programs does:</P
><DL
CLASS="variablelist"
><DT
CLASS="term"
><KBD
CLASS="command"
>input.idx</KBD
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
>Standardizes the format of entries and rotates them.</P
></DD
><DT
CLASS="term"
><KBD
CLASS="command"
>sort</KBD
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
>Sorts entries by key, volume, and page number.</P
></DD
><DT
CLASS="term"
><KBD
CLASS="command"
>pagenums.idx</KBD
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
>Merges entries with same key, creating a list of page numbers.</P
></DD
><DT
CLASS="term"
><KBD
CLASS="command"
>combine.idx</KBD
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
>Combines consecutive page numbers into a range. </P
></DD
><DT
CLASS="term"
><KBD
CLASS="command"
>format.idx</KBD
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
>Prepares the formatted index for the screen or processing by <KBD
CLASS="command"
>troff</KBD
>. </P
></DD
></DL
><P
CLASS="para"
>We will discuss each of these steps in a separate section.</P
></DIV
><DIV
CLASS="sect2"
><H3
CLASS="sect2"
><A
CLASS="title"
NAME="SEDAWK-CH-12-SECT-2.2"
>12.2.2 Standardizing Input</A
></H3
><P
CLASS="para"
>This <KBD
CLASS="command"
>input.idx</KBD
> script looks for different types of
entries and standardizes them for easier processing by subsequent
programs.  Additionally, it automatically rotates index entries
containing a tilde (~).  (See the section &quot;Rotating Two Parts&quot; later
in this chapter.)</P
><P
CLASS="para"
>The input to the <KBD
CLASS="command"
>input.idx</KBD
> program consists of two
tab-separated fields, as described earlier.  The program produces
output records with three colon-separated fields.  The first field
contains the primary key; the second field contains the secondary and
tertiary keys, if defined; and the third field contains the page
number.</P
><P
CLASS="para"
>Here's the code for <KBD
CLASS="command"
>input.idx</KBD
> program:</P
><P
CLASS="para"
><BLOCKQUOTE
CLASS="screen"
><PRE
CLASS="screen"
>#!/work/bin/nawk -f
# ------------------------------------------------
# input.idx -- standardize input before sorting
# Author:  Dale Dougherty
# Version 1.1   7/10/90
# 
# input is &quot;entry&quot; tab &quot;page_number&quot;
# ------------------------------------------------
BEGIN { FS = &quot;\t&quot;; OFS = &quot;&quot; }

#1 Match entries that need rotating that contain a single tilde
   # $1 ~ /~[^~]/  # regexp does not work and I do not know why 
$1 ~ /~/ &amp;&amp; $1 !~ /~~/ { 
   # split first field into array named subfield 
	n = split($1, subfield, &quot;~&quot;)
	if (n == 2) {
	# print entry without &quot;~&quot; and then rotated
		printf(&quot;%s %s::%s\n&quot;, subfield[1], subfield[2], $2)
		printf(&quot;%s:%s:%s\n&quot;, subfield[2], subfield[1], $2)
	}
	next
}# End of 1

#2 Match entries that contain two tildes 
$1 ~ /~~/ { 
   # replace ~~ with ~	
	gsub(/~~/, &quot;~&quot;, $1)
} # End of 2

#3  Match entries that use &quot;::&quot; for literal &quot;:&quot;. 
$1 ~ /::/ { 
   # substitute octal value for &quot;::&quot;
	gsub(/::/, &quot;\\72&quot;, $1) 
}# End of 3

#4 Clean up entries 
{
   # look for second colon, which might be used instead of &quot;;&quot;
	if (sub(/:.*:/, &quot;&amp;;&quot;, $1)) {
		sub(/:;/, &quot;;&quot;, $1)	
	}
   # remove blank space if any after colon.
	sub(/: */, &quot;:&quot;, $1)
   # if comma is used as delimiter, convert to colon. 
	if ( $1 !~ /:/ ) {
	# On see also &amp; see, try to put delimiter before &quot;(&quot; 
		if ($1 ~ /\([sS]ee/) {
			if (sub(/, *.*\(/, &quot;:&amp;&quot;, $1)) 
				sub(/:, */, &quot;:&quot;, $1)
			else
				sub(/  *\(/, &quot;:(&quot;, $1)
		}
		else { # otherwise, just look for comma
			sub(/, */, &quot;:&quot;, $1)
		}
	}
	else {
		# added to insert semicolon in &quot;See&quot;
		if ($1 ~ /:[^;]+ *\([sS]ee/) 
			sub(/  *\(/, &quot;;(&quot;, $1)
	}	
}# End of 4

#5 match See Alsos and fix for sort at end
$1 ~ / *\([Ss]ee +[Aa]lso/ { 
  # add &quot;~zz&quot; for sort at end
	sub(/\([Ss]ee +[Aa]lso/, &quot;~zz(see also&quot;, $1) 
	if ($1 ~ /:[^; ]+ *~zz/) {
		sub(/ *~zz/, &quot;; ~zz&quot;, $1)
	}
  # if no page number
	if ($2 == &quot;&quot;) {
		print $0 &quot;:&quot; 
		next
	}
	else {
	# output two entries: 
	# print See Also entry w/out page number
		print $1 &quot;:&quot;
	# remove See Also 
		sub(/ *~zz\(see also.*$/, &quot;&quot;, $1) 
		sub(/;/, &quot;&quot;, $1)
	# print as normal entry
		if ( $1 ~ /:/ )
			print $1 &quot;:&quot; $2
		else
			print $1 &quot;::&quot; $2
		next
	}
}# End of 5

#6 Process entries without page number (See entries)
(NF == 1 || $2 == &quot;&quot; || $1 ~ /\([sS]ee/) { 
   # if a &quot;See&quot; entry
	if ( $1 ~ /\([sS]ee/ ) { 
		if ( $1 ~ /:/ ) 
			print $1 &quot;:&quot;
		else  
			print $1 &quot;:&quot;
		next
	}
	else  { # if not a See entry, generate error
		printerr(&quot;No page number&quot;)
		next
        }
}# End of 6

#7 If the colon is used as the delimiter 
$1 ~ /:/ { 
   # output entry:page
	print $1 &quot;:&quot; $2
	next
}# End of 7

#8  Match entries with only primary keys.
{
	print $1 &quot;::&quot; $2
}# End of 8

# supporting functions
# 
# printerr -- print error message and current record
#		Arg: message to be displayed

function printerr (message) {
	# print message, record number and record
	printf(&quot;ERROR:%s (%d) %s\n&quot;, message, NR, $0) &gt; &quot;/dev/tty&quot;
}</PRE
></BLOCKQUOTE
></P
><P
CLASS="para"
>This script consists of a number of pattern-matching rules to
recognize different types of input.  Note that an entry could match
more than one rule unless the action associated with a rule calls the
<KBD
CLASS="command"
>next</KBD
> statement.</P
><P
CLASS="para"
>As we describe this script, we will be referring to the rules by
number.  Rule 1 rotates entries containing a tilde and produces two
output records.  The <KBD
CLASS="command"
>split()</KBD
> function
creates an array named <KBD
CLASS="command"
>subfield</KBD
> that contains the
two parts of the compound entry.  The two parts are printed in their
original order and are then swapped to create a second output record in
which the secondary key becomes a primary key.</P
><P
CLASS="para"
>Because we are using the tilde as a special character, we must provide
some way of actually entering a tilde.  We have implemented the
convention that two consecutive tildes are translated into a single
tilde.  Rule 2 deals with that case, but notice that the pattern for
rule 1 makes sure that the first tilde it matches is not followed by
another tilde.[4] </P
><BLOCKQUOTE
CLASS="footnote"
><P
CLASS="para"
>[4] In the first edition, Dale wrote, &quot;For extra credit, please send me
mail if you can figure out why the commented regular expression just
before rule 1 does not do the job.  I used the compound expression as
a last resort.&quot;  I'm ashamed to admit that this stumped me also.  When
Henry Spencer turned on the light, it was blinding: &quot;The reason why
the commented regexp doesn't work is that it doesn't do what the
author thought. :-) It looks for tilde followed by a non-tilde
character... but the second tilde of a ~~ combination is
usually followed by a non-tilde!  Using /[^~]~[^~]/ would probably
work.&quot;  I plugged this regular expression in to the program, and it
worked just fine. [A.R.] </P
></BLOCKQUOTE
><P
CLASS="para"
>The order of rules 1 and 2 in the script is significant.  We can't
replace &quot;~~&quot; with &quot;~&quot; until after the procedure for rotating
the entry.</P
><P
CLASS="para"
>Rule 3 does a job similar to that of rule 2; it allows &quot;::&quot; to be used to
output a literal &quot;:&quot; in the index.  However, since we use the colon as
an input delimiter throughout the input to the program, we cannot
allow it to appear in an entry as finally output until the very end.
Thus, we replace the sequence &quot;::&quot; with the colon's ASCII value in
octal.  (The <KBD
CLASS="command"
>format.idx</KBD
> program will reverse the
replacement.)</P
><P
CLASS="para"
>Beginning with rule 4, we attempt to recognize various ways of coding
entries&nbsp;- giving the user more flexibility.  However, to make
writing the remaining programs easier, we must reduce this variety to
a few basic forms.</P
><P
CLASS="para"
>In the &quot;basic&quot; syntax, the primary and secondary keys are separated by
a colon.  The secondary and tertiary keys are separated by a
semicolon.  Nonetheless the program also recognizes a second colon, in
place of a semicolon, as the delimiter between the secondary and
tertiary keys.  It also recognizes that if no colon is specified as a
delimiter, then a comma can be used as the delimiter between primary
and secondary keys.  (In part, this was done to be compatible with an
earlier program that used the comma as the delimiter.)  The
<KBD
CLASS="command"
>sub()</KBD
> function looks for the first comma on
the line and changes it to a colon.  This rule also tries to
standardize the syntax of &quot;see&quot; and &quot;see also&quot; entries.  For entries
that are colon-delimited, rule 4 removes spaces after the colon.
All of the work is done using the <KBD
CLASS="command"
>sub()</KBD
>
function.</P
><P
CLASS="para"
>Rule 5 deals with &quot;see also&quot; entries.  We prepend the arbitrary string
&quot;~zz&quot; to the &quot;see also&quot; entries so that they will sort at the end of
the list of secondary keys.  The <KBD
CLASS="command"
>pagenums.idx</KBD
>
script, later in the pipeline, will remove &quot;~zz&quot; after the entries
have been sorted.</P
><P
CLASS="para"
>Rule 6 matches entries that do not specify a page number.  The only
valid entry without a page number contains a &quot;see&quot; reference.  This
rule outputs &quot;see&quot; entries with &quot;:&quot; at the end to indicate an empty
third field.  All other entries generate an error message via the
<KBD
CLASS="command"
>printerr()</KBD
> function.  This function
notifies the user that a particular entry does not have a page number
and will not be included in the output.  This is one method of
standardizing input&nbsp;- throwing out what you can't interpret
properly.  However, it is critical to notify the user so that he or
she can correct the entry.</P
><P
CLASS="para"
>Rule 7 outputs entries that contain the colon-delimiter.  Its action
uses <KBD
CLASS="command"
>next</KBD
> to avoid reaching rule 8.</P
><P
CLASS="para"
>Finally, rule 8 matches entries that contain only a primary key.  In
other words, there is no delimiter.  We output &quot;::&quot; to indicate an
empty second field.</P
><P
CLASS="para"
>Here's a portion of the contents of our <I
CLASS="filename"
>test</I
>
file.  We'll be using it to generate examples in this section.</P
><P
CLASS="para"
><BLOCKQUOTE
CLASS="screen"
><PRE
CLASS="screen"
>$ <CODE
CLASS="userinput"
><B
>cat test</B
></CODE
>
XView: programs; initialization 45
XV_INIT_ARGS~macro      46
Xv_object~type  49
Xv_singlecolor~type     80
graphics: (see also server image)
graphics, XView model   83
X Window System: events 84
graphics, CANVAS_X_PAINT_WINDOW 86
X Window System, X Window ID for paint window   87
toolkit (See X Window System).
graphics: (see also server image)
Xlib, repainting canvas 88
Xlib.h~header file      89</PRE
></BLOCKQUOTE
></P
><P
CLASS="para"
>When we run this file through <KBD
CLASS="command"
>input.idx</KBD
>, 
it produces:</P
><P
CLASS="para"
><BLOCKQUOTE
CLASS="screen"
><PRE
CLASS="screen"
>$ <CODE
CLASS="userinput"
><B
>input.idx test</B
></CODE
>
XView:programs; initialization:45
XV_INIT_ARGS macro::46
macro:XV_INIT_ARGS:46
Xv_object type::49
type:Xv_object:49
Xv_singlecolor type::80
type:Xv_singlecolor:80
graphics:~zz(see also server image):
graphics:XView model:83
X Window System:events:84
graphics:CANVAS_X_PAINT_WINDOW:86
X Window System:X Window ID for paint window:87
graphics:~zz(see also server image):
Xlib:repainting canvas:88
Xlib.h header file::89
header file:Xlib.h:89</PRE
></BLOCKQUOTE
></P
><P
CLASS="para"
>Each entry now consists of three colon-separated fields.  In the
sample output, you can find examples of entries with only a primary
key, those with primary and secondary keys, and those with primary,
secondary, and tertiary keys.  You can also find examples of rotated
entries, duplicate entries, and &quot;see also&quot; entries.</P
><P
CLASS="para"
>The only difference in the output for multivolume entries is that
each entry would have a fourth field that contains the volume
identifier.</P
></DIV
><DIV
CLASS="sect2"
><H3
CLASS="sect2"
><A
CLASS="title"
NAME="SEDAWK-CH-12-SECT-2.3"
>12.2.3 Sorting the Entries</A
></H3
><P
CLASS="para"
>Now the output produced by <KBD
CLASS="command"
>input.idx</KBD
> is ready to be
sorted.  The easiest way to sort the entries is to use the standard
UNIX <KBD
CLASS="command"
>sort</KBD
> program rather than write a custom
script.  In addition to sorting the entries, we want to remove any
duplicates and for this task we use the <KBD
CLASS="command"
>uniq</KBD
>
program.</P
><P
CLASS="para"
>Here's the command line we use:</P
><BLOCKQUOTE
CLASS="screen"
><PRE
CLASS="screen"
>sort -bdf -t: +0 -1 +1 -2 +3 -4 +2n -3n | uniq</PRE
></BLOCKQUOTE
><P
CLASS="para"
>As you can see, we use a number of options with the
<KBD
CLASS="command"
>sort</KBD
> command.  The first option,
<I
CLASS="option"
>-b</I
>, specifies that leading spaces be ignored.  The
<I
CLASS="option"
>-d</I
> option specifies a dictionary sort in which
symbols and special characters are ignored.  <I
CLASS="option"
>-f</I
>
specifies that lower- and uppercase letters are to be
<EM
CLASS="emphasis"
>folded</EM
> together; in other words, they are to be
treated as the same character for purposes of the sort.  The next
argument is perhaps the most important: <I
CLASS="option"
>-t:</I
> tells the
program to use a colon as a field delimiter for sort keys.  The
&quot;<I
CLASS="option"
>+</I
>&quot; options that follow specify the number of fields to
skip from the beginning of the line.  Therefore, to specify the first
field as the primary sort key, we use &quot;+0.&quot;  Similarly, the
&quot;<I
CLASS="option"
>-</I
>&quot; options specify the end of a sort key.  &quot;-1&quot;
specifies that the primary sort key ends at the first field, or the
beginning of the second field.  The second sort field is the secondary
key.  The fourth field (&quot;+3&quot;) if it exists, contains the volume
number.  The last key to sort is the page number; this requires a
numeric sort (if we did not tell <KBD
CLASS="command"
>sort</KBD
> that this key
consists of numbers, then the number 1 would be followed by 10,
instead of 2).  Notice that we sort page numbers after sorting the
volume numbers.  Thus, all the page numbers for Volume I are sorted in
order before the page numbers for Volume II.  Finally, we pipe the
output to <KBD
CLASS="command"
>uniq</KBD
> to remove identical entries.
Processing the output from <KBD
CLASS="command"
>input.idx</KBD
>, the
<KBD
CLASS="command"
>sort</KBD
> command produces:</P
><BLOCKQUOTE
CLASS="screen"
><PRE
CLASS="screen"
>graphics:CANVAS_X_PAINT_WINDOW:86
graphics:XView model:83
graphics:~zz(see also server image):
header file:Xlib.h:89 
macro:XV_INIT_ARGS:46
toolkit:(See X Window System).:
type:Xv_object:49
type:Xv_singlecolor:80
X Window System:events:84
X Window System:X Window ID for paint window:87
Xlib:repainting canvas:88
Xlib.h header file::89 
XView:programs; initialization:45
XV_INIT_ARGS macro::46
Xv_object type::49
Xv_singlecolor type::80</PRE
></BLOCKQUOTE
></DIV
><DIV
CLASS="sect2"
><H3
CLASS="sect2"
><A
CLASS="title"
NAME="SEDAWK-CH-12-SECT-2.4"
>12.2.4 Handling Page Numbers</A
></H3
><P
CLASS="para"
>The <KBD
CLASS="command"
>pagenums.idx</KBD
> program looks for entries that
differ only in page number and creates a list of page numbers for a
single entry.
The input to this program is four colon-separated fields:</P
><BLOCKQUOTE
CLASS="literallayout"
><P
CLASS="literallayout"
>PRIMARY:SECONDARY:PAGE:VOLUME</P
></BLOCKQUOTE
><P
CLASS="para"
>The fourth is optional.  For now, we consider only the index for a
single book, in which there are no volume numbers.  Remember that the
entries are now sorted.</P
><P
CLASS="para"
>The heart of this program compares the current entry to the previous
one and determines what to output.  The conditionals that implement
the comparison can be extracted and expressed in pseudocode, as
follows:</P
><BLOCKQUOTE
CLASS="screen"
><PRE
CLASS="screen"
>PRIMARY = $1
SECONDARY = $2
PAGE = $3
if (PRIMARY == prevPRIMARY)
	if (SECONDARY == prevSECONDARY)
		print PAGE
	else
		print PRIMARY:SECONDARY:PAGE
else
	print PRIMARY:SECONDARY:PAGE
prevPRIMARY = PRIMARY
prevSECONDARY = SECONDARY</PRE
></BLOCKQUOTE
><P
CLASS="para"
>Let's see how this code handles a series of entries, beginning with:</P
><BLOCKQUOTE
CLASS="screen"
><PRE
CLASS="screen"
>XView::18</PRE
></BLOCKQUOTE
><P
CLASS="para"
>The primary key doesn't match the previous primary key; the line
is output as is:</P
><BLOCKQUOTE
CLASS="screen"
><PRE
CLASS="screen"
>XView::18</PRE
></BLOCKQUOTE
><P
CLASS="para"
>The next entry is:</P
><BLOCKQUOTE
CLASS="screen"
><PRE
CLASS="screen"
>XView:about:3</PRE
></BLOCKQUOTE
><P
CLASS="para"
>When we compare the primary key of this entry to the previous one,
they are the same.  When we compare secondary keys, they differ; we
output the record as is:</P
><BLOCKQUOTE
CLASS="screen"
><PRE
CLASS="screen"
>XView:about:3</PRE
></BLOCKQUOTE
><P
CLASS="para"
>The next entry is:</P
><BLOCKQUOTE
CLASS="screen"
><PRE
CLASS="screen"
>XView:about:7</PRE
></BLOCKQUOTE
><P
CLASS="para"
>Because both the primary and secondary keys match the keys of the
previous entry, we simply output the page number.  (The
<KBD
CLASS="command"
>printf</KBD
> function is used instead of
<KBD
CLASS="command"
>print</KBD
> so that there is no automatic newline.)  This
page number is appended to the previous entry so that it looks like
this:</P
><BLOCKQUOTE
CLASS="screen"
><PRE
CLASS="screen"
>XView:about:3,7</PRE
></BLOCKQUOTE
><P
CLASS="para"
>The next entry also matches both keys:</P
><BLOCKQUOTE
CLASS="screen"
><PRE
CLASS="screen"
>XView:about:10</PRE
></BLOCKQUOTE
><P
CLASS="para"
>Again, only the page number is output so that entry now looks like:</P
><P
CLASS="para"
><BLOCKQUOTE
CLASS="screen"
><PRE
CLASS="screen"
>XView:about:3,7,10</PRE
></BLOCKQUOTE
></P
><P
CLASS="para"
>In this way, three entries that differ only in page number are
combined into a single entry.</P
><P
CLASS="para"
>The full script adds an additional test to see if the volume
identifier matches.  Here's the full <KBD
CLASS="command"
>pagenums.idx</KBD
>
script:</P
><P
CLASS="para"
><BLOCKQUOTE
CLASS="screen"
><PRE
CLASS="screen"
>#!/work/bin/nawk -f
# ------------------------------------------------
# pagenums.idx -- collect pages for common entries 
# Author:  Dale Dougherty
# Version 1.1   7/10/90
# 
# input should be PRIMARY:SECONDARY:PAGE:VOLUME
# ------------------------------------------------

BEGIN { FS = &quot;:&quot;; OFS = &quot;&quot;}

# main routine -- apply to all input lines
{
   # assign fields to variables
	PRIMARY = $1
	SECONDARY = $2
	PAGE = $3
	VOLUME = $4

   # check for a see also and collect it in array
	if (SECONDARY ~ /\([Ss]ee +[Aa]lso/) {
	# create tmp copy &amp; remove &quot;~zz&quot; from copy 
		tmpSecondary = SECONDARY
		sub(/~zz\([Ss]ee +[Aa]lso */, &quot;&quot;, tmpSecondary)
		sub(/\) */, &quot;&quot;, tmpSecondary)
	# remove secondary key along with &quot;~zz&quot;
		sub(/^.*~zz\([Ss]ee +[Aa]lso */, &quot;&quot;, SECONDARY)
		sub(/\) */, &quot;&quot;, SECONDARY)
	# assign to next element of seeAlsoList
		seeAlsoList[++eachSeeAlso] = SECONDARY &quot;; &quot;
		prevPrimary = PRIMARY
	# assign copy to previous secondary key
		prevSecondary = tmpSecondary 
		next
	} # end test for see Also

   # Conditionals to compare keys of current record to previous
   #  record.  If Primary and Secondary keys are the same, only
   #  the page number is printed. 

   # test to see if each PRIMARY key matches previous key
	if (PRIMARY == prevPrimary) {
	# test to see if each SECONDARY key matches previous key
		if (SECONDARY == prevSecondary)
		# test to see if VOLUME matches;
		# print only VOLUME:PAGE
			if (VOLUME == prevVolume)
				printf (&quot;,%s&quot;, PAGE)
			else {
				printf (&quot;; &quot;)
				volpage(VOLUME, PAGE)
			}
		else{
		# if array of See Alsos, output them now
			if (eachSeeAlso) outputSeeAlso(2)
		# print PRIMARY:SECONDARY:VOLUME:PAGE
			printf (&quot;\n%s:%s:&quot;, PRIMARY, SECONDARY)
			volpage(VOLUME, PAGE)
		}
	} # end of test for PRIMARY == prev
	else { # PRIMARY != prev
		# if we have an array of See Alsos, output them now
		if (eachSeeAlso) outputSeeAlso(1)
		if (NR != 1) 
			printf (&quot;\n&quot;)
		if (NF == 1){
			printf (&quot;%s:&quot;, $0)
		}
		else {
			printf (&quot;%s:%s:&quot;, PRIMARY, SECONDARY)
			volpage(VOLUME, PAGE)
		}
	}
   	prevPrimary = PRIMARY
	prevSecondary = SECONDARY
	prevVolume = VOLUME

} # end of main routine

# at end, print newline
END { 
   # in case last entry has &quot;see Also&quot;
	if (eachSeeAlso) outputSeeAlso(1)
	printf(&quot;\n&quot;)
}

# outputSeeAlso function -- list elements of seeAlsoList 
function outputSeeAlso(LEVEL) {
	# LEVEL - indicates which key we need to output
	if (LEVEL == 1)
		printf (&quot;\n%s:(See also &quot;, prevPrimary)
	else {
		sub(/;.*$/, &quot;&quot;, prevSecondary)
		printf (&quot;\n%s:%s; (See also &quot;, prevPrimary, prevSecondary)
	}
	sub(/; $/, &quot;.):&quot;, seeAlsoList[eachSeeAlso])
	for (i = 1; i &lt;= eachSeeAlso; ++i)
		printf (&quot;%s&quot;, seeAlsoList[i]) 
	eachSeeAlso = 0
}

# volpage function -- determine whether or not to print volume info 
# 	two args: volume &amp; page
 
function volpage(v, p)
{
   # if VOLUME is empty then print PAGE only 
	if ( v == &quot;&quot; ) 
		printf (&quot;%s&quot;, p)
	else
   # otherwise print VOLUME^PAGE
		printf (&quot;%s^%s&quot;,v, p)  
}</PRE
></BLOCKQUOTE
></P
><P
CLASS="para"
>Remember, first of all, that the input to the program is sorted by its
keys.  The page numbers are also in order, such that an entry for
&quot;graphics&quot; on page 7 appears in the input before one on page 10.
Similarly, entries for Volume I appear in the input before Volume II.
Therefore, this program need do no sorting; it simply compares the
keys and if they are the same, appends the page number to a list.  In
this way, the entries are reduced.</P
><P
CLASS="para"
>This script also handles &quot;see also&quot; entries.  Since the records are
now sorted, we can remove the special sorting sequence &quot;~zz.&quot;  We also
handle the case where we might encounter consecutive &quot;see also&quot;
entries.  We don't want to output:</P
><BLOCKQUOTE
CLASS="screen"
><PRE
CLASS="screen"
>Toolkit (see also Xt) (See also XView) (See also Motif).</PRE
></BLOCKQUOTE
><P
CLASS="para"
>Instead we'd like to combine them into a list such that they appear
as:</P
><BLOCKQUOTE
CLASS="screen"
><PRE
CLASS="screen"
>Toolkit (see also Xt; XView; Motif)</PRE
></BLOCKQUOTE
><P
CLASS="para"
>To do that, we create an array named <KBD
CLASS="command"
>seeAlsoList</KBD
>.
From <KBD
CLASS="command"
>SECONDARY</KBD
>, we remove the parentheses, the
secondary key if it exists and the &quot;see also&quot; and then assign it to an
element of <KBD
CLASS="command"
>seeAlsoList</KBD
>.  We make a copy of
<KBD
CLASS="command"
>SECONDARY</KBD
> with the secondary key and assign it to
<KBD
CLASS="command"
>prevSecondary</KBD
> for making comparisons to the next
entry.</P
><P
CLASS="para"
>The function <KBD
CLASS="command"
>outputSeeAlso()</KBD
> is called to
read all the elements of the array and print them.  The function
<KBD
CLASS="command"
>volpage()</KBD
> is also simple and determines
whether or not we need to output a volume number.  Both of these
functions are called from more than one place in the code, so the main
reason for defining them as functions is to reduce duplication.</P
><P
CLASS="para"
>Here's an example of what it produces for a single-book index:</P
><BLOCKQUOTE
CLASS="screen"
><PRE
CLASS="screen"
>X Window System:Xlib:6
XFontStruct structure::317
Xlib::6
Xlib:repainting canvas:88
Xlib.h header file::89,294
Xv_Font type::310
XView::18
XView:about:3,7,10
XView:as object-oriented system:17</PRE
></BLOCKQUOTE
><P
CLASS="para"
>Here's an example of what it produces for a master index:</P
><BLOCKQUOTE
CLASS="screen"
><PRE
CLASS="screen"
>reserved names:table of:I^43
Xt:example of programming interface:I^44,65
Xt:objects; list of:I^43,58; II^40
Xt:packages:I^43,61; II^42
Xt:programs; initialization:I^45
Xt:reserved names:I^43,58
Xt:reserved prefixes:I^43,58
Xt:types:I^43,54,61</PRE
></BLOCKQUOTE
><P
CLASS="para"
>The &quot;^&quot; is used as a temporary delimiter between the volume number and
the list of page numbers.</P
></DIV
><DIV
CLASS="sect2"
><H3
CLASS="sect2"
><A
CLASS="title"
NAME="SEDAWK-CH-12-SECT-2.5"
>12.2.5 Merging Entries with the Same Keys</A
></H3
><P
CLASS="para"
>The <KBD
CLASS="command"
>pagenums.idx</KBD
> program reduced entries that were
the same except for the page number.  Now we'll to process
entries that share the same primary key.  We also want to look for
consecutive page numbers and combine them in ranges.</P
><P
CLASS="para"
>The <KBD
CLASS="command"
>combine.idx</KBD
> is quite similar to the
<KBD
CLASS="command"
>pagenums.idx</KBD
> script, making another pass through
the index, comparing entries with the same primary key.  The following
pseudocode abstracts this comparison. (To make this discussion easier, we
will omit tertiary keys and show how to compare primary and secondary
keys.)  After the entries are processed by
<KBD
CLASS="command"
>pagenums.idx</KBD
>, no two entries exist that share the
same primary and secondary keys.  Therefore, we don't have to compare
secondary keys.</P
><BLOCKQUOTE
CLASS="screen"
><PRE
CLASS="screen"
>PRIMARY = $1
SECONDARY = $2
PAGE = $3
if (PRIMARY == prevPRIMARY)
	print :SECONDARY:
else
	print PRIMARY:SECONDARY
prevPRIMARY = PRIMARY
prevSECONDARY = SECONDARY</PRE
></BLOCKQUOTE
><P
CLASS="para"
>If the primary keys match, we output only the secondary
key.  For instance, if there are three entries:</P
><BLOCKQUOTE
CLASS="screen"
><PRE
CLASS="screen"
>XView:18
XView:about:3, 7, 10
XView:as object-oriented system:17</PRE
></BLOCKQUOTE
><P
CLASS="para"
>they will be output as:</P
><P
CLASS="para"
><BLOCKQUOTE
CLASS="screen"
><PRE
CLASS="screen"
>XView:18
:about:3, 7, 10
:as object-oriented system:17</PRE
></BLOCKQUOTE
></P
><P
CLASS="para"
>We drop the primary key when it is the same.  The actual code is a
little more difficult because there are tertiary keys.  We have to
test primary and secondary keys to see if they are unique or the same,
but we don't have to test tertiary keys.  (We only need to know that
they are there.)</P
><P
CLASS="para"
>You no doubt noticed that the above pseudocode does not output page
numbers.  The second role of this script is to examine page numbers
and combine a list of consecutive numbers.  The page numbers are a
comma-separated list that can be loaded into an array, using the
<KBD
CLASS="command"
>split()</KBD
> function.</P
><P
CLASS="para"
>To see if numbers are consecutive, we loop through the array comparing
each element to 1 + the previous element.</P
><P
CLASS="para"
><BLOCKQUOTE
CLASS="screen"
><PRE
CLASS="screen"
>eachpage[j-1]+1 == eachpage[j]</PRE
></BLOCKQUOTE
></P
><P
CLASS="para"
>In other words, if adding 1 to the previous element produces the
current element, then they are consecutive.  The previous element
becomes the first page number in the range and the current element
becomes the last page in the range.  This is done within a
<KBD
CLASS="command"
>while</KBD
> loop until the conditional is not true, and
the page numbers are not consecutive.  Then we output the first page
number and the last page number separated by a hyphen:</P
><P
CLASS="para"
><BLOCKQUOTE
CLASS="screen"
><PRE
CLASS="screen"
>23-25</PRE
></BLOCKQUOTE
></P
><P
CLASS="para"
>The actual code looks more complicated than this because it is called
from a function that must recognize volume and page number pairs.  It
first has to split the volume from the list of page numbers and then
it can call the function (<KBD
CLASS="command"
>rangeOfPages()</KBD
>)
to process the list of numbers.</P
><P
CLASS="para"
>Here is the full listing of <KBD
CLASS="command"
>combine.idx</KBD
>:</P
><P
CLASS="para"
><BLOCKQUOTE
CLASS="screen"
><PRE
CLASS="screen"
>#!/work/bin/nawk -f
# ------------------------------------------------
# combine.idx -- merge keys with same PRIMARY key
#		and combine consecutive page numbers
# Author:  Dale Dougherty
# Version 1.1   7/10/90
# 
# input should be PRIMARY:SECONDARY:PAGELIST
# ------------------------------------------------

BEGIN   { FS = &quot;:&quot;; OFS = &quot;&quot;}
# main routine -- applies to all input lines
#  It compares the keys and merges the duplicates.
{
   # assign first field
	PRIMARY=$1
   # split second field, getting SEC and TERT keys.
	sizeOfArray = split($2, array, &quot;;&quot;) 
	SECONDARY = array[1]
	TERTIARY = array[2]
   # test that tertiary key exists
	if (sizeOfArray &gt; 1) {
	# tertiary key exists
		isTertiary = 1 
	# two cases where &quot;;&quot; might turn up
	# check SEC key for list of &quot;see also&quot; 
		if (SECONDARY ~ /\([sS]ee also/){
			SECONDARY = $2
			isTertiary = 0
		}
	# check TERT key for &quot;see also&quot; 
		if (TERTIARY ~ /\([sS]ee also/){
			TERTIARY = substr($2, (index($2, &quot;;&quot;) + 1))
		}	
	}
	else # tertiary key does not exist
		isTertiary = 0
   # assign third field
	PAGELIST = $3

   # Conditional to compare primary key of this entry to that
   #  of previous entry. Then compare secondary keys.  This 
   #  determines which non-duplicate keys to output.
	if (PRIMARY == prevPrimary) {
		if (isTertiary &amp;&amp; SECONDARY == prevSecondary)
			printf (&quot;;\n::%s&quot;, TERTIARY)
		else
			if (isTertiary)
				printf (&quot;\n:%s; %s&quot;, SECONDARY, TERTIARY)
			else
				printf (&quot;\n:%s&quot;, SECONDARY)
	 }
	 else {
		if (NR != 1) 
			printf (&quot;\n&quot;)
		if ($2 != &quot;&quot;) 
			printf (&quot;%s:%s&quot;, PRIMARY, $2)
		else 
			printf (&quot;%s&quot;, PRIMARY)

		prevPrimary = PRIMARY
	}

	prevSecondary = SECONDARY
} # end of main procedure

# routine for &quot;See&quot; entries (primary key only)
NF == 1 { printf (&quot;\n&quot;) }

# routine for all other entries
#  It handles output of the page number.

NF &gt; 1  {
	if (PAGELIST)
	# calls function numrange() to look for 
 	# consecutive page numbers.
		printf (&quot;:%s&quot;, numrange(PAGELIST))  
	else
		if (! isTertiary || (TERTIARY &amp;&amp; SECONDARY)) printf (&quot;:&quot;)  

} # end of NF &gt; 1

# END procedure outputs newline
END {  printf (&quot;\n&quot;) }

# Supporting Functions

# numrange -- read list of Volume^Page numbers, detach Volume
#		from Page for each Volume and call rangeOfPages 
#		to combine consecutive page numbers in the list. 
#	PAGE = volumes separated by semicolons; volume and page
#		separated by ^.

function numrange(PAGE,     listOfPages, sizeOfArray)
{
  # Split up list by volume.
	sizeOfArray = split(PAGE, howManyVolumes,&quot;;&quot;) 
  # Check to see if more than 1 volume.
	if (sizeOfArray &gt; 1) {

	# if more than 1 volume, loop through list 
		for (i = 1; i &lt;= sizeOfArray; ++i) {
		# for each Volume^Page element, detach Volume 
		# and call rangeOfPages function on Page to
		# separate page numbers and compare to find
		# consecutive numbers.
			if (split(howManyVolumes[i],volPage,&quot;^&quot;) == 2)  
				listOfPages = volPage[1] &quot;^&quot;
				   rangeOfPages(volPage[2])
		# collect output in listOfPages
			if (i == 1) 
				result = listOfPages
			else
				result=result &quot;;&quot; listOfPages
		} # end for loop
	}
	else { # not more than 1 volume

	# check for single volume index with volume number 
	# if so, detach volume number.
	# Both call rangeOfPages on the list of page numbers.
		if (split(PAGE,volPage,&quot;^&quot;) == 2 )  
		# if Volume^Page, detach volume and then call rangeOfPages 
			listOfPages = volPage[1] &quot;^&quot; rangeOfPages(volPage[2])
		else # No volume number involved 
			listOfPages = rangeOfPages(volPage[1])
		result = listOfPages
	} # end of else

	return result  # Volume^Page list

} # End of numrange function

# rangeOfPages -- read list of comma-separated page numbers,  
#		load them into an array, and compare each one
#		to the next, looking for consecutive numbers.
#	PAGENUMBERS = comma-separated list of page numbers

function rangeOfPages(PAGENUMBERS, pagesAll, sizeOfArray,pages,
                       listOfPages, d, p, j) {
   # close-up space on troff-generated ranges
	gsub(/ - /, &quot;,-&quot;, PAGENUMBERS)

   # split list up into eachpage array.
	sizeOfArray = split(PAGENUMBERS, eachpage, &quot;,&quot;)
   # if more than 1 page number
	if (sizeOfArray &gt; 1){
	# for each page number, compare it to previous number + 1
		p = 0  # flag indicates assignment to pagesAll 
	# for loop starts at 2
		for (j = 2; j-1 &lt;= sizeOfArray; ++j) {
		# start by saving first page in sequence (firstpage)    
		# and loop until we find last page (lastpage)
			firstpage = eachpage[j-1]
			d = 0  # flag indicates consecutive numbers found  
		# loop while page numbers are consecutive
			while ((eachpage[j-1]+1) == eachpage[j] ||
					eachpage[j] ~ /^-/) {
			# remove &quot;-&quot; from troff-generated range
				if (eachpage[j] ~ /^-/) {
					sub(/^-/, &quot;&quot;, eachpage[j])
				}
				lastpage = eachpage[j]
			# increment counters
				++d
				++j
			} # end of while loop
		# use values of firstpage and lastpage to make range.
			if (d &gt;= 1) {
			# there is a range
				pages = firstpage &quot;-&quot; lastpage 
			}
			else # no range; only read firstpage 
				pages = firstpage 
		# assign range to pagesAll 
			if (p == 0) {
				pagesAll = pages 
				p = 1
			}
			else {
				pagesAll = pagesAll &quot;,&quot; pages
			}
		}# end of for loop

	# assign pagesAll to listOfPages
		listOfPages = pagesAll

	} # end of sizeOfArray &gt; 1

	else # only one page 
		listOfPages = PAGENUMBERS

   # add space following comma
	gsub(/,/, &quot;, &quot;, listOfPages)
   # return changed list of page numbers
	return listOfPages
} # End of rangeOfPages function</PRE
></BLOCKQUOTE
></P
><P
CLASS="para"
>This script consists of minimal <KBD
CLASS="command"
>BEGIN</KBD
> and
<KBD
CLASS="command"
>END</KBD
> procedures.  The main routine does the work of
comparing primary and secondary keys.  The first part of this routine
assigns the fields to variables.  The second field contains the
secondary and tertiary keys and we use
<KBD
CLASS="command"
>split()</KBD
> to separate them.  Then we test
that there is a tertiary key and set the flag
<KBD
CLASS="command"
>isTertiary</KBD
> to either 1 or 0.</P
><P
CLASS="para"
>The next part of the main procedure contains the conditional
expressions that look for identical keys.  As we said in our
discussion of the pseudocode for this part of the program, entries
with wholly identical keys have already been removed by the
<KBD
CLASS="command"
>pagenums.idx</KBD
>.</P
><P
CLASS="para"
>The conditionals in this procedure determine what keys to output based
on whether or not each is unique.  If the primary key is unique, it is
output, along with the rest of the entry.  If the primary key matches
the previous key, we compare secondary keys.  If the secondary key is
unique, then it is output, along with the rest of the entry.  If the
primary key matches the previous primary key, and the secondary key
matches the previous secondary key, then the tertiary key must be
unique.  Then we only output the tertiary key, leaving the primary and
secondary keys blank.</P
><P
CLASS="para"
>The different forms are shown below:</P
><TABLE
CLASS="simplelist"
><TR
><TD
CLASS="member"
> primary</TD
></TR
><TR
><TD
CLASS="member"
> primary:secondary</TD
></TR
><TR
><TD
CLASS="member"
> :secondary</TD
></TR
><TR
><TD
CLASS="member"
> :secondary:tertiary</TD
></TR
><TR
><TD
CLASS="member"
> ::tertiary</TD
></TR
><TR
><TD
CLASS="member"
> primary:secondary:tertiary</TD
></TR
></TABLE
><P
CLASS="para"
>The main procedure is followed by two additional routines.  The first
of them is executed only when <KBD
CLASS="command"
>NF</KBD
> equals one.  It
deals with the first of the forms on the list above.  That is, there
is no page number so we must output a newline to finish the entry.</P
><P
CLASS="para"
>The second procedure deals with all entries that have page numbers.
This is the procedure where we call a function to take apart the list
of page numbers and look for consecutive pages.  It calls the
<KBD
CLASS="command"
>numrange()</KBD
> function, whose main purpose is
to deal with a multivolume index where a list of page numbers might
look like:</P
><P
CLASS="para"
><BLOCKQUOTE
CLASS="screen"
><PRE
CLASS="screen"
>I^35,55; II^200</PRE
></BLOCKQUOTE
></P
><P
CLASS="para"
>This function calls <KBD
CLASS="command"
>split()</KBD
> using a
semicolon delimiter to separate each volume.  Then we call
<KBD
CLASS="command"
>split()</KBD
> using a &quot;^&quot; delimiter to detach the
volume number from the list of page numbers.  Once we have the list of
pages, we call a second function
<KBD
CLASS="command"
>rangeOfPages()</KBD
> to look for consecutive
numbers.  On a single-book index, such as the sample shown in this
chapter, the <KBD
CLASS="command"
>numrange()</KBD
> function really
does nothing but call <KBD
CLASS="command"
>rangeOfPages()</KBD
>.  We
discussed the meat of the <KBD
CLASS="command"
>rangeOfPages()</KBD
>
function earlier.  The <KBD
CLASS="command"
>eachpage</KBD
> array is created
and a <KBD
CLASS="command"
>while</KBD
> loop is used to go through the array
comparing an element to the one previous.  This function returns the
list of pages.</P
><P
CLASS="para"
>Sample output from this program follows: </P
><P
CLASS="para"
><BLOCKQUOTE
CLASS="screen"
><PRE
CLASS="screen"
>Xlib:6
:repainting canvas:88
Xlib.h header file:89, 294
Xv_Font type:310
XView:18
:about:3, 7, 10
:as object-oriented system:17
:compiling programs:41
:concept of windows differs from X:25
:data types;  table of:20
:example of programming interface:44
:frames and subframes:26
:generic functions:21
:Generic Object:18, 24
:libraries:42
:notification:10, 35
:objects:23-24;
:: table of:20;
:: list of:43
:packages:18, 43
:programmer's model:17-23
:programming interface:41
:programs;  initialization:45
:reserved names:43
:reserved prefixes:43
:structure of applications:41
:subwindows:28
:types:43
:window objects:25</PRE
></BLOCKQUOTE
></P
><P
CLASS="para"
>In particular, notice the entry for &quot;objects&quot; under &quot;XView.&quot;  This is
an example of a secondary key with multiple tertiary keys.  It is also
an example of an entry with a consecutive page range.</P
></DIV
><DIV
CLASS="sect2"
><H3
CLASS="sect2"
><A
CLASS="title"
NAME="SEDAWK-CH-12-SECT-2.6"
>12.2.6 Formatting the Index</A
></H3
><P
CLASS="para"
>The previous scripts have done nearly all of the processing, leaving 
the list of entries in good order.  The
<KBD
CLASS="command"
>format.idx</KBD
> script, probably the easiest of the
scripts, reads the list of entries and generates a report in two
different formats, one for display on a terminal screen and one to
send to <KBD
CLASS="command"
>troff</KBD
> for printing on a laser printer.
Perhaps the only difficulty is that we output the entries grouped by
each letter of the alphabet.</P
><P
CLASS="para"
>A command-line argument sets the variable <KBD
CLASS="command"
>FMT</KBD
> that
determines which of the two output formats is to be used.</P
><P
CLASS="para"
>Here's the full listing for <KBD
CLASS="command"
>format.idx</KBD
>:</P
><P
CLASS="para"
><BLOCKQUOTE
CLASS="screen"
><PRE
CLASS="screen"
>#!/work/bin/nawk -f
# ------------------------------------------------
# format.idx -- prepare formatted index
# Author:  Dale Dougherty
# Version 1.1   7/10/90
# 
# input should be PRIMARY:SECONDARY:PAGE:VOLUME
# Args:  FMT = 0 (default) format for screen
#        FMT = 1 output with troff macros
#        MACDIR = pathname of index troff macro file 
# ------------------------------------------------
BEGIN {		FS = &quot;:&quot;
		upper = &quot;ABCDEFGHIJKLMNOPQRSTUVWXYZ&quot;
		lower = &quot;abcdefghijklmnopqrstuvwxyz&quot; 
}

# Output initial macros if troff FMT 
NR == 1 &amp;&amp; FMT == 1 {
		if (MACDIR)
			printf (&quot;.so %s/indexmacs\n&quot;, MACDIR) 
		else
			printf (&quot;.so indexmacs\n&quot;) 
		printf (&quot;.Se \&quot;\&quot; \&quot;Index\&quot;\n&quot;) 
		printf (&quot;.XC\n&quot;) 
} # end of NR == 1
 

# main routine - apply to all lines
# determine which fields to output
{
   # convert octal colon to &quot;literal&quot; colon 
   # make sub for each field, not $0, so that fields are not parsed
	gsub(/\\72/, &quot;:&quot;, $1)
	gsub(/\\72/, &quot;:&quot;, $2)
	gsub(/\\72/, &quot;:&quot;, $3)

   # assign field to variables
	PRIMARY = $1
	SECONDARY = $2
	TERTIARY = &quot;&quot;
	PAGE = $3
	if (NF == 2) {
		SECONDARY = &quot;&quot;
		PAGE = $2
	}
   # Look for empty fields to determine what to output
	if (! PRIMARY) {  
		if (! SECONDARY) {
			TERTIARY = $3
			PAGE = $4	
			if (FMT == 1)
				printf (&quot;.XF 3 \&quot;%s&quot;, TERTIARY)
			else
				printf (&quot;  %s&quot;, TERTIARY)
		}
		else
		        if (FMT == 1)
			        printf (&quot;.XF 2 \&quot;%s&quot;, SECONDARY)
		        else
			        printf (&quot;  %s&quot;, SECONDARY)
	}
	else { # if primary entry exists	
	     # extract first char of primary entry
		firstChar = substr($1, 1, 1)
	     # see if it is in lower string.
		char = index(lower, firstChar) 
	     # char is an index to lower or upper letter 
		if (char == 0)  {
		# if char not found, see if it is upper
			char = index(upper, firstChar)
			if (char == 0)
				char = prevChar
		}
		# if new char, then start group for new letter of alphabet
		if (char != prevChar) {
			if (FMT == 1)
				printf(&quot;.XF A \&quot;%s\&quot;\n&quot;, substr(upper, char, 1))
			else
				printf(&quot;\n\t\t%s\n&quot;, substr(upper, char, 1))
			prevChar = char
		}
		# now output primary and secondary entry
		if (FMT == 1)
			if (SECONDARY)
				printf (&quot;.XF 1 \&quot;%s\&quot; \&quot;%s&quot;, PRIMARY, SECONDARY)
			else
				printf (&quot;.XF 1 \&quot;%s\&quot; \&quot;&quot;, PRIMARY)
		else
			if (SECONDARY)
				printf (&quot;%s, %s&quot;, PRIMARY, SECONDARY)
			else
				printf (&quot;%s&quot;, PRIMARY)
	}
	
   # if page number, call pageChg to replace &quot;^&quot; with &quot;:&quot;
   # for multi-volume page lists.
	if (PAGE) {
		if (FMT == 1) {
			# added to omit comma after bold entry
			if (! SECONDARY &amp;&amp; ! TERTIARY)
				printf (&quot;%s\&quot;&quot;, pageChg(PAGE))
			else
				printf (&quot;, %s\&quot;&quot;, pageChg(PAGE))
		}
		else
			printf (&quot;, %s&quot;, pageChg(PAGE))
	}
	else if (FMT == 1)
		printf(&quot;\&quot;&quot;)
	
	printf (&quot;\n&quot;)

} # End of main routine

# Supporting function

# pageChg -- convert &quot;^&quot; to &quot;:&quot; in list of volume^page 
#	Arg: pagelist -- list of numbers 

function pageChg(pagelist) {
	 gsub(/\^/, &quot;:&quot;, pagelist)
	 if (FMT == 1) {
		gsub(/[1-9]+\*/, &quot;\\fB&amp;\\P&quot;, pagelist)
		gsub(/\*/, &quot;&quot;, pagelist)
	}
	return pagelist
}# End of pageChg function</PRE
></BLOCKQUOTE
></P
><P
CLASS="para"
>The <KBD
CLASS="command"
>BEGIN</KBD
> procedure defines the field separator and
the strings <KBD
CLASS="command"
>upper</KBD
> and <KBD
CLASS="command"
>lower</KBD
>.
The next procedure is one that outputs the name of the file that
contains the <KBD
CLASS="command"
>troff</KBD
> index macro definitions.  The
name of the macro directory can be set from the command line as the
second argument.</P
><P
CLASS="para"
>The main procedure begins by converting the &quot;hidden&quot; colon to a
literal colon.  Note that we apply the
<KBD
CLASS="command"
>gsub()</KBD
> function to each field rather than
the entire line because doing the latter would cause the line to be
reevaluated and the current order of fields would be disturbed.</P
><P
CLASS="para"
>Next we assign the fields to variables and then test to see whether
the field is empty.  If the primary key is not defined, then we see if
the secondary key is defined.  If it is, we output it.  If it is not,
then we output a tertiary key.  If the primary key is defined, then we
extract its first character and then see if we find it in the
<KBD
CLASS="command"
>lower</KBD
> string.</P
><P
CLASS="para"
><BLOCKQUOTE
CLASS="screen"
><PRE
CLASS="screen"
>firstChar = substr($1, 1, 1)
     
char = index(lower, firstChar)</PRE
></BLOCKQUOTE
></P
><P
CLASS="para"
>The <KBD
CLASS="command"
>char</KBD
> variable holds the position of the letter
in the string.  If this number is greater than or equal to 1, then we
also have an index into the <KBD
CLASS="command"
>upper</KBD
> string.  We
compare each entry and while <KBD
CLASS="command"
>char</KBD
> and
<KBD
CLASS="command"
>prevChar</KBD
> are the same, the current letter of the
alphabet is unchanged.  Once they differ, first we check for the
letter in the <KBD
CLASS="command"
>upper</KBD
> string.  If
<KBD
CLASS="command"
>char</KBD
> is a new letter, we output a centered string
that identifies that letter of the alphabet.</P
><P
CLASS="para"
>Then we look at outputting the primary and secondary entries.
Finally, the list of page numbers is output, after calling the
<KBD
CLASS="command"
>pageChg()</KBD
> function to replace the &quot;^&quot; in
volume-page references with a colon.</P
><P
CLASS="para"
>Sample screen output produced by <KBD
CLASS="command"
>format.idx</KBD
> is
shown below:  </P
><P
CLASS="para"
><BLOCKQUOTE
CLASS="screen"
><PRE
CLASS="screen"
>            X
X Protocol, 6
X Window System, events, 84
  extensibility, 9
  interclient communications, 9
  overview, 3
  protocol, 6
  role of window manager, 9
  server and client relationship, 5
  software hierarchy, 6
  toolkits, 7
  X Window ID for paint window, 87
  Xlib, 6
XFontStruct structure, 317
Xlib, 6
  repainting canvas, 88
Xlib.h header file, 89, 294
Xv_Font type, 310
XView, 18
  about, 3, 7, 10
  as object-oriented system, 17
  compiling programs, 41
  concept of windows differs from X, 25
  data types;  table of, 20
  example of programming interface, 44
  frames and subframes, 26
  generic functions, 21
  Generic Object, 18, 24</PRE
></BLOCKQUOTE
></P
><P
CLASS="para"
>Sample <KBD
CLASS="command"
>troff</KBD
> output produced by <KBD
CLASS="command"
>format.idx</KBD
> is
shown below:  </P
><P
CLASS="para"
><BLOCKQUOTE
CLASS="screen"
><PRE
CLASS="screen"
>.XF A &quot;X&quot;
.XF 1 &quot;X Protocol&quot; &quot;6&quot;
.XF 1 &quot;X Window System&quot; &quot;events, 84&quot;
.XF 2 &quot;extensibility, 9&quot;
.XF 2 &quot;interclient communications, 9&quot;
.XF 2 &quot;overview, 3&quot;
.XF 2 &quot;protocol, 6&quot;
.XF 2 &quot;role of window manager, 9&quot;
.XF 2 &quot;server and client relationship, 5&quot;
.XF 2 &quot;software hierarchy, 6&quot;
.XF 2 &quot;toolkits, 7&quot;
.XF 2 &quot;X Window ID for paint window, 87&quot;
.XF 2 &quot;Xlib, 6&quot;
.XF 1 &quot;XFontStruct structure&quot; &quot;317&quot;
.XF 1 &quot;Xlib&quot; &quot;6&quot;
.XF 2 &quot;repainting canvas, 88&quot;
.XF 1 &quot;Xlib.h header file&quot; &quot;89, 294&quot;
.XF 1 &quot;Xv_Font type&quot; &quot;310&quot;
.XF 1 &quot;XView&quot; &quot;18&quot;
.XF 2 &quot;about, 3, 7, 10&quot;
.XF 2 &quot;as object-oriented system, 17&quot;</PRE
></BLOCKQUOTE
></P
><P
CLASS="para"
>This output must be formatted by <KBD
CLASS="command"
>troff</KBD
> to produce a
printed version of the index.  The index of this book was originally
done using the <KBD
CLASS="command"
>masterindex</KBD
> program.</P
><DIV
CLASS="sect3"
><H4
CLASS="sect3"
><A
CLASS="title"
NAME="SEDAWK-CH-12-SECT-2.6.1"
>12.2.6.1 The masterindex shell script</A
></H4
><P
CLASS="para"
>The <KBD
CLASS="command"
>masterindex</KBD
> shell script is the glue that holds
all of these scripts together and invokes them with the proper options
based on the user's command line.  For instance, the user enters:</P
><P
CLASS="para"
><BLOCKQUOTE
CLASS="screen"
><PRE
CLASS="screen"
>$ <CODE
CLASS="userinput"
><B
>masterindex -s -m volume1 volume2 </B
></CODE
></PRE
></BLOCKQUOTE
></P
><P
CLASS="para"
>to specify that a master index be created from the files
<I
CLASS="filename"
>volume1</I
> and <I
CLASS="filename"
>volume2</I
> and that
the output be sent to the screen.</P
><P
CLASS="para"
>The <KBD
CLASS="command"
>masterindex</KBD
> shell script is presented in <A
CLASS="xref"
HREF="appc_01.htm"
TITLE="Supplement for Chapter 12"
>Appendix C</A
> with the documentation.</P
></DIV
></DIV
><A
CLASS="indexterm"
NAME="AUTOID-11018"
></A
><A
CLASS="indexterm"
NAME="AUTOID-11019"
></A
></DIV
><DIV
CLASS="htmlnav"
><P
></P
><HR
ALIGN="LEFT"
WIDTH="515"
TITLE="footer"><TABLE
WIDTH="515"
BORDER="0"
CELLSPACING="0"
CELLPADDING="0"
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="172"
><A
CLASS="SECT1"
HREF="ch12_01.htm"
TITLE="12.1 An Interactive Spelling Checker"
><IMG
SRC="../gifs/txtpreva.gif"
ALT="Previous: 12.1 An Interactive Spelling Checker"
BORDER="0"></A
></TD
><TD
ALIGN="CENTER"
VALIGN="TOP"
WIDTH="171"
><A
CLASS="book"
HREF="index.htm"
TITLE="sed &amp; awk"
><IMG
SRC="../gifs/txthome.gif"
ALT="sed &amp; awk"
BORDER="0"></A
></TD
><TD
ALIGN="RIGHT"
VALIGN="TOP"
WIDTH="172"
><A
CLASS="SECT1"
HREF="ch12_03.htm"
TITLE="12.3 Spare Details of the masterindex Program"
><IMG
SRC="../gifs/txtnexta.gif"
ALT="Next: 12.3 Spare Details of the masterindex Program"
BORDER="0"></A
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="172"
>12.1 An Interactive Spelling Checker</TD
><TD
ALIGN="CENTER"
VALIGN="TOP"
WIDTH="171"
><A
CLASS="index"
HREF="index/idx_0.htm"
TITLE="Book Index"
><IMG
SRC="../gifs/index.gif"
ALT="Book Index"
BORDER="0"></A
></TD
><TD
ALIGN="RIGHT"
VALIGN="TOP"
WIDTH="172"
>12.3 Spare Details of the masterindex Program</TD
></TR
></TABLE
><HR
ALIGN="LEFT"
WIDTH="515"
TITLE="footer"><IMG
SRC="../gifs/smnavbar.gif"
USEMAP="#map"
BORDER="0"
ALT="The UNIX CD Bookshelf Navigation"><MAP
NAME="map"
><AREA
SHAPE="RECT"
COORDS="0,0,73,21"
HREF="../index.htm"
ALT="The UNIX CD Bookshelf"><AREA
SHAPE="RECT"
COORDS="74,0,163,21"
HREF="../upt/index.htm"
ALT="UNIX Power Tools"><AREA
SHAPE="RECT"
COORDS="164,0,257,21"
HREF="../unixnut/index.htm"
ALT="UNIX in a Nutshell"><AREA
SHAPE="RECT"
COORDS="258,0,321,21"
HREF="../vi/index.htm"
ALT="Learning the vi Editor"><AREA
SHAPE="RECT"
COORDS="322,0,378,21"
HREF="index.htm"
ALT="sed &amp; awk"><AREA
SHAPE="RECT"
COORDS="379,0,438,21"
HREF="../ksh/index.htm"
ALT="Learning the Korn Shell"><AREA
SHAPE="RECT"
COORDS="439,0,514,21"
HREF="../lrnunix/index.htm"
ALT="Learning the UNIX Operating System"></MAP
></DIV
></BODY
></HTML
>
