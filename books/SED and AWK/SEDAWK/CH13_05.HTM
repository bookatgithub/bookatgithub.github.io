<HTML
><HEAD
>
<TITLE>[Chapter 13] 13.5 adj&nbsp;- Adjust Lines for Text Files</TITLE>
<META
NAME="DC.title"
CONTENT="sed &amp; awk"><META
NAME="DC.creator"
CONTENT="Dale Dougherty &amp; Arnold Robbins"><META
NAME="DC.publisher"
CONTENT="O'Reilly &amp; Associates, Inc."><META
NAME="DC.date"
CONTENT="1998-08-03T21:05:33Z"><META
NAME="DC.type"
CONTENT="Text.Monograph"><META
NAME="DC.format"
CONTENT="text/html"
SCHEME="MIME"><META
NAME="DC.source"
CONTENT="1-56592-225-5"
SCHEME="ISBN"><META
NAME="DC.language"
CONTENT="en-US"><META
NAME="generator"
CONTENT="Jade 1.1/O'Reilly DocBook 3.0 to HTML 4.0"><LINK
REV="made"
HREF="mailto:online-books@oreilly.com"
TITLE="Online Books Comments"><LINK
REL="up"
HREF="ch13_01.htm"
TITLE="13. A Miscellany of Scripts"><LINK
REL="prev"
HREF="ch13_04.htm"
TITLE="13.4 mailavg&nbsp;- Check Size of Mailboxes"><LINK
REL="next"
HREF="ch13_06.htm"
TITLE="13.6 readsource&nbsp;- Format Program Source Files for troff"></HEAD
><BODY
BGCOLOR="#FFFFFF"
TEXT="#000000"
><DIV
CLASS="htmlnav"
><H1
><IMG
SRC="gifs/smbanner.gif"
ALT="sed &amp; awk"
USEMAP="#srchmap"
BORDER="0"></H1
><MAP
NAME="srchmap"
><AREA
SHAPE="RECT"
COORDS="0,0,466,65"
HREF="index.htm"
ALT="sed &amp; awk"><AREA
SHAPE="RECT"
COORDS="467,0,514,18"
HREF="../search/ssrch.htm"
ALT="Search this book"></MAP
><TABLE
WIDTH="515"
BORDER="0"
CELLSPACING="0"
CELLPADDING="0"
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="172"
><A
CLASS="SECT1"
HREF="ch13_04.htm"
TITLE="13.4 mailavg&nbsp;- Check Size of Mailboxes"
><IMG
SRC="../gifs/txtpreva.gif"
ALT="Previous: 13.4 mailavg&nbsp;- Check Size of Mailboxes"
BORDER="0"></A
></TD
><TD
ALIGN="CENTER"
VALIGN="TOP"
WIDTH="171"
><B
><FONT
FACE="ARIEL,HELVETICA,HELV,SANSERIF"
SIZE="-1"
>Chapter 13<BR>A Miscellany of Scripts</FONT
></B
></TD
><TD
ALIGN="RIGHT"
VALIGN="TOP"
WIDTH="172"
><A
CLASS="SECT1"
HREF="ch13_06.htm"
TITLE="13.6 readsource&nbsp;- Format Program Source Files for troff"
><IMG
SRC="../gifs/txtnexta.gif"
ALT="Next: 13.6 readsource&nbsp;- Format Program Source Files for troff"
BORDER="0"></A
></TD
></TR
></TABLE
>&nbsp;<HR
ALIGN="LEFT"
WIDTH="515"
TITLE="footer"></DIV
><DIV
CLASS="SECT1"
><H2
CLASS="sect1"
><A
CLASS="title"
NAME="AUTOID-11336"
>13.5 adj&nbsp;- Adjust Lines for Text Files</A
></H2
><P
CLASS="para"
><EM
CLASS="emphasis"
>Contributed by Norman Joseph</EM
></P
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="CH13.B"
></A
>[Because the author used his program to format his mail message
before sending it, we're preserving the linebreaks and
indented paragraphs in presenting it here as the program's example.
This program is similar to the BSD <KBD
CLASS="command"
>fmt</KBD
> program.]</P
><BLOCKQUOTE
CLASS="literallayout"
><P
CLASS="literallayout"
>        Well, I decided to take you up on your offer.  I'm sure there are<BR>more sophisticated gurus out there than me, but I do have a nawk script<BR>that I'm kind of fond of, so I'm sending it in.<BR><BR>        Ok, here's the low down.  When I'm writing e-mail, I often make a<BR>lot of changes to the text (especially if I'm going to post on the net).<BR>So what starts out as a nicely adjusted letter or posting usually ends up<BR>looking pretty sloppy by the time I'm done adding and deleting lines.  So<BR>I end up spending a lot of time joining and breaking lines all through my<BR>document so as to get a nice right-hand margin.  So I say to myself,<BR>&quot;This is just the kind of tedious work a program would be good for.&quot;<BR><BR>        Now, I know I can use <KBD
CLASS="command"
>nroff</KBD
> to filter my document through and<BR>adjust the lines, but it has lousy defaults (IMHO) for simple text like<BR>this.  So, with a view to sharpening my nawk skills I wrote <KBD
CLASS="command"
>adj.nawk</KBD
><BR>and the accompanying shell script wrapper <KBD
CLASS="command"
>adj</KBD
>.  <BR><BR>Here's the syntax for the nawk filter <KBD
CLASS="command"
>adj</KBD
>:<BR><BR><KBD
CLASS="command"
>adj </KBD
>[<I
CLASS="option"
>-l|c|r|b</I
>] [<I
CLASS="option"
>-w</I
> <CODE
CLASS="replaceable"
><I
>n</I
></CODE
>] [<I
CLASS="option"
>-i</I
> <CODE
CLASS="replaceable"
><I
>n</I
></CODE
>] [<CODE
CLASS="replaceable"
><I
>files ...</I
></CODE
>]<BR><BR>The options are:</P
></BLOCKQUOTE
><DL
CLASS="variablelist"
><DT
CLASS="term"
><I
CLASS="option"
>-l</I
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
>Lines are left adjusted, right ragged (default).</P
></DD
><DT
CLASS="term"
><I
CLASS="option"
>-c</I
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
>Lines are centered.</P
></DD
><DT
CLASS="term"
><I
CLASS="option"
>-r</I
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
>Lines are right adjusted, left ragged.</P
></DD
><DT
CLASS="term"
><I
CLASS="option"
>-b</I
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
>Lines are left and right adjusted.</P
></DD
><DT
CLASS="term"
><I
CLASS="option"
>-w</I
> <CODE
CLASS="replaceable"
><I
>n</I
></CODE
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
>Sets line width to <CODE
CLASS="replaceable"
><I
>n</I
></CODE
> characters (default is 70).</P
></DD
><DT
CLASS="term"
><I
CLASS="option"
>-i</I
> <CODE
CLASS="replaceable"
><I
>n</I
></CODE
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
>Sets initial indent to <CODE
CLASS="replaceable"
><I
>n</I
></CODE
> characters (default is 0).</P
></DD
></DL
><BLOCKQUOTE
CLASS="literallayout"
><P
CLASS="literallayout"
>        So, whenever I'm finished with this letter (I'm using <KBD
CLASS="command"
>vi</KBD
>) I will<BR>give the command <KBD
CLASS="command"
>:%!adj -w73</KBD
> (I like my lines a little longer) and<BR>all the breaking and joining will be done by a program (the way the Good<BR>Lord intended :-).  Indents and blank lines are preserved, and two spaces<BR>are given after any end-of-sentence punctuation.<BR><BR>        The program is naive about tabs, and when computing line lengths,<BR>it considers a tab character to be one space wide.<BR><BR>        The program is notable for its use of command-line parameter<BR>assignment, and some of the newer features of awk (nawk), such as the<BR>match and split built-in functions, and for its use of support functions.</P
></BLOCKQUOTE
><BLOCKQUOTE
CLASS="screen"
><PRE
CLASS="screen"
>#! /bin/sh
#
# adj - adjust text lines
#
# usage: adj [-l|c|r|b] [-w n] [-i n] [files ...]
#
# options:
#    -l    - lines are left adjusted, right ragged (default)
#    -c    - lines are centered
#    -r    - lines are right adjusted, left ragged
#    -b    - lines are left and right adjusted
#    -w n  - sets line width to &lt;n&gt; characters (default: 70)
#    -i n  - sets initial indent to &lt;n&gt; characters (default: 0)
#
# note:
#    output line width is -w setting plus -i setting
#
# author:
#    Norman Joseph (amanue!oglvee!norm)

adj=l
wid=70
ind=0

set -- `getopt lcrbw:i: $*`
if test $? != 0
then
    printf 'usage: %s [-l|c|r|b] [-w n] [-i n] [files ...]' $0
    exit 1
fi

for arg in $*
do
    case $arg in
    -l) adj=l;  shift;;
    -c) adj=c;  shift;;
    -r) adj=r;  shift;;
    -b) adj=b;  shift;;
    -w) wid=$2;  shift 2;;
    -i) ind=$2;  shift 2;;
    --) shift;  break;;
    esac
done

exec nawk -f adj.nawk type=$adj linelen=$wid indent=$ind $*</PRE
></BLOCKQUOTE
><BLOCKQUOTE
CLASS="literallayout"
><P
CLASS="literallayout"
>Here's the <KBD
CLASS="command"
>adj.nawk</KBD
> script that's called by the shell script <KBD
CLASS="command"
>adj</KBD
>.</P
></BLOCKQUOTE
><BLOCKQUOTE
CLASS="screen"
><PRE
CLASS="screen"
># adj.nawk -- adjust lines of text per options
#
# NOTE:  this nawk program is called from the shell script &quot;adj&quot;
#    see that script for usage &amp; calling conventions
#
# author:
#    Norman Joseph (amanue!oglvee!norm)

BEGIN  {
    FS = &quot;\n&quot;
    blankline  = &quot;^[ \t]*$&quot;
    startblank = &quot;^[ \t]+[^ \t]+&quot;
    startwords = &quot;^[^ \t]+&quot;
}

$0 ~ blankline {
    if ( type == &quot;b&quot; )
        putline( outline &quot;\n&quot; )
    else
        putline( adjust( outline, type ) &quot;\n&quot; )
    putline( &quot;\n&quot; )
    outline = &quot;&quot;
}

$0 ~ startblank {
    if ( outline != &quot;&quot; ) {
        if ( type == &quot;b&quot; )
            putline( outline &quot;\n&quot; )
        else
            putline( adjust( outline, type ) &quot;\n&quot; )
    }

    firstword = &quot;&quot;
    i = 1
    while ( substr( $0, i, 1 ) ~ &quot;[ \t]&quot; ) {
        firstword = firstword substr( $0, i, 1 )
        i++
    }
    inline = substr( $0, i )
    outline = firstword

    nf = split( inline, word, &quot;[ \t]+&quot; )

    for ( i = 1;  i &lt;= nf;  i++ ) {
        if ( i == 1 ) {
            testlen = length( outline word[i] )
        } else {
            testlen = length( outline &quot; &quot; word[i] )
            if ( match( &quot;.!?:;&quot;, &quot;\\&quot; substr( outline,
                    length( outline ), 1 )) )
                testlen++
        }

        if ( testlen &gt; linelen ) {
            putline( adjust( outline, type ) &quot;\n&quot; )
            outline = &quot;&quot;
        }

        if ( outline == &quot;&quot; )
            outline = word[i]
        else if ( i == 1 )
            outline = outline word[i]
        else {
            if ( match( &quot;.!?:;&quot;, &quot;\\&quot; substr( outline,
                   length( outline ), 1 )) )
                outline = outline &quot;  &quot; word[i]     # 2 spaces
            else
                outline = outline &quot; &quot; word[i]      # 1 space
        }
    }
}

$0 ~ startwords  {
    nf = split( $0, word, &quot;[ \t]+&quot; )

    for ( i = 1;  i &lt;= nf;  i++ ) {
        if ( outline == &quot;&quot; )
            testlen = length( word[i] )
        else {
            testlen = length( outline &quot; &quot; word[i] )
            if ( match( &quot;.!?:;&quot;, &quot;\\&quot; substr( outline,
                   length( outline ), 1 )) )
                testlen++
        }

        if ( testlen &gt; linelen ) {
            putline( adjust( outline, type ) &quot;\n&quot; )
            outline = &quot;&quot;
        }

        if ( outline == &quot;&quot; )
            outline = word[i]
        else {
            if ( match( &quot;.!?:;&quot;, &quot;\\&quot; substr( outline,
                   length( outline ), 1 )) )
                outline = outline &quot;  &quot; word[i]     # 2 spaces
            else
                outline = outline &quot; &quot; word[i]      # 1 space
        }
    }
}

END  {
    if ( type == &quot;b&quot; )
        putline( outline &quot;\n&quot; )
    else
        putline( adjust( outline, type ) &quot;\n&quot; )
}


#
# -- support functions --
#

function putline( line,    fmt )
{
    if ( indent ) {
        fmt = &quot;%&quot; indent &quot;s%s&quot;
        printf( fmt, &quot; &quot;, line )
    } else
        printf( &quot;%s&quot;, line )
}


function adjust( line, type,    fill, fmt )
{
    if ( type != &quot;l&quot; )
        fill = linelen - length( line )

    if ( fill &gt; 0 ) {
        if        ( type == &quot;c&quot; ) {
            fmt = &quot;%&quot; (fill+1)/2 &quot;s%s&quot;
            line = sprintf( fmt, &quot; &quot;, line )
        } else if ( type == &quot;r&quot; ) {
            fmt = &quot;%&quot; fill &quot;s%s&quot;
            line = sprintf( fmt, &quot; &quot;, line )
        } else if ( type == &quot;b&quot; ) {
            line = fillout( line, fill )
        }
    }

    return line
}


function fillout( line, need,    i, newline, nextchar, blankseen )
{
    while ( need ) {
        newline = &quot;&quot;
        blankseen = 0

        if ( dir == 0 ) {
            for ( i = 1;  i &lt;= length( line );  i++ ) {
                nextchar = substr( line, i, 1 )
                if ( need ) {
                    if ( nextchar == &quot; &quot; ) {
                        if ( ! blankseen ) {
                            newline = newline &quot; &quot;
                            need--
                            blankseen = 1
                        }
                    } else {
                        blankseen = 0
                    }
                }
                newline = newline nextchar
            }

        } else if ( dir == 1 ) {
            for ( i = length( line );  i &gt;= 1;  i-- ) {
                nextchar = substr( line, i, 1 )
                if ( need ) {
                    if ( nextchar == &quot; &quot; ) {
                        if ( ! blankseen ) {
                            newline = &quot; &quot; newline
                            need--
                            blankseen = 1
                        }
                    } else {
                        blankseen = 0
                    }
                }
                newline = nextchar newline
            }
        }

        line = newline
        dir = 1 - dir
    }

    return line
}</PRE
></BLOCKQUOTE
><DIV
CLASS="sect2"
><H3
CLASS="sect2"
><A
CLASS="title"
NAME="SEDAWK-CH-13-SECT-0.0.0.5"
>13.5.1 Program Notes for adj</A
></H3
><P
CLASS="para"
>This small text formatter is a nifty program for those of us
who use text editors.  It allows you to set the maximum line width
and justify paragraphs and thus can be used to format mail
messages or simple letters. </P
><P
CLASS="para"
>The <KBD
CLASS="command"
>adj</KBD
> shell script does all the option setting,
although it could have been done by reading <B
CLASS="emphasis.bold"
>ARGV</B
> 
in the <B
CLASS="emphasis.bold"
>BEGIN</B
> action.  Using the shell to establish command-line
parameters is probably easier
for those who are already familiar with the shell. </P
><P
CLASS="para"
>The lack of comments in the <KBD
CLASS="command"
>adj.awk</KBD
> script makes this
script more difficult to read than some of the others. 
The <KBD
CLASS="command"
>BEGIN</KBD
> procedure assigns three regular expressions to
variables:  <B
CLASS="emphasis.bold"
>blankline</B
>, <B
CLASS="emphasis.bold"
>startblank</B
>,
<B
CLASS="emphasis.bold"
>startwords</B
>.  This is a good technique
(one that you'll see used in <KBD
CLASS="command"
>lex</KBD
> specifications)
because regular expressions can be difficult to read
and the name of the variable makes it clear what it matches.
Remember that modern awks lets you supply a regular expression as
a string, in a variable.</P
><P
CLASS="para"
>There are three main procedures, which can be named by the variable
they match.  The first is <B
CLASS="emphasis.bold"
>blankline</B
>, a procedure
which handles collected
text once a blank line is encountered.  The second is <B
CLASS="emphasis.bold"
>startblank</B
>,
which handles lines that begin with whitespace (spaces or tabs).  The third
is <B
CLASS="emphasis.bold"
>startwords</B
>, which handles a line of text. 
The basic procedure is to read a line of text and determine how many
of the words in that line will fit, given the line width, outputting
those that will fit and saving those that will not in the variable
<B
CLASS="emphasis.bold"
>outline</B
>.  When the next input line is read, the contents of
<B
CLASS="emphasis.bold"
>outline</B
> must be output before that line is output. </P
><P
CLASS="para"
>The <KBD
CLASS="command"
>adjust()</KBD
> function does the work of justifying the text
based on a command-line option specifying the format type.
All types except &quot;l&quot; (left-adjusted, right-ragged) need
to be filled.  Therefore, the first thing this function does
is figure out how much &quot;fill&quot; is needed by subtracting
the length of the current line from the specified line length. 
It makes excellent use of the <KBD
CLASS="command"
>sprintf()</KBD
> function
to actually do the positioning of the text.  For instance,
to center text, the value of <B
CLASS="emphasis.bold"
>fill</B
> (plus 1) is divided by
2 to determine the amount of padding needed on each side of the
line.  This amount is passed through the <B
CLASS="emphasis.bold"
>fmt</B
> variable
as the argument to <KBD
CLASS="command"
>sprintf()</KBD
>:</P
><BLOCKQUOTE
CLASS="screen"
><PRE
CLASS="screen"
>            fmt = &quot;%&quot; (fill+1)/2 &quot;s%s&quot;
            line = sprintf( fmt, &quot; &quot;, line )</PRE
></BLOCKQUOTE
><P
CLASS="para"
>Thus, the space will be used to pad a field that is
the length of half the amount of fill needed.</P
><P
CLASS="para"
>If text is right-justified, the value of <B
CLASS="emphasis.bold"
>fill</B
> itself is used
to pad the field.  Finally, if the format type is &quot;b&quot; (block),
then the function <KBD
CLASS="command"
>fillout</KBD
> is called to determine
where to add spaces that will fill out the line.</P
><P
CLASS="para"
>In looking over the design of the program,
you can see, once again, how the use of functions helps
to clarify what a program is doing. 
It helps to think of the main procedure 
as controlling the flow of input through the program
while procedures handle
the operations performed on the input.
Separating the &quot;operations&quot; from the flow control makes
the program readable and more easily maintained.</P
><P
CLASS="para"
>In passing, we're not sure why <B
CLASS="emphasis.bold"
>FS</B
>, the field separator, is set
to newline
in the <KBD
CLASS="command"
>BEGIN</KBD
> procedure.  This means that the field and record 
separators are the same (i.e., $0 and $1 are the same). 
The <B
CLASS="emphasis.bold"
>split()</B
> function is
called to break the line into fields using tabs or spaces
as the delimiter.</P
><BLOCKQUOTE
CLASS="screen"
><PRE
CLASS="screen"
>nf = split( $0, word, &quot;[ \t]+&quot; )</PRE
></BLOCKQUOTE
><P
CLASS="para"
>It would seem that the field separator could have been set 
to the same regular expression, as follows: </P
><BLOCKQUOTE
CLASS="screen"
><PRE
CLASS="screen"
>FS = &quot;[ \t]+&quot;</PRE
></BLOCKQUOTE
><P
CLASS="para"
>It would be more efficient to use the default field parsing.</P
><P
CLASS="para"
>Finally, using the <B
CLASS="emphasis.bold"
>match()</B
> function to find punctuation is inefficient;
it would have been better to use <B
CLASS="emphasis.bold"
>index()</B
>.</P
></DIV
><A
CLASS="indexterm"
NAME="AUTOID-11442"
></A
></DIV
><DIV
CLASS="htmlnav"
><P
></P
><HR
ALIGN="LEFT"
WIDTH="515"
TITLE="footer"><TABLE
WIDTH="515"
BORDER="0"
CELLSPACING="0"
CELLPADDING="0"
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="172"
><A
CLASS="SECT1"
HREF="ch13_04.htm"
TITLE="13.4 mailavg&nbsp;- Check Size of Mailboxes"
><IMG
SRC="../gifs/txtpreva.gif"
ALT="Previous: 13.4 mailavg&nbsp;- Check Size of Mailboxes"
BORDER="0"></A
></TD
><TD
ALIGN="CENTER"
VALIGN="TOP"
WIDTH="171"
><A
CLASS="book"
HREF="index.htm"
TITLE="sed &amp; awk"
><IMG
SRC="../gifs/txthome.gif"
ALT="sed &amp; awk"
BORDER="0"></A
></TD
><TD
ALIGN="RIGHT"
VALIGN="TOP"
WIDTH="172"
><A
CLASS="SECT1"
HREF="ch13_06.htm"
TITLE="13.6 readsource&nbsp;- Format Program Source Files for troff"
><IMG
SRC="../gifs/txtnexta.gif"
ALT="Next: 13.6 readsource&nbsp;- Format Program Source Files for troff"
BORDER="0"></A
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="172"
>13.4 mailavg&nbsp;- Check Size of Mailboxes</TD
><TD
ALIGN="CENTER"
VALIGN="TOP"
WIDTH="171"
><A
CLASS="index"
HREF="index/idx_0.htm"
TITLE="Book Index"
><IMG
SRC="../gifs/index.gif"
ALT="Book Index"
BORDER="0"></A
></TD
><TD
ALIGN="RIGHT"
VALIGN="TOP"
WIDTH="172"
>13.6 readsource&nbsp;- Format Program Source Files for troff</TD
></TR
></TABLE
><HR
ALIGN="LEFT"
WIDTH="515"
TITLE="footer"><IMG
SRC="../gifs/smnavbar.gif"
USEMAP="#map"
BORDER="0"
ALT="The UNIX CD Bookshelf Navigation"><MAP
NAME="map"
><AREA
SHAPE="RECT"
COORDS="0,0,73,21"
HREF="../index.htm"
ALT="The UNIX CD Bookshelf"><AREA
SHAPE="RECT"
COORDS="74,0,163,21"
HREF="../upt/index.htm"
ALT="UNIX Power Tools"><AREA
SHAPE="RECT"
COORDS="164,0,257,21"
HREF="../unixnut/index.htm"
ALT="UNIX in a Nutshell"><AREA
SHAPE="RECT"
COORDS="258,0,321,21"
HREF="../vi/index.htm"
ALT="Learning the vi Editor"><AREA
SHAPE="RECT"
COORDS="322,0,378,21"
HREF="index.htm"
ALT="sed &amp; awk"><AREA
SHAPE="RECT"
COORDS="379,0,438,21"
HREF="../ksh/index.htm"
ALT="Learning the Korn Shell"><AREA
SHAPE="RECT"
COORDS="439,0,514,21"
HREF="../lrnunix/index.htm"
ALT="Learning the UNIX Operating System"></MAP
></DIV
></BODY
></HTML
>
