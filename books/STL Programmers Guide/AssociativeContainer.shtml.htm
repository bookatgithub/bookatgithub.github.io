<HTML>
<HEAD>
   <META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=iso-8859-1">
   <META NAME="Author" CONTENT="Zafir Anjum">
   <TITLE>Associative Container</TITLE>
    <META name="description" 
     content="A freely available implementation 
     of the C++ Standard Template Library, including 
     hypertext documentation.">
	<META name="keywords" 
	content="generic programming, STL, standard template library">
</HEAD>

<SCRIPT LANGUAGE="JavaScript"><!--
var adcategory = "cpp";
// -->
</SCRIPT>


<TITLE>CodeGuru - Visual C++</TITLE>

<META NAME="Author" CONTENT="developer.com">


<META NAME="Keywords" CONTENT="visual c++ java vb source code software downloads freeware shareware visual basic c++ web development general internet internet security news articles directory reference sample example guide tutorial help resource developer discussion earthweb developer.com">

<META NAME="description" CONTENT="Developer.com offers dedicated downloads for the IT professional developer. Features include visual c++, java, visual basic, vb, source code and more.">
<META NAME="distribution" CONTENT="global">
<META NAME="resource-type" CONTENT="document">
<META NAME="language" CONTENT="en">
</HEAD>
<BODY BGCOLOR="#FFFFFF" TEXT="#000000" LINK="#DD0000" VLINK="#999999" ALINK="#FF0000"><!-- begin main content column -->







































<BR Clear>
<H1>Associative Container</H1>

<Table CellPadding=0 CellSpacing=0 width=100%>
<TR>
<TD Align=left><Img src = "containers.gif" tppabs="http://codeguru.developer.com/cpp/stlguide/containers.gif" Alt=""   WIDTH = "194"  HEIGHT = "38" ></TD>
<TD Align=right><Img src = "concept.gif" tppabs="http://codeguru.developer.com/cpp/stlguide/concept.gif" Alt=""   WIDTH = "194"  HEIGHT = "38" ></TD>
</TR>
<TR>
<TD Align=left VAlign=top><b>Category</b>: containers</TD>
<TD Align=right VAlign=top><b>Component type</b>: concept</TD>
</TR>
</Table>

<h3>Description</h3>
An Associative Container is a variable-sized <A href="Container.shtml.htm" tppabs="http://codeguru.developer.com/cpp/stlguide/Container.shtml">Container</A> that
supports efficient retrieval of elements (values) based on keys.  It
supports insertion and removal of elements, but differs from a
<A href="Sequence.shtml.htm" tppabs="http://codeguru.developer.com/cpp/stlguide/Sequence.shtml">Sequence</A> in that it does not provide a mechanism for inserting an
element at a specific position. <A href="#1">[1]</A>
<P>
As with all containers, the elements in an Associative Container are
of type <tt>value_type</tt>.  Additionally, each element in an Associative
Container has a <i>key</i>, of type <tt>key_type</tt>.  In some Associative
Containers, <A href="SimpleAssociativeContainer.shtml.htm" tppabs="http://codeguru.developer.com/cpp/stlguide/SimpleAssociativeContainer.shtml">Simple Associative Containers</A>, the <tt>value_type</tt> and
<tt>key_type</tt> are the same: elements are their own keys.  In others, the
key is some specific part of the value.  Since elements are stored
according to their keys, it is essential that the key associated with
each element is immutable.  In <A href="SimpleAssociativeContainer.shtml.htm" tppabs="http://codeguru.developer.com/cpp/stlguide/SimpleAssociativeContainer.shtml">Simple Associative Containers</A> this
means that the elements themselves are immutable, while 
in other types of Associative Containers, such as 
<A href="PairAssociativeContainer.shtml.htm" tppabs="http://codeguru.developer.com/cpp/stlguide/PairAssociativeContainer.shtml">Pair Associative Containers</A>, the elements themselves are mutable but
the part of an element that is its key cannot be modified.  This means
that an Associative Container's value type is not <A href="Assignable.shtml.htm" tppabs="http://codeguru.developer.com/cpp/stlguide/Assignable.shtml">Assignable</A>.
<P>
The fact that the value type of an Associative Container is not
<A href="Assignable.shtml.htm" tppabs="http://codeguru.developer.com/cpp/stlguide/Assignable.shtml">Assignable</A> has an important consequence: associative
containers cannot have mutable iterators.  This is simply because
a mutable iterator (as defined in the <A href="trivial.shtml.htm" tppabs="http://codeguru.developer.com/cpp/stlguide/trivial.shtml">Trivial Iterator</A> requirements)
must allow assignment.  That is, if <tt>i</tt> is a mutable iterator and 
<tt>t</tt> is an object of <tt>i</tt>'s value type, then <tt>*i = t</tt> must be a valid
expression.  
<P>
In <A href="SimpleAssociativeContainer.shtml.htm" tppabs="http://codeguru.developer.com/cpp/stlguide/SimpleAssociativeContainer.shtml">Simple Associative Containers</A>, where the elements are the keys,
the elements are completely immutable; the nested types <tt>iterator</tt> and
<tt>const_iterator</tt> are therefore the same.  Other types of associative
containers, however, do have mutable elements, and do provide
iterators through which elements can be modified.  
<A href="PairAssociativeContainer.shtml.htm" tppabs="http://codeguru.developer.com/cpp/stlguide/PairAssociativeContainer.shtml">Pair Associative Containers</A>, for example, have two different
nested types <tt>iterator</tt> and <tt>const_iterator</tt>.  Even in this case,
<tt>iterator</tt> is not a mutable iterator: as explained above,
it does not provide the expression <tt>*i = t</tt>.  It is, however, possible
to modify an element through such an iterator: if, for example, <tt>i</tt>
is of type <tt><A href="Map.shtml.htm" tppabs="http://codeguru.developer.com/cpp/stlguide/Map.shtml">map</A>&lt;int, double&gt;</tt>, then <tt>(*i).second = 3</tt> is a valid
expression.
<P>
In some associative containers, <A href="UniqueAssociativeContainer.shtml.htm" tppabs="http://codeguru.developer.com/cpp/stlguide/UniqueAssociativeContainer.shtml">Unique Associative Containers</A>,
it is guaranteed that no two elements have the same key. <A href="#2">[2]</A>  In other
associative containers, <A href="MultipleAssociativeContainer.shtml.htm" tppabs="http://codeguru.developer.com/cpp/stlguide/MultipleAssociativeContainer.shtml">Multiple Associative Containers</A>, multiple
elements with the same key are permitted.
<h3>Refinement of</h3>
<A href="ForwardContainer.shtml.htm" tppabs="http://codeguru.developer.com/cpp/stlguide/ForwardContainer.shtml">Forward Container</A>, <A href="DefaultConstructible.shtml.htm" tppabs="http://codeguru.developer.com/cpp/stlguide/DefaultConstructible.shtml">Default Constructible</A>
<h3>Associated types</h3>
One new type is introduced, in addition to the types defined in the
<A href="ForwardContainer.shtml.htm" tppabs="http://codeguru.developer.com/cpp/stlguide/ForwardContainer.shtml">Forward Container</A> requirements.
<Table border>
<TR>
<TD VAlign=top>
Key type
</TD>
<TD VAlign=top>
<tt>X::key_type</tt>
</TD>
<TD VAlign=top>
The type of the key associated with <tt>X::value_type</tt>.  Note that the
   key type and value type might be the same.
</TD>
</tr>
</table>
<h3>Notation</h3>
<Table>
<TR>
<TD VAlign=top>
<tt>X</tt>
</TD>
<TD VAlign=top>
A type that is a model of Associative Container
</TD>
</TR>
<TR>
<TD VAlign=top>
<tt>a</tt>
</TD>
<TD VAlign=top>
Object of type <tt>X</tt>
</TD>
</TR>
<TR>
<TD VAlign=top>
<tt>t</tt>
</TD>
<TD VAlign=top>
Object of type <tt>X::value_type</tt>
</TD>
</TR>
<TR>
<TD VAlign=top>
<tt>k</tt>
</TD>
<TD VAlign=top>
Object of type <tt>X::key_type</tt>
</TD>
</TR>
<TR>
<TD VAlign=top>
<tt>p</tt>, <tt>q</tt>
</TD>
<TD VAlign=top>
Object of type <tt>X::iterator</tt>
</TD>
</tr>
</table>
<h3>Definitions</h3>
If <tt>a</tt> is an associative container, then <tt>p</tt> is a
<i>valid iterator in a</i> if it is a valid iterator that is 
reachable from <tt>a.begin()</tt>.
<P>
If <tt>a</tt> is an associative container, then <tt>[p, q)</tt> is a <i>valid range in a</i>
if <tt>[p, q)</tt> is a valid range and <tt>p</tt> is a valid iterator in <tt>a</tt>.
<h3>Valid expressions</h3>
In addition to the expressions defined in <A href="ForwardContainer.shtml.htm" tppabs="http://codeguru.developer.com/cpp/stlguide/ForwardContainer.shtml">Forward Container</A>, the
following expressions must be valid.
<Table border>
<TR>
<TH>
Name
</TH>
<TH>
Expression
</TH>
<TH>
Type requirements
</TH>
<TH>
Return type
</TH>
</TR>
<TR>
<TD VAlign=top>
Default constructor
</TD>
<TD VAlign=top>
<pre>
X()
X a;
</pre>
</TD>
<TD VAlign=top>
&nbsp;
</TD>
<TD VAlign=top>
&nbsp;
</TD>
</TR>
<TR>
<TD VAlign=top>
Erase key
</TD>
<TD VAlign=top>
<tt>a.erase(k)</tt>
</TD>
<TD VAlign=top>
&nbsp;
</TD>
<TD VAlign=top>
<tt>size_type</tt>
</TD>
</TR>
<TR>
<TD VAlign=top>
Erase element
</TD>
<TD VAlign=top>
<tt>a.erase(p)</tt>
</TD>
<TD VAlign=top>
&nbsp;
</TD>
<TD VAlign=top>
<tt>void</tt>
</TD>
</TR>
<TR>
<TD VAlign=top>
Erase range
</TD>
<TD VAlign=top>
<tt>a.erase(p, q)</tt>
</TD>
<TD VAlign=top>
&nbsp;
</TD>
<TD VAlign=top>
<tt>void</tt>
</TD>
</TR>
<TR>
<TD VAlign=top>
Clear
</TD>
<TD VAlign=top>
<tt>a.clear()</tt>
</TD>
<TD VAlign=top>
&nbsp;
</TD>
<TD VAlign=top>
<tt>void</tt>
</TD>
</TR>
<TR>
<TD VAlign=top>
Find
</TD>
<TD VAlign=top>
<tt>a.find(k)</tt>
</TD>
<TD VAlign=top>
&nbsp;
</TD>
<TD VAlign=top>
<tt>iterator</tt> if <tt>a</tt> is mutable, otherwise <tt>const_iterator</tt>
</TD>
</TR>
<TR>
<TD VAlign=top>
Count
</TD>
<TD VAlign=top>
<tt>a.count(k)</tt>
</TD>
<TD VAlign=top>
&nbsp;
</TD>
<TD VAlign=top>
<tt>size_type</tt>
</TD>
</TR>
<TR>
<TD VAlign=top>
Equal range
</TD>
<TD VAlign=top>
<tt>a.equal_range(k)</tt>
</TD>
<TD VAlign=top>
&nbsp;
</TD>
<TD VAlign=top>
<tt>pair&lt;iterator, iterator&gt;</tt> if <tt>a</tt> is mutable, otherwise
   <tt>pair&lt;const_iterator, const_iterator&gt;</tt>.
</TD>
</tr>
</table>
<h3>Expression semantics</h3>
<Table border>
<TR>
<TH>
Name
</TH>
<TH>
Expression
</TH>
<TH>
Precondition
</TH>
<TH>
Semantics
</TH>
<TH>
Postcondition
</TH>
</TR>
<TR>
<TD VAlign=top>
Default constructor
</TD>
<TD VAlign=top>
<pre>
X()
X a;
</pre>
</TD>
<TD VAlign=top>
&nbsp;
</TD>
<TD VAlign=top>
Creates an empty container.
</TD>
<TD VAlign=top>
The size of the container is <tt>0</tt>.
</TD>
</TR>
<TR>
<TD VAlign=top>
Erase key
</TD>
<TD VAlign=top>
<tt>a.erase(k)</tt>
</TD>
<TD VAlign=top>
&nbsp;
</TD>
<TD VAlign=top>
Destroys all elements whose key is the same as <tt>k</tt>, and removes
   them from <tt>a</tt>. <A href="#2">[2]</A>  The return value is the number of elements that
   were erased, <i>i.e.</i> the old value of <tt>a.count(k)</tt>.
</TD>
<TD VAlign=top>
<tt>a.size()</tt> is decremented by <tt>a.count(k)</tt>.
   <tt>a</tt> contains no elements with key <tt>k</tt>.  
</TD>
</TR>
<TR>
<TD VAlign=top>
Erase element
</TD>
<TD VAlign=top>
<tt>a.erase(p)</tt>
</TD>
<TD VAlign=top>
<tt>p</tt> is a dereferenceable iterator in <tt>a</tt>.
</TD>
<TD VAlign=top>
Destroys the element pointed to by <tt>p</tt>, and removes it from <tt>a</tt>.
</TD>
<TD VAlign=top>
<tt>a.size()</tt> is decremented by 1.
</TD>
</TR>
<TR>
<TD VAlign=top>
Erase range
</TD>
<TD VAlign=top>
<tt>a.erase(p, q)</tt>
</TD>
<TD VAlign=top>
<tt>[p, q)</tt> is a valid range in <tt>a</tt>.
</TD>
<TD VAlign=top>
Destroys the elements in the range <tt>[p,q)</tt> and removes them from
   <tt>a</tt>. 
</TD>
<TD VAlign=top>
<tt>a.size()</tt> is decremented by the distance from <tt>i</tt> to <tt>j</tt>.
</TD>
</TR>
<TR>
<TD VAlign=top>
Clear
</TD>
<TD VAlign=top>
<tt>a.clear()</tt>
</TD>
<TD VAlign=top>
&nbsp;
</TD>
<TD VAlign=top>
Equivalent to <tt>a.erase(a.begin(), a.end())</tt>
</TD>
<TD VAlign=top>
&nbsp;
</TD>
</TR>
<TR>
<TD VAlign=top>
Find
</TD>
<TD VAlign=top>
<tt>a.find(k)</tt>
</TD>
<TD VAlign=top>
&nbsp;
</TD>
<TD VAlign=top>
Returns an iterator pointing to an element whose key is the same
   as <tt>k</tt>, or <tt>a.end()</tt> if no such element exists.
</TD>
<TD VAlign=top>
Either the return value is <tt>a.end()</tt>, or else the return value has
   a key that is the same as <tt>k</tt>.
</TD>
</TR>
<TR>
<TD VAlign=top>
Count
</TD>
<TD VAlign=top>
<tt>a.count(k)</tt>
</TD>
<TD VAlign=top>
&nbsp;
</TD>
<TD VAlign=top>
Returns the number of elements in <tt>a</tt> whose keys are the same as <tt>k</tt>.
</TD>
<TD VAlign=top>
&nbsp;
</TD>
</TR>
<TR>
<TD VAlign=top>
Equal range
</TD>
<TD VAlign=top>
<tt>a.equal_range(k)</tt>
</TD>
<TD VAlign=top>
&nbsp;
</TD>
<TD VAlign=top>
Returns a pair <tt>P</tt> such that <tt>[P.first, P.second)</tt> is a range
   containing all elements in <tt>a</tt> whose keys are the same as <tt>k</tt>. <A href="#3">[3]</A>
   If no elements have the same key as <tt>k</tt>, the return value is an empty
   range.
</TD>
<TD VAlign=top>
The distance between <tt>P.first</tt> and <tt>P.second</tt> is equal to
   <tt>a.count(k)</tt>.  If <tt>p</tt> is a dereferenceable iterator in <tt>a</tt>, then
   either <tt>p</tt> lies in the range <tt>[P.first, P.second)</tt>, or else
   <tt>*p</tt> has a key that is not the same as <tt>k</tt>.
</TD>
</tr>
</table>
<h3>Complexity guarantees</h3>
Average complexity for erase key is at most <tt>O(log(size()) + count(k))</tt>.
<P>
Average complexity for erase element is constant time.
<P>
Average complexity for erase range is at most 
   <tt>O(log(size()) + N)</tt>, where <tt>N</tt> is the number of elements in the range.
<P>
Average complexity for count is at most <tt>O(log(size()) + count(k))</tt>.
<P>
Average complexity for find is at most logarithmic.
<P>
Average complexity for equal range is at most logarithmic.
<h3>Invariants</h3>
<Table border>
<TR>
<TD VAlign=top>
Contiguous storage
</TD>
<TD VAlign=top>
All elements with the same key are adjacent to each other.  That
   is, if <tt>p</tt> and <tt>q</tt> are iterators that point to elements that have
   the same key, and if <tt>p</tt> precedes <tt>q</tt>, then every element in the
   range <tt>[p, q)</tt> has the same key as every other element.
</TD>
</TR>
<TR>
<TD VAlign=top>
Immutability of keys
</TD>
<TD VAlign=top>
Every element of an Associative Container has an immutable key.
   Objects may be inserted and erased, but an element in an 
   Associative Container may not be modified in such a way as to change
   its key.
</TD>
</tr>
</table>
<h3>Models</h3>
<UL>
<LI>
<tt><A href="set.shtml.htm" tppabs="http://codeguru.developer.com/cpp/stlguide/set.shtml">set</A></tt>
<LI>
<tt><A href="multiset.shtml.htm" tppabs="http://codeguru.developer.com/cpp/stlguide/multiset.shtml">multiset</A></tt>
<LI>
<tt><A href="hash_set.shtml.htm" tppabs="http://codeguru.developer.com/cpp/stlguide/hash_set.shtml">hash_set</A></tt>
<LI>
<tt><A href="hash_multiset.shtml.htm" tppabs="http://codeguru.developer.com/cpp/stlguide/hash_multiset.shtml">hash_multiset</A></tt>
<LI>
<tt><A href="Map.shtml.htm" tppabs="http://codeguru.developer.com/cpp/stlguide/Map.shtml">map</A></tt>
<LI>
<tt><A href="Multimap.shtml.htm" tppabs="http://codeguru.developer.com/cpp/stlguide/Multimap.shtml">multimap</A></tt>
<LI>
<tt><A href="hash_map.shtml.htm" tppabs="http://codeguru.developer.com/cpp/stlguide/hash_map.shtml">hash_map</A></tt>
<LI>
<tt><A href="hash_multimap.shtml.htm" tppabs="http://codeguru.developer.com/cpp/stlguide/hash_multimap.shtml">hash_multimap</A></tt>
</UL>
<h3>Notes</h3>
<P><A name="1">[1]</A>
The reason there is no such mechanism is that the way in which
elements are arranged in an associative container is typically a class
invariant; elements in a <A href="SortedAssociativeContainer.shtml.htm" tppabs="http://codeguru.developer.com/cpp/stlguide/SortedAssociativeContainer.shtml">Sorted Associative Container</A>, for
example, are always stored in ascending order, and elements in a 
<A href="HashedAssociativeContainer.shtml.htm" tppabs="http://codeguru.developer.com/cpp/stlguide/HashedAssociativeContainer.shtml">Hashed Associative Container</A> are always stored according to the
hash function.  It would make no sense to allow the position of an
element to be chosen arbitrarily.
<P><A name="2">[2]</A>
Keys are not required to be <A href="EqualityComparable.shtml.htm" tppabs="http://codeguru.developer.com/cpp/stlguide/EqualityComparable.shtml">Equality Comparable</A>: associative
containers do not necessarily use <tt>operator==</tt> to determine whether two
keys are the same.  In <A href="SortedAssociativeContainer.shtml.htm" tppabs="http://codeguru.developer.com/cpp/stlguide/SortedAssociativeContainer.shtml">Sorted Associative Containers</A>, for example,
where keys are ordered by a comparison function, two keys are considered
to be the same if neither one is less than the other.
<P><A name="3">[3]</A>
Note the implications of this member function: it means that if
two elements have the same key, there must be no elements with
different keys in between them.  The requirement that elements with
the same key be stored contiguously is an associative container
invariant.
<h3>See also</h3>
<A href="SimpleAssociativeContainer.shtml.htm" tppabs="http://codeguru.developer.com/cpp/stlguide/SimpleAssociativeContainer.shtml">Simple Associative Container</A>, <A href="PairAssociativeContainer.shtml.htm" tppabs="http://codeguru.developer.com/cpp/stlguide/PairAssociativeContainer.shtml">Pair Associative Container</A>,
<A href="UniqueAssociativeContainer.shtml.htm" tppabs="http://codeguru.developer.com/cpp/stlguide/UniqueAssociativeContainer.shtml">Unique Associative Container</A>, <A href="MultipleAssociativeContainer.shtml.htm" tppabs="http://codeguru.developer.com/cpp/stlguide/MultipleAssociativeContainer.shtml">Multiple Associative Container</A>,
<A href="SortedAssociativeContainer.shtml.htm" tppabs="http://codeguru.developer.com/cpp/stlguide/SortedAssociativeContainer.shtml">Sorted Associative Container</A>, 
<A href="UniqueSortedAssociativeContainer.shtml.htm" tppabs="http://codeguru.developer.com/cpp/stlguide/UniqueSortedAssociativeContainer.shtml">Unique Sorted Associative Container</A>, 
<A href="MultipleSortedAssociativeContainer.shtml.htm" tppabs="http://codeguru.developer.com/cpp/stlguide/MultipleSortedAssociativeContainer.shtml">Multiple Sorted Associative Container</A>,
<A href="HashedAssociativeContainer.shtml.htm" tppabs="http://codeguru.developer.com/cpp/stlguide/HashedAssociativeContainer.shtml">Hashed Associative Container</A>,
<A href="UniqueHashedAssociativeContainer.shtml.htm" tppabs="http://codeguru.developer.com/cpp/stlguide/UniqueHashedAssociativeContainer.shtml">Unique Hashed Associative Container</A>, 
<A href="MultipleHashedAssociativeContainer.shtml.htm" tppabs="http://codeguru.developer.com/cpp/stlguide/MultipleHashedAssociativeContainer.shtml">Multiple Hashed Associative Container</A>.

<HR SIZE="6"> <FONT SIZE="-2"> Copyright &copy; 1996 Silicon Graphics, Inc.


</td>

<td valign="top" width="20">&nbsp;&nbsp;&nbsp;</td>

</BODY>
</HTML>