<HTML>
<HEAD>
   <META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=iso-8859-1">
   <META NAME="Author" CONTENT="Zafir Anjum">
   <TITLE>Random Access Iterator</TITLE>
    <META name="description" 
     content="A freely available implementation 
     of the C++ Standard Template Library, including 
     hypertext documentation.">
	<META name="keywords" 
	content="generic programming, STL, standard template library">
</HEAD>

<SCRIPT LANGUAGE="JavaScript"><!--
var adcategory = "cpp";
// -->
</SCRIPT>


<TITLE>CodeGuru - Visual C++</TITLE>

<META NAME="Author" CONTENT="developer.com">


<META NAME="Keywords" CONTENT="visual c++ java vb source code software downloads freeware shareware visual basic c++ web development general internet internet security news articles directory reference sample example guide tutorial help resource developer discussion earthweb developer.com">

<META NAME="description" CONTENT="Developer.com offers dedicated downloads for the IT professional developer. Features include visual c++, java, visual basic, vb, source code and more.">
<META NAME="distribution" CONTENT="global">
<META NAME="resource-type" CONTENT="document">
<META NAME="language" CONTENT="en">
</HEAD>
<BODY BGCOLOR="#FFFFFF" TEXT="#000000" LINK="#DD0000" VLINK="#999999" ALINK="#FF0000"><!-- begin main content column -->







































<BR Clear>
<H1>Random Access Iterator</H1>

<Table CellPadding=0 CellSpacing=0 width=100%>
<TR>
<TD Align=left><Img src = "iterators.gif" tppabs="http://codeguru.developer.com/cpp/stlguide/iterators.gif" Alt=""   WIDTH = "194"  HEIGHT = "38" ></TD>
<TD Align=right><Img src = "concept.gif" tppabs="http://codeguru.developer.com/cpp/stlguide/concept.gif" Alt=""   WIDTH = "194"  HEIGHT = "38" ></TD>
</TR>
<TR>
<TD Align=left VAlign=top><b>Category</b>: iterators</TD>
<TD Align=right VAlign=top><b>Component type</b>: concept</TD>
</TR>
</Table>

<h3>Description</h3>
A Random Access Iterator is an iterator that provides both
increment and decrement (just like a <A href="BidirectionalIterator.shtml.htm" tppabs="http://codeguru.developer.com/cpp/stlguide/BidirectionalIterator.shtml">Bidirectional Iterator</A>),
and that also provides constant-time methods for moving forward
and backward in arbitrary-sized steps.  Random Access Iterators
provide essentially all of the operations of ordinary
C pointer arithmetic.
<h3>Refinement of</h3>
<A href="BidirectionalIterator.shtml.htm" tppabs="http://codeguru.developer.com/cpp/stlguide/BidirectionalIterator.shtml">Bidirectional Iterator</A>, <A href="LessThanComparable.shtml.htm" tppabs="http://codeguru.developer.com/cpp/stlguide/LessThanComparable.shtml">LessThan Comparable</A>
<h3>Associated types</h3>
The same as for <A href="BidirectionalIterator.shtml.htm" tppabs="http://codeguru.developer.com/cpp/stlguide/BidirectionalIterator.shtml">Bidirectional Iterator</A>
<h3>Notation</h3>
<Table>
<TR>
<TD VAlign=top>
<tt>X</tt>
</TD>
<TD VAlign=top>
A type that is a model of Random Access Iterator
</TD>
</TR>
<TR>
<TD VAlign=top>
<tt>T</tt>
</TD>
<TD VAlign=top>
The value type of <tt>X</tt>
</TD>
</TR>
<TR>
<TD VAlign=top>
<tt>Distance</tt>
</TD>
<TD VAlign=top>
The distance type of <tt>X</tt>
</TD>
</TR>
<TR>
<TD VAlign=top>
<tt>i</tt>, <tt>j</tt>
</TD>
<TD VAlign=top>
Object of type <tt>X</tt>
</TD>
</TR>
<TR>
<TD VAlign=top>
<tt>t</tt>
</TD>
<TD VAlign=top>
Object of type <tt>T</tt>
</TD>
</TR>
<TR>
<TD VAlign=top>
<tt>n</tt>
</TD>
<TD VAlign=top>
Object of type <tt>Distance</tt>
</TD>
</tr>
</table>
<h3>Definitions</h3>
<h3>Valid expressions</h3>
In addition to the expressions defined in <A href="BidirectionalIterator.shtml.htm" tppabs="http://codeguru.developer.com/cpp/stlguide/BidirectionalIterator.shtml">Bidirectional Iterator</A>,
the following expressions must be valid.
<Table border>
<TR>
<TH>
Name
</TH>
<TH>
Expression
</TH>
<TH>
Type requirements
</TH>
<TH>
Return type
</TH>
</TR>
<TR>
<TD VAlign=top>
Iterator addition
</TD>
<TD VAlign=top>
<tt>i += n</tt>
</TD>
<TD VAlign=top>
&nbsp;
</TD>
<TD VAlign=top>
<tt>X&amp;</tt>
</TD>
</TR>
<TR>
<TD VAlign=top>
Iterator addition
</TD>
<TD VAlign=top>
<tt>i + n</tt> or <tt>n + i</tt>
</TD>
<TD VAlign=top>
&nbsp;
</TD>
<TD VAlign=top>
<tt>X</tt>
</TD>
</TR>
<TR>
<TD VAlign=top>
Iterator subtraction
</TD>
<TD VAlign=top>
<tt>i -= n</tt>
</TD>
<TD VAlign=top>
&nbsp;
</TD>
<TD VAlign=top>
<tt>X&amp;</tt>
</TD>
</TR>
<TR>
<TD VAlign=top>
Iterator subtraction
</TD>
<TD VAlign=top>
<tt>i - n</tt>
</TD>
<TD VAlign=top>
&nbsp;
</TD>
<TD VAlign=top>
<tt>X</tt>
</TD>
</TR>
<TR>
<TD VAlign=top>
Difference
</TD>
<TD VAlign=top>
<tt>i - j</tt>
</TD>
<TD VAlign=top>
&nbsp;
</TD>
<TD VAlign=top>
<tt>Distance</tt>
</TD>
</TR>
<TR>
<TD VAlign=top>
Element operator
</TD>
<TD VAlign=top>
<tt>i[n]</tt>
</TD>
<TD VAlign=top>
&nbsp;
</TD>
<TD VAlign=top>
Convertible to <tt>T</tt>
</TD>
</TR>
<TR>
<TD VAlign=top>
Element assignment
</TD>
<TD VAlign=top>
<tt>i[n] = t</tt>
</TD>
<TD VAlign=top>
<tt>X</tt> is mutable
</TD>
<TD VAlign=top>
Convertible to <tt>T</tt>
</TD>
</tr>
</table>
<h3>Expression semantics</h3>
Semantics of an expression is defined only where it differs from,
or is not defined in, <A href="BidirectionalIterator.shtml.htm" tppabs="http://codeguru.developer.com/cpp/stlguide/BidirectionalIterator.shtml">Bidirectional Iterator</A> or 
<A href="LessThanComparable.shtml.htm" tppabs="http://codeguru.developer.com/cpp/stlguide/LessThanComparable.shtml">LessThan Comparable</A>.
<Table border>
<TR>
<TH>
Name
</TH>
<TH>
Expression
</TH>
<TH>
Precondition
</TH>
<TH>
Semantics
</TH>
<TH>
Postcondition
</TH>
</TR>
<TR>
<TD VAlign=top>
Forward motion
</TD>
<TD VAlign=top>
<tt>i += n</tt>
</TD>
<TD VAlign=top>
Including <tt>i</tt> itself, there must be <tt>n</tt> dereferenceable or
   past-the-end iterators following or preceding <tt>i</tt>, depending
   on whether <tt>n</tt> is positive or negative.
</TD>
<TD VAlign=top>
If <tt>n &gt; 0</tt>, equivalent to executing <tt>++i</tt> <tt>n</tt> times.  If <tt>n &lt; 0</tt>,
   equivalent to executing <tt>--i</tt> <tt>n</tt> times.  If <tt>n == 0</tt>, this is
   a null operation. <A href="#1">[1]</A>
</TD>
<TD VAlign=top>
<tt>i</tt> is dereferenceable or past-the-end.
</TD>
</TR>
<TR>
<TD VAlign=top>
Iterator addition
</TD>
<TD VAlign=top>
<tt>i + n</tt> or <tt>n + i</tt>
</TD>
<TD VAlign=top>
Same as for <tt>i += n</tt>
</TD>
<TD VAlign=top>
Equivalent to <tt>{ X tmp = i; return tmp += n; }</tt>.  The two forms
   <tt>i + n</tt> and <tt>n + i</tt> are identical.
</TD>
<TD VAlign=top>
Result is dereferenceable or past-the-end
</TD>
</TR>
<TR>
<TD VAlign=top>
Iterator subtraction
</TD>
<TD VAlign=top>
<tt>i -= n</tt>
</TD>
<TD VAlign=top>
Including <tt>i</tt> itself, there must be <tt>n</tt> dereferenceable or
   past-the-end iterators preceding  or following <tt>i</tt>, depending
   on whether <tt>n</tt> is positive or negative.
</TD>
<TD VAlign=top>
Equivalent to <tt>i += (-n)</tt>.
</TD>
<TD VAlign=top>
<tt>i</tt> is dereferenceable or past-the-end.
</TD>
</TR>
<TR>
<TD VAlign=top>
Iterator subtraction
</TD>
<TD VAlign=top>
<tt>i - n</tt>
</TD>
<TD VAlign=top>
Same as for <tt>i -= n</tt>
</TD>
<TD VAlign=top>
Equivalent to <tt>{ X tmp = i; return tmp -= n; }</tt>.
</TD>
<TD VAlign=top>
Result is dereferenceable or past-the-end
</TD>
</TR>
<TR>
<TD VAlign=top>
Difference
</TD>
<TD VAlign=top>
<tt>i - j</tt>
</TD>
<TD VAlign=top>
Either <tt>i</tt> is reachable from <tt>j</tt> or <tt>j</tt> is reachable from <tt>i</tt>, or both.
</TD>
<TD VAlign=top>
Returns a number <tt>n</tt> such that <tt>i == j + n</tt>
</TD>
<TD VAlign=top>
&nbsp;
</TD>
</TR>
<TR>
<TD VAlign=top>
Element operator
</TD>
<TD VAlign=top>
<tt>i[n]</tt>
</TD>
<TD VAlign=top>
<tt>i + n</tt> exists and is dereferenceable.
</TD>
<TD VAlign=top>
Equivalent to <tt>*(i + n)</tt> <A href="#2">[2]</A>
</TD>
<TD VAlign=top>
&nbsp;
</TD>
</TR>
<TR>
<TD VAlign=top>
Element assignment
</TD>
<TD VAlign=top>
<tt>i[n] = t</tt>
</TD>
<TD VAlign=top>
<tt>i + n</tt> exists and is dereferenceable.
</TD>
<TD VAlign=top>
Equivalent to <tt>*(i + n) = t</tt> <A href="#2">[2]</A>
</TD>
<TD VAlign=top>
<tt>i[n]</tt> is a copy of <tt>t</tt>.
</TD>
</TR>
<TR>
<TD VAlign=top>
Less
</TD>
<TD VAlign=top>
<tt>i &lt; j</tt>
</TD>
<TD VAlign=top>
Either <tt>i</tt> is reachable from <tt>j</tt> or <tt>j</tt> is reachable from <tt>i</tt>, or both. <A href="#3">[3]</A>
</TD>
<TD VAlign=top>
As described in <A href="LessThanComparable.shtml.htm" tppabs="http://codeguru.developer.com/cpp/stlguide/LessThanComparable.shtml">LessThan Comparable</A> <A href="#4">[4]</A>
</TD>
<TD VAlign=top>
&nbsp;
</TD>
</tr>
</table>
<h3>Complexity guarantees</h3>
All operations on Random Access Iterators are amortized constant
time. <A href="#5">[5]</A>
<h3>Invariants</h3>
<Table border>
<TR>
<TD VAlign=top>
Symmetry of addition and subtraction
</TD>
<TD VAlign=top>
If <tt>i + n</tt> is well-defined, then <tt>i += n; i -= n;</tt> and <tt>(i + n) - n</tt>
   are null operations.  Similarly, if <tt>i - n</tt> is well-defined, 
   then <tt>i -= n; i += n;</tt> and <tt>(i - n) + n</tt> are null operations.
</TD>
</TR>
<TR>
<TD VAlign=top>
Relation between distance and addition
</TD>
<TD VAlign=top>
If <tt>i - j</tt> is well-defined, then <tt>i == j + (i - j)</tt>.
</TD>
</TR>
<TR>
<TD VAlign=top>
Reachability and distance
</TD>
<TD VAlign=top>
If <tt>i</tt> is reachable from <tt>j</tt>, then <tt>i - j &gt;= 0</tt>.
</TD>
</TR>
<TR>
<TD VAlign=top>
Ordering
</TD>
<TD VAlign=top>
<tt>operator &lt;</tt> is a strict weak ordering, as defined in
   <A href="LessThanComparable.shtml.htm" tppabs="http://codeguru.developer.com/cpp/stlguide/LessThanComparable.shtml">LessThan Comparable</A>.
</TD>
</tr>
</table>
<h3>Models</h3>
<UL>
<LI>
<tt>T*</tt>
<LI>
<tt><A href="Vector.shtml.htm" tppabs="http://codeguru.developer.com/cpp/stlguide/Vector.shtml">vector</A>&lt;T&gt;::iterator</tt>
<LI>
<tt><A href="Vector.shtml.htm" tppabs="http://codeguru.developer.com/cpp/stlguide/Vector.shtml">vector</A>&lt;T&gt;::const_iterator</tt>
<LI>
<tt><A href="Deque.shtml.htm" tppabs="http://codeguru.developer.com/cpp/stlguide/Deque.shtml">deque</A>&lt;T&gt;::iterator</tt>
<LI>
<tt><A href="Deque.shtml.htm" tppabs="http://codeguru.developer.com/cpp/stlguide/Deque.shtml">deque</A>&lt;T&gt;::const_iterator</tt>
</UL>
<h3>Notes</h3>
<P><A name="1">[1]</A>
&quot;Equivalent to&quot; merely means that <tt>i += n</tt> yields the same iterator
as if <tt>i</tt> had been incremented (decremented) <tt>n</tt> times.  It does
not mean that this is how <tt>operator+=</tt> should be implemented; in fact,
this is not a permissible implementation.  It is guaranteed that <tt>i += n</tt>
is amortized constant time, regardless of the magnitude of <tt>n</tt>. <A href="#5">[5]</A>
<P><A name="2">[2]</A>
One minor syntactic oddity: in C, if <tt>p</tt> is a pointer and
<tt>n</tt> is an int, then <tt>p[n]</tt> and <tt>n[p]</tt> are equivalent.  This equivalence
is not guaranteed, however, for Random Access Iterators:  only 
<tt>i[n]</tt> need be supported.  This isn't a terribly important restriction,
though, since the equivalence of <tt>p[n]</tt> and <tt>n[p]</tt> has essentially
no application except for obfuscated C contests.
<P><A name="3">[3]</A>
The precondition defined in <A href="LessThanComparable.shtml.htm" tppabs="http://codeguru.developer.com/cpp/stlguide/LessThanComparable.shtml">LessThan Comparable</A> is that <tt>i</tt>
and <tt>j</tt> be in the domain of <tt>operator &lt;</tt>.  Essentially, then, this
is a definition of that domain: it is the set of pairs of iterators such
that one iterator is reachable from the other.  
<P><A name="4">[4]</A>
All of the other comparison operators have the same domain and
are defined in terms of <tt>operator &lt;</tt>, so they have exactly the same
semantics as described in <A href="LessThanComparable.shtml.htm" tppabs="http://codeguru.developer.com/cpp/stlguide/LessThanComparable.shtml">LessThan Comparable</A>.
<P><A name="5">[5]</A>
This complexity guarantee is in fact the only reason why
Random Access Iterator exists as a distinct concept.  Every
operation in iterator arithmetic can be defined for 
<A href="BidirectionalIterator.shtml.htm" tppabs="http://codeguru.developer.com/cpp/stlguide/BidirectionalIterator.shtml">Bidirectional Iterators</A>; in fact, that is exactly what the 
algorithms <tt><A href="advance.shtml.htm" tppabs="http://codeguru.developer.com/cpp/stlguide/advance.shtml">advance</A></tt> and <tt><A href="distance.shtml.htm" tppabs="http://codeguru.developer.com/cpp/stlguide/distance.shtml">distance</A></tt> do.  The distinction is
simply that the <A href="BidirectionalIterator.shtml.htm" tppabs="http://codeguru.developer.com/cpp/stlguide/BidirectionalIterator.shtml">Bidirectional Iterator</A> implementations are
linear time, while Random Access Iterators are required to support
random access to elements in amortized constant time.  This has
major implications for the sorts of algorithms that can sensibly
be written using the two types of iterators.
<h3>See also</h3>
<A href="LessThanComparable.shtml.htm" tppabs="http://codeguru.developer.com/cpp/stlguide/LessThanComparable.shtml">LessThan Comparable</A>, <A href="trivial.shtml.htm" tppabs="http://codeguru.developer.com/cpp/stlguide/trivial.shtml">Trivial Iterator</A>, 
<A href="BidirectionalIterator.shtml.htm" tppabs="http://codeguru.developer.com/cpp/stlguide/BidirectionalIterator.shtml">Bidirectional Iterator</A>, <A href="Iterators.shtml.htm" tppabs="http://codeguru.developer.com/cpp/stlguide/Iterators.shtml">Iterator overview</A>

<HR SIZE="6"> <FONT SIZE="-2"> Copyright &copy; 1996 Silicon Graphics, Inc.


</td>

<td valign="top" width="20">&nbsp;&nbsp;&nbsp;</td>

</BODY>
</HTML>