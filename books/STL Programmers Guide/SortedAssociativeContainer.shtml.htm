<HTML>
<HEAD>
   <META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=iso-8859-1">
   <META NAME="Author" CONTENT="Zafir Anjum">
   <TITLE>Sorted Associative Container</TITLE>
    <META name="description" 
     content="A freely available implementation 
     of the C++ Standard Template Library, including 
     hypertext documentation.">
	<META name="keywords" 
	content="generic programming, STL, standard template library">
</HEAD>

<SCRIPT LANGUAGE="JavaScript"><!--
var adcategory = "cpp";
// -->
</SCRIPT>


<TITLE>CodeGuru - Visual C++</TITLE>

<META NAME="Author" CONTENT="developer.com">


<META NAME="Keywords" CONTENT="visual c++ java vb source code software downloads freeware shareware visual basic c++ web development general internet internet security news articles directory reference sample example guide tutorial help resource developer discussion earthweb developer.com">

<META NAME="description" CONTENT="Developer.com offers dedicated downloads for the IT professional developer. Features include visual c++, java, visual basic, vb, source code and more.">
<META NAME="distribution" CONTENT="global">
<META NAME="resource-type" CONTENT="document">
<META NAME="language" CONTENT="en">
</HEAD>
<BODY BGCOLOR="#FFFFFF" TEXT="#000000" LINK="#DD0000" VLINK="#999999" ALINK="#FF0000"><!-- begin main content column -->







































<BR Clear>
<H1>Sorted Associative Container</H1>

<Table CellPadding=0 CellSpacing=0 width=100%>
<TR>
<TD Align=left><Img src = "containers.gif" tppabs="http://codeguru.developer.com/cpp/stlguide/containers.gif" Alt=""   WIDTH = "194"  HEIGHT = "38" ></TD>
<TD Align=right><Img src = "concept.gif" tppabs="http://codeguru.developer.com/cpp/stlguide/concept.gif" Alt=""   WIDTH = "194"  HEIGHT = "38" ></TD>
</TR>
<TR>
<TD Align=left VAlign=top><b>Category</b>: containers</TD>
<TD Align=right VAlign=top><b>Component type</b>: concept</TD>
</TR>
</Table>

<h3>Description</h3>
A Sorted Associative Container is a type of <A href="AssociativeContainer.shtml.htm" tppabs="http://codeguru.developer.com/cpp/stlguide/AssociativeContainer.shtml">Associative Container</A>.
Sorted Associative Containers use an ordering relation on their keys;
two keys are considered to be equivalent if neither one is less than
the other.  (If the ordering relation is case-insensitive string
comparison, for example, then the keys &quot;abcde&quot; and &quot;aBcDe&quot; are
equivalent.)  
<P>
Sorted Associative Containers guarantee that the complexity for most
operations is never worse than logarithmic <A href="#1">[1]</A>, and they also
guarantee that their elements are always sorted in ascending order by
key.
<h3>Refinement of</h3>
<A href="ReversibleContainer.shtml.htm" tppabs="http://codeguru.developer.com/cpp/stlguide/ReversibleContainer.shtml">Reversible Container</A>, <A href="AssociativeContainer.shtml.htm" tppabs="http://codeguru.developer.com/cpp/stlguide/AssociativeContainer.shtml">Associative Container</A>
<h3>Associated types</h3>
Two new types are introduced, in addition to the types defined in the
<A href="AssociativeContainer.shtml.htm" tppabs="http://codeguru.developer.com/cpp/stlguide/AssociativeContainer.shtml">Associative Container</A> and <A href="ReversibleContainer.shtml.htm" tppabs="http://codeguru.developer.com/cpp/stlguide/ReversibleContainer.shtml">Reversible Container</A> requirements. 
<Table border>
<TR>
<TD VAlign=top>
<tt>X::key_compare</tt>
</TD>
<TD VAlign=top>
The type of a <A href="StrictWeakOrdering.shtml.htm" tppabs="http://codeguru.developer.com/cpp/stlguide/StrictWeakOrdering.shtml">Strict Weak Ordering</A> used to compare keys.
   Its argument type must be <tt>X::key_type</tt>.
</TD>
</TR>
<TR>
<TD VAlign=top>
<tt>X::value_compare</tt>
</TD>
<TD VAlign=top>
The type of a <A href="StrictWeakOrdering.shtml.htm" tppabs="http://codeguru.developer.com/cpp/stlguide/StrictWeakOrdering.shtml">Strict Weak Ordering</A> used to compare values.
   Its argument type must be <tt>X::value_type</tt>, and it compares two
   objects of <tt>value_type</tt> by passing the keys associated with those
   objects to a function object of type <tt>key_compare</tt>.
</TD>
</tr>
</table>
<h3>Notation</h3>
<Table>
<TR>
<TD VAlign=top>
<tt>X</tt>
</TD>
<TD VAlign=top>
A type that is a model of Sorted Associative Container
</TD>
</TR>
<TR>
<TD VAlign=top>
<tt>a</tt>
</TD>
<TD VAlign=top>
Object of type <tt>X</tt>
</TD>
</TR>
<TR>
<TD VAlign=top>
<tt>t</tt>
</TD>
<TD VAlign=top>
Object of type <tt>X::value_type</tt>
</TD>
</TR>
<TR>
<TD VAlign=top>
<tt>k</tt>
</TD>
<TD VAlign=top>
Object of type <tt>X::key_type</tt>
</TD>
</TR>
<TR>
<TD VAlign=top>
<tt>p</tt>, <tt>q</tt>
</TD>
<TD VAlign=top>
Object of type <tt>X::iterator</tt>
</TD>
</TR>
<TR>
<TD VAlign=top>
<tt>c</tt>
</TD>
<TD VAlign=top>
Object of type <tt>X::key_compare</tt>
</TD>
</tr>
</table>
<h3>Definitions</h3>
<h3>Valid expressions</h3>
In addition to the expressions defined in <A href="AssociativeContainer.shtml.htm" tppabs="http://codeguru.developer.com/cpp/stlguide/AssociativeContainer.shtml">Associative Container</A>
and <A href="ReversibleContainer.shtml.htm" tppabs="http://codeguru.developer.com/cpp/stlguide/ReversibleContainer.shtml">Reversible Container</A>, the following expressions must be valid.
<Table border>
<TR>
<TH>
Name
</TH>
<TH>
Expression
</TH>
<TH>
Type requirements
</TH>
<TH>
Return type
</TH>
</TR>
<TR>
<TD VAlign=top>
Default constructor
</TD>
<TD VAlign=top>
<pre>
X()
X a;
</pre>
</TD>
<TD VAlign=top>
&nbsp;
</TD>
<TD VAlign=top>
&nbsp;
</TD>
</TR>
<TR>
<TD VAlign=top>
Constructor with compare
</TD>
<TD VAlign=top>
<pre>
X(c)
X a(c);
</pre>
</TD>
<TD VAlign=top>
&nbsp;
</TD>
<TD VAlign=top>
&nbsp;
</TD>
</TR>
<TR>
<TD VAlign=top>
Key comparison
</TD>
<TD VAlign=top>
<tt>a.key_comp()</tt>
</TD>
<TD VAlign=top>
&nbsp;
</TD>
<TD VAlign=top>
<tt>X::key_compare</tt>
</TD>
</TR>
<TR>
<TD VAlign=top>
Value comparison
</TD>
<TD VAlign=top>
<tt>a::value_compare()</tt>
</TD>
<TD VAlign=top>
&nbsp;
</TD>
<TD VAlign=top>
<tt>X::value_compare</tt>
</TD>
</TR>
<TR>
<TD VAlign=top>
Lower bound
</TD>
<TD VAlign=top>
<tt>a.lower_bound(k)</tt>
</TD>
<TD VAlign=top>
&nbsp;
</TD>
<TD VAlign=top>
<tt>iterator</tt> if <tt>a</tt> is mutable, otherwise <tt>const_iterator</tt>.
</TD>
</TR>
<TR>
<TD VAlign=top>
Upper bound
</TD>
<TD VAlign=top>
<tt>a.upper_bound(k)</tt>
</TD>
<TD VAlign=top>
&nbsp;
</TD>
<TD VAlign=top>
<tt>iterator</tt> if <tt>a</tt> is mutable, otherwise <tt>const_iterator</tt>.
</TD>
</TR>
<TR>
<TD VAlign=top>
Equal range
</TD>
<TD VAlign=top>
<tt>a.equal_range(k)</tt>
</TD>
<TD VAlign=top>
&nbsp;
</TD>
<TD VAlign=top>
<tt>pair&lt;iterator, iterator&gt;</tt> if <tt>a</tt> is mutable, otherwise
   <tt>pair&lt;const_iterator, const_iterator&gt;</tt>.
</TD>
</tr>
</table>
<h3>Expression semantics</h3>
<Table border>
<TR>
<TH>
Name
</TH>
<TH>
Expression
</TH>
<TH>
Precondition
</TH>
<TH>
Semantics
</TH>
<TH>
Postcondition
</TH>
</TR>
<TR>
<TD VAlign=top>
Default constructor
</TD>
<TD VAlign=top>
<pre>
X()
X a;
</pre>
</TD>
<TD VAlign=top>
&nbsp;
</TD>
<TD VAlign=top>
Creates an empty container, using <tt>key_compare()</tt> as the comparison
   object.
</TD>
<TD VAlign=top>
The size of the container is <tt>0</tt>.
</TD>
</TR>
<TR>
<TD VAlign=top>
Constructor with compare
</TD>
<TD VAlign=top>
<pre>
X(c)
X a(c);
</pre>
</TD>
<TD VAlign=top>
&nbsp;
</TD>
<TD VAlign=top>
Creates an empty container, using <tt>c</tt> as the comparison
   object.
</TD>
<TD VAlign=top>
The size of the container is <tt>0</tt>.  <tt>key_comp()</tt> returns a function
   object that is equivalent to <tt>c</tt>.
</TD>
</TR>
<TR>
<TD VAlign=top>
Key comparison
</TD>
<TD VAlign=top>
<tt>a.key_comp()</tt>
</TD>
<TD VAlign=top>
&nbsp;
</TD>
<TD VAlign=top>
Returns the key comparison object used by <tt>a</tt>.
</TD>
<TD VAlign=top>
&nbsp;
</TD>
</TR>
<TR>
<TD VAlign=top>
Value comparison
</TD>
<TD VAlign=top>
<tt>a::value_compare()</tt>
</TD>
<TD VAlign=top>
&nbsp;
</TD>
<TD VAlign=top>
Returns the value comparison object used by <tt>a</tt>.
</TD>
<TD VAlign=top>
If <tt>t1</tt> and <tt>t2</tt> are objects of type <tt>value_type</tt>, and <tt>k1</tt> and
   <tt>k2</tt> are the keys associated with them, then <tt>a.value_comp()(t1, t2)</tt>
   is equivalent to <tt>a.key_comp()(k1, k2)</tt>.
</TD>
</TR>
<TR>
<TD VAlign=top>
Lower bound
</TD>
<TD VAlign=top>
<tt>a.lower_bound(k)</tt>
</TD>
<TD VAlign=top>
&nbsp;
</TD>
<TD VAlign=top>
Returns an iterator pointing to the first element whose key
   is not less than <tt>k</tt>.  Returns <tt>a.end()</tt> if no such element exists.
</TD>
<TD VAlign=top>
If <tt>a</tt> contains any elements that have the same key as <tt>k</tt>, then
   the return value of <tt>lower_bound</tt> points to the first such element.
</TD>
</TR>
<TR>
<TD VAlign=top>
Upper bound
</TD>
<TD VAlign=top>
<tt>a.upper_bound(k)</tt>
</TD>
<TD VAlign=top>
&nbsp;
</TD>
<TD VAlign=top>
Returns an iterator pointing to the first element whose key
   is greater than <tt>k</tt>.  Returns <tt>a.end()</tt> if no such element exists.
</TD>
<TD VAlign=top>
If <tt>a</tt> contains any elements that have the same key as <tt>k</tt>, then
   the return value of <tt>upper_bound</tt> points to one past the last such
   element.
</TD>
</TR>
<TR>
<TD VAlign=top>
Equal range
</TD>
<TD VAlign=top>
<tt>a.equal_range(k)</tt>
</TD>
<TD VAlign=top>
&nbsp;
</TD>
<TD VAlign=top>
Returns a pair whose first element is <tt>a.lower_bound(k)</tt> and whose
   second element is <tt>a.upper_bound(k)</tt>.  
</TD>
<TD VAlign=top>
&nbsp;
</TD>
</tr>
</table>
<h3>Complexity guarantees</h3>
<tt>key_comp()</tt> and <tt>value_comp()</tt> are constant time.
<P>
Erase element is constant time.
<P>
Erase key is <tt>O(log(size()) + count(k))</tt>. <A href="#1">[1]</A>
<P>
Erase range is <tt>O(log(size()) + N)</tt>, where <tt>N</tt> is the length of the
range. <A href="#1">[1]</A>
<P>
Find is logarithmic. <A href="#1">[1]</A>
<P>
Count is <tt>O(log(size()) + count(k))</tt>. <A href="#1">[1]</A>
<P>
Lower bound, upper bound, and equal range are logarithmic. <A href="#1">[1]</A>
<h3>Invariants</h3>
<Table border>
<TR>
<TD VAlign=top>
Definition of <tt>value_comp</tt>
</TD>
<TD VAlign=top>
If <tt>t1</tt> and <tt>t2</tt> are objects of type <tt>X::value_type</tt> and
   <tt>k1</tt> and <tt>k2</tt> are the keys associated with those objects, then
   <tt>a.value_comp()</tt> returns a <A href="functors.shtml.htm" tppabs="http://codeguru.developer.com/cpp/stlguide/functors.shtml">function object</A> such that
   <tt>a.value_comp()(t1, t2)</tt> is equivalent to <tt>a.key_comp()(k1, k2)</tt>.
</TD>
</TR>
<TR>
<TD VAlign=top>
Ascending order
</TD>
<TD VAlign=top>
The elements in a Sorted Associative Container are always arranged
   in ascending order by key.  That is, if <tt>a</tt> is a Sorted Associative
   Container, then <tt><A href="is_sorted.shtml.htm" tppabs="http://codeguru.developer.com/cpp/stlguide/is_sorted.shtml">is_sorted</A>(a.begin(), a.end(), a.value_comp())</tt> 
   is always <tt>true</tt>.
</TD>
</tr>
</table>
<h3>Models</h3>
<UL>
<LI>
<tt><A href="set.shtml.htm" tppabs="http://codeguru.developer.com/cpp/stlguide/set.shtml">set</A></tt>
<LI>
<tt><A href="multiset.shtml.htm" tppabs="http://codeguru.developer.com/cpp/stlguide/multiset.shtml">multiset</A></tt>
<LI>
<tt><A href="Map.shtml.htm" tppabs="http://codeguru.developer.com/cpp/stlguide/Map.shtml">map</A></tt>
<LI>
<tt><A href="Multimap.shtml.htm" tppabs="http://codeguru.developer.com/cpp/stlguide/Multimap.shtml">multimap</A></tt>
</UL>
<h3>Notes</h3>
<P><A name="1">[1]</A>
This is a much stronger guarantee than the one provided
by <A href="AssociativeContainer.shtml.htm" tppabs="http://codeguru.developer.com/cpp/stlguide/AssociativeContainer.shtml">Associative Container</A>.  The guarantees in <A href="AssociativeContainer.shtml.htm" tppabs="http://codeguru.developer.com/cpp/stlguide/AssociativeContainer.shtml">Associative Container</A>
only apply to average complexity; worst case complexity is allowed to
be greater.  Sorted Associative Container, however, provides an upper
limit on worst case complexity.
<P><A name="2">[2]</A>
This definition is consistent with the semantics described in
<A href="AssociativeContainer.shtml.htm" tppabs="http://codeguru.developer.com/cpp/stlguide/AssociativeContainer.shtml">Associative Container</A>.  It is a stronger condition, though: if
<tt>a</tt> contains no elements with the key <tt>k</tt>, then <tt>a.equal_range(k)</tt>
returns an empty range that indicates the position where those elements
would be if they did exist.  The <A href="AssociativeContainer.shtml.htm" tppabs="http://codeguru.developer.com/cpp/stlguide/AssociativeContainer.shtml">Associative Container</A> requirements,
however, merely state that the return value is an arbitrary empty range.
<h3>See also</h3>
<A href="AssociativeContainer.shtml.htm" tppabs="http://codeguru.developer.com/cpp/stlguide/AssociativeContainer.shtml">Associative Container</A>, <A href="HashedAssociativeContainer.shtml.htm" tppabs="http://codeguru.developer.com/cpp/stlguide/HashedAssociativeContainer.shtml">Hashed Associative Container</A>

<HR SIZE="6"> <FONT SIZE="-2"> Copyright &copy; 1996 Silicon Graphics, Inc.


</td>

<td valign="top" width="20">&nbsp;&nbsp;&nbsp;</td>

</BODY>
</HTML>