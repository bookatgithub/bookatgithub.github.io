<HTML>
<HEAD>
   <META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=iso-8859-1">
   <META NAME="Author" CONTENT="Zafir Anjum">
   <TITLE>Trivial Iterator</TITLE>
    <META name="description" 
     content="A freely available implementation 
     of the C++ Standard Template Library, including 
     hypertext documentation.">
	<META name="keywords" 
	content="generic programming, STL, standard template library">
</HEAD>

<SCRIPT LANGUAGE="JavaScript"><!--
var adcategory = "cpp";
// -->
</SCRIPT>


<TITLE>CodeGuru - Visual C++</TITLE>

<META NAME="Author" CONTENT="developer.com">


<META NAME="Keywords" CONTENT="visual c++ java vb source code software downloads freeware shareware visual basic c++ web development general internet internet security news articles directory reference sample example guide tutorial help resource developer discussion earthweb developer.com">

<META NAME="description" CONTENT="Developer.com offers dedicated downloads for the IT professional developer. Features include visual c++, java, visual basic, vb, source code and more.">
<META NAME="distribution" CONTENT="global">
<META NAME="resource-type" CONTENT="document">
<META NAME="language" CONTENT="en">
</HEAD>
<BODY BGCOLOR="#FFFFFF" TEXT="#000000" LINK="#DD0000" VLINK="#999999" ALINK="#FF0000"><!-- begin main content column -->







































<BR Clear>
<H1>Trivial Iterator</H1>

<Table CellPadding=0 CellSpacing=0 width=100%>
<TR>
<TD Align=left><Img src = "iterators.gif" tppabs="http://codeguru.developer.com/cpp/stlguide/iterators.gif" Alt=""   WIDTH = "194"  HEIGHT = "38" ></TD>
<TD Align=right><Img src = "concept.gif" tppabs="http://codeguru.developer.com/cpp/stlguide/concept.gif" Alt=""   WIDTH = "194"  HEIGHT = "38" ></TD>
</TR>
<TR>
<TD Align=left VAlign=top><b>Category</b>: iterators</TD>
<TD Align=right VAlign=top><b>Component type</b>: concept</TD>
</TR>
</Table>

<h3>Description</h3>
A Trivial Iterator is an object that may be dereferenced to refer to
some other object.  Arithmetic operations (such as increment and
comparison) are not guaranteed to be supported.
<h3>Refinement of</h3>
<A href="Assignable.shtml.htm" tppabs="http://codeguru.developer.com/cpp/stlguide/Assignable.shtml">Assignable</A>,
<A href="EqualityComparable.shtml.htm" tppabs="http://codeguru.developer.com/cpp/stlguide/EqualityComparable.shtml">Equality Comparable</A>,
<A href="DefaultConstructible.shtml.htm" tppabs="http://codeguru.developer.com/cpp/stlguide/DefaultConstructible.shtml">Default Constructible</A>
<h3>Associated types</h3>
<Table border>
<TR>
<TD VAlign=top>
Value type
</TD>
<TD VAlign=top>
The type of the value obtained by dereferencing a Trivial Iterator
</TD>
</tr>
</table>
<h3>Notation</h3>
<Table>
<TR>
<TD VAlign=top>
<tt>X</tt>
</TD>
<TD VAlign=top>
A type that is a model of Trivial Iterator
</TD>
</TR>
<TR>
<TD VAlign=top>
<tt>T</tt>
</TD>
<TD VAlign=top>
The value type of <tt>X</tt>
</TD>
</TR>
<TR>
<TD VAlign=top>
<tt>x</tt>, <tt>y</tt>
</TD>
<TD VAlign=top>
Object of type <tt>X</tt>
</TD>
</TR>
<TR>
<TD VAlign=top>
<tt>t</tt>
</TD>
<TD VAlign=top>
Object of type <tt>T</tt>
</TD>
</tr>
</table>
<h3>Definitions</h3>
A type that is a model of Trivial Iterator may be <i>mutable</i>,
meaning that the values referred to by objects of that type may be
modified, or <i>constant</i>, meaning that they may not.  For example,
<tt>int*</tt> is a mutable iterator type and <tt>const int*</tt> is a
constant iterator type.  If an iterator type is mutable, this implies
that its value type is a model of
<A href="Assignable.shtml.htm" tppabs="http://codeguru.developer.com/cpp/stlguide/Assignable.shtml">Assignable</A>; the converse, though, is not
necessarily true.
<P>
A Trivial Iterator may have a <i>singular</i> value, meaning that the
results of most operations, including comparison for equality, are
undefined.  The only operation that a is guaranteed to be supported is
assigning a nonsingular iterator to a singular iterator.
<P>
A Trivial Iterator may have a <i>dereferenceable</i> value, meaning
that dereferencing it yields a well-defined value.  Dereferenceable
iterators are always nonsingular, but the converse is not true.  For
example, a null pointer is nonsingular (there are well defined
operations involving null pointers) even thought it is not
dereferenceable.
<P>
<i>Invalidating</i> a dereferenceable iterator means performing an
operation after which the iterator might be nondereferenceable or
singular.  For example, if <tt>p</tt> is a pointer, then <tt>delete
p</tt> invalidates <tt>p</tt>.
<h3>Valid expressions</h3>
In addition to the expressions defined in
<A href="Assignable.shtml.htm" tppabs="http://codeguru.developer.com/cpp/stlguide/Assignable.shtml">Assignable</A>,
<A href="EqualityComparable.shtml.htm" tppabs="http://codeguru.developer.com/cpp/stlguide/EqualityComparable.shtml">Equality Comparable</A>, and 
<A href="DefaultConstructible.shtml.htm" tppabs="http://codeguru.developer.com/cpp/stlguide/DefaultConstructible.shtml">Default Constructible</A>, the
following expressions must be valid.
<Table border>
<TR>
<TH>
Name
</TH>
<TH>
Expression
</TH>
<TH>
Type requirements
</TH>
<TH>
Return type
</TH>
</TR>
<TR>
<TD VAlign=top>
Default constructor
</TD>
<TD VAlign=top>
<tt>X x</tt>
</TD>
<TD VAlign=top>
&nbsp;
</TD>
<TD VAlign=top>
&nbsp;
</TD>
</TR>
<TR>
<TD VAlign=top>
Dereference
</TD>
<TD VAlign=top>
<tt>*x</tt>
</TD>
<TD VAlign=top>
&nbsp;
</TD>
<TD VAlign=top>
Convertible to <tt>T</tt> <A href="#1">[1]</A>
</TD>
</TR>
<TR>
<TD VAlign=top>
Dereference assignment
</TD>
<TD VAlign=top>
<tt>*x = t</tt>
</TD>
<TD VAlign=top>
<tt>X</tt> is mutable
</TD>
<TD VAlign=top>
&nbsp;
</TD>
</TR>
<TR>
<TD VAlign=top>
Member access
</TD>
<TD VAlign=top>
<tt>x-&gt;m</tt> <A href="#2">[2]</A>
</TD>
<TD VAlign=top>
<tt>T</tt> is a type for which <tt>x.m</tt> is defined
</TD>
<TD VAlign=top>
&nbsp;
</TD>
</tr>
</table>
<h3>Expression semantics</h3>
<Table border>
<TR>
<TH>
Name
</TH>
<TH>
Expression
</TH>
<TH>
Precondition
</TH>
<TH>
Semantics
</TH>
<TH>
Postcondition
</TH>
</TR>
<TR>
<TD VAlign=top>
Default constructor
</TD>
<TD VAlign=top>
<tt>X x</tt>
</TD>
<TD VAlign=top>
&nbsp;
</TD>
<TD VAlign=top>
&nbsp;
</TD>
<TD VAlign=top>
<tt>x</tt> is singular
</TD>
</TR>
<TR>
<TD VAlign=top>
Dereference
</TD>
<TD VAlign=top>
<tt>*x</tt>
</TD>
<TD VAlign=top>
<tt>x</tt> is dereferenceable
</TD>
<TD VAlign=top>
&nbsp;
</TD>
<TD VAlign=top>
&nbsp;
</TD>
</TR>
<TR>
<TD VAlign=top>
Dereference assignment
</TD>
<TD VAlign=top>
<tt>*x = t</tt>
</TD>
<TD VAlign=top>
<tt>x</tt> is dereferenceable
</TD>
<TD VAlign=top>
&nbsp;
</TD>
<TD VAlign=top>
<tt>*x</tt> is a copy of t
</TD>
</TR>
<TR>
<TD VAlign=top>
Member access
</TD>
<TD VAlign=top>
<tt>x-&gt;m</tt>
</TD>
<TD VAlign=top>
<tt>x</tt> is dereferenceable
</TD>
<TD VAlign=top>
Equivalent to <tt>(*x).m</tt>
</TD>
<TD VAlign=top>
&nbsp;
</TD>
</tr>
</table>
<h3>Complexity guarantees</h3>
The complexity of operations on trivial iterators is
guaranteed to be amortized constant time.
<h3>Invariants</h3>
<Table border>
<TR>
<TD VAlign=top>
Identity
</TD>
<TD VAlign=top>
<tt>x == y</tt> if and only if <tt>&amp;*x == &amp;*y</tt>
</TD>
</tr>
</table>
<h3>Models</h3>
<UL>
<LI>
A pointer to an object that is not part of an array.
</UL>
<h3>Notes</h3>
<P><A name="1">[1]</A>
The requirement for the return type of <tt>*x</tt> is specified as
&quot;convertible to <tt>T</tt>&quot;, rather than simply <tt>T</tt>,
because it sometimes makes sense for an iterator to return some sort
of proxy object instead of the object that the iterator conceptually
points to.  Proxy objects are implementation details rather than part
of an interface (one use of them, for example, is to allow an iterator
to behave differently depending on whether its value is being read or
written), so the value type of an iterator that returns a proxy is
still <tt>T</tt>.
<P><A name="2">[2]</A>
Defining <tt>operator-&gt;</tt> for iterators depends on a feature
that is part of the C++ language but that is not yet widely
implemented by C++ compilers.  It is therefore not implemented in this
release; once compilers that support it become more common, future
releases of the STL will provide <tt>operator-&gt;</tt> for iterators.
In the mean time, the workaround is to use <tt>(*it).m</tt> instead of
<tt>it-&gt;m</tt>.
<h3>See also</h3>
<A href="InputIterator.shtml.htm" tppabs="http://codeguru.developer.com/cpp/stlguide/InputIterator.shtml">Input Iterator</A>, <A href="OutputIterator.shtml.htm" tppabs="http://codeguru.developer.com/cpp/stlguide/OutputIterator.shtml">Output Iterator</A>, <A href="ForwardIterator.shtml.htm" tppabs="http://codeguru.developer.com/cpp/stlguide/ForwardIterator.shtml">Forward Iterator</A>,
<A href="BidirectionalIterator.shtml.htm" tppabs="http://codeguru.developer.com/cpp/stlguide/BidirectionalIterator.shtml">Bidirectional Iterator</A>, <A href="RandomAccessIterator.shtml.htm" tppabs="http://codeguru.developer.com/cpp/stlguide/RandomAccessIterator.shtml">Random Access Iterator</A>,
<A href="Iterators.shtml.htm" tppabs="http://codeguru.developer.com/cpp/stlguide/Iterators.shtml">Iterator Overview</A>

<HR SIZE="6"> <FONT SIZE="-2"> Copyright &copy; 1996 Silicon Graphics, Inc.


</td>

<td valign="top" width="20">&nbsp;&nbsp;&nbsp;</td>

</BODY>
</HTML>