<HTML>
<HEAD>
   <META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=iso-8859-1">
   <META NAME="Author" CONTENT="Zafir Anjum">
   <TITLE>value_type</TITLE>
    <META name="description" 
     content="A freely available implementation 
     of the C++ Standard Template Library, including 
     hypertext documentation.">
	<META name="keywords" 
	content="generic programming, STL, standard template library">
</HEAD>

<SCRIPT LANGUAGE="JavaScript"><!--
var adcategory = "cpp";
// -->
</SCRIPT>


<TITLE>CodeGuru - Visual C++</TITLE>

<META NAME="Author" CONTENT="developer.com">


<META NAME="Keywords" CONTENT="visual c++ java vb source code software downloads freeware shareware visual basic c++ web development general internet internet security news articles directory reference sample example guide tutorial help resource developer discussion earthweb developer.com">

<META NAME="description" CONTENT="Developer.com offers dedicated downloads for the IT professional developer. Features include visual c++, java, visual basic, vb, source code and more.">
<META NAME="distribution" CONTENT="global">
<META NAME="resource-type" CONTENT="document">
<META NAME="language" CONTENT="en">
</HEAD>
<BODY BGCOLOR="#FFFFFF" TEXT="#000000" LINK="#DD0000" VLINK="#999999" ALINK="#FF0000"><!-- begin main content column -->







































<BR Clear>
<H1>value_type</H1>

<Table CellPadding=0 CellSpacing=0 width=100%>
<TR>
<TD Align=left><Img src = "iterators.gif" tppabs="http://codeguru.developer.com/cpp/stlguide/iterators.gif" Alt=""   WIDTH = "194"  HEIGHT = "38" ></TD>
<TD Align=right><Img src = "function.gif" tppabs="http://codeguru.developer.com/cpp/stlguide/function.gif" Alt=""   WIDTH = "194"  HEIGHT = "38" ></TD>
</TR>
<TR>
<TD Align=left VAlign=top><b>Category</b>: iterators</TD>
<TD Align=right VAlign=top><b>Component type</b>: function</TD>
</TR>
</Table>

<h3>Prototype</h3>
<tt>Value_type</tt> is overloaded; it is in fact five different functions.
<pre>
template &lt;class T, class Distance&gt; 
inline T* value_type(const <A href="input_iterator.shtml.htm" tppabs="http://codeguru.developer.com/cpp/stlguide/input_iterator.shtml">input_iterator</A>&lt;T, Distance&gt;&amp;);

template &lt;class T, class Distance&gt; 
inline T* value_type(const <A href="forward_iterator.shtml.htm" tppabs="http://codeguru.developer.com/cpp/stlguide/forward_iterator.shtml">forward_iterator</A>&lt;T, Distance&gt;&amp;);

template &lt;class T, class Distance&gt; 
inline T* value_type(const <A href="bidirectional_iterator.shtml.htm" tppabs="http://codeguru.developer.com/cpp/stlguide/bidirectional_iterator.shtml">bidirectional_iterator</A>&lt;T, Distance&gt;&amp;);

template &lt;class T, class Distance&gt; 
inline T* value_type(const <A href="random_access_iterator.shtml.htm" tppabs="http://codeguru.developer.com/cpp/stlguide/random_access_iterator.shtml">random_access_iterator</A>&lt;T, Distance&gt;&amp;);

template &lt;class T&gt; inline T* value_type(const T*);
</pre>
<h3>Description</h3>
<tt>Value_type</tt> is an <A href="iterator_tags.shtml.htm" tppabs="http://codeguru.developer.com/cpp/stlguide/iterator_tags.shtml">iterator tag</A> function: it is used to
determine the value type associated with an iterator.  An iterator's
value type is the type of object returned when the iterator is
dereferenced; <A href="OutputIterator.shtml.htm" tppabs="http://codeguru.developer.com/cpp/stlguide/OutputIterator.shtml">Output Iterators</A> do not have value types 
(<A href="OutputIterator.shtml.htm" tppabs="http://codeguru.developer.com/cpp/stlguide/OutputIterator.shtml">Output Iterators</A> may only be used for storing values, not for
accessing values), but <A href="InputIterator.shtml.htm" tppabs="http://codeguru.developer.com/cpp/stlguide/InputIterator.shtml">Input Iterators</A>, <A href="ForwardIterator.shtml.htm" tppabs="http://codeguru.developer.com/cpp/stlguide/ForwardIterator.shtml">Forward Iterators</A>,
<A href="BidirectionalIterator.shtml.htm" tppabs="http://codeguru.developer.com/cpp/stlguide/BidirectionalIterator.shtml">Bidirectional Iterators</A>, and <A href="RandomAccessIterator.shtml.htm" tppabs="http://codeguru.developer.com/cpp/stlguide/RandomAccessIterator.shtml">Random Access Iterators</A> do. <A href="#1">[1]</A>
In some cases, such as an algorithm that must
declare a local variable that holds a value returned from
dereferencing an iterator, it is necessary to find out an iterator's
value  type.  Accordingly, <tt>value_type(Iter)</tt> returns <tt>(T*) 0</tt>, where <tt>T</tt> is
<tt>Iter</tt>'s value type.
<P>
Although <tt>value_type</tt> looks like a single function whose
return type depends on its argument type, in reality it is a set
of functions; the name <tt>value_type</tt> is overloaded.  
The function <tt>value_type</tt> must be overloaded for every iterator type <A href="#1">[1]</A>.
<P>
In practice, ensuring that <tt>value_type</tt> is defined requires
essentially no work at all.  It is already defined for pointers, and
for the base classes <tt><A href="input_iterator.shtml.htm" tppabs="http://codeguru.developer.com/cpp/stlguide/input_iterator.shtml">input_iterator</A></tt>,
<tt><A href="forward_iterator.shtml.htm" tppabs="http://codeguru.developer.com/cpp/stlguide/forward_iterator.shtml">forward_iterator</A></tt>, <tt><A href="bidirectional_iterator.shtml.htm" tppabs="http://codeguru.developer.com/cpp/stlguide/bidirectional_iterator.shtml">bidirectional_iterator</A></tt>, and
<tt><A href="random_access_iterator.shtml.htm" tppabs="http://codeguru.developer.com/cpp/stlguide/random_access_iterator.shtml">random_access_iterator</A></tt>.  If you are implementing a new type of
forward iterator, for example, you can simply derive it from the base
class <tt><A href="forward_iterator.shtml.htm" tppabs="http://codeguru.developer.com/cpp/stlguide/forward_iterator.shtml">forward_iterator</A></tt>; this means that <tt>value_type</tt>
(along with <tt><A href="iterator_category.shtml.htm" tppabs="http://codeguru.developer.com/cpp/stlguide/iterator_category.shtml">iterator_category</A></tt> and <tt><A href="distance_type.shtml.htm" tppabs="http://codeguru.developer.com/cpp/stlguide/distance_type.shtml">distance_type</A></tt>) will 
automatically be defined for your iterator.   These base classes are
empty: they contain no member functions or member variables, but
only type information.  Using them should therefore incur no overhead.
<P>
Note that, while the function <tt>value_type</tt> was present in the
original STL, it is no longer present in the most recent draft C++
standard: it has been replaced by the <tt><A href="iterator_traits.shtml.htm" tppabs="http://codeguru.developer.com/cpp/stlguide/iterator_traits.shtml">iterator_traits</A></tt> class
At present both mechanisms are supported <A href="#2">[2]</A>, but eventually
<tt>value_type</tt> will be removed.
<h3>Definition</h3>
Defined in <A href="iterator.h" tppabs="http://codeguru.developer.com/cpp/stlguide/iterator.h">iterator.h</A>.
<h3>Requirements on types</h3>
The argument of <tt>value_type</tt> must be an <A href="InputIterator.shtml.htm" tppabs="http://codeguru.developer.com/cpp/stlguide/InputIterator.shtml">Input Iterator</A>, 
<A href="ForwardIterator.shtml.htm" tppabs="http://codeguru.developer.com/cpp/stlguide/ForwardIterator.shtml">Forward Iterator</A>, <A href="BidirectionalIterator.shtml.htm" tppabs="http://codeguru.developer.com/cpp/stlguide/BidirectionalIterator.shtml">Bidirectional Iterator</A>, or
<A href="RandomAccessIterator.shtml.htm" tppabs="http://codeguru.developer.com/cpp/stlguide/RandomAccessIterator.shtml">Random Access Iterator</A>. <A href="#1">[1]</A>
<h3>Preconditions</h3>
None.  <tt>Value_type</tt>'s argument is even permitted to be
a singular iterator.
<h3>Complexity</h3>
At most amortized constant time.  In many cases, a compiler should be
able to optimize away <tt>value_type</tt> entirely.
<h3>Example</h3>
This example uses the <tt><A href="value_type.shtml.htm" tppabs="http://codeguru.developer.com/cpp/stlguide/value_type.shtml">value_type</A></tt> iterator tag function in order to
declare a temporary variable of an iterator's value type.
<pre>
template &lt;class <A href="ForwardIterator.shtml.htm" tppabs="http://codeguru.developer.com/cpp/stlguide/ForwardIterator.shtml">ForwardIterator</A>1, class <A href="ForwardIterator.shtml.htm" tppabs="http://codeguru.developer.com/cpp/stlguide/ForwardIterator.shtml">ForwardIterator</A>2, class ValueType&gt;
inline void __iter_swap(ForwardIterator1 a, ForwardIterator2 b, ValueType*) {
    T tmp = *a;
    *a = *b;
    *b = tmp;
}

template &lt;class <A href="ForwardIterator.shtml.htm" tppabs="http://codeguru.developer.com/cpp/stlguide/ForwardIterator.shtml">ForwardIterator</A>1, class <A href="ForwardIterator.shtml.htm" tppabs="http://codeguru.developer.com/cpp/stlguide/ForwardIterator.shtml">ForwardIterator</A>2&gt;
inline void iter_swap(ForwardIterator1 a, ForwardIterator2 b) {
    __iter_swap(a, b, <A href="value_type.shtml.htm" tppabs="http://codeguru.developer.com/cpp/stlguide/value_type.shtml">value_type</A>(a));
}
</pre>
<h3>Notes</h3>
<P><A name="1">[1]</A>
Note that <tt>distance_type</tt> is not defined for <A href="OutputIterator.shtml.htm" tppabs="http://codeguru.developer.com/cpp/stlguide/OutputIterator.shtml">Output Iterators</A>
or for <A href="trivial.shtml.htm" tppabs="http://codeguru.developer.com/cpp/stlguide/trivial.shtml">Trivial Iterators</A>.  In the case of <A href="OutputIterator.shtml.htm" tppabs="http://codeguru.developer.com/cpp/stlguide/OutputIterator.shtml">Output Iterators</A>,
this is because an <A href="OutputIterator.shtml.htm" tppabs="http://codeguru.developer.com/cpp/stlguide/OutputIterator.shtml">Output Iterator</A> does not have a value type:
it is not possible to dereference an <A href="OutputIterator.shtml.htm" tppabs="http://codeguru.developer.com/cpp/stlguide/OutputIterator.shtml">Output Iterator</A> and obtain
a value.  In the case of <A href="trivial.shtml.htm" tppabs="http://codeguru.developer.com/cpp/stlguide/trivial.shtml">Trivial Iterators</A>, this is because 
the concept was introduced only for conceptual clarity,
in order to separate the axioms related to an object that refers
to another object from those related to iteration over a range.
In fact, the STL does not define any types that are <A href="trivial.shtml.htm" tppabs="http://codeguru.developer.com/cpp/stlguide/trivial.shtml">Trivial Iterators</A>.
Although built-in C pointers may be <A href="trivial.shtml.htm" tppabs="http://codeguru.developer.com/cpp/stlguide/trivial.shtml">Trivial Iterators</A>, the C
type system does not allow a distinction between pointers that are
<A href="trivial.shtml.htm" tppabs="http://codeguru.developer.com/cpp/stlguide/trivial.shtml">Trivial Iterators</A> and pointers that are <A href="RandomAccessIterator.shtml.htm" tppabs="http://codeguru.developer.com/cpp/stlguide/RandomAccessIterator.shtml">Random Access Iterators</A>
into C arrays.  Consequently, there is no <A href="trivial.shtml.htm" tppabs="http://codeguru.developer.com/cpp/stlguide/trivial.shtml">Trivial Iterator</A> category
tag or iterator base.
<P><A name="2">[2]</A>
The <tt><A href="iterator_traits.shtml.htm" tppabs="http://codeguru.developer.com/cpp/stlguide/iterator_traits.shtml">iterator_traits</A></tt> class
relies on a C++ feature known as <i>partial specialization</i>.  Many of
today's compilers don't implement the complete standard; in
particular, many compilers do not support partial specialization.  If
your compiler does not support partial specialization, then you will
not be able to use <tt><A href="iterator_traits.shtml.htm" tppabs="http://codeguru.developer.com/cpp/stlguide/iterator_traits.shtml">iterator_traits</A></tt>, and you will have to 
continue using the functions <tt><A href="iterator_category.shtml.htm" tppabs="http://codeguru.developer.com/cpp/stlguide/iterator_category.shtml">iterator_category</A></tt>, <tt><A href="distance_type.shtml.htm" tppabs="http://codeguru.developer.com/cpp/stlguide/distance_type.shtml">distance_type</A></tt>,
and <tt>value_type</tt>.  This is one reason that those functions have
not yet been removed.
<h3>See also</h3>
The <A href="iterator_tags.shtml.htm" tppabs="http://codeguru.developer.com/cpp/stlguide/iterator_tags.shtml">Iterator Tags</A> overview, <tt><A href="iterator_traits.shtml.htm" tppabs="http://codeguru.developer.com/cpp/stlguide/iterator_traits.shtml">iterator_traits</A></tt>,
<tt><A href="iterator_category.shtml.htm" tppabs="http://codeguru.developer.com/cpp/stlguide/iterator_category.shtml">iterator_category</A></tt>, <tt><A href="distance_type.shtml.htm" tppabs="http://codeguru.developer.com/cpp/stlguide/distance_type.shtml">distance_type</A></tt>,
<tt><A href="output_iterator_tag.shtml.htm" tppabs="http://codeguru.developer.com/cpp/stlguide/output_iterator_tag.shtml">output_iterator_tag</A></tt>, <tt><A href="input_iterator_tag.shtml.htm" tppabs="http://codeguru.developer.com/cpp/stlguide/input_iterator_tag.shtml">input_iterator_tag</A></tt>,
<tt><A href="forward_iterator_tag.shtml.htm" tppabs="http://codeguru.developer.com/cpp/stlguide/forward_iterator_tag.shtml">forward_iterator_tag</A></tt>, <tt><A href="bidirectional_iterator_tag.shtml.htm" tppabs="http://codeguru.developer.com/cpp/stlguide/bidirectional_iterator_tag.shtml">bidirectional_iterator_tag</A></tt>,
<tt><A href="random_access_iterator_tag.shtml.htm" tppabs="http://codeguru.developer.com/cpp/stlguide/random_access_iterator_tag.shtml">random_access_iterator_tag</A></tt>

<HR SIZE="6"> <FONT SIZE="-2"> Copyright &copy; 1996 Silicon Graphics, Inc.


</td>

<td valign="top" width="20">&nbsp;&nbsp;&nbsp;</td>

</BODY>
</HTML>