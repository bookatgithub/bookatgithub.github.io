<html><head>
<META http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<!--SafClassName="docSection1Title"--><!--SafTocEntry="A.3 Datatypes"-->
<link rel="STYLESHEET" type="text/css" href="FILES/style.css">
<link rel="STYLESHEET" type="text/css" href="FILES/docsafari.css">
<style type="text/css">	.tt1    {font-size: 10pt;}</style>
</head>
<body>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<td class="tt1"><a href="NFO/lib.html">[ Team LiB ]</a></td><td valign="top" class="tt1" align="right">
	<a href="0321112547_app01lev1sec2.html"><img src="FILES/btn_prev.gif" width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a>
	<a href="0321112547_app01lev1sec4.html"><img src="FILES/btn_next.gif" width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a>
</td></table>
<br>
<table width="100%" border="0" cellspacing="0" cellpadding="0"><tr><td valign="top"><A NAME="app01lev1sec3"></A><H3 class="docSection1Title">A.3 Datatypes</H3>
<P class="docText">Python has a rich collection of basic datatypes. All of Python's collection types allow you to hold heterogeneous elements inside them, including other collection types (with minor limitations). It is straightforward, therefore, to build complex data structures in Python.</P>
<P class="docText">Unlike many languages, Python datatypes come in two varieties: mutable and immutable. All of the atomic datatypes are immutable, as is the collection type <TT>tuple</TT>. The collections <TT>list</TT> and <TT>dict</TT> are mutable, as are class instances. The mutability of a datatype is simply a question of whether objects of that type can be changed "in place"—an immutable object can only be created and destroyed, but never altered during its existence. One upshot of this distinction is that immutable objects may act as dictionary keys, but mutable objects may not. Another upshot is that when you want a data structure—especially a large one—that will be modified frequently during program operation, you should choose a mutable datatype (usually a list).</P>
<P class="docText">Most of the time, if you want to convert values between different Python datatypes, an explicit conversion/encoding call is required, but numeric types contain promotion rules to allow numeric expressions over a mixture of types. The built-in datatypes are listed below with discussions of each. The built-in function <span class="docEmphasis"><TT>type()</TT></span> can be used to check the datatype of an object.</P>
<A NAME="app01lev2sec6"></A><H4 class="docSection2Title">A.3.1 Simple Types</H4>
<A NAME="app01lev4sec1"></A><H5 class="docSection3Title"> bool</H5>
<P class="docText">Python 2.3+ supports a Boolean datatype with the possible values <TT>True</TT> and <TT>False</TT>. In earlier versions of Python, these values are typically called <TT>1</TT> and <TT>0</TT>; even in Python 2.3+, the Boolean values behave like numbers in numeric contexts. Some earlier micro-releases of Python (e.g., 2.2.1) include the <span class="docEmphasis">names</span> <TT>True</TT> and <TT>False</TT>, but not the Boolean datatype.</P>
<A NAME="app01lev4sec2"></A><H5 class="docSection3Title"> int</H5>
<P class="docText">A signed integer in the range indicated by the register size of the interpreter's CPU/OS platform. For most current platforms, integers range from (2**31)-1 to negative (2**31)-1. You can find the size on your platform by examining <span class="docEmphasis"><TT>sys.maxint</TT></span>. Integers are the bottom numeric type in terms of promotions; nothing gets promoted <span class="docEmphasis">to</span> an integer, but integers are sometimes promoted to other numeric types. A float, long, or string may be explicitly converted to an int using the <span class="docEmphasis"><TT>int()</TT></span> function.</P>
<p class="docText"><span class="docEmphRoman">S<span class="docEmphSmaller">EE</span> A<span class="docEmphSmaller">LSO</span></span>: 
int <span class="docEmphasis">18;</span></p>
<A NAME="app01lev4sec3"></A><H5 class="docSection3Title"> long</H5>
<P class="docText">An (almost) unlimited size integral number. A long literal is indicated by an integer followed by an <TT>1</TT> or <TT>L</TT> (e.g., <TT>34L</TT>, <TT>98765432101</TT>). In Python 2.2+, operations on ints that overflow <span class="docEmphasis"><TT>sys.maxint</TT></span> are automatically promoted to longs. An int, float, or string may be explicitly converted to a long using the <span class="docEmphasis"><TT>long()</TT></span> function.</P>
<A NAME="app01lev4sec4"></A><H5 class="docSection3Title"> float</H5>
<P class="docText">An IEEE754 floating point number. A literal floating point number is distinguished from an int or long by containing a decimal point and/or exponent notation (e.g., <TT>1.0</TT>, <TT>1e3</TT>, <TT>37.</TT>, <TT>.453e-12</TT>). A numeric expression that involves both int/long types and float types promotes all component types to floats before performing the computation. An int, long, or string may be explicitly converted to a float using the <span class="docEmphasis"><TT>float()</TT></span> function.</P>
<p class="docText"><span class="docEmphRoman">S<span class="docEmphSmaller">EE</span> A<span class="docEmphSmaller">LSO</span></span>: 
float <span class="docEmphasis">19;</span></p>
<A NAME="app01lev4sec5"></A><H5 class="docSection3Title"> complex</H5>
<P class="docText">An object containing two floats, representing real and imaginary components of a number. A numeric expression that involves both int/long/float types and complex types promotes all component types to complex before performing the computation. There is no way to spell a literal complex in Python, but an addition such as <TT>1.1+2j</TT> is the usual way of computing a complex value. A <TT>j</TT> or <TT>J</TT> following a float or int literal indicates an imaginary number. An int, long, or string may be explicitly converted to a complex using the <span class="docEmphasis"><TT>complex()</TT></span> function. If two float/int arguments are passed to <span class="docEmphasis"><TT>complex()</TT></span>, the second is the imaginary component of the constructed number (e.g., <TT>complex(1.1,2)</TT>).</P>
<A NAME="app01lev4sec6"></A><H5 class="docSection3Title"> string</H5>
<P class="docText">An immutable sequence of 8-bit character values. Unlike in many programming languages, there is no "character" type in Python, merely strings that happen to have length one. String objects have a variety of methods to modify strings, but such methods always return a new string object rather than modify the initial object itself. The built-in <span class="docEmphasis"><TT>chr()</TT></span> function will return a length-one string whose ordinal value is the passed integer. The <span class="docEmphasis"><TT>str()</TT></span> function will return a string representation of a passed in object. For example:</P>
<pre>
&gt;&gt;&gt; ord('a')
97
&gt;&gt;&gt; chr(97)
'a'
&gt;&gt;&gt; str(97)
'97'
</pre>
<p class="docText"><span class="docEmphRoman">S<span class="docEmphSmaller">EE</span> A<span class="docEmphSmaller">LSO</span></span>: 
string <span class="docEmphasis">129;</span></p>
<A NAME="app01lev4sec7"></A><H5 class="docSection3Title"> unicode</H5>
<P class="docText">An immutable sequence of Unicode characters. There is no datatype for a single Unicode character, but Unicode strings of length-one contain a single character. Unicode strings contain a similar collection of methods to string objects, and like the latter, Unicode methods return new Unicode objects rather than modify the initial object. See <A class="docLink" HREF="0321112547_ch02.html#ch02">Chapter 2</A> and <A class="docLink" HREF="0321112547_app03.html#app03">Appendix C</A> for additional discussion, of Unicode.</P>
<A NAME="app01lev2sec7"></A><H4 class="docSection2Title">A.3.2 String Interpolation</H4>
<P class="docText">Literal strings and Unicode strings may contain embedded format codes. When a string contains format codes, values may be <span class="docEmphasis">interpolated</span> into the string using the <TT>%</TT> operator and a tuple or dictionary giving the values to substitute in.</P>
<P class="docText">Strings that contain format codes may follow either of two patterns. The simpler pattern uses format codes with the syntax <TT>%[flags][len[.precision]]&lt;type&gt;</TT>. Interpolating a string with format codes on this pattern requires <TT>%</TT> combination with a tuple of matching length and content datatypes. If only one value is being interpolated, you may give the bare item rather than a tuple of length one. For example:</P>
<pre>
&gt;&gt;&gt; "float %3.1f, int %+d, hex %06x" % (1.234, 1234, 1234)
'float 1.2, int +1234, hex 0004d2'
&gt;&gt;&gt; '%e' % 1234
'1.234000e+03'
&gt;&gt;&gt; '%e' % (1234,)
'1.234000e+03'
</pre>
<P class="docText">The (slightly) more complex pattern for format codes embeds a name within the format code, which is then used as a string key to an interpolation dictionary. The syntax of this pattern is <TT>%(key)[flags][len[.precision]]&lt;type&gt;</TT>. Interpolating a string with this style of format codes requires <TT>%</TT> combination with a dictionary that contains all the named keys, and whose corresponding values contain acceptable datatypes. For example:</P>
<pre>
&gt;&gt;&gt; dct = {'ratio':1.234, 'count':1234, 'offset':1234}
&gt;&gt;&gt; "float %(ratio)3.1f, int %(count)+d, hex %(offset)06x" % dct
'float 1.2, int +1234, hex 0004d2'
</pre>
<P class="docText">You <span class="docEmphasis">may not</span> mix tuple interpolation and dictionary interpolation within the same string.</P>
<P class="docText">I mentioned that datatypes must match format codes. Different format codes accept a different range of datatypes, but the rules are almost always what you would expect. Generally, numeric data will be promoted or demoted as necessary, but strings and complex types cannot be used for numbers.</P>
<P class="docText">One useful style of using dictionary interpolation is against the global and/or local namespace dictionary. Regular bound names defined in scope can be interpolated into strings.</P>
<pre>
&gt;&gt;&gt; s = "float %(ratio)3.1f, int %(count)+d, hex %(offset)06x"
&gt;&gt;&gt; ratio = 1.234
&gt;&gt;&gt; count = 1234
&gt;&gt;&gt; offset = 1234
&gt;&gt;&gt; s % globals()
'float 1.2, int +1234, hex 0004d2'
</pre>
<P class="docText">If you want to look for names across scope, you can create an ad hoc dictionary with both local and global names:</P>
<pre>
&gt;&gt;&gt; vardct = {}
&gt;&gt;&gt; vardct.update(globals())
&gt;&gt;&gt; vardct.update(locals())
&gt;&gt;&gt; interpolated = somestring % vardct
</pre>
<P class="docText">The flags for format codes consist of the following:</P>
<pre>
0 Pad to length with leading zeros
- Align the value to the left within its length
- (space) Pad to length with leading spaces
+ Explicitly indicate the sign of positive values
</pre>
<P class="docText">When a length is included, it specifies the <span class="docEmphasis">minimum</span> length of the interpolated formatting. Numbers that will not fit within a length simply occupy more bytes than specified. When a precision is included, the length of those digits to the right of the decimal are included in the total length:</P>
<pre>
&gt;&gt;&gt; '[%f]' % 1.234
'[1.234000]'
&gt;&gt;&gt; '[%5f]' % 1.234
'[1.234000]'
&gt;&gt;&gt; '[%.1f]' % 1.234
'[1.2]'
&gt;&gt;&gt; '[%5.1f]' % 1.234
'[  1.2]'
&gt;&gt;&gt; '[%05.1f]' % 1.234
'[001.2]'
</pre>
<P class="docText">The formatting types consist of the following:</P>
<pre>
d Signed integer decimal
i Signed integer decimal
o Unsigned octal
u Unsigned decimal
x Lowercase unsigned hexadecimal
X Uppercase unsigned hexadecimal
e Lowercase exponential format floating point
E Uppercase exponential format floating point
f Floating point decimal format
g Floating point: exponential format if -4 &lt; exp &lt; precision
G Uppercase version of 'g'
c Single character: integer for chr(i) or length-one string
r Converts any Python object using repr()
s Converts any Python object using str()
% The '%' character, e.g.: '%%%d' % (1) --&gt; '%1'
</pre>
<P class="docText">One more special format code style allows the use of a <TT>*</TT> in place of a length. In this case, the interpolated tuple must contain an extra element for the formatted length of each format code, preceding the value to format. For example:</P>
<pre>
&gt;&gt;&gt; "%0*d # %0*.2f" % (4, 123, 4, 1.23)
'0123 # 1.23'
&gt;&gt;&gt; "%0*d # %0*.2f" % (6, 123, 6, 1.23)
'000123 # 001.23'
</pre>
<A NAME="app01lev2sec8"></A><H4 class="docSection2Title">A.3.3 Printing</H4>
<P class="docText">The least-sophisticated form of textual output in Python is writing to open files. In particular, the STDOUT and STDERR streams can be accessed using the pseudo-files <span class="docEmphasis"><TT>sys.stdout</TT></span> and <span class="docEmphasis"><TT>sys.stderr</TT></span>. Writing to these is just like writing to any other file; for example:</P>
<pre>
&gt;&gt;&gt; import sys
&gt;&gt;&gt; try:
...    # some fragile action
...    sys.stdout.write('result of action\n')
... except:
...    sys.stderr.write('could not complete action\n')
...
result of action
</pre>
<P class="docText">You cannot seek within STDOUT or STDERR—generally you should consider these as pure sequential outputs.</P>
<P class="docText">Writing to STDOUT and STDERR is fairly inflexible, and most of the time the <TT>print</TT> statement accomplishes the same purpose more flexibly. In particular, methods like <span class="docEmphasis"><TT>sys.stdout.write()</TT></span> only accept a single string as an argument, while <TT>print</TT> can handle any number of arguments of any type. Each argument is coerced to a string using the equivalent of <TT>repr(obj)</TT>. For example:</P>
<pre>
&gt;&gt;&gt; print "Pi: %.3f" % 3.1415, 27+11, {3:4,1:2}, (1,2,3)
Pi: 3.142 38 {1: 2, 3: 4} (1, 2, 3)
</pre>
<P class="docText">Each argument to the <TT>print</TT> statment is evaluated before it is printed, just as when an argument is passed to a function. As a consequence, the canonical representation of an object is printed, rather than the exact form passed as an argument. In my example, the dictionary prints in a different order than it was defined in, and the spacing of the list and dictionary is slightly different. String interpolation is also peformed and is a very common means of defining an output format precisely.</P>
<P class="docText">There are a few things to watch for with the <TT>print</TT> statement. A space is printed between each argument to the statement. If you want to print several objects without a separating space, you will need to use string concatenation or string interpolation to get the right result. For example:</P>
<pre>
&gt;&gt;&gt; numerator, denominator = 3, 7
&gt;&gt;&gt; print repr(numerator)+"/"+repr(denominator)
3/7
&gt;&gt;&gt; print "%d/%d" % (numerator, denominator)
3/7
</pre>
<P class="docText">By default, a <TT>print</TT> statement adds a linefeed to the end of its output. You may eliminate the linefeed by adding a trailing comma to the statement, but you still wind up with a space added to the end:</P>
<pre>
&gt;&gt;&gt; letlist = ('a','B','Z','r','w')
&gt;&gt;&gt; for c in letlist: print c,   # inserts spaces
...
a B Z r w
</pre>
<P class="docText">Assuming these spaces are unwanted, you must either use <span class="docEmphasis"><TT>sys.stdout.write()</TT></span> or otherwise calculate the space-free string you want:</P>
<pre>
&gt;&gt;&gt; for c in letlist+('\n',): # no spaces
...     sys.stdout.write(c)
...
aBZrw
&gt;&gt;&gt; print ''.join(letlist)
aBZrw
</pre>
<P class="docText">There is a special form of the <TT>print</TT> statement that redirects its output somewhere other than STDOUT. The <TT>print</TT> statement itself can be followed by two greater-than signs, then a writable file-like object, then a comma, then the remainder of the (printed) arguments. For example:</P>
<pre>
&gt;&gt;&gt; print &gt;&gt; open('test','w'), "Pi: %.3f" % 3.1415, 27+11
&gt;&gt;&gt; open('test').read()
'Pi: 3.142 38\n'
</pre>
<P class="docText">Some Python programmers (including your author) consider this special form overly "noisy," but it <span class="docEmphasis">is</span> occassionally useful for quick configuration of output destinations.</P>
<P class="docText">If you want a function that would do the same thing as a <TT>print</TT> statement, the following one does so, but without any facility to eliminate the trailing linefeed or redirect output:</P>
<pre>
def print_func(*args):
    import sys
    sys.stdout.write(' '.join(map(repr,args))+'\n')
</pre>
<P class="docText">Readers could enhance this to add the missing capabilities, but using <TT>print</TT> as a statement is the clearest approach, generally.</P>
<p class="docText"><span class="docEmphRoman">S<span class="docEmphSmaller">EE</span> A<span class="docEmphSmaller">LSO</span></span>: 
sys.stderr <span class="docEmphasis">50;</span> sys.stdout <span class="docEmphasis">51;</span></p>
<A NAME="app01lev2sec9"></A><H4 class="docSection2Title">A.3.4 Container Types</H4>
<A NAME="app01lev4sec8"></A><H5 class="docSection3Title"> tuple</H5>
<P class="docText">An immutable sequence of (heterogeneous) objects. Being immutable, the membership and length of a tuple cannot be modified after creation. However, tuple elements and subsequences can be accessed by subscripting and slicing, and new tuples can be constructed from such elements and slices. Tuples are similar to "records" in some other programming languages.</P>
<P class="docText">The constructor syntax for a tuple is commas between listed items; in many contexts, parentheses around a constructed list are required to disambiguate a tuple for other constructs such as function arguments, but it is the commas not the parentheses that construct a tuple. Some examples:</P>
<pre>
&gt;&gt;&gt; tup = 'spam','eggs','bacon','sausage'
&gt;&gt;&gt; newtup = tup[1:3] + (1,2,3) + (tup[3],)
&gt;&gt;&gt; newtup
('eggs', 'bacon', 1, 2, 3, 'sausage')
</pre>
<P class="docText">The function <span class="docEmphasis"><TT>tuple()</TT></span> may also be used to construct a tuple from another sequence type (either a list or custom sequence type).</P>
<p class="docText"><span class="docEmphRoman">S<span class="docEmphSmaller">EE</span> A<span class="docEmphSmaller">LSO</span></span>: 
tuple <span class="docEmphasis">28;</span></p>
<A NAME="app01lev4sec9"></A><H5 class="docSection3Title"> list</H5>
<P class="docText">A mutable sequence of objects. Like a tuple, list elements can be accessed by subscripting and slicing; unlike a tuple, list methods and index and slice assignments can modify the length and membership of a list object.</P>
<P class="docText">The constructor syntax for a list is surrounding square braces. An empty list may be constructed with no objects between the braces; a length-one list can contain simply an object name; longer lists separate each element object with commas. Indexing and slices, of course, also use square braces, but the syntactic contexts are different in the Python grammar (and common sense usually points out the difference). Some examples:</P>
<pre>
&gt;&gt;&gt; lst = ['spam', (1,2,3), 'eggs', 3.1415]
&gt;&gt;&gt; lst[:2]
['spam', (1, 2, 3)]
</pre>
<P class="docText">The function <span class="docEmphasis"><TT>list()</TT></span> may also be used to construct a list from another sequence type (either a tuple or custom sequence type).</P>
<p class="docText"><span class="docEmphRoman">S<span class="docEmphSmaller">EE</span> A<span class="docEmphSmaller">LSO</span></span>: 
list <span class="docEmphasis">28;</span></p>
<A NAME="app01lev4sec10"></A><H5 class="docSection3Title"> dict</H5>
<P class="docText">A mutable mapping between immutable keys and object values. At most one entry in a dict exists for a given key; adding the same key to a dictionary a second time overrides the previous entry (much as with binding a name in a namespace). Dicts are unordered, and entries are accessed either by key as index; by creating lists of contained objects using the methods <TT>.keys()</TT>, <TT>.values()</TT>, and <TT>.items()</TT>; or— in recent Python versions—with the <TT>.popitem()</TT> method. All the dict methods generate contained objects in an unspecified order.</P>
<P class="docText">The constructor syntax for a dict is surrounding curly brackets. An empty dict may be constructed with no objects between the brackets. Each key/value pair entered into a dict is separated by a colon, and successive pairs are separated by commas. For example:</P>
<pre>
&gt;&gt;&gt; dct = {1:2, 3.14:(1+2j), 'spam':'eggs'}
&gt;&gt;&gt; dct['spam']
'eggs'
&gt;&gt;&gt; dct['a'] = 'b'    # add item to dict
&gt;&gt;&gt; dct.items()
[('a', 'b'), (1, 2), ('spam', 'eggs'), (3.14, (1+2j))]
&gt;&gt;&gt; dct.popitem()
('a', 'b')
&gt;&gt;&gt; dct
{1: 2, 'spam': 'eggs', 3.14: (1+2j)}
</pre>
<P class="docText">In Python 2.2+, the function <span class="docEmphasis"><TT>dict()</TT></span> may also be used to construct a dict from a sequence of pairs or from a custom mapping type. For example:</P>
<pre>
&gt;&gt;&gt; d1 = dict([('a','b'), (1,2), ('spam','eggs')])
&gt;&gt;&gt; d1
{'a': 'b', 1: 2, 'spam': 'eggs'}
&gt;&gt;&gt; d2 = dict(zip([1,2,3],['a','b','c']))
&gt;&gt;&gt; d2
{1: 'a', 2: 'b', 3: 'c'}
</pre>
<p class="docText"><span class="docEmphRoman">S<span class="docEmphSmaller">EE</span> A<span class="docEmphSmaller">LSO</span></span>: 
dict <span class="docEmphasis">24;</span></p>
<A NAME="app01lev4sec11"></A><H5 class="docSection3Title"> sets.Set</H5>
<P class="docText">Python 2.3+ includes a standard module that implements a set datatype. For earlier Python versions, a number of developers have created third-party implementations of sets. If you have at least Python 2.2, you can download and use the <span class="docEmphasis"><TT>sets</TT></span> module from <TT>&lt;</TT><A class="docLink" target="_blank" HREF="http://tinyurl.com/2d31">http://tinyurl.com/2d31</A><TT>&gt;</TT> (or browse the Python CVS)—you will need to add the definition <TT>True,False=1, 0</TT> to your local version, though.</P>
<P class="docText">A set is an unordered collection of hashable objects. Unlike a list, no object can occur in a set more than once; a set resembles a dict that has only keys but no values. Sets utilize bitwise and Boolean syntax to perform basic set-theoretic operations; a subset test does not have a special syntactic form, instead using the <TT>.issubset()</TT> and <TT>.issuperset()</TT> methods. You may also loop through set members in an unspecified order. Some examples illustrate the type:</P>
<pre>
&gt;&gt;&gt; from sets import Set
&gt;&gt;&gt; x = Set([1,2,3])
&gt;&gt;&gt; y = Set((3,4,4,6,6,2)) # init with any seq
&gt;&gt;&gt; print x, '//', y       # make sure dups removed
Set([1, 2, 3]) // Set([2, 3, 4, 6])
&gt;&gt;&gt; print x | y            # union of sets
Set([1, 2, 3, 4, 6])
&gt;&gt;&gt; print x &amp; y            # intersection of sets
Set([2, 3])
&gt;&gt;&gt; print y-x              # difference of sets
Set([4, 6])
&gt;&gt;&gt; print x ^ y            # symmetric difference
Set([1, 4, 6])
</pre>
<P class="docText">You can also check membership and iterate over set members:</P>
<pre>
&gt;&gt;&gt; 4 in y                # membership check
1
&gt;&gt;&gt; x.issubset(y)         # subset check
0
&gt;&gt;&gt; for i in y:
...     print i+10,
...
12 13 14 16
&gt;&gt;&gt; from operator import add
&gt;&gt;&gt; plus_ten = Set(map(add, y, [10]*len(y)))
&gt;&gt;&gt; plus_ten
Set([16, 12, 13, 14])
</pre>
<P class="docText"><span class="docEmphasis"><TT>sets.Set</TT></span> also supports in-place modification of sets; <span class="docEmphasis"><TT>sets.ImmutableSet</TT></span>, naturally, does not allow modification.</P>
<pre>
&gt;&gt;&gt; x = Set([1,2,3])
&gt;&gt;&gt; x |= Set([4,5,6])
&gt;&gt;&gt; x
Set([1, 2, 3, 4, 5, 6])
&gt;&gt;&gt; x &amp;= Set([4,5,6])
&gt;&gt;&gt; x
Set([4, 5, 6])
&gt;&gt;&gt; x ^= Set ([4, 5])
&gt;&gt;&gt; x
Set([6])
</pre>
<A NAME="app01lev2sec10"></A><H4 class="docSection2Title">A.3.5 Compound Types</H4>
<A NAME="app01lev4sec12"></A><H5 class="docSection3Title"> class instance</H5>
<P class="docText">A class instance defines a namespace, but this namespace's main purpose is usually to act as a data container (but a container that also knows how to perform actions; i.e., has methods). A class instance (or any namespace) acts very much like a dict in terms of creating a mapping between names and values. Attributes of a class instance may be set or modified using standard qualified names and may also be set within class methods by qualifying with the namespace of the first (implicit) method argument, conventionally called <TT>self</TT>. For example:</P>
<pre>
&gt;&gt;&gt; class Klass:
...     def setfoo(self, val):
...         self.foo = val
...
&gt;&gt;&gt; obj = Klass()
&gt;&gt;&gt; obj.bar = 'BAR'
&gt;&gt;&gt; obj.setfoo(['this','that','other'])
&gt;&gt;&gt; obj.bar, obj.foo
('BAR', ['this', 'that', 'other'])
&gt;&gt;&gt; obj.__dict__
{'foo': ['this', 'that', 'other'], 'bar': 'BAR'}
</pre>
<P class="docText">Instance attributes often dereference to other class instances, thereby allowing hierarchically organized namespace quantification to indicate a data structure. Moreover, a number of "magic" methods named with leading and trailing double-underscores provide optional syntactic conveniences for working with instance data. The most common of these magic methods is <TT>.__init__()</TT>, which initializes an instance (often utilizing arguments). For example:</P>
<pre>
&gt;&gt;&gt; class Klass2:
...     def __init__(self, *args, **kw):
...         self.listargs = args
...         for key, val in kw.items():
...             setattr(self, key, val)
...
&gt;&gt;&gt; obj = Klass2(1, 2, 3, foo='F00', bar=Klass2(baz='BAZ'))
&gt;&gt;&gt; obj.bar.blam = 'BLAM'
&gt;&gt;&gt; obj.listargs, obj.foo, obj.bar.baz, obj.bar.blam
((1, 2, 3), 'F00', 'BAZ', 'BLAM')
</pre>
<P class="docText">There are quite a few additional "magic" methods that Python classes may define. Many of these methods let class instances behave more like basic datatypes (while still maintaining special class behaviors). For example, the <TT>.__str__()</TT> and <TT>.__repr__()</TT> methods control the string representation of an instance; the <TT>.__getitem__()</TT> and <TT>.__setitem__()</TT> methods allow indexed access to instance data (either dict-like named indices, or list-like numbered indices); methods like <TT>.__add__()</TT>, <TT>.__mul__()</TT>, <TT>.__pow__()</TT>, and <TT>.__abs__()</TT> allow instances to behave in number-like ways. The <span class="docEmphasis">Python Reference Manual</span> discusses magic methods in detail.</P>
<P class="docText">In Python 2.2 and above, you can also let instances behave more like basic datatypes by inheriting classes from these built-in types. For example, suppose you need a datatype whose "shape" contains both a mutable sequence of elements and a <TT>.foo</TT> attribute. Two ways to define this datatype are:</P>
<pre>
&gt;&gt;&gt; class FooList(list):        # works only in Python 2.2+
...     def __init__(self, lst=[], foo=None):
...         list.__init__(self, lst)
...         self.foo = foo
...
&gt;&gt;&gt; foolist = FooList([1,2,3], 'F00')
&gt;&gt;&gt; foolist[1], foolist.foo
(2, 'F00')
&gt;&gt;&gt; class oldFooList:           # works in older Pythons
...     def __init__(self, lst=[], foo=None):
...         self._lst, self.foo = 1st, foo
...     def append(self, item):
...         self._lst.append(item)
...     def __getitem__(self, item):
...         return self._lst[item]
...     def __setitem__(self, item, val):
...         self._lst [item] = val
...     def __delitem__(self, item):
...         del self._lst[item]
...
&gt;&gt;&gt; foolst2 = oldFooList([1,2,3], 'F00')
&gt;&gt;&gt; foolst2[1], foolst2.foo
(2, 'F00')
</pre>
<P class="docText">If you need more complex datatypes than the basic types, or even than an instance whose class has magic methods, often these can be constructed by using instances whose attributes are bound in link-like fashion to other instances. Such bindings can be constructed according to various topologies, including circular ones (such as for modeling graphs). As a simple example, you can construct a binary tree in Python using the following node class:</P>
<pre>
&gt;&gt;&gt; class Node:
...     def __init__(self, left=None, value=None, right=None):
...         self.left, self.value, self.right = left, value, right
...     def __repr__(self):
...         return self.value
...
&gt;&gt;&gt; tree = Node(Node(value="Left Leaf"),
...             "Tree Root",
...             Node(left=Node(value="RightLeft Leaf"),
...                  right=Node(value="RightRight Leaf") ))
&gt;&gt;&gt; tree,tree.left,tree.left.left,tree.right.left,tree.right.right
(Tree Root, Left Leaf, None, RightLeft Leaf, RightRight Leaf)
</pre>
<P class="docText">In practice, you would probably bind intermediate nodes to names, in order to allow easy pruning and rearrangement.</P>
<p class="docText"><span class="docEmphRoman">S<span class="docEmphSmaller">EE</span> A<span class="docEmphSmaller">LSO</span></span>: 
int <span class="docEmphasis">18</span>; float <span class="docEmphasis">19</span>; list <span class="docEmphasis">28</span>; string <span class="docEmphasis">129</span>; tuple <span class="docEmphasis">28</span>; UserDict <span class="docEmphasis">24;</span> UserList <span class="docEmphasis">28</span>; UserString <span class="docEmphasis">33</span>;</p>
<a href="0321112547_10061533.html"><img src="FILES/pixel.gif" width="1" height="1" border="0"></a><ul></ul></td></tr></table>
<td></td>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<td class="tt1"><a href="NFO/lib.html">[ Team LiB ]</a></td><td valign="top" class="tt1" align="right">
          <a href="0321112547_app01lev1sec2.html"><img src="FILES/btn_prev.gif" width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a>
          <a href="0321112547_app01lev1sec4.html"><img src="FILES/btn_next.gif" width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a>
</td></table>
</body></html>
