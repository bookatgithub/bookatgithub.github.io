<html><head>
<META http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<!--SafClassName="docSection1Title"--><!--SafTocEntry="A.4 Flow Control"-->
<link rel="STYLESHEET" type="text/css" href="FILES/style.css">
<link rel="STYLESHEET" type="text/css" href="FILES/docsafari.css">
<style type="text/css">	.tt1    {font-size: 10pt;}</style>
</head>
<body>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<td class="tt1"><a href="NFO/lib.html">[ Team LiB ]</a></td><td valign="top" class="tt1" align="right">
	<a href="0321112547_app01lev1sec3.html"><img src="FILES/btn_prev.gif" width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a>
	<a href="0321112547_app01lev1sec5.html"><img src="FILES/btn_next.gif" width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a>
</td></table>
<br>
<table width="100%" border="0" cellspacing="0" cellpadding="0"><tr><td valign="top"><A NAME="app01lev1sec4"></A><H3 class="docSection1Title">A.4 Flow Control</H3>
<P class="docText">Depending on how you count it, Python has about a half-dozen flow control mechanisms, which is much simpler than most programming languages. Fortunately, Python's collection of mechanisms is well chosen, with a high—but not obsessively high—degree of orthogonality between them.</P>
<P class="docText">From the point of view of this appendix, exception handling is mostly one of Python's flow control techniques. In a language like Java, an application is probably considered "happy" if it does not throw any exceptions at all, but Python programmers find exceptions less "exceptional"—a perfectly good design might exit a block of code <span class="docEmphasis">only</span> when an exception is raised.</P>
<P class="docText">Two additional aspects of the Python language are not usually introduced in terms of flow control, but nonetheless amount to such when considered abstractly. Both functional programming style operations on lists and Boolean shortcutting are, at the heart, flow control constructs.</P>
<A NAME="app01lev2sec11"></A><H4 class="docSection2Title">A.4.1 <TT>if/then/else</TT> Statements</H4>
<P class="docText">Choice between alternate code paths is generally performed with the <TT>if</TT> statement and its optional <TT>elif</TT> and <TT>else</TT> components. An <TT>if</TT> block is followed by zero or more <TT>elif</TT> blocks; at the end of the compound statement, zero or one <TT>else</TT> blocks occur. An <TT>if</TT> statement is followed by a Boolean expression and a colon. Each <TT>elif</TT> is likewise followed by a Boolean expression and colon. The <TT>else</TT> statement, if it occurs, has no Boolean expression after it, just a colon. Each statement introduces a block containing one or more statements (indented on the following lines or on the same line, after the colon).</P>
<P class="docText">Every expression in Python has a Boolean value, including every bare object name or literal. Any empty container (list, dict, tuple) is considered false; an empty string or Unicode string is false; the number 0 (of any numeric type) is false. As well, an instance whose class defines a <TT>.__nonzero__()</TT> or <TT>.__len__()</TT> method is false if these methods return a false value. Without these special methods, every instance is true. Much of the time, Boolean expressions consist of comparisons between objects, where comparisons actually evaluate to the canonical objects "0" or "1". Comparisons are <TT>&lt;</TT>, <TT>&gt;</TT>, <TT>==</TT>, <TT>&gt;=</TT>, <TT>&lt;=</TT>, <TT>&lt;&gt;</TT>, <TT>!=</TT>, <TT>is</TT>, <TT>is not</TT>, <TT>in</TT>, and <TT>not in</TT>. Sometimes the unary operator <TT>not</TT> precedes such an expression.</P>
<P class="docText">Only one block in an "if/elif/else" compound statement is executed during any pass—if multiple conditions hold, the first one that evaluates as true is followed. For example:</P>
<pre>
&gt;&gt;&gt; if 2+2 &lt;= 4:
...   print "Happy math"
...
Happy math
&gt;&gt;&gt; x = 3
&gt;&gt;&gt; if x &gt; 4: print "More than 4"
... elif x &gt; 3: print "More than 3"
... elif x &gt; 2: print "More than 2"
... else: print "2 or less"
...
More than 2
&gt;&gt;&gt; if isinstance(2, int):
...     print "2 is an int"     # 2.2+ test
... else:
...     print "2 is not an int"
</pre>
<P class="docText">Python has no "switch" statement to compare one value with multiple candidate matches. Occasionally, the repetition of an expression being compared on multiple <TT>elif</TT> lines looks awkward. A "trick" in such a case is to use a dict as a pseudo-switch. The following are equivalent, for example:</P>
<pre>
&gt;&gt;&gt; if var.upper() == 'ONE':     val = 1
... elif var.upper() == 'TWO':   val = 2
... elif var.upper() == 'THREE': val = 3
... elif var.upper() == 'FOUR':  val = 4
... else:                        val = 0
...
&gt;&gt;&gt; switch = {'ONE':1, 'TWO':2, 'THREE':3, 'FOUR':4}
&gt;&gt;&gt; val = switch.get(var.upper(), 0)
</pre>
<A NAME="app01lev2sec12"></A><H4 class="docSection2Title">A.4.2 Boolean Shortcutting</H4>
<P class="docText">The Boolean operators <TT>or</TT> and <TT>and</TT> are "lazy." That is, an expression containing <TT>or</TT> or <TT>and</TT> evaluates only as far as it needs to determine the overall value. Specifically, if the first disjoin of an <TT>or</TT> is true, the value of that disjoin becomes the value of the expression, without evaluating the rest; if the first conjoin of an <TT>and</TT> is false, its value likewise becomes the value of the whole expression.</P>
<P class="docText">Shortcutting is formally sufficient for switching and is sometimes more readable and concise than "if/elif/else" blocks. For example:</P>
<pre>
&gt;&gt;&gt; if this:          # 'if' compound statement
...     result = this
... elif that:
...     result = that
... else:
...     result = 0
...
&gt;&gt;&gt; result = this or that or 0 # boolean shortcutting
</pre>
<P class="docText">Compound shortcutting is also possible, but not necessarily easy to read; for example:</P>
<pre>
&gt;&gt;&gt; (cond1 and func1()) or (cond2 and func2()) or func3()
</pre>
<A NAME="app01lev2sec13"></A><H4 class="docSection2Title">A.4.3 <TT>for/continue/break</TT> Statements</H4>
<P class="docText">The <TT>for</TT> statement loops over the elements of a sequence. In Python 2.2+, looping utilizes an iterator object (which may not have a predetermined length)—but standard sequences like lists, tuples, and strings are automatically transformed to iterators in <TT>for</TT> statements. In earlier Python versions, a few special functions like <TT>xreadlines()</TT> and <TT>xrange()</TT> also act as iterators.</P>
<P class="docText">Each time a <TT>for</TT> statement loops, a sequence/iterator element is bound to the loop variable. The loop variable may be a tuple with named items, thereby creating bindings for multiple names in each loop. For example:</P>
<pre>
&gt;&gt;&gt; for x,y,z in [(1,2,3),(4,5,6),(7,8,9)]: print x, y, z, '*',
...
1 2 3 * 4 5 6 * 7 8 9 *
</pre>
<P class="docText">A particularly common idiom for operating on each item in a dictionary is:</P>
<pre>
&gt;&gt;&gt; for key,val in dct.items():
...     print key, val, '*',
...
1 2 * 3 4 * 5 6 *
</pre>
<P class="docText">When you wish to loop through a block a certain number of times, a common idiom is to use the <TT>range()</TT> or <TT>xrange()</TT> built-in functions to create ad hoc sequences of the needed length. For example:</P>
<pre>
&gt;&gt;&gt; for _ in range(10):
...     print "X",      # '_' is not used in body
...
X X X X X X X X X X
</pre>
<P class="docText">However, if you find yourself binding over a range just to repeat a block, this often indicates that you have not properly understood the loop. Usually repetition is a way of operating on a collection of related <span class="docEmphasis">things</span> that could instead be explicitly bound in the loop, not just a need to do exactly the same thing multiple times.</P>
<P class="docText">If the <TT>continue</TT> statement occurs in a <TT>for</TT> loop, the next loop iteration proceeds without executing later lines in the block. If the <TT>break</TT> statement occurs in a <TT>for</TT> loop, control passes past the loop without executing later lines (except the <TT>finally</TT> block if the <TT>break</TT> occurs in a <TT>try</TT>).</P>
<A NAME="app01lev2sec14"></A><H4 class="docSection2Title">A.4.4 <TT>map()</TT>, <TT>filter()</TT>, <TT>reduce()</TT>, and List Comprehensions</H4>
<P class="docText">Much like the <TT>for</TT> statement, the built-in functions <span class="docEmphasis"><TT>map()</TT>, <TT>filter()</TT></span>, and <span class="docEmphasis"><TT>reduce()</TT></span> perform actions based on a sequence of items. Unlike a <TT>for</TT> loop, these functions explicitly return a value resulting from this application to each item. Each of these three functional programming style functions accepts a function object as a first argument and sequence(s) as a subsequent argument(s).</P>
<P class="docText">The <span class="docEmphasis"><TT>map()</TT></span> function returns a list of items of the same length as the input sequence, where each item in the result is a "transformation" of one item in the input. Where you explicitly want such transformed items, use of <span class="docEmphasis"><TT>map()</TT></span> is often both more concise and clearer than an equivalent <TT>for</TT> loop; for example:</P>
<pre>
&gt;&gt;&gt; nums = (1,2,3,4)
&gt;&gt;&gt; str_nums = []
&gt;&gt;&gt; for n in nums:
...     str_nums.append(str(n))
...
&gt;&gt;&gt; str_nums
['1', '2', '3', '4']
&gt;&gt;&gt; str_nums = map(str, nums)
&gt;&gt;&gt; str_nums
['1', '2', '3', '4']
</pre>
<P class="docText">If the function argument of <span class="docEmphasis"><TT>map()</TT></span> accepts (or can accept) multiple arguments, multiple sequences can be given as later arguments. If such multiple sequences are of different lengths, the shorter ones are padded with <TT>None</TT> values. The special value <TT>None</TT> may be given as the function argument, producing a sequence of tuples of elements from the argument sequences.</P>
<pre>
&gt;&gt;&gt; nums = (1,2,3,4)
&gt;&gt;&gt; def add(x, y):
...     if x is None: x=0
...     if y is None: y=0
...     return x+y
...
&gt;&gt;&gt; map(add, nums, [5,5,5])
[6, 7, 8, 4]
&gt;&gt;&gt; map(None, (1,2,3,4), [5,5,5])
[(1, 5), (2, 5), (3, 5), (4, None)]
</pre>
<P class="docText">The <span class="docEmphasis"><TT>filter()</TT></span> function returns a list of those items in the input sequence that satisfy a condition given by the function argument. The function argument must accept one parameter, and its return value is interpreted as a Boolean (in the usual manner). For example:</P>
<pre>
&gt;&gt;&gt; nums = (1,2,3,4)
&gt;&gt;&gt; odds = filter(lambda n: n%2, nums)
&gt;&gt;&gt; odds
(1, 3)
</pre>
<P class="docText">Both <span class="docEmphasis"><TT>map()</TT></span> and <span class="docEmphasis"><TT>filter()</TT></span> can use function arguments that have side effects, thereby making it possible—but not usually desirable—to replace every <TT>for</TT> loop with a <span class="docEmphasis"><TT>map()</TT></span> or <span class="docEmphasis"><TT>filter()</TT></span> function. For example:</P>
<pre>
&gt;&gt;&gt; for x in seq:
...     # bunch of actions
...     pass
...
&gt;&gt;&gt; def actions(x):
...     # same bunch of actions
...     return 0
...
&gt;&gt;&gt; filter(actions, seq)
[]
</pre>
<P class="docText">Some epicycles are needed for the scoping of block variables and for <TT>break</TT> and <TT>continue</TT> statements. But as a general picture, it is worth being aware of the formal equivalence between these very different-seeming techniques.</P>
<P class="docText">The <span class="docEmphasis"><TT>reduce()</TT></span> function takes as a function argument a function with two parameters. In addition to a sequence second argument, <span class="docEmphasis"><TT>reduce()</TT></span> optionally accepts a third argument as an initializer. For each item in the input sequence, <span class="docEmphasis"><TT>reduce()</TT></span> combines the previous aggregate result with the item, until the sequence is exhausted. While <span class="docEmphasis"><TT>reduce()</TT></span>—like <span class="docEmphasis"><TT>map()</TT></span> and <span class="docEmphasis"><TT>filter()</TT></span>—has a loop-like effect of operating on every item in a sequence, its main purpose is to create some sort of aggregation, tally, or selection across indefinitely many items. For example:</P>
<pre>
&gt;&gt;&gt; from operator import add
&gt;&gt;&gt; sum = lambda seq: reduce(add, seq)
&gt;&gt;&gt; sum([4,5,23,12])
44
&gt;&gt;&gt; def tastes_better(x, y):
...     # some complex comparison of x, y
...     # either return x, or return y
...     # ...
...
&gt;&gt;&gt; foods = [spam, eggs, bacon, toast]
&gt;&gt;&gt; favorite = reduce(tastes_better, foods)
</pre>
<P class="docText">List comprehensions (listcomps) are a syntactic form that was introduced with Python 2.0. It is easiest to think of list comprehensions as a sort of cross between for loops and the <span class="docEmphasis"><TT>map()</TT></span> or <span class="docEmphasis"><TT>filter()</TT></span> functions. That is, like the functions, listcomps are expressions that produce lists of items, based on "input" sequences. But listcomps also use the keywords <TT>for</TT> and <TT>if</TT> that are familiar from statements. Moreover, it is typically much easier to read a compound list comprehension expression than it is to read corresponding nested <span class="docEmphasis"><TT>map()</TT></span> and <span class="docEmphasis"><TT>filter()</TT></span> functions.</P>
<P class="docText">For example, consider the following small problem: You have a list of numbers and a string of characters; you would like to construct a list of all pairs that consist of a number from the list and a character from the string, but only if the ASCII ordinal is larger than the number. In traditional imperative style, you might write:</P>
<pre>
&gt;&gt;&gt; bigord_pairs = []
&gt;&gt;&gt; for n in (95,100,105):
...     for c in 'aei':
...         if ord(c) &gt; n:
...             bigord_pairs.append((n,c))
...
&gt;&gt;&gt; bigord_pairs
[(95, 'a'), (95, 'e'), (95, 'i'), (100, 'e'), (100, 'i')]
</pre>
<P class="docText">In a functional programming style you might write the nearly unreadable:</P>
<pre>
&gt;&gt;&gt; dupelms=lambda lst,n: reduce(lambda s,t:s+t,
...                              map(lambda l,n=n: [l]*n, 1st))
&gt;&gt;&gt; combine=lambda xs,ys: map(None,xs*len(ys), dupelms(ys,len(xs)))
&gt;&gt;&gt; bigord_pairs=lambda ns,cs: filter(lambda (n,c):ord(c)&gt;n,
...                                   combine(ns,cs))
&gt;&gt;&gt; bigord_pairs((95,100,105),'aei')
[(95, 'a'), (95, 'e'), (100, 'e'), (95, 'i'), (100, 'i')]
</pre>
<P class="docText">In defense of this FP approach, it has not <span class="docEmphasis">only</span> accomplished the task at hand, but also provided the general combinatorial function <TT>combine()</TT> along the way. But the code is still rather obfuscated.</P>
<P class="docText">List comprehensions let you write something that is both concise and clear:</P>
<pre>
&gt;&gt;&gt; [(n,c) for n in (95,100,105) for c in 'aei' if ord(c)&gt;n]
[(95, 'a'), (95, 'e'), (95, 'i'), (100, 'e'), (100, 'i')]
</pre>
<P class="docText">As long as you have listcomps available, you hardly <span class="docEmphasis">need</span> a general <TT>combine()</TT> function, since it just amounts to repeating the <TT>for</TT> clause in a listcomp.</P>
<P class="docText">Slightly more formally, a list comprehension consists of the following: (1) Surrounding square brackets (like a list constructor, which it is). (2) An expression that usually, but not by requirement, contains some names that get bound in the <TT>for</TT> clauses. (3) One or more <TT>for</TT> clauses that bind a name repeatedly (just like a <TT>for</TT> loop). (4) Zero or more <TT>if</TT> clauses that limit the results. Generally, but not by requirement, the <TT>if</TT> clauses contain some names that were bound by the <TT>for</TT> clauses.</P>
<P class="docText">List comprehensions may nest inside each other freely. Sometimes a <TT>for</TT> clause in a listcomp loops over a list that is defined by another listcomp; once in a while a nested listcomp is even used inside a listcomp's expression or <TT>if</TT> clauses. However, it is almost as easy to produce difficult-to-read code by excessively nesting listcomps as it is by nesting <span class="docEmphasis"><TT>map()</TT></span> and <span class="docEmphasis"><TT>filter()</TT></span> functions. Use caution and common sense about such nesting.</P>
<P class="docText">It is worth noting that list comprehensions are not as referentially transparent as functional programming style calls. Specifically, any names bound in <TT>for</TT> clauses remain bound in the enclosing scope (or global if the name is so declared). These side effects put a minor extra burden on you to choose distinctive or throwaway names for use in listcomps.</P>
<A NAME="app01lev2sec15"></A><H4 class="docSection2Title">A.4.5 <TT>while/else/continue/break</TT> Statements</H4>
<P class="docText">The <TT>while</TT> statement loops over a block as long as the expression after the <TT>while</TT> remains true. If an <TT>else</TT> block is used within a compound <TT>while</TT> statement, as soon as the expression becomes false, the <TT>else</TT> block is executed. The <TT>else</TT> block is chosen even if the <TT>while</TT> expression is initially false.</P>
<P class="docText">If the <TT>continue</TT> statement occurs in a <TT>while</TT> loop, the next loop iteration proceeds without executing later lines in the block. If the <TT>break</TT> statement occurs in a <TT>while </TT>loop, control passes past the loop without executing later lines (except the <TT>finally</TT> block if the <TT>break</TT> occurs in a <TT>try</TT>). If a <TT>break</TT> occurs in a <TT>while</TT> block, the <TT>else</TT> block is not executed.</P>
<P class="docText">If a <TT>while</TT> statement's expression is to go from being true to being false, typically some name in the expression will be re-bound within the <TT>while</TT> block. At times an expression will depend on an external condition, such as a file handle or a socket, or it may involve a call to a function whose Boolean value changes over invocations. However, probably the most common Python idiom for <TT>while</TT> statements is to rely on a <TT>break</TT> to terminate a block. Some examples:</P>
<pre>
&gt;&gt;&gt; command = ''
&gt;&gt;&gt; while command != 'exit':
...     command = raw_input('Command &gt; ')
...     # if/elif block to dispatch on various commands
...
Command &gt; someaction
Command &gt; exit
&gt;&gt;&gt; while socket.ready():
...     socket.getdata()  # do something with the socket
... else:
...     socket.close()    # cleanup (e.g. close socket)
...
&gt;&gt;&gt; while 1:
...     command = raw_input('Command &gt; ')
...     if command == 'exit': break
...     # elif's for other commands
...
Command &gt; someaction
Command &gt; exit
</pre>
<A NAME="app01lev2sec16"></A><H4 class="docSection2Title">A.4.6 Functions, Simple Generators, and the <TT>yield</TT> Statement</H4>
<P class="docText">Both functions and object methods allow a kind of nonlocality in terms of program flow, but one that is quite restrictive. A function or method is called from another context, enters at its top, executes any statements encountered, then returns to the calling context as soon as a <TT>return</TT> statement is reached (or the function body ends). The invocation of a function or method is basically a strictly linear nonlocal flow.</P>
<P class="docText">Python 2.2 introduced a flow control construct, called generators, that enables a new style of nonlocal branching. If a function or method body contains the statement <TT>yield</TT>, then it becomes a <span class="docEmphasis">generator function,</span> and invoking the function returns a <span class="docEmphasis">generator iterator</span> instead of a simple value. A generator iterator is an object that has a <TT>.next()</TT> method that returns values. Any instance object can have a <TT>.next()</TT> method, but a generator iterator's method is special in having "resumable execution."</P>
<P class="docText">In a standard function, once a <TT>return</TT> statement is encountered, the Python interpreter discards all information about the function's flow state and local name bindings. The returned value might contain some information about local values, but the flow state is always gone. A generator iterator, in contrast, "remembers" the entire flow state, and all local bindings, between each invocation of its <TT>.next()</TT> method. A value is returned to a calling context each place a <TT>yield</TT> statement is encountered in the generator function body, but the calling context (or any context with access to the generator iterator) is able to jump back to the flow point where this last <TT>yield</TT> occurred.</P>
<P class="docText">In the abstract, generators seem complex, but in practice they prove quite simple. For example:</P>
<pre>
&gt;&gt;&gt; from __future__ import generators # not needed in 2.3+
&gt;&gt;&gt; def generator_func():
...     for n in [1,2]:
...         yield n
...     print "Two yields in for loop"
...     yield 3
...
&gt;&gt;&gt; generator_iter = generator_func()
&gt;&gt;&gt; generator_iter.next()
1
&gt;&gt;&gt; generator_iter.next()
2
&gt;&gt;&gt; generator_iter.next()
Two yields in for loop
3
&gt;&gt;&gt; generator_iter.next()
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in ?
StopIteration
</pre>
<P class="docText">The object <TT>generator_iter</TT> in the example can be bound in different scopes, and passed to and returned from functions, just like any other object. Any context invoking <TT>generator_iter.next()</TT> jumps back into the last flow point where the generator function body yielded.</P>
<P class="docText">In a sense, a generator iterator allows you to perform jumps similar to the "GOTO" statements of some (older) languages, but still retains the advantages of structured programming. The most common usage for generators, however, is simpler than this. Most of the time, generators are used as "iterators" in a loop context; for example:</P>
<pre>
&gt;&gt;&gt; for n in generator_func():
...     print n
...
1
2
Two yields  in for loop
3
</pre>
<P class="docText">In recent Python versions, the <TT>StopIteration</TT> exception is used to signal the end of a <TT>for</TT> loop. The generator iterator's <TT>.next()</TT> method is implicitly called as many times as possible by the <TT>for</TT> statement. The name indicated in the <TT>for</TT> statement is repeatedly re-bound to the values the <TT>yield</TT> statement(s) return.</P>
<A NAME="app01lev2sec17"></A><H4 class="docSection2Title">A.4.7 Raising and Catching Exceptions</H4>
<P class="docText">Python uses exceptions quite broadly and probably more naturally than any other programming language. In fact there are certain flow control constructs that are awkward to express by means other than raising and catching exceptions.</P>
<P class="docText">There are two general purposes for exceptions in Python. On the one hand, Python actions can be invalid or disallowed in various ways. You are not allowed to divide by zero; you cannot open (for reading) a filename that does not exist; some functions require arguments of specific types; you cannot use an unbound name on the right side of an assignment; and so on. The exceptions raised by these types of occurrences have names of the form <TT>[A–Z].*Error</TT>. Catching <span class="docEmphasis">error</span> exceptions is often a useful way to recover from a problem condition and restore an application to a "happy" state. Even if such error exceptions are not caught in an application, their occurrence provides debugging clues since they appear in tracebacks.</P>
<P class="docText">The second purpose for exceptions is for circumstances a programmer wishes to flag as "exceptional." But understand "exceptional" in a weak sense—not as something that indicates a programming or computer error, but simply as something unusual or "not the norm." For example, Python 2.2+ iterators raise a <TT>StopIteration</TT> exception when no more items can be generated. Most such implied sequences are not infinite length, however; it is merely the case that they contain a (large) number of items, and they run out only once at the end. It's not "the norm" for an iterator to run out of items, but it is often expected that this will happen eventually.</P>
<P class="docText">In a sense, raising an exception can be similar to executing a <TT>break</TT> statement—both cause control flow to leave a block. For example, compare:</P>
<pre>
&gt;&gt;&gt; n = 0
&gt;&gt;&gt; while 1:
...     n = n+1
...     if n &gt; 10: break
...
&gt;&gt;&gt; print n
11
&gt;&gt;&gt; n = 0
&gt;&gt;&gt; try:
...     while 1:
...         n = n+1
...         if n &gt; 10: raise "ExitLoop"
... except:
...     print n
...
11
</pre>
<P class="docText">In two closely related ways, exceptions behave differently than do <TT>break</TT> statements. In the first place, exceptions could be described as having "dynamic scope," which in most contexts is considered a sin akin to "GOTO," but here is quite useful. That is, you never know at compile time exactly where an exception might get caught (if not anywhere else, it is caught by the Python interpreter). It might be caught in the exception's block, or a containing block, and so on; or it might be in the local function, or something that called it, or something that called the caller, and so on. An exception is a <span class="docEmphasis">fact</span> that winds its way through execution contexts until it finds a place to settle. The upward propagation of exceptions is quite opposite to the downward propagation of lexically scoped bindings (or even to the earlier "three-scope rule").</P>
<P class="docText">The corollary of exceptions' dynamic scope is that, unlike <TT>break</TT>, they can be used to exit gracefully from deeply nested loops. The "Zen of Python" offers a caveat here: "Flat is better than nested." And indeed it is so, if you find yourself nesting loops <span class="docEmphasis">too</span> deeply, you should probably refactor (e.g., break loops into utility functions). But if you are nesting <span class="docEmphasis">just deeply enough,</span> dynamically scoped exceptions are just the thing for you. Consider the following small problem: A "Fermat triple" is here defined as a triple of integers (i,j,k) such that "i**2 + j**2 == k**2". Suppose that you wish to determine if any Fermat triples exist with all three integers inside a given numeric range. An obvious (but entirely nonoptimal) solution is:</P>
<pre>
&gt;&gt;&gt; def fermat_triple(beg, end):
...     class EndLoop(Exception): pass
...     range_ = range(beg, end)
...     try:
...         for i in range_:
...             for j in range_:
...                 for k in range_:
...                     if i**2 + j**2 == k**2:
...                         raise EndLoop, (i,j,k)
...     except EndLoop, triple:
...         # do something with 'triple'
...         return i,j,k
...
&gt;&gt;&gt; fermat_triple(1,10)
(3, 4, 5)
&gt;&gt;&gt; fermat_triple(120,150)
&gt;&gt;&gt; fermat_triple(100,150)
(100, 105, 145)
</pre>
<P class="docText">By raising the <TT>EndLoop</TT> exception in the middle of the nested loops, it is possible to catch it again outside of all the loops. A simple <TT>break</TT> in the inner loop would only break out of the most deeply nested block, which is pointless. One might devise some system for setting a "satisfied" flag and testing for this at every level, but the exception approach is much simpler. Since the <TT>except</TT> block does not actually <span class="docEmphasis">do</span> anything extra with the triple, it could have just been returned inside the loops; but in the general case, other actions can be required before a <TT>return</TT>.</P>
<P class="docText">It is not uncommon to want to leave nested loops when something has "gone wrong" in the sense of an "*Error" exception. Sometimes you might only be in a position to discover a problem condition within nested blocks, but recovery still makes better sense outside the nesting. Some typical examples are problems in I/O, calculation overflows, missing dictionary keys or list indices, and so on. Moreover, it is useful to assign <TT>except</TT> statements to the calling position that really needs to handle the problems, then write support functions as if nothing can go wrong. For example:</P>
<pre>
&gt;&gt;&gt; try:
...     result = complex_file_operation(filename)
... except IOError:
...     print "Cannot open file", filename
</pre>
<P class="docText">The function <TT>complex_file_operation()</TT> should not be burdened with trying to figure out what to do if a bad <TT>filename</TT> is given to it—there is really nothing to be done in that context. Instead, such support functions can simply propagate their exceptions upwards, until some caller takes responsibility for the problem.</P>
<P class="docText">The <TT>try</TT> statement has two forms. The <TT>try/except/else</TT> form is more commonly used, but the <TT>try/finally</TT> form is useful for "cleanup handlers."</P>
<P class="docText">In the first form, a <TT>try</TT> block must be followed by one or more <TT>except</TT> blocks. Each <TT>except</TT> may specify an exception or tuple of exceptions to catch; the last <TT>except</TT> block may omit an exception (tuple), in which case it catches every exception that is not caught by an earlier <TT>except</TT> block. After the <TT>except</TT> blocks, you may optionally specify an <TT>else</TT> block. The <TT>else</TT> block is run only if no exception occurred in the <TT>try</TT> block. For example:</P>
<pre>
&gt;&gt;&gt; def except_test(n):
...     try: x = 1/n
...     except IOError: print "IO Error"
...     except ZeroDivisionError: print "Zero Division"
...     except: print "Some Other Error"
...     else: print "All is Happy"
...
&gt;&gt;&gt; except_test(l)
All is Happy
&gt;&gt;&gt; except_test(0)
Zero Division
&gt;&gt;&gt; except_test('x')
Some Other Error
</pre>
<P class="docText">An <TT>except</TT> test will match either the exception actually listed or any descendent of that exception. It tends to make sense, therefore, in defining your own exceptions to inherit from related ones in the <span class="docEmphasis"><TT>exceptions</TT></span> module. For example:</P>
<pre>
&gt;&gt;&gt; class MyException(IOError): pass
&gt;&gt;&gt; try:
...    raise MyException
... except IOError:
...    print "got it"
...
got it
</pre>
<P class="docText">In the <TT>try/finally</TT> form of the <TT>try</TT> statement, the <TT>finally</TT> statement acts as general cleanup code. If no exception occurs in the <TT>try</TT> block, the <TT>finally</TT> block runs, and that is that. If an exception <span class="docEmphasis">was</span> raised in the <TT>try</TT> block, the <TT>finally</TT> block still runs, but the original exception is re-raised at the end of the block. However, if a <TT>return</TT> or <TT>break</TT> statement is executed in a <TT>finally</TT> block—or if a new exception is raised in the block (including with the <TT>raise</TT> statement)—the <TT>finally</TT> block never reaches its end, and the original exception disappears.</P>
<P class="docText">A <TT>finally</TT> statement acts as a cleanup block even when its corresponding <TT>try</TT> block contains a <TT>return</TT>, <TT>break</TT>, or <TT>continue</TT> statement. That is, even though a <TT>try</TT> block might not run all the way through, <TT>finally</TT> is still entered to clean up whatever the <TT>try</TT> <span class="docEmphasis">did</span> accomplish. A typical use of this compound statement opens a file or other external resource at the very start of the <TT>try</TT> block, then performs several actions that may or may not succeed in the rest of the block; the <TT>finally</TT> is responsible for making sure the file gets closed, whether or not all the actions on it prove possible.</P>
<P class="docText">The <TT>try/finally</TT> form is never strictly needed since a bare <TT>raise</TT> statement will reraise the last exception. It is possible, therefore, to have an <TT>except</TT> block end with the <TT>raise</TT> statement to propagate an error upward after taking some action. However, when a cleanup action is desired whether or not exceptions were encountered, the <TT>try/finally</TT> form can save a few lines and express your intent more clearly. For example:</P>
<pre>
&gt;&gt;&gt; def finally_test(x):
...     try:
...         y = 1/x
...         if x &gt; 10:
...             return x
...     finally:
...         print "Cleaning up..."
...     return y
...
&gt;&gt;&gt; finally_test(0)
Cleaning up...
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in ?
  File "&lt;stdin&gt;", line 3, in finally_test
ZeroDivisionError: integer division or modulo by zero
&gt;&gt;&gt; finally_test(3)
Cleaning up...
0
&gt;&gt;&gt; finally_test(100)
Cleaning up...
100
</pre>
<A NAME="app01lev2sec18"></A><H4 class="docSection2Title">A.4.8 Data as Code</H4>
<P class="docText">Unlike in languages in the Lisp family, it is <span class="docEmphasis">usually</span> not a good idea to create Python programs that execute data values. It is <span class="docEmphasis">possible,</span> however, to create and run Python strings during program runtime using several built-in functions. The modules <span class="docEmphasis"><TT>code</TT>, <TT>codeop</TT>, <TT>imp</TT></span>, and <span class="docEmphasis"><TT>new</TT></span> provide additional capabilities in this direction. In fact, the Python interactive shell itself is an example of a program that dynamically reads strings as user input, then executes them. So clearly, this approach is occasionally useful.</P>
<P class="docText">Other than in providing an interactive environment for advanced users (who themselves know Python), a possible use for the "data as code" model is with applications that themselves generate Python code, either to run later or to communicate with another application. At a simple level, it is not difficult to write compilable Python programs based on templatized functionality; for this to be useful, of course, you would want a program to contain some customization that was determinable only at runtime.</P>
<A NAME="app01lev4sec13"></A><H5 class="docSection3Title"> eval(s [,globals=globals() [,locals=locals()]])</H5>
<P class="docText">Evaluate the expression in string <TT>s</TT> and return the result of that evaluation. You may specify optional arguments <TT>globals</TT> and <TT>locals</TT> to specify the namespaces to use for name lookup. By default, use the regular global and local namespace dictionaries. Note that only an expression can be evaluated, not a statement suite.</P>
<P class="docText">Most of the time when a (novice) programmer thinks of using <span class="docEmphasis"><TT>eval()</TT></span> it is to compute some value—often numeric—based on data encoded in texts. For example, suppose that a line in a report file contains a list of dollar amounts, and you would like the sum of these numbers. A naive approach to the problem uses <span class="docEmphasis"><TT>eval()</TT> :</span></P>
<pre>
&gt;&gt;&gt; line = "$47  $33  $51  $76"
&gt;&gt;&gt; eval("+".join([d.replace('$', '') for d in line.split()]))
207
</pre>
<P class="docText">While this approach is generally slow, that is not an important problem. A more significant issue is that <span class="docEmphasis"><TT>eval()</TT></span> runs code that is not known until runtime; potentially <TT>line</TT> could contain Python code that causes harm to the system it runs on or merely causes an application to malfunction. Imagine that instead of a dollar figure, your data file contained <TT>os.rmdir("/")</TT>. A better approach is to use the safe type coercion functions <span class="docEmphasis"><TT>int()</TT>, <TT>float()</TT></span>, and so on.</P>
<pre>
&gt;&gt;&gt; nums = [int(d.replace('$', '')) for d in line.split()]
&gt;&gt;&gt; from operator import add
&gt;&gt;&gt; reduce(add, nums)
207
</pre>
<A NAME="app01lev4sec14"></A><H5 class="docSection3Title"> exec</H5>
<P class="docText">The <span class="docEmphasis"><TT>exec</TT></span> statement is a more powerful sibling of the <span class="docEmphasis"><TT>eval()</TT></span> function. Any valid Python code may be run if passed to the <span class="docEmphasis"><TT>exec</TT></span> statement. The format of the <span class="docEmphasis"><TT>exec</TT></span> statement allows optional namespace specification, as with <span class="docEmphasis"><TT>eval()</TT></span> :</P>
<pre>
exec code [in globals [,locals]]
</pre>
<P class="docText">For example:</P>
<pre>
&gt;&gt;&gt; s = "for i in range(10):\n  print i,\n"
&gt;&gt;&gt; exec s in globals(), locals()
0 1 2 3 4 5 6 7 8 9
</pre>
<P class="docText">The argument <TT>code</TT> may be either a string, a code object, or an open file object. As with <span class="docEmphasis"><TT>eval()</TT></span>, the security dangers and speed penalties of <span class="docEmphasis"><TT>exec</TT></span> usually outweigh any convenience provided. However, where <TT>code</TT> is clearly under application control, there are occasionally uses for this statement.</P>
<A NAME="app01lev4sec15"></A><H5 class="docSection3Title"> __import__(s [,globals=globals() [,locals=locals() [,fromlist]]])</H5>
<P class="docText">Import the module named <TT>s</TT>, using namespace dictionaries <TT>globals</TT> and <TT>locals</TT>. The argument <TT>fromlist</TT> may be omitted, but if specified as a nonempty list of strings—e.g., <TT>[""]</TT>—the fully qualified subpackage will be imported. For normal cases, the <span class="docEmphasis"><TT>import</TT></span> statement is the way you import modules, but in the special circumstance that the value of <TT>s</TT> is not determined until runtime, use <TT>__</TT><span class="docEmphasis"><TT>import</TT></span><TT>__</TT><span class="docEmphasis"><TT>()</TT></span>.</P>
<pre>
&gt;&gt;&gt; op = __import__('os.path',globals(),locals(),[''])
&gt;&gt;&gt; op.basename('/this/that/other')
'other'
</pre>
<A NAME="app01lev4sec16"></A><H5 class="docSection3Title"> input([prompt])</H5>
<P class="docText">Equivalent to <TT>eval(raw_input (prompt))</TT>, along with all the dangers associated with <span class="docEmphasis"><TT>eval()</TT></span> generally. Best practice is to always use <span class="docEmphasis"><TT>raw_input()</TT></span>, but you might see <span class="docEmphasis"><TT>input()</TT></span> in existing programs.</P>
<A NAME="app01lev4sec17"></A><H5 class="docSection3Title"> raw_input([prompt])</H5>
<P class="docText">Return a string from user input at the terminal. Used to obtain values interactive in console-based applications.</P>
<pre>
&gt;&gt;&gt; s = raw_input('Last Name: ')
Last Name: Mertz
&gt;&gt;&gt; s
'Mertz'
</pre>
<ul></ul></td></tr></table>
<td></td>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<td class="tt1"><a href="NFO/lib.html">[ Team LiB ]</a></td><td valign="top" class="tt1" align="right">
          <a href="0321112547_app01lev1sec3.html"><img src="FILES/btn_prev.gif" width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a>
          <a href="0321112547_app01lev1sec5.html"><img src="FILES/btn_next.gif" width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a>
</td></table>
</body></html>
