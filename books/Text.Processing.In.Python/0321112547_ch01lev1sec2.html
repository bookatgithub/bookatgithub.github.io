<html><head>
<META http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<!--SafClassName="docSection1Title"--><!--SafTocEntry="1.2 Standard Modules"-->
<link rel="STYLESHEET" type="text/css" href="FILES/style.css">
<link rel="STYLESHEET" type="text/css" href="FILES/docsafari.css">
<style type="text/css">	.tt1    {font-size: 10pt;}</style>
</head>
<body>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<td class="tt1"><a href="NFO/lib.html">[ Team LiB ]</a></td><td valign="top" class="tt1" align="right">
	<a href="0321112547_ch01lev1sec1.html"><img src="FILES/btn_prev.gif" width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a>
	<a href="0321112547_ch01lev1sec3.html"><img src="FILES/btn_next.gif" width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a>
</td></table>
<br>
<table width="100%" border="0" cellspacing="0" cellpadding="0"><tr><td valign="top"><A NAME="ch01lev1sec2"></A><H3 class="docSection1Title">1.2 Standard Modules</H3>
<P class="docText">There are a variety of tasks that many or most text processing applications will perform, but that are not themselves text processing tasks. For example, texts typically live inside files, so for a concrete application you might want to check whether files exist, whether you have access to them, and whether they have certain attributes; you might also want to read their contents. The text processing per se does not happen until the text makes it into a Python value, but getting the text into local memory is a necessary step.</P>
<P class="docText">Another task is making Python objects persistent so that final or intermediate processing results can be saved in computer-usable forms. Or again, Python applications often benefit from being able to call external processes and possibly work with the results of those calls.</P>
<P class="docText">Yet another class of modules helps you deal with Python internals in ways that go beyond what the inherent syntax does. I have made a judgment call in this book as to which such "Python internal" modules are sufficiently general and frequently used in text processing applications; a number of "internal" modules are given only one-line descriptions under the "Other Modules" topic.</P>
<A NAME="ch01lev2sec7"></A><H4 class="docSection2Title">1.2.1 Working with the Python Interpreter</H4>
<P class="docText">Some of the modules in the standard library contain functionality that is nearly as important to Python as the basic syntax. Such modularity is an important strength of Python's design, but users of other languages may be surprised to find capabilities for reading command-line arguments, catching exceptions, copying objects, or the like in external modules.</P>
<P><A NAME="ch01sb14"></A><TABLE CELLSPACING="0" WIDTH="90%" BORDER="1"><TR><TD>
<P class="docText"><span class="docEmphStrong">copy </span>&#8226; <span class="docEmphStrong">Generic copying operations</span></P></TD></TR></TABLE></P>
<P class="docText">Names in Python programs are merely bindings to underlying objects; many of these objects are mutable. This point is simple, but it winds up biting almost every beginning Python programmer—and even a few experienced Pythoners get caught, too. The problem is that binding another name (including a sequence position, dictionary entry, or attribute) to an object leaves you with two names bound to the same object. If you change the underlying object using one name, the other name also points to a changed object. Sometimes you want that, sometimes you do not.</P>
<P class="docText">One variant of the binding trap is a particularly frequent pitfall. Say you want a 2D table of values, initialized as zeros. Later on, you would like to be able to refer to a row/column position as, for example, <TT>table[2][3]</TT> (as in many programming languages). Here is what you would probably try first, along with its failure:</P>
<pre>
&gt;&gt;&gt; row = [0]*4
&gt;&gt;&gt; print row
[0, 0, 0, 0]
&gt;&gt;&gt; table = [row]*4   # or 'table = [[0]*4]*4
&gt;&gt;&gt; for row in table: print row
...
[0, 0, 0, 0]
[0, 0, 0, 0]
[0, 0, 0, 0]
[0, 0, 0, 0]
&gt;&gt;&gt; table[2][3] = 7
&gt;&gt;&gt; for row in table: print row
...
[0, 0, 0, 7]
[0, 0, 0, 7]
[0, 0, 0, 7]
[0, 0, 0, 7]
&gt;&gt;&gt; id(table[2]), id(table[3])
(6207968, 6207968)
</pre>
<P class="docText">The problem with the example is that <TT>table</TT> is a list of four positional bindings to the <span class="docEmphasis">exact same</span> list object. You cannot change just one row, since all four point to just one object. What you need instead is a <span class="docEmphasis">copy</span> of <TT>row</TT> to put in each row of <TT>table</TT>.</P>
<P class="docText">Python provides a number of ways to create copies of objects (and bind them to names). Such a copy is a "snapshot" of the state of the object that can be modified independently of changes to the original. A few ways to correct the table problem are:</P>
<pre>
&gt;&gt;&gt; table1 = map(list, [(0,)*4]*4)
&gt;&gt;&gt; id(table1[2]), id(table1[3])
(6361712, 6361808)
&gt;&gt;&gt; table2 = [1st[:] for 1st in [[0]*4]*4]
&gt;&gt;&gt; id(table2[2]), id(table2[3])
(6356720, 6356800)
&gt;&gt;&gt; from copy import copy
&gt;&gt;&gt; row = [0]*4
&gt;&gt;&gt; table3 = map(copy, [row]*4)
&gt;&gt;&gt; id(table3[2]), id(table3[3])
(6498640, 6498720)
</pre>
<P class="docText">In general, slices always create new lists. In Python 2.2+, the constructors <TT>list()</TT> and <TT>dict()</TT> likewise construct new/copied lists/dicts (possibly using other sequence or association types as arguments).</P>
<P class="docText">But the most general way to make a new copy of <span class="docEmphasis">whatever object you might need</span> is with the <span class="docEmphasis"><TT>copy</TT></span> module. If you use the <span class="docEmphasis"><TT>copy</TT></span> module you do not need to worry about issues of whether a given sequence is a list, or merely list-like, which the <TT>list()</TT> coercion forces into a list.</P>
<A NAME="ch01lev3sec19"></A><H5 class="docSection3Title"> FUNCTIONS</H5>
<A NAME="ch01lev4sec83"></A><H5 class="docSection4Title"> copy.copy(obj)</H5>
<P class="docText">Return a shallow copy of a Python object. Most (but not quite all) types of Python objects can be copied. A shallow copy binds its elements/members to the same objects as bound in the original—but the object itself is distinct.</P>
<pre>
&gt;&gt;&gt; import copy
&gt;&gt;&gt; class C: pass
...
&gt;&gt;&gt; o1 = C()
&gt;&gt;&gt; o1.lst = [1,2,3]
&gt;&gt;&gt; o1.str = "spam"
&gt;&gt;&gt; o2 = copy.copy(o1)
&gt;&gt;&gt; o1.lst.append(17)
&gt;&gt;&gt; o2.lst
[1, 2, 3, 17]
&gt;&gt;&gt; o1.str = 'eggs'
&gt;&gt;&gt; o2.str
'spam'
</pre>
<A NAME="ch01lev4sec84"></A><H5 class="docSection4Title"> copy.deepcopy(obj)</H5>
<P class="docText">Return a deep copy of a Python object. Each element or member in an object is itself recursively copied. For nested containers, it is usually more desirable to perform a deep copy—otherwise you can run into problems like the 2D table example above.</P>
<pre>
&gt;&gt;&gt; o1 = C()
&gt;&gt;&gt; o1.lst = [1,2,3]
&gt;&gt;&gt; o3 = copy.deepcopy(o1)
&gt;&gt;&gt; o1.lst.append(17)
&gt;&gt;&gt; o3.lst
[1, 2, 3]
&gt;&gt;&gt; o1.lst
[1, 2, 3, 17]
</pre>
<P><A NAME="ch01sb15"></A><TABLE CELLSPACING="0" WIDTH="90%" BORDER="1"><TR><TD>
<P class="docText"><span class="docEmphStrong">exceptions </span>&#8226; <span class="docEmphStrong">Standard exception class hierarchy</span></P></TD></TR></TABLE></P>
<P class="docText">Various actions in Python raise exceptions, and these exceptions can be caught using an <TT>except</TT> clause. Although strings can serve as exceptions for backwards-compatibility reasons, it is greatly preferable to use class-based exceptions.</P>
<P class="docText">When you catch an exception in using an <TT>except</TT> clause, you also catch any descendent exceptions. By utilizing a hierarchy of standard and user-defined exception classes, you can tailor exception handling to meet your specific code requirements.</P>
<pre>
&gt;&gt;&gt; class MyException(StandardError): pass
...
&gt;&gt;&gt; try:
...     raise MyException
... except StandardError:
...     print "Caught parent"
... except MyException:
...     print "Caught specific class"
... except:
...     print "Caught generic leftover"
...
Caught parent
</pre>
<P class="docText">In general, if you need to raise exceptions manually, you should either use a built-in exception close to your situation, or inherit from that built-in exception. The outline in <A class="docLink" HREF="#ch01fig01">Figure 1.1</A> shows the exception classes defined in <span class="docEmphasis"><TT>exceptions</TT></span>.</P>
<CENTER><H5 class="docFigureTitle"><A NAME="ch01fig01"></A>Figure 1.1. Standard exceptions</H5>
<p class="docText"><IMG BORDER="0" WIDTH="400" HEIGHT="493" src="FILES/01fig01.jpg" ALT="graphics/01fig01.jpg"></p></CENTER>
<P><A NAME="ch01sb16"></A><TABLE CELLSPACING="0" WIDTH="90%" BORDER="1"><TR><TD>
<P class="docText"><span class="docEmphStrong">getopt </span>&#8226; <span class="docEmphStrong">Parser for command line options</span></P></TD></TR></TABLE></P>
<P class="docText">Utility applications—whether for text processing or otherwise—frequently accept a variety of command-line switches to configure their behavior. In principle, and frequently in practice, all that you need to do to process command-line options is read through the list <TT>sys.argv[1:]</TT> and handle each element of the option line. I have certainly written my own small "sys.argv parser" more than once; it is not hard if you do not expect too much.</P>
<P class="docText">The <span class="docEmphasis"><TT>getopt</TT></span> module provides some automation and error handling for option parsing. It takes just a few lines of code to tell <span class="docEmphasis"><TT>getopt</TT></span> what options it should handle, and which switch prefixes and parameter styles to use. However, <span class="docEmphasis"><TT>getopt</TT></span> is not necessarily the final word in parsing command lines. Python 2.3 includes Greg Ward's <span class="docEmphasis"><TT>optik</TT></span> module <TT>&lt;</TT><A class="docLink" target="_blank" HREF="http://optik.sourceforge.net/default.htm">http://optik.sourceforge.net/</A><TT>&gt;</TT> renamed as <span class="docEmphasis"><TT>optparse</TT></span>, and the Twisted Matrix library contains <span class="docEmphasis"><TT>twisted.python.usage</TT></span> <TT>&lt;</TT><A class="docLink" target="_blank" HREF="http://www.twistedmatrix.com/documents/howto/options">http://www.twistedmatrix.com/documents/howto/options</A><TT>&gt;</TT>. These modules, and other third-party tools, were written because of perceived limitations in <span class="docEmphasis"><TT>getopt</TT></span>.</P>
<P class="docText">For most purposes, <span class="docEmphasis"><TT>getopt</TT></span> is a perfectly good tool. Moreover, even if some enhanced module is included in later Python versions, either this enhancement will be backwards compatible or <span class="docEmphasis"><TT>getopt</TT></span> will remain in the distribution to support existing scripts.</P>
<p class="docText"><span class="docEmphRoman">S<span class="docEmphSmaller">EE</span> A<span class="docEmphSmaller">LSO</span></span>: 
sys.argv <span class="docEmphasis">49;</span></p>
<A NAME="ch01lev3sec20"></A><H5 class="docSection3Title"> FUNCTIONS</H5>
<A NAME="ch01lev4sec85"></A><H5 class="docSection4Title"> getopt.getopt(args, options [,long_options]])</H5>
<P class="docText">The argument <TT>args</TT> is the actual list of options being parsed, most commonly <TT>sys.argv[1:]</TT>. The argument <TT>options</TT> and the optional argument <TT>long_options</TT> contain formats for acceptable options. If any options specified in <TT>args</TT> do not match any acceptable format, a <span class="docEmphasis"><TT>getopt.GetoptError</TT></span> exception is raised. All options must begin with either a single dash for single-letter options or a double dash for long options (DOS-style leading slashes are not usable, unfortunately).</P>
<P class="docText">The return value of <span class="docEmphasis"><TT>getopt.getopt()</TT></span> is a pair containing an option list and a list of additional arguments. The latter is typically a list of filenames the utility will operate on. The option list is a list of pairs of the form <TT>(option, value)</TT>. Under recent versions of Python, you can convert an option list to a dictionary with <TT>dict(optlist)</TT>, which is likely to be useful.</P>
<P class="docText">The <TT>options</TT> format string is a sequence of letters, each optionally followed by a colon. Any option letter followed by a colon takes a (mandatory) value after the option.</P>
<P class="docText">The format for <TT>long_options</TT> is a list of strings indicating the option names (excluding the leading dashes). If an option name ends with an equal sign, it requires a value after the option.</P>
<P class="docText">It is easiest to see <span class="docEmphasis"><TT>getopt</TT></span> in action:</P>
<pre>
&gt;&gt;&gt; import getopt
&gt;&gt;&gt; opts='-al -b -c 2 --foo=bar --baz file1 file2'.split()
&gt;&gt;&gt; optlist, args = getopt.getopt(opts,'a:bc:',['foo=','baz'])
&gt;&gt;&gt; optlist
[('-a', '1'), ('-b', ''), ('-c', '2'), ('--foo', 'bar'),
('--baz', '')]
&gt;&gt;&gt; args
['file1', 'file2']
&gt;&gt;&gt; nodash = lambda s: \
...          s.translate(''.join(map(chr,range(256))),'-')
&gt;&gt;&gt; todict = lambda 1: \
...          dict([(nodash(opt),val) for opt,val in 1])
&gt;&gt;&gt; optdict = todict(optlist)
&gt;&gt;&gt; optdict
{'a': '1', 'c': '2', 'b': '', 'baz': '', 'foo': 'bar'}
</pre>
<P class="docText">You can examine options given either by looping through <TT>optlist</TT> or by performing <TT>optdict.get(key, default)</TT> type tests as needed in your program flow.</P>
<P><A NAME="ch01sb17"></A><TABLE CELLSPACING="0" WIDTH="90%" BORDER="1"><TR><TD>
<P class="docText"><span class="docEmphStrong">operator </span>&#8226; <span class="docEmphStrong">Standard operations as functions</span></P></TD></TR></TABLE></P>
<P class="docText">All of the standard Python syntactic operators are available in functional form using the <span class="docEmphasis"><TT>operator</TT></span> module. In most cases, it is more clear to use the actual operators, but in a few cases functions are useful. The most common usage for <span class="docEmphasis"><TT>operator</TT></span> is in conjunction with functional programming constructs. For example:</P>
<pre>
&gt;&gt;&gt; import operator
&gt;&gt;&gt; 1st = [1, 0, (), '', 'abc']
&gt;&gt;&gt; map(operator.not_, 1st)   # fp-style negated bool vals
[0, 1, 1, 1, 0]
&gt;&gt;&gt; tmplst = []               # imperative style
&gt;&gt;&gt; for item in 1st:
...     tmplst.append(not item)
...
&gt;&gt;&gt; tmplst
[0, 1, 1, 1, 0]
&gt;&gt;&gt; del tmplst                # must cleanup stray name
</pre>
<P class="docText">As well as being shorter, I find the FP style more clear. The source code below provides <span class="docEmphasis">sample</span> implementations of the functions in the <span class="docEmphasis"><TT>operator</TT></span> module. The actual implementations are faster and are written directly in <TT>C</TT>, but the samples illustrate what each function does.</P>
<H5 class="docExampleTitle"><A NAME="ch01list10"></A> operator2.py</H5>

<PRE>
### Comparison functions
It = __lt__ = lambda a,b: a &lt; b
le = __le__ = lambda a,b: a &lt;= b
eq = __eq__ = lambda a,b: a == b
ne = __ne__ = lambda a,b: a != b
ge = __ge__ = lambda a,b: a &gt;= b
gt = __gt__ = lambda a,b: a &gt; b
### Boolean functions
not_ = __not__ = lambda o: not o
truth = lambda o: not not o
# Arithmetic functions
abs = __abs__ = abs   # same as built-in function
add = __add__ = lambda a,b: a + b
and_ = __and__ = lambda a,b: a &amp; b  # bitwise, not boolean
div = __div__ = \
      lambda a,b: a/b  # depends on __future__.division
floordiv = __floordiv__ = lambda a,b: a/b # Only for 2.2+
inv = invert = __inv__ = __invert__ = lambda o: <SUP>~</SUP>o
lshift = __lshift__ = lambda a,b: a &lt;&lt; b
rshift = __rshift__ = lambda a,b: a &lt;&lt; b
mod = __mod__ = lambda a,b: a % b
mul = __mul__ = lambda a,b: a * b
neg = __neg__ = lambda o: -o
or_ = __or__ = lambda a,b: a | b    # bitwise, not boolean
pos = __pos__ = lambda o: +o # identity for numbers
sub = __sub__ = lambda a,b: a - b
truediv = __truediv__ = lambda a,b: 1.0*a/b # New in 2.2+
xor = __xor__ = lambda a,b: a ^ b
### Sequence functions (note overloaded syntactic operators)
concat = __concat__ = add
contains = __contains__ = lambda a,b: b in a
countOf = lambda seq,a: len([x for x in seq if x==a])
def delitem(seq,a): del seq[a]
__delitem__ = delitem
def delslice(seq,b,e): del seq[b:e]
__delslice__ = delslice
getitem = __getitem__ = lambda seq,i: seq[i]
getslice = __getslice__ = lambda seq,b,e: seq[b:e]
index0f = lambda seq,o: seq.index(o)
repeat = __repeat__ = mul
def setitem(seq,i,v): seq[i] = v
__setitem__ = setitem
def setslice(seq,b,e,v): seq[b:e] = v
__setslice__ = setslice
### Functionality functions (not implemented here)
# The precise interfaces required to pass the below tests
#     are ill-defined, and might vary at limit-cases between
#     Python versions and custom data types.
import operator
isCallable = callable     # just use built-in 'callable()'
isMappingType = operator.isMappingType
isNumberType = operator.isNumberType
isSequenceType = operator.isSequenceType
</PRE>
<P><A NAME="ch01sb18"></A><TABLE CELLSPACING="0" WIDTH="90%" BORDER="1"><TR><TD>
<P class="docText"><span class="docEmphStrong">sys </span>&#8226; <span class="docEmphStrong">Information about current Python interpreter</span></P></TD></TR></TABLE></P>
<P class="docText">As with the Python "userland" objects you create within your applications, the Python interpreter itself is very open to introspection. Using the <span class="docEmphasis"><TT>sys</TT></span> module, you can examine and modify many aspects of the Python runtime environment. However, as with much of the functionality in the <span class="docEmphasis"><TT>os</TT></span> module, some of what <span class="docEmphasis"><TT>sys</TT></span> provides is too esoteric to address in this book about text processing. Consult the <span class="docEmphasis">Python Library Reference</span> for information on those attributes and functions not covered here.</P>
<P class="docText">The module attributes <span class="docEmphasis"><TT>sys.exc_type</TT>, <TT>sys.exc_value</TT></span>, and <span class="docEmphasis"><TT>sys.exc_traceback</TT></span> have been deprecated in favor of the function <span class="docEmphasis"><TT>sys.exc_info()</TT></span>. All of these, and also <span class="docEmphasis"><TT>sys.last-type</TT>, <TT>sys.last-value</TT>, <TT>sys.last_traceback</TT></span>, and <span class="docEmphasis"><TT>sys.tracebacklimit</TT></span>, let you poke into exceptions and stack frames to a finer degree than the basic <span class="docEmphasis"><TT>try</TT></span> and <span class="docEmphasis"><TT>except</TT></span> statements do. <span class="docEmphasis"><TT>sys.exec_prefix</TT></span> and <span class="docEmphasis"><TT>sys.executable</TT></span> provide information on installed paths for Python.</P>
<P class="docText">The functions <span class="docEmphasis"><TT>sys.displayhook()</TT></span> and <span class="docEmphasis"><TT>sys.excepthook()</TT></span> control where program output goes, and <span class="docEmphasis"><TT>sys.__displayhook__</TT></span> and <span class="docEmphasis"><TT>sys.__excepthook__</TT></span> retain their original values (e.g., STDOUT and STDERR). <span class="docEmphasis"><TT>sys.exitfunc</TT></span> affects interpreter cleanup. The attributes <span class="docEmphasis"><TT>sys.ps1</TT></span> and <span class="docEmphasis"><TT>sys.ps2</TT></span> control prompts in the Python interactive shell.</P>
<P class="docText">Other attributes and methods simply provide more detail than you almost ever need to know for text processing applications. The attributes <span class="docEmphasis"><TT>sys.dllhandle</TT></span> and <span class="docEmphasis"><TT>sys.winver</TT></span> are Windows specific; <span class="docEmphasis"><TT>sys.setdlopenf lags ()</TT></span>, and <span class="docEmphasis"><TT>sys.getdlopenflags()</TT></span> are Unix only. Methods like <span class="docEmphasis"><TT>sys.builtin_module_names</TT>, <TT>sys._getframe()</TT>, <TT>sys.prefix</TT>, <TT>sys.getrecursionlimit()</TT>, <TT>sys.setprofile()</TT>, <TT>sys.settrace()</TT>, <TT>sys.setcheckinterval()</TT>, <TT>sys.setrecursionlimit()</TT>, <TT>sys.modules</TT></span>, and also <span class="docEmphasis"><TT>sys.warnoptions</TT></span> concern Python internals. Unicode behavior is affected by the <span class="docEmphasis"><TT>sys.setdefaultencoding()</TT></span> method, but is overridable with arguments anyway.</P>
<A NAME="ch01lev3sec21"></A><H5 class="docSection3Title"> ATTRIBUTES</H5>
<A NAME="ch01lev4sec86"></A><H5 class="docSection4Title"> sys.argv</H5>
<P class="docText">A list of command-line arguments passed to a Python script. The first item, <TT>argv[0]</TT>, is the script name itself, so you are normally interested in <TT>argv[1:]</TT> when parsing arguments.</P>
<p class="docText"><span class="docEmphRoman">S<span class="docEmphSmaller">EE</span> A<span class="docEmphSmaller">LSO</span></span>: 
getopt <span class="docEmphasis">44;</span> sys.stdin <span class="docEmphasis">51;</span> sys.stdout <span class="docEmphasis">51;</span></p>
<A NAME="ch01lev4sec87"></A><H5 class="docSection4Title"> sys.byteorder</H5>
<P class="docText">The native byte order (endianness) of the current platform. Possible values are <TT>big</TT> and <TT>little</TT>. Available in Python 2.0+.</P>
<A NAME="ch01lev4sec88"></A><H5 class="docSection4Title"> sys.copyright</H5>
<P class="docText">A string with copyright information for the current Python interpreter.</P>
<A NAME="ch01lev4sec89"></A><H5 class="docSection4Title"> sys.hexversion</H5>
<P class="docText">The version number of the current Python interpreter as an integer. This number increases with every version, even nonproduction releases. This attribute is not very human-readable; <span class="docEmphasis"><TT>sys.version</TT></span> or <span class="docEmphasis"><TT>sys.version_info</TT></span> is generally easier to work with.</P>
<p class="docText"><span class="docEmphRoman">S<span class="docEmphSmaller">EE</span> A<span class="docEmphSmaller">LSO</span></span>: 
sys.version <span class="docEmphasis">51;</span> sys.version_info <span class="docEmphasis">52;</span></p>
<A NAME="ch01lev4sec90"></A><H5 class="docSection4Title"> sys.maxint</H5>
<P class="docText">The largest positive integer supported by Python's regular integer type, on most platforms, 2**31-1. The largest negative integer is -sys.maxint-1.</P>
<A NAME="ch01lev4sec91"></A><H5 class="docSection4Title"> sys.maxunicode</H5>
<P class="docText">The integer of the largest supported code point for a Unicode character under the current configuration. Unicode characters are stored as UCS-2 or UCS-4.</P>
<A NAME="ch01lev4sec92"></A><H5 class="docSection4Title"> sys.path</H5>
<P class="docText">A list of the pathnames searched for modules. You may modify this path to control module loading.</P>
<A NAME="ch01lev4sec93"></A><H5 class="docSection4Title"> sys.platform</H5>
<P class="docText">A string identifying the OS platform.</P>
<p class="docText"><span class="docEmphRoman">S<span class="docEmphSmaller">EE</span> A<span class="docEmphSmaller">LSO</span></span>: 
os.uname() <span class="docEmphasis">81;</span></p>
<A NAME="ch01lev4sec94"></A><H5 class="docSection4Title"> sys.stderr<br>sys.__stderr__</H5>
<P class="docText">File object for standard error stream (STDERR). <span class="docEmphasis"><TT>sys.__stderr__</TT></span> retains the original value in case <span class="docEmphasis"><TT>sys.stderr</TT></span> is modified during program execution. Error messages and warnings from the Python interpreter are written to <span class="docEmphasis"><TT>sys.stderr</TT></span>. The most typical use of <span class="docEmphasis"><TT>sys.stderr</TT></span> is for application messages that indicate "abnormal" conditions. For example:</P>
<pre>
% cat cap_file.py
#!/usr/bin/env python
import sys, string
if len(sys.argv) &lt; 2:
    sys.stderr.write("No filename specified\n")
else:
    fname = sys.argv[1]
    try:
        input = open(fname).read()
        sys.stdout.write(string.upper(input))
    except:
        sys.stderr.write("Could not read '%s'\n" % fname)
% ./cap_file.py this &gt; CAPS
% ./cap_file.py nosuchfile &gt; CAPS
Could not read 'nosuchfile'
% ./cap_file.py &gt; CAPS
No filename specified
</pre>
<p class="docText"><span class="docEmphRoman">S<span class="docEmphSmaller">EE</span> A<span class="docEmphSmaller">LSO</span></span>: 
sys.argv <span class="docEmphasis">49;</span> sys.stdin <span class="docEmphasis">51;</span> sys.stdout <span class="docEmphasis">51;</span></p>
<A NAME="ch01lev4sec95"></A><H5 class="docSection4Title"> sys.stdin<br>sys.__stdin__</H5>
<P class="docText">File object for standard input stream (STDIN). <span class="docEmphasis"><TT>sys.__stdin__</TT></span> retains the original value in case <span class="docEmphasis"><TT>sys.stdin</TT></span> is modified during program execution. <span class="docEmphasis"><TT>input()</TT></span> and <span class="docEmphasis"><TT>raw-input()</TT></span> are read from <span class="docEmphasis"><TT>sys.stdin</TT></span>, but the most typical use of <span class="docEmphasis"><TT>sys.stdin</TT></span> is for piped and redirected streams on the command line. For example:</P>
<pre>
% cat cap_stdin.py
#!/usr/bin/env python
import sys, string
input = sys.stdin.read()
print string.upper(input)
% echo "this and that" | ./cap_stdin.py
THIS AND THAT
</pre>
<p class="docText"><span class="docEmphRoman">S<span class="docEmphSmaller">EE</span> A<span class="docEmphSmaller">LSO</span></span>: 
sys.argv <span class="docEmphasis">49;</span> sys.stderr <span class="docEmphasis">50;</span> sys.stdout <span class="docEmphasis">51;</span></p>
<A NAME="ch01lev4sec96"></A><H5 class="docSection4Title"> sys.stdout<br>sys.__stdout__</H5>
<P class="docText">File object for standard output stream (STDOUT). <span class="docEmphasis"><TT>sys.__stdout__</TT></span> retains the original value in case <span class="docEmphasis"><TT>sys.stdout</TT></span> is modified during program execution. The formatted output of the <span class="docEmphasis"><TT>print</TT></span> statement goes to <span class="docEmphasis"><TT>sys.stdout</TT></span>, and you may also use regular file methods, such as <span class="docEmphasis"><TT>sys.stdout.write()</TT></span>.</P>
<p class="docText"><span class="docEmphRoman">S<span class="docEmphSmaller">EE</span> A<span class="docEmphSmaller">LSO</span></span>: 
sys.argv <span class="docEmphasis">49;</span> sys.stderr <span class="docEmphasis">50;</span> sys.stdin <span class="docEmphasis">51;</span></p>
<A NAME="ch01lev4sec97"></A><H5 class="docSection4Title"> sys.version</H5>
<P class="docText">A string containing version information on the current Python interpreter. The form of the string is <TT>version (#build_num, build_date, build_time) [compiler]</TT>. For example:</P>
<pre>
&gt;&gt;&gt; print sys.version
1.5.2 (#0 Apr 13 1999, 10:51:12) [MSC 32 bit (Intel)]
</pre>
<P class="docText">Or:</P>
<pre>
&gt;&gt;&gt; print sys.version
2.2 (#1, Apr 17 2002, 16:11:12)
[GCC 2.95.2 19991024 (release)]
</pre>
<P class="docText">This version-independent way to find the major, minor, and micro version components should work for 1.5-2.3.x (at least):</P>
<pre>
&gt;&gt;&gt; from string import split
&gt;&gt;&gt; from sys import version
&gt;&gt;&gt; ver_tup = map(int, split(split(version)[0],'.'))+[0]
&gt;&gt;&gt; major, minor, point = ver_tup[:3]
&gt;&gt;&gt; if (major, minor) &gt;= (1, 6):
...     print "New Way"
... else:
...     print "Old Way"
...
New Way
</pre>
<A NAME="ch01lev4sec98"></A><H5 class="docSection4Title"> sys.version_info</H5>
<P class="docText">A 5-tuple containing five components of the version number of the current Python interpreter: <TT>(major, minor, micro, releaselevel, serial)</TT>. <TT>releaselevel</TT> is a descriptive phrase; the other are integers.</P>
<pre>
&gt;&gt;&gt; sys.version_info
(2, 2, 0, 'final', 0)
</pre>
<P class="docText">Unfortunately, this attribute was added to Python 2.0, so its items are not entirely useful in requiring a minimal version for some desired functionality.</P>
<p class="docText"><span class="docEmphRoman">S<span class="docEmphSmaller">EE</span> A<span class="docEmphSmaller">LSO</span></span>: 
sys.version <span class="docEmphasis">51;</span></p>
<A NAME="ch01lev3sec22"></A><H5 class="docSection3Title"> FUNCTIONS</H5>
<A NAME="ch01lev4sec99"></A><H5 class="docSection4Title"> sys.exit ([code=0])</H5>
<P class="docText">Exit Python with exit code <TT>code</TT>. Cleanup actions specified by <TT>finally</TT> clauses of <TT>try</TT> statements are honored, and it is possible to intercept the exit attempt by catching the SystemExit exception. You may specify a numeric exit code for those systems that codify them; you may also specify a string exit code, which is printed to STDERR (with the actual exit code set to 1).</P>
<A NAME="ch01lev4sec100"></A><H5 class="docSection4Title"> sys.getdefaultencoding()</H5>
<P class="docText">Return the name of the default Unicode string encoding in Python 2.0+.</P>
<A NAME="ch01lev4sec101"></A><H5 class="docSection4Title"> sys.getrefcount(obj)</H5>
<P class="docText">Return the number of references to the object <TT>obj</TT>. The value returned is one higher than you might expect, because it includes the (temporary) reference passed as the argument.</P>
<pre>
&gt;&gt;&gt; x = y = "hi there"
&gt;&gt;&gt; import sys
&gt;&gt;&gt; sys.getrefcount(x)
3
&gt;&gt;&gt; 1st = [x, x, x]
&gt;&gt;&gt; sys.getrefcount(x)
6
</pre>
<p class="docText"><span class="docEmphRoman">S<span class="docEmphSmaller">EE</span> A<span class="docEmphSmaller">LSO</span></span>: 
os <span class="docEmphasis">74</span>;</p>
<P><A NAME="ch01sb19"></A><TABLE CELLSPACING="0" WIDTH="90%" BORDER="1"><TR><TD>
<P class="docText"><span class="docEmphStrong">types </span>&#8226; <span class="docEmphStrong">Standard Python object types</span></P></TD></TR></TABLE></P>
<P class="docText">Every object in Python has a type; you can find it by using the built-in function <span class="docEmphasis"><TT>type()</TT></span>. Often Python functions use a sort of <span class="docEmphasis">ad hoc</span> overloading, which is implemented by checking features of objects passed as arguments. Programmers coming from languages like C or Java are sometimes surprised by this style, since they are accustomed to seeing multiple "type signatures" for each set of argument types the function can accept. But that is not the Python way.</P>
<P class="docText">Experienced Python programmers try not to rely on the precise types of objects, not even in an inheritance sense. This attitude is also sometimes surprising to programmers of other languages (especially statically typed). What is usually important to a Python program is what an object can <span class="docEmphasis">do</span>, not what it <span class="docEmphasis">is</span>. In fact, it has become much more complicated to describe what many objects <span class="docEmphasis">are</span> with the "type/class unification" in Python 2.2 and above (the details are outside the scope of this book).</P>
<P class="docText">For example, you might be inclined to write an overloaded function in the following manner:</P>
<H5 class="docExampleTitle"><A NAME="ch01list11"></A> Naive overloading of argument</H5>

<PRE>
import types, exceptions
def overloaded_get_text(o):
    if type(o) is types.FileType:
        text = o.read()
    elif type(o) is types.StringType:
        text = o
    elif type(o) in (types.IntType, types.FloatType,
                     types.LongType, types.ComplexType):
        text = repr(o)
    else:
        raise exceptions.TypeError
    return text
</PRE>
<P class="docText">The problem with this rigidly typed code is that it is far more fragile than is necessary. Something need not be an actual <TT>FileType</TT> to read its text, it just needs to be sufficiently "file-like" (e.g., a <span class="docEmphasis"><TT>urllib.urlopen()</TT></span> or <span class="docEmphasis"><TT>cStringIO.StringIO()</TT></span> object is file-like enough for this purpose). Similarly, a new-style object that descends from <span class="docEmphasis"><TT>types.StringType</TT></span> or a <span class="docEmphasis"><TT>UserString.UserString()</TT></span> object is "string-like" enough to return as such, and similarly for other numeric types.</P>
<P class="docText">A better implementation of the function above is:</P>
<H5 class="docExampleTitle"><A NAME="ch01list12"></A> "Quacks like a duck" overloading of argument</H5>

<PRE>
def overloaded_get_text(o):
    if hasattr(o,'read'):
        return o.read()
    try:
        return ""+o
    except TypeError:
        pass
    try:
        return repr(0+o)
    except TypeError:
        pass
    raise
</PRE>
<P class="docText">At times, nonetheless, it is useful to have symbolic names available to name specific object types. In many such cases, an empty or minimal version of the type of object may be used in conjunction with the <span class="docEmphasis"><TT>type()</TT></span> function equally well—the choice is mostly stylistic:</P>
<pre>
&gt;&gt;&gt; type('') == types.StringType
1
&gt;&gt;&gt; type(0.0) == types.FloatType
1
&gt;&gt;&gt; type(None) == types.NoneType
1
&gt;&gt;&gt; type([]) == types.ListType
1
</pre>
<A NAME="ch01lev3sec23"></A><H5 class="docSection3Title"> BUILT-IN</H5>
<A NAME="ch01lev4sec102"></A><H5 class="docSection4Title"> type(o)</H5>
<P class="docText">Return the datatype of any object <TT>o</TT>. The return value of this function is itself an object of the type <span class="docEmphasis"><TT>types.TypeType</TT></span>. TypeType objects implement .<TT>__str__()</TT> and <TT>.__repr__()</TT> methods to create readable descriptions of object types.</P>
<pre>
&gt;&gt;&gt; print type(1)
&lt;type 'int'&gt;
&gt;&gt;&gt; print type(type(1))
&lt;type 'type'&gt;
&gt;&gt;&gt; type(1) is type(0)
1
</pre>
<A NAME="ch01lev3sec24"></A><H5 class="docSection3Title"> CONSTANTS</H5>
<A NAME="ch01lev4sec103"></A><H5 class="docSection4Title"> types.BuiltinFunctionType<br>types.BuiltinMethodType</H5>
<P class="docText">The type for built-in functions like <span class="docEmphasis"><TT>abs()</TT>, <TT>len()</TT></span>, and <span class="docEmphasis"><TT>dir()</TT></span>, and for functions in "standard" C extensions like <span class="docEmphasis"><TT>sys</TT></span> and <span class="docEmphasis"><TT>os</TT></span>. However, extensions like <span class="docEmphasis"><TT>string</TT></span> and <span class="docEmphasis"><TT>re</TT></span> are actually Python wrappers for C extensions, so their functions are of type <span class="docEmphasis"><TT>types.FuntionType</TT></span>. A general Python programmer need not worry about these fussy details.</P>
<A NAME="ch01lev4sec104"></A><H5 class="docSection4Title"> types.BufferType</H5>
<P class="docText">The type for objects created by the built-in buffer() function.</P>
<A NAME="ch01lev4sec105"></A><H5 class="docSection4Title"> types.Class Type</H5>
<P class="docText">The type for user-defined classes.</P>
<pre>
&gt;&gt;&gt; from operator import eq
&gt;&gt;&gt; from types import *
&gt;&gt;&gt; map(eq, [type(C), type(C()), type(C().foo)],
...         [ClassType, InstanceType, MethodType])
[1, 1, 1]
</pre>
<p class="docText"><span class="docEmphRoman">S<span class="docEmphSmaller">EE</span> A<span class="docEmphSmaller">LSO</span></span>: 
types.InstanceType <span class="docEmphasis">56</span>; types.MethodType <span class="docEmphasis">56</span>;</p>
<A NAME="ch01lev4sec106"></A><H5 class="docSection4Title"> types.CodeType</H5>
<P class="docText">The type for code objects such as returned by <TT>compile()</TT>.</P>
<A NAME="ch01lev4sec107"></A><H5 class="docSection4Title"> types.ComplexType</H5>
<P class="docText">Same as <TT>type(0+0j)</TT>.</P>
<A NAME="ch01lev4sec108"></A><H5 class="docSection4Title"> types.DictType<br>types.DictionaryType</H5>
<P class="docText">Same as <TT>type({})</TT>.</P>
<A NAME="ch01lev4sec109"></A><H5 class="docSection4Title"> types.EllipsisType</H5>
<P class="docText">The type for built-in Ellipsis object.</P>
<A NAME="ch01lev4sec110"></A><H5 class="docSection4Title"> types.FileType</H5>
<P class="docText">The type for open file objects.</P>
<pre>
&gt;&gt;&gt; from sys import stdout
&gt;&gt;&gt; fp = open('tst','w')
&gt;&gt;&gt; [type(stdout), type(fp)] == [types.FileType]*2
1
</pre>
<A NAME="ch01lev4sec111"></A><H5 class="docSection4Title"> types.FloatType</H5>
<P class="docText">Same as <TT>type (0.0)</TT>.</P>
<A NAME="ch01lev4sec112"></A><H5 class="docSection4Title"> types.FrameType</H5>
<P class="docText">The type for frame objects such as <TT>tb.tb_frame</TT> in which <TT>tb</TT> has the type <span class="docEmphasis"><TT>types.TracebackType</TT></span>.</P>
<A NAME="ch01lev4sec113"></A><H5 class="docSection4Title"> types.FunctionType<br>types.LambdaType</H5>
<P class="docText">Same as <TT>type(lambda:0)</TT>.</P>
<A NAME="ch01lev4sec114"></A><H5 class="docSection4Title"> types.GeneratorType</H5>
<P class="docText">The type for generator-iterator objects in Python 2.2+.</P>
<pre>
&gt;&gt;&gt; from __future__ import generators
&gt;&gt;&gt; def foo(): yield 0
...
&gt;&gt;&gt; type(foo) == types.FunctionType
1
&gt;&gt;&gt; type(foo()) == types.GeneratorType
1
</pre>
<p class="docText"><span class="docEmphRoman">S<span class="docEmphSmaller">EE</span> A<span class="docEmphSmaller">LSO</span></span>: 
types.FunctionType <span class="docEmphasis">56;</span></p>
<A NAME="ch01lev4sec115"></A><H5 class="docSection4Title"> types.InstanceType</H5>
<P class="docText">The type for instances of user-defined classes.</P>
<p class="docText"><span class="docEmphRoman">S<span class="docEmphSmaller">EE</span> A<span class="docEmphSmaller">LSO</span></span>: 
types.ClassType <span class="docEmphasis">55;</span> types.MethodType <span class="docEmphasis">56;</span></p>
<A NAME="ch01lev4sec116"></A><H5 class="docSection4Title"> types.IntType</H5>
<P class="docText">Same as <TT>type(0)</TT>.</P>
<A NAME="ch01lev4sec117"></A><H5 class="docSection4Title"> types.ListType</H5>
<P class="docText">Same as <TT>type()</TT>.</P>
<A NAME="ch01lev4sec118"></A><H5 class="docSection4Title"> types.LongType</H5>
<P class="docText">Same as <TT>type(OL)</TT>.</P>
<A NAME="ch01lev4sec119"></A><H5 class="docSection4Title"> types.MethodType<br>types.Unbound MethodType</H5>
<P class="docText">The type for methods of user-defined class instances.</P>
<p class="docText"><span class="docEmphRoman">S<span class="docEmphSmaller">EE</span> A<span class="docEmphSmaller">LSO</span></span>: 
types.ClassType <span class="docEmphasis">55</span>; types.InstanceType <span class="docEmphasis">56;</span></p>
<A NAME="ch01lev4sec120"></A><H5 class="docSection4Title"> types.ModuleType</H5>
<P class="docText">The type for modules.</P>
<pre>
&gt;&gt;&gt; import os, re, sys
&gt;&gt;&gt; [type(os), type(re), type(sys)] == [types.ModuleType]*3
1
</pre>
<A NAME="ch01lev4sec121"></A><H5 class="docSection4Title"> types.NoneType</H5>
<P class="docText">Same as <TT>type(None)</TT>.</P>
<A NAME="ch01lev4sec122"></A><H5 class="docSection4Title"> types.StringType</H5>
<P class="docText">Same as <TT>type("")</TT>.</P>
<A NAME="ch01lev4sec123"></A><H5 class="docSection4Title"> types.TracebackType</H5>
<P class="docText">The type for traceback objects found in <span class="docEmphasis"><TT>sys.exc_traceback</TT></span>.</P>
<A NAME="ch01lev4sec124"></A><H5 class="docSection4Title"> types.TupleType</H5>
<P class="docText">Same as <TT>type(())</TT>.</P>
<A NAME="ch01lev4sec125"></A><H5 class="docSection4Title"> types.UnicodeType</H5>
<P class="docText">Same as <TT>type(u"")</TT>.</P>
<A NAME="ch01lev4sec126"></A><H5 class="docSection4Title"> types.SliceType</H5>
<P class="docText">The type for objects returned by <TT>slice()</TT>.</P>
<A NAME="ch01lev4sec127"></A><H5 class="docSection4Title"> types.StringTypes</H5>
<P class="docText">Same as <TT>(types.StringType,types.UnicodeType)</TT>.</P>
<p class="docText"><span class="docEmphRoman">S<span class="docEmphSmaller">EE</span> A<span class="docEmphSmaller">LSO</span></span>: 
types.StringType <span class="docEmphasis">57</span>; types.UnicodeType <span class="docEmphasis">57</span>;</p>
<A NAME="ch01lev4sec128"></A><H5 class="docSection4Title"> types.TypeType</H5>
<P class="docText">Same as <TT>type (type (obj))</TT> (for any <TT>obj</TT>).</P>
<A NAME="ch01lev4sec129"></A><H5 class="docSection4Title"> types.XRangeType</H5>
<P class="docText">Same as <TT>type(xrange(1))</TT>.</P>
<A NAME="ch01lev2sec8"></A><H4 class="docSection2Title">1.2.2 Working with the Local Filesystem</H4>
<P><A NAME="ch01sb20"></A><TABLE CELLSPACING="0" WIDTH="90%" BORDER="1"><TR><TD>
<P class="docText"><span class="docEmphStrong">dircache</span> &#8226; <span class="docEmphStrong">Read and cache directory listings</span></P></TD></TR></TABLE></P>
<P class="docText">The <span class="docEmphasis"><TT>dircache</TT></span> module is an enhanced version of the <span class="docEmphasis"><TT>os.listdir()</TT></span> function. Unlike the os function, <span class="docEmphasis"><TT>dircache</TT></span> keeps prior directory listings in memory to avoid the need for a new call to the filesystem. Since <span class="docEmphasis"><TT>dircache</TT></span> is smart enough to check whether a directory has been touched since last caching, <span class="docEmphasis"><TT>dircache</TT></span> is a complete replacement for <span class="docEmphasis"><TT>os.listdir()</TT></span> (with possible minor speed gains).</P>
<A NAME="ch01lev3sec25"></A><H5 class="docSection3Title"> FUNCTIONS</H5>
<A NAME="ch01lev4sec130"></A><H5 class="docSection4Title"> dircache.listdir(path)</H5>
<P class="docText">Return a directory listing of path path. Uses a list cached in memory where possible.</P>
<A NAME="ch01lev4sec131"></A><H5 class="docSection4Title"> dircache.opendir(path)</H5>
<P class="docText">Identical to <span class="docEmphasis"><TT>dircache.listdir()</TT></span>. Legacy function to support old scripts.</P>
<A NAME="ch01lev4sec132"></A><H5 class="docSection4Title"> dircache.annotate(path, lst)</H5>
<P class="docText">Modify the list <TT>lst</TT> in place to indicate which items are directories, and which are plain files. The string <TT>path</TT> should indicate the path to reach the listed files.</P>
<pre>
&gt;&gt;&gt; l = dircache.listdir('/tmp')
&gt;&gt;&gt; l
['501', 'md10834.db']
&gt;&gt;&gt; dircache.annotate('/tmp', l)
&gt;&gt;&gt; l
['501/', 'md10834.db']
</pre>
<P><A NAME="ch01sb21"></A><TABLE CELLSPACING="0" WIDTH="90%" BORDER="1"><TR><TD>
<P class="docText"><span class="docEmphStrong">filecmp </span>&#8226; <span class="docEmphStrong">Compare files and directories</span></P></TD></TR></TABLE></P>
<P class="docText">The <span class="docEmphasis"><TT>filecmp</TT></span> module lets you check whether two files are identical, and whether two directories contain some identical files. You have several options in determining how thorough of a comparison is performed.</P>
<A NAME="ch01lev3sec26"></A><H5 class="docSection3Title"> FUNCTIONS</H5>
<A NAME="ch01lev4sec133"></A><H5 class="docSection4Title"> filecmp.cmp(fname1, fname2 [,shallow=1 [,use_statcache=0]])</H5>
<P class="docText">Compare the file named by the string <TT>fname1</TT> with the file named by the string <TT>fname2</TT>. If the default true value of <TT>shallow</TT> is used, the comparison is based only on the mode, size, and modification time of the two files. If <TT>shallow</TT> is a false value, the files are compared byte by byte. Unless you are concerned that someone will deliberately falsify timestamps on files (as in a cryptography context), a shallow comparison is quite reliable. However, <TT>tar</TT> and <TT>untar</TT> can also change timestamps.</P>
<pre>
&gt;&gt;&gt; import filecmp
&gt;&gt;&gt; filecmp.cmp('dir1/file1', 'dir2/file1')
0
&gt;&gt;&gt; filecmp.cmp('dir1/file2', 'dir2/file2', shallow=0)
1
</pre>
<P class="docText">The <TT>use_statcache</TT> argument is not relevant for Python 2.2+. In older Python versions, the <span class="docEmphasis"><TT>statcache</TT></span> module provided (slightly) more efficient cached access to file stats, but its use is no longer needed.</P>
<A NAME="ch01lev4sec134"></A><H5 class="docSection4Title"> filecmp.cmpfiles(dirname1, dirname2, fnamelist [,shallow=1 [,use_statcache=0]])</H5>
<P class="docText">Compare those filenames listed in <TT>fnamelist</TT> if they occur in both the directory <TT>dirname1</TT> and the directory <TT>dirname2</TT>. <span class="docEmphasis"><TT>filecmp.cmpfiles()</TT></span> returns a tuple of three lists (some of the lists may be empty): <TT>(matches, mismatches, errors)</TT>. <TT>matches</TT> are identical files in both directories, <TT>mismatches</TT> are nonidentical files in both directories. <TT>errors</TT> will contain names if a file exists in neither, or in only one, of the two directories, or if either file cannot be read for any reason (permissions, disk problems, etc.).</P>
<pre>
&gt;&gt;&gt; import filecmp, os
&gt;&gt;&gt; filecmp.cmpfiles('dirl','dir2',['this','that','other'])
(['this'], ['that'], ['other'])
&gt;&gt;&gt; print os.popen('ls -l dir1').read()
-rwxr-xr-x    1 quilty   staff     169 Sep 27 00:13 this
-rwxr-xr-x    1 quilty   staff     687 Sep 27 00:13 that
-rwxr-xr-x    1 quilty   staff     737 Sep 27 00:16 other
-rwxr-xr-x    1 quilty   staff     518 Sep 12 11:57 spam
&gt;&gt;&gt; print os.popen('ls -l dir2').read()
-rwxr-xr-x    1 quilty   staff     169 Sep 27 00:13 this
-rwxr-xr-x    1 quilty   staff     692 Sep 27 00:32 that
</pre>
<P class="docText">The <TT>shallow</TT> and <TT>use_statcache</TT> arguments are the same as those to <span class="docEmphasis"><TT>filecmp.cmp()</TT></span>.</P>
<A NAME="ch01lev3sec27"></A><H5 class="docSection3Title"> CLASSES</H5>
<A NAME="ch01lev4sec135"></A><H5 class="docSection4Title"> filecmp.dircmp(dirname1, dirname2 [,ignore=...[,hide=...])</H5>
<P class="docText">Create a directory comparison object. <TT>dirname1</TT> and <TT>dirname2</TT> are two directories to compare. The optional argument <TT>ignore</TT> is a sequence of pathnames to ignore and defaults to <TT>["RCS","CVS","tags"]</TT>; <TT>hide</TT> is a sequence of pathnames to hide and defaults to <TT>[os.curdir,os.pardir]</TT> (i.e., <TT>[".",".."]</TT>).</P>
<A NAME="ch01lev3sec28"></A><H5 class="docSection3Title"> METHODS AND ATTRIBUTES</H5>
<P class="docText">The attributes of <span class="docEmphasis"><TT>filecmp.dircmp</TT></span> are read-only. Do not attempt to modify them.</P>
<A NAME="ch01lev4sec136"></A><H5 class="docSection4Title"> filecmp.dircmp.report()</H5>
<P class="docText">Print a comparison report on the two directories.</P>
<pre>
&gt;&gt;&gt; mycmp = filecmp.dircmp('dir1','dir2')
&gt;&gt;&gt; mycmp.report()
diff dir1 dir2
Only in dir1 : ['other', 'spam']
Identical files : ['this']
Differing files : ['that']
</pre>
<A NAME="ch01lev4sec137"></A><H5 class="docSection4Title"> filecmp.dircmp.report_partial_closure()</H5>
<P class="docText">Print a comparison report on the two directories, including immediate subdirectories. The method name has nothing to do with the theoretical term "closure" from functional programming.</P>
<A NAME="ch01lev4sec138"></A><H5 class="docSection4Title"> filecmp.dircmp.report_partial_closure()</H5>
<P class="docText">Print a comparison report on the two directories, recursively including all nested subdirectories.</P>
<A NAME="ch01lev4sec139"></A><H5 class="docSection4Title"> filecmp.dircmp.left_list</H5>
<P class="docText">Pathnames in the <TT>dirname1</TT> directory, filtering out the <TT>hide</TT> and <TT>ignore</TT> lists.</P>
<A NAME="ch01lev4sec140"></A><H5 class="docSection4Title"> filecmp.dircmp.right_list</H5>
<P class="docText">Pathnames in the <TT>dirname2</TT> directory, filtering out the <TT>hide</TT> and <TT>ignore</TT> lists.</P>
<A NAME="ch01lev4sec141"></A><H5 class="docSection4Title"> filecmp.dircmp.common</H5>
<P class="docText">Pathnames in both directories.</P>
<A NAME="ch01lev4sec142"></A><H5 class="docSection4Title"> filecmp.dircmp.left_only</H5>
<P class="docText">Pathnames in <TT>dirname 1</TT> but not <TT>dirname2</TT>.</P>
<A NAME="ch01lev4sec143"></A><H5 class="docSection4Title"> filecmp.dircmp.right_only</H5>
<P class="docText">Pathnames in <TT>dirname2</TT> but not <TT>dirname1</TT>.</P>
<A NAME="ch01lev4sec144"></A><H5 class="docSection4Title"> filecmp.dircmp.common_dirs</H5>
<P class="docText">Subdirectories in both directories.</P>
<A NAME="ch01lev4sec145"></A><H5 class="docSection4Title"> filecmp.dircmp.common_files</H5>
<P class="docText">Filenames in both directories.</P>
<A NAME="ch01lev4sec146"></A><H5 class="docSection4Title"> filecmp.dircmp.common_funny</H5>
<P class="docText">Pathnames in both directories, but of different types.</P>
<A NAME="ch01lev4sec147"></A><H5 class="docSection4Title"> filecmp.dircmp.same_files</H5>
<P class="docText">Filenames of identical files in both directories.</P>
<A NAME="ch01lev4sec148"></A><H5 class="docSection4Title"> filecmp.dircmp.diff_files</H5>
<P class="docText">Filenames of nonidentical files whose name occurs in both directories.</P>
<A NAME="ch01lev4sec149"></A><H5 class="docSection4Title"> filecmp.dircmp.funny_files</H5>
<P class="docText">Filenames in both directories where something goes wrong during comparison.</P>
<A NAME="ch01lev4sec150"></A><H5 class="docSection4Title"> filecmp.dircmp.subdirs</H5>
<P class="docText">A dictionary mapping <span class="docEmphasis"><TT>filecmp.dircmp.common_dirs</TT></span> strings to corresponding <span class="docEmphasis"><TT>filecmp.dircmp</TT></span> objects; for example:</P>
<pre>
&gt;&gt;&gt; usercmp = filecmp.dircmp('/Users/quilty','/Users/dqm')
&gt;&gt;&gt; usercmp.subdirs['Public'].common
['Drop Box']
</pre>
<p class="docText"><span class="docEmphRoman">S<span class="docEmphSmaller">EE</span> A<span class="docEmphSmaller">LSO</span></span>: 
os.stat() <span class="docEmphasis">79;</span> os.listdir() <span class="docEmphasis">76;</span></p>
<P><A NAME="ch01sb22"></A><TABLE CELLSPACING="0" WIDTH="90%" BORDER="1"><TR><TD>
<P class="docText"><span class="docEmphStrong">flleinput &#8226; Read multiple files or </span><span class="docEmphStrong">STDIN</span></P></TD></TR></TABLE></P>
<P class="docText">Many utilities, especially on Unix-like systems, operate line-by-line on one or more files and/or on redirected input. A flexibility in treating input sources in a homogeneous fashion is part of the "Unix philosophy." The <span class="docEmphasis"><TT>fileinput</TT></span> module allows you to write a Python application that uses these common conventions with almost no special programming to adjust to input sources.</P>
<P class="docText">A common, minimal, but extremely useful Unix utility is <TT>cat</TT>, which simply writes its input to STDOUT (allowing redirection of STDOUT as needed). Below are a few simple examples of <TT>cat</TT>:</P>
<pre>
% cat a
AAAAA
% cat a b
AAAAA
BBBBB
% cat - b &lt; a
AAAAA
BBBBB
% cat &lt; b
BBBBB
% cat a &lt; b
AAAAA
% echo "XXX" | cat a -
AAAAA
XXX
</pre>
<P class="docText">Notice that STDIN is read only if either "-" is given as an argument, or no arguments are given at all. We can implement a Python version of <TT>cat</TT> using the <span class="docEmphasis"><TT>fileinput</TT></span> module as follows:</P>
<H5 class="docExampleTitle"><A NAME="ch01list13"></A> cat.py</H5>

<PRE>
#!/usr/bin/env python
import fileinput
for line in fileinput.input():
        print line,
</PRE>
<A NAME="ch01lev3sec29"></A><H5 class="docSection3Title"> FUNCTIONS</H5>
<A NAME="ch01lev4sec151"></A><H5 class="docSection4Title"> fileinput.input([files=sys.argv[1:] [,inplace=0 [,backup=".bak"]]])</H5>
<P class="docText">Most commonly, this function will be used without any of its optional arguments, as in the introductory example of <TT>cat.py</TT>. However, behavior may be customized for special cases.</P>
<P class="docText">The argument <TT>files</TT> is a sequence of filenames to process. By default, it consists of all the arguments given on the command line. Commonly, however, you might want to treat some of these arguments as flags rather than filenames (e.g., if they start with <TT>-</TT> or <TT>/</TT>). Any list of filenames you like may be used as the <TT>files</TT> argument, whether or not it is built from <TT>sys.argv</TT>.</P>
<P class="docText">If you specify a true value for <TT>inplace</TT>, output will go into each file specified rather than to STDOUT. Input taken from STDIN, however, will still go to STDOUT. For in-place operation, a temporary backup file is created as the actual input source and is given the extension indicated by the <TT>backup</TT> argument. For example:</P>
<pre>
% cat a b
AAAAA
BBBBB
% cat modify.py
#!/usr/bin/env python
import fileinput, sys
for line in fileinput.input(sys.argv[1:], inplace=1):
        print "MODIFIED", line,
% echo "XXX" | ./modify.py a b -
MODIFIED XXX
% cat a b
MODIFIED AAAAA
MODIFIED BBBBB
</pre>
<A NAME="ch01lev4sec152"></A><H5 class="docSection4Title"> fileinput.close()</H5>
<P class="docText">Close the input sequence.</P>
<A NAME="ch01lev4sec153"></A><H5 class="docSection4Title"> fileinput.nextfile()</H5>
<P class="docText">Close the current file, and proceed to the next one. Any unread lines in the current file will not be counted towards the line total.</P>
<P class="docText">There are several functions in the <span class="docEmphasis"><TT>fileinput</TT></span> module that provide information about the current input state. These tests can be used to process the current line in a context-dependent way.</P>
<A NAME="ch01lev4sec154"></A><H5 class="docSection4Title"> fileinput.filelineno()</H5>
<P class="docText">The number of lines read from the current file.</P>
<A NAME="ch01lev4sec155"></A><H5 class="docSection4Title"> fileinput.filename()</H5>
<P class="docText">The name of the file from which the last line was read. Before a line is read, the function returns <TT>None</TT>.</P>
<A NAME="ch01lev4sec156"></A><H5 class="docSection4Title"> fileinput.isfirstline()</H5>
<P class="docText">Same as <TT>fileinput.filelineno()==1</TT>.</P>
<A NAME="ch01lev4sec157"></A><H5 class="docSection4Title"> fileinput.isstdin()</H5>
<P class="docText">True if the last line read was from STDIN.</P>
<A NAME="ch01lev4sec158"></A><H5 class="docSection4Title"> fileinput.lineno()</H5>
<P class="docText">The number of lines read during the input loop, cumulative between files.</P>
<A NAME="ch01lev3sec30"></A><H5 class="docSection3Title"> CLASSES</H5>
<A NAME="ch01lev4sec159"></A><H5 class="docSection4Title"> fileinput.Filelnput([files [,inplace=0 [,backup=".bak"]]])</H5>
<P class="docText">The methods of <span class="docEmphasis"><TT>fileinput.FileInput</TT></span> are the same as the module-level functions, plus an additional .<TT>readline()</TT> method that matches that of file objects. <span class="docEmphasis"><TT>fileinput.FileInput</TT></span> objects also have a .<TT>__getitem__()</TT> method to support sequential access.</P>
<P class="docText">The arguments to initialize a <span class="docEmphasis"><TT>fileinput.FileInput</TT></span> object are the same as those passed to the <span class="docEmphasis"><TT>fileinput.input ()</TT></span> function. The class exists primarily in order to allow subclassing. For normal usage, it is best to just use the <span class="docEmphasis"><TT>fileinput</TT></span> functions.</P>
<p class="docText"><span class="docEmphRoman">S<span class="docEmphSmaller">EE</span> A<span class="docEmphSmaller">LSO</span></span>: 
multifile <span class="docEmphasis">285;</span> xreadlines <span class="docEmphasis">72;</span></p>
<P><A NAME="ch01sb23"></A><TABLE CELLSPACING="0" WIDTH="90%" BORDER="1"><TR><TD>
<P class="docText"><span class="docEmphStrong">glob </span>&#8226; <span class="docEmphStrong">Filename globing utility</span></P></TD></TR></TABLE></P>
<P class="docText">The <span class="docEmphasis"><TT>glob</TT></span> module provides a list of pathnames matching a glob-style pattern. The <span class="docEmphasis"><TT>fnmatch</TT></span> module is used internally to determine whether a path matches.</P>
<A NAME="ch01lev3sec31"></A><H5 class="docSection3Title"> FUNCTIONS</H5>
<A NAME="ch01lev4sec160"></A><H5 class="docSection4Title"> glob.glob(pat)</H5>
<P class="docText">Both directories and plain files are returned, so if you are only interested in one type of path, use <span class="docEmphasis"><TT>os.path.isdir()</TT></span> or <span class="docEmphasis"><TT>os.path.isfile()</TT></span><TT>;</TT> other functions in <span class="docEmphasis"><TT>os.path</TT></span> also support other filters.</P>
<P class="docText">Pathnames returned by <span class="docEmphasis"><TT>glob.glob()</TT></span> contain as much absolute or relative path information as the pattern <TT>pat</TT> gives. For example:</P>
<pre>
&gt;&gt;&gt; import glob, os.path
&gt;&gt;&gt; glob.glob('/Users/quilty/Book/chap[3-4].txt')
['/Users/quilty/Book/chap3.txt', '/Users/quilty/Book/chap4.txt']
&gt;&gt;&gt; glob.glob('chap[3-6].txt')
['chap3.txt', 'chap4.txt', 'chap5.txt', 'chap6.txt']
&gt;&gt;&gt; filter(os.path.isdir, glob.glob('/Users/quilty/Book/[A-Z]*'))
['/Users/quilty/Book/SCRIPTS', '/Users/quilty/Book/XML']
</pre>
<p class="docText"><span class="docEmphRoman">S<span class="docEmphSmaller">EE</span> A<span class="docEmphSmaller">LSO</span></span>: 
fnmatch <span class="docEmphasis">232;</span> os.path <span class="docEmphasis">65;</span></p>
<P><A NAME="ch01sb24"></A><TABLE CELLSPACING="0" WIDTH="90%" BORDER="1"><TR><TD>
<P class="docText"><span class="docEmphStrong">linecache </span>&#8226; <span class="docEmphStrong">Cache lines from files</span></P></TD></TR></TABLE></P>
<P class="docText">The module <span class="docEmphasis"><TT>linecache</TT></span> can be used to simulate relatively efficient random access to the lines in a file. Lines that are read are cached for later access.</P>
<A NAME="ch01lev3sec32"></A><H5 class="docSection3Title"> FUNCTIONS</H5>
<A NAME="ch01lev4sec161"></A><H5 class="docSection4Title"> linecache.getline(fname, linenum)</H5>
<P class="docText">Read line <TT>linenum</TT> from the file named <TT>fname</TT>. If an error occurs reading the line, the function will catch the error and return an empty string. <TT>sys.path</TT> is also searched for the filename if it is not found in the current directory.</P>
<pre>
&gt;&gt;&gt; import linecache
&gt;&gt;&gt; linecache.getline('/etc/hosts', 15)
'192.168.1.108   hermes  hermes.gnosis.lan\n'
</pre>
<A NAME="ch01lev4sec162"></A><H5 class="docSection4Title"> linecache.clearcache()</H5>
<P class="docText">Clear the cache of read lines.</P>
<A NAME="ch01lev4sec163"></A><H5 class="docSection4Title"> linecache.checkcache()</H5>
<P class="docText">Check whether files in the cache have been modified since they were cached.</P>
<P><A NAME="ch01sb25"></A><TABLE CELLSPACING="0" WIDTH="90%" BORDER="1"><TR><TD>
<P class="docText"><span class="docEmphStrong">os.path </span>&#8226; <span class="docEmphStrong">Common pathname manipulations</span></P></TD></TR></TABLE></P>
<P class="docText">The <span class="docEmphasis"><TT>os.path</TT></span> module provides a variety of functions to analyze and manipulate filesystem paths in a cross-platform fashion.</P>
<A NAME="ch01lev3sec33"></A><H5 class="docSection3Title"> FUNCTIONS</H5>
<A NAME="ch01lev4sec164"></A><H5 class="docSection4Title"> os.path.abspath(pathname)</H5>
<P class="docText">Return an absolute path for a (relative) pathname.</P>
<pre>
&gt;&gt;&gt; os.path.abspath('SCRIPTS/mk_book')
'/Users/quilty/Book/SCRIPTS/mk_book'
</pre>
<A NAME="ch01lev4sec165"></A><H5 class="docSection4Title"> os.path.basename(pathname)</H5>
<P class="docText">Same as <TT>os.path.split(pathname)[1]</TT>.</P>
<A NAME="ch01lev4sec166"></A><H5 class="docSection4Title"> os .path.commonprefix(pathlist)</H5>
<P class="docText">Return the path to the most nested parent directory shared by all elements of the sequence <TT>pathlist</TT>.</P>
<pre>
&gt;&gt;&gt; os.path.commonprefix(['/usr/X11R6/bin/twm',
...                       '/usr/sbin/bash',
...                       '/usr/local/bin/dada'])
'/usr/'
</pre>
<A NAME="ch01lev4sec167"></A><H5 class="docSection4Title"> os.path.dirname(pathname)</H5>
<P class="docText">Same as <TT>os.path.split(pathname)[0]</TT>.</P>
<A NAME="ch01lev4sec168"></A><H5 class="docSection4Title"> os.path.exists(pathname)</H5>
<P class="docText">Return true if the pathname <TT>pathname</TT> exists.</P>
<A NAME="ch01lev4sec169"></A><H5 class="docSection4Title"> os.path.expanduser(pathname)</H5>
<P class="docText">Expand pathnames that include the tilde character: <TT>~</TT>. Under standard Unix shells, an initial tilde refers to a user's home directory, and a tilde followed by a name refers to the named user's home directory. This function emulates that behavior on other platforms.</P>
<pre>
&gt;&gt;&gt; os.path.expanduser('~dqm')
'/Users/dqm'
&gt;&gt;&gt; os.path.expanduser('~/Book')
'/Users/quilty/Book'
</pre>
<A NAME="ch01lev4sec170"></A><H5 class="docSection4Title"> os.path.expandvars(pathname)</H5>
<P class="docText">Expand <TT>pathname</TT> by replacing environment variables in a Unix shell style. While this function is in the <span class="docEmphasis"><TT>os.path</TT></span> module, you could equally use it for bash-like scripting in Python, generally (this is not necessarily a good idea, but it is possible).</P>
<pre>
&gt;&gt;&gt; os.path.expandvars('$HOME/Book')
'/Users/quilty/Book'
&gt;&gt;&gt; from os.path import expandvars as ev  # Python 2.0+
&gt;&gt;&gt; if ev('$HOSTTYPE')=='macintosh' and ev('$OSTYPE')=='darwin':
...     print ev("The vendor is $VENDOR, the CPU is $MACHTYPE")
...
The vendor is apple, the CPU is powerpc
</pre>
<A NAME="ch01lev4sec171"></A><H5 class="docSection4Title"> os.path.getatime(pathname)</H5>
<P class="docText">Return the last access time of <TT>pathname</TT> (or raise <TT>os.error</TT> if checking is not possible).</P>
<A NAME="ch01lev4sec172"></A><H5 class="docSection4Title"> os.path.getmtime(pathname)</H5>
<P class="docText">Return the modification time of <TT>pathname</TT> (or raise <TT>os.error</TT> if checking is not possible).</P>
<A NAME="ch01lev4sec173"></A><H5 class="docSection4Title"> os.path.getsize(pathname)</H5>
<P class="docText">Return the size of <TT>pathname</TT> in bytes (or raise <TT>os.error</TT> if checking is not possible).</P>
<A NAME="ch01lev4sec174"></A><H5 class="docSection4Title"> os.path.isabs(pathname)</H5>
<P class="docText">Return true if <TT>pathname</TT> is an absolute path.</P>
<A NAME="ch01lev4sec175"></A><H5 class="docSection4Title"> os.path.isdir(pathname)</H5>
<P class="docText">Return true if <TT>pathname</TT> is a directory.</P>
<A NAME="ch01lev4sec176"></A><H5 class="docSection4Title"> os.path.isfile(pathname)</H5>
<P class="docText">Return true if <TT>pathname</TT> is a regular file (including symbolic links).</P>
<A NAME="ch01lev4sec177"></A><H5 class="docSection4Title"> os.path.islink(pathname)</H5>
<P class="docText">Return true if <TT>pathname</TT> is a symbolic link.</P>
<A NAME="ch01lev4sec178"></A><H5 class="docSection4Title"> os.path.ismount(pathname)</H5>
<P class="docText">Return true if <TT>pathname</TT> is a mount point (on POSIX systems).</P>
<A NAME="ch01lev4sec179"></A><H5 class="docSection4Title"> os.path.join(path1 [,path2 [...]])</H5>
<P class="docText">Join multiple path components intelligently.</P>
<pre>
&gt;&gt;&gt; os.path.join('/Users/quilty/','Book','SCRIPTS/','mk_book')
'/Users/quilty/Book/SCRIPTS/mk_book'
</pre>
<A NAME="ch01lev4sec180"></A><H5 class="docSection4Title"> os.path.normcase(pathname)</H5>
<P class="docText">Convert <TT>pathname</TT> to canonical lowercase on case-insensitive filesystems. Also convert slashes on Windows systems.</P>
<A NAME="ch01lev4sec181"></A><H5 class="docSection4Title"> os.path.normpath(pathname)</H5>
<P class="docText">Remove redundant path information.</P>
<pre>
&gt;&gt;&gt; os.path.normpath('/usr/local/bin/../include/./slang.h')
'/usr/local/include/slang.h'
</pre>
<A NAME="ch01lev4sec182"></A><H5 class="docSection4Title"> os.path.realpath(pathname)</H5>
<P class="docText">Return the "real" path to <TT>pathname</TT> after de-aliasing any symbolic links. New in Python 2.2+.</P>
<pre>
&gt;&gt;&gt; os.path.realpath('/usr/bin/newaliases')
'/usr/sbin/sendmail'
</pre>
<A NAME="ch01lev4sec183"></A><H5 class="docSection4Title"> os.path.samefile(pathname1, pathname2)</H5>
<P class="docText">Return true if <TT>pathname1</TT> and <TT>pathname2</TT> are the same file.</P>
<p class="docText"><span class="docEmphRoman">S<span class="docEmphSmaller">EE</span> A<span class="docEmphSmaller">LSO</span></span>:  filecmp <span class="docEmphasis">58;</span></p>
<A NAME="ch01lev4sec184"></A><H5 class="docSection4Title"> os.path.sameopenfile(fp1, fp2)</H5>
<P class="docText">Return true if the file handles <TT>fp1</TT> and <TT>fp2</TT> refer to the same file. Not available on Windows.</P>
<A NAME="ch01lev4sec185"></A><H5 class="docSection4Title"> os.path.split(pathname)</H5>
<P class="docText">Return a tuple containing the path leading up to the named pathname and the named directory or filename in isolation.</P>
<pre>
&gt;&gt;&gt; os.path.split('/Users/quilty/Book/SCRIPTS')
('/Users/quilty/Book', 'SCRIPTS')
</pre>
<A NAME="ch01lev4sec186"></A><H5 class="docSection4Title"> os.path.splitdrive(pathname)</H5>
<P class="docText">Return a tuple containing the drive letter and the rest of the path. On systems that do not use a drive letter, the drive letter is empty (as it is where none is specified on Windows-like systems).</P>
<A NAME="ch01lev4sec187"></A><H5 class="docSection4Title"> os.path.walk(pathname, visitfunc, arg)</H5>
<P class="docText">For every directory recursively contained in <TT>pathname</TT>, call <TT>visitfunc (arg, dirname, pathnames)</TT> for each path.</P>
<pre>
&gt;&gt;&gt; def big_files(minsize, dirname, files):
...     for file in files:
...         fullname = os.path.join(dirname,file)
...         if os.path.isfile(fullname):
...             if os.path.getsize(fullname) &gt;= minsize:
...                 print fullname
...
&gt;&gt;&gt; os.path.walk('/usr/', big_files, 5e6)
/usr/lib/libSystem.B_debug.dylib
/usr/lib/libSystem.B_profile.dylib
</pre>
<P><A NAME="ch01sb26"></A><TABLE CELLSPACING="0" WIDTH="90%" BORDER="1"><TR><TD>
<P class="docText"><span class="docEmphStrong">shutil </span>&#8226; <span class="docEmphStrong">Copy files and directory trees</span></P></TD></TR></TABLE></P>
<P class="docText">The functions in the <span class="docEmphasis"><TT>shutil</TT></span> module make working with files a bit easier. There is nothing in this module that you could not do using basic file objects and <span class="docEmphasis"><TT>os.path</TT></span> functions, but <span class="docEmphasis"><TT>shutil</TT></span> often provides a more direct means and handles minor details for you. The functions in <span class="docEmphasis"><TT>shutil</TT></span> match fairly closely the capabilities you would find in Unix filesystem utilities like <TT>cp</TT> and <TT>rm</TT>.</P>
<A NAME="ch01lev3sec34"></A><H5 class="docSection3Title"> FUNCTIONS</H5>
<A NAME="ch01lev4sec188"></A><H5 class="docSection4Title"> shutil.copy(src, dst)</H5>
<P class="docText">Copy the file named <TT>src</TT> to the pathname <TT>dst</TT>. If <TT>dst</TT> is a directory, the created file is given the name <TT>os.path.join(dst+os.path.basename(src))</TT>.</P>
<p class="docText"><span class="docEmphRoman">S<span class="docEmphSmaller">EE</span> A<span class="docEmphSmaller">LSO</span></span>: 
os.path.join() <span class="docEmphasis">66;</span> os.path.basename() <span class="docEmphasis">65</span>;</p>
<A NAME="ch01lev4sec189"></A><H5 class="docSection4Title"> shutil.copy2(src, dst)</H5>
<P class="docText">Same as <span class="docEmphasis"><TT>shutil.copy()</TT></span> except that the access and creation time of <TT>dst</TT> are set to the values in <TT>src</TT>.</P>
<A NAME="ch01lev4sec190"></A><H5 class="docSection4Title"> shutil.copyfile(src, dst)</H5>
<P class="docText">Copy the file named <TT>src</TT> to the filename <TT>dst</TT> (overwriting <TT>dst</TT> if present). Basically, this has the same effect as <TT>open(dst,"wb").write(open(src,"rb").read())</TT>.</P>
<A NAME="ch01lev4sec191"></A><H5 class="docSection4Title"> shutil.copyfileobj(fpsrc, fpdst [,buffer=-1])</H5>
<P class="docText">Copy the file-like object <TT>fpsrc</TT> to the file-like object <TT>fpdst</TT>. If the optional argument <TT>buffer</TT> is given, only the specified number of bytes are read into memory at a time; this allows copying very large files.</P>
<A NAME="ch01lev4sec192"></A><H5 class="docSection4Title"> shutil.copymode(src, dst)</H5>
<P class="docText">Copy the permission bits from the file named <TT>src</TT> to the filename <TT>dst</TT>.</P>
<A NAME="ch01lev4sec193"></A><H5 class="docSection4Title"> shutil.copystat(src, dst)</H5>
<P class="docText">Copy the permission and timestamp data from the file named <TT>src</TT> to the filename <TT>dst</TT>.</P>
<A NAME="ch01lev4sec194"></A><H5 class="docSection4Title"> shutil.copytree(src, dst [,symlinks=0])</H5>
<P class="docText">Copy the directory <TT>src</TT> to the destination <TT>dst</TT> recursively. If the optional argument <TT>symlinks</TT> is a true value, copy symbolic links as links rather than the default behavior of copying the content of the link target. This function may not be entirely reliable on every platform and filesystem.</P>
<A NAME="ch01lev4sec195"></A><H5 class="docSection4Title"> shutil.rmtree(dirname [ignore [,errorhandler]])</H5>
<P class="docText">Remove an entire directory tree rooted at <TT>dirname</TT>. If optional argument ignore is a true value, errors will be silently ignored. If <TT>errorhandler</TT> is given, a custom error handler is used to catch errors. This function may not be entirely reliable on every platform and filesystem.</P>
<p class="docText"><span class="docEmphRoman">S<span class="docEmphSmaller">EE</span> A<span class="docEmphSmaller">LSO</span></span>: 
open() <span class="docEmphasis">15;</span> os.path <span class="docEmphasis">65;</span></p>
<P><A NAME="ch01sb27"></A><TABLE CELLSPACING="0" WIDTH="90%" BORDER="1"><TR><TD>
<P class="docText"><span class="docEmphStrong">stat</span> &#8226; <span class="docEmphStrong">Constants/functions for os.stat()</span></P></TD></TR></TABLE></P>
<P class="docText">The <span class="docEmphasis"><TT>stat</TT></span> module provides two types of support for analyzing the results of <span class="docEmphasis"><TT>os.stat()</TT>, <TT>os.lstat()</TT></span>, and <span class="docEmphasis"><TT>os.fstat()</TT></span> calls.</P>
<P class="docText">Several functions exist to allow you to perform tests on a file. If you simply wish to check one predicate of a file, it is more direct to use one of the <span class="docEmphasis"><TT>os.path.is*()</TT></span> functions, but for performing several such tests, it is faster to read the mode once and perform several <span class="docEmphasis"><TT>stat.S_*()</TT></span> tests.</P>
<P class="docText">As well as helper functions, <span class="docEmphasis"><TT>stat</TT></span> defines symbolic constants to access the fields of the 10-tuple returned by <span class="docEmphasis"><TT>os.stat()</TT></span> and friends. For example:</P>
<pre>
&gt;&gt;&gt; from stat import *
&gt;&gt;&gt; import os
&gt;&gt;&gt; fileinfo = os.stat('chap1.txt')
&gt;&gt;&gt; fileinfo[ST_SIZE]
68666L
&gt;&gt;&gt; mode = fileinfo [ST_MODE]
&gt;&gt;&gt; S_ISSOCK(mode)
0
&gt;&gt;&gt; S_ISDIR(mode)
0
&gt;&gt;&gt; S_ISREG(mode)
1
</pre>
<A NAME="ch01lev3sec35"></A><H5 class="docSection3Title"> FUNCTIONS</H5>
<A NAME="ch01lev4sec196"></A><H5 class="docSection4Title"> stat.S_ISDIR(mode)</H5>
<P class="docText">Mode indicates a directory.</P>
<A NAME="ch01lev4sec197"></A><H5 class="docSection4Title"> stat.S_ISCHR(mode)</H5>
<P class="docText">Mode indicates a character special device file.</P>
<A NAME="ch01lev4sec198"></A><H5 class="docSection4Title"> stat.S_ISBLK(mode)</H5>
<P class="docText">Mode indicates a block special device file.</P>
<A NAME="ch01lev4sec199"></A><H5 class="docSection4Title"> stat.S_ISREG(mode)</H5>
<P class="docText">Mode indicates a regular file.</P>
<A NAME="ch01lev4sec200"></A><H5 class="docSection4Title"> stat.S_ISFIFO(mode)</H5>
<P class="docText">Mode indicates a FIFO (named pipe).</P>
<A NAME="ch01lev4sec201"></A><H5 class="docSection4Title"> stat.S_ISLNK(mode)</H5>
<P class="docText">Mode indicates a symbolic link.</P>
<A NAME="ch01lev4sec202"></A><H5 class="docSection4Title"> stat.S_ISSOCK(mode)</H5>
<P class="docText">Mode indicates a socket.</P>
<A NAME="ch01lev3sec36"></A><H5 class="docSection3Title"> CONSTANTS</H5>
<A NAME="ch01lev4sec203"></A><H5 class="docSection4Title"> stat.ST_MODE</H5>
<P class="docText">I-node protection mode.</P>
<A NAME="ch01lev4sec204"></A><H5 class="docSection4Title"> stat.ST_INO</H5>
<P class="docText">I-node number.</P>
<A NAME="ch01lev4sec205"></A><H5 class="docSection4Title"> stat.ST_DEV</H5>
<P class="docText">Device.</P>
<A NAME="ch01lev4sec206"></A><H5 class="docSection4Title"> stat.ST_NLINK</H5>
<P class="docText">Number of links to this i-node.</P>
<A NAME="ch01lev4sec207"></A><H5 class="docSection4Title"> stat.ST_UID</H5>
<P class="docText">User id of file owner.</P>
<A NAME="ch01lev4sec208"></A><H5 class="docSection4Title"> stat.ST_GID</H5>
<P class="docText">Group id of file owner.</P>
<A NAME="ch01lev4sec209"></A><H5 class="docSection4Title"> stat.ST_SIZE</H5>
<P class="docText">Size of file.</P>
<A NAME="ch01lev4sec210"></A><H5 class="docSection4Title"> stat.ST_ATIME</H5>
<P class="docText">Last access time.</P>
<A NAME="ch01lev4sec211"></A><H5 class="docSection4Title"> stat.ST_MTIME</H5>
<P class="docText">Modification time.</P>
<A NAME="ch01lev4sec212"></A><H5 class="docSection4Title"> stat.ST_CTIME</H5>
<P class="docText">Time of last status change.</P>
<P><A NAME="ch01sb28"></A><TABLE CELLSPACING="0" WIDTH="90%" BORDER="1"><TR><TD>
<P class="docText"><span class="docEmphStrong">tempfile </span>&#8226; <span class="docEmphStrong">Temporary files and filenames</span></P></TD></TR></TABLE></P>
<P class="docText">The <span class="docEmphasis"><TT>tempfile</TT></span> module is useful when you need to store transient data using a file-like interface. In contrast to the file-like interface of <span class="docEmphasis"><TT>StringIO</TT>, <TT>tempfile</TT></span> uses the actual filesystem for storage rather than simulating the interface to a file in memory. In memory-constrained contexts, therefore, <span class="docEmphasis"><TT>tempfile</TT></span> is preferable.</P>
<P class="docText">The temporary files created by <span class="docEmphasis"><TT>tempfile</TT></span> are as secure against external modification as is supported by the underlying platform. You can be fairly confident that your temporary data will not be read or changed either while your program is running or afterwards (temporary files are deleted when closed). While you should not count on <span class="docEmphasis"><TT>tempfile</TT></span> to provide you with cryptographic-level security, it is good enough to prevent accidents and casual inspection.</P>
<A NAME="ch01lev3sec37"></A><H5 class="docSection3Title"> FUNCTIONS</H5>
<A NAME="ch01lev4sec213"></A><H5 class="docSection4Title"> tempfile.mktemp([suffix=""])</H5>
<P class="docText">Return an absolute path to a unique temporary filename. If optional argument <TT>suffix</TT> is specified, the name will end with the <TT>suffix</TT> string.</P>
<A NAME="ch01lev4sec214"></A><H5 class="docSection4Title"> tempfile.TemporaryFile([mode="w+b" [,buffsize=-1 [suffix=""]]])</H5>
<P class="docText">Return a temporary file object. In general, there is little reason to change the default <TT>mode</TT> argument of <TT>w+b</TT>; there is no existing file to append to before the creation, and it does little good to write temporary data you cannot read. Likewise, the optional <TT>suffix</TT> argument generally will not ever be visible, since the file is deleted when closed. The default <TT>buffsize</TT> uses the platform defaults, but may be modified if needed.</P>
<pre>
&gt;&gt;&gt; tmpfp = tempfile.TemporaryFile()
&gt;&gt;&gt; tmpfp.write('this and that\n')
&gt;&gt;&gt; tmpfp.write('something else\n')
&gt;&gt;&gt; tmpfp.tell()
29L
&gt;&gt;&gt; tmpfp.seek(0)
&gt;&gt;&gt; tmpfp.read()
'this and that\nsomething else\n'
</pre>
<p class="docText"><span class="docEmphRoman">S<span class="docEmphSmaller">EE</span> A<span class="docEmphSmaller">LSO</span></span>: 
StringIO <span class="docEmphasis">153</span>; cStringIO <span class="docEmphasis">153</span>;</p>
<P><A NAME="ch01sb29"></A><TABLE CELLSPACING="0" WIDTH="90%" BORDER="1"><TR><TD>
<P class="docText"><span class="docEmphStrong">xreadlines </span>&#8226; <span class="docEmphStrong">Efficient iteration over a file</span></P></TD></TR></TABLE></P>
<P class="docText">Reading over the lines of a file had some pitfalls in older versions of Python: There was a memory-friendly way, and there was a fast way, but never the twain shall meet. These techniques were:</P>
<pre>
&gt;&gt;&gt; fp = open('bigfile')
&gt;&gt;&gt; line = fp.readline()
&gt;&gt;&gt; while line:
...     # Memory-friendly but slow
...     # ...do stuff...
...     line = fp.readline()

&gt;&gt;&gt; for line in open('bigfile').readlines():
...     # Fast but memory-hungry
...     # ...do stuff...
</pre>
<P class="docText">Fortunately, with Python 2.1 a more efficient technique was provided. In Python 2.2+, this efficient technique was also wrapped into a more elegant syntactic form (in keeping with the new iterator). With Python 2.3+, <span class="docEmphasis"><TT>xreadlines</TT></span> is officially deprecated in favor of the idiom <TT>"for line in file:"</TT>.</P>
<A NAME="ch01lev3sec38"></A><H5 class="docSection3Title"> FUNCTIONS</H5>
<A NAME="ch01lev4sec215"></A><H5 class="docSection4Title"> xreadlines.xreadlines(fp)</H5>
<P class="docText">Iterate over the lines of file object <TT>fp</TT> in an efficient way (both speed-wise and in memory usage).</P>
<pre>
&gt;&gt;&gt; for line in xreadlines.xreadlines(open('tmp')):
...     # Efficient all around
...     # ...do stuff...
</pre>
<P class="docText">Corresponding to this <span class="docEmphasis"><TT>xreadlines</TT></span> module function is the <TT>.xreadlines()</TT> method of file objects.</P>
<pre>
&gt;&gt;&gt; for line in open('tmp').xreadlines():
...     # As a file object method
...     # ...do stuff...
</pre>
<P class="docText">If you use Python 2.2 or above, an even nicer version is available:</P>
<pre>
&gt;&gt;&gt; for line in open('tmp'):
...     # ...do stuff...
</pre>
<p class="docText"><span class="docEmphRoman">S<span class="docEmphSmaller">EE</span> A<span class="docEmphSmaller">LSO</span></span>: 
linecache <span class="docEmphasis">64;</span> FILE.xreadlines() <span class="docEmphasis">17;</span> os.tmpfile() <span class="docEmphasis">80;</span></p>
<A NAME="ch01lev2sec9"></A><H4 class="docSection2Title">1.2.3 Running External Commands and Accessing OS Features</H4>
<P><A NAME="ch01sb30"></A><TABLE CELLSPACING="0" WIDTH="90%" BORDER="1"><TR><TD>
<P class="docText"><span class="docEmphStrong">commands </span>&#8226; <span class="docEmphStrong">Quick access to external commands</span></P></TD></TR></TABLE></P>
<P class="docText">The <span class="docEmphasis"><TT>commands</TT></span> module exists primarily as a convenience wrapper for calls to <span class="docEmphasis"><TT>os.popen*()</TT></span> functions on Unix-like systems. STDERR is combined with STDOUT in the results.</P>
<A NAME="ch01lev3sec39"></A><H5 class="docSection3Title"> FUNCTIONS</H5>
<A NAME="ch01lev4sec216"></A><H5 class="docSection4Title"> commands.getoutput(cmd)</H5>
<P class="docText">Return the output from running <TT>cmd</TT>. This function could also be implemented as:</P>
<pre>
&gt;&gt;&gt; def getoutput(cmd):
...     import os
...     return os.popen('{ '+cmd+'; } 2&gt;&amp;1').read()
</pre>
<A NAME="ch01lev4sec217"></A><H5 class="docSection4Title"> commands.getstatusoutput(cmd)</H5>
<P class="docText">Return a tuple containing the exit status and output from running <TT>cmd</TT>. This function could also be implemented as:</P>
<pre>
&gt;&gt;&gt; def getstatusoutput(cmd):
...     import os
...     fp = os.popen('{ '+cmd+'; } 2&gt;&amp;1')
...     output = fp.read()
...     status = fp.close()
...     if not status: status=0 # Want zero rather than None
...     return (status, output)
...
&gt;&gt;&gt; getstatusoutput('ls nosuchfile')
(256, 'ls: nosuchfile: No such file or directory\n')
&gt;&gt;&gt; getstatusoutput('ls c*[1-3].txt')
(0, 'chap1.txt\nchap2.txt\nchap3.txt\n')
</pre>
<A NAME="ch01lev4sec218"></A><H5 class="docSection4Title"> commands.getstatus(filename)</H5>
<P class="docText">Same as <TT>commands.getoutput('ls -ld '+filename)</TT>.</P>
<p class="docText"><span class="docEmphRoman">S<span class="docEmphSmaller">EE</span> A<span class="docEmphSmaller">LSO</span></span>: 
os.popen() <span class="docEmphasis">77</span>; os.popen2() <span class="docEmphasis">77</span>; os.popen3() <span class="docEmphasis">78;</span> os.popen4() <span class="docEmphasis">78;</span></p>
<P><A NAME="ch01sb31"></A><TABLE CELLSPACING="0" WIDTH="90%" BORDER="1"><TR><TD>
<P class="docText"><span class="docEmphStrong">os</span> &#8226; <span class="docEmphStrong">Portable operating system services</span></P></TD></TR></TABLE></P>
<P class="docText">The <span class="docEmphasis"><TT>os</TT></span> module contains a large number of functions, attributes, and constants for calling on or determining features of the operating system that Python runs on. In many cases, functions in <span class="docEmphasis"><TT>os</TT></span> are internally implemented using modules like <span class="docEmphasis"><TT>posix, os2</TT></span>, <span class="docEmphasis"><TT>riscos</TT></span>, or <span class="docEmphasis"><TT>mac</TT></span>, but for portability it is better to use the <span class="docEmphasis"><TT>os</TT></span> module.</P>
<P class="docText">Not everything in the <span class="docEmphasis"><TT>os</TT></span> module is documented in this book. You can read about those features that are unlikely to be used in text processing applications in the <span class="docEmphasis">Python Library Reference</span> that accompanies Python distributions.</P>
<P class="docText">Functions and constants not documented here fall into several categories. The functions and attributes <span class="docEmphasis"><TT>os.confstr()</TT>, <TT>os.confstr_names</TT>, <TT>os.sysconf()</TT></span>, and <span class="docEmphasis"><TT>os.sysconf_names</TT></span> let you probe system configuration. As well, I skip some functions specific to process permissions on Unix-like systems: <span class="docEmphasis"><TT>os.ctermid()</TT>, <TT>os.getegid()</TT>, <TT>os.geteuid()</TT>, <TT>os.getgid()</TT>, <TT>os.getgroups()</TT>, <TT>os.getlogin()</TT>, <TT>os.getpgrp()</TT>, <TT>os.getppid()</TT>, <TT>os.getuid()</TT>, <TT>os.setegid()</TT>, <TT>os.seteuid()</TT>, <TT>os.setgid()</TT>, <TT>os.setgroups()</TT>, <TT>os.setpgrp()</TT>, <TT>os.setpgid()</TT>, <TT>os.setreuid()</TT>, <TT>os.setregid()</TT>, <TT>os.setsid()</TT></span>, and <span class="docEmphasis"><TT>os.setuid(uid)</TT></span>.</P>
<P class="docText">The functions <span class="docEmphasis"><TT>os.abort()</TT>, <TT>os.exec*()</TT>, <TT>os._exit()</TT>, <TT>os.fork()</TT>, <TT>os.forkpty ()</TT>, <TT>os.plock()</TT>, <TT>os.spawn*()</TT>, <TT>os.times()</TT>, <TT>os.wait()</TT>, <TT>os.waitpid()</TT>, <TT>os.WIF*()</TT>, <TT>os.WEXITSTATUS()</TT></span>, os.WSTOPSIG()', and <span class="docEmphasis"><TT>os.WTERMSIG()</TT></span> and the constants <span class="docEmphasis"><TT>os.P_*</TT></span> and <span class="docEmphasis"><TT>os.WNOHANG</TT></span> all deal with process creation and management. These are not documented in this book, since creating and managing multiple processes is not typically central to text processing tasks. However, I briefly document the basic capabilities in <span class="docEmphasis"><TT>os.kill()</TT>, <TT>os.nice()</TT>, <TT>os.startfile()</TT></span>, and <span class="docEmphasis"><TT>os.system()</TT></span> and in the <span class="docEmphasis"><TT>os.popen()</TT></span> family. Some of the omitted functionality can also be found in the <span class="docEmphasis"><TT>commands</TT></span> and <span class="docEmphasis"><TT>sys</TT></span> modules.</P>
<P class="docText">A number of functions in the os module allow you to perform low-level I/O using file descriptors. In general, it is simpler to perform I/O using file objects created with the built-in <span class="docEmphasis"><TT>open()</TT></span> function or the <span class="docEmphasis"><TT>os.popen*()</TT></span> family. These file objects provide methods like <span class="docEmphasis"><TT>FILE.readline()</TT>, <TT>FILE.write()</TT>, <TT>FILE.seek()</TT></span>, and <span class="docEmphasis"><TT>FILE.close()</TT> .</span> Information about files can be determined using the <span class="docEmphasis"><TT>os.stat()</TT></span> function or functions in the <span class="docEmphasis"><TT>os.path</TT></span> and <span class="docEmphasis"><TT>shutil</TT></span> modules. Therefore, the functions <span class="docEmphasis"><TT>os.close()</TT>, <TT>os.dup()</TT>, <TT>os.dup2()</TT>, <TT>os.fpathconf()</TT>, <TT>os.fstat()</TT>, <TT>os.fstatvfs()</TT>, <TT>os.ftruncate()</TT>, <TT>os.isatty()</TT>, <TT>os.lseek()</TT>, <TT>os.open()</TT>, <TT>os.openpty()</TT>, <TT>os.pathconf()</TT>, <TT>os.pipe()</TT>, <TT>os.read()</TT>, <TT>os.statvfs()</TT>, <TT>os.tcgetpgrp()</TT>, <TT>os.tcsetpgrp()</TT>, <TT>os.ttyname()</TT>, <TT>os.umask()</TT></span>, and <span class="docEmphasis"><TT>os.write()</TT></span> are not covered here. As well, the supporting constants os.0_* and <span class="docEmphasis"><TT>os.pathconf_names</TT></span> are omitted.</P>
<p class="docText"><span class="docEmphRoman">S<span class="docEmphSmaller">EE</span> A<span class="docEmphSmaller">LSO</span></span>: 
commands <span class="docEmphasis">73;</span> os.path <span class="docEmphasis">65;</span> shutil <span class="docEmphasis">68;</span> sys <span class="docEmphasis">49;</span></p>
<A NAME="ch01lev3sec40"></A><H5 class="docSection3Title"> FUNCTIONS</H5>
<A NAME="ch01lev4sec219"></A><H5 class="docSection4Title"> os.access(pathname, operation)</H5>
<P class="docText">Check the permission for the file or directory <TT>pathname</TT>. If the type of operation specified is allowed, return a true value. The argument <TT>operation</TT> is a number between 0 and 7, inclusive, and encodes four features: exists, executable, writable, and readable. These features have symbolic names:</P>
<pre>
&gt;&gt;&gt; import os
&gt;&gt;&gt; os.F_OK, os.X_OK, os.W_OK, os.R_OK
(0, 1, 2, 4)
</pre>
<P class="docText">To query a specific combination of features, you may add or bitwise-or the individual features.</P>
<pre>
&gt;&gt;&gt; os.access('myfile', os.W_OK | os.R_OK)
1
&gt;&gt;&gt; os.access('myfile', os.X_OK + os.R_OK)
0
&gt;&gt;&gt; os.access('myfile', 6)
1
</pre>
<A NAME="ch01lev4sec220"></A><H5 class="docSection4Title"> os.chdir(pathname)</H5>
<P class="docText">Change the current working directory to the path <TT>pathname</TT>.</P>
<p class="docText"><span class="docEmphRoman">S<span class="docEmphSmaller">EE</span> A<span class="docEmphSmaller">LSO</span></span>: 
os.getcwd() <span class="docEmphasis">75;</span></p>
<A NAME="ch01lev4sec221"></A><H5 class="docSection4Title"> os.chmod(pathname, mode)</H5>
<P class="docText">Change the mode of file or directory <TT>pathname</TT> to numeric mode <TT>mode</TT>. See the <TT>man</TT> page for the <TT>chmod</TT> utility for more information on modes.</P>
<A NAME="ch01lev4sec222"></A><H5 class="docSection4Title"> os.chown(pathname, uid, gid)</H5>
<P class="docText">Change the owner and group of file or directory <TT>pathname</TT> to <TT>uid</TT> and <TT>gid</TT> respectively. See the <TT>man</TT> page for the <TT>chown</TT> utility for more information.</P>
<A NAME="ch01lev4sec223"></A><H5 class="docSection4Title"> os.chroot(pathname)</H5>
<P class="docText">Change the root directory under Unix-like systems (on Python 2.2+). See the <TT>man</TT> page for the <TT>chroot</TT> utility for more information.</P>
<A NAME="ch01lev4sec224"></A><H5 class="docSection4Title"> os.getcwd()</H5>
<P class="docText">Return the current working directory as a string.</P>
<pre>
&gt;&gt;&gt; os.getcwd()
'/Users/quilty/Book'
</pre>
<p class="docText"><span class="docEmphRoman">S<span class="docEmphSmaller">EE</span> A<span class="docEmphSmaller">LSO</span></span>: 
os.chdir() <span class="docEmphasis">75</span>;</p>
<A NAME="ch01lev4sec225"></A><H5 class="docSection4Title"> os.getenv(var [,value=None])</H5>
<P class="docText">Return the value of environment variable <TT>var</TT>. If the environment variable is not defined, return <TT>value</TT>. An equivalent call is os. <TT>environ.get(var, value)</TT>.</P>
<p class="docText"><span class="docEmphRoman">S<span class="docEmphSmaller">EE</span> A<span class="docEmphSmaller">LSO</span></span>: 
os.environ <span class="docEmphasis">81;</span> os.putenv() <span class="docEmphasis">78;</span></p>
<A NAME="ch01lev4sec226"></A><H5 class="docSection4Title"> os.getpid()</H5>
<P class="docText">Return the current process id. Possibly useful for calls to external utilities that use process id's.</P>
<p class="docText"><span class="docEmphRoman">S<span class="docEmphSmaller">EE</span> A<span class="docEmphSmaller">LSO</span></span>: 
os.kill() <span class="docEmphasis">76;</span></p>
<A NAME="ch01lev4sec227"></A><H5 class="docSection4Title"> os.kill(pid, sig)</H5>
<P class="docText">Kill an external process on Unix-like systems. You will need to determine values for the <TT>pid</TT> argument by some means, such as a call to the <TT>ps</TT> utility. Values for the signal <TT>sig</TT> sent to the process may be found in the <span class="docEmphasis"><TT>signal</TT></span> module or with <TT>man signal</TT>. For example:</P>
<pre>
&gt;&gt;&gt; from signal import  *
&gt;&gt;&gt; SIGHUP, SIGINT, SIGQUIT, SIGIOT, SIGKILL
(1, 2, 3, 6, 9)
&gt;&gt;&gt; def kill_by_name(progname):
...     pidstr = os.popen('ps|grep '+progname+'|sort').read()
<span class="docEmphStrong">...</span>     pid = int(pidstr.split()[0])
<span class="docEmphStrong">...</span>     os.kill(pid, 9)
...
&gt;&gt;&gt; kill_by_name('myprog')
</pre>
<A NAME="ch01lev4sec228"></A><H5 class="docSection4Title"> os.link(src, dst)</H5>
<P class="docText">Create a hard link from path <TT>src</TT> to path <TT>dst</TT> on Unix-like systems. See the <TT>man</TT> page on the <TT>ln</TT> utility for more information.</P>
<p class="docText"><span class="docEmphRoman">S<span class="docEmphSmaller">EE</span> A<span class="docEmphSmaller">LSO</span></span>: 
os.symlink() <span class="docEmphasis">80;</span></p>
<A NAME="ch01lev4sec229"></A><H5 class="docSection4Title"> os.listdir(pathname)</H5>
<P class="docText">Return a list of the names of files and directories at path <TT>pathname</TT>. The special entries for the current and parent directories (typically "." and "..") are excluded from the list.</P>
<A NAME="ch01lev4sec230"></A><H5 class="docSection4Title"> os.lstat(pathname)</H5>
<P class="docText">Information on file or directory <TT>pathname</TT>. See <span class="docEmphasis"><TT>os.stat()</TT></span> for details. <span class="docEmphasis"><TT>os.lstat()</TT></span> does not follow symbolic links.</P>
<p class="docText"><span class="docEmphRoman">S<span class="docEmphSmaller">EE</span> A<span class="docEmphSmaller">LSO</span></span>: 
os.stat() <span class="docEmphasis">79;</span> stat <span class="docEmphasis">69;</span></p>
<A NAME="ch01lev4sec231"></A><H5 class="docSection4Title"> os.mkdir(pathname [,mode=0777])</H5>
<P class="docText">Create a directory named <TT>pathname</TT> with the numeric mode <TT>mode</TT>. On some operating systems, <TT>mode</TT> is ignored. See the <TT>man</TT> page for the <TT>chmod</TT> utility for more information on modes.</P>
<p class="docText"><span class="docEmphRoman">S<span class="docEmphSmaller">EE</span> A<span class="docEmphSmaller">LSO</span></span>: 
os.chmod() <span class="docEmphasis">75;</span> os.mkdirs() <span class="docEmphasis">77</span>;</p>
<A NAME="ch01lev4sec232"></A><H5 class="docSection4Title"> os.mkdirs(pathname [,mode=0777])</H5>
<P class="docText">Create a directory named <TT>pathname</TT> with the numeric mode <TT>mode</TT>. Unlike <span class="docEmphasis"><TT>os.mkdir()</TT></span>, this function will create any intermediate directories needed for a nested directory.</P>
<p class="docText"><span class="docEmphRoman">S<span class="docEmphSmaller">EE</span> A<span class="docEmphSmaller">LSO</span></span>: 
os.mkdir() <span class="docEmphasis">76;</span></p>
<A NAME="ch01lev4sec233"></A><H5 class="docSection4Title"> os.mkfifo(pathname [,mode=0666])</H5>
<P class="docText">Create a named pipe on Unix-like systems.</P>
<A NAME="ch01lev4sec234"></A><H5 class="docSection4Title"> os.nice(increment)</H5>
<P class="docText">Decrease the process priority of the current application under Unix-like systems. This is useful if you do not wish for your application to hog system CPU resources.</P>
<P class="docText">The four functions in the <span class="docEmphasis"><TT>os.popen*()</TT></span> family allow you to run external processes and capture their STDOUT and STDERR and/or set their STDIN. The members of the family differ somewhat in how these three pipes are handled.</P>
<A NAME="ch01lev4sec235"></A><H5 class="docSection4Title"> os.popen(cmd [,mode="r" [,bufsize]])</H5>
<P class="docText">Open a pipe to or from the external command <TT>cmd</TT>. The return value of the function is an open file object connected to the pipe. The <TT>mode</TT> may be <TT>r</TT> for read (the default) or <TT>w</TT> for write. The exit status of the command is returned when the file object is closed. An optional buffer size <TT>bufsize</TT> may be specified.</P>
<pre>
&gt;&gt;&gt; import os
&gt;&gt;&gt; def ls(pat):
...     stdout = os.popen('ls '+pat)
...     result = stdout.read()
...     status = stdout.close()
...     if status: print "Error status", status
...     else: print result
...
&gt;&gt;&gt; ls('nosuchfile')
ls: nosuchfile: No such file or directory
Error status 256
&gt;&gt;&gt; ls('chap[7-9].txt')
chap7.txt
</pre>
<A NAME="ch01lev4sec236"></A><H5 class="docSection4Title"> os.popen2(cmd [,mode [,bufsize]])</H5>
<P class="docText">Open both STDIN and STDOUT pipes to the external command <TT>cmd</TT>. The return value is a pair of file objects connecting to the two respective pipes. <TT>mode</TT> and <TT>bufsize</TT> work as with <span class="docEmphasis"><TT>os.popen()</TT></span>.</P>
<p class="docText"><span class="docEmphRoman">S<span class="docEmphSmaller">EE</span> A<span class="docEmphSmaller">LSO</span></span>: 
os.popen3() <span class="docEmphasis">78;</span> os.popen() <span class="docEmphasis">77</span>;</p>
<A NAME="ch01lev4sec237"></A><H5 class="docSection4Title"> os.popen3(cmd [,mode [,bufsize]])</H5>
<P class="docText">Open STDIN, STDOUT, and STDERR pipes to the external command <TT>cmd</TT>. The return value is a 3-tuple of file objects connecting to the three respective pipes. <TT>mode</TT> and <TT>bufsize</TT> work as with <span class="docEmphasis"><TT>os.popen()</TT></span>.</P>
<pre>
&gt;&gt;&gt; import os
&gt;&gt;&gt; stdin, stdout, stderr = os.popen3('sed s/line/LINE/')
&gt;&gt;&gt; print &gt;&gt;stdin, 'line one'
&gt;&gt;&gt; print &gt;&gt;stdin, 'line two'
&gt;&gt;&gt; stdin.write('line three\n)'
&gt;&gt;&gt; stdin.close()
&gt;&gt;&gt; stdout.read()
'LINE one\nLINE two\nLINE three\n'
&gt;&gt;&gt; stderr.read()
''
</pre>
<A NAME="ch01lev4sec238"></A><H5 class="docSection4Title"> os.popen4(cmd [,mode [,bufsize]])</H5>
<P class="docText">Open STDIN, STDOUT, and STDERR pipes to the external command <TT>cmd</TT>. In contrast to <span class="docEmphasis"><TT>os.popen3(), os.popen4()</TT></span> combines STDOUT and STDERR on the same pipe. The return value is a pipe of file objects connecting to the two respective pipes. <TT>mode</TT> and <TT>bufsize</TT> work as with <span class="docEmphasis"><TT>os.popen()</TT></span>.</P>
<p class="docText"><span class="docEmphRoman">S<span class="docEmphSmaller">EE</span> A<span class="docEmphSmaller">LSO</span></span>: 
os.popen3() <span class="docEmphasis">78;</span> os.popen() <span class="docEmphasis">77</span>;</p>
<A NAME="ch01lev4sec239"></A><H5 class="docSection4Title"> os.putenv(var, value)</H5>
<P class="docText">Set the environment variable <TT>var</TT> to the value <TT>value</TT>. Changes to the current environment only affect subprocesses of the current process, such as those launched with <span class="docEmphasis"><TT>os.system()</TT></span> or <span class="docEmphasis"><TT>os.popen()</TT></span>, not the whole OS.</P>
<P class="docText">Calls to <span class="docEmphasis"><TT>os.putenv()</TT></span> will update the environment, but not the <span class="docEmphasis"><TT>os.environ</TT></span> variable. Therefore, it is better to update <span class="docEmphasis"><TT>os.environ</TT></span> directly (which also changes the external environment).</P>
<p class="docText"><span class="docEmphRoman">S<span class="docEmphSmaller">EE</span> A<span class="docEmphSmaller">LSO</span></span>: 
os.environ <span class="docEmphasis">81;</span> os.getenv() <span class="docEmphasis">75;</span> os.popen() <span class="docEmphasis">77</span>; os.system() <span class="docEmphasis">80;</span></p>
<A NAME="ch01lev4sec240"></A><H5 class="docSection4Title"> os.readlink(linkname)</H5>
<P class="docText">Return a string containing the path symbolic link <TT>linkname</TT> points to. Works on Unix-like systems.</P>
<p class="docText"><span class="docEmphRoman">S<span class="docEmphSmaller">EE</span> A<span class="docEmphSmaller">LSO</span></span>: 
os.symlink() <span class="docEmphasis">80;</span></p>
<A NAME="ch01lev4sec241"></A><H5 class="docSection4Title"> os.remove(filename)</H5>
<P class="docText">Remove the file named <TT>filename</TT>. This function is identical to <span class="docEmphasis"><TT>os.unlink()</TT></span>. If the file cannot be removed, an <TT>OSError</TT> is raised.</P>
<p class="docText"><span class="docEmphRoman">S<span class="docEmphSmaller">EE</span> A<span class="docEmphSmaller">LSO</span></span>: 
os.unlink() <span class="docEmphasis">81;</span></p>
<A NAME="ch01lev4sec242"></A><H5 class="docSection4Title"> os.removedirs(pathname)</H5>
<P class="docText">Remove the directory named <TT>pathname</TT> and any subdirectories of <TT>pathname</TT>. This function will not remove directories with files, and will raise an <TT>OSError</TT> if you attempt to do so.</P>
<p class="docText"><span class="docEmphRoman">S<span class="docEmphSmaller">EE</span> A<span class="docEmphSmaller">LSO</span></span>: 
os.rmdir() <span class="docEmphasis">79;</span></p>
<A NAME="ch01lev4sec243"></A><H5 class="docSection4Title"> os.rename(src, dst)</H5>
<P class="docText">Rename the file or directory <TT>src</TT> as <TT>dst</TT>. Depending on the operating system, the operation may raise an <TT>OSError</TT> if <TT>dst</TT> already exists.</P>
<p class="docText"><span class="docEmphRoman">S<span class="docEmphSmaller">EE</span> A<span class="docEmphSmaller">LSO</span></span>: 
os.renames() <span class="docEmphasis">79;</span></p>
<A NAME="ch01lev4sec244"></A><H5 class="docSection4Title"> os.renames(src, dst)</H5>
<P class="docText">Rename the file or directory <TT>src</TT> as <TT>dst</TT>. Unlike <span class="docEmphasis"><TT>os.rename()</TT></span>, this function will create any intermediate directories needed for a nested directory.</P>
<p class="docText"><span class="docEmphRoman">S<span class="docEmphSmaller">EE</span> A<span class="docEmphSmaller">LSO</span></span>: 
os.rename() <span class="docEmphasis">79;</span></p>
<A NAME="ch01lev4sec245"></A><H5 class="docSection4Title"> os.rmdir(pathname)</H5>
<P class="docText">Remove the directory named <TT>pathname</TT>. This function will not remove nonempty directories and will raise an <TT>OSError</TT> if you attempt to do so.</P>
<p class="docText"><span class="docEmphRoman">S<span class="docEmphSmaller">EE</span> A<span class="docEmphSmaller">LSO</span></span>: 
os.removedirs() <span class="docEmphasis">79;</span></p>
<A NAME="ch01lev4sec246"></A><H5 class="docSection4Title"> os.startfile(path)</H5>
<P class="docText">Launch an application under Windows system. The behavior is the same as if <TT>path</TT> was double-clicked in a Drives window or as if you typed <TT>start &lt;path&gt;</TT> at a command line. Using Windows associations, a data file can be launched in the same manner as an actual executable application.</P>
<p class="docText"><span class="docEmphRoman">S<span class="docEmphSmaller">EE</span> A<span class="docEmphSmaller">LSO</span></span>: 
os.system() <span class="docEmphasis">80;</span></p>
<A NAME="ch01lev4sec247"></A><H5 class="docSection4Title"> os.stat(pathname)</H5>
<P class="docText">Create a <TT>stat_result</TT> object that contains information on the file or directory <TT>pathname</TT>. A <TT>stat_result</TT> object has a number of attributes and also behaves like a tuple of numeric values. Before Python 2.2, only the tuple was provided. The attributes of a <TT>stat_result</TT> object are named the same as the constants in the <span class="docEmphasis"><TT>stat</TT></span> module, but in lowercase.</P>
<pre>
&gt;&gt;&gt; import os, stat
&gt;&gt;&gt; file_info = os.stat('chap1.txt')
&gt;&gt;&gt; file_info.st_size
87735L
&gt;&gt;&gt; file_info [stat.ST_SIZE]
87735L
</pre>
<P class="docText">On some platforms, additional attributes are available. For example, Unix-like systems usually have <TT>.st_blocks</TT>, <TT>.st_blksize</TT>, and <TT>.st_rdev</TT> attributes; MacOS has <TT>.st_rsize</TT>, <TT>.st_creator</TT>, and <TT>.st_type</TT>; RISCOS has <TT>.st_ftype</TT>, <TT>.st_attrs</TT>, and <TT>.st_obtype</TT>.</P>
<p class="docText"><span class="docEmphRoman">S<span class="docEmphSmaller">EE</span> A<span class="docEmphSmaller">LSO</span></span>: 
stat <span class="docEmphasis">69;</span> os.lstat() <span class="docEmphasis">76;</span></p>
<A NAME="ch01lev4sec248"></A><H5 class="docSection4Title"> os.strerror(code)</H5>
<P class="docText">Give a description for a numeric error code <TT>code</TT>, such as that returned by <TT>os.popen(bad_cmd).close()</TT>.</P>
<p class="docText"><span class="docEmphRoman">S<span class="docEmphSmaller">EE</span> A<span class="docEmphSmaller">LSO</span></span>: 
os.popen() <span class="docEmphasis">77</span>;</p>
<A NAME="ch01lev4sec249"></A><H5 class="docSection4Title"> os.symlink(src, dst)</H5>
<P class="docText">Create a soft link from path <TT>src</TT> to path <TT>dst</TT> on Unix-like systems. See the <TT>man</TT> page on the <TT>ln</TT> utility for more information.</P>
<p class="docText"><span class="docEmphRoman">S<span class="docEmphSmaller">EE</span> A<span class="docEmphSmaller">LSO</span></span>: 
os.link() <span class="docEmphasis">76;</span> os.readlink() <span class="docEmphasis">78;</span></p>
<A NAME="ch01lev4sec250"></A><H5 class="docSection4Title"> os.system(cmd)</H5>
<P class="docText">Execute the command <TT>cmd</TT> in a subshell. Unlike execution using <span class="docEmphasis"><TT>os.popen()</TT></span> the output of the executed process is not captured (but it may still echo to the same terminal as the current Python application). In some cases, you can use <span class="docEmphasis"><TT>os.system()</TT></span> on non-Windows systems to detach an application in a manner similar to <span class="docEmphasis"><TT>os.startfile()</TT> .</span> For example, under MacOSX, you could launch the TextEdit application with:</P>
<pre>
&gt;&gt;&gt; import os
&gt;&gt;&gt; cmd="/Applications/TextEdit.app/Contents/MacOS/TextEdit &amp;"
&gt;&gt;&gt; os.system(cmd)
0
</pre>
<p class="docText"><span class="docEmphRoman">S<span class="docEmphSmaller">EE</span> A<span class="docEmphSmaller">LSO</span></span>: 
os.popen() <span class="docEmphasis">77;</span> os.startfile() <span class="docEmphasis">79;</span> commands <span class="docEmphasis">73;</span></p>
<A NAME="ch01lev4sec251"></A><H5 class="docSection4Title"> os.tempnam([dir [,prefix]])</H5>
<P class="docText">Return a unique filename for a temporary file. If optional argument <TT>dir</TT> is specified, that directory will be used in the path; if <TT>prefix</TT> is specified, the file will have the indicated prefix. For most purposes, it is more secure to use <span class="docEmphasis"><TT>os.tmpfile()</TT></span> to directly obtain a file object rather than first generating a name.</P>
<p class="docText"><span class="docEmphRoman">S<span class="docEmphSmaller">EE</span> A<span class="docEmphSmaller">LSO</span></span>: 
tempfile <span class="docEmphasis">71;</span> os.tmpfile() <span class="docEmphasis">80;</span></p>
<A NAME="ch01lev4sec252"></A><H5 class="docSection4Title"> os.tmpfile()</H5>
<P class="docText">Return an "invisible" file object in update mode. This file does not create a directory entry, but simply acts as a transient buffer for data on the filesystem.</P>
<p class="docText"><span class="docEmphRoman">S<span class="docEmphSmaller">EE</span> A<span class="docEmphSmaller">LSO</span></span>: 
tempfile <span class="docEmphasis">71;</span> StringIO <span class="docEmphasis">153;</span> cStringIO <span class="docEmphasis">153;</span></p>
<A NAME="ch01lev4sec253"></A><H5 class="docSection4Title"> os.uname()</H5>
<P class="docText">Return detailed information about the current operating system on recent Unix-like systems. The returned 5-tuple contains sysname, nodename, release, version, and machine, each as descriptive strings.</P>
<A NAME="ch01lev4sec254"></A><H5 class="docSection4Title"> os.unlink(filename)</H5>
<P class="docText">Remove the file named <TT>filename</TT>. This function is identical to <span class="docEmphasis"><TT>os.remove()</TT></span>. If the file cannot be removed, an <TT>OSError</TT> is raised.</P>
<p class="docText"><span class="docEmphRoman">S<span class="docEmphSmaller">EE</span> A<span class="docEmphSmaller">LSO</span></span>: 
os.remove() <span class="docEmphasis">78;</span></p>
<A NAME="ch01lev4sec255"></A><H5 class="docSection4Title"> os.utime(pathname, times)</H5>
<P class="docText">Set the access and modification timestamps of file <TT>pathname</TT> to the tuple <TT>(atime, mtime)</TT> specified in <TT>times</TT>. Alternately, if <TT>times</TT> is <TT>None</TT>, set both timestamps to the current time.</P>
<p class="docText"><span class="docEmphRoman">S<span class="docEmphSmaller">EE</span> A<span class="docEmphSmaller">LSO</span></span>: 
time <span class="docEmphasis">86;</span> os.chmod() <span class="docEmphasis">75;</span> os.chown() <span class="docEmphasis">75;</span> os.stat() <span class="docEmphasis">79;</span></p>
<A NAME="ch01lev3sec41"></A><H5 class="docSection3Title"> CONSTANTS AND ATTRIBUTES</H5>
<A NAME="ch01lev4sec256"></A><H5 class="docSection4Title"> os.altsep</H5>
<P class="docText">Usually <TT>None</TT>, but an alternative path delimiter ("/") under Windows.</P>
<A NAME="ch01lev4sec257"></A><H5 class="docSection4Title"> os.curdir</H5>
<P class="docText">The string the operating system uses to refer to the current directory; for example, "." on Unix or ":" on Macintosh (before MacOSX).</P>
<A NAME="ch01lev4sec258"></A><H5 class="docSection4Title"> os.defpath</H5>
<P class="docText">The search path used by exec*p*() and spawn*p*() absent a PATH environment variable.</P>
<A NAME="ch01lev4sec259"></A><H5 class="docSection4Title"> os.environ</H5>
<P class="docText">A dictionary-like object containing the current environment.</P>
<pre>
&gt;&gt;&gt; os.environ['TERM']
'vt100'
&gt;&gt;&gt; os.environ['TERM'] = 'vt220'
&gt;&gt;&gt; os.getenv('TERM')
'vt220'
</pre>
<p class="docText"><span class="docEmphRoman">S<span class="docEmphSmaller">EE</span> A<span class="docEmphSmaller">LSO</span></span>: 
os.getenv() <span class="docEmphasis">75;</span> os.putenv() <span class="docEmphasis">78;</span></p>
<A NAME="ch01lev4sec260"></A><H5 class="docSection4Title"> os.linesep</H5>
<P class="docText">The string that delimits lines in a file; for example "\n" on Unix, "\r" on Macintosh, "\r\n" on Windows.</P>
<A NAME="ch01lev4sec261"></A><H5 class="docSection4Title"> os.name</H5>
<P class="docText">A string identifying the operating system the current Python interpreter is running on. Possible strings include <TT>posix</TT>, <TT>nt</TT>, <TT>dos</TT>, <TT>mac</TT>, <TT>os2</TT>, <TT>ce</TT>, <TT>java</TT>, and <TT>riscos</TT>.</P>
<A NAME="ch01lev4sec262"></A><H5 class="docSection4Title"> os.pardir</H5>
<P class="docText">The string the operating system uses to refer to the parent directory; for example, ".." on Unix or "::" on Macintosh (before MacOSX).</P>
<A NAME="ch01lev4sec263"></A><H5 class="docSection4Title"> os.pathsep</H5>
<P class="docText">The string that delimits search paths; for example, ";" on Windows or ":" on Unix.</P>
<A NAME="ch01lev4sec264"></A><H5 class="docSection4Title"> os.sep</H5>
<P class="docText">The string the operating system uses to refer to path delimiters; for example "/" on Unix, "\" on Windows, ":" on Macintosh.</P>
<p class="docText"><span class="docEmphRoman">S<span class="docEmphSmaller">EE</span> A<span class="docEmphSmaller">LSO</span></span>: 
sys <span class="docEmphasis">49;</span> os.path <span class="docEmphasis">65;</span></p>
<A NAME="ch01lev2sec10"></A><H4 class="docSection2Title">1.2.4 Special Data Values and Formats</H4>
<P><A NAME="ch01sb32"></A><TABLE CELLSPACING="0" WIDTH="90%" BORDER="1"><TR><TD>
<P class="docText"><span class="docEmphStrong">random </span>&#8226; <span class="docEmphStrong">Pseudo-random value generator</span></P></TD></TR></TABLE></P>
<P class="docText">Python provides better pseudo-random number generation than do most C libraries with a <TT>rand()</TT> function, but not good enough for cryptographic purposes. The period of Python's Wichmann-Hill generator is about 7 trillion (7e13), but that merely indicates how long it will take a particular seeded generator to cycle; a different seed will produce a different sequence of numbers. Python 2.3 uses the superior Mersenne Twister generator, which has a longer period and has been better analyzed. For practical purposes, pseudorandom numbers generated by Python are more than adequate for random-seeming behavior in applications.</P>
<P class="docText">The underlying pseudo-random numbers generated by the <span class="docEmphasis"><TT>random</TT></span> module can be mapped into a variety of nonuniform patterns and distributions. Moreover, you can capture and tinker with the state of a pseudo-random generator; you can even subclass the <span class="docEmphasis"><TT>random.Random</TT></span> class that operates behind the scenes. However, this latter sort of specialization is outside the scope of this book, and the class <span class="docEmphasis"><TT>random.Random</TT></span> and functions <span class="docEmphasis"><TT>random.getstate()</TT>, <TT>random.jumpahead()</TT></span>, and <span class="docEmphasis"><TT>random.setstate()</TT></span> are omitted from this discussion. The functions <span class="docEmphasis"><TT>random.whseed()</TT></span> and <span class="docEmphasis"><TT>random.randint()</TT></span> are deprecated.</P>
<A NAME="ch01lev3sec42"></A><H5 class="docSection3Title"> FUNCTIONS</H5>
<A NAME="ch01lev4sec265"></A><H5 class="docSection4Title"> random.betavariate(alpha, beta)</H5>
<P class="docText">Return a floating point value in the range [0.0, 1.0) with a beta distribution.</P>
<A NAME="ch01lev4sec266"></A><H5 class="docSection4Title"> random.choice(seq)</H5>
<P class="docText">Select a random element from the nonempty sequence <TT>seq</TT>.</P>
<A NAME="ch01lev4sec267"></A><H5 class="docSection4Title"> random.cunifvariate(mean, arc)</H5>
<P class="docText">Return a floating point value in the range [mean-arc/2, mean+arc/2) with a circular uniform distribution. Arguments and result are expressed in radians.</P>
<A NAME="ch01lev4sec268"></A><H5 class="docSection4Title"> random.expovariate(lambda_)</H5>
<P class="docText">Return a floating point value in the range [0.0, +inf) with an exponential distribution. The argument <TT>lambda_</TT> gives the <span class="docEmphasis">inverse</span> of the mean of the distribution.</P>
<pre>
&gt;&gt;&gt; import random
&gt;&gt;&gt; t1,t2 = 0,0
&gt;&gt;&gt; for x in range(100):
...     t1 += random.expovariate(1./20)
...     t2 += random.expovariate(20.)
...
&gt;&gt;&gt; print t1/100, t2/100
18.4021962198 0.0558234063338
</pre>
<A NAME="ch01lev4sec269"></A><H5 class="docSection4Title"> random.gamma(alpha, beta)</H5>
<P class="docText">Return a floating point value with a gamma distribution (not the gamma function).</P>
<A NAME="ch01lev4sec270"></A><H5 class="docSection4Title"> random.gauss(mu, sigma)</H5>
<P class="docText">Return a floating point value with a Gaussian distribution; the mean is <TT>mu</TT> and the sigma is <TT>sigma</TT>. <span class="docEmphasis"><TT>random.gauss()</TT></span> is slightly faster than <span class="docEmphasis"><TT>random.normalvariate()</TT></span>.</P>
<A NAME="ch01lev4sec271"></A><H5 class="docSection4Title"> random.lognormvariate(mu, sigma)</H5>
<P class="docText">Return a floating point value with a log normal distribution; the natural logarithm of this distribution is Gaussian with mean <TT>mu</TT> and sigma <TT>sigma</TT>.</P>
<A NAME="ch01lev4sec272"></A><H5 class="docSection4Title"> random.normalvariate(mu, sigma)</H5>
<P class="docText">Return a floating point value with a Gaussian distribution; the mean is <TT>mu</TT> and the sigma is <TT>sigma</TT>.</P>
<A NAME="ch01lev4sec273"></A><H5 class="docSection4Title"> random.paretovariate(alpha)</H5>
<P class="docText">Return a floating point value with a Pareto distribution. <TT>alpha</TT> specifies the shape parameter.</P>
<A NAME="ch01lev4sec274"></A><H5 class="docSection4Title"> random.random()</H5>
<P class="docText">Return a floating point value in the range [0.0, 1.0).</P>
<A NAME="ch01lev4sec275"></A><H5 class="docSection4Title"> random.randrange([start=0,] stop [,step=1])</H5>
<P class="docText">Return a random element from the specified range. Functionally equivalent to the expression <TT>random.choice(range(start,stop,step))</TT>, but it does not build the actual range object. Use <span class="docEmphasis"><TT>random.randrange()</TT></span> in place of the deprecated <span class="docEmphasis"><TT>random.randint()</TT></span>.</P>
<A NAME="ch01lev4sec276"></A><H5 class="docSection4Title"> random.seed([x=time.time()])</H5>
<P class="docText">Initialize the Wichmann-Hill generator. You do not necessarily <span class="docEmphasis">need</span> to call <span class="docEmphasis"><TT>random.seed()</TT></span>, since the current system time is used to initialize the generator upon module import. But if you wish to provide more entropy in the initial state, you may pass any hashable object as argument <TT>x</TT>. Your best choice for <TT>x</TT> is a positive long integer less than 27814431486575L, whose value is selected at random by independent means.</P>
<A NAME="ch01lev4sec277"></A><H5 class="docSection4Title"> random.shuffle(seq [,random=random.random])</H5>
<P class="docText">Permute the mutable sequence <TT>seq</TT> in place. An optional argument <TT>random</TT> may be specified to use an alternate random generator, but it is unlikely you will want to use one. Possible permutations get very big very quickly, so even for moderately sized sequences, not every permutation will occur.</P>
<A NAME="ch01lev4sec278"></A><H5 class="docSection4Title"> random.uniform(min, max)</H5>
<P class="docText">Return a random floating point value in the range [min, max).</P>
<A NAME="ch01lev4sec279"></A><H5 class="docSection4Title"> random.vonmisesvariate(mu, kappa)</H5>
<P class="docText">Return a floating point value with a von Mises distribution. <TT>mu</TT> is the mean angle expressed in radians, and <TT>kappa</TT> is the concentration parameter.</P>
<A NAME="ch01lev4sec280"></A><H5 class="docSection4Title"> random.weibullvariate(alpha, beta)</H5>
<P class="docText">Return a floating point value with a Weibull distribution. <TT>alpha</TT> is the scale parameter, and <TT>beta</TT> is the shape parameter.</P>
<P><A NAME="ch01sb33"></A><TABLE CELLSPACING="0" WIDTH="90%" BORDER="1"><TR><TD>
<P class="docText"><span class="docEmphStrong">struct &#8226; Create and read packed binary strings</span></P></TD></TR></TABLE></P>
<P class="docText">The <span class="docEmphasis"><TT>struct</TT></span> module allows you to encode compactly Python numeric values. This module may also be used to read C structs that use the same formats; some formatting codes are only useful for reading C structs. The exception <span class="docEmphasis"><TT>struct.error</TT></span> is raised if a format does not match its string or values.</P>
<P class="docText">A format string consists of a sequence of alphabetic formatting codes. Each code is represented by zero or more bytes in the encoded packed binary string. Each formatting code may be preceded by a number indicating a number of occurrences. The entire format string may be preceded by a global flag. If the flag <TT>@</TT> is used, platform-native data sizes and endianness are used. In all other cases, standard data sizes are used. The flag <TT>=</TT> explicitly indicates platform endianness; <TT>&lt;</TT> indicates little-endian representations; <TT>&gt;</TT> or <TT>!</TT> indicates big-endian representations.</P>
<P class="docText">The available formatting codes are listed below. The standard sizes are given (check your platform for its sizes if platform-native sizes are needed).</P>
<H5 class="docExampleTitle"><A NAME="ch01list14"></A> Formatting codes for struct module</H5>

<PRE>
x      pad byte                  0 bytes
c      char                      1 bytes
b      signed char               1 bytes
B      unsigned char             1 bytes
h      short int                 2 bytes
H      unsigned short            2 bytes
i      int                       4 bytes
I      unsigned int              4 bytes
l      long int                  4 bytes
L      unsigned long             4 bytes
q      long long int             8 bytes
Q      unsigned long long        8 bytes
f      float                     4 bytes
d      double                    8 bytes
s      string                    padded to size
p      Pascal string             padded to size
P      char pointer              4 bytes
</PRE>
<P class="docText">Some usage examples clarify the encoding:</P>
<pre>
&gt;&gt;&gt; import struct
&gt;&gt;&gt; struct.pack('5s5p2c', 'sss','ppp','c','c')
'sss\x00\x00\x03ppp\x00cc'
&gt;&gt;&gt; struct.pack('h', 1)
'\x00\x01'
&gt;&gt;&gt; struct.pack('I', 1)
'\x00\x00\x00\x01'
&gt;&gt;&gt; struct.pack('l', 1)
'\x00\x00\x00\x01'
&gt;&gt;&gt; struct.pack('&lt;l', 1)
'\x01\x00\x00\x00'
&gt;&gt;&gt; struct.pack('f', 1)
'?\x80\x00\x00'
&gt;&gt;&gt; struct.pack('hil', 1,2,3)
'\x00\x01\x00\x00\x00\x00\x00\x02\x00\x00\x00\x03'
</pre>
<A NAME="ch01lev3sec43"></A><H5 class="docSection3Title"> FUNCTIONS</H5>
<A NAME="ch01lev4sec281"></A><H5 class="docSection4Title"> struct.calcsize(fmt)</H5>
<P class="docText">Return the length of the string that corresponds to the format <TT>fmt</TT>.</P>
<A NAME="ch01lev4sec282"></A><H5 class="docSection4Title"> struct.pack(fmt, v1 [,v2 [...]])</H5>
<P class="docText">Return a string with values <TT>v1</TT>, et alia, packed according to the format <TT>fmt</TT>.</P>
<A NAME="ch01lev4sec283"></A><H5 class="docSection4Title"> struct.unpack(fmt, s)</H5>
<P class="docText">Return a tuple of values represented by string <TT>s</TT> packed according to the format <TT>fmt</TT>.</P>
<P><A NAME="ch01sb34"></A><TABLE CELLSPACING="0" WIDTH="90%" BORDER="1"><TR><TD>
<P class="docText"><span class="docEmphStrong">time </span>&#8226; <span class="docEmphStrong">Functions to manipulate date/time values</span></P></TD></TR></TABLE></P>
<P class="docText">The <span class="docEmphasis"><TT>time</TT></span> module is useful both for computing and displaying dates and time increments, and for simple benchmarking of applications and functions. For some purposes, eGenix.com's <span class="docEmphasis"><TT>mx.Date</TT></span> module is more useful for manipulating datetimes than is <span class="docEmphasis"><TT>time</TT></span>. You may obtain <span class="docEmphasis"><TT>mx.Date</TT></span> from:</P>
<BLOCKQUOTE><P><P class="docList">&lt;<A class="docLink" target="_blank" HREF="http://egenix.com/files/python/eGenix-mx-Extensions.html">http://egenix.com/files/python/eGenix-mx-Extensions.html</A>&gt;</P></P></BLOCKQUOTE>
<P class="docText">Time tuples—used by several functions—consist of year, month, day, hour, minute, second, weekday, Julian day, and Daylight Savings flag. All values are integers. Month, day, and Julian day (day of year) are one-based; hour, minute, second, and weekday are zero-based (Monday is 0). The Daylight Savings flag uses 1 for DST, 0 for Standard Time, and -1 for "best guess."</P>
<A NAME="ch01lev3sec44"></A><H5 class="docSection3Title"> CONSTANTS AND ATTRIBUTES</H5>
<A NAME="ch01lev4sec284"></A><H5 class="docSection4Title"> time.accept2dyear</H5>
<P class="docText">Boolean to allow two-digit years in date tuples. Default is true value, in which case the first matching date since <TT>time.gmtime(0)</TT> is extrapolated.</P>
<pre>
&gt;&gt;&gt; import time
&gt;&gt;&gt; time.accept2dyear
1
&gt;&gt;&gt; time.localtime(time.mktime((99,1,1,0,0,0,0,0,0)))
(1999, 1, 1, 0, 0, 0, 4, 1, 0)
&gt;&gt;&gt; time.gmtime(0)
(1970, 1, 1, 0, 0, 0, 3, 1, 0)
</pre>
<A NAME="ch01lev4sec285"></A><H5 class="docSection4Title"> time.altzone<br>time.daylight<br>time.timezone<br>time.tzname</H5>
<P class="docText">These several constants show information on the current timezone. Different locations use Daylight Savings adjustments during different portions of the year, usually but not always a one-hour adjustment. <span class="docEmphasis"><TT>time.daylight</TT></span> indicates only whether such an adjustment is available in <span class="docEmphasis"><TT>time.altzone</TT>. <TT>time.timezone</TT></span> indicates how many seconds west of UTC the current zone is; <span class="docEmphasis"><TT>time.altzone</TT></span> adjusts that for Daylight Savings if possible. <span class="docEmphasis"><TT>time.tzname</TT></span> gives a tuple of strings describing the current zone.</P>
<pre>
&gt;&gt;&gt; time.daylight, time.tzname
(1, ('EST', 'EDT'))
&gt;&gt;&gt; time.altzone, time.timezone
(14400, 18000)
</pre>
<A NAME="ch01lev3sec45"></A><H5 class="docSection3Title"> FUNCTIONS</H5>
<A NAME="ch01lev4sec286"></A><H5 class="docSection4Title"> time.asctime([tuple=time.localtime()])</H5>
<P class="docText">Return a string description of a time tuple.</P>
<pre>
&gt;&gt;&gt; time.asctime((2002, 10, 25, 1, 51, 48, 4, 298, 1))
'Fri Oct 25 01:51:48 2002'
</pre>
<p class="docText"><span class="docEmphRoman">S<span class="docEmphSmaller">EE</span> A<span class="docEmphSmaller">LSO</span></span>: 
time.ctime() <span class="docEmphasis">87;</span> time.strftime() <span class="docEmphasis">88;</span></p>
<A NAME="ch01lev4sec287"></A><H5 class="docSection4Title"> time.clock()</H5>
<P class="docText">Return the processor time for the current process. The raw value returned has little inherent meaning, but the value is guaranteed to increase roughly in proportion to the amount of CPU time used by the process. This makes <span class="docEmphasis"><TT>time.clock()</TT></span> useful for comparative benchmarking of various operations or approaches. The values returned should not be compared between different CPUs, OSs, and so on, but are meaningful on one machine. For example:</P>
<pre>
import time
start1 = time.clock()
approach_one()
time1 = time.clock()-start1
start2 = time.clock()
approach_two()
time2 = time.clock()-start2
if time1 &gt; time2:
    print "The second approach seems better"
else:
    print "The first approach seems better"
</pre>
<P class="docText">Always use <span class="docEmphasis"><TT>time.clock()</TT></span> for benchmarking rather than <span class="docEmphasis"><TT>time.time()</TT></span>. The latter is a low-resolution "wall clock" only.</P>
<A NAME="ch01lev4sec288"></A><H5 class="docSection4Title"> time.ctime([seconds=time.time()])</H5>
<P class="docText">Return a string description of <TT>seconds</TT> since epoch.</P>
<pre>
&gt;&gt;&gt; time.ctime(1035526125)
'Fri Oct 25 02:08:45 2002'
</pre>
<p class="docText"><span class="docEmphRoman">S<span class="docEmphSmaller">EE</span> A<span class="docEmphSmaller">LSO</span></span>: 
time.asctime() <span class="docEmphasis">87;</span></p>
<A NAME="ch01lev4sec289"></A><H5 class="docSection4Title"> time.gmtime([seconds=time.time()])</H5>
<P class="docText">Return a time tuple of <TT>seconds</TT> since epoch, giving Greenwich Mean Time.</P>
<pre>
&gt;&gt;&gt; time.gmtime(1035526125)
(2002, 10, 25, 6, 8, 45, 4, 298, 0)
</pre>
<p class="docText"><span class="docEmphRoman">S<span class="docEmphSmaller">EE</span> A<span class="docEmphSmaller">LSO</span></span>: 
time.localtime() <span class="docEmphasis">88;</span></p>
<A NAME="ch01lev4sec290"></A><H5 class="docSection4Title"> time.localtime([seconds=time.time()])</H5>
<P class="docText">Return a time tuple of <TT>seconds</TT> since epoch, giving the local time.</P>
<pre>
&gt;&gt;&gt; time.localtime(1035526125)
(2002, 10, 25, 2, 8, 45, 4, 298, 1)
</pre>
<p class="docText"><span class="docEmphRoman">S<span class="docEmphSmaller">EE</span> A<span class="docEmphSmaller">LSO</span></span>: 
time.gmtime() <span class="docEmphasis">88;</span> time.mktime() <span class="docEmphasis">88;</span></p>
<A NAME="ch01lev4sec291"></A><H5 class="docSection4Title"> time.mktime(tuple)</H5>
<P class="docText">Return a number of seconds since epoch corresponding to a time tuple.</P>
<pre>
&gt;&gt;&gt; time.mktime((2002, 10, 25, 2, 8, 45, 4, 298, 1))
1035526125.0
</pre>
<p class="docText"><span class="docEmphRoman">S<span class="docEmphSmaller">EE</span> A<span class="docEmphSmaller">LSO</span></span>: 
time.localtime() <span class="docEmphasis">88;</span></p>
<A NAME="ch01lev4sec292"></A><H5 class="docSection4Title"> time.sleep(seconds)</H5>
<P class="docText">Suspend execution for approximately <TT>seconds</TT> measured in "wall clock" time (not CPU time). The argument <TT>seconds</TT> is a floating point value (precision subject to system timer) and is fully thread safe.</P>
<A NAME="ch01lev4sec293"></A><H5 class="docSection4Title"> time.strftime(format [,tuple=time.localtime()])</H5>
<P class="docText">Return a custom string description of a time tuple. The format given in the string <TT>format</TT> may contain the following fields: <TT>%a/%A/%w</TT> for abbreviated/full/decimal weekday name; <TT>%b/%B/%m</TT> for abbreviated/full/decimal month; <TT>%y/%Y</TT> for abbreviated/full year; <TT>%d</TT> for day-of-month; <TT>%H/%I</TT> for 24/12 clock hour; <TT>%j</TT> for day-of-year; <TT>%M</TT> for minute; <TT>%p</TT> for AM/PM; <TT>%S</TT> for seconds; <TT>%U/%W</TT> for week-of-year (Sunday/Monday start); <TT>%c/%x/%X</TT> for locale-appropriate datetime/date/time; <TT>%Z</TT> for timezone name. Other characters may occur in the format also and will appear as literals (a literal <TT>%</TT> can be escaped).</P>
<pre>
&gt;&gt;&gt; import time
&gt;&gt;&gt; tuple = (2002, 10, 25, 2, 8, 45, 4, 298, 1)
&gt;&gt;&gt; time.strftime("%A, %B %d '%y (week %U)", tuple)
"Friday, October 25 '02 (week 42)"
</pre>
<p class="docText"><span class="docEmphRoman">S<span class="docEmphSmaller">EE</span> A<span class="docEmphSmaller">LSO</span></span>: 
time.asctime() <span class="docEmphasis">87;</span> time.ctime() <span class="docEmphasis">87;</span> time.strptime() <span class="docEmphasis">89;</span></p>
<A NAME="ch01lev4sec294"></A><H5 class="docSection4Title"> time.strptime(s [,format="%a %b %d %H:%M:%S %Y"])</H5>
<P class="docText">Return a time tuple based on a string description of a time. The format given in the string <TT>format</TT> follows the same rules as in <span class="docEmphasis"><TT>time.strftime()</TT></span>. Not available on most platforms.</P>
<p class="docText"><span class="docEmphRoman">S<span class="docEmphSmaller">EE</span> A<span class="docEmphSmaller">LSO</span></span>: 
time.strftime() <span class="docEmphasis">88;</span></p>
<A NAME="ch01lev4sec295"></A><H5 class="docSection4Title"> time.time()</H5>
<P class="docText">Return the number of seconds since the epoch for the current time. You can specifically determine the epoch using <TT>time.ctime(0)</TT>, but normally you will use other functions in the <span class="docEmphasis"><TT>time</TT></span> module to generate useful values. Even though <span class="docEmphasis"><TT>time.time()</TT></span> is also generally nondecreasing in its return values, you should use <span class="docEmphasis"><TT>time.clock()</TT></span> for benchmarking purposes.</P>
<pre>
&gt;&gt;&gt; time.ctime(0)
'Wed Dec 31 19:00:00 1969'
&gt;&gt;&gt; time.time()
1035585490.484154
&gt;&gt;&gt; time.ctime(1035585437)
'Fri Oct 25 18:37:17 2002'
</pre>
<p class="docText"><span class="docEmphRoman">S<span class="docEmphSmaller">EE</span> A<span class="docEmphSmaller">LSO</span></span>: 
time.clock() <span class="docEmphasis">87;</span> time.ctime() <span class="docEmphasis">87;</span></p>
<p class="docText"><span class="docEmphRoman">S<span class="docEmphSmaller">EE</span> A<span class="docEmphSmaller">LSO</span></span>: 
calendar <span class="docEmphasis">100;</span></p>
<a href="0321112547_10061533.html"><img src="FILES/pixel.gif" width="1" height="1" border="0"></a><ul></ul></td></tr></table>
<td></td>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<td class="tt1"><a href="NFO/lib.html">[ Team LiB ]</a></td><td valign="top" class="tt1" align="right">
          <a href="0321112547_ch01lev1sec1.html"><img src="FILES/btn_prev.gif" width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a>
          <a href="0321112547_ch01lev1sec3.html"><img src="FILES/btn_next.gif" width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a>
</td></table>
</body></html>
