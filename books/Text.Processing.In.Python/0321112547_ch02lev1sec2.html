<html><head>
<META http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<!--SafClassName="docSection1Title"--><!--SafTocEntry="2.2 Standard Modules"-->
<link rel="STYLESHEET" type="text/css" href="FILES/style.css">
<link rel="STYLESHEET" type="text/css" href="FILES/docsafari.css">
<style type="text/css">	.tt1    {font-size: 10pt;}</style>
</head>
<body>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<td class="tt1"><a href="NFO/lib.html">[ Team LiB ]</a></td><td valign="top" class="tt1" align="right">
	<a href="0321112547_ch02lev1sec1.html"><img src="FILES/btn_prev.gif" width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a>
	<a href="0321112547_ch02lev1sec3.html"><img src="FILES/btn_next.gif" width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a>
</td></table>
<br>
<table width="100%" border="0" cellspacing="0" cellpadding="0"><tr><td valign="top"><A NAME="ch02lev1sec2"></A><H3 class="docSection1Title" id="162609-962">2.2 Standard Modules</H3>
<A NAME="ch02lev2sec8"></A><H4 class="docSection2Title">2.2.1 Basic String Transformations</H4>
<P class="docText">The module <span class="docEmphasis"><TT>string</TT></span> forms the core of Python's text manipulation libraries. That module is certainly the place to look before other modules. Most of the methods in the <span class="docEmphasis"><TT>string</TT></span> module, you should note, have been copied to methods of string objects from Python 1.6+. Moreover, methods of string objects are a little bit faster to use than are the corresponding module functions. A few new methods of string objects do not have equivalents in the <span class="docEmphasis"><TT>string</TT></span> module, but are still documented here.</P>
<p class="docText"><span class="docEmphRoman">S<span class="docEmphSmaller">EE</span> A<span class="docEmphSmaller">LSO</span></span>: 
str <span class="docEmphasis">33;</span> UserString <span class="docEmphasis">33</span>;</p>
<P><A NAME="ch02sb01"></A><TABLE CELLSPACING="0" WIDTH="90%" BORDER="1"><TR><TD>
<P class="docText"><span class="docEmphStrong">string &#8226; A collection of string operations</span></P></TD></TR></TABLE></P>
<P class="docText">There are a number of general things to notice about the functions in the <span class="docEmphasis"><TT>string</TT></span> module (which is composed entirely of functions and constants; no classes).</P>
<span style="font-weight:bold"><OL class="docList" TYPE="1"><LI><span style="font-weight:normal"><P class="docList">Strings are immutable (as discussed in <A class="docLink" HREF="0321112547_ch01.html#ch01">Chapter 1</A>). This means that there is no such thing as changing a string "in place" (as we might do in many other languages, such as C, by changing the bytes at certain offsets within the string). Whenever a <span class="docEmphasis"><TT>string</TT></span> module function takes a string object as an argument, it returns a brand-new string object and leaves the original one as is. However, the very common pattern of binding the same name on the left of an assignment as was passed on the right side within the <span class="docEmphasis"><TT>string</TT></span> module function somewhat conceals this fact. For example:</P><pre>
&gt;&gt;&gt; import string
&gt;&gt;&gt; str = "Mary had a little lamb"
&gt;&gt;&gt; str = string.replace(str, 'had', 'ate')
&gt;&gt;&gt; str
'Mary ate a little lamb'
</pre><P class="docList">The first string object never gets modified per se; but since the first string object is no longer bound to any name after the example runs, the object is subject to garbage collection and will disappear from memory. In short, calling a <span class="docEmphasis"><TT>string</TT></span> module function will not change any existing strings, but rebinding a name can make it look like they changed.</P></span></LI><LI><span style="font-weight:normal"><P class="docList">Many <span class="docEmphasis"><TT>string</TT></span> module functions are now also available as string object methods. To use these string object methods, there is no need to import the <span class="docEmphasis"><TT>string</TT></span> module, and the expression is usually slightly more concise. Moreover, using a string object method is usually slightly faster than the corresponding <span class="docEmphasis"><TT>string</TT></span> module function. However, the most thorough documentation of each function/method that exists as both a <span class="docEmphasis"><TT>string</TT></span> module function and a string object method is contained in this reference to the <span class="docEmphasis"><TT>string</TT></span> module.</P></span></LI><LI><span style="font-weight:normal"><P class="docList">The form <TT>string.join(string.split (...))</TT> is a frequent Python idiom. A more thorough discussion is contained in the reference items for <span class="docEmphasis"><TT>string.join()</TT></span> and <span class="docEmphasis"><TT>string.split()</TT></span>, but in general, combining these two functions is very often a useful way of breaking down a text, processing the parts, then putting together the pieces.</P></span></LI><LI><span style="font-weight:normal"><P class="docList">Think about clever <span class="docEmphasis"><TT>string.replace()</TT></span> patterns. By combining multiple <span class="docEmphasis"><TT>string.replace()</TT></span> calls with use of "place holder" string patterns, a surprising range of results can be achieved (especially when also manipulating the intermediate strings with other techniques). See the reference item for <span class="docEmphasis"><TT>string.replace()</TT></span> for some discussion and examples.</P></span></LI><LI><span style="font-weight:normal"><P class="docList">A mutable string of sorts can be obtained by using built-in lists, or the <span class="docEmphasis"><TT>array</TT></span> module. Lists can contain a collection of substrings, each one of which may be replaced or modified individually. The <span class="docEmphasis"><TT>array</TT></span> module can define arrays of individual characters, each position modifiable, included with slice notation. The function <span class="docEmphasis"><TT>string.join()</TT></span> or the method <span class="docEmphasis"><TT>"".join()</TT></span> may be used to re-create true strings; for example:</P><pre>
&gt;&gt;&gt; 1st = ['spam','and','eggs']
&gt;&gt;&gt; 1st[2] = 'toast'
&gt;&gt;&gt; print ''.join(lst)
spamandtoast
&gt;&gt;&gt; print ' '.join(lst)
spam and toast
</pre><P class="docList">Or:</P><pre>
&gt;&gt;&gt; import array
&gt;&gt;&gt; a = array.array('c','spam and eggs')
&gt;&gt;&gt; print ''.join(a)
spam and eggs
&gt;&gt;&gt; a[0] = 'S'
&gt;&gt;&gt; print ''.join(a)
Spam and eggs
&gt;&gt;&gt; a[-4:] = array.array('c','toast')
&gt;&gt;&gt; print ''.join(a)
Spam and toast
</pre></span></LI></OL></span>
<A NAME="ch02lev3sec2"></A><H5 class="docSection3Title"> CONSTANTS</H5>
<P class="docText">The <span class="docEmphasis"><TT>string</TT></span> module contains constants for a number of frequently used collections of characters. Each of these constants is itself simply a string (rather than a list, tuple, or other collection). As such, it is easy to define constants alongside those provided by the <span class="docEmphasis"><TT>string</TT></span> module, should you need them. For example:</P>
<pre>
&gt;&gt;&gt; import string
&gt;&gt;&gt; string.brackets = "[]{}()&lt;&gt;"
&gt;&gt;&gt; print string.brackets
[]{}()&lt;&gt;
</pre>
<A NAME="ch02lev4sec1"></A><H5 class="docSection4Title"> string.digits</H5>
<P class="docText">The decimal numerals ("0123456789").</P>
<A NAME="ch02lev4sec2"></A><H5 class="docSection4Title"> string.hexdigits</H5>
<P class="docText">The hexadecimal numerals ("0123456789abcdefABCDEF").</P>
<A NAME="ch02lev4sec3"></A><H5 class="docSection4Title"> string.octdigits</H5>
<P class="docText">The octal numerals ("01234567").</P>
<A NAME="ch02lev4sec4"></A><H5 class="docSection4Title"> string.lowercase</H5>
<P class="docText">The lowercase letters; can vary by language. In English versions of Python (most systems):</P>
<pre>
&gt;&gt;&gt; import string
&gt;&gt;&gt; string.lowercase
'abcdefghijklmnopqrstuvwxyz'
</pre>
<P class="docText">You should not modify <span class="docEmphasis"><TT>string.lowercase</TT></span> for a source text language, but rather define a new attribute, such as <TT>string.spanish_lowercase</TT> with an appropriate string (some methods depend on this constant).</P>
<A NAME="ch02lev4sec5"></A><H5 class="docSection4Title"> string.uppercase</H5>
<P class="docText">The uppercase letters; can vary by language. In English versions of Python (most systems):</P>
<pre>
&gt;&gt;&gt; import string
&gt;&gt;&gt; string.uppercase
'ABCDEFGHIJKLMNOPQRSTUVWXYZ'
</pre>
<P class="docText">You should not modify <span class="docEmphasis"><TT>string.uppercase</TT></span> for a source text language, but rather define a new attribute, such as <TT>string.spanish_uppercase</TT> with an appropriate string (some methods depend on this constant).</P>
<A NAME="ch02lev4sec6"></A><H5 class="docSection4Title"> string.letters</H5>
<P class="docText">All the letters (string.lowercase+string.uppercase).</P>
<A NAME="ch02lev4sec7"></A><H5 class="docSection4Title"> string.punctuation</H5>
<P class="docText">The characters normally considered as punctuation; can vary by language. In English versions of Python (most systems):</P>
<pre>
&gt;&gt;&gt; import string
&gt;&gt;&gt; string.punctuation
'!"#$%&amp;\'()*+,-./:;&lt;=&gt;?@[\\]^_'{|}~'
</pre>
<A NAME="ch02lev4sec8"></A><H5 class="docSection4Title"> string.whitespace</H5>
<P class="docText">The "empty" characters. Normally these consist of tab, linefeed, vertical tab, formfeed, carriage return, and space (in that order):</P>
<pre>
&gt;&gt;&gt; import string
&gt;&gt;&gt; string.whitespace
'\011\012\013\014\015 '
</pre>
<P class="docText">You should not modify <span class="docEmphasis"><TT>string.whitespace</TT></span> (some methods depend on this constant).</P>
<A NAME="ch02lev4sec9"></A><H5 class="docSection4Title"> string.printable</H5>
<P class="docText">All the characters that can be printed to any device; can vary by language (string.digits+string.letters+string.punctuation+string.whitespace).</P>
<A NAME="ch02lev3sec3"></A><H5 class="docSection3Title"> FUNCTIONS</H5>
<A NAME="ch02lev4sec10"></A><H5 class="docSection4Title"> string.atof(s=...)</H5>
<P class="docText">Deprecated. Use <span class="docEmphasis"><TT>float()</TT></span>.</P>
<P class="docText">Converts a string to a floating point value.</P>
<p class="docText"><span class="docEmphRoman">S<span class="docEmphSmaller">EE</span> A<span class="docEmphSmaller">LSO</span></span>: 
eval() <span class="docEmphasis">445</span>; float() <span class="docEmphasis">422</span>;</p>
<A NAME="ch02lev4sec11"></A><H5 class="docSection4Title"> string.atoi(s=...[,base=10])</H5>
<P class="docText">Deprecated with Python 2.0. Use <span class="docEmphasis"><TT>int()</TT></span> if no custom base is needed or if using Python 2.0+.</P>
<P class="docText">Converts a string to an integer value (if the string should be assumed to be in a base other than 10, the base may be specified as the second argument).</P>
<p class="docText"><span class="docEmphRoman">S<span class="docEmphSmaller">EE</span> A<span class="docEmphSmaller">LSO</span></span>: 
eval() <span class="docEmphasis">445</span>; int() <span class="docEmphasis">421</span>; long() <span class="docEmphasis">422</span>;</p>
<A NAME="ch02lev4sec12"></A><H5 class="docSection4Title"> string.atol(s=...[,base=10])</H5>
<P class="docText">Deprecated with Python 2.0. Use <span class="docEmphasis"><TT>long()</TT></span> if no custom base is needed or if using Python 2.0+.</P>
<P class="docText">Converts a string to an unlimited length integer value (if the string should be assumed to be in a base other than 10, the base may be specified as the second argument).</P>
<p class="docText"><span class="docEmphRoman">S<span class="docEmphSmaller">EE</span> A<span class="docEmphSmaller">LSO</span></span>: 
eval() <span class="docEmphasis">445</span>; long() <span class="docEmphasis">422</span>; int() <span class="docEmphasis">421</span>;</p>
<A NAME="ch02lev4sec13"></A><H5 class="docSection4Title"> string.capitalize(s=...)<br>"".capitalize()</H5>
<P class="docText">Return a string consisting of the initial character converted to uppercase (if applicable), and all other characters converted to lowercase (if applicable):</P>
<pre>
&gt;&gt;&gt; import string
&gt;&gt;&gt; string.capitalize("mary had a little lamb!")
'Mary had a little lamb!'
&gt;&gt;&gt; string.capitalize("Mary had a Little Lamb!")
'Mary had a little lamb!'
&gt;&gt;&gt; string.capitalize("2 Lambs had Mary!")
'2 lambs had mary!'
</pre>
<P class="docText">For Python 1.6+, use of a string object method is marginally faster and is stylistically preferred in most cases:</P>
<pre>
&gt;&gt;&gt; "mary had a little lamb".capitalize()
'Mary had a little lamb'
</pre>
<p class="docText"><span class="docEmphRoman">S<span class="docEmphSmaller">EE</span> A<span class="docEmphSmaller">LSO</span></span>: 
string.capwords() <span class="docEmphasis">133</span>; string.lower() <span class="docEmphasis">138</span>;</p>
<A NAME="ch02lev4sec14"></A><H5 class="docSection4Title"> string.capwords(s=...)<br>"".title()</H5>
<P class="docText">Return a string consisting of the capitalized words. An equivalent expression is:</P>
<pre>
string.join(map(string.capitalize,string.split(s))
</pre>
<P class="docText">But <span class="docEmphasis"><TT>string.capwords()</TT></span> is a clearer way of writing it. An effect of this implementation is that whitespace is "normalized" by the process:</P>
<pre>
&gt;&gt;&gt; import string
&gt;&gt;&gt; string.capwords("mary HAD a little lamb!")
'Mary Had A Little Lamb!'
&gt;&gt;&gt; string.capwords("Mary     had a      Little Lamb!")
'Mary Had A Little Lamb!'
</pre>
<P class="docText">With the creation of string methods in Python 1.6, the module function <span class="docEmphasis"><TT>string.capwords()</TT></span> was renamed as a string method to <span class="docEmphasis"><TT>"".title()</TT></span>.</P>
<p class="docText"><span class="docEmphRoman">S<span class="docEmphSmaller">EE</span> A<span class="docEmphSmaller">LSO</span></span>: 
string.capitalize() <span class="docEmphasis">132</span>; string.lower() <span class="docEmphasis">138</span>; "".istitle() <span class="docEmphasis">136;</span></p>
<A NAME="ch02lev4sec15"></A><H5 class="docSection4Title"> string.center(s=. . . , width=...)<br>"".center(width)</H5>
<P class="docText">Return a string with <TT>s</TT> padded with symmetrical leading and trailing spaces (but not truncated) to occupy length <TT>width</TT> (or more).</P>
<pre>
&gt;&gt;&gt; import string
&gt;&gt;&gt; string.center(width=30,s="Mary had a little lamb")
'    Mary had a little lamb '
&gt;&gt;&gt; string.center("Mary had a little lamb", 5)
'Mary had a little lamb'
</pre>
<P class="docText">For Python 1.6+, use of a string object method is stylistically preferred in many cases:</P>
<pre>
&gt;&gt;&gt; "Mary had a little lamb".center(25)
'  Mary had a little lamb '
</pre>
<p class="docText"><span class="docEmphRoman">S<span class="docEmphSmaller">EE</span> A<span class="docEmphSmaller">LSO</span></span>: 
string.ljust() <span class="docEmphasis">138;</span> string.rjust() <span class="docEmphasis">141</span>;</p>
<A NAME="ch02lev4sec16"></A><H5 class="docSection4Title"> string.count(s, sub [,start [,end]])<br>"".count(sub [,start [,end]])</H5>
<P class="docText">Return the number of nonoverlapping occurrences of <TT>sub</TT> in <TT>s</TT>. If the optional third or fourth arguments are specified, only the corresponding slice of <TT>s</TT> is examined.</P>
<pre>
&gt;&gt;&gt; import string
&gt;&gt;&gt; string.count("mary had a little lamb", "a")
4
&gt;&gt;&gt; string.count("mary had a little lamb", "a", 3, 10)
2
</pre>
<P class="docText">For Python 1.6+, use of a string object method is stylistically preferred in many cases:</P>
<pre>
&gt;&gt;&gt; 'mary had a little lamb'.count("a")
4
</pre>
<A NAME="ch02lev4sec17"></A><H5 class="docSection4Title"> "".endswith(suffix [,start [,end]])</H5>
<P class="docText">This string method does not have an equivalent in the <span class="docEmphasis"><TT>string</TT></span> module. Return a Boolean value indicating whether the string ends with the suffix <TT>suffix</TT>. If the optional second argument <TT>start</TT> is specified, only consider the terminal substring after offset <TT>start</TT>. If the optional third argument <TT>end</TT> is given, only consider the slice <TT>[start:end]</TT>.</P>
<p class="docText"><span class="docEmphRoman">S<span class="docEmphSmaller">EE</span> A<span class="docEmphSmaller">LSO</span></span>: 
"".startswith() <span class="docEmphasis">144</span>; string.find() <span class="docEmphasis">135;</span></p>
<A NAME="ch02lev4sec18"></A><H5 class="docSection4Title"> string.expandtabs(s=...[,tabsize=8])<br>"".expandtabs([,tabsize=8])</H5>
<P class="docText">Return a string with tabs replaced by a variable number of spaces. The replacement causes text blocks to line up at "tab stops." If no second argument is given, the new string will line up at multiples of 8 spaces. A newline implies a new set of tab stops.</P>
<pre>
&gt;&gt;&gt; import string
&gt;&gt;&gt; s = 'mary\011had a little lamb'
&gt;&gt;&gt; print s
mary    had a little lamb
&gt;&gt;&gt; string.expandtabs(s, 16)
'mary            had a little lamb'
&gt;&gt;&gt; string.expandtabs(tabsize=l, s=s)
'mary had a little lamb'
</pre>
<P class="docText">For Python 1.6+, use of a string object method is stylistically preferred in many cases:</P>
<pre>
&gt;&gt;&gt; 'mary\011had a little lamb'.expandtabs(25)
'mary                     had a little lamb'
</pre>
<A NAME="ch02lev4sec19"></A><H5 class="docSection4Title"> string.find(s, sub [,start [,end]])<br>"".find(sub [,start [,end]])</H5>
<P class="docText">Return the index position of the first occurrence of <TT>sub</TT> in <TT>s</TT>. If the optional third or fourth arguments are specified, only the corresponding slice of <TT>s</TT> is examined (but result is position in s as a whole). Return -1 if no occurrence is found. Position is zero-based, as with Python list indexing:</P>
<pre>
&gt;&gt;&gt; import string
&gt;&gt;&gt; string.find("mary had a little lamb", "a")
1
&gt;&gt;&gt; string.find("mary had a little lamb", "a", 3, 10)
6
&gt;&gt;&gt; string.find("mary had a little lamb", "b")
21
&gt;&gt;&gt; string.find("mary had a little lamb", "b", 3, 10)
-1
</pre>
<P class="docText">For Python 1.6+, use of a string object method is stylistically preferred in many cases:</P>
<pre>
&gt;&gt;&gt; 'mary had a little lamb'.find("ad")
6
</pre>
<p class="docText"><span class="docEmphRoman">S<span class="docEmphSmaller">EE</span> A<span class="docEmphSmaller">LSO</span></span>: 
string.index() <span class="docEmphasis">135;</span> string.rfind() <span class="docEmphasis">140</span>;</p>
<A NAME="ch02lev4sec20"></A><H5 class="docSection4Title"> string.index(s, sub [,start [,end]])<br>"".index(sub [,start [,end]])</H5>
<P class="docText">Return the same value as does <span class="docEmphasis"><TT>string.find()</TT></span> with same arguments, except raise <TT>ValueError</TT> instead of returning -1 when sub does not occur in s.</P>
<pre>
&gt;&gt;&gt; import string
&gt;&gt;&gt; string.index("mary had a little lamb", "b")
21
&gt;&gt;&gt; string.index("mary had a little lamb", "b", 3, 10)
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in ?
  File "d:/py20sl/lib/string.py", line 139, in index
    return s.index(*args)
ValueError: substring not found in string.index
</pre>
<P class="docText">For Python 1.6+, use of a string object method is stylistically preferred in many cases:</P>
<pre>
&gt;&gt;&gt; 'mary had a little lamb'.index("ad")
6
</pre>
<p class="docText"><span class="docEmphRoman">S<span class="docEmphSmaller">EE</span> A<span class="docEmphSmaller">LSO</span></span>: 
string.find() <span class="docEmphasis">135;</span> string.rindex() <span class="docEmphasis">141;</span></p>
<P class="docText">Several string methods that return Boolean values indicating whether a string has a certain property. None of the <TT>.is*()</TT> methods, however, have equivalents in the <span class="docEmphasis"><TT>string</TT></span> module:</P>
<A NAME="ch02lev4sec21"></A><H5 class="docSection4Title"> "".isalpha()</H5>
<P class="docText">Return a true value if all the characters are alphabetic.</P>
<A NAME="ch02lev4sec22"></A><H5 class="docSection4Title"> "".isalnum()</H5>
<P class="docText">Return a true value if all the characters are alphanumeric.</P>
<A NAME="ch02lev4sec23"></A><H5 class="docSection4Title"> "".isdigit()</H5>
<P class="docText">Return a true value if all the characters are digits.</P>
<A NAME="ch02lev4sec24"></A><H5 class="docSection4Title"> "".islower()</H5>
<P class="docText">Return a true value if all the characters are lowercase and there is at least one cased character:</P>
<pre>
&gt;&gt;&gt; "ab123".islower(), '123'.islower(), 'Ab123'.islower()
(1, 0, 0)
</pre>
<p class="docText"><span class="docEmphRoman">S<span class="docEmphSmaller">EE</span> A<span class="docEmphSmaller">LSO</span></span>: 
"".lower() <span class="docEmphasis">138;</span></p>
<A NAME="ch02lev4sec25"></A><H5 class="docSection4Title"> "".isspace()</H5>
<P class="docText">Return a true value if all the characters are whitespace.</P>
<A NAME="ch02lev4sec26"></A><H5 class="docSection4Title"> "".istitle()</H5>
<P class="docText">Return a true value if all the string has title casing (each word capitalized).</P>
<p class="docText"><span class="docEmphRoman">S<span class="docEmphSmaller">EE</span> A<span class="docEmphSmaller">LSO</span></span>: 
"".title() <span class="docEmphasis">133;</span></p>
<A NAME="ch02lev4sec27"></A><H5 class="docSection4Title"> "".isupper()</H5>
<P class="docText">Return a true value if all the characters are uppercase and there is at least one cased character.</P>
<p class="docText"><span class="docEmphRoman">S<span class="docEmphSmaller">EE</span> A<span class="docEmphSmaller">LSO</span></span>: 
"".upper() <span class="docEmphasis">146;</span></p>
<A NAME="ch02lev4sec28"></A><H5 class="docSection4Title"> string.join(words=...[,sep=" "])<br>"".join (words)</H5>
<P class="docText">Return a string that results from concatenating the elements of the list <TT>words</TT> together, with <TT>sep</TT> between each. The function <span class="docEmphasis"><TT>string.join()</TT></span> differs from all other <span class="docEmphasis"><TT>string</TT></span> module functions in that it takes a list (of strings) as a primary argument, rather than a string.</P>
<P class="docText">It is worth noting <span class="docEmphasis"><TT>string.join()</TT></span> and <span class="docEmphasis"><TT>string.split()</TT></span> are inverse functions if <TT>sep</TT> is specified to both; in other words, <TT>string.join(string.split(s,sep),sep)==s</TT> for all <TT>s</TT> and <TT>sep</TT>.</P>
<P class="docText">Typically, <span class="docEmphasis"><TT>string.join()</TT></span> is used in contexts where it is natural to generate lists of strings. For example, here is a small program to output the list of all-capital words from STDIN to STDOUT, one per line:</P>
<H5 class="docExampleTitle"><A NAME="ch02list08"></A> list_capwords.py</H5>

<PRE>
import string,sys
capwords = []

for line in sys.stdin.readlines():
    for word in line.split():
        if word == word.upper() and word.isalpha():
            capwords.append(word)
print string.join(capwords, '\n')
</PRE>
<P class="docText">The technique in the sample <TT>list_capwords.py</TT> script can be considerably more efficient than building up a string by direct concatenation. However, Python 2.0's augmented assignment reduces the performance difference:</P>
<pre>
&gt;&gt;&gt; import string
&gt;&gt;&gt; s = "Mary had a little lamb"
&gt;&gt;&gt; t = "its fleece was white as snow"
&gt;&gt;&gt; s = s +" "+ t    # relatively "expensive" for big strings
&gt;&gt;&gt; s += " " + t     # "cheaper" than Python 1.x style
&gt;&gt;&gt; 1st = [s]
&gt;&gt;&gt; lst.append(t)    # "cheapest" way of building long string
&gt;&gt;&gt; s = string.join(lst)
</pre>
<P class="docText">For Python 1.6+, use of a string object method is stylistically preferred in some cases. However, just as <span class="docEmphasis"><TT>string.join()</TT></span> is special in taking a list as a first argument, the string object method <span class="docEmphasis"><TT>"".join()</TT></span> is unusual in being an operation on the (optional) <TT>sep</TT> string, not on the (required) <TT>words</TT> list (this surprises many new Python programmers).</P>
<p class="docText"><span class="docEmphRoman">S<span class="docEmphSmaller">EE</span> A<span class="docEmphSmaller">LSO</span></span>: 
string.split() <span class="docEmphasis">142;</span></p>
<A NAME="ch02lev4sec29"></A><H5 class="docSection4Title"> string.joinfields(...)</H5>
<P class="docText">Identical to <span class="docEmphasis"><TT>string.join().</TT></span></P>
<A NAME="ch02lev4sec30"></A><H5 class="docSection4Title"> string.ljust(s=..., width=...)<br>"".Ijust(width)</H5>
<P class="docText">Return a string with <TT>s</TT> padded with trailing spaces (but not truncated) to occupy length <TT>width</TT> (or more).</P>
<pre>
&gt;&gt;&gt; import string
&gt;&gt;&gt; string.ljust(width=30,s="Mary had a little lamb")
'Mary had a little lamb        '
&gt;&gt;&gt; string.ljust("Mary had a little lamb", 5)
'Mary had a little lamb'
</pre>
<P class="docText">For Python 1.6+, use of a string object method is stylistically preferred in many cases:</P>
<pre>
&gt;&gt;&gt; "Mary had a little lamb".ljust(25)
'Mary had a little lamb   '
</pre>
<p class="docText"><span class="docEmphRoman">S<span class="docEmphSmaller">EE</span> A<span class="docEmphSmaller">LSO</span></span>: 
string.rjust() <span class="docEmphasis">141;</span> string.center() <span class="docEmphasis">133;</span></p>
<A NAME="ch02lev4sec31"></A><H5 class="docSection4Title"> string.lower(s=...)<br>"".lower()</H5>
<P class="docText">Return a string with any uppercase letters converted to lowercase.</P>
<pre>
&gt;&gt;&gt; import string
&gt;&gt;&gt; string.lower("mary HAD a little lamb!")
'mary had a little lamb!'
&gt;&gt;&gt; string.lower("Mary had a Little Lamb!")
'mary had a little lamb!'
</pre>
<P class="docText">For Python 1.6+, use of a string object method is stylistically preferred in many cases:</P>
<pre>
&gt;&gt;&gt; "Mary had a Little Lamb!".lower()
'mary had a little lamb!'
</pre>
<p class="docText"><span class="docEmphRoman">S<span class="docEmphSmaller">EE</span> A<span class="docEmphSmaller">LSO</span></span>: 
string.upper() <span class="docEmphasis">146;</span></p>
<A NAME="ch02lev4sec32"></A><H5 class="docSection4Title"> string.lstrip(s=...)<br>"".lstrip([chars=string.whitespace])</H5>
<P class="docText">Return a string with leading whitespace characters removed. For Python 1.6+, use of a string object method is stylistically preferred in many cases:</P>
<pre>
&gt;&gt;&gt; import string
&gt;&gt;&gt; s = """
...     Mary had a little lamb      \011"""
&gt;&gt;&gt; string.lstrip(s)
'Mary had a little lamb      \011'
&gt;&gt;&gt; s.lstrip()
'Mary had a little lamb      \011'
</pre>
<P class="docText">Python 2.3+ accepts the optional argument <TT>chars</TT> to the string object method. All characters in the string <TT>chars</TT> will be removed.</P>
<p class="docText"><span class="docEmphRoman">S<span class="docEmphSmaller">EE</span> A<span class="docEmphSmaller">LSO</span></span>: 
string.rstrip() <span class="docEmphasis">142;</span> string.strip() <span class="docEmphasis">144;</span></p>
<A NAME="ch02lev4sec33"></A><H5 class="docSection4Title"> string.maketrans(from, to)</H5>
<P class="docText">Return a translation table string for use with <span class="docEmphasis"><TT>string.translate()</TT> .</span> The strings <TT>from</TT> and <TT>to</TT> must be the same length. A translation table is a string of 256 successive byte values, where each position defines a translation from the <span class="docEmphasis"><TT>chr()</TT></span> value of the index to the character contained at that index position.</P>
<pre>
&gt;&gt;&gt; import string
&gt;&gt;&gt; ord('A')
65
&gt;&gt;&gt; ord('z')
122
&gt;&gt;&gt; string.maketrans('ABC','abc')[65:123]
'abcDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_'abcdefghijklmnopqrstuvwxyz'
&gt;&gt;&gt; string.maketrans('ABCxyz','abcXYZ')[65:123]
'abcDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_'abcdefghijklmnopqrstuvwXYZ'
</pre>
<p class="docText"><span class="docEmphRoman">S<span class="docEmphSmaller">EE</span> A<span class="docEmphSmaller">LSO</span></span>: 
string.translate() <span class="docEmphasis">145;</span></p>
<A NAME="ch02lev4sec34"></A><H5 class="docSection4Title"> string.replace(s=..., old=..., new=...[,maxsplit=...])<br>"".replace(old, new [,maxsplit])</H5>
<P class="docText">Return a string based on <TT>s</TT> with occurrences of <TT>old</TT> replaced by <TT>new</TT>. If the fourth argument <TT>maxsplit</TT> is specified, only replace <TT>maxsplit</TT> initial occurrences.</P>
<pre>
&gt;&gt;&gt; import string
&gt;&gt;&gt; string.replace("Mary had a little lamb", "a little", "some")
'Mary had some lamb'
</pre>
<P class="docText">For Python 1.6+, use of a string object method is stylistically preferred in many cases:</P>
<pre>
&gt;&gt;&gt; "Mary had a little lamb".replace("a little", "some")
'Mary had some lamb'
</pre>
<P class="docText">A common "trick" involving <span class="docEmphasis"><TT>string.replace()</TT></span> is to use it multiple times to achieve a goal. Obviously, simply to replace several different substrings in a string, multiple <span class="docEmphasis"><TT>string.replace()</TT></span> operations are almost inevitable. But there is another class of cases where <span class="docEmphasis"><TT>string.replace()</TT></span> can be used to create an intermediate string with "placeholders" for an original substring in a particular context. The same goal can always be achieved with regular expressions, but sometimes staged <span class="docEmphasis"><TT>string.replace()</TT></span> operations are both faster and easier to program:</P>
<pre>
&gt;&gt;&gt; import string
&gt;&gt;&gt; line = 'variable = val      # see comments #3 and #4'
&gt;&gt;&gt; # we'd like '#3' and '#4' spelled out within comment
&gt;&gt;&gt; string.replace(line,'#','number ')       # doesn't work
'variable = val      number  see comments number 3 and number 4'
&gt;&gt;&gt; place_holder=string.replace(line,' # ',' !!! ') # insrt plcholder
&gt;&gt;&gt; place_holder
'variable = val      !!! see comments #3 and #4'
&gt;&gt;&gt; place_holder=place_holder.replace('#','number ') # almost there
&gt;&gt;&gt; place_holder
'variable = val      !!! see comments number 3 and number 4'
&gt;&gt;&gt; line = string.replace(place_holder,'!!!','#') # restore orig
&gt;&gt;&gt; line
'variable = val      # see comments number 3 and number 4'
</pre>
<P class="docText">Obviously, for jobs like this, a placeholder must be chosen so as not ever to occur within the strings undergoing "staged transformation"; but that should be possible generally since placeholders may be as long as needed.</P>
<p class="docText"><span class="docEmphRoman">S<span class="docEmphSmaller">EE</span> A<span class="docEmphSmaller">LSO</span></span>: 
string.translate() <span class="docEmphasis">145;</span> mx.TextTools.replace() <span class="docEmphasis">314</span><SUB>;</SUB></p>
<A NAME="ch02lev4sec35"></A><H5 class="docSection4Title"> string.rfind(s, sub [,start [,end]])<br>"".rfind(sub [,start [,end]])</H5>
<P class="docText">Return the index position of the last occurrence of <TT>sub</TT> in <TT>s</TT>. If the optional third or fourth arguments are specified, only the corresponding slice of <TT>s</TT> is examined (but result is position in <TT>s</TT> as a whole). Return -1 if no occurrence is found. Position is zero-based, as with Python list indexing:</P>
<pre>
&gt;&gt;&gt; import string
&gt;&gt;&gt; string.rfind("mary had a little lamb", "a")
19
&gt;&gt;&gt; string.rfind("mary had a little lamb", "a", 3, 10)
9
&gt;&gt;&gt; string.rfind("mary had a little lamb", "b")
21
&gt;&gt;&gt; string.rfind("mary had a little lamb", "b", 3, 10)
-1
</pre>
<P class="docText">For Python 1.6+, use of a string object method is stylistically preferred in many cases:</P>
<pre>
&gt;&gt;&gt; 'mary had a little lamb'.rfind("ad")
6
</pre>
<p class="docText"><span class="docEmphRoman">S<span class="docEmphSmaller">EE</span> A<span class="docEmphSmaller">LSO</span></span>: 
string.rindex() <span class="docEmphasis">141;</span> string.find() <span class="docEmphasis">135;</span></p>
<A NAME="ch02lev4sec36"></A><H5 class="docSection4Title"> string.rindex(s, sub [,start [,end]])<br>"".rindex(sub [,start [,end]])</H5>
<P class="docText">Return the same value as does <span class="docEmphasis"><TT>string.rfind()</TT></span> with same arguments, except raise <TT>ValueError</TT> instead of returning -1 when sub does not occur in <TT>s</TT>.</P>
<pre>
&gt;&gt;&gt; import string
&gt;&gt;&gt; string.rindex("mary had a little lamb", "b")
21
&gt;&gt;&gt; string.rindex("mary had a little lamb", "b", 3, 10)
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in ?
  File "d:/py20sl/lib/string.py", line 148, in rindex
    return s.rindex(*args)
ValueError: substring not found in string.rindex
</pre>
<P class="docText">For Python 1.6+, use of a string object method is stylistically preferred in many cases:</P>
<pre>
&gt;&gt;&gt; 'mary had a little lamb'.index("ad")
6
</pre>
<p class="docText"><span class="docEmphRoman">S<span class="docEmphSmaller">EE</span> A<span class="docEmphSmaller">LSO</span></span>: 
string.rfind() <span class="docEmphasis">140;</span> string.index() <span class="docEmphasis">135;</span></p>
<A NAME="ch02lev4sec37"></A><H5 class="docSection4Title"> string.rjust(s=..., width=...)<br>"".rjust(width)</H5>
<P class="docText">Return a string with <TT>s</TT> padded with leading spaces (but not truncated) to occupy length <TT>width</TT> (or more).</P>
<pre>
&gt;&gt;&gt; import string
&gt;&gt;&gt; string.rjust(width=30,s="Mary had a little lamb")
'        Mary had a little lamb'
&gt;&gt;&gt; string.rjust("Mary had a little lamb", 5)
'Mary had a little lamb'
</pre>
<P class="docText">For Python 1.6+, use of a string object method is stylistically preferred in many cases:</P>
<pre>
&gt;&gt;&gt; "Mary had a little lamb".rjust(25)
'   Mary had a little lamb'
</pre>
<p class="docText"><span class="docEmphRoman">S<span class="docEmphSmaller">EE</span> A<span class="docEmphSmaller">LSO</span></span>: 
string.ljust() <span class="docEmphasis">138;</span> string.center() <span class="docEmphasis">133;</span></p>
<A NAME="ch02lev4sec38"></A><H5 class="docSection4Title"> string.rstrip(s=...)<br>"".rstrip([chars=string.whitespace])</H5>
<P class="docText">Return a string with trailing whitespace characters removed. For Python 1.6+, use of a string object method is stylistically preferred in many cases:</P>
<pre>
&gt;&gt;&gt; import string
&gt;&gt;&gt; s = """
...     Mary had a little lamb       \011"""
&gt;&gt;&gt; string.rstrip(s)
'\012    Mary had a little lamb'
&gt;&gt;&gt; s.rstrip()
'\012    Mary had a little lamb'
</pre>
<P class="docText">Python 2.3+ accepts the optional argument <TT>chars</TT> to the string object method. All characters in the string <TT>chars</TT> will be removed.</P>
<p class="docText"><span class="docEmphRoman">S<span class="docEmphSmaller">EE</span> A<span class="docEmphSmaller">LSO</span></span>: 
string.lstrip() <span class="docEmphasis">139;</span> string.strip() <span class="docEmphasis">144</span>;</p>
<A NAME="ch02lev4sec39"></A><H5 class="docSection4Title"> string.split(s=...[,sep=...[,maxsplit=...]])<br>"".split([,sep [,maxsplit]])</H5>
<P class="docText">Return a list of nonoverlapping substrings of <TT>s</TT>. If the second argument <TT>sep</TT> is specified, the substrings are divided around the occurrences of <TT>sep</TT>. If <TT>sep</TT> is not specified, the substrings are divided around <span class="docEmphasis">any</span> whitespace characters. The dividing strings do not appear in the resultant list. If the third argument <TT>maxsplit</TT> is specified, everything "left over" after splitting <TT>maxsplit</TT> parts is appended to the list, giving the list length 'maxsplit'+1.</P>
<pre>
&gt;&gt;&gt; import string
&gt;&gt;&gt; s = 'mary had a little lamb    ...with a glass of sherry'
&gt;&gt;&gt; string.split(s, ' a ')
['mary had', 'little lamb     ...with', 'glass of sherry']
&gt;&gt;&gt; string.split(s)
['mary', 'had', 'a', 'little', 'lamb', '...with', 'a', 'glass',
'of', 'sherry']
&gt;&gt;&gt; string.split(s,maxsplit=5)
['mary', 'had', 'a', 'little', 'lamb', '...with a glass of sherry']
</pre>
<P class="docText">For Python 1.6+, use of a string object method is stylistically preferred in many cases:</P>
<pre>
&gt;&gt;&gt; "Mary had a Little Lamb!".split()
['Mary', 'had', 'a', 'Little', 'Lamb!']
</pre>
<P class="docText">The <span class="docEmphasis"><TT>string.split()</TT></span> function (and corresponding string object method) is surprisingly versatile for working with texts, especially ones that resemble prose. Its default behavior of treating all whitespace as a single divider allows <span class="docEmphasis"><TT>string.split()</TT></span> to act as a quick-and-dirty word parser:</P>
<pre>
&gt;&gt;&gt; wc = lambda s: len(s.split())
&gt;&gt;&gt; wc("Mary had a Little Lamb")
5
&gt;&gt;&gt; s = """Mary had a Little Lamb
... its fleece as white as snow.
... And everywhere that Mary went  ...  the lamb was sure to go."""
&gt;&gt;&gt; print s
Mary had a Little Lamb
its fleece as white as snow.
And everywhere that Mary went   ...  the lamb was sure to go.
&gt;&gt;&gt; wc(s)
23
</pre>
<P class="docText">The function <span class="docEmphasis"><TT>string.split()</TT></span> is very often used in conjunction with <span class="docEmphasis"><TT>string.join()</TT></span>. The pattern involved is "pull the string apart, modify the parts, put it back together." Often the parts will be words, but this also works with lines (dividing on <TT>\n</TT>) or other chunks. For example:</P>
<pre>
&gt;&gt;&gt; import string
&gt;&gt;&gt; s = """Mary had a Little Lamb
... its fleece as white as snow.
... And everywhere that Mary went   ...  the lamb was sure to go."""
&gt;&gt;&gt; string.join(string.split(s))
'Mary had a Little Lamb its fleece as white as snow. And everywhere
... that Mary went the lamb was sure to go.'
</pre>
<P class="docText">A Python 1.6+ idiom for string object methods expresses this technique compactly:</P>
<pre>
&gt;&gt;&gt; "-".join(s.split())
'Mary-had-a-Little-Lamb-its-fleece-as-white-as-snow.-And-everywhere
...-that-Mary-went--the-lamb-was-sure-to-go.'
</pre>
<p class="docText"><span class="docEmphRoman">S<span class="docEmphSmaller">EE</span> A<span class="docEmphSmaller">LSO</span></span>: 
string.join() <span class="docEmphasis">137;</span> mx.TextTools.setsplit() <span class="docEmphasis">314;</span> mx.TextTools.charsplit() <span class="docEmphasis">311;</span> mx.TextTools.splitat() <span class="docEmphasis">315;</span> mx.TextTools.splitlines() <span class="docEmphasis">315;</span></p>
<A NAME="ch02lev4sec40"></A><H5 class="docSection4Title"> string.splitfields(...)</H5>
<P class="docText">Identical to <span class="docEmphasis"><TT>string.split()</TT></span>.</P>
<A NAME="ch02lev4sec41"></A><H5 class="docSection4Title"> "".splitlines([keepends=0])</H5>
<P class="docText">This string method does not have an equivalent in the <span class="docEmphasis"><TT>string</TT></span> module. Return a list of lines in the string. The optional argument <TT>keepends</TT> determines whether line break character(s) are included in the line strings.</P>
<A NAME="ch02lev4sec42"></A><H5 class="docSection4Title"> "".startswith(prefix [,start [,end]])</H5>
<P class="docText">This string method does not have an equivalent in the <span class="docEmphasis"><TT>string</TT></span> module. Return a Boolean value indicating whether the string begins with the prefix <TT>prefix</TT>. If the optional second argument <TT>start</TT> is specified, only consider the terminal substring after the offset <TT>start</TT>. If the optional third argument <TT>end</TT> is given, only consider the slice <TT>[start: end]</TT>.</P>
<p class="docText"><span class="docEmphRoman">S<span class="docEmphSmaller">EE</span> A<span class="docEmphSmaller">LSO</span></span>: 
"".endswith() <span class="docEmphasis">134;</span> string.find() <span class="docEmphasis">135;</span></p>
<A NAME="ch02lev4sec43"></A><H5 class="docSection4Title"> string.strip(s=...)<br>"".strip([chars=string.whitespace])</H5>
<P class="docText">Return a string with leading and trailing whitespace characters removed. For Python 1.6+, use of a string object method is stylistically preferred in many cases:</P>
<pre>
&gt;&gt;&gt; import string
&gt;&gt;&gt; s = """
...     Mary had a little lamb     \011"""
&gt;&gt;&gt; string.strip(s)
'Mary had a little lamb'
&gt;&gt;&gt; s.strip()
'Mary had a little lamb'
</pre>
<P class="docText">Python 2.3+ accepts the optional argument <TT>chars</TT> to the string object method. All characters in the string <TT>chars</TT> will be removed.</P>
<pre>
&gt;&gt;&gt; s = "MARY had a LITTLE lamb STEW"
&gt;&gt;&gt; s.strip("ABCDEFGHIJKLMNOPQRSTUVWXYZ") # strip caps
' had a LITTLE lamb '
</pre>
<p class="docText"><span class="docEmphRoman">S<span class="docEmphSmaller">EE</span> A<span class="docEmphSmaller">LSO</span></span>: 
string.rstrip() <span class="docEmphasis">142;</span> string.lstrip() <span class="docEmphasis">139;</span></p>
<A NAME="ch02lev4sec44"></A><H5 class="docSection4Title"> string.swapcase(s=...)<br>"".swapcase()</H5>
<P class="docText">Return a string with any uppercase letters converted to lowercase and any lowercase letters converted to uppercase.</P>
<pre>
&gt;&gt;&gt; import string
&gt;&gt;&gt; string.swapcase("mary HAD a little lamb!")
'MARY had A LITTLE LAMB!'
</pre>
<P class="docText">For Python 1.6+, use of a string object method is stylistically preferred in many cases:</P>
<pre>
&gt;&gt;&gt; "Mary had a Little Lamb!".swapcase()
'MARY had A LITTLE LAMB!'
</pre>
<p class="docText"><span class="docEmphRoman">S<span class="docEmphSmaller">EE</span> A<span class="docEmphSmaller">LSO</span></span>: 
string.upper() <span class="docEmphasis">146;</span> string.lower() <span class="docEmphasis">138;</span></p>
<A NAME="ch02lev4sec45"></A><H5 class="docSection4Title"> string.translate(s=..., table=...[,deletechars=""])<br>"".translate(table [,deletechars=""])</H5>
<P class="docText">Return a string, based on <TT>s</TT>, with <TT>deletechars</TT> deleted (if the third argument is specified) and with any remaining characters translated according to the translation <TT>table</TT>.</P>
<pre>
&gt;&gt;&gt; import string
&gt;&gt;&gt; tab = string.maketrans('ABC','abc')
&gt;&gt;&gt; string.translate('MARY HAD a little LAMB', tab, 'Atl')
'MRY HD a ie LMb'
</pre>
<P class="docText">For Python 1.6+, use of a string object method is stylistically preferred in many cases. However, if <span class="docEmphasis"><TT>string.maketrans()</TT></span> is used to create the translation table, one will need to import the <span class="docEmphasis"><TT>string</TT></span> module anyway:</P>
<pre>
&gt;&gt;&gt; 'MARY HAD a little LAMB'.translate(tab, 'Atl')
'MRY HD a ie LMb'
</pre>
<P class="docText">The <span class="docEmphasis"><TT>string.translate()</TT></span> function is a <span class="docEmphasis">very</span> fast way to modify a string. Setting up the translation table takes some getting used to, but the resultant transformation is much faster than a procedural technique such as:</P>
<pre>
&gt;&gt;&gt; (new,frm,to,dlt) = ("",'ABC','abc','Alt')
&gt;&gt;&gt; for c in 'MARY HAD a little LAMB':
...     if c not in dlt:
...         pos = frm.find(c)
...         if pos == -1: new += c
...         else:         new += to[pos]
...
&gt;&gt;&gt; new
'MRY HD a ie LMb'
</pre>
<p class="docText"><span class="docEmphRoman">S<span class="docEmphSmaller">EE</span> A<span class="docEmphSmaller">LSO</span></span>: 
string.maketrans() <span class="docEmphasis">139;</span></p>
<A NAME="ch02lev4sec46"></A><H5 class="docSection4Title"> string.upper(s=...)<br>"".upper()</H5>
<P class="docText">Return a string with any lowercase letters converted to uppercase.</P>
<pre>
&gt;&gt;&gt; import string
&gt;&gt;&gt; string.upper("mary HAD a little lamb!")
'MARY HAD A LITTLE LAMB!'
&gt;&gt;&gt; string.upper("Mary had a Little Lamb!")
'MARY HAD A LITTLE LAMB!'
</pre>
<P class="docText">For Python 1.6+, use of a string object method is stylistically preferred in many cases:</P>
<pre>
&gt;&gt;&gt; "Mary had a Little Lamb!".upper()
'MARY HAD A LITTLE LAMB!'
</pre>
<p class="docText"><span class="docEmphRoman">S<span class="docEmphSmaller">EE</span> A<span class="docEmphSmaller">LSO</span></span>: 
string.lower() <span class="docEmphasis">138;</span></p>
<A NAME="ch02lev4sec47"></A><H5 class="docSection4Title"> string.zfill(s=..., width=...)</H5>
<P class="docText">Return a string with <TT>s</TT> padded with leading zeros (but not truncated) to occupy length <TT>width</TT> (or more). If a leading sign is present, it "floats" to the beginning of the return value. In general, <span class="docEmphasis"><TT>string.zfill()</TT></span> is designed for alignment of numeric values, but no checking is done to see if a string looks number-like.</P>
<pre>
&gt;&gt;&gt; import string
&gt;&gt;&gt; string.zfill("this", 20)
'0000000000000000this'
&gt;&gt;&gt; string.zfill("-37", 20)
'-0000000000000000037'
&gt;&gt;&gt; string.zfill("+3.7", 20)
'+00000000000000003.7'
</pre>
<P class="docText">Based on the example of <span class="docEmphasis"><TT>string.rjust()</TT></span>, one might expect a string object method <span class="docEmphasis"><TT>"".zfill()</TT></span> ; however, no such method exists.</P>
<p class="docText"><span class="docEmphRoman">S<span class="docEmphSmaller">EE</span> A<span class="docEmphSmaller">LSO</span></span>: 
string.rjust() <span class="docEmphasis">141;</span></p>
<A NAME="ch02lev2sec9"></A><H4 class="docSection2Title">2.2.2 Strings as Files, and Files as Strings</H4>
<P class="docText">In many ways, strings and files do a similar job. Both provide a storage container for an unlimited amount of (textual) information that is directly structured only by linear position of the bytes. A first inclination is to suppose that the difference between files and strings is one of persistence—files hang around when the current program is no longer running. But that distinction is not really tenable. On the one hand, standard Python modules like <span class="docEmphasis"><TT>shelve</TT>, <TT>pickle</TT></span>, and <span class="docEmphasis"><TT>marshal</TT></span>—and third-party modules like <span class="docEmphasis"><TT>xml_pickle</TT></span> and <span class="docEmphasis"><TT>ZODB</TT></span>—provide simple ways of making strings persist (but not thereby correspond in any direct way to a filesystem). On the other hand, many files are not particularly persistent: Special files like STDIN and STDOUT under Unix-like systems exist only for program life; other peculiar files like <TT>/dev/cua0</TT> and similar "device files" are really just streams; and even files that live on transient memory disks, or get deleted with program cleanup, are not very persistent.</P>
<P class="docText">The real difference between files and strings in Python is no more or less than the set of techniques available to operate on them. File objects can do things like <TT>.read()</TT> and <TT>.seek()</TT> on themselves. Notably, file objects have a concept of a "current position" that emulates an imaginary "read-head" passing over the physical storage media. Strings, on the other hand, can be sliced and indexed—for example, <TT>str[4:10]</TT> or <TT>for c in str:</TT>—and can be processed with string object methods and by functions of modules like <span class="docEmphasis"><TT>string</TT></span> and <span class="docEmphasis"><TT>re</TT></span>. Moreover, a number of special-purpose Python objects act "file-like" without quite being files; for example, <span class="docEmphasis"><TT>gzip.open()</TT></span> and <span class="docEmphasis"><TT>urllib.urlopen()</TT> .</span> Of course, Python itself does not impose any strict condition for just how "file-like" something has to be to work in a file-like context. A programmer has to figure that out for each type of object she wishes to apply techniques to (but most of the time things "just work" right).</P>
<P class="docText">Happily, Python provides some standard modules to make files and strings easily interoperable.</P>
<P><A NAME="ch02sb02"></A><TABLE CELLSPACING="0" WIDTH="90%" BORDER="1"><TR><TD>
<P class="docText"><span class="docEmphStrong">mmap &#8226; Memory-mapped file support</span></P></TD></TR></TABLE></P>
<P class="docText">The <span class="docEmphasis"><TT>mmap</TT></span> module allows a programmer to create "memory-mapped" file objects. These special <span class="docEmphasis"><TT>mmap</TT></span> objects enable most of the techniques you might apply to "true" file objects and simultaneously most of the techniques you might apply to "true" strings. Keep in mind the hinted caveat about "most," however: Many <span class="docEmphasis"><TT>string</TT></span> module functions are implemented using the corresponding string object methods. Since a <span class="docEmphasis"><TT>mmap</TT></span> object is only somewhat "string-like," it basically only implements the <TT>.find()</TT> method and those "magic" methods associated with slicing and indexing. This is enough to support most string object idioms.</P>
<P class="docText">When a string-like change is made to a <span class="docEmphasis"><TT>mmap</TT></span> object, that change is propagated to the underlying file, and the change is persistent (assuming the underlying file is persistent, and that the object called <TT>.flush()</TT> before destruction). <span class="docEmphasis"><TT>mmap</TT></span> thereby provides an efficient route to "persistent strings."</P>
<P class="docText">Some examples of working with memory-mapped file objects are worth looking at:</P>
<pre>
&gt;&gt;&gt; # Create a file with some test data
&gt;&gt;&gt; open('test','w').write(' #'.join(map(str, range(1000))))
&gt;&gt;&gt; fp = open('test','r+')
&gt;&gt;&gt; import mmap
&gt;&gt;&gt; mm = mmap.mmap(fp.fileno(),1000)
&gt;&gt;&gt; len(mm)
1000
&gt;&gt;&gt; mm[-20:]
'218 #219 #220 #221 #'
&gt;&gt;&gt; import string   # apply a string module method
&gt;&gt;&gt; mm.seek(string.find(mm, '21'))
&gt;&gt;&gt; mm.read(10)
'21 #22 #23'
&gt;&gt;&gt; mm.read(10)     # next ten bytes
' #24 #25 #'
&gt;&gt;&gt; mm.find('21')   # object method to find next occurrence
402
&gt;&gt;&gt; try: string.rfind(mm, '21')
... except AttributeError: print "Unsupported string function"
...
Unsupported string function
&gt;&gt;&gt; '/'.join(re.findall('..21..',mm))   # regex's work nicely
' #21 #/#121 #/ #210 / #212 / #214 / #216 / #218 /#221 #'
</pre>
<P class="docText">It is worth emphasizing that the bytes in a file on disk are in fixed positions. You may use the <span class="docEmphasis"><TT>mmap.mmap.resize()</TT></span> method to write into different portions of a file, but you cannot expand the file from the middle, only by adding to the end.</P>
<A NAME="ch02lev3sec4"></A><H5 class="docSection3Title"> CLASSES</H5>
<A NAME="ch02lev4sec48"></A><H5 class="docSection4Title"> mmap.mmap(fileno, length [,tagname]) (Windows)<br>mmap.mmap(fileno, length [,flags=MAP_SHARED, prot=PROT_READ|PROT_WRITE])</H5>
<P class="docText">Create a new memory-mapped file object. <TT>fileno</TT> is the numeric file handle to base the mapping on. Generally this number should be obtained using the <TT>.fileno()</TT> method of a file object. <TT>length</TT> specifies the length of the mapping. Under Windows, the value 0 may be given for <TT>length</TT> to specify the current length of the file. If <TT>length</TT> smaller than the current file is specified, only the initial portion of the file will be mapped. If <TT>length</TT> larger than the current file is specified, the file can be extended with additional string content.</P>
<P class="docText">The underlying file for a memory-mapped file object must be opened for updating, using the "+" mode modifier.</P>
<P class="docText">According to the official Python documentation for Python 2.1, a third argument <TT>tagname</TT> may be specified. If it is, multiple memory-maps against the same file are created. In practice, however, each instance of <span class="docEmphasis"><TT>mmap.mmap()</TT></span> creates a new memory-map whether or not a <TT>tagname</TT> is specified. In any case, this allows multiple file-like updates to the same underlying file, generally at different positions in the file.</P>
<pre>
&gt;&gt;&gt; open('test','w').write(' #'.join([str(n) for n in range(1000)]))
&gt;&gt;&gt; fp = open('test','r+')
&gt;&gt;&gt; import mmap
&gt;&gt;&gt; mm1 = mmap.mmap(fp.fileno(),1000)
&gt;&gt;&gt; mm2 = mmap.mmap(fp.fileno(),1000)
&gt;&gt;&gt; mm1.seek(500)
&gt;&gt;&gt; mm1.read(10)
'122 #123 #'
&gt;&gt;&gt; mm2.read(10)
'0 #1 #2 #3'
</pre>
<P class="docText">Under Unix, the third argument <TT>flags</TT> may be MAP_PRIVATE or MAP_SHARED. If MAP_SHARED is specified for <TT>flags</TT>, all processes mapping the file will see the changes made to a <span class="docEmphasis"><TT>mmap</TT></span> object. Otherwise, the changes are restricted to the current process. The fourth argument, <TT>prot</TT>, may be used to disallow certain types of access by other processes to the mapped file regions.</P>
<A NAME="ch02lev3sec5"></A><H5 class="docSection3Title"> METHODS</H5>
<A NAME="ch02lev4sec49"></A><H5 class="docSection4Title"> mmap.mmap.close()</H5>
<P class="docText">Close the memory-mapped file object. Subsequent calls to the other methods of the <span class="docEmphasis"><TT>mmap</TT></span> object will raise an exception. Under Windows, the behavior of a <span class="docEmphasis"><TT>mmap</TT></span> object after . <TT>close()</TT> is somewhat erratic, however. Note that closing the memory-mapped file object is not the same as closing the underlying file object. Closing the underlying file will make the contents inaccessible, but closing the memory-mapped file object will not affect the underlying file object.</P>
<p class="docText"><span class="docEmphRoman">S<span class="docEmphSmaller">EE</span> A<span class="docEmphSmaller">LSO</span></span>: 
FILE.close() <span class="docEmphasis">16;</span></p>
<A NAME="ch02lev4sec50"></A><H5 class="docSection4Title"> mmap.mmap.find(sub [,pos])</H5>
<P class="docText">Similar to <span class="docEmphasis"><TT>string.find()</TT> .</span> Return the index position of the first occurrence of <TT>sub</TT> in the <span class="docEmphasis"><TT>mmap</TT></span> object. If the optional second argument <TT>pos</TT> is specified, the result is the offset returned relative to <TT>pos</TT>. Return -1 if no occurrence is found:</P>
<pre>
&gt;&gt;&gt; open('test','w').write(' #'.join([str(n) for n in range(1000)]))
&gt;&gt;&gt; fp = open('test','r+')
&gt;&gt;&gt; import mmap
&gt;&gt;&gt; mm = mmap.mmap(fp.fileno(), 0)
&gt;&gt;&gt; mm.find('21')
74
&gt;&gt;&gt; mm.find('21',100)
-26
&gt;&gt;&gt; mm.tell()
0
</pre>
<p class="docText"><span class="docEmphRoman">S<span class="docEmphSmaller">EE</span> A<span class="docEmphSmaller">LSO</span></span>: 
mmap.mmap.seek() <span class="docEmphasis">152;</span> string.find() <span class="docEmphasis">135;</span></p>
<A NAME="ch02lev4sec51"></A><H5 class="docSection4Title"> mmap.mmap.flush([offset, size])</H5>
<P class="docText">Writes changes made in memory to <span class="docEmphasis"><TT>mmap</TT></span> object back to disk. The first argument <TT>offset</TT> and second argument <TT>size</TT> must either both be specified or both be omitted. If <TT>offset</TT> and <TT>size</TT> are specified, only the position starting at <TT>offset</TT> or length <TT>size</TT> will be written back to disk.</P>
<P class="docText"><span class="docEmphasis"><TT>mmap.mmap.flush()</TT></span> is necessary to guarantee that changes are written to disk; however, no guarantee is given that changes <span class="docEmphasis">will not</span> be written to disk as part of normal Python interpreter housekeeping. <span class="docEmphasis"><TT>mmap</TT></span> should not be used for systems with "cancelable" changes (since changes may not be cancelable).</P>
<p class="docText"><span class="docEmphRoman">S<span class="docEmphSmaller">EE</span> A<span class="docEmphSmaller">LSO</span></span>: 
FILE.flush() <span class="docEmphasis">16;</span></p>
<A NAME="ch02lev4sec52"></A><H5 class="docSection4Title"> mmap.mmap.move(target, source, length)</H5>
<P class="docText">Copy a substring within a memory-mapped file object. The length of the substring is the third argument <TT>length</TT>. The target location is the first argument <TT>target</TT>. The substring is copied from the position <TT>source</TT>. It is allowable to have the substring's original position overlap its target range, but it must not go past the last position of the <span class="docEmphasis"><TT>mmap</TT></span> object.</P>
<pre>
&gt;&gt;&gt; open('test','w').write(''.join([c*10 for c in 'ABCDE']))
&gt;&gt;&gt; fp = open('test','r+')
&gt;&gt;&gt; import mmap
&gt;&gt;&gt; mm = mmap.mmap(fp.fileno(),0)
&gt;&gt;&gt; mm[:]
'AAAAAAAAAABBBBBBBBBBCCCCCCCCCCDDDDDDDDDDEEEEEEEEEE'
&gt;&gt;&gt; mm.move(40,0,5)
&gt;&gt;&gt; mm[:]
'AAAAAAAAAABBBBBBBBBBCCCCCCCCCCDDDDDDDDDDAAAAAEEEEE'
</pre>
<A NAME="ch02lev4sec53"></A><H5 class="docSection4Title"> mmap.mmap.read(num)</H5>
<P class="docText">Return a string containing <TT>num</TT> bytes, starting at the current file position. The file position is moved to the end of the read string. In contrast to the <TT>.read()</TT> method of file objects, <span class="docEmphasis"><TT>mmap.mmap.read()</TT></span> always requires that a byte count be specified, which makes a memory-map file object not fully substitutable for a file object when data is read. However, the following is safe for both true file objects and memory-mapped file objects:</P>
<pre>
&gt;&gt;&gt; open('test','w').write(' #'.join( [str (n) for n in range(1000)]))
&gt;&gt;&gt; fp = open('test','r+')
&gt;&gt;&gt; import mmap
&gt;&gt;&gt; mm = mmap.mmap(fp.fileno(),0)
&gt;&gt;&gt; def safe_readall(file):
...     try:
...         length = len(file)
...         return file.read(length)
...     except TypeError:
...         return file.read()
...
&gt;&gt;&gt; s1 = safe_readall(fp)
&gt;&gt;&gt; s2 = safe_readall(mm)
&gt;&gt;&gt; s1 == s2
1
</pre>
<p class="docText"><span class="docEmphRoman">S<span class="docEmphSmaller">EE</span> A<span class="docEmphSmaller">LSO</span></span>: 
mmap.mmap.read_byte() <span class="docEmphasis">151;</span> mmap.mmap.readline() <span class="docEmphasis">151;</span> mmap.mmap.write() <span class="docEmphasis">153;</span> FILE.read() <span class="docEmphasis">17;</span></p>
<A NAME="ch02lev4sec54"></A><H5 class="docSection4Title"> mmap.mmap.read_byte()</H5>
<P class="docText">Return a one-byte string from the current file position and advance the current position by one. Same as <TT>mmap.mmap.read (1)</TT>.</P>
<p class="docText"><span class="docEmphRoman">S<span class="docEmphSmaller">EE</span> A<span class="docEmphSmaller">LSO</span></span>: 
mmap.mmap.read() <span class="docEmphasis">150;</span> mmap.mmap.readline() <span class="docEmphasis">151;</span></p>
<A NAME="ch02lev4sec55"></A><H5 class="docSection4Title"> mmap.mmap.readline()</H5>
<P class="docText">Return a string from the memory-mapped file object, starting from the current file position and going to the next newline character. Advance the current file position by the amount read.</P>
<p class="docText"><span class="docEmphRoman">S<span class="docEmphSmaller">EE</span> A<span class="docEmphSmaller">LSO</span></span>: 
mmap.mmap.read() <span class="docEmphasis">150;</span> mmap.mmap.read_byte() <span class="docEmphasis">151;</span> FILE.readline() <span class="docEmphasis">17;</span></p>
<A NAME="ch02lev4sec56"></A><H5 class="docSection4Title"> mmap.mmap.resize(newsize)</H5>
<P class="docText">Change the size of a memory-mapped file object. This may be used to expand the size of an underlying file or merely to expand the area of a file that is memory-mapped. An expanded file is padded with null bytes (\000) unless otherwise filled with content. As with other operations on <span class="docEmphasis"><TT>mmap</TT></span> objects, changes to the underlying file system may not occur until a <TT>.flush()</TT> is performed.</P>
<p class="docText"><span class="docEmphRoman">S<span class="docEmphSmaller">EE</span> A<span class="docEmphSmaller">LSO</span></span>: 
mmap.mmap.flush() <span class="docEmphasis">150;</span></p>
<A NAME="ch02lev4sec57"></A><H5 class="docSection4Title"> mmap.mmap.seek(offset [,mode])</H5>
<P class="docText">Change the current file position. If a second argument <TT>mode</TT> is given, a different seek mode can be selected. The default is 0, absolute file positioning. Mode 1 seeks relative to the current file position. Mode 2 is relative to the end of the memory-mapped file (which may be smaller than the whole size of the underlying file). The first argument <TT>offset</TT> specifies the distance to move the current file position—in mode 0 it should be positive, in mode 2 it should be negative, in mode 1 the current position can be moved either forward or backward.</P>
<p class="docText"><span class="docEmphRoman">S<span class="docEmphSmaller">EE</span> A<span class="docEmphSmaller">LSO</span></span>: 
FILE.seek() <span class="docEmphasis">17;</span></p>
<A NAME="ch02lev4sec58"></A><H5 class="docSection4Title"> mmap.mmap.size()</H5>
<P class="docText">Return the length of the underlying file. The size of the actual memory-map may be smaller if less than the whole file is mapped:</P>
<pre>
&gt;&gt;&gt; open('test','w').write('X'*100)
&gt;&gt;&gt; fp = open('test','r+')
&gt;&gt;&gt; import mmap
&gt;&gt;&gt; mm = mmap.mmap(fp.fileno(),50)
&gt;&gt;&gt; mm.size()
100
&gt;&gt;&gt; len(mm)
50
</pre>
<p class="docText"><span class="docEmphRoman">S<span class="docEmphSmaller">EE</span> A<span class="docEmphSmaller">LSO</span></span>: 
len() <span class="docEmphasis">14;</span> mmap.mmap.seek() <span class="docEmphasis">152;</span> mmap.mmap.tell() <span class="docEmphasis">152;</span></p>
<A NAME="ch02lev4sec59"></A><H5 class="docSection4Title"> mmap.mmap.tell()</H5>
<P class="docText">Return the current file position.</P>
<pre>
&gt;&gt;&gt; open('test','w').write('X'*100)
&gt;&gt;&gt; fp = open('test','r+')
&gt;&gt;&gt; import mmap
&gt;&gt;&gt; mm = mmap.mmap(fp.fileno(), 0)
&gt;&gt;&gt; mm.tell()
0
&gt;&gt;&gt; mm.seek(20)
&gt;&gt;&gt; mm.tell()
20
&gt;&gt;&gt; mm.read(20)
'XXXXXXXXXXXXXXXXXXXX'
&gt;&gt;&gt; mm.tell()
40
</pre>
<p class="docText"><span class="docEmphRoman">S<span class="docEmphSmaller">EE</span> A<span class="docEmphSmaller">LSO</span></span>: 
FILE.tell() <span class="docEmphasis">17;</span> mmap.mmap.seek() <span class="docEmphasis">152;</span></p>
<A NAME="ch02lev4sec60"></A><H5 class="docSection4Title"> mmap.mmap.write(s)</H5>
<P class="docText">Write <TT>s</TT> into the memory-mapped file object at the current file position. The current file position is updated to the position following the write. The method <span class="docEmphasis"><TT>mmap.mmap.write()</TT></span> is useful for functions that expect to be passed a file-like object with a <TT>.write()</TT> method. However, for new code, it is generally more natural to use the string-like index and slice operations to write contents. For example:</P>
<pre>
&gt;&gt;&gt; open('test','w').write('X'*50)
&gt;&gt;&gt; fp = open('test','r+')
&gt;&gt;&gt; import mmap
&gt;&gt;&gt; mm = mmap.mmap(fp.fileno(), 0)
&gt;&gt;&gt; mm.write('AAAAA')
&gt;&gt;&gt; mm.seek(10)
&gt;&gt;&gt; mm.write('BBBBB')
&gt;&gt;&gt; mm[30:35] = 'SSSSS'
&gt;&gt;&gt; mm[:]
'AAAAAXXXXXBBBBBXXXXXXXXXXXXXXXSSSSSXXXXXXXXXXXXXXX'
&gt;&gt;&gt; mm.tell()
15
</pre>
<p class="docText"><span class="docEmphRoman">S<span class="docEmphSmaller">EE</span> A<span class="docEmphSmaller">LSO</span></span>: 
FILE.write() <span class="docEmphasis">17;</span> mmap.mmap.read() <span class="docEmphasis">150;</span></p>
<A NAME="ch02lev4sec61"></A><H5 class="docSection4Title"> mmap.mmap.write_byte(c)</H5>
<P class="docText">Write a one-byte string to the current file position, and advance the current position by one. Same as <TT>mmap.mmap.write(c)</TT> where <TT>c</TT> is a one-byte string.</P>
<p class="docText"><span class="docEmphRoman">S<span class="docEmphSmaller">EE</span> A<span class="docEmphSmaller">LSO</span></span>: 
mmap.mmap.write() <span class="docEmphasis">153;</span></p>
<P><A NAME="ch02sb03"></A><TABLE CELLSPACING="0" WIDTH="90%" BORDER="1"><TR><TD>
<P class="docText"><span class="docEmphStrong">StringIO &#8226; File-like objects that read from or write to a string buffer</span></P></TD></TR></TABLE></P>
<P><A NAME="ch02sb04"></A><TABLE CELLSPACING="0" WIDTH="90%" BORDER="1"><TR><TD>
<P class="docText"><span class="docEmphStrong">cStringIO &#8226; Fast, but incomplete, StringIO replacement</span></P></TD></TR></TABLE></P>
<P class="docText">The <span class="docEmphasis"><TT>StringIO</TT></span> and <span class="docEmphasis"><TT>cStringIO</TT></span> modules allow a programmer to create "memory files," that is, "string buffers." These special <span class="docEmphasis"><TT>StringIO</TT></span> objects enable most of the techniques you might apply to "true" file objects, but without any connection to a filesystem.</P>
<P class="docText">The most common use of string buffer objects is when some existing techniques for working with byte-streams in files are to be applied to strings that do not come from files. A string buffer object behaves in a file-like manner and can "drop in" to most functions that want file objects.</P>
<P class="docText"><span class="docEmphasis"><TT>cStringIO</TT></span> is much faster than <span class="docEmphasis"><TT>StringIO</TT></span> and should be used in most cases. Both modules provide a <TT>StringIO</TT> class whose instances are the string buffer objects. <span class="docEmphasis"><TT>cStringI0.StringI0</TT></span> cannot be subclassed (and therefore cannot provide additional methods), and it cannot handle Unicode strings. One rarely needs to subclass <span class="docEmphasis"><TT>StringIO</TT></span>, but the absence of Unicode support in <span class="docEmphasis"><TT>cStringIO</TT></span> could be a problem for many developers. As well, <span class="docEmphasis"><TT>cStringIO</TT></span> does not support write operations, which makes its string buffers less general (the effect of a write against an in-memory file can be accomplished by normal string operations).</P>
<P class="docText">A string buffer object may be initialized with a string (or Unicode for <span class="docEmphasis"><TT>StringIO</TT>)</span> argument. If so, that is the initial content of the buffer. Below are examples of usage (including Unicode handling):</P>
<pre>
&gt;&gt;&gt; from cStringIO import StringIO as CSIO
&gt;&gt;&gt; from StringIO import StringIO as SIO
&gt;&gt;&gt; alef, omega = unichr(1488), unichr(969)
&gt;&gt;&gt; sentence = "In set theory, the Greek "+omega+" represents the \n"+\
...            "ordinal limit of the integers, while the Hebrew \n"+\
...            alef+" represents their cardinality."
&gt;&gt;&gt; sio = SIO(sentence)
&gt;&gt;&gt; try:
...     csio = CSIO(sentence)
...     print "New string buffer from raw string"
... except TypeError:
...     csio = CSIO(sentence.encode('utf-8'))
...     print "New string buffer from ENCODED string"
...
New string buffer from ENCODED string
&gt;&gt;&gt; sio.getvalue() == unicode(csio.getvalue(),'utf-8')
1
&gt;&gt;&gt; try:
...     sio.getvalue() == csio.getvalue()
... except UnicodeError:
...     print "Cannot even compare Unicode with string, in general"
...
Cannot even compare Unicode with string, in general
&gt;&gt;&gt; lines = csio.readlines()
&gt;&gt;&gt; len(lines)
3
&gt;&gt;&gt; sio.seek(0)
&gt;&gt;&gt; print sio.readline().encode('utf-8'),
In set theory, the Greek  represents the ordinal
&gt;&gt;&gt; sio.tell(), csio.tell()
(51, 124)
</pre>
<A NAME="ch02lev3sec6"></A><H5 class="docSection3Title"> CONSTANTS</H5>
<A NAME="ch02lev4sec62"></A><H5 class="docSection4Title"> cStringIO.InputType</H5>
<P class="docText">The type of a <span class="docEmphasis"><TT>cStringIO.StringIO</TT></span> instance that has been opened in "read" mode. All <span class="docEmphasis"><TT>StringIO.StringIO</TT></span> instances are simply InstanceType.</P>
<p class="docText"><span class="docEmphRoman">S<span class="docEmphSmaller">EE</span> A<span class="docEmphSmaller">LSO</span></span>: 
cStringIO.StringIO <span class="docEmphasis">155;</span></p>
<A NAME="ch02lev4sec63"></A><H5 class="docSection4Title"> cStringlO.OutputType</H5>
<P class="docText">The type of <span class="docEmphasis"><TT>cStringIO.StringIO</TT></span> instance that has been opened in "write" mode (actually read/write). All <span class="docEmphasis"><TT>StringIO.StringIO</TT></span> instances are simply InstanceType.</P>
<p class="docText"><span class="docEmphRoman">S<span class="docEmphSmaller">EE</span> A<span class="docEmphSmaller">LSO</span></span>: 
cStringIO.StringIO <span class="docEmphasis">155;</span></p>
<A NAME="ch02lev3sec7"></A><H5 class="docSection3Title"> CLASSES</H5>
<A NAME="ch02lev4sec64"></A><H5 class="docSection4Title"> StringlO.StringIO ([buf=...])<br>cStringIO.StringIO([buf])</H5>
<P class="docText">Create a new string buffer. If the first argument <TT>buf</TT> is specified, the buffer is initialized with a string content. If the <span class="docEmphasis"><TT>cStringIO</TT></span> module is used, the presence of the <TT>buf</TT> argument determines whether write access to the buffer is enabled. A <span class="docEmphasis"><TT>cStringIO.StringIO</TT></span> buffer with write access must be initialized with no argument, otherwise it becomes read-only. A <span class="docEmphasis"><TT>StringIO.StringIO</TT></span> buffer, however, is always read/write.</P>
<A NAME="ch02lev3sec8"></A><H5 class="docSection3Title"> METHODS</H5>
<A NAME="ch02lev4sec65"></A><H5 class="docSection4Title"> StringIO.StringIO.close()<br>cStringIO.StringIO.close()</H5>
<P class="docText">Close the string buffer. No access is permitted after close.</P>
<p class="docText"><span class="docEmphRoman">S<span class="docEmphSmaller">EE</span> A<span class="docEmphSmaller">LSO</span></span>: 
FILE.close() <span class="docEmphasis">16;</span></p>
<A NAME="ch02lev4sec66"></A><H5 class="docSection4Title"> StringIO.StringIO.flush()<br>cStringIO.StringIO.flush()</H5>
<P class="docText">Compatibility method for file-like behavior. Data in a string buffer is already in memory, so there is no need to finalize a write to disk.</P>
<p class="docText"><span class="docEmphRoman">S<span class="docEmphSmaller">EE</span> A<span class="docEmphSmaller">LSO</span></span>: 
FILE.close() <span class="docEmphasis">16;</span></p>
<A NAME="ch02lev4sec67"></A><H5 class="docSection4Title"> StringIO.StringIO.getvalue()<br>cStringIO.StringIO.getvalue()</H5>
<P class="docText">Return the entire string held by the string buffer. Does not affect the current file position. Basically, this is the way you convert back from a string buffer to a string.</P>
<A NAME="ch02lev4sec68"></A><H5 class="docSection4Title"> StringIO.StringIO.isatty()<br>cStringIO.StringIO.isatty()</H5>
<P class="docText">Return 0. Compatibility method for file-like behavior.</P>
<p class="docText"><span class="docEmphRoman">S<span class="docEmphSmaller">EE</span> A<span class="docEmphSmaller">LSO</span></span>: 
FILE.isatty() <span class="docEmphasis">16;</span></p>
<A NAME="ch02lev4sec69"></A><H5 class="docSection4Title"> StringIO.StringIO.read ([num])<br>cStringIO.StringIO.read ([num])</H5>
<P class="docText">If the first argument <TT>num</TT> is specified, return a string containing the next <TT>num</TT> characters. If <TT>num</TT> characters are not available, return as many as possible. If <TT>num</TT> is not specified, return all the characters from current file position to end of string buffer. Advance the current file position by the amount read.</P>
<p class="docText"><span class="docEmphRoman">S<span class="docEmphSmaller">EE</span> A<span class="docEmphSmaller">LSO</span></span>: 
FILE.read() <span class="docEmphasis">17;</span> mmap.mmap.read() <span class="docEmphasis">150;</span> StringIO.StringIO.readline() <span class="docEmphasis">156;</span></p>
<A NAME="ch02lev4sec70"></A><H5 class="docSection4Title"> StringIO.StringIO.readline([length=...])<br>cStringIO.StringIO.readline([length])</H5>
<P class="docText">Return a string from the string buffer, starting from the current file position and going to the next newline character. Advance the current file position by the amount read.</P>
<p class="docText"><span class="docEmphRoman">S<span class="docEmphSmaller">EE</span> A<span class="docEmphSmaller">LSO</span></span>: 
mmap.mmap.readline() <span class="docEmphasis">151;</span> StringIO.StringIO.read() <span class="docEmphasis">156;</span> StringIO.StringIO.readlines() <span class="docEmphasis">156;</span> FILE.readline() <span class="docEmphasis">17;</span></p>
<A NAME="ch02lev4sec71"></A><H5 class="docSection4Title"> StringIO.StringIO.readlines([sizehint=...])<br>cStringIO.StringIO.readlines([sizehint]</H5>
<P class="docText">Return a list of strings from the string buffer. Each list element consists of a single line, including the trailing newline character(s). If an argument <TT>sizehint</TT> is specified, only read approximately <TT>sizehint</TT> characters worth of lines (full lines will always be read).</P>
<p class="docText"><span class="docEmphRoman">S<span class="docEmphSmaller">EE</span> A<span class="docEmphSmaller">LSO</span></span>: 
StringIO.StringIO.readline() <span class="docEmphasis">156;</span> FILE.readlines() <span class="docEmphasis">17;</span></p>
<A NAME="ch02lev4sec72"></A><H5 class="docSection4Title"> cStringIO.StringIO.reset()</H5>
<P class="docText">Sets the current file position to the beginning of the string buffer. Same as <TT>cStringIO.StringIO.seek(0)</TT>.</P>
<p class="docText"><span class="docEmphRoman">S<span class="docEmphSmaller">EE</span> A<span class="docEmphSmaller">LSO</span></span>: 
StringIO.StringIO.seek() <span class="docEmphasis">156;</span></p>
<A NAME="ch02lev4sec73"></A><H5 class="docSection4Title"> StringIO.StringIO.seek(offset [,mode=0])<br>cStringIO.StringIO.seek(offset [,mode])</H5>
<P class="docText">Change the current file position. If the second argument <TT>mode</TT> is given, a different seek mode can be selected. The default is 0, absolute file positioning. Mode 1 seeks relative to the current file position. Mode 2 is relative to the end of the string buffer. The first argument <TT>offset</TT> specifies the distance to move the current file position—in mode 0 it should be positive, in mode 2 it should be negative, in mode 1 the current position can be moved either forward or backward.</P>
<p class="docText"><span class="docEmphRoman">S<span class="docEmphSmaller">EE</span> A<span class="docEmphSmaller">LSO</span></span>: 
FILE.seek() <span class="docEmphasis">17</span>; mmap.mmap.seek() <span class="docEmphasis">152</span>;</p>
<A NAME="ch02lev4sec74"></A><H5 class="docSection4Title"> StringIO.StringIO.tell()<br>cStringIO.StringIO.tell()</H5>
<P class="docText">Return the current file position in the string buffer.</P>
<p class="docText"><span class="docEmphRoman">S<span class="docEmphSmaller">EE</span> A<span class="docEmphSmaller">LSO</span></span>: 
StringIO.StringIO.seek() <span class="docEmphasis">156;</span></p>
<A NAME="ch02lev4sec75"></A><H5 class="docSection4Title"> StringIO.StringIO.truncate([len=0])<br>cStringIO.StringIO.truncate ([len])</H5>
<P class="docText">Reduce the length of the string buffer to the first argument <TT>len</TT> characters. Truncation can only reduce characters later than the current file position (an initial <TT>cStringIO.StringIO.reset()</TT> can be used to assure truncation from the beginning).</P>
<p class="docText"><span class="docEmphRoman">S<span class="docEmphSmaller">EE</span> A<span class="docEmphSmaller">LSO</span></span>: 
StringIO.StringIO.seek() <span class="docEmphasis">156;</span> cStringIO.StringIO.reset() <span class="docEmphasis">156;</span> StringIO.StringIO.close() <span class="docEmphasis">155;</span></p>
<A NAME="ch02lev4sec76"></A><H5 class="docSection4Title"> StringIO.StringIO.write(s=...)<br>cStringIO.StringIO.write(s)</H5>
<P class="docText">Write the first argument <TT>s</TT> into the string buffer at the current file position. The current file position is updated to the position following the write.</P>
<p class="docText"><span class="docEmphRoman">S<span class="docEmphSmaller">EE</span> A<span class="docEmphSmaller">LSO</span></span>: 
StringIO.StringIO.writelines() <span class="docEmphasis">157;</span> mmap.mmap.write() <span class="docEmphasis">153;</span> StringIO.StringIO.read() <span class="docEmphasis">156;</span> FILE.write() <span class="docEmphasis">17;</span></p>
<A NAME="ch02lev4sec77"></A><H5 class="docSection4Title"> StringIO.StringIO.writelines(list=...)<br>cStringIO.String IO.writelines(list)</H5>
<P class="docText">Write each element of <TT>list</TT> into the string buffer at the current file position. The current file position is updated to the position following the write. For the <span class="docEmphasis"><TT>cStringIO</TT></span> method, <TT>list</TT> must be an actual list. For the <span class="docEmphasis"><TT>StringIO</TT></span> method, other sequence types are allowed. To be safe, it is best to coerce an argument into an actual list first. In either case, <TT>list</TT> must contain only strings, or a <TT>TypeError</TT> will occur.</P>
<P class="docText">Contrary to what might be expected from the method name, <span class="docEmphasis"><TT>StringIO.StringIO.writelines()</TT></span> never inserts newline characters. For the list elements actually to occupy separate lines in the string buffer, each element string must already have a newline terminator. Consider the following variants on writing a list to a string buffer:</P>
<pre>
&gt;&gt;&gt; from StringIO import StringIO
&gt;&gt;&gt; sio = StringIO()
&gt;&gt;&gt; 1st = [c*5 for c in 'ABC']
&gt;&gt;&gt; sio.writelines(lst)
&gt;&gt;&gt; sio.write(''.join(lst))
&gt;&gt;&gt; sio.write('\n'.join(lst))
&gt;&gt;&gt; print sio.getvalue()
AAAAABBBBBCCCCCAAAAABBBBBCCCCCAAAAA
BBBBB
CCCCC
</pre>
<p class="docText"><span class="docEmphRoman">S<span class="docEmphSmaller">EE</span> A<span class="docEmphSmaller">LSO</span></span>: 
FILE.writelines() <span class="docEmphasis">17;</span> StringIO.StringIO.write() <span class="docEmphasis">157;</span></p>
<A NAME="ch02lev2sec10"></A><H4 class="docSection2Title">2.2.3 Converting Between Binary and ASCII</H4>
<P class="docText">The Python standard library provides several modules for converting between binary data and 7-bit ASCII. At the low level, <span class="docEmphasis"><TT>binascii</TT></span> is a C extension to produce fast string conversions. At a high level, <span class="docEmphasis"><TT>base64</TT>, <TT>binhex</TT>, <TT>quopri</TT></span>, and <span class="docEmphasis"><TT>uu</TT></span> provide file-oriented wrappers to the facilities in <span class="docEmphasis"><TT>binascii</TT></span>.</P>
<P><A NAME="ch02sb05"></A><TABLE CELLSPACING="0" WIDTH="90%" BORDER="1"><TR><TD>
<P class="docText"><span class="docEmphStrong">base64 &#8226; Convert to/from base64 encoding (RFC1521)</span></P></TD></TR></TABLE></P>
<P class="docText">The <span class="docEmphasis"><TT>base64</TT></span> module is a wrapper around the functions <span class="docEmphasis"><TT>binascii.a2b-base64()</TT></span> and <span class="docEmphasis"><TT>binascii.b2a-base64()</TT></span>. As well as providing a file-based interface on top of the underlying string conversions, <span class="docEmphasis"><TT>base64</TT></span> handles the chunking of binary files into base64 line blocks and provides for the direct encoding of arbitrary input strings. Unlike <span class="docEmphasis"><TT>uu</TT>, <TT>base64</TT></span> adds no content headers to encoded data; MIME standards for headers and message-wrapping are handled by other modules that utilize <span class="docEmphasis"><TT>base64</TT></span>. Base64 encoding is specified in RFC 1521.</P>
<A NAME="ch02lev3sec9"></A><H5 class="docSection3Title"> FUNCTIONS</H5>
<A NAME="ch02lev4sec78"></A><H5 class="docSection4Title"> base64.encode(input=..., output=...)</H5>
<P class="docText">Encode the contents of the first argument <TT>input</TT> to the second argument <TT>output</TT>. Arguments <TT>input</TT> and <TT>output</TT> should be file-like objects; <TT>input</TT> must be readable and <TT>output</TT> must be writable.</P>
<A NAME="ch02lev4sec79"></A><H5 class="docSection4Title"> base64.encodestring(s=...)</H5>
<P class="docText">Return the base64 encoding of the string passed in the first argument <TT>s</TT>.</P>
<A NAME="ch02lev4sec80"></A><H5 class="docSection4Title"> base64.decode(input=..., output=...)</H5>
<P class="docText">Decode the contents of the first argument <TT>input</TT> to the second argument <TT>output</TT>. Arguments <TT>input</TT> and <TT>output</TT> should be file-like objects; <TT>input</TT> must be readable and <TT>output</TT> must be writable.</P>
<A NAME="ch02lev4sec81"></A><H5 class="docSection4Title"> base64.decodestring(s=...)</H5>
<P class="docText">Return the decoding of the base64-encoded string passed in the first argument <TT>s</TT>.</P>
<p class="docText"><span class="docEmphRoman">S<span class="docEmphSmaller">EE</span> A<span class="docEmphSmaller">LSO</span></span>: 
email <span class="docEmphasis">345</span>; rfc822 <span class="docEmphasis">397</span>; mimetools <span class="docEmphasis">396</span>; mimetypes <span class="docEmphasis">374<SUB>;</SUB></span> MimeWriter <span class="docEmphasis">396</span>; mimify <span class="docEmphasis">396;</span> binascii <span class="docEmphasis">159;</span> quopri <span class="docEmphasis">162</span>;</p>
<P><A NAME="ch02sb06"></A><TABLE CELLSPACING="0" WIDTH="90%" BORDER="1"><TR><TD>
<P class="docText"><span class="docEmphStrong">binascii &#8226; Convert between binary data and </span><span class="docEmphStrong">ASCII</span></P></TD></TR></TABLE></P>
<P class="docText">The <span class="docEmphasis"><TT>binascii</TT></span> module is a C implementation of a number of styles of ASCII encoding of binary data. Each function in the <span class="docEmphasis"><TT>binascii</TT></span> module takes either encoded ASCII or raw binary strings as an argument, and returns the string result of converting back or forth. Some restrictions apply to the length of strings passed to some functions in the module (for encodings that operate on specific block sizes).</P>
<A NAME="ch02lev3sec10"></A><H5 class="docSection3Title"> FUNCTIONS</H5>
<A NAME="ch02lev4sec82"></A><H5 class="docSection4Title"> binascii.a2b_base64(s)</H5>
<P class="docText">Return the decoded version of a base64-encoded string. A string consisting of one or more encoding blocks should be passed as the argument <TT>s</TT>.</P>
<A NAME="ch02lev4sec83"></A><H5 class="docSection4Title"> binascii.a2b_hex(s)</H5>
<P class="docText">Return the decoded version of a hexadecimal-encoded string. A string consisting of an even number of hexadecimals digits should be passed as the argument <TT>s</TT>.</P>
<A NAME="ch02lev4sec84"></A><H5 class="docSection4Title"> binascii.a2b_hqx(s)</H5>
<P class="docText">Return the decoded version of a binhex-encoded string. A string containing a complete number of encoded binary bytes should be passed as the argument <TT>s</TT>.</P>
<A NAME="ch02lev4sec85"></A><H5 class="docSection4Title"> binascii.a2b_qp(s [,header=0])</H5>
<P class="docText">Return the decoded version of a quoted printable string. A string containing a complete number of encoded binary bytes should be passed as the argument <TT>s</TT>. If the optional argument <TT>header</TT> is specified, underscores will be decoded as spaces. New to Python 2.2.</P>
<A NAME="ch02lev4sec86"></A><H5 class="docSection4Title"> binascii.a2b_uu(s)</H5>
<P class="docText">Return the decoded version of a UUencoded string. A string consisting of exactly one encoding block should be passed as the argument <TT>s</TT> (for a full block, 62 bytes input, 45 bytes returned).</P>
<A NAME="ch02lev4sec87"></A><H5 class="docSection4Title"> binascii.b2a_base64(s)</H5>
<P class="docText">Return the based64 encoding of a binary string (including the newline after block). A binary string no longer than 57 bytes should be passed as the argument <TT>s</TT>.</P>
<A NAME="ch02lev4sec88"></A><H5 class="docSection4Title"> binascii.b2a_hex(s)</H5>
<P class="docText">Return the hexadecimal encoding of a binary string. A binary string of any length should be passed as the argument <TT>s</TT>.</P>
<A NAME="ch02lev4sec89"></A><H5 class="docSection4Title"> binascii.b2a_hqx(s)</H5>
<P class="docText">Return the binhex4 encoding of a binary string. A binary string of any length should be passed as the argument <TT>s</TT>. Run-length compression of <TT>s</TT> is not performed by this function (use <span class="docEmphasis"><TT>binascii.rlecode_hqx()</TT></span> first, if needed).</P>
<A NAME="ch02lev4sec90"></A><H5 class="docSection4Title"> binascii.b2a_qp(s [,quotetabs=0 [,istext=1 [header=0]]])</H5>
<P class="docText">Return the quoted printable encoding of a binary string. A binary string of any length should be passed as the argument <TT>s</TT>. The optional argument <TT>quotetabs</TT> specified whether to escape spaces and tabs; <TT>istext</TT> specifies <span class="docEmphasis">not</span> to newlines; <TT>header</TT> specifies whether to encode spaces as underscores (and escape underscores). New to Python 2.2.</P>
<A NAME="ch02lev4sec91"></A><H5 class="docSection4Title"> binascii.b2a_uu(s)</H5>
<P class="docText">Return the UUencoding of a binary string (including the initial block specifier—"M" for full blocks—and newline after block). A binary string no longer than 45 bytes should be passed as the argument <TT>s</TT>.</P>
<A NAME="ch02lev4sec92"></A><H5 class="docSection4Title"> binascii.crc32(s [,crc])</H5>
<P class="docText">Return the CRC32 checksum of the first argument <TT>s</TT>. If the second argument <TT>crc</TT> is specified, it will be used as an initial checksum. This allows partial computation of a checksum and continuation. For example:</P>
<pre>
&gt;&gt;&gt; import binascii
&gt;&gt;&gt; crc = binascii.crc32('spam')
&gt;&gt;&gt; binascii.crc32(' and eggs', crc)
739139840
&gt;&gt;&gt; binascii.crc32('spam and eggs')
739139840
</pre>
<A NAME="ch02lev4sec93"></A><H5 class="docSection4Title"> binascii.crc_hqx(s, crc)</H5>
<P class="docText">Return the binhex4 checksum of the first argument <TT>s</TT>, using initial checksum value in second argument. This allows partial computation of a checksum and continuation. For example:</P>
<pre>
&gt;&gt;&gt; import binascii
&gt;&gt;&gt; binascii.crc_hqx('spam and eggs', 0)
17918
&gt;&gt;&gt; crc = binascii.crc_hqx('spam', 0)
&gt;&gt;&gt; binascii.crc_hqx(' and eggs', crc)
17918
</pre>
<p class="docText"><span class="docEmphRoman">S<span class="docEmphSmaller">EE</span> A<span class="docEmphSmaller">LSO</span></span>: 
binascii.crc32 <span class="docEmphasis">160;</span></p>
<A NAME="ch02lev4sec94"></A><H5 class="docSection4Title"> binascii.hexlify(s)</H5>
<P class="docText">Identical to <span class="docEmphasis"><TT>binascii.b2a_hex()</TT></span>.</P>
<A NAME="ch02lev4sec95"></A><H5 class="docSection4Title"> binascii.rlecode_hqx(s)</H5>
<P class="docText">Return the binhex4 run-length encoding (RLE) of first argument <TT>s</TT>. Under this RLE technique, <TT>0x90</TT> is used as an indicator byte. Independent of the binhex4 standard, this is a poor choice of precompression for encoded strings.</P>
<p class="docText"><span class="docEmphRoman">S<span class="docEmphSmaller">EE</span> A<span class="docEmphSmaller">LSO</span></span>: 
zlib.compress() <span class="docEmphasis">182;</span></p>
<A NAME="ch02lev4sec96"></A><H5 class="docSection4Title"> binascii.rledecode_hqx(s)</H5>
<P class="docText">Return the expansion of a binhex4 run-length encoded string.</P>
<A NAME="ch02lev4sec97"></A><H5 class="docSection4Title"> binascii.unhexlify(s)</H5>
<P class="docText">Identical to <span class="docEmphasis"><TT>binascii.a2b_hex()</TT></span></P>
<A NAME="ch02lev3sec11"></A><H5 class="docSection3Title"> EXCEPTIONS</H5>
<A NAME="ch02lev4sec98"></A><H5 class="docSection4Title"> binascii.Error</H5>
<P class="docText">Generic exception that should only result from programming errors.</P>
<A NAME="ch02lev4sec99"></A><H5 class="docSection4Title"> binascii.Incomplete</H5>
<P class="docText">Exception raised when a data block is incomplete. Usually this results from programming errors in reading blocks, but it could indicate data or channel corruption.</P>
<p class="docText"><span class="docEmphRoman">S<span class="docEmphSmaller">EE</span> A<span class="docEmphSmaller">LSO</span></span>: 
base64 <span class="docEmphasis">158;</span> binhex <span class="docEmphasis">161;</span> uu <span class="docEmphasis">163;</span></p>
<P><A NAME="ch02sb07"></A><TABLE CELLSPACING="0" WIDTH="90%" BORDER="1"><TR><TD>
<P class="docText"><span class="docEmphStrong">binhex &#8226; Encode and decode binhex4 files</span></P></TD></TR></TABLE></P>
<P class="docText">The <span class="docEmphasis"><TT>binhex</TT></span> module is a wrapper around the functions <span class="docEmphasis"><TT>binascii.a2b_hqx()</TT>, <TT>binascii.b2a_hqx()</TT>, <TT>binascii.rlecode_hqx()</TT>, <TT>binascii.rledecode_hqx()</TT></span>, and <span class="docEmphasis"><TT>binascii.crc_hqx()</TT></span>. As well as providing a file-based interface on top of the underlying string conversions, <span class="docEmphasis"><TT>binhex</TT></span> handles run-length encoding of encoded files and attaches the needed header and footer information. Under MacOS, the resource fork of a file is encoded along with the data fork (not applicable under other platforms).</P>
<A NAME="ch02lev3sec12"></A><H5 class="docSection3Title"> FUNCTIONS</H5>
<A NAME="ch02lev4sec100"></A><H5 class="docSection4Title"> binhex.binhex(inp=..., out=...)</H5>
<P class="docText">Encode the contents of the first argument <TT>inp</TT> to the second argument <TT>out</TT>. Argument <TT>inp</TT> is a filename; <TT>out</TT> may be either a filename or a file-like object. However, a <span class="docEmphasis"><TT>cStringIO.StringIO</TT></span> object is not "file-like" enough since it will be closed after the conversion—and therefore, its value lost. You could override the . <TT>close()</TT> method in a subclass of <span class="docEmphasis"><TT>StringIO.StringIO</TT></span> to solve this limitation.</P>
<A NAME="ch02lev4sec101"></A><H5 class="docSection4Title"> binhex.hexbin(inp=...[,out=...])</H5>
<P class="docText">Decode the contents of the first argument to an output file. If the second argument <TT>out</TT> is specified, it will be used as the output filename, otherwise the filename will be taken from the binhex header. The argument <TT>inp</TT> may be either a filename or a file-like object.</P>
<A NAME="ch02lev3sec13"></A><H5 class="docSection3Title"> CLASSES</H5>
<P class="docText">A number of internal classes are used by <span class="docEmphasis"><TT>binhex</TT></span>. They are not documented here, but can be examined in <TT>$PYTHONHOME/lib/binhex.py</TT> if desired (it is unlikely readers will need to do this).</P>
<p class="docText"><span class="docEmphRoman">S<span class="docEmphSmaller">EE</span> A<span class="docEmphSmaller">LSO</span></span>: 
binascii <span class="docEmphasis">159;</span></p>
<P><A NAME="ch02sb08"></A><TABLE CELLSPACING="0" WIDTH="90%" BORDER="1"><TR><TD>
<P class="docText"><span class="docEmphStrong">quopri &#8226; Convert to/from quoted printable encoding (RFC1521)</span></P></TD></TR></TABLE></P>
<P class="docText">The <span class="docEmphasis"><TT>quopri</TT></span> module is a wrapper around the functions <span class="docEmphasis"><TT>binascii.a2b_qp()</TT></span> and <span class="docEmphasis"><TT>binascii.b2a_qp()</TT></span>. The module <span class="docEmphasis"><TT>quopri</TT></span> has the same methods as <span class="docEmphasis"><TT>base64</TT></span>. Unlike <span class="docEmphasis"><TT>uu</TT>, <TT>base64</TT></span> adds no content headers to encoded data; MIME standards for headers and message wrapping are handled by other modules that utilize <span class="docEmphasis"><TT>quopri</TT></span>. Quoted printable encoding is specified in RFC 1521.</P>
<A NAME="ch02lev3sec14"></A><H5 class="docSection3Title"> FUNCTIONS</H5>
<A NAME="ch02lev4sec102"></A><H5 class="docSection4Title"> quopri.encode(input, output, quotetabs)</H5>
<P class="docText">Encode the contents of the first argument <TT>input</TT> to the second argument <TT>output</TT>. Arguments <TT>input</TT> and <TT>output</TT> should be file-like objects; <TT>input</TT> must be readable and <TT>output</TT> must be writable. If <TT>quotetabs</TT> is a true value, escape tabs and spaces.</P>
<A NAME="ch02lev4sec103"></A><H5 class="docSection4Title"> quopri.encodestring(s [,quotetabs=0])</H5>
<P class="docText">Return the quoted printable encoding of the string passed in the first argument <TT>s</TT>. If <TT>quotetabs</TT> is a true value, escape tabs and spaces.</P>
<A NAME="ch02lev4sec104"></A><H5 class="docSection4Title"> quopri.decode(input=..., output=...[,header=0])</H5>
<P class="docText">Decode the contents of the first argument <TT>input</TT> to the second argument <TT>output</TT>. Arguments <TT>input</TT> and <TT>output</TT> should be file-like objects; <TT>input</TT> must be readable and <TT>output</TT> must be writable. If <TT>header</TT> is a true value, encode spaces as underscores and escape underscores.</P>
<A NAME="ch02lev4sec105"></A><H5 class="docSection4Title"> quopri.decodestring(s [,header=0])</H5>
<P class="docText">Return the decoding of the quoted printable string passed in the first argument <TT>s</TT>. If <TT>header</TT> is a true value, decode underscores as spaces.</P>
<p class="docText"><span class="docEmphRoman">S<span class="docEmphSmaller">EE</span> A<span class="docEmphSmaller">LSO</span></span>: 
email <span class="docEmphasis">345</span>; rfc822 <span class="docEmphasis">397</span>; mimetools <span class="docEmphasis">396;</span> mimetypes <span class="docEmphasis">374</span>; MimeWriter <span class="docEmphasis">396</span>; mimify <span class="docEmphasis">396;</span> binascii <span class="docEmphasis">159;</span> base64 <span class="docEmphasis">158;</span></p>
<P><A NAME="ch02sb09"></A><TABLE CELLSPACING="0" WIDTH="90%" BORDER="1"><TR><TD>
<P class="docText"><span class="docEmphStrong">uu &#8226; UUencode and UUdecode files</span></P></TD></TR></TABLE></P>
<P class="docText">The <span class="docEmphasis"><TT>uu</TT></span> module is a wrapper around the functions <span class="docEmphasis"><TT>binascii.a2b_uu()</TT></span> and <span class="docEmphasis"><TT>binascii.b2a_uu()</TT></span>. As well as providing a file-based interface on top of the underlying string conversions, <span class="docEmphasis"><TT>uu</TT></span> handles the chunking of binary files into UUencoded line blocks and attaches the needed header and footer.</P>
<A NAME="ch02lev3sec15"></A><H5 class="docSection3Title"> FUNCTIONS</H5>
<A NAME="ch02lev4sec106"></A><H5 class="docSection4Title"> uu.encode(in, out, [name=...[,mode=0666]])</H5>
<P class="docText">Encode the contents of the first argument <TT>in</TT> to the second argument <TT>out</TT>. Arguments <TT>in</TT> and <TT>out</TT> should be file objects, but filenames are also accepted (the latter is deprecated). The special filename "-" can be used to specify STDIN or STDOUT, as appropriate. When file objects are passed as arguments, <TT>in</TT> must be readable and <TT>out</TT> must be writable. The third argument <TT>name</TT> can be used to specify the filename that appears in the UUencoding header; by default it is the name of <TT>in</TT>. The fourth argument <TT>mode</TT> is the octal filemode to store in the UUencoding header.</P>
<A NAME="ch02lev4sec107"></A><H5 class="docSection4Title"> uu.decode(in, [,out_file=...[, mode=...])</H5>
<P class="docText">Decode the contents of the first argument <TT>in</TT> to an output file. If the second argument <TT>out_file</TT> is specified, it will be used as the output file; otherwise, the filename will be taken from the UUencoding header. Arguments <TT>in</TT> and <TT>out_file</TT> should be file objects, but filenames are also accepted (the latter is deprecated). If the third argument <TT>mode</TT> is specified (and if <TT>out_file</TT> is either unspecified or is a filename), open the created file in mode <TT>mode</TT>.</P>
<p class="docText"><span class="docEmphRoman">S<span class="docEmphSmaller">EE</span> A<span class="docEmphSmaller">LSO</span></span>: 
binascii <span class="docEmphasis">159;</span></p>
<A NAME="ch02lev2sec11"></A><H4 class="docSection2Title">2.2.4 Cryptography</H4>
<P class="docText">Python does not come with any standard and general cryptography modules. The few included capabilities are fairly narrow in purpose and limited in scope. The capabilities in the standard library consist of several cryptographic hashes and one weak symmetrical encryption algorithm. A quick survey of cryptographic techniques shows what capabilities are absent from the standard library:</P>
<p class="docText"><span class="docEmphStrong">Symmetrical Encryption</span>: 
Any technique by which a plaintext message M is "encrypted" with a key K to produce a cyphertext C. Application of K—or some K' easily derivable from K—to C is called "decryption" and produces as output M. The standard module <span class="docEmphasis"><TT>rotor</TT></span> provides a form of symmetrical encryption.</p>
<p class="docText"><span class="docEmphStrong">Cryptographic Hash</span>: 
Any technique by which a short "hash" H is produced from a plaintext message M that has several additional properties: (1) Given only H, it is difficult to obtain any M' such that the cryptographic hash of M' is H; (2) Given two plaintext messages M and M', there is a very low probability that the cryptographic hashes of M and M' are the same. Sometimes a third property is included: (3) Given M, its cryptographic hash H, and another hash H', examining the relationship between H and H' does not make it easier to find an M' whose hash is H'. The standard modules <span class="docEmphasis"><TT>crypt</TT>, <TT>md5</TT></span>, and <span class="docEmphasis"><TT>sha</TT></span> provide forms of cryptographic hashes.</p>
<p class="docText"><span class="docEmphStrong">Asymmetrical Encryption</span>: 
Also called "public-key cryptography." Any technique by which a pair of keys <span class="docEmphasis"><TT>K</TT><TT><SUB>pub</SUB></TT></span> and <span class="docEmphasis"><TT>K</TT><TT><SUB>priv</SUB></TT></span> can be generated that have several properties. The algorithm for an asymmetrical encryption technique will be called "P(M,K)" in the following. (1) For any plaintext message M, M equals P(<span class="docEmphasis"><TT>K</TT><TT><SUB>priv</SUB></TT></span>,P(M,<span class="docEmphasis"><TT>K</TT><TT><SUB>pub</SUB></TT></span>)). (2) Given only a public-key <span class="docEmphasis"><TT>K</TT><TT><SUB>pub</SUB></TT></span>, it is difficult to obtain a private-key <span class="docEmphasis"><TT>K</TT><TT><SUB>priv</SUB></TT></span> that assures the equality in (1). (3) Given only P(M,<span class="docEmphasis"><TT>K</TT><TT><SUB>pub</SUB></TT></span>), it is difficult to obtain M. In general, in an asymmetrical encryption system, a user generates <span class="docEmphasis"><TT>K</TT><TT><SUB>pub</SUB></TT></span> and <span class="docEmphasis"><TT>K</TT><TT><SUB>priv</SUB></TT></span>, then releases <span class="docEmphasis"><TT>K</TT><TT><SUB>pub</SUB></TT></span> to other users but retains <span class="docEmphasis"><TT>K</TT><TT><SUB>priv</SUB></TT></span> as a secret. There is no support for asymmetrical encryption in the standard library.</p>
<p class="docText"><span class="docEmphStrong">Digital Signatures</span>: 
Digital signatures are really just "public-keys in reverse." In many cases, the same underlying algorithm is used for each. A digital signature is any technique by which a pair of keys <span class="docEmphasis"><TT>K</TT><TT><SUB>ver</SUB></TT></span> and <span class="docEmphasis"><TT>K</TT><TT><SUB>sig</SUB></TT></span> can be generated that have several properties. The algorithm for a digital signature will be called S(M,K) in the following. (1) For any message M, M equals P(<span class="docEmphasis"><TT>K</TT><TT><SUB>ver</SUB></TT></span>,P(M,<span class="docEmphasis"><TT>K</TT><TT><SUB>sig</SUB></TT></span>)). (2) Given only a verification key <span class="docEmphasis"><TT>K</TT><TT><SUB>ver</SUB></TT></span>, it is difficult to obtain a signature key <span class="docEmphasis"><TT>K</TT><TT><SUB>sig</SUB></TT></span> that assures the equality in (1). (3) Given only P(M,<span class="docEmphasis"><TT>K</TT><TT><SUB>sig</SUB></TT></span>), it is difficult to find any C' such that P(<span class="docEmphasis"><TT>K</TT><TT><SUB>ver</SUB></TT></span>,C) is a plausible message (in other words, the signature shows it is not a forgery). In general, in a digital signature system, a user generates <span class="docEmphasis"><TT>K</TT><TT><SUB>ver</SUB></TT></span> and <span class="docEmphasis"><TT>K</TT><TT><SUB>sig</SUB></TT></span>, then releases <span class="docEmphasis"><TT>K</TT><TT><SUB>ver</SUB></TT></span> to other users but retains <span class="docEmphasis"><TT>K</TT><TT><SUB>sig</SUB></TT></span> as a secret. There is no support for digital signatures in the standard library.</p>
<p class="docText"><IMG BORDER="0" WIDTH="500" HEIGHT="17" src="FILES/common.gif" ALT="graphics/common.gif"></p>
<P class="docText">Those outlined are the most important cryptographic techniques. More detailed general introductions to cryptology and cryptography can be found at the author's Web site. A first tutorial is <span class="docEmphasis">Introduction to Cryptology Concepts I:</span></P>
<BLOCKQUOTE><P><P class="docList"><TT>&lt;</TT><A class="docLink" target="_blank" HREF="http://gnosis.cx/publish/programming/cryptologyl.pdf">http://gnosis.cx/publish/programming/cryptologyl.pdf</A><TT>&gt;</TT></P></P></BLOCKQUOTE>
<P class="docText">Further material is in <span class="docEmphasis">Introduction to Cryptology Concepts II:</span></P>
<BLOCKQUOTE><P><P class="docList"><TT>&lt;</TT><A class="docLink" target="_blank" HREF="http://gnosis.cx/publish/programming/cryptology2.pdf">http://gnosis.cx/publish/programming/cryptology2.pdf</A><TT>&gt;</TT></P></P></BLOCKQUOTE>
<P class="docText">And more advanced material is in <span class="docEmphasis">Intermediate Cryptology: Specialized Protocols:</span></P>
<BLOCKQUOTE><P><P class="docList"><TT>&lt;</TT><A class="docLink" target="_blank" HREF="http://gnosis.cx/publish/programming/cryptology3.pdf">http://gnosis.cx/publish/programming/cryptology3.pdf</A><TT>&gt;</TT></P></P></BLOCKQUOTE>
<P class="docText">A number of third-party modules have been created to handle cryptographic tasks; a good guide to these third-party tools is the Vaults of Parnassus Encryption/Encoding index at <TT>&lt;</TT><A class="docLink" target="_blank" HREF="http://www.vex.net/parnassus/apyllo.py@i=94738404">http://www.vex.net/parnassus/apyllo.py?i=94738404</A><TT>&gt;</TT>. Only the tools in the standard library will be covered here specifically, since all the third-party tools are somewhat far afield of the topic of text processing as such. Moreover, third-party tools often rely on additional non-Python libraries, which will not be present on most platforms, and these tools will not necessarily be maintained as new Python versions introduce changes.</P>
<P class="docText">The most important third-party modules are listed below. These are modules that the author believes are likely to be maintained and that provide access to a wide range of cryptographic algorithms.</P>
<A NAME="ch02lev4sec108"></A><H5 class="docSection3Title"> mxCrypto<br>amkCrypto</H5>
<P class="docText">Marc-Andre Lemburg and Andrew Kuchling—both valuable contributors of many Python modules—have played a game of leapfrog with each other by releasing <span class="docEmphasis"><TT>mxCrypto</TT></span> and <span class="docEmphasis"><TT>amkCrypto</TT></span>, respectively. Each release of either module builds on the work of the other, providing compatible interfaces and overlapping source code. Whatever is newest at the time you read this is the best bet. Current information on both should be obtainable from:</P>
<BLOCKQUOTE><P><P class="docList"><TT>&lt;</TT><A class="docLink" target="_blank" HREF="http://www.amk.ca/python/code/crypto.html">http://www.amk.ca/python/code/crypto.html</A><TT>&gt;</TT></P></P></BLOCKQUOTE>
<A NAME="ch02lev4sec109"></A><H5 class="docSection3Title"> Python Cryptography</H5>
<P class="docText">Andrew Kuchling, who has provided a great deal of excellent Python documentation, documents these cryptography modules at:</P>
<BLOCKQUOTE><P><P class="docList"><TT>&lt;</TT><A class="docLink" target="_blank" HREF="http://www.amk.ca/python/writing/pycrypt/default.htm">http://www.amk.ca/python/writing/pycrypt/</A><TT>&gt;</TT></P></P></BLOCKQUOTE>
<A NAME="ch02lev4sec110"></A><H5 class="docSection3Title"> M2Crypto</H5>
<P class="docText">The <span class="docEmphasis"><TT>mxCrypto</TT></span> and <span class="docEmphasis"><TT>amkCrypto</TT></span> modules are most readily available for Unix-like platforms. A similar range of cryptographic capabilities for a Windows platform is available in Ng Pheng Siong's <span class="docEmphasis"><TT>M2Crypto</TT></span>. Information and documentation can be found at:</P>
<BLOCKQUOTE><P><P class="docList"><TT>&lt;</TT><A class="docLink" target="_blank" HREF="http://www.post1.com/home/ngps/m2/default.htm">http://www.post1.com/home/ngps/m2/</A><TT>&gt;</TT></P></P></BLOCKQUOTE>
<A NAME="ch02lev4sec111"></A><H5 class="docSection3Title"> fcrypt</H5>
<P class="docText">Carey Evans has created <span class="docEmphasis"><TT>fcrypt</TT></span>, which is a pure-Python, single-module replacement for the standard library's <span class="docEmphasis"><TT>crypt</TT></span> module. While probably orders-of-magnitude slower than a C implementation, <span class="docEmphasis"><TT>fcrypt</TT></span> will run anywhere that Python does (and speed is rarely an issue for this functionality). <span class="docEmphasis"><TT>fcrypt</TT></span> may be obtained at:</P>
<BLOCKQUOTE><P><P class="docList"><TT>&lt;</TT><A class="docLink" target="_blank" HREF="http://home.clear.net.nz/pages/c.evans/sw/default.htm">http://home.clear.net.nz/pages/c.evans/sw/</A><TT>&gt;</TT></P></P></BLOCKQUOTE>
<P><A NAME="ch02sb10"></A><TABLE CELLSPACING="0" WIDTH="90%" BORDER="1"><TR><TD>
<P class="docText"><span class="docEmphStrong">crypt &#8226; Create and verify Unix-style passwords</span></P></TD></TR></TABLE></P>
<P class="docText">The <TT>crypt()</TT> function is a frequently used, but somewhat antiquated, password creation/verification tool. Under Unix-like systems, <TT>crypt()</TT> is contained in system libraries and may be called from wrapper functions in languages like Python. <TT>crypt()</TT> is a form of cryptographic hash based on the Data Encryption Standard (DES). The hash produced by <TT>crypt()</TT> is based on an 8-byte key and a 2-byte "salt." The output of <TT>crypt()</TT> is produced by repeated encryption of a constant string, using the user key as a DES key and the salt to perturb the encryption in one of 4,096 ways. Both the key and the salt are restricted to alphanumerics plus dot and slash.</P>
<P class="docText">By using a cryptographic hash, passwords may be stored in a relatively insecure location. An imposter cannot easily produce a false password that will hash to the same value as the one stored in the password file, even given access to the password file. The salt is used to make "dictionary attacks" more difficult. If an imposter has access to the password file, she might try applying <TT>crypt()</TT> to a candidate password and compare the result to every entry in the password file. Without a salt, the chances of matching <span class="docEmphasis">some</span> encrypted password would be higher. The salt (a random value should be used) decreases the chance of such a random guess by 4,096 times.</P>
<P class="docText">The <span class="docEmphasis"><TT>crypt</TT></span> module is only installed on some Python systems (even only some Unix systems). Moreover, the module, if installed, relies on an underlying system library. For a portable approach to password creation, the third-party <span class="docEmphasis"><TT>fcrypt</TT></span> module provides a portable, pure-Python reimplementation.</P>
<A NAME="ch02lev3sec16"></A><H5 class="docSection3Title"> FUNCTIONS</H5>
<A NAME="ch02lev4sec112"></A><H5 class="docSection4Title"> crypt.crypt(passwd, salt)</H5>
<P class="docText">Return an ASCII 13-byte encrypted password. The first argument <TT>passwd</TT> must be a string up to eight characters in length (extra characters are truncated and do not affect the result). The second argument <TT>salt</TT> must be a string up to two characters in length (extra characters are truncated). The value of <TT>salt</TT> forms the first two characters of the result.</P>
<pre>
&gt;&gt;&gt; from crypt import crypt
&gt;&gt;&gt; crypt('mypassword','XY')
'XY5XuULXk4pcs'
&gt;&gt;&gt; crypt('mypasswo','XY')
'XY5XuULXk4pcs'
&gt;&gt;&gt; crypt('mypassword...more.characters','XY')
'XY5XuULXk4pcs'
&gt;&gt;&gt; crypt('mypasswo','AB')
'AB061nfYxWIKg'
&gt;&gt;&gt; crypt('diffpass','AB')
'AB105BopaFYNs'
</pre>
<p class="docText"><span class="docEmphRoman">S<span class="docEmphSmaller">EE</span> A<span class="docEmphSmaller">LSO</span></span>: 
fcrypt <span class="docEmphasis">165;</span> md5 <span class="docEmphasis">167;</span> sha <span class="docEmphasis">170;</span></p>
<P><A NAME="ch02sb11"></A><TABLE CELLSPACING="0" WIDTH="90%" BORDER="1"><TR><TD>
<P class="docText"><span class="docEmphStrong">md5 &#8226; Create MD5 message digests</span></P></TD></TR></TABLE></P>
<P class="docText">RSA Data Security, Inc.'s MD5 cryptographic hash is a popular algorithm that is codified by RFC1321. Like <span class="docEmphasis"><TT>sha</TT></span>, and unlike <span class="docEmphasis"><TT>crypt</TT>, <TT>md5</TT></span> allows one to find the cryptographic hash of arbitrary strings (Unicode strings may not be hashed, however). Absent any other considerations—such as compatibility with other programs—Secure Hash Algorithm (SHA) is currently considered a better algorithm than MD5, and the <span class="docEmphasis"><TT>sha</TT></span> module should be used for cryptographic hashes. The operation of <span class="docEmphasis"><TT>md5</TT></span> objects is similar to <span class="docEmphasis"><TT>binascii.crc32()</TT></span> hashes in that the final hash value may be built progressively from partial concatenated strings. The MD5 algorithm produces a 128-bit hash.</P>
<A NAME="ch02lev3sec17"></A><H5 class="docSection3Title"> CONSTANTS</H5>
<A NAME="ch02lev4sec113"></A><H5 class="docSection4Title"> md5.MD5Type</H5>
<P class="docText">The type of an <span class="docEmphasis"><TT>md5.new</TT></span> instance.</P>
<A NAME="ch02lev3sec18"></A><H5 class="docSection3Title"> CLASSES</H5>
<A NAME="ch02lev4sec114"></A><H5 class="docSection4Title"> md5.new([s])</H5>
<P class="docText">Create an <span class="docEmphasis"><TT>md5</TT></span> object. If the first argument <TT>s</TT> is specified, initialize the MD5 digest buffer with the initial string <TT>s</TT>. An MD5 hash can be computed in a single line with:</P>
<pre>
&gt;&gt;&gt; import md5
&gt;&gt;&gt; md5.new('Mary had a little lamb').hexdigest()
'e946adb45d4299def2071880d30136d4'
</pre>
<A NAME="ch02lev4sec115"></A><H5 class="docSection4Title"> md5.md5([s])</H5>
<P class="docText">Identical to <span class="docEmphasis"><TT>md5.new</TT></span>.</P>
<A NAME="ch02lev3sec19"></A><H5 class="docSection3Title"> METHODS</H5>
<A NAME="ch02lev4sec116"></A><H5 class="docSection4Title"> md5.copy()</H5>
<P class="docText">Return a new <span class="docEmphasis"><TT>md5</TT></span> object that is identical to the current state of the current object. Different terminal strings can be concatenated to the clone objects after they are copied. For example:</P>
<pre>
&gt;&gt;&gt; import md5
&gt;&gt;&gt; m = md5.new('spam and eggs')
&gt;&gt;&gt; m.digest()
'\xb5\x81f\xOc\xff\x17\xe7\x8c\x84\xc3\xa8J\xdO.g\x85'
&gt;&gt;&gt; m2 = m.copy()
&gt;&gt;&gt; m2.digest()
'\xb5\x81f\xOc\xff\x17\xe7\x8c\x84\xc3\xa8J\xdO.g\x85'
&gt;&gt;&gt; m.update(' are tasty')
&gt;&gt;&gt; m2.update(' are wretched')
&gt;&gt;&gt; m.digest()
'*\x94\xa2\xc5\xceq\x96\xef&amp;\x1a\xc9#\xac98\x16'
&gt;&gt;&gt; m2.digest()
'h\x8c\xfam\xe3\xbO\x90\xe8\xOe\xcb\xbf\xb3\xa7N\xe6\xbc'
</pre>
<A NAME="ch02lev4sec117"></A><H5 class="docSection4Title"> md5.digest()</H5>
<P class="docText">Return the 128-bit digest of the current state of the <span class="docEmphasis"><TT>md5</TT></span> object as a 16-byte string. Each byte will contain a full 8-bit range of possible values.</P>
<pre>
&gt;&gt;&gt; import md5          # Python 2.1+
&gt;&gt;&gt; m = md5.new('spam and eggs')
&gt;&gt;&gt; m.digest()
'\xb5\x81f\xOc\xff\x17\xe7\x8c\x84\xc3\xa8J\xdO.g\x85'

&gt;&gt;&gt;  import md5         # Python &lt;= 2.0
&gt;&gt;&gt; m = md5.new('spam and eggs')
&gt;&gt;&gt; m.digest()
'\265\201f\014\377\027\347\214\204\303\250J\320.g\205'
</pre>
<A NAME="ch02lev4sec118"></A><H5 class="docSection4Title"> md5.hexdigest()</H5>
<P class="docText">Return the 128-bit digest of the current state of the <span class="docEmphasis"><TT>md5</TT></span> object as a 32-byte hexadecimal-encoded string. Each byte will contain only values in <span class="docEmphasis"><TT>string.hexdigits</TT></span>. Each pair of bytes represents 8-bits of hash, and this format may be transmitted over 7-bit ASCII channels like email.</P>
<pre>
&gt;&gt;&gt; import md5
&gt;&gt;&gt; m = md5.new('spam and eggs')
&gt;&gt;&gt; m.hexdigest()
'b581660cff17e78c84c3a84ad02e6785'
</pre>
<A NAME="ch02lev4sec119"></A><H5 class="docSection4Title"> md5.update(s)</H5>
<P class="docText">Concatenate additional strings to the <span class="docEmphasis"><TT>md5</TT></span> object. Current hash state is adjusted accordingly. The number of concatenation steps that go into an MD5 hash does not affect the final hash, only the actual string that would result from concatenating each part in a single string. However, for large strings that are determined incrementally, it may be more practical to call <span class="docEmphasis"><TT>md5.update()</TT></span> numerous times. For example:</P>
<pre>
&gt;&gt;&gt; import md5
&gt;&gt;&gt; ml = md5.new('spam and eggs')
&gt;&gt;&gt; m2 = md5.new('spam')
&gt;&gt;&gt; m2.update(' and eggs')
&gt;&gt;&gt; m3 = md5.new('spam')
&gt;&gt;&gt; m3.update(' and ')
&gt;&gt;&gt; m3.update('eggs')
&gt;&gt;&gt; m1.hexdigest()
'b581660cff17e78c84c3a84ad02e6785'
&gt;&gt;&gt; m2.hexdigest()
'b581660cff17e78c84c3a84ad02e6785'
&gt;&gt;&gt; m3.hexdigest()
'b581660cff17e78c84c3a84ad02e6785'
</pre>
<p class="docText"><span class="docEmphRoman">S<span class="docEmphSmaller">EE</span> A<span class="docEmphSmaller">LSO</span></span>: 
sha <span class="docEmphasis">170;</span> crypt <span class="docEmphasis">166;</span> binascii.crc32() <span class="docEmphasis">160;</span></p>
<P><A NAME="ch02sb12"></A><TABLE CELLSPACING="0" WIDTH="90%" BORDER="1"><TR><TD>
<P class="docText"><span class="docEmphStrong">rotor &#8226; Perform Enigma-like encryption and decryption</span></P></TD></TR></TABLE></P>
<P class="docText">The <span class="docEmphasis"><TT>rotor</TT></span> module is a bit of a curiosity in the Python standard library. The symmetric encryption performed by <span class="docEmphasis"><TT>rotor</TT></span> is similar to that performed by the extremely historically interesting and important Enigma algorithm. Given Alan Turing's famous role not just in inventing the theory of computability, but also in cracking German encryption during WWII, there is a nice literary quality to the inclusion of <span class="docEmphasis"><TT>rotor</TT></span> in Python. However, <span class="docEmphasis"><TT>rotor</TT></span> should not be mistaken for a robust modern encryption algorithm. Bruce Schneier has commented that there are two types of encryption algorithms: those that will stop your little sister from reading your messages, and those that will stop major governments and powerful organization from reading your messages. <span class="docEmphasis"><TT>rotor</TT></span> is in the first category—albeit allowing for rather bright little sisters. But <span class="docEmphasis"><TT>rotor</TT></span> will not help much against TLAs (three letter agencies). On the other hand, there is nothing else in the Python standard library that performs actual military-grade encryption, either.</P>
<A NAME="ch02lev3sec20"></A><H5 class="docSection3Title"> CLASSES</H5>
<A NAME="ch02lev4sec120"></A><H5 class="docSection4Title"> rotor.newrotor(key [,numrotors])</H5>
<P class="docText">Return a <span class="docEmphasis"><TT>rotor</TT></span> object with rotor permutations and positions based on the first argument <TT>key</TT>. If the second argument <TT>numrotors</TT> is specified, a number of rotors other than the default of 6 can be used (more is stronger). A rotor encryption can be computed in a single line with:</P>
<pre>
&gt;&gt;&gt; rotor.newrotor('mypassword').encrypt('Mary had a lamb')
'\x10\xef\xf1\x1e\xeaor\xe9\xf7\xe5\xad,r\xc6\x9f'
</pre>
<P class="docText">Object style encryption and decryption is performed like the following:</P>
<pre>
&gt;&gt;&gt; import rotor
&gt;&gt;&gt; C = rotor.newrotor('pass2').encrypt('Mary had a little lamb')
&gt;&gt;&gt; r1 = rotor.newrotor('mypassword')
&gt;&gt;&gt; C2 = r1.encrypt('Mary had a little lamb')
&gt;&gt;&gt; r1.decrypt(C2)
'Mary had a little lamb'
&gt;&gt;&gt; r1.decrypt(C)   # Let's try it
'\217R$\217/sE\311\330~#\310\342\200\025F\221\245\263\036\2200'
&gt;&gt;&gt; r1.setkey('pass2')
&gt;&gt;&gt; r1.decrypt(C)   # Let's try it
'Mary had a little lamb'
</pre>
<A NAME="ch02lev3sec21"></A><H5 class="docSection3Title"> METHODS</H5>
<A NAME="ch02lev4sec121"></A><H5 class="docSection4Title"> rotor.decrypt(s)</H5>
<P class="docText">Return a decrypted version of cyphertext string <TT>s</TT>. Prior to decryption, rotors are set to their initial positions.</P>
<A NAME="ch02lev4sec122"></A><H5 class="docSection4Title"> rotor.decryptmore(s)</H5>
<P class="docText">Return a decrypted version of cyphertext string <TT>s</TT>. Prior to decryption, rotors are left in their current positions.</P>
<A NAME="ch02lev4sec123"></A><H5 class="docSection4Title"> rotor.encrypt(s)</H5>
<P class="docText">Return an encrypted version of plaintext string <TT>s</TT>. Prior to encryption, rotors are set to their initial positions.</P>
<A NAME="ch02lev4sec124"></A><H5 class="docSection4Title"> rotor.encryptmore(s)</H5>
<P class="docText">Return an encrypted version of plaintext string <TT>s</TT>. Prior to encryption, rotors are left in their current positions.</P>
<A NAME="ch02lev4sec125"></A><H5 class="docSection4Title"> rotor.setkey (key)</H5>
<P class="docText">Set a new key for a <span class="docEmphasis"><TT>rotor</TT></span> object.</P>
<P><A NAME="ch02sb13"></A><TABLE CELLSPACING="0" WIDTH="90%" BORDER="1"><TR><TD>
<P class="docText"><span class="docEmphStrong">sha &#8226; Create </span><span class="docEmphStrong">SHA</span> <span class="docEmphStrong">message digests</span></P></TD></TR></TABLE></P>
<P class="docText">The National Institute of Standards and Technology's (NIST's) Secure Hash Algorithm is the best well-known cryptographic hash for most purposes. Like <span class="docEmphasis"><TT>md5</TT></span>, and unlike <span class="docEmphasis"><TT>crypt</TT>, <TT>sha</TT></span> allows one to find the cryptographic hash of arbitrary strings (Unicode strings may not be hashed, however). Absent any other considerations—such as compatibility with other programs—SHA is currently considered a better algorithm than MD5, and the <span class="docEmphasis"><TT>sha</TT></span> module should be used for cryptographic hashes. The operation of <span class="docEmphasis"><TT>sha</TT></span> objects is similar to <span class="docEmphasis"><TT>binascii.crc32()</TT></span> hashes in that the final hash value may be built progressively from partial concatenated strings. The SHA algorithm produces a 160-bit hash.</P>
<A NAME="ch02lev3sec22"></A><H5 class="docSection3Title"> CLASSES</H5>
<A NAME="ch02lev4sec126"></A><H5 class="docSection4Title"> sha.new([s])</H5>
<P class="docText">Create an <span class="docEmphasis"><TT>sha</TT></span> object. If the first argument <TT>s</TT> is specified, initialize the SHA digest buffer with the initial string <TT>s</TT>. An SHA hash can be computed in a single line with:</P>
<pre>
&gt;&gt;&gt; import sha
&gt;&gt;&gt; sha.new('Mary had a little lamb').hexdigest()
'bac9388d0498fb378e528d35abd05792291af182'
</pre>
<A NAME="ch02lev4sec127"></A><H5 class="docSection4Title"> sha.sha ([s])</H5>
<P class="docText">Identical to <span class="docEmphasis"><TT>sha.new</TT></span>.</P>
<A NAME="ch02lev3sec23"></A><H5 class="docSection3Title"> METHODS</H5>
<A NAME="ch02lev4sec128"></A><H5 class="docSection4Title"> sha.copy()</H5>
<P class="docText">Return a new <span class="docEmphasis"><TT>sha</TT></span> object that is identical to the current state of the current object. Different terminal strings can be concatenated to the clone objects after they are copied. For example:</P>
<pre>
&gt;&gt;&gt; import sha
&gt;&gt;&gt; s = sha.new('spam and eggs')
&gt;&gt;&gt; s.digest()
'\276\207\224\213\255\375x\024\245b\036C\322\017\2528 @\017\246'
&gt;&gt;&gt; s2 = s.copy()
&gt;&gt;&gt; s2.digest()
'\276\207\224\213\255\375x\024\245b\036C\322\017\2528 @\017\246'
&gt;&gt;&gt; s.update(' are tasty')
&gt;&gt;&gt; s2.update(' are wretched')
&gt;&gt;&gt; s.digest()
'\013^C\366\253?I\323\206nt\2443\251\227\204-kr6'
&gt;&gt;&gt; s2.digest()
'\013\210\237\216\014\3337X\333\221h&amp;+c\345\007\367\326\274\321'
</pre>
<A NAME="ch02lev4sec129"></A><H5 class="docSection4Title"> sha.digest()</H5>
<P class="docText">Return the 160-bit digest of the current state of the <span class="docEmphasis"><TT>sha</TT></span> object as a 20-byte string. Each byte will contain a full 8-bit range of possible values.</P>
<pre>
&gt;&gt;&gt; import sha          # Python 2.1+
&gt;&gt;&gt; s = sha.new('spam and eggs')
&gt;&gt;&gt; s.digest()
'\xbe\x87\x94\x8b\xad\xfdx\x14\xa5b\xleC\xd2\xOf\xaa8 @\xOf\xa6'

&gt;&gt;&gt; import sha          # Python &lt;= 2.0
&gt;&gt;&gt; s = sha.new('spam and eggs')
&gt;&gt;&gt; s.digest()
'\276\207\224\213\255\375x\024\245b\036C\322\017\2528 @\017\246'
</pre>
<A NAME="ch02lev4sec130"></A><H5 class="docSection4Title"> sha.hexdigest()</H5>
<P class="docText">Return the 160-bit digest of the current state of the <span class="docEmphasis"><TT>sha</TT></span> object as a 40-byte hexadecimal-encoded string. Each byte will contain only values in <span class="docEmphasis"><TT>string.hexdigits</TT></span>. Each pair of bytes represents 8-bits of hash, and this format may be transmitted over 7-bit ASCII channels like email.</P>
<pre>
&gt;&gt;&gt; import sha
&gt;&gt;&gt; s = sha.new('spam and eggs')
&gt;&gt;&gt; s.hexdigest()
'be87948badfd7814a5621e43d20faa3820400fa6'
</pre>
<A NAME="ch02lev4sec131"></A><H5 class="docSection4Title"> sha.update(s)</H5>
<P class="docText">Concatenate additional strings to the <span class="docEmphasis"><TT>sha</TT></span> object. Current hash state is adjusted accordingly. The number of concatenation steps that go into an SHA hash does not affect the final hash, only the actual string that would result from concatenating each part in a single string. However, for large strings that are determined incrementally, it may be more practical to call <span class="docEmphasis"><TT>sha.update()</TT></span> numerous times. For example:</P>
<pre>
&gt;&gt;&gt; import sha
&gt;&gt;&gt; s1 = sha.sha('spam and eggs')
&gt;&gt;&gt; s2 = sha.sha('spam')
&gt;&gt;&gt; s2.update(' and eggs')
&gt;&gt;&gt; s3 = sha.sha('spam')
&gt;&gt;&gt; s3.update(' and ')
&gt;&gt;&gt; s3.update('eggs')
&gt;&gt;&gt; s1.hexdigest()
'be87948badfd7814a5621e43d20faa3820400fa6'
&gt;&gt;&gt; s2.hexdigest()
'be87948badfd7814a5621e43d20faa3820400fa6'
&gt;&gt;&gt; s3.hexdigest()
'be87948badfd7814a5621e43d20faa3820400fa6'
</pre>
<p class="docText"><span class="docEmphRoman">S<span class="docEmphSmaller">EE</span> A<span class="docEmphSmaller">LSO</span></span>: 
md5 <span class="docEmphasis">167;</span> crypt <span class="docEmphasis">166;</span> binascii.crc32() <span class="docEmphasis">160;</span></p>
<A NAME="ch02lev2sec12"></A><H4 class="docSection2Title">2.2.5 Compression</H4>
<P class="docText">Over the history of computers, a large number of data compression formats have been invented, mostly as variants on Lempel-Ziv and Huffman techniques. Compression is useful for all sorts of data streams, but file-level archive formats have been the most widely used and known application. Under MS-DOS and Windows we have seen ARC, PAK, ZOO, LHA, ARJ, CAB, RAR, and other formats—but the ZIP format has become the most widespread variant. Under Unix-like systems, <TT>compress</TT> (.Z) mostly gave way to <TT>gzip</TT> (GZ); <TT>gzip</TT> is still the most popular format on these systems, but <TT>bzip</TT> (BZ2) generally obtains better compression rates. Under MacOS, the most popular format is SIT. Other platforms have additional variants on archive formats, but ZIP—and to a lesser extent GZ—are widely supported on a number of platforms.</P>
<P class="docText">The Python standard library includes support for several styles of compression. The <span class="docEmphasis"><TT>zlib</TT></span> module performs low-level compression of raw string data and has no concept of a file. <span class="docEmphasis"><TT>zlib</TT></span> is itself called by the high-level modules below for its compression services.</P>
<P class="docText">The modules <span class="docEmphasis"><TT>gzip</TT></span> and <span class="docEmphasis"><TT>zipfile</TT></span> provide file-level interfaces to compressed archives. However, a notable difference in the operation of <span class="docEmphasis"><TT>gzip</TT></span> and <span class="docEmphasis"><TT>zipfile</TT></span> arises out of a difference in the underlying GZ and ZIP formats. <TT>gzip</TT> (GZ) operates exclusively on single files—leaving the work of concatenating collections of files to tools like <TT>tar</TT>. One frequently encounters (especially on Unix-like systems) files like <TT>foo.tar.gz</TT> or <TT>foo.tgz</TT> that are produced by first applying <TT>tar</TT> to a collection of files, then applying <TT>gzip</TT> to the result. ZIP, however, handles both the compression and archiving aspects in a single tool and format. As a consequence, <span class="docEmphasis"><TT>gzip</TT></span> is able to create file-like objects based directly on the compressed contents of a GZ file. <span class="docEmphasis"><TT>ziplib</TT></span> needs to provide more specialized methods for navigating archive contents and for working with individual compressed file images therein.</P>
<P class="docText">Also see <A class="docLink" HREF="0321112547_app02.html#app02">Appendix B</A> (A Data Compression Primer).</P>
<P><A NAME="ch02sb14"></A><TABLE CELLSPACING="0" WIDTH="90%" BORDER="1"><TR><TD>
<P class="docText"><span class="docEmphStrong">gzip &#8226; Functions that read and write gzipped files</span></P></TD></TR></TABLE></P>
<P class="docText">The <span class="docEmphasis"><TT>gzip</TT></span> module allows the treatment of the compressed data inside <TT>gzip</TT> compressed files directly in a file-like manner. Uncompressed data can be read out, and compressed data written back in, all without a caller knowing or caring that the file is a GZ-compressed file. A simple example illustrates this:</P>
<H5 class="docExampleTitle"><A NAME="ch02list09"></A> gzip_file.py</H5>

<PRE>
# Treat a GZ as "just another file"
import gzip, glob
print "Size of data in files:"
for fname in glob.glob('*'):
    try:
        if fname[-3:] == '.gz':
            s = gzip.open(fname).read()
        else:
            s = open(fname).read()
        print ' ',fname,'-',len(s),'bytes'
    except IOError:
        print 'Skipping',file
</PRE>
<P class="docText">The module <span class="docEmphasis"><TT>gzip</TT></span> is a wrapper around <span class="docEmphasis"><TT>zlib</TT></span>, with the latter performing the actual compression and decompression tasks. In many respects, <span class="docEmphasis"><TT>gzip</TT></span> is similar to <span class="docEmphasis"><TT>mmap</TT></span> and <span class="docEmphasis"><TT>StringI0</TT></span> in emulating and/or wrapping a file object.</P>
<p class="docText"><span class="docEmphRoman">S<span class="docEmphSmaller">EE</span> A<span class="docEmphSmaller">LSO</span></span>: 
mmap <span class="docEmphasis">147;</span> StringIO <span class="docEmphasis">153;</span> cStringIO <span class="docEmphasis">153</span>;</p>
<A NAME="ch02lev3sec24"></A><H5 class="docSection3Title"> CLASSES</H5>
<A NAME="ch02lev4sec132"></A><H5 class="docSection4Title"> gzip.GzipFile([filename=...[,mode="rb" [,compresslevel=9 [,fileobj=...]]]])</H5>
<P class="docText">Create a <span class="docEmphasis"><TT>gzip</TT></span> file-like object. Such an object supports most file object operations, with the exception of .<TT>seek()</TT> and .<TT>tell()</TT>. Either the first argument <TT>filename</TT> or the fourth argument <TT>fileobj</TT> should be specified (likely by argument name, especially if fourth argument <TT>fileobj</TT>).</P>
<P class="docText">The second argument <TT>mode</TT> takes the mode of <TT>fileobj</TT> if specified, otherwise it defaults to <TT>rb</TT> (<TT>r</TT>, <TT>rb</TT>, <TT>a</TT>, <TT>ab</TT>, <TT>w</TT>, or <TT>wb</TT> may be specified with the same meaning as with <span class="docEmphasis"><TT>FILE.open()</TT></span> objects). The third argument <TT>compresslevel</TT> specifies the level of compression. The default is the highest level, 9; an integer down to 1 may be selected for less compression but faster operation (compression level of a read file comes from the file itself, however).</P>
<A NAME="ch02lev4sec133"></A><H5 class="docSection4Title"> gzip.open(filename=...[mode='rb [,compresslevel=9]])</H5>
<P class="docText">Same as <span class="docEmphasis"><TT>gzip.GzipFile</TT></span> but with extra arguments omitted. A GZ file object opened with <span class="docEmphasis"><TT>gzip.open</TT></span> is always opened by name, not by underlying file object.</P>
<A NAME="ch02lev3sec25"></A><H5 class="docSection3Title"> METHODS AND ATTRIBUTES</H5>
<A NAME="ch02lev4sec134"></A><H5 class="docSection4Title"> gzip.close()</H5>
<P class="docText">Close the <span class="docEmphasis"><TT>gzip</TT></span> object. No access is permitted after close. If the object was opened by file object, the underlying file object is not closed, only the <span class="docEmphasis"><TT>gzip</TT></span> interface to the file.</P>
<p class="docText"><span class="docEmphRoman">S<span class="docEmphSmaller">EE</span> A<span class="docEmphSmaller">LSO</span></span>: 
FILE.close() <span class="docEmphasis">16;</span></p>
<A NAME="ch02lev4sec135"></A><H5 class="docSection4Title"> gzip.flush()</H5>
<P class="docText">Write outstanding data from memory to disk.</P>
<p class="docText"><span class="docEmphRoman">S<span class="docEmphSmaller">EE</span> A<span class="docEmphSmaller">LSO</span></span>: 
FILE.close() <span class="docEmphasis">16;</span></p>
<A NAME="ch02lev4sec136"></A><H5 class="docSection4Title"> gzip.isatty()</H5>
<P class="docText">Return 0. Compatibility method for file-like behavior.</P>
<p class="docText"><span class="docEmphRoman">S<span class="docEmphSmaller">EE</span> A<span class="docEmphSmaller">LSO</span></span>: 
FILE.isatty() <span class="docEmphasis">16;</span></p>
<A NAME="ch02lev4sec137"></A><H5 class="docSection4Title"> gzip.myfileobj</H5>
<P class="docText">Attribute holding the underlying file object.</P>
<A NAME="ch02lev4sec138"></A><H5 class="docSection4Title"> gzip.read([num])</H5>
<P class="docText">If the first argument <TT>num</TT> is specified, return a string containing the next <TT>num</TT> characters. If <TT>num</TT> characters are not available, return as many as possible. If <TT>num</TT> is not specified, return all the characters from current file position to end of string buffer. Advance the current file position by the amount read.</P>
<p class="docText"><span class="docEmphRoman">S<span class="docEmphSmaller">EE</span> A<span class="docEmphSmaller">LSO</span></span>: 
FILE.read() <span class="docEmphasis">17;</span></p>
<A NAME="ch02lev4sec139"></A><H5 class="docSection4Title"> gzip.readline([length])</H5>
<P class="docText">Return a string from the <span class="docEmphasis"><TT>gzip</TT></span> object, starting from the current file position and going to the next newline character. The argument <TT>length</TT> limits the read if specified. Advance the current file position by the amount read.</P>
<p class="docText"><span class="docEmphRoman">S<span class="docEmphSmaller">EE</span> A<span class="docEmphSmaller">LSO</span></span>: 
FILE.readline() <span class="docEmphasis">17;</span></p>
<A NAME="ch02lev4sec140"></A><H5 class="docSection4Title"> gzip.readlines([sizehint=...])</H5>
<P class="docText">Return a list of strings from the <span class="docEmphasis"><TT>gzip</TT></span> object. Each list element consists of a single line, including the trailing newline character(s). If an argument <TT>sizehint</TT> is specified, read only approximately <TT>sizehint</TT> characters worth of lines (full lines will always be read).</P>
<p class="docText"><span class="docEmphRoman">S<span class="docEmphSmaller">EE</span> A<span class="docEmphSmaller">LSO</span></span>: 
FILE.readlines() <span class="docEmphasis">17;</span></p>
<A NAME="ch02lev4sec141"></A><H5 class="docSection4Title"> gzip.write(s)</H5>
<P class="docText">Write the first argument <TT>s</TT> into the <span class="docEmphasis"><TT>gzip</TT></span> object at the current file position. The current file position is updated to the position following the write.</P>
<p class="docText"><span class="docEmphRoman">S<span class="docEmphSmaller">EE</span> A<span class="docEmphSmaller">LSO</span></span>: 
FILE.write() <span class="docEmphasis">17;</span></p>
<A NAME="ch02lev4sec142"></A><H5 class="docSection4Title"> gzip.writelines(list)</H5>
<P class="docText">Write each element of <TT>list</TT> into the <span class="docEmphasis"><TT>gzip</TT></span> object at the current file position. The current file position is updated to the position following the write. Most sequence types are allowed, but <TT>list</TT> must contain only strings, or a <TT>TypeError</TT> will occur.</P>
<P class="docText">Contrary to what might be expected from the method name, <span class="docEmphasis"><TT>gzip.writelines()</TT></span> never inserts newline characters. For the list elements actually to occupy separate lines in the string buffer, each element string must already have a newline terminator. See <span class="docEmphasis"><TT>StringIO.StringIO.writelines()</TT></span> for an example.</P>
<p class="docText"><span class="docEmphRoman">S<span class="docEmphSmaller">EE</span> A<span class="docEmphSmaller">LSO</span></span>: 
FILE.writelines() <span class="docEmphasis">17;</span> StringIO.StringIO.writelines() <span class="docEmphasis">157</span>;</p>
<p class="docText"><span class="docEmphRoman">S<span class="docEmphSmaller">EE</span> A<span class="docEmphSmaller">LSO</span></span>: 
zlib <span class="docEmphasis">181;</span> zipfile <span class="docEmphasis">176;</span></p>
<P><A NAME="ch02sb15"></A><TABLE CELLSPACING="0" WIDTH="90%" BORDER="1"><TR><TD>
<P class="docText"><span class="docEmphStrong">zipfile &#8226; Read and write ZIP files</span></P></TD></TR></TABLE></P>
<P class="docText">The <span class="docEmphasis"><TT>zipfile</TT></span> module enables a variety of operations on ZIP files and is compatible with archives created by applications such as PKZip, Info-Zip, and WinZip. Since the ZIP format allows inclusion of multiple file images within a single archive, the <span class="docEmphasis"><TT>zipfile</TT></span> does not behave in a directly file-like manner as <span class="docEmphasis"><TT>gzip</TT></span> does. Nonetheless, it is possible to view the contents of an archive, add new file images to one, create a new ZIP archive, or manipulate the contents and directory information of a ZIP file.</P>
<P class="docText">An initial example of working with the <span class="docEmphasis"><TT>zipfile</TT></span> module gives a feel for its usage.</P>
<pre>
&gt;&gt;&gt; for name in 'ABC':
...     open(name,'w').write(name*1000)
...
&gt;&gt;&gt; import zipfile
&gt;&gt;&gt; z = zipfile.ZipFile('new.zip','w',zipfile.ZIP_DEFLATED) # new archv
&gt;&gt;&gt; z.write('A')                        # write files to archive
&gt;&gt;&gt; z.write('B','B.newname',zipfile.ZIP_STORED)
&gt;&gt;&gt; z.write('C','C.newname')
&gt;&gt;&gt; z.close()                           # close the written archive
&gt;&gt;&gt; z = zipfile.ZipFile('new.zip')      # reopen archive in read mode
&gt;&gt;&gt; z.testzip()                         # 'None' returned means OK
&gt;&gt;&gt; z.namelist()                        # What's in it?
['A', 'B.newname', 'C.newname']
&gt;&gt;&gt; z.printdir()                        # details
File Name                                   Modified             Size
A                                    2001-07-18 21:39:36         1000
B.newname                            2001-07-18 21:39:36         1000
C.newname                            2001-07-18 21:39:36         1000
&gt;&gt;&gt; A = z.getinfo('A')                  # bind ZipInfo object
&gt;&gt;&gt; B = z.getinfo('B.newname')          # bind ZipInfo object
&gt;&gt;&gt; A.compress_size
11
&gt;&gt;&gt; B.compress_size
1000
&gt;&gt;&gt; z.read(A.filename)[:40]             # Check what's in A
'AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA'
&gt;&gt;&gt; z.read(B.filename)[:40]             # Check what's in B
'BBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB'
&gt;&gt;&gt; # For comparison, see what Info-Zip reports on created archive
&gt;&gt;&gt; import os
&gt;&gt;&gt; print os.popen('unzip -v new.zip').read()
Archive: new.zip
 Length  Method   Size  Ratio   Date    Time   CRC-32     Name
 ------  ------   ----  -----   ----    ----   ------     ----
   1000  Defl:N      11  99%  07-18-01  21:39  51a02e01   A
   1000  Stored    1000   0%  07-18-01  21:39  7d9c564d   B.newname
   1000  Defl:N      11  99%  07-18-01  21:39  66778189   C.newname
 ------          ------  ---                              ------
   3000            1022  66%                              3 files
</pre>
<P class="docText">The module <span class="docEmphasis"><TT>gzip</TT></span> is a wrapper around <span class="docEmphasis"><TT>zlib</TT></span>, with the latter performing the actual compression and decompression tasks.</P>
<A NAME="ch02lev3sec26"></A><H5 class="docSection3Title"> CONSTANTS</H5>
<P class="docText">Several string constants (<span class="docEmphasis"><TT>struct</TT></span> formats) are used to recognize signature identifiers in the ZIP format. These constants are not normally used directly by end-users of <span class="docEmphasis"><TT>zipfile</TT></span>.</P>
<pre>
zipfile.stringCentralDir = 'PK\x01\x02'
zipfile.stringEndArchive = 'PK\x05\x06'
zipfile.stringFileHeader = 'PK\x03\x04'
zipfile.structCentralDir = '&lt;4s4B4H315H21'
zipfile.structEndArchive = '&lt;4s4H21H'
zipfile.structFileHeader = '&lt;4s2B4H312H'
</pre>
<P class="docText">Symbolic names for the two supported compression methods are also defined.</P>
<pre>
zipfile.ZIP_STORED = 0
zipfile.ZIP_DEFLATED = 8
</pre>
<A NAME="ch02lev3sec27"></A><H5 class="docSection3Title"> FUNCTIONS</H5>
<A NAME="ch02lev4sec143"></A><H5 class="docSection4Title"> zipfile.is_zipfile(filename=...)</H5>
<P class="docText">Check if the argument <TT>filename</TT> is a valid ZIP archive. Archives with appended comments are not recognized as valid archives. Return 1 if valid, None otherwise. This function does not guarantee archive is fully intact, but it does provide a sanity check on the file type.</P>
<A NAME="ch02lev3sec28"></A><H5 class="docSection3Title"> CLASSES</H5>
<A NAME="ch02lev4sec144"></A><H5 class="docSection4Title"> zipfile.PyZipFile(pathname)</H5>
<P class="docText">Create a <span class="docEmphasis"><TT>zipfile.ZipFile</TT></span> object that has the extra method <span class="docEmphasis"><TT>zipfile.ZipFile.writepy()</TT> .</span> This extra method allows you to recursively add all <TT>*.py[oc]</TT> files to an archive. This class is not general purpose, but a special feature to aid <span class="docEmphasis"><TT>distutils</TT></span>.</P>
<A NAME="ch02lev4sec145"></A><H5 class="docSection4Title"> zipfile.ZipFile(file=...[,mode='r' [,compression=ZIP_STORED]])</H5>
<P class="docText">Create a new <span class="docEmphasis"><TT>zipfile.ZipFile</TT></span> object. This object is used for management of a ZIP archive. The first argument <TT>file</TT> must be specified and is simply the filename of the archive to be manipulated. The second argument <TT>mode</TT> may have one of three string values: <TT>r</TT> to open the archive in read-only mode; <TT>w</TT> to truncate the filename and create a new archive; <TT>a</TT> to read an existing archive and add to it. The third argument <TT>compression</TT> indicates the compression method—ZIP_DEFLATED requires that <span class="docEmphasis"><TT>zlib</TT></span> and the zlib system library be present.</P>
<A NAME="ch02lev4sec146"></A><H5 class="docSection4Title"> zipfile.Ziplnfo()</H5>
<P class="docText">Create a new <span class="docEmphasis"><TT>zipfile.ZipInfo</TT></span> object. This object contains information about an individual archived filename and its file image. Normally, one will not directly instantiate <span class="docEmphasis"><TT>zipfile.ZipInfo</TT></span> but only look at the <span class="docEmphasis"><TT>zipfile.ZipInfo</TT></span> objects that are returned by methods like <span class="docEmphasis"><TT>zipfile.ZipFile.infolist()</TT>, <TT>zipfile.ZipFile.getinfo()</TT></span>, and <span class="docEmphasis"><TT>zipfile.ZipFile.NameToInfo</TT></span>. However, in special cases like <span class="docEmphasis"><TT>zipfile.ZipFile.writestr()</TT></span>, it is useful to create a <span class="docEmphasis"><TT>zipfile.ZipInfo</TT></span> directly.</P>
<A NAME="ch02lev3sec29"></A><H5 class="docSection3Title"> METHODS AND ATTRIBUTES</H5>
<A NAME="ch02lev4sec147"></A><H5 class="docSection4Title"> zipfile.ZipFile.close()</H5>
<P class="docText">Close the <span class="docEmphasis"><TT>zipfile.ZipFile</TT></span> object, and flush any changes made to it. An object must be explicitly closed to perform updates.</P>
<A NAME="ch02lev4sec148"></A><H5 class="docSection4Title"> zipfile.ZipFile.getinfo(name=...)</H5>
<P class="docText">Return the <span class="docEmphasis"><TT>zipfile.ZipInfo</TT></span> object corresponding to the filename <TT>name</TT>. If <TT>name</TT> is not in the ZIP archive, a <TT>KeyError</TT> is raised.</P>
<A NAME="ch02lev4sec149"></A><H5 class="docSection4Title"> zipfile.ZipFile.infolist()</H5>
<P class="docText">Return a list of <span class="docEmphasis"><TT>zipfile.ZipInfo</TT></span> objects contained in the <span class="docEmphasis"><TT>zipfile.ZipFile</TT></span> object. The return value is simply a list of instances of the same type. If the filename within the archive is known, <span class="docEmphasis"><TT>zipfile.ZipFile.getinfo()</TT></span> is a better method to use. For enumerating over all archived files, however, <span class="docEmphasis"><TT>zipfile.ZipFile.infolist()</TT></span> provides a nice sequence.</P>
<A NAME="ch02lev4sec150"></A><H5 class="docSection4Title"> zipfile.ZipFile.namelist()</H5>
<P class="docText">Return a list of the filenames of all the archived files (including nested relative directories).</P>
<A NAME="ch02lev4sec151"></A><H5 class="docSection4Title"> zipfile.ZipFile.printdir()</H5>
<P class="docText">Print to STDOUT a pretty summary of archived files and information about them. The results are similar to running Info-Zip's <TT>unzip</TT> with the <TT>-l</TT> option.</P>
<A NAME="ch02lev4sec152"></A><H5 class="docSection4Title"> zipfile.ZipFile.read(name=...)</H5>
<P class="docText">Return the contents of the archived file with filename <TT>name</TT>.</P>
<A NAME="ch02lev4sec153"></A><H5 class="docSection4Title"> zipfile.ZipFile.testzip()</H5>
<P class="docText">Test the integrity of the current archive. Return the filename of the first <span class="docEmphasis"><TT>zipfile.ZipInfo</TT></span> object with corruption. If everything is valid, return None.</P>
<A NAME="ch02lev4sec154"></A><H5 class="docSection4Title"> zipfile.ZipFile.write(filename=...[,arcname=...[,compress_type=...]])</H5>
<P class="docText">Add the file <TT>filename</TT> to the <span class="docEmphasis"><TT>zipfile.ZipFile</TT></span> object. If the second argument <TT>arcname</TT> is specified, use <TT>arcname</TT> as the stored filename (otherwise, use <TT>filename</TT> itself). If the third argument <TT>compress_type</TT> is specified, use the indicated compression method. The current archive must be opened in <TT>w</TT> or <TT>a</TT> mode.</P>
<A NAME="ch02lev4sec155"></A><H5 class="docSection4Title"> zipfile.ZipFile.writestr(zinfo=..., bytes=...)</H5>
<P class="docText">Write the data contained in the second argument <TT>bytes</TT> to the <span class="docEmphasis"><TT>zipfile.ZipFile</TT></span> object. Directory meta-information must be contained in attributes of the first argument <TT>zinfo</TT> (a filename, data, and time should be included; other information is optional). The current archive must be opened in <TT>w</TT> or <TT>a</TT> mode.</P>
<A NAME="ch02lev4sec156"></A><H5 class="docSection4Title"> zipfile.ZipFile.NameTolnfo</H5>
<P class="docText">Dictionary that maps filenames in archive to corresponding <span class="docEmphasis"><TT>zipfile.ZipInfo</TT></span> objects. The method <span class="docEmphasis"><TT>zipfile.ZipFile.getinfo()</TT></span> is simply a wrapper for a dictionary lookup in this attribute.</P>
<A NAME="ch02lev4sec157"></A><H5 class="docSection4Title"> zipfile.ZipFile.compression</H5>
<P class="docText">Compression type currently in effect for new <span class="docEmphasis"><TT>zipfile.ZipFile.write()</TT></span> operations. Modify with due caution (most likely not at all after initialization).</P>
<A NAME="ch02lev4sec158"></A><H5 class="docSection4Title"> zipfile.ZipFile.debug = 0</H5>
<P class="docText">Attribute for level of debugging information sent to STDOUT. Values range from the default 0 (no output) to 3 (verbose). May be modified.</P>
<A NAME="ch02lev4sec159"></A><H5 class="docSection4Title"> zipfile.ZipFile.filelist</H5>
<P class="docText">List of <span class="docEmphasis"><TT>zipfile.ZipInfo</TT></span> objects contained in the <span class="docEmphasis"><TT>zipfile.ZipFile</TT></span> object. The method <span class="docEmphasis"><TT>zipfile.ZipFile.infolist()</TT></span> is simply a wrapper to retrieve this attribute. Modify with due caution (most likely not at all).</P>
<A NAME="ch02lev4sec160"></A><H5 class="docSection4Title"> zipfile.ZipFile.filename</H5>
<P class="docText">Filename of the <span class="docEmphasis"><TT>zipfile.ZipFile</TT></span> object. DO NOT modify!</P>
<A NAME="ch02lev4sec161"></A><H5 class="docSection4Title"> zipfile.ZipFile.fp</H5>
<P class="docText">Underlying file object for the <span class="docEmphasis"><TT>zipfile.ZipFile</TT></span> object. DO NOT modify!</P>
<A NAME="ch02lev4sec162"></A><H5 class="docSection4Title"> zipfile.ZipFile.mode</H5>
<P class="docText">Access mode of current <span class="docEmphasis"><TT>zipfile.ZipFile</TT></span> object. DO NOT modify!</P>
<A NAME="ch02lev4sec163"></A><H5 class="docSection4Title"> zipfile.ZipFile.start_dir</H5>
<P class="docText">Position of start of central directory. DO NOT modify!</P>
<A NAME="ch02lev4sec164"></A><H5 class="docSection4Title"> zipfile.Ziplnfo.CRC</H5>
<P class="docText">Hash value of this archived file. DO NOT modify!</P>
<A NAME="ch02lev4sec165"></A><H5 class="docSection4Title"> zipfile.ZipInfo.comment</H5>
<P class="docText">Comment attached to this archived file. Modify with due caution (e.g., for use with <span class="docEmphasis"><TT>zipfile.ZipFile.writestr()</TT></span>).</P>
<A NAME="ch02lev4sec166"></A><H5 class="docSection4Title"> zipfile.ZipInfo.compress_size</H5>
<P class="docText">Size of the compressed data of this archived file. DO NOT modify!</P>
<A NAME="ch02lev4sec167"></A><H5 class="docSection4Title"> zipfile.ZipInfo.compress_type</H5>
<P class="docText">Compression type used with this archived file. Modify with due caution (e.g., for use with <span class="docEmphasis"><TT>zipfile.ZipFile.writestr()</TT></span>).</P>
<A NAME="ch02lev4sec168"></A><H5 class="docSection4Title"> zipfile.ZipInfo.create_system</H5>
<P class="docText">System that created this archived file. Modify with due caution (e.g., for use with <span class="docEmphasis"><TT>zipfile.ZipFile.writestr()</TT></span>).</P>
<A NAME="ch02lev4sec169"></A><H5 class="docSection4Title"> zipfile.ZipInfo.create_version</H5>
<P class="docText">PKZip version that created the archive. Modify with due caution (e.g., for use with <span class="docEmphasis"><TT>zipfile.ZipFile.writestr()</TT></span>).</P>
<A NAME="ch02lev4sec170"></A><H5 class="docSection4Title"> zipfile.ZipInfo.date_time</H5>
<P class="docText">Timestamp of this archived file. Modify with due caution (e.g., for use with <span class="docEmphasis"><TT>zipfile.ZipFile.writestr()</TT></span>).</P>
<A NAME="ch02lev4sec171"></A><H5 class="docSection4Title"> zipfile.ZipInfo.external_attr</H5>
<P class="docText">File attribute of archived file when extracted.</P>
<A NAME="ch02lev4sec172"></A><H5 class="docSection4Title"> zipfile.ZipInfo.extract_version</H5>
<P class="docText">PKZip version needed to extract the archive. Modify with due caution (e.g., for use with 
<span class="docEmphasis"><TT>zipfile.ZipFile.writestr()</TT></span>).</P>
<A NAME="ch02lev4sec173"></A><H5 class="docSection4Title"> zipfile.ZipInfo.file_offset</H5>
<P class="docText">Byte offset to start of file data. DO NOT modify!</P>
<A NAME="ch02lev4sec174"></A><H5 class="docSection4Title"> zipfile.ZipInfo.file size</H5>
<P class="docText">Size of the uncompressed data in the archived file. DO NOT modify!</P>
<A NAME="ch02lev4sec175"></A><H5 class="docSection4Title"> zipfile.ZipInfo.filename</H5>
<P class="docText">Filename of archived file. Modify with due caution (e.g., for use with <span class="docEmphasis"><TT>zipfile.ZipFile.writestr()</TT></span>).</P>
<A NAME="ch02lev4sec176"></A><H5 class="docSection4Title"> zipfile.ZipInfo.header_offset</H5>
<P class="docText">Byte offset to file header of the archived file. DO NOT modify!</P>
<A NAME="ch02lev4sec177"></A><H5 class="docSection4Title"> zipfile.ZipInfo.volume</H5>
<P class="docText">Volume number of the archived file. DO NOT modify!</P>
<A NAME="ch02lev3sec30"></A><H5 class="docSection3Title"> EXCEPTIONS</H5>
<A NAME="ch02lev4sec178"></A><H5 class="docSection4Title"> zipfile.error</H5>
<P class="docText">Exception that is raised when corrupt ZIP file is processed.</P>
<A NAME="ch02lev4sec179"></A><H5 class="docSection4Title"> zipfile.BadZipFile</H5>
<P class="docText">Alias for <span class="docEmphasis"><TT>zipfile.error</TT></span>.</P>
<p class="docText"><span class="docEmphRoman">S<span class="docEmphSmaller">EE</span> A<span class="docEmphSmaller">LSO</span></span>: 
zlib <span class="docEmphasis">181;</span> gzip <span class="docEmphasis">173;</span></p>
<P><A NAME="ch02sb16"></A><TABLE CELLSPACING="0" WIDTH="90%" BORDER="1"><TR><TD>
<P class="docText"><span class="docEmphStrong">zlib &#8226; Compress and decompress with zlib library</span></P></TD></TR></TABLE></P>
<P class="docText"><span class="docEmphasis"><TT>zlib</TT></span> is the underlying compression engine for all Python standard library compression modules. Moreover, <span class="docEmphasis"><TT>zlib</TT></span> is extremely useful in itself for compression and decompression of data that does not necessarily live in files (or where data does not map directly to files, even if it winds up in them indirectly). The Python <span class="docEmphasis"><TT>zlib</TT></span> module relies on the availability of the zlib system library.</P>
<P class="docText">There are two basic modes of operation for <span class="docEmphasis"><TT>zlib</TT></span>. In the simplest mode, one can simply pass an uncompressed string to <span class="docEmphasis"><TT>zlib.compress()</TT></span> and have the compressed version returned. Using <span class="docEmphasis"><TT>zlib.decompress()</TT></span> is symmetrical. In a more complicated mode, one can create compression or decompression objects that are able to receive incremental raw or compressed byte-streams, and return partial results based on what they have seen so far. This mode of operation is similar to the way one uses <span class="docEmphasis"><TT>sha.sha.update()</TT>, <TT>md5.md5.update()</TT> , <TT>rotor.encryptmore()</TT></span>, or <span class="docEmphasis"><TT>binascii.crc32()</TT></span> (albeit for a different purpose from each of those). For large byte-streams that are determined, it may be more practical to utilize compression/decompression objects than it would be to compress/decompress an entire string at once (for example, if the input or result is bound to a slow channel).</P>
<A NAME="ch02lev3sec31"></A><H5 class="docSection3Title"> CONSTANTS</H5>
<A NAME="ch02lev4sec180"></A><H5 class="docSection4Title"> zlib.ZLIB_VERSION</H5>
<P class="docText">The installed zlib system library version.</P>
<A NAME="ch02lev4sec181"></A><H5 class="docSection4Title"> zlib.Z_BEST_COMPRESSION = 9</H5>
<P class="docText">Highest compression level.</P>
<A NAME="ch02lev4sec182"></A><H5 class="docSection4Title"> zlib.Z_BEST_SPEED = 1</H5>
<P class="docText">Fastest compression level.</P>
<A NAME="ch02lev4sec183"></A><H5 class="docSection4Title"> zlib.Z_HUFFMAN_ONLY = 2</H5>
<P class="docText">Intermediate compression level that uses Huffman codes, but not Lempel-Ziv.</P>
<A NAME="ch02lev3sec32"></A><H5 class="docSection3Title"> FUNCTIONS</H5>
<A NAME="ch02lev4sec184"></A><H5 class="docSection4Title"> zlib.adler32(s [,crc])</H5>
<P class="docText">Return the Adler-32 checksum of the first argument <TT>s</TT>. If the second argument <TT>crc</TT> is specified, it will be used as an initial checksum. This allows partial computation of a checksum and continuation. An Adler-32 checksum can be computed much more quickly than a CRC32 checksum. Unlike <span class="docEmphasis"><TT>md5</TT></span> or <span class="docEmphasis"><TT>sha</TT></span>, an Adler-32 checksum is not sufficient for cryptographic hashes, but merely for detection of accidental corruption of data.</P>
<p class="docText"><span class="docEmphRoman">S<span class="docEmphSmaller">EE</span> A<span class="docEmphSmaller">LSO</span></span>: 
zlib.crc32() <span class="docEmphasis">182</span>; md5 <span class="docEmphasis">167;</span> sha <span class="docEmphasis">170</span>;</p>
<A NAME="ch02lev4sec185"></A><H5 class="docSection4Title"> zlib.compress(s [,level])</H5>
<P class="docText">Return the zlib compressed version of the string in the first argument <TT>s</TT>. If the second argument <TT>level</TT> is specified, the compression technique can be fine-tuned. The compression level ranges from 1 to 9 and may also be specified using symbolic constants such as Z_BEST_COMPRESSION and Z_BEST_SPEED. The default value for <TT>level</TT> is 6 and is usually the desired compression level (usually within a few percent of the speed of Z_BEST_SPEED and within a few percent of the size of Z_BEST_COMPRESSION).</P>
<p class="docText"><span class="docEmphRoman">S<span class="docEmphSmaller">EE</span> A<span class="docEmphSmaller">LSO</span></span>: 
zlib.decompress() <span class="docEmphasis">182;</span> zlib.compressobj <span class="docEmphasis">183;</span></p>
<A NAME="ch02lev4sec186"></A><H5 class="docSection4Title"> zlib.crc32(s [,crc])</H5>
<P class="docText">Return the CRC32 checksum of the first argument <TT>s</TT>. If the second argument <TT>crc</TT> is specified, it will be used as an initial checksum. This allows partial computation of a checksum and continuation. Unlike <span class="docEmphasis"><TT>md5</TT></span> or <span class="docEmphasis"><TT>sha</TT></span>, a CRC32 checksum is not sufficient for cryptographic hashes, but merely for detection of accidental corruption of data.</P>
<P class="docText">Identical to <span class="docEmphasis"><TT>binascii.crc32()</TT></span> (example appears there).</P>
<p class="docText"><span class="docEmphRoman">S<span class="docEmphSmaller">EE</span> A<span class="docEmphSmaller">LSO</span></span>: 
binascii.crc32() <span class="docEmphasis">160;</span> zlib.adler32() <span class="docEmphasis">182</span>; md5 <span class="docEmphasis">167</span>; sha <span class="docEmphasis">170</span>;</p>
<A NAME="ch02lev4sec187"></A><H5 class="docSection4Title"> zlib.decompress(s [,winsize [,buffsize]])</H5>
<P class="docText">Return the decompressed version of the zlib compressed string in the first argument s. If the second argument <TT>winsize</TT> is specified, it determines the base 2 logarithm of the history buffer size. The default <TT>winsize</TT> is 15. If the third argument <TT>buffsize</TT> is specified, it determines the size of the decompression buffer. The default <TT>buffsize</TT> is 16384, but more is dynamically allocated if needed. One rarely needs to use <TT>winsize</TT> and <TT>buffsize</TT> values other than the defaults.</P>
<p class="docText"><span class="docEmphRoman">S<span class="docEmphSmaller">EE</span> A<span class="docEmphSmaller">LSO</span></span>: 
zlib.compress() <span class="docEmphasis">182</span>; zlib.decompressobj <span class="docEmphasis">183;</span></p>
<A NAME="ch02lev3sec33"></A><H5 class="docSection3Title"> CLASS FACTORIES</H5>
<P class="docText"><span class="docEmphasis"><TT>zlib</TT></span> does not define true classes that can be specialized. <span class="docEmphasis"><TT>zlib.compressobj()</TT></span> and <span class="docEmphasis"><TT>zlib.decompressobj()</TT></span> are actually factory-functions rather than classes. That is, they return instance objects, just as classes do, but they do not have unbound data and methods. For most users, the difference is not important: To get a <span class="docEmphasis"><TT>zlib.compressobj</TT></span> or <span class="docEmphasis"><TT>zlib.decompressobj</TT></span> object, you just call that factory-function in the same manner you would a class object.</P>
<A NAME="ch02lev4sec188"></A><H5 class="docSection4Title"> zlib.compressobj([level])</H5>
<P class="docText">Create a compression object. A compression object is able to incrementally compress new strings that are fed to it while maintaining the seeded symbol table from previously compressed byte-streams. If argument <TT>level</TT> is specified, the compression technique can be fine-tuned. The compression level ranges from 1 to 9. The default value for <TT>level</TT> is 6 and is usually the desired compression level.</P>
<p class="docText"><span class="docEmphRoman">S<span class="docEmphSmaller">EE</span> A<span class="docEmphSmaller">LSO</span></span>: 
zlib.compress() <span class="docEmphasis">182</span>; zlib.decompressobj() <span class="docEmphasis">183</span>;</p>
<A NAME="ch02lev4sec189"></A><H5 class="docSection4Title"> zlib.decompressobj([winsize])</H5>
<P class="docText">Create a decompression object. A decompression object is able to incrementally decompress new strings that are fed to it while maintaining the seeded symbol table from previously decompressed byte-streams. If the argument <TT>winsize</TT> is specified, it determines the base 2 logarithm of the history buffer size. The default <TT>winsize</TT> is 15.</P>
<p class="docText"><span class="docEmphRoman">S<span class="docEmphSmaller">EE</span> A<span class="docEmphSmaller">LSO</span></span>: 
zlib.decompress() <span class="docEmphasis">182</span>; zlib.compressobj() <span class="docEmphasis">183</span>;</p>
<A NAME="ch02lev3sec34"></A><H5 class="docSection3Title"> METHODS AND ATTRIBUTES</H5>
<A NAME="ch02lev4sec190"></A><H5 class="docSection4Title"> zlib.compressobj.compress(s)</H5>
<P class="docText">Add more data to the compression object. If the symbol table becomes full, compressed data is returned, otherwise an empty string. All returned output from each repeated call to <span class="docEmphasis"><TT>zlib.compressobj.compress()</TT></span> should be concatenated to a decompression byte-stream (either a string or a decompression object). The example below, if run in a directory with some files, lets one examine the buffering behavior of compression objects:</P>
<H5 class="docExampleTitle"><A NAME="ch02list10"></A> zlib_objs.py</H5>

<PRE>
# Demonstrate compression object streams
import zlib, glob
decom = zlib.decompressobj()
com = zlib.compressobj()
for file in glob.glob('*'):
    s = open(file).read()
    c = com.compress(s)
    print 'COMPRESSED:', len(c), 'bytes out'
    d = decom.decompress(c)
    print 'DECOMPRESS:', len(d), 'bytes out'
    print 'UNUSED DATA:', len(decom.unused_data), 'bytes'
    raw_input('-- %s (%s bytes) --' % (file, 'len(s)'))
f = com.flush()
m = decom.decompress(f)
print 'DECOMPRESS:', len(m), 'bytes out'
print 'UNUSED DATA:', len(decom.unused_data), 'byte'
</PRE>
<p class="docText"><span class="docEmphRoman">S<span class="docEmphSmaller">EE</span> A<span class="docEmphSmaller">LSO</span></span>: 
zlib.compressobj.flush() <span class="docEmphasis">184</span>; zlib.decompressobj.decompress() <span class="docEmphasis">185;</span> zlib.compress() <span class="docEmphasis">182</span>;</p>
<A NAME="ch02lev4sec191"></A><H5 class="docSection4Title"> zlib.compressobj.flush([mode])</H5>
<P class="docText">Flush any buffered data from the compression object. As in the example in <span class="docEmphasis"><TT>zlib.compressobj.compress()</TT></span>, the output of a <span class="docEmphasis"><TT>zlib.compressobj.flush()</TT></span> should be concatenated to the same decompression byte-stream as <span class="docEmphasis"><TT>zlib.compressobj.compress()</TT></span> calls are. If the first argument <TT>mode</TT> is left empty, or the default Z_FINISH is specified, the compression object cannot be used further, and one should <span class="docEmphasis"><TT>delete</TT></span> it. Otherwise, if Z_SYNC_FLUSH or Z_FULL_FLUSH are specified, the compression object can still be used, but some uncompressed data may not be recovered by the decompression object.</P>
<p class="docText"><span class="docEmphRoman">S<span class="docEmphSmaller">EE</span> A<span class="docEmphSmaller">LSO</span></span>: 
zlib.compress() <span class="docEmphasis">182</span>; zlib.compressobj.compress() <span class="docEmphasis">183</span>;</p>
<A NAME="ch02lev4sec192"></A><H5 class="docSection4Title"> zlib.decompressobj.unused_data</H5>
<P class="docText">As indicated, <span class="docEmphasis"><TT>zlib.decompressobj.unused-data</TT></span> is an instance attribute rather than a method. If any partial compressed stream cannot be decompressed immediately based on the byte-stream received, the remainder is buffered in this instance attribute. Normally, any output of a compression object forms a complete decompression block, and nothing is left in this instance attribute. However, if data is received in bits over a channel, only partial decompression may be possible on a particular <span class="docEmphasis"><TT>zlib.decompressobj.decompress()</TT></span> call.</P>
<p class="docText"><span class="docEmphRoman">S<span class="docEmphSmaller">EE</span> A<span class="docEmphSmaller">LSO</span></span>: 
zlib.decompress() <span class="docEmphasis">182</span>; zlib.decompressobj.decompress() <span class="docEmphasis">185</span>;</p>
<A NAME="ch02lev4sec193"></A><H5 class="docSection4Title"> zlib.decompressobj.decompress (s)</H5>
<P class="docText">Return the decompressed data that may be derived from the current decompression object state and the argument <TT>s</TT> data passed in. If all of <TT>s</TT> cannot be decompressed in this pass, the remainder is left in <span class="docEmphasis"><TT>zlib.decompressobj.unused-data</TT></span>.</P>
<A NAME="ch02lev4sec194"></A><H5 class="docSection4Title"> zlib.decompressobj.flush()</H5>
<P class="docText">Return the decompressed data from any bytes buffered by the decompression object. After this call, the decompression object cannot be used further, and you should <span class="docEmphasis"><TT>del</TT></span> it.</P>
<A NAME="ch02lev3sec35"></A><H5 class="docSection3Title"> EXCEPTIONS</H5>
<A NAME="ch02lev4sec195"></A><H5 class="docSection4Title"> zlib.error</H5>
<P class="docText">Exception that is raised by compression or decompression errors.</P>
<p class="docText"><span class="docEmphRoman">S<span class="docEmphSmaller">EE</span> A<span class="docEmphSmaller">LSO</span></span>: 
gzip <span class="docEmphasis">173;</span> zipfile <span class="docEmphasis">176;</span></p>
<A NAME="ch02lev2sec13"></A><H4 class="docSection2Title">2.2.6 Unicode</H4>
<P class="docText">Note that <A class="docLink" HREF="0321112547_app03.html#app03">Appendix C</A> (Understanding Unicode) also discusses Unicode issues.</P>
<P class="docText">Unicode is an enhanced set of character entities, well beyond the basic 128 characters defined in ASCII encoding and the codepage-specific national language sets that contain 128 characters each. The full Unicode character set—evolving continuously, but with a large number of codepoints already fixed—can contain literally millions of distinct characters. This allows the representation of a large number of national character sets within a unified encoding space, even the large character sets of Chinese-Japanese-Korean (CJK) alphabets.</P>
<P class="docText">Although Unicode defines a unique codepoint for each distinct character in its range, there are numerous <span class="docEmphasis">encodings</span> that correspond to each character. The encoding called <TT>UTF-8</TT> defines ASCII characters as single bytes with standard ASCII values. However, for non-ASCII characters, a variable number of bytes (up to 6) are used to encode characters, with the "escape" to Unicode being indicated by high-bit values in initial bytes of multibyte sequences. <TT>UTF-16</TT> is similar, but uses either 2 or 4 bytes to encode each character (but never just 1). <TT>UTF-32</TT> is a format that uses a fixed 4-byte value for each Unicode character. <TT>UTF-32</TT>, however, is not currently supported by Python.</P>
<P class="docText">Native Unicode support was added to Python 2.0. On the face of it, it is a happy situation that Python supports Unicode—it brings the world closer to multinational language support in computer applications. But in practice, you have to be careful when working with Unicode, because it is all too easy to encounter glitches like the one below:</P>
<pre>
&gt;&gt;&gt; alef, omega = unichr(1488), unichr(969)
&gt;&gt;&gt; unicodedata.name(alef)
&gt;&gt;&gt; print alef
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in ?
UnicodeError: ASCII encoding error: ordinal not in range(128)
&gt;&gt;&gt; print chr(170)

&gt;&gt;&gt; if alef == chr(170): print "Hebrew is Roman diacritic"
...
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in ?
UnicodeError: ASCII decoding error: ordinal not in range(128)
</pre>
<P class="docText">A Unicode string that is composed of only ASCII characters, however, is considered equal (but not identical) to a Python string of the same characters.</P>
<pre>
&gt;&gt;&gt; u"spam" == "spam"
1
&gt;&gt;&gt; u"spam" is "spam"
0
&gt;&gt;&gt; "spam" is "spam"   # string interning is not guaranteed
1
&gt;&gt;&gt; u"spam" is u"spam" # unicode interning not guaranteed
1
</pre>
<P class="docText">Still, the care you take should not discourage you from working with multilanguage strings, as Unicode enables. It is really amazingly powerful to be able to do so. As one says of a talking dog: It is not that he speaks so <span class="docEmphasis">well,</span> but that he speaks at all.</P>
<P><A NAME="ch02sb17"></A><TABLE CELLSPACING="0" WIDTH="90%" BORDER="1"><TR><TD>
<P class="docText"><span class="docEmphStrong">Built-In Unicode Functions/Methods</span></P></TD></TR></TABLE></P>
<P class="docText">The Unicode string method <span class="docEmphasis"><TT>u"".encode()</TT></span> and the built-in function <span class="docEmphasis"><TT>unicode()</TT></span> are inverse operations. The Unicode string method returns a plain string with the 8-bit bytes needed to represent it (using the specified or default encoding). The built-in <span class="docEmphasis"><TT>unicode()</TT></span> takes one of these encoded strings and produces the Unicode object represented by the encoding. Specifically, suppose we define the function:</P>
<pre>
&gt;&gt;&gt; chk_eq = lambda u,enc: u == unicode(u.encode(enc),enc)
</pre>
<P class="docText">The call <span class="docEmphasis"><TT>chk_eq(u, enc</TT></span>) should return 1 for every value of <TT>u</TT> and <TT>enc</TT>—as long as <TT>enc</TT> is a valid encoding name and <TT>u</TT> is capable of being represented in that encoding.</P>
<P class="docText">The set of encodings supported for both built-ins are listed below. Additional encodings may be registered using the <span class="docEmphasis"><TT>codecs</TT></span> module. Each encoding is indicated by the string that names it, and the case of the string is normalized before comparison (case-insensitive naming of encodings):</P>
<A NAME="ch02lev4sec196"></A><H5 class="docSection3Title"> ascii, us-ascii</H5>
<P class="docText">Encode using 7-bit ASCII.</P>
<A NAME="ch02lev4sec197"></A><H5 class="docSection3Title"> base64</H5>
<P class="docText">Encode Unicode strings using the base64 4-to-3 encoding format.</P>
<A NAME="ch02lev4sec198"></A><H5 class="docSection3Title"> latin-1, iso-8859-1</H5>
<P class="docText">Encode using common European accent characters in high-bit values of 8-bit bytes. Latin-1 character's <span class="docEmphasis"><TT>ord()</TT></span> values are identical to their Unicode codepoints.</P>
<A NAME="ch02lev4sec199"></A><H5 class="docSection3Title"> quopri</H5>
<P class="docText">Encode in quoted printable format.</P>
<A NAME="ch02lev4sec200"></A><H5 class="docSection3Title"> rot13</H5>
<P class="docText">Not really a Unicode encoding, but "rotate 13 chars" is included with Python 2.2+ as an example and convenience.</P>
<A NAME="ch02lev4sec201"></A><H5 class="docSection3Title"> utf-7</H5>
<P class="docText">Encode using variable byte-length encoding that is restricted to 7-bit ASCII octets. As with <TT>utf-8</TT>, ASCII characters encode themselves.</P>
<A NAME="ch02lev4sec202"></A><H5 class="docSection3Title"> utf-8</H5>
<P class="docText">Encode using variable byte-length encoding that preserves ASCII value bytes.</P>
<A NAME="ch02lev4sec203"></A><H5 class="docSection3Title"> utf-16</H5>
<P class="docText">Encoding using 2/4 byte encoding. Include "endian" lead bytes (platform-specific selection).</P>
<A NAME="ch02lev4sec204"></A><H5 class="docSection3Title"> utf-16-le</H5>
<P class="docText">Encoding using 2/4 byte encoding. Assume "little endian," and do not prepend "endian" indicator bytes.</P>
<A NAME="ch02lev4sec205"></A><H5 class="docSection3Title"> utf-16-be</H5>
<P class="docText">Encoding using 2/4 byte encoding. Assume "big endian," and do not prepend "endian" indicator bytes.</P>
<A NAME="ch02lev4sec206"></A><H5 class="docSection3Title"> unicode-escape</H5>
<P class="docText">Encode using Python-style Unicode string constants (<TT>u"\uXXXX"</TT>).</P>
<A NAME="ch02lev4sec207"></A><H5 class="docSection3Title"> raw-unicode-escape</H5>
<P class="docText">Encode using Python-style Unicode raw string constants (<TT>ur"\uXXXX"</TT>).</P>
<P class="docText">The error modes for both built-ins are listed below. Errors in encoding transformations may be handled in any of several ways:</P>
<A NAME="ch02lev4sec208"></A><H5 class="docSection3Title"> strict</H5>
<P class="docText">Raise <TT>UnicodeError</TT> for all decoding errors. Default handling.</P>
<A NAME="ch02lev4sec209"></A><H5 class="docSection3Title"> ignore</H5>
<P class="docText">Skip all invalid characters.</P>
<A NAME="ch02lev4sec210"></A><H5 class="docSection3Title"> replace</H5>
<P class="docText">Replace invalid characters with <TT>?</TT> (string target) or <TT>u"\xfffd"</TT> (Unicode target).</P>
<A NAME="ch02lev4sec211"></A><H5 class="docSection3Title"> u"".encode([enc [,errmode]])<br>"".encode([enc [,errmode]])</H5>
<P class="docText">Return an encoded string representation of a Unicode string (or of a plain string). The representation is in the style of encoding <TT>enc</TT> (or system default). This string is suitable for writing to a file or stream that other applications will treat as Unicode data. Examples show several encodings:</P>
<pre>
&gt;&gt;&gt; alef = unichr(1488)
&gt;&gt;&gt; s = 'A'+alef
&gt;&gt;&gt; s
u'A\u05d0'
&gt;&gt;&gt; s.encode('unicode-escape')
'A\\u05d0'
&gt;&gt;&gt; s.encode('utf-8')
'A\xd7\x90'
&gt;&gt;&gt; s.encode('utf-16')
'\xff\xfeA\x00\xd0\x05'
&gt;&gt;&gt; s.encode('utf-16-le')
'A\x00\xd0\x05'
&gt;&gt;&gt; s.encode('ascii')
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in ?
UnicodeError: ASCII encoding error: ordinal not in range(128)
&gt;&gt;&gt; s.encode('ascii','ignore')
'A'
</pre>
<A NAME="ch02lev4sec212"></A><H5 class="docSection3Title"> unicode(s [,enc [,errmode]])</H5>
<P class="docText">Return a Unicode string object corresponding to the encoded string passed in the first argument <TT>s</TT>. The string <TT>s</TT> might be a string that is read from another Unicode-aware application. The representation is treated as conforming to the style of the encoding <TT>enc</TT> if the second argument is specified, or system default otherwise (usually <TT>utf-8</TT>). Errors can be handled in the default <TT>strict</TT> style or in a style specified in the third argument <TT>errmode</TT>.</P>
<A NAME="ch02lev4sec213"></A><H5 class="docSection3Title"> unichr(cp)</H5>
<P class="docText">Return a Unicode string object containing the single Unicode character whose integer codepoint is passed in the argument <TT>cp</TT>.</P>
<P><A NAME="ch02sb18"></A><TABLE CELLSPACING="0" WIDTH="90%" BORDER="1"><TR><TD>
<P class="docText"><span class="docEmphStrong">codecs &#8226; Python Codec Registry, API, and helpers</span></P></TD></TR></TABLE></P>
<P class="docText">The <span class="docEmphasis"><TT>codecs</TT></span> module contains a lot of sophisticated functionality to get at the internals of Python's Unicode handling. Most of those capabilities are at a lower level than programmers who are just interested in text processing need to worry about. The documentation of this module, therefore, will break slightly with the style of most of the documentation and present only two very useful wrapper functions within the <span class="docEmphasis"><TT>codecs</TT></span> module.</P>
<A NAME="ch02lev4sec214"></A><H5 class="docSection3Title"> codecs.open(filename=...[,mode='rb' [,encoding=...[,errors='strict' [,buffering=1]]]])</H5>
<P class="docText">This wrapper function provides a simple and direct means of opening a Unicode file, and treating its contents directly as Unicode. In contrast, the contents of a file opened with the built-in <span class="docEmphasis"><TT>open()</TT></span> function are written and read as strings; to read/write Unicode data to such a file involves multiple passes through <span class="docEmphasis"><TT>u"".encode()</TT></span> and <span class="docEmphasis"><TT>unicode()</TT></span>.</P>
<P class="docText">The first argument <TT>filename</TT> specifies the name of the file to access. If the second argument <TT>mode</TT> is specified, the read/write mode can be selected. These arguments work identically to those used by <span class="docEmphasis"><TT>open()</TT></span>. If the third argument encoding is specified, this <TT>encoding</TT> will be used to interpret the file (an incorrect encoding will probably result in a <TT>UnicodeError</TT>). Error handling may be modified by specifying the fourth argument <TT>errors</TT> (the options are the same as with the built-in <span class="docEmphasis"><TT>unicode()</TT></span> function). A fifth argument <TT>buffering</TT> may be specified to use a specific buffer size (on platforms that support this).</P>
<P class="docText">An example of usage clarifies the difference between <span class="docEmphasis"><TT>codecs.open()</TT></span> and the built-in <span class="docEmphasis"><TT>open()</TT></span>:</P>
<pre>
&gt;&gt;&gt; import codecs
&gt;&gt;&gt; alef = unichr(1488)
&gt;&gt;&gt; open('unicode_test','wb').write(('A'+alef).encode('utf-8'))
&gt;&gt;&gt; open('unicode_test').read()   # Read as plain string
'A\xd7\x90'
&gt;&gt;&gt; # Now read directly as Unicode
&gt;&gt;&gt; codecs.open('unicode_test', encoding='utf-8').read()
u'A\u05d0'
</pre>
<P class="docText">Data written back to a file opened with <span class="docEmphasis"><TT>codecs.open()</TT></span> should likewise be Unicode data.</P>
<p class="docText"><span class="docEmphRoman">S<span class="docEmphSmaller">EE</span> A<span class="docEmphSmaller">LSO</span></span>: 
open() <span class="docEmphasis">15;</span></p>
<A NAME="ch02lev4sec215"></A><H5 class="docSection3Title"> codecs.EncodedFile(file=..., data_encoding=...[,file_encoding=...[,errors='strict']])</H5>
<P class="docText">This function allows an already opened file to be wrapped inside an "encoding translation" layer. The mode and buffering are taken from the underlying file. By specifying a second argument <TT>data_encoding</TT> and a third argument <TT>file_encoding</TT>, it is possible to generate strings in one encoding within an application, then write them directly into the appropriate file encoding. As with <span class="docEmphasis"><TT>codecs.open()</TT></span> and <span class="docEmphasis"><TT>unicode()</TT></span>, an error handling style may be specified with the fourth argument <TT>errors</TT>.</P>
<P class="docText">The most likely purpose for <span class="docEmphasis"><TT>codecs.EncodedFile()</TT></span> is where an application is likely to receive byte-streams from multiple sources, encoded according to multiple Unicode encodings. By wrapping file objects (or file-like objects) in an encoding translation layer, the strings coming in one encoding can be transparently written to an output in the format the output expects. An example clarifies:</P>
<pre>
&gt;&gt;&gt; import codecs
&gt;&gt;&gt; alef = unichr(1488)
&gt;&gt;&gt; open('unicode_test','wb').write(('A'+alef).encode('utf-8'))
&gt;&gt;&gt; fp = open('unicode_test','rb+')
&gt;&gt;&gt; fp.read()     # Plain string w/ two-byte UTF-8 char in it
'A\xd7\x90'
&gt;&gt;&gt; utf16_writer = codecs.EncodedFile(fp,'utf-16','utf-8')
&gt;&gt;&gt; ascii_writer = codecs.EncodedFile(fp,'ascii','utf-8')
&gt;&gt;&gt; utf16_writer.tell()   # Wrapper keeps same current position
3
&gt;&gt;&gt; s = alef.encode('utf-16')
&gt;&gt;&gt; s             # Plain string as UTF-16 encoding
'\xff\xfe\xd0\x05'
&gt;&gt;&gt; utf16_writer.write(s)
&gt;&gt;&gt; ascii_writer.write('XYZ')
&gt;&gt;&gt; fp.close()             # File should be UTF-8 encoded
&gt;&gt;&gt; open('unicode_test').read()
'A\xd7\x90\xd7\x90XYZ'
</pre>
<p class="docText"><span class="docEmphRoman">S<span class="docEmphSmaller">EE</span> A<span class="docEmphSmaller">LSO</span></span>: 
codecs.open() <span class="docEmphasis">189;</span></p>
<P><A NAME="ch02sb19"></A><TABLE CELLSPACING="0" WIDTH="90%" BORDER="1"><TR><TD>
<P class="docText"><span class="docEmphStrong">unicodedata &#8226; Database of Unicode characters</span></P></TD></TR></TABLE></P>
<P class="docText">The module <span class="docEmphasis"><TT>unicodedata</TT></span> is a database of Unicode character entities. Most of the functions in <span class="docEmphasis"><TT>unicodedata</TT></span> take as an argument one Unicode character and return some information about the character contained in a plain (non-Unicode) string. The function of <span class="docEmphasis"><TT>unicodedata</TT></span> is essentially informational, rather than transformational. Of course, an application might make decisions about the transformations performed based on the information returned by <span class="docEmphasis"><TT>unicodedata</TT></span>. The short utility below provides all the information available for any Unicode codepoint:</P>
<H5 class="docExampleTitle"><A NAME="ch02list11"></A> unichr_info.py</H5>

<PRE>
# Return all the information [unicodedata] has
# about the single unicode character whose codepoint
# is specified as a command-line argument.
# Arg may be any expression evaluating to an integer
from unicodedata import  *
import sys
char = unichr(eval(sys.argv[1]))
print 'bidirectional', bidirectional(char)
print 'category     ', category(char)
print 'combining    ', combining(char)
print 'decimal      ', decimal(char,0)
print 'decomposition', decomposition(char)
print 'digit        ', digit(char,0)
print 'mirrored     ', mirrored(char)
print 'name         ', name(char,'NOT DEFINED')
print 'numeric      ', numeric(char,0)
try: print 'lookup       ', 'lookup(name(char))'
except: print "Cannot lookup"
</PRE>
<P class="docText">The usage of <TT>unichr_info.py</TT> is illustrated below by the runs with two possible arguments:</P>
<pre>
% python unichr_info.py 1488
bidirectional R
category      Lo
combining     0
decimal       0
decomposition
digit         0
mirrored      0
name          HEBREW LETTER ALEF
numeric       0
lookup        u'\u05dO'

% python unichr_info.py ord('1')
bidirectional EN
category      Nd
combining     0
decimal       1
decomposition
digit         1
mirrored      0
name          DIGIT ONE
numeric       1.0
lookup        u'1'
</pre>
<P class="docText">For additional information on current Unicode character codepoints and attributes, consult:</P>
<BLOCKQUOTE><P><P class="docList"><TT>&lt;</TT><A class="docLink" target="_blank" HREF="http://www.unicode.org/Public/UNIDATA/UnicodeData.html">http://www.unicode.org/Public/UNIDATA/UnicodeData.html</A><TT>&gt;</TT></P></P></BLOCKQUOTE>
<A NAME="ch02lev3sec36"></A><H5 class="docSection3Title"> FUNCTIONS</H5>
<A NAME="ch02lev4sec216"></A><H5 class="docSection4Title"> unicodedata.bidirectional(unichr)</H5>
<P class="docText">Return the bidirectional characteristic of the character specified in the argument <TT>unichr</TT>. Possible values are AL, AN, B, BN, CS, EN, ES, ET, L, LRE, LRO, NSM, ON, PDF, R, RLE, RLO, S, and WS. Consult the URL above for details on these. Particularly notable values are L (left-to-right), R (right-to-left), and WS (whitespace).</P>
<A NAME="ch02lev4sec217"></A><H5 class="docSection4Title"> unicodedata.category (unichr)</H5>
<P class="docText">Return the category of the character specified in the argument <TT>unichr</TT>. Possible values are Cc, Cf, Cn, Ll, Lm, Lo, Lt, Lu, Mc, Me, Mn, Nd, Nl, No, Pc, Pd, Pe, Pf, Pi, Po, Ps, Sc, Sk , Sm, So, Zl, Zp, and Zs. The first (capital) letter indicates L (letter), M (mark), N (number), P (punctuation), S (symbol), Z (separator), or C (other). The second letter is generally mnemonic within the major category of the first letter. Consult the URL above for details.</P>
<A NAME="ch02lev4sec218"></A><H5 class="docSection4Title"> unicodedata.combining(unichr)</H5>
<P class="docText">Return the numeric combining class of the character specified in the argument <TT>unichr</TT>. These include values such as 218 (below left) or 210 (right attached). Consult the URL above for details.</P>
<A NAME="ch02lev4sec219"></A><H5 class="docSection4Title"> unicodedata.decimal(unichr [,default])</H5>
<P class="docText">Return the numeric decimal value assigned to the character specified in the argument <TT>unichr</TT>. If the second argument <TT>default</TT> is specified, return that if no value is assigned (otherwise raise <TT>ValueError</TT>).</P>
<A NAME="ch02lev4sec220"></A><H5 class="docSection4Title"> unicodedata.decomposition(unichr)</H5>
<P class="docText">Return the decomposition mapping of the character specified in the argument <TT>unichr</TT>, or empty string if none exists. Consult the URL above for details. An example shows that some characters may be broken into component characters:</P>
<pre>
&gt;&gt;&gt; from unicodedata import *
&gt;&gt;&gt; name(unichr(190))
'VULGAR FRACTION THREE QUARTERS'
&gt;&gt;&gt; decomposition(unichr(190))
'&lt;fraction&gt; 0033 2044 0034'
&gt;&gt;&gt; name(unichr(0x33)), name(unichr(0x2044)), name(unichr(0x34))
('DIGIT THREE', 'FRACTION SLASH', 'DIGIT FOUR')
</pre>
<A NAME="ch02lev4sec221"></A><H5 class="docSection4Title"> unicodedata.digit(unichr [,default])</H5>
<P class="docText">Return the numeric digit value assigned to the character specified in the argument <TT>unichr</TT>. If the second argument <TT>default</TT> is specified, return that if no value is assigned (otherwise raise <TT>ValueError</TT>).</P>
<A NAME="ch02lev4sec222"></A><H5 class="docSection4Title"> unicodedata.lookup(name)</H5>
<P class="docText">Return the Unicode character with the name specified in the first argument <TT>name</TT>. Matches must be exact, and <TT>ValueError</TT> is raised if no match is found. For example:</P>
<pre>
&gt;&gt;&gt; from unicodedata import *
&gt;&gt;&gt; lookup('GREEK SMALL LETTER ETA')
u'\u03b7'
&gt;&gt;&gt; lookup('ETA')
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in ?
KeyError: undefined character name
</pre>
<p class="docText"><span class="docEmphRoman">S<span class="docEmphSmaller">EE</span> A<span class="docEmphSmaller">LSO</span></span>: 
unicodedata.name() <span class="docEmphasis">193;</span></p>
<A NAME="ch02lev4sec223"></A><H5 class="docSection4Title"> unicodedata.mirrored(unichr)</H5>
<P class="docText">Return 1 if the character specified in the argument <TT>unichr</TT> is a mirrored character in bidirection text. Return 0 otherwise.</P>
<A NAME="ch02lev4sec224"></A><H5 class="docSection4Title"> unicodedata.name(unichr)</H5>
<P class="docText">Return the name of the character specified in the argument <TT>unichr</TT>. Names are in all caps and have a regular form by descending category importance. Consult the URL above for details.</P>
<p class="docText"><span class="docEmphRoman">S<span class="docEmphSmaller">EE</span> A<span class="docEmphSmaller">LSO</span></span>: 
unicodedata.lookup() <span class="docEmphasis">193;</span></p>
<A NAME="ch02lev4sec225"></A><H5 class="docSection4Title"> unicodedata.numeric(unichr [,default])</H5>
<P class="docText">Return the floating point numeric value assigned to the character specified in the argument <TT>unichr</TT>. If the second argument <TT>default</TT> is specified, return that if no value is assigned (otherwise raise <TT>ValueError</TT>).</P>
<ul></ul></td></tr></table>
<td></td>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<td class="tt1"><a href="NFO/lib.html">[ Team LiB ]</a></td><td valign="top" class="tt1" align="right">
          <a href="0321112547_ch02lev1sec1.html"><img src="FILES/btn_prev.gif" width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a>
          <a href="0321112547_ch02lev1sec3.html"><img src="FILES/btn_next.gif" width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a>
</td></table>
</body></html>
