<html><head>
<META http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<!--SafClassName="docSection1Title"--><!--SafTocEntry="3.3 Standard Modules"-->
<link rel="STYLESHEET" type="text/css" href="FILES/style.css">
<link rel="STYLESHEET" type="text/css" href="FILES/docsafari.css">
<style type="text/css">	.tt1    {font-size: 10pt;}</style>
</head>
<body>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<td class="tt1"><a href="NFO/lib.html">[ Team LiB ]</a></td><td valign="top" class="tt1" align="right">
	<a href="0321112547_ch03lev1sec2.html"><img src="FILES/btn_prev.gif" width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a>
	<a href="0321112547_ch04.html"><img src="FILES/btn_next.gif" width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a>
</td></table>
<br>
<table width="100%" border="0" cellspacing="0" cellpadding="0"><tr><td valign="top"><A NAME="ch03lev1sec3"></A><H3 class="docSection1Title">3.3 Standard Modules</H3>
<A NAME="ch03lev2sec12"></A><H4 class="docSection2Title">3.3.1 Versions and Optimizations</H4>
<blockquote>
<p class="docText">Rules of Optimization:</p>
<p class="docText">Rule 1: Don't do it.</p>
<p class="docText">Rule 2 (for experts only): Don't do it yet.</p>
<p class="docText">—M.A. Jackson</p></blockquote>
<P class="docText">Python has undergone several changes in its regular expression support. <span class="docEmphasis"><TT>regex</TT></span> was superceded by <span class="docEmphasis"><TT>pre</TT></span> in Python 1.5; <span class="docEmphasis"><TT>pre</TT></span>, in turn, by <span class="docEmphasis"><TT>sre</TT></span> in Python 2.0. Although Python has continued to include the older modules in its standard library for backwards compatibility, the older ones are deprecated when the newer versions are included. From Python 1.5 forward, the module <span class="docEmphasis"><TT>re</TT></span> has served as a wrapper to the underlying regular expression engine (<span class="docEmphasis"><TT>sre</TT></span> or <span class="docEmphasis"><TT>pre</TT></span>). But even though Python 2.0+ has used <span class="docEmphasis"><TT>re</TT></span> to wrap <span class="docEmphasis"><TT>sre</TT>, <TT>pre</TT></span> is still available (the latter along with its own underlying <span class="docEmphasis"><TT>pcre</TT></span> C extension module that can technically be used directly).</P>
<P class="docText">Each version has generally improved upon its predecessor, but with something as complicated as regular expressions there are always a few losses with each gain. For example, <span class="docEmphasis"><TT>sre</TT></span> adds Unicode support and is faster for most operations—but <span class="docEmphasis"><TT>pre</TT></span> has better optimization of case-insensitive searches. Subtle details of regular expression patterns might even let the quite-old <span class="docEmphasis"><TT>regex</TT></span> module perform faster than the newer ones. Moreover, optimizing regular expressions can be extremely complicated and dependent upon specific small version differences.</P>
<P class="docText">Readers might start to feel their heads swim with these version details. Don't panic. Other than out of historic interest, you really do not need to worry about what implementations underlie regular expression support. The simple rule is just to use the module <span class="docEmphasis"><TT>re</TT></span> and not think about what it wraps—the interface is compatible between versions.</P>
<P class="docText">The real virtue of regular expressions is that they allow a concise and precise (albeit somewhat cryptic) description of complex patterns in text. Most of the time, regular expression operations are <span class="docEmphasis">fast enough</span>; there is rarely any point in optimizing an application past the point where it does what it needs to do fast enough that speed is not a problem. As Knuth famously remarks, "We should forget about small efficiencies, say about 97% of the time: Premature optimization is the root of all evil." ("Computer Programming as an Art" in <span class="docEmphasis">Literate Programming,</span> CSLI Lecture Notes Number 27, Stanford University Center for the Study of Languages and Information, 1992).</P>
<P class="docText">In case regular expression operations prove to be a genuinely problematic performance bottleneck in an application, there are four steps you should take in speeding things up. Try these in order:</P>
<A NAME="ch03pr01"></A>



<span style="font-weight:bold"><OL class="docList" START="1"><LI><span style="font-weight:normal" value="1"><P class="docText">Think about whether there is a way to simplify the regular expressions involved. Most especially, is it possible to reduce the likelihood of backtracking during pattern matching? You should always test your beliefs about such simplification, however; performance characteristics rarely turn out exactly as you expect.</P></span></LI><LI><span style="font-weight:normal" value="2"><P class="docText">Consider whether regular expressions are <span class="docEmphasis">really</span> needed for the problem at hand. With surprising frequency, faster and simpler operations in the <span class="docEmphasis"><TT>string</TT></span> module (or, occasionally, in other modules) do what needs to be done. Actually, this step can often come earlier than the first one.</P></span></LI><LI><span style="font-weight:normal" value="3"><P class="docText">Write the search or transformation in a faster and lower-level engine, especially <span class="docEmphasis"><TT>mx.TextTools</TT></span>. Low-level modules will inevitably involve more work and considerably more intense thinking about the problem. But order-of-magnitude speed gains are often possible for the work.</P></span></LI><LI><span style="font-weight:normal" value="4"><P class="docText">Code the application (or the relevant parts of it) in a different programming language. If speed is the absolutely first consideration in an application, Assembly, C, or C++ are going to win. Tools like swig—while outside the scope of this book—can help you create custom extension modules to perform bottleneck operations. There is a chance also that if the problem <span class="docEmphasis">really must</span> be solved with regular expressions that Perl's engine will be faster (but not always, by any means).</P></span></LI></OL></span>
<A NAME="ch03lev2sec13"></A><H4 class="docSection2Title">3.3.2 Simple Pattern Matching</H4>
<P><A NAME="ch03sb01"></A><TABLE CELLSPACING="0" WIDTH="90%" BORDER="1"><TR><TD>
<P class="docText"><span class="docEmphStrong">fnmatch </span>&#8226; <span class="docEmphStrong">Glob-style pattern matching</span></P></TD></TR></TABLE></P>
<P class="docText">The real purpose of the <span class="docEmphasis"><TT>fnmatch</TT></span> module is to match filenames against a pattern. Most typically, <span class="docEmphasis"><TT>fnmatch</TT></span> is used indirectly through the <span class="docEmphasis"><TT>glob</TT></span> module, where the latter returns lists of matching files (for example to process each matching file). But <span class="docEmphasis"><TT>fnmatch</TT></span> does not itself know anything about filesystems, it simply provides a way of checking patterns against strings. The pattern language used by <span class="docEmphasis"><TT>fnmatch</TT></span> is much simpler than that used by <span class="docEmphasis"><TT>re</TT></span>, which can be either good or bad, depending on your needs. As a plus, most everyone who has used a DOS, Windows, OS/2, or Unix command line is already familiar with the <span class="docEmphasis"><TT>fnmatch</TT></span> pattern language, which is simply shell-style expansions.</P>
<P class="docText">Four subpatterns are available in <span class="docEmphasis"><TT>fnmatch</TT></span> patterns. In contrast to <span class="docEmphasis"><TT>re</TT></span> patterns, there is no grouping and no quantifiers. Obviously, the discernment of matches is much less with <span class="docEmphasis"><TT>fnmatch</TT></span> than with <span class="docEmphasis"><TT>re</TT></span>. The subpatterns are as follows:</P>
<H5 class="docExampleTitle"><A NAME="ch03list11"></A> Glob-style subpatterns</H5>

<PRE>
*      Match everything that follows (non-greedy).
?      Match any single character.
[set]  Match one character from a set.  A set generally
       follows the same rules as a regular expression
       character class.  It may include zero or more ranges
       and zero or more enumerated characters.
[!set] Match any one character that is not in the set.
</PRE>
<P class="docText">A pattern is simply the concatenation of one or more subpatterns.</P>
<A NAME="ch03lev3sec1"></A><H5 class="docSection3Title"> FUNCTIONS</H5>
<A NAME="ch03lev4sec1"></A><H5 class="docSection4Title"> fnmatch.fnmatch(s, pat)</H5>
<P class="docText">Test whether the pattern <TT>pat</TT> matches the string <TT>s</TT>. On case-insensitive filesystems, the match is case-insensitive. A cross-platform script should avoid <span class="docEmphasis"><TT>fnmatch.fnmatch()</TT></span> except when used to match actual filenames.</P>
<pre>
&gt;&gt;&gt; from fnmatch import fnmatch
&gt;&gt;&gt; fnmatch('this', '[T]?i*')  # On Unix-like  system
0

&gt;&gt;&gt; fnmatch('this', '[T]?i*')  # On Win-like system
1
</pre>
<p class="docText"><span class="docEmphRoman">S<span class="docEmphSmaller">EE</span> A<span class="docEmphSmaller">LSO</span></span>: 
fnmatch.fnmatchcase() <span class="docEmphasis">233</span>;</p>
<A NAME="ch03lev4sec2"></A><H5 class="docSection4Title"> fnmatch.fnmatchcase(s, pat)</H5>
<P class="docText">Test whether the pattern <TT>pat</TT> matches the string <TT>s</TT>. The match is case-sensitive regardless of platform.</P>
<pre>
&gt;&gt;&gt; from fnmatch import fnmatchcase
&gt;&gt;&gt; fnmatchcase('this', '[T]?i*')
0
&gt;&gt;&gt; from string import upper
&gt;&gt;&gt; fnmatchcase(upper('this'), upper('[T]?i*'))
1
</pre>
<p class="docText"><span class="docEmphRoman">S<span class="docEmphSmaller">EE</span> A<span class="docEmphSmaller">LSO</span></span>: 
fnmatch.fnmatch() <span class="docEmphasis">233</span>;</p>
<A NAME="ch03lev4sec3"></A><H5 class="docSection4Title"> fnmatch.filter(lst, pat)</H5>
<P class="docText">Return a new list containing those elements of <TT>lst</TT> that match <TT>pat</TT>. The matching behaves like <span class="docEmphasis"><TT>fnmatch.fnmatch()</TT></span> rather than like <span class="docEmphasis"><TT>fnmatch.fnmatchcase()</TT></span>, so the results can be OS-dependent. The example below shows a (slower) means of performing a case-sensitive match on all platforms.</P>
<pre>
&gt;&gt;&gt; import fnmatch          # Assuming Unix-like system
&gt;&gt;&gt; fnmatch.filter(['This','that','other','thing'], '[Tt]?i*')
['This', 'thing']
&gt;&gt;&gt; fnmatch.filter(['This','that','other','thing'], '[a-z]*')
['that', 'other', 'thing']
&gt;&gt;&gt; from fnmatch import fnmatchcase   # For all platforms
&gt;&gt;&gt; mymatch = lambda s: fnmatchcase(s, '[a-z]*')
&gt;&gt;&gt; filter(mymatch, ['This','that','other','thing'])
['that', 'other', 'thing']
</pre>
<P class="docText">For an explanation of the built-in function <span class="docEmphasis"><TT>filter ()</TT></span> function, see <A class="docLink" HREF="0321112547_app01.html#app01">Appendix A</A>.</P>
<p class="docText"><span class="docEmphRoman">S<span class="docEmphSmaller">EE</span> A<span class="docEmphSmaller">LSO</span></span>: 
fnmatch.fnmatch() <span class="docEmphasis">233;</span> fnmatch.fnmatchcase() <span class="docEmphasis">233;</span></p>
<p class="docText"><span class="docEmphRoman">S<span class="docEmphSmaller">EE</span> A<span class="docEmphSmaller">LSO</span></span>: 
glob <span class="docEmphasis">64;</span> re <span class="docEmphasis">236;</span></p>
<A NAME="ch03lev2sec14"></A><H4 class="docSection2Title">3.3.3 Regular Expression Modules</H4>
<P><A NAME="ch03sb02"></A><TABLE CELLSPACING="0" WIDTH="90%" BORDER="1"><TR><TD>
<P class="docText"><span class="docEmphStrong">pre </span>&#8226; <span class="docEmphStrong">Pre-sre module</span></P></TD></TR></TABLE></P>
<P><A NAME="ch03sb03"></A><TABLE CELLSPACING="0" WIDTH="90%" BORDER="1"><TR><TD>
<P class="docText"><span class="docEmphStrong">pcre </span>&#8226; <span class="docEmphStrong">Underlying C module for pre</span></P></TD></TR></TABLE></P>
<P class="docText">The Python-written module <span class="docEmphasis"><TT>pre</TT></span>, and the C-written <span class="docEmphasis"><TT>pcre</TT></span> module that implements the actual regular expression engine, are the regular expression modules for Python 1.5—1.6. For complete backwards compatibility, they continue to be included in Python 2.0+. Importing the symbol space of <span class="docEmphasis"><TT>pre</TT></span> is intended to be equivalent to importing <span class="docEmphasis"><TT>re</TT></span> (i.e., <span class="docEmphasis"><TT>sre</TT></span> at one level of indirection) in Python 2.0+, with the exception of the handling of Unicode strings, which <span class="docEmphasis"><TT>pre</TT></span> cannot do. That is, the lines below are almost equivalent, other than potential performance differences in specific operations:</P>
<pre>
&gt;&gt;&gt; import pre as re
&gt;&gt;&gt; import re
</pre>
<P class="docText">However, there is very rarely any reason to use <span class="docEmphasis"><TT>pre</TT></span> in Python 2.0+. Anyone deciding to import <span class="docEmphasis"><TT>pre</TT></span> should know far more about the internals of regular expression engines than is contained in this book. Of course, prior to Python 2.0, importing <span class="docEmphasis"><TT>re</TT></span> simply imports <span class="docEmphasis"><TT>pcre</TT></span> itself (and the Python wrappers later renamed <span class="docEmphasis"><TT>pre</TT></span>).</P>
<p class="docText"><span class="docEmphRoman">S<span class="docEmphSmaller">EE</span> A<span class="docEmphSmaller">LSO</span></span>: 
re <span class="docEmphasis">236;</span></p>
<P><A NAME="ch03sb04"></A><TABLE CELLSPACING="0" WIDTH="90%" BORDER="1"><TR><TD>
<P class="docText"><span class="docEmphStrong">reconvert &#8226; Convert [regex] patterns to [re] patterns</span></P></TD></TR></TABLE></P>
<P class="docText">This module exists solely for conversion of old regular expressions from scripts written for pre-1.5 versions of Python, or possibly from regular expression patterns used with tools such as sed, awk, or grep. Conversions are not guaranteed to be entirely correct, but <span class="docEmphasis"><TT>reconvert</TT></span> provides a starting point for a code update.</P>
<A NAME="ch03lev3sec2"></A><H5 class="docSection3Title"> FUNCTIONS</H5>
<A NAME="ch03lev4sec4"></A><H5 class="docSection4Title"> reconvert.convert(s)</H5>
<P class="docText">Return as a string the modern <span class="docEmphasis"><TT>re</TT></span>-style pattern that corresponds to the <span class="docEmphasis"><TT>regex</TT></span>-style pattern passed in argument <TT>s</TT>. For example:</P>
<pre>
&gt;&gt;&gt; import reconvert
&gt;&gt;&gt; reconvert.convert(r'\&lt;\(cat\|dog\)\&gt;')
'\\b(cat|dog)\\b'
&gt;&gt;&gt; import re
&gt;&gt;&gt; re.findall(r'\b(cat | dog)\b', "The dog chased a bobcat")
['dog']
</pre>
<p class="docText"><span class="docEmphRoman">S<span class="docEmphSmaller">EE</span> A<span class="docEmphSmaller">LSO</span></span>: 
regex <span class="docEmphasis">235;</span></p>
<P><A NAME="ch03sb05"></A><TABLE CELLSPACING="0" WIDTH="90%" BORDER="1"><TR><TD>
<P class="docText"><span class="docEmphStrong">regex </span>&#8226; <span class="docEmphStrong">Deprecated regular expression module</span></P></TD></TR></TABLE></P>
<P class="docText">The <span class="docEmphasis"><TT>regex</TT></span> module is distributed with recent Python versions only to ensure strict backwards compatibility of scripts. Starting with Python 2.1, importing <span class="docEmphasis"><TT>regex</TT></span> will produce a DeprecationWarning:</P>
<pre>
% python -c "import regex"
-c:1:  DeprecationWarning: the regex module is deprecated;
please use the re module
</pre>
<P class="docText">For all users of Python 1.5+, <span class="docEmphasis"><TT>regex</TT></span> should not be used in new code, and efforts should be made to convert its usage to <span class="docEmphasis"><TT>re</TT></span> calls.</P>
<p class="docText"><span class="docEmphRoman">S<span class="docEmphSmaller">EE</span> A<span class="docEmphSmaller">LSO</span></span>: 
reconvert <span class="docEmphasis">235;</span></p>
<P><A NAME="ch03sb06"></A><TABLE CELLSPACING="0" WIDTH="90%" BORDER="1"><TR><TD>
<P class="docText"><span class="docEmphStrong">sre </span>&#8226; <span class="docEmphStrong">Secret Labs Regular Expression Engine</span></P></TD></TR></TABLE></P>
<P class="docText">Support for regular expressions in Python 2.0+ is provided by the module <span class="docEmphasis"><TT>sre</TT></span>. The module <span class="docEmphasis"><TT>re</TT></span> simply wraps <span class="docEmphasis"><TT>sre</TT></span> in order to have a backwards- and forwards-compatible name. There will almost never be any reason to import <span class="docEmphasis"><TT>sre</TT></span> itself; some later version of Python might eventually deprecate <span class="docEmphasis"><TT>sre</TT></span> also. As with <span class="docEmphasis"><TT>pre</TT></span>, anyone deciding to import <span class="docEmphasis"><TT>sre</TT></span> itself should know far more about the internals of regular expression engines than is contained in this book.</P>
<p class="docText"><span class="docEmphRoman">S<span class="docEmphSmaller">EE</span> A<span class="docEmphSmaller">LSO</span></span>: 
re <span class="docEmphasis">236;</span></p>
<P><A NAME="ch03sb07"></A><TABLE CELLSPACING="0" WIDTH="90%" BORDER="1"><TR><TD>
<P class="docText"><span class="docEmphStrong">re </span>&#8226; <span class="docEmphStrong">Regular expression operations</span></P></TD></TR></TABLE></P>
<A NAME="ch03lev3sec3"></A><H5 class="docSection3Title"> PATTERN SUMMARY</H5>
<P class="docText"><A class="docLink" HREF="#ch03fig01">Figure 3.1</A> lists regular expression patterns; following that are explanations of each pattern. For more detailed explanation of patterns in action, consult the tutorial and/or problems contained in this chapter. The utility function <TT>re_show()</TT> defined in the tutorial is used in some descriptions.</P>
<CENTER><H5 class="docFigureTitle"><A NAME="ch03fig01"></A>Figure 3.1. Regular expression patterns</H5>
<p class="docText"><IMG BORDER="0" WIDTH="450" HEIGHT="509" src="FILES/03fig01.jpg" ALT="graphics/03fig01.jpg"></p></CENTER>
<A NAME="ch03lev3sec4"></A><H5 class="docSection3Title"> ATOMIC OPERATORS</H5>
<A NAME="ch03lev4sec5"></A><H5 class="docSection4Title"> Plain symbol</H5>
<P class="docText">Any character not described below as having a special meaning simply represents itself in the target string. An "A" matches exactly one "A" in the target, for example.</P>
<A NAME="ch03lev4sec6"></A><H5 class="docSection4Title"> Escape: "\"</H5>
<P class="docText">The escape character starts a special sequence. The special characters listed in this pattern summary must be escaped to be treated as literal character values (including the escape character itself). The letters "A", "b", "B", "d", "D", "s", "S", "w", "W", and "Z" specify special patterns if preceded by an escape. The escape character may also introduce a backreference group with up to two decimal digits. The escape is ignored if it precedes a character with no special escaped meaning.</P>
<P class="docText">Since Python string escapes overlap regular expression escapes, it is usually better to use raw strings for regular expressions that potentially include escapes. For example:</P>
<pre>
&gt;&gt;&gt; from re_show import re_show
&gt;&gt;&gt; re_show(r'\$ \\ \^', r'\$ \\ \^ $ \ ^')
\$ \\ \^ {$ \ ^}

&gt;&gt;&gt; re_show(r'\d \w', '7 a 6 # ! C')
{7 a} 6 # ! C
</pre>
<A NAME="ch03lev4sec7"></A><H5 class="docSection4Title"> Grouping operators: "(", ")"</H5>
<P class="docText">Parentheses surrounding any pattern turn that pattern into a group (possibly within a larger pattern). Quantifiers refer to the immediately preceding group, if one is defined, otherwise to the preceding character or character class. For example:</P>
<pre>
&gt;&gt;&gt; from re_show import  re_show
&gt;&gt;&gt; re_show(r'abc+', 'abcabc abc abccc')
{abc}{abc} {abc} {abccc}

&gt;&gt;&gt; re_show(r'(abc)+', 'abcabc abc abccc')
{abcabc} {abc}  {abc}cc
</pre>
<A NAME="ch03lev4sec8"></A><H5 class="docSection4Title"> Backreference: "\d", "\dd"</H5>
<P class="docText">A backreference consists of the escape character followed by one or two decimal digits. The first digit in a back reference may not be a zero. A backreference refers to the same string matched by an earlier group, where the enumeration of previous groups starts with 1. For example:</P>
<pre>
&gt;&gt;&gt; from re_show import  re_show
&gt;&gt;&gt; re_show(r'([abc])(.*)\1',  'all the boys are coy')
{all the boys a}re coy
</pre>
<P class="docText">An attempt to reference an undefined group will raise an error.</P>
<A NAME="ch03lev4sec9"></A><H5 class="docSection4Title"> Character classes: "[", "]"</H5>
<P class="docText">Specify a set of characters that may occur at a position. The list of allowable characters may be enumerated with no delimiter. Predefined character classes, such as "\d", are allowed within custom character classes. A range of characters may be indicated with a dash. Multiple ranges are allowed within a class. If a dash is meant to be included in the character class itself, it should occur as the first listed character. A character class may be complemented by beginning it with a caret ("^"). If a caret is meant to be included in the character class itself, it should occur in a noninitial position. Most special characters, such as "$", ".", and "(", lose their special meaning inside a character class and are merely treated as class members. The characters "]", "\", and "<TT>-</TT>" should be escaped with a backslash, however. For example:</P>
<pre>
&gt;&gt;&gt; from re_show import re_show
&gt;&gt;&gt; re_show(r'[a-fA-F]', 'A X c G')
{A} X {c} G

&gt;&gt;&gt; re_show(r'[-A$BC\]]', r'A X - \ ] [ $')
{A} X {-} \ {]} [ {$}

&gt;&gt;&gt; re_show(r'[^A-Fa-f]', r'A X c G')
A{ }{X}c{}{G}
</pre>
<A NAME="ch03lev4sec10"></A><H5 class="docSection4Title"> Digit character class: "\d"</H5>
<P class="docText">The set of decimal digits. Same as "<span class="docEmphasis"><TT>0-9</TT></span>".</P>
<A NAME="ch03lev4sec11"></A><H5 class="docSection4Title"> Non-digit character class: "\D"</H5>
<P class="docText">The set of all characters <span class="docEmphasis">except</span> decimal digits. Same as <span class="docEmphasis">"^<TT>0-9</TT>"</span>.</P>
<A NAME="ch03lev4sec12"></A><H5 class="docSection4Title"> Alphanumeric character class: "\w"</H5>
<P class="docText">The set of alphanumeric characters. If re.LOCALE and re.UNICODE modifiers are <span class="docEmphasis">not</span> set, this is the same as <TT>[a-zA-ZO-9_]</TT>. Otherwise, the set includes any other alphanumeric characters appropriate to the locale or with an indicated Unicode character property of alphanumeric.</P>
<A NAME="ch03lev4sec13"></A><H5 class="docSection4Title"> Non-alphanumeric character class: "\W"</H5>
<P class="docText">The set of nonalphanumeric characters. If re.LOCALE and re.UNICODE modifiers are <span class="docEmphasis">not</span> set, this is the same as <TT>[^a-zA-ZO-9_]</TT>. Otherwise, the set includes any other characters not indicated by the locale or Unicode character properties as alphanumeric.</P>
<A NAME="ch03lev4sec14"></A><H5 class="docSection4Title"> Whitespace character class: "\s"</H5>
<P class="docText">The set of whitespace characters. Same as <TT>[</TT> \<TT>t</TT>\<TT>n</TT>\<TT>r</TT>\<TT>f</TT>\<TT>v]</TT>.</P>
<A NAME="ch03lev4sec15"></A><H5 class="docSection4Title"> Non-whitespace character class: "\S"</H5>
<P class="docText">The set of nonwhitespace characters. Same as <TT>[^</TT> \<TT>t</TT>\<TT>n</TT>\<TT>r</TT>\<TT>f</TT>\<TT>v]</TT>.</P>
<A NAME="ch03lev4sec16"></A><H5 class="docSection4Title"> Wildcard character: "."</H5>
<P class="docText">The period matches any single character at a position. If the re.DOTALL modifier is specified, "." will match a newline. Otherwise, it will match anything other than a newline.</P>
<A NAME="ch03lev4sec17"></A><H5 class="docSection4Title"> Beginning of line: "^"</H5>
<P class="docText">The caret will match the beginning of the target string. If the re.MULTILINE modifier is specified, "^" will match the beginning of each line within the target string.</P>
<A NAME="ch03lev4sec18"></A><H5 class="docSection4Title"> Beginning of string: "\A"</H5>
<P class="docText">The "\A" will match the beginning of the target string. If the re.MULTILINE modifier is <span class="docEmphasis">not</span> specified, "\A" behaves the same as "^". But even if the modifier is used, "\A" will match only the beginning of the entire target.</P>
<A NAME="ch03lev4sec19"></A><H5 class="docSection4Title"> End of line: "$"</H5>
<P class="docText">The dollar sign will match the end of the target string. If the re.MULTILINE modifier is specified, "$" will match the end of each line within the target string.</P>
<A NAME="ch03lev4sec20"></A><H5 class="docSection4Title"> End of string: "\Z"</H5>
<P class="docText">The "\Z" will match the end of the target string. If the re.MULTILINE modifier is <span class="docEmphasis">not</span> specified, "\Z" behaves the same as "$". But even if the modifier is used, "\Z" will match only the end of the entire target.</P>
<A NAME="ch03lev4sec21"></A><H5 class="docSection4Title"> Word boundary: "\b"</H5>
<P class="docText">The "\b" will match the beginning or end of a word (where a word is defined as a sequence of alphanumeric characters according to the current modifiers). Like "^" and "$", "\b" is a zero-width match.</P>
<A NAME="ch03lev4sec22"></A><H5 class="docSection4Title"> Non-word boundary: "\B"</H5>
<P class="docText">The "\B" will match any position that is <span class="docEmphasis">not</span> the beginning or end of a word (where a word is defined as a sequence of alphanumeric characters according to the current modifiers). Like "^" and "$", "\B" is a zero-width match.</P>
<A NAME="ch03lev4sec23"></A><H5 class="docSection4Title"> Alternation operator: " |"</H5>
<P class="docText">The pipe symbol indicates a choice of multiple atoms in a position. Any of the atoms (including groups) separated by a pipe will match. For example:</P>
<pre>
&gt;&gt;&gt; from re_show import re_show
&gt;&gt;&gt; re_show(r'A|c|G', r'A X c G')
{A} X {c} {G}

&gt;&gt;&gt; re_show(r'(abc)|(xyz)', 'abc efg xyz lmn')
{abc} efg {xyz} lmn
</pre>
<A NAME="ch03lev3sec5"></A><H5 class="docSection3Title"> QUANTIFIERS</H5>
<A NAME="ch03lev4sec24"></A><H5 class="docSection4Title"> Universal quantifier: "*"</H5>
<P class="docText">Match zero or more occurrences of the preceding atom. The "*" quantifier is happy to match an empty string. For example:</P>
<pre>
&gt;&gt;&gt; from re_show import re_show
&gt;&gt;&gt; re_show('a* ', ' a aa aaa aaaa b')
{ }{a }{aa }{aaa}{aaaa }b
</pre>
<A NAME="ch03lev4sec25"></A><H5 class="docSection4Title"> Non-greedy universal quantifier: "*?"</H5>
<P class="docText">Match zero or more occurrences of the preceding atom, but try to match as few occurrences as allowable. For example:</P>
<pre>
&gt;&gt;&gt; from re_show import re_show
&gt;&gt;&gt; re_show('&lt;.*&gt;', '&lt;&gt; &lt;tag&gt;Text&lt;/tag&gt;')
{&lt;&gt; &lt;tag&gt;Text&lt;/tag&gt;}

&gt;&gt;&gt; re_show('&lt;.*?&gt;', '&lt;&gt; &lt;tag&gt;Text&lt;/tag&gt;')
{&lt;&gt;} {&lt;tag&gt;}Text{&lt;/tag&gt;}
</pre>
<A NAME="ch03lev4sec26"></A><H5 class="docSection4Title"> Existential quantifier: "+"</H5>
<P class="docText">Match one or more occurrences of the preceding atom. A pattern must actually occur in the target string to satisfy the "+" quantifier. For example:</P>
<pre>
&gt;&gt;&gt; from re_show import re_show
&gt;&gt;&gt; re_show('a+ ', ' a aa aaa aaaa b')
 {a }{aa }{aaa }{aaaa }b
</pre>
<A NAME="ch03lev4sec27"></A><H5 class="docSection4Title"> Non-greedy existential quantifier: "+?"</H5>
<P class="docText">Match one or more occurrences of the preceding atom, but try to match as few occurrences as allowable. For example:</P>
<pre>
&gt;&gt;&gt; from re_show import  re_show
&gt;&gt;&gt; re_show('&lt;.+&gt;', '&lt;&gt;  &lt;tag&gt;Text&lt;/tag&gt;')
{&lt;&gt; &lt;tag&gt;Text&lt;/tag&gt;}

&gt;&gt;&gt; re_show('&lt;.+?&gt;', '&lt;&gt; &lt;tag&gt;Text&lt;/tag&gt;')
{&lt;&gt; &lt;tag&gt;}Text{&lt;/tag&gt;}
</pre>
<A NAME="ch03lev4sec28"></A><H5 class="docSection4Title"> Potentiality quantifier: "?"</H5>
<P class="docText">Match zero or one occurrence of the preceding atom. The "?" quantifier is happy to match an empty string. For example:</P>
<pre>
&gt;&gt;&gt; from re_show import  re_show
&gt;&gt;&gt; re_show('a? ', ' a  aa aaa aaaa b')
{ }{a }a{a }aa{a }aaa{a  }b
</pre>
<A NAME="ch03lev4sec29"></A><H5 class="docSection4Title"> Non-greedy potentiality quantifier: "??"</H5>
<P class="docText">Match zero or one occurrence of the preceding atom, but match zero if possible. For example:</P>
<pre>
&gt;&gt;&gt; from re_show import re_show
&gt;&gt;&gt; re_show(' a?', ' a aa aaa aaaa b')
{ a}{ a}a{ a}aa{ a}aaa{ }b

&gt;&gt;&gt; re_show(' a??', ' a aa aaa aaaa b')
{ }a{ }aa{ }aaa{ }aaaa{ }b
</pre>
<A NAME="ch03lev4sec30"></A><H5 class="docSection4Title"> Exact numeric quantifier: "{num}"</H5>
<P class="docText">Match exactly <TT>num</TT> occurrences of the preceding atom. For example:</P>
<pre>
&gt;&gt;&gt; from re_show import re_show
&gt;&gt;&gt; re_show('a{3} ', ' a aa aaa aaaa b')
 a aa {aaa }a{aaa }b
</pre>
<A NAME="ch03lev4sec31"></A><H5 class="docSection4Title"> Lower-bound quantifier: "{min,}"</H5>
<P class="docText">Match <span class="docEmphasis">at least</span> <TT>min</TT> occurrences of the preceding atom. For example:</P>
<pre>
&gt;&gt;&gt; from re_show import re_show
&gt;&gt;&gt; re_show('a{3,} ', ' a aa aaa aaaa b')
 a aa {aaa }{aaaa }b
</pre>
<A NAME="ch03lev4sec32"></A><H5 class="docSection4Title"> Bounded numeric quantifier: "{min,max}"</H5>
<P class="docText">Match <span class="docEmphasis">at least</span> <TT>min</TT> and <span class="docEmphasis">no more than</span> <TT>max</TT> occurrences of the preceding atom. For example:</P>
<pre>
&gt;&gt;&gt; from re_show import re_show
&gt;&gt;&gt; re_show('a{2,3} ', ' a aa aaa aaaa b')
 a {aa }{aaa }a{aaa }
</pre>
<A NAME="ch03lev4sec33"></A><H5 class="docSection4Title"> Non-greedy bounded quantifier: "{min,max}?"</H5>
<P class="docText">Match <span class="docEmphasis">at least</span> <TT>min</TT> and <span class="docEmphasis">no more than</span> <TT>max</TT> occurrences of the preceding atom, but try to match as few occurrences as allowable. Scanning is from the left, so a nonminimal match may be produced in terms of right-side groupings. For example:</P>
<pre>
&gt;&gt;&gt; from re_show import re_show
&gt;&gt;&gt; re_show(' a{2,4}?', ' a aa aaa aaaa b')
 a{ aa}{ aa}a{ aa}aa b

&gt;&gt;&gt; re_show('a{2,4}? ', ' a aa aaa aaaa b')
 a {aa }{aaa }{aaaa }b
</pre>
<A NAME="ch03lev3sec6"></A><H5 class="docSection3Title"> GROUP-LIKE PATTERNS</H5>
<P class="docText">Python regular expressions may contain a number of pseudo-group elements that condition matches in some manner. With the exception of named groups, pseudo-groups are not counted in backreferencing. All pseudo-group patterns have the form "(?...)".</P>
<A NAME="ch03lev4sec34"></A><H5 class="docSection4Title"> Pattern modifiers: "(?Limsux)"</H5>
<P class="docText">The pattern modifiers should occur at the very beginning of a regular expression pattern. One or more letters in the set "Limsux" may be included. If pattern modifiers are given, the interpretation of the pattern is changed globally. See the discussion of modifier constants below or the tutorial for details.</P>
<A NAME="ch03lev4sec35"></A><H5 class="docSection4Title"> Comments: "(?#...)"</H5>
<P class="docText">Create a comment inside a pattern. The comment is not enumerated in backreferences and has no effect on what is matched. In most cases, use of the "(?x)" modifier allows for more clearly formatted comments than does "(?#...)".</P>
<pre>
&gt;&gt;&gt; from re_show import re_show
&gt;&gt;&gt; re_show(r'The(?#words in caps) Cat', 'The Cat in the Hat')
{The Cat} in the Hat
</pre>
<A NAME="ch03lev4sec36"></A><H5 class="docSection4Title"> Non-backreferenced atom: "(?:...)"</H5>
<P class="docText">Match the pattern "...", but do not include the matched string as a backreferencable group. Moreover, methods like <span class="docEmphasis"><TT>re.match.group ()</TT></span> will not see the pattern inside a non-backreferenced atom.</P>
<pre>
&gt;&gt;&gt; from re_show import re_show
&gt;&gt;&gt; re_show(r'(?:\w+) (\w+).* \1', 'abc xyz xyz abc')
{abc xyz xyz} abc

&gt;&gt;&gt; re_show(r'(\w+) (\w+).* \1', 'abc xyz xyz abc')
{abc xyz xyz abc}
</pre>
<A NAME="ch03lev4sec37"></A><H5 class="docSection4Title"> Positive Lookahead assertion: "(?=...)"</H5>
<P class="docText">Match the entire pattern only if the subpattern "..." occurs next. But do not include the target substring matched by "..." as part of the match (however, some other subpattern may claim the same characters, or some of them).</P>
<pre>
&gt;&gt;&gt; from re_show import re_show
&gt;&gt;&gt; re_show(r'\w+ (?=xyz)', 'abc xyz xyz abc')
{abc }{xyz }xyz abc
</pre>
<A NAME="ch03lev4sec38"></A><H5 class="docSection4Title"> Negative Lookahead assertion: "(?!...)"</H5>
<P class="docText">Match the entire pattern only if the subpattern "..." does <span class="docEmphasis">not</span> occur next.</P>
<pre>
&gt;&gt;&gt; from re_show import re_show
&gt;&gt;&gt; re_show(r'\w+ (?!xyz)', 'abc xyz xyz abc')
abc xyz {xyz }abc
</pre>
<A NAME="ch03lev4sec39"></A><H5 class="docSection4Title"> Positive Lookbehind assertion: "(?&lt; =...)"</H5>
<P class="docText">Match the rest of the entire pattern only if the subpattern "..." occurs immediately prior to the current match point. But do not include the target substring matched by "..." as part of the match (the same characters may or may not be claimed by some prior group(s) in the entire pattern). The pattern "..." must match a fixed number of characters and therefore not contain general quantifiers.</P>
<pre>
&gt;&gt;&gt; from re_show import re_show
&gt;&gt;&gt; re_show(r'\w+(?&lt;=[A-Z]) ', 'Words THAT end in capS X')
Words {THAT }end in {capS }X
</pre>
<A NAME="ch03lev4sec40"></A><H5 class="docSection4Title"> Negative Lookbehind assertion: "(?&lt;!...)"</H5>
<P class="docText">Match the rest of the entire pattern only if the subpattern "..." does <span class="docEmphasis">not</span> occur immediately prior to the current match point. The same characters may or may not be claimed by some prior group(s) in the entire pattern. The pattern "..." must match a fixed number of characters and therefore not contain general quantifiers.</P>
<pre>
&gt;&gt;&gt; from re_show import re_show
&gt;&gt;&gt; re_show(r'\w+(?&lt;![A-Z]) ', 'Words THAT end in capS X')
{Words }THAT {end }{in }capS X
</pre>
<A NAME="ch03lev4sec41"></A><H5 class="docSection4Title"> Named group identifier: "(?P&lt;name&gt;)"</H5>
<P class="docText">Create a group that can be referred to by the name <TT>name</TT> as well as in enumerated backreferences. The forms below are equivalent.</P>
<pre>
&gt;&gt;&gt; from re_show import re_show
&gt;&gt;&gt; re_show(r'(\w+) (\w+).* \1', 'abc xyz xyz abc')
{abc xyz xyz abc}

&gt;&gt;&gt; re_show(r'(?P&lt;first&gt;\w+) (\w+).* (?P=first)', 'abc xyz xyz abc')
{abc xyz xyz abc}

&gt;&gt;&gt; re_show(r'(?P&lt;first&gt;\w+) (\w+).* \1', 'abc xyz xyz abc')
{abc xyz xyz abc}
</pre>
<A NAME="ch03lev4sec42"></A><H5 class="docSection4Title"> Named group backreference: "(?P=name)"</H5>
<P class="docText">Backreference a group by the name <TT>name</TT> rather than by escaped group number. The group name must have been defined earlier by <TT>(?P&lt;name&gt;)</TT>, or an error is raised.</P>
<A NAME="ch03lev3sec7"></A><H5 class="docSection3Title"> CONSTANTS</H5>
<P class="docText">A number of constants are defined in the <span class="docEmphasis"><TT>re</TT></span> modules that act as modifiers to many <span class="docEmphasis"><TT>re</TT></span> functions. These constants are independent bit-values, so that multiple modifiers may be selected by bitwise disjunction of modifiers. For example:</P>
<pre>
&gt;&gt;&gt; import re
&gt;&gt;&gt; c = re.compile('cat | dog', re.IGNORECASE | re.UNICODE)
</pre>
<A NAME="ch03lev4sec43"></A><H5 class="docSection4Title"> re.l, re.IGNORECASE</H5>
<P class="docText">Modifier for case-insensitive matching. Lowercase and uppercase letters are interchangeable in patterns modified with this modifier. The prefix <TT>(?i)</TT> may also be used inside the pattern to achieve the same effect.</P>
<A NAME="ch03lev4sec44"></A><H5 class="docSection4Title"> re.L, re.LOCALE</H5>
<P class="docText">Modifier for locale-specific matching of \<TT>w</TT>, \<TT>W</TT>, \<TT>b</TT>, and \<TT>B</TT>. The prefix <TT>(?L)</TT> may also be used inside the pattern to achieve the same effect.</P>
<A NAME="ch03lev4sec45"></A><H5 class="docSection4Title"> re.M, re.MULTILINE</H5>
<P class="docText">Modifier to make <TT>^</TT> and <TT>$</TT> match the beginning and end, respectively, of <span class="docEmphasis">each</span> line in the target string rather than the beginning and end of the entire target string. The prefix <TT>(?m)</TT> may also be used inside the pattern to achieve the same effect.</P>
<A NAME="ch03lev4sec46"></A><H5 class="docSection4Title"> re.S, re.DOTALL</H5>
<P class="docText">Modifier to allow <TT>.</TT> to match a newline character. Otherwise, <TT>.</TT> matches every character <span class="docEmphasis">except</span> newline characters. The prefix <TT>(?s)</TT> may also be used inside the pattern to achieve the same effect.</P>
<A NAME="ch03lev4sec47"></A><H5 class="docSection4Title"> re.U, re.UNICODE</H5>
<P class="docText">Modifier for Unicode-property matching of \<TT>w</TT>, \<TT>W</TT>, \<TT>b</TT>, and \<TT>B</TT>. Only relevant for Unicode targets. The prefix <TT>(?u)</TT> may also be used inside the pattern to achieve the same effect.</P>
<A NAME="ch03lev4sec48"></A><H5 class="docSection4Title"> re.X, re.VERBOSE</H5>
<P class="docText">Modifier to allow patterns to contain insignificant whitespace and end-of-line comments. Can significantly improve readability of patterns. The prefix <TT>(?x)</TT> may also be used inside the pattern to achieve the same effect.</P>
<A NAME="ch03lev4sec49"></A><H5 class="docSection4Title"> re.engine</H5>
<P class="docText">The regular expression engine currently in use. Only supported in Python 2.0+, where it normally is set to the string <TT>sre</TT>. The presence and value of this constant can be checked to make sure which underlying implementation is running, but this check is rarely necessary.</P>
<A NAME="ch03lev3sec8"></A><H5 class="docSection3Title"> FUNCTIONS</H5>
<P class="docText">For all <span class="docEmphasis"><TT>re</TT></span> functions, where a regular expression pattern <TT>pattern</TT> is an argument, <TT>pattern</TT> may be either a compiled regular expression or a string.</P>
<A NAME="ch03lev4sec50"></A><H5 class="docSection4Title"> re.escape(s)</H5>
<P class="docText">Return a string with all nonalphanumeric characters escaped. This (slightly scattershot) conversion makes an arbitrary string suitable for use in a regular expression pattern (matching all literals in original string).</P>
<pre>
&gt;&gt;&gt; import  re
&gt;&gt;&gt; print  re.escape("(*@&amp;^$@|")
\(\*\@\&amp;\^\$\@\|
</pre>
<A NAME="ch03lev4sec51"></A><H5 class="docSection4Title"> re.findall(pattern=..., string=...)</H5>
<P class="docText">Return a list of all nonoverlapping occurrences of <TT>pattern</TT> in <TT>string</TT>. If <TT>pattern</TT> consists of several groups, return a list of tuples where each tuple contains a match for each group. Length-zero matches are included in the returned list, if they occur.</P>
<pre>
&gt;&gt;&gt; import re
&gt;&gt;&gt; re.findall(r'\b[a-z]+\d+\b', 'abc123 xyz666 lmn-11 def77')
['abc123', 'xyz666', 'def77']
&gt;&gt;&gt; re.findall(r'\b([a-z]+)(\d+)\b', 'abc123 xyz666 lmn-11 def77')
[('abc', '123'), ('xyz', '666'), ('def', '77')]
</pre>
<p class="docText"><span class="docEmphRoman">S<span class="docEmphSmaller">EE</span> A<span class="docEmphSmaller">LSO</span></span>: 
re.search() <span class="docEmphasis">249;</span> mx.TextTools.findall() <span class="docEmphasis">312;</span></p>
<A NAME="ch03lev4sec52"></A><H5 class="docSection4Title"> re.purge()</H5>
<P class="docText">Clear the regular expression cache. The <span class="docEmphasis"><TT>re</TT></span> module keeps a cache of implicitly compiled regular expression patterns. The number of patterns cached differs between Python versions, with more recent versions generally keeping 100 items in the cache. When the cache space becomes full, it is flushed automatically. You could use <span class="docEmphasis"><TT>re.purge()</TT></span> to tune the timing of cache flushes. However, such tuning is approximate at best: Patterns that are used repeatedly are much better off explicitly compiled with <span class="docEmphasis"><TT>re.compile()</TT></span> and then used explicitly as named objects.</P>
<A NAME="ch03lev4sec53"></A><H5 class="docSection4Title"> re.split(pattern=..., string=...[,maxsplit=0])</H5>
<P class="docText">Return a list of substrings of the second argument <TT>string</TT>. The first argument <TT>pattern</TT> is a regular expression that delimits the substrings. If <TT>pattern</TT> contains groups, the groups are included in the resultant list. Otherwise, those substrings that match <TT>pattern</TT> are dropped, and only the substrings between occurrences of <TT>pattern</TT> are returned.</P>
<P class="docText">If the third argument <TT>maxsplit</TT> is specified as a positive integer, no more than <TT>maxsplit</TT> items are parsed into the list, with any leftover contained in the final list element.</P>
<pre>
&gt;&gt;&gt; import re
&gt;&gt;&gt; re.split(r'\s+', 'The Cat in the Hat')
['The', 'Cat', 'in', 'the', 'Hat']
&gt;&gt;&gt; re.split(r'\s+', 'The Cat in the Hat', maxsplit=3)
['The', 'Cat', 'in', 'the Hat']
&gt;&gt;&gt; re.split(r'(\s+)', 'The Cat in the Hat')
['The', ' ', 'Cat', ' ', 'in', ' ', 'the', ' ', 'Hat']
&gt;&gt;&gt; re.split(r'(a)(t)', 'The Cat in the Hat')
['The C', 'a', 't', ' in the H', 'a', 't', '']
&gt;&gt;&gt; re.split(r'a(t)', 'The Cat in the Hat')
['The C', 't', ' in the H', 't', '']
</pre>
<p class="docText"><span class="docEmphRoman">S<span class="docEmphSmaller">EE</span> A<span class="docEmphSmaller">LSO</span></span>: 
string.split() <span class="docEmphasis">142</span>;</p>
<A NAME="ch03lev4sec54"></A><H5 class="docSection4Title"> re.sub(pattern=..., repl=..., string=...[,count=0])</H5>
<P class="docText">Return the string produced by replacing every nonoverlapping occurrence of the first argument <TT>pattern</TT> with the second argument <TT>repl</TT> in the third argument <TT>string</TT>. If the fourth argument <TT>count</TT> is specified, no more than <TT>count</TT> replacements will be made.</P>
<P class="docText">The second argument <TT>repl</TT> is most often a regular expression pattern as a string. Backreferences to groups matched by <TT>pattern</TT> may be referred to by enumerated backreferences using the usual escaped numbers. If backreferences in <TT>pattern</TT> are named, they may also be referred to using the form \<TT>g&lt;name&gt;</TT> (where <TT>name</TT> is the name given the group in <TT>pat</TT>). As well, enumerated backreferences may optionally be referred to using the form \<TT>g&lt;num&gt;</TT>, where <TT>num</TT> is an integer between 1 and 99. Some examples:</P>
<pre>
&gt;&gt;&gt; import re
&gt;&gt;&gt; s = 'abc123 xyz666 lmn-11 def77'
&gt;&gt;&gt; re.sub(r'\b([a-z]+)(\d+)', r'\2\1 :', s)
'123abc : 666xyz : lmn-11 77def :'
&gt;&gt;&gt; re.sub(r'\b(?P&lt;lets&gt;[a-z]+)(?P&lt;nums&gt;\d+)', r'\g&lt;nums&gt;\g&lt;1&gt; :', s)
'123abc : 666xyz : lmn-11 77def :'
&gt;&gt;&gt; re.sub('A', 'X', 'AAAAAAAAAA', count=4)
'XXXXAAAAAA'
</pre>
<P class="docText">A variant manner of calling <span class="docEmphasis"><TT>re.sub ()</TT></span> uses a function object as the second argument <TT>repl</TT>. Such a callback function should take a MatchObject as an argument and return a string. The <TT>repl</TT> function is invoked for each match of <TT>pattern</TT>, and the string it returns is substituted in the result for whatever <TT>pattern</TT> matched. For example:</P>
<pre>
&gt;&gt;&gt; import re
&gt;&gt;&gt; sub_cb = lambda pat: '('+'len(pat.group())'+')'+pat.group()
&gt;&gt;&gt; re.sub(r'\w+', sub_cb, 'The length of each word')
'(3)The (6)length (2)of (4)each (4)word'
</pre>
<P class="docText">Of course, if <TT>repl</TT> is a function object, you can take advantage of side effects rather than (or instead of) simply returning modified strings. For example:</P>
<pre>
&gt;&gt;&gt; import re
&gt;&gt;&gt; def side_effects(match):
...     # Arbitrarily complicated behavior could go here...
...     print len(match.group()), match.group()
...     return match.group()  # unchanged match
...
&gt;&gt;&gt; new = re.sub(r'\w+', side_effects, 'The length of each word')
3 The
6 length
2 of
4 each
4 word
&gt;&gt;&gt; new
'The length of each word'
</pre>
<P class="docText">Variants on callbacks with side effects could be turned into complete string-driven programs (in principle, a parser and execution environment for a whole programming language could be contained in the callback function, for example).</P>
<p class="docText"><span class="docEmphRoman">S<span class="docEmphSmaller">EE</span> A<span class="docEmphSmaller">LSO</span></span>: 
string.replace() <span class="docEmphasis">139;</span></p>
<A NAME="ch03lev4sec55"></A><H5 class="docSection4Title"> re.subn(pattern=..., repl=..., string=...[,count=0])</H5>
<P class="docText">Identical to <span class="docEmphasis"><TT>re.sub ()</TT> ,</span> except return a 2-tuple with the new string and the number of replacements made.</P>
<pre>
&gt;&gt;&gt; import re
&gt;&gt;&gt; s = 'abc123 xyz666 lmn-11 def77'
&gt;&gt;&gt; re.subn(r'\b([a-z]+)(\d+)', r'\2\1 :', s)
('123abc : 666xyz : lmn-11 77def :', 3)
</pre>
<p class="docText"><span class="docEmphRoman">S<span class="docEmphSmaller">EE</span> A<span class="docEmphSmaller">LSO</span></span>: 
re.sub() <span class="docEmphasis">246</span>;</p>
<A NAME="ch03lev3sec9"></A><H5 class="docSection3Title"> CLASS FACTORIES</H5>
<P class="docText">As with some other Python modules, primarily ones written in C, <span class="docEmphasis"><TT>re</TT></span> does not contain true classes that can be specialized. Instead, <span class="docEmphasis"><TT>re</TT></span> has several factory-functions that return instance objects. The practical difference is small for most users, who will simply use the methods and attributes of returned instances in the same manner as those produced by true classes.</P>
<A NAME="ch03lev4sec56"></A><H5 class="docSection4Title"> re.compile(pattern=...[,flags=...])</H5>
<P class="docText">Return a PatternObject based on pattern string <TT>pattern</TT>. If the second argument <TT>flags</TT> is specified, use the modifiers indicated by <TT>flags</TT>. A PatternObject is interchangeable with a pattern string as an argument to <span class="docEmphasis"><TT>re</TT></span> functions. However, a pattern that will be used frequently within an application should be compiled in advance to assure that it will not need recompilation during execution. Moreover, a compiled PatternObject has a number of methods and attributes that achieve effects equivalent to <span class="docEmphasis"><TT>re</TT></span> functions, but which are somewhat more readable in some contexts. For example:</P>
<pre>
&gt;&gt;&gt; import re
    &gt;&gt;&gt; word = re.compile('[A-Za-z]+')
&gt;&gt;&gt; word.findall('The Cat in the Hat')
['The', 'Cat', 'in', 'the', 'Hat']
&gt;&gt;&gt; re.findall(word, 'The Cat in the Hat')
['The', 'Cat', 'in', 'the', 'Hat']
</pre>
<A NAME="ch03lev4sec57"></A><H5 class="docSection4Title"> re.match(pattern=..., string=...[,flags=...])</H5>
<P class="docText">Return a MatchObject if an initial substring of the second argument <TT>string</TT> matches the pattern in the first argument <TT>pattern</TT>. Otherwise return None. A MatchObject, if returned, has a variety of methods and attributes to manipulate the matched pattern—but notably a MatchObject is <span class="docEmphasis">not</span> itself a string.</P>
<P class="docText">Since <span class="docEmphasis"><TT>re.match()</TT></span> only matches initial substrings, <span class="docEmphasis"><TT>re.search()</TT></span> is more general. <span class="docEmphasis"><TT>re.search()</TT></span> can be constrained to itself match only initial substrings by prepending "\A" to the pattern matched.</P>
<p class="docText"><span class="docEmphRoman">S<span class="docEmphSmaller">EE</span> A<span class="docEmphSmaller">LSO</span></span>: 
re.search() <span class="docEmphasis">249</span>; re.compile.match() <span class="docEmphasis">250</span>;</p>
<A NAME="ch03lev4sec58"></A><H5 class="docSection4Title"> re.search(pattern=..., string=...[,flags=...])</H5>
<P class="docText">Return a MatchObject corresponding to the leftmost substring of the second argument <TT>string</TT> that matches the pattern in the first argument <TT>pattern</TT>. If no match is possible, return None. A matched string can be of zero length if the pattern allows that (usually not what is actually desired). A MatchObject, if returned, has a variety of methods and attributes to manipulate the matched pattern—but notably a MatchObject is <span class="docEmphasis">not</span> itself a string.</P>
<p class="docText"><span class="docEmphRoman">S<span class="docEmphSmaller">EE</span> A<span class="docEmphSmaller">LSO</span></span>: 
re.match() <span class="docEmphasis">248</span>; re.compile.search() <span class="docEmphasis">250</span>;</p>
<A NAME="ch03lev3sec10"></A><H5 class="docSection3Title"> METHODS AND ATTRIBUTES</H5>
<A NAME="ch03lev4sec59"></A><H5 class="docSection4Title"> re.compile.findall(s)</H5>
<P class="docText">Return a list of nonoverlapping occurrences of the PatternObject in <TT>s</TT>. Same as <TT>re.findall()</TT> called with the PatternObject.</P>
<P class="docText">SEE ALSO <span class="docEmphasis"><TT>re.findall()</TT></span></P>
<A NAME="ch03lev4sec60"></A><H5 class="docSection4Title"> re.compile.flags</H5>
<P class="docText">The numeric sum of the flags passed to <span class="docEmphasis"><TT>re.compile()</TT></span> in creating the PatternObject. No formal guarantee is given by Python as to the values assigned to modifier flags, however. For example:</P>
<pre>
&gt;&gt;&gt; import re
&gt;&gt;&gt; re.I,re.L,re.M,re.S,re.X
(2, 4, 8, 16, 64)
&gt;&gt;&gt; c = re.compile('a', re.I | re.M)
&gt;&gt;&gt; c.flags
10
</pre>
<A NAME="ch03lev4sec61"></A><H5 class="docSection4Title"> re.compile.groupindex</H5>
<P class="docText">A dictionary mapping group names to group numbers. If no named groups are used in the pattern, the dictionary is empty. For example:</P>
<pre>
&gt;&gt;&gt; import re
&gt;&gt;&gt; c = re.compile(r'(\d+)(\[A-Z]+)([a-z]+)')
&gt;&gt;&gt; c.groupindex
{}
&gt;&gt;&gt; c=re.compile(r'(?P&lt;nums&gt;\d+)(?P&lt;caps&gt;\[A-Z]+)(?P&lt;lwrs&gt;[a-z]+)')
&gt;&gt;&gt; c.groupindex
{'nums': 1, 'caps': 2, 'lwrs': 3}
</pre>
<A NAME="ch03lev4sec62"></A><H5 class="docSection4Title"> re.compile.match(s [,start [,end]])</H5>
<P class="docText">Return a MatchObject if an initial substring of the first argument <TT>s</TT> matches the PatternObject. Otherwise, return None. A MatchObject, if returned, has a variety of methods and attributes to manipulate the matched pattern—but notably a MatchObject is <span class="docEmphasis">not</span> itself a string.</P>
<P class="docText">In contrast to the similar function <span class="docEmphasis"><TT>re.match()</TT> ,</span> this method accepts optional second and third arguments <TT>start</TT> and <TT>end</TT> that limit the match to substring within <TT>s</TT>. In most respects specifying <TT>start</TT> and <TT>end</TT> is similar to taking a slice of <TT>s</TT> as the first argument. But when <TT>start</TT> and <TT>end</TT> are used, "^" will only match the true start of <TT>s</TT>. For example:</P>
<pre>
&gt;&gt;&gt; import re
&gt;&gt;&gt; s = 'abcdefg'
&gt;&gt;&gt; c = re.compile('^b')
&gt;&gt;&gt; print c.match(s, 1)
None
&gt;&gt;&gt; c.match(s[1:])
&lt;SRE_Match object at 0x10c440&gt;
&gt;&gt;&gt; c = re.compile('.*f$')
&gt;&gt;&gt; c.match(s[:-1])
&lt;SRE_Match object at 0x116d80&gt;
&gt;&gt;&gt; c.match(s,1,6)
&lt;SRE_Match object at 0x10c440&gt;
</pre>
<p class="docText"><span class="docEmphRoman">S<span class="docEmphSmaller">EE</span> A<span class="docEmphSmaller">LSO</span></span>: 
re.match() <span class="docEmphasis">248</span>; re.compile.search() <span class="docEmphasis">250</span>;</p>
<A NAME="ch03lev4sec63"></A><H5 class="docSection4Title"> re.compile.pattern</H5>
<P class="docText">The pattern string underlying the compiled MatchObject.</P>
<pre>
&gt;&gt;&gt; import re
&gt;&gt;&gt; c = re.compile('^abc$')
&gt;&gt;&gt; c.pattern
'^abc$'
</pre>
<A NAME="ch03lev4sec64"></A><H5 class="docSection4Title"> re.compile.search(s [,start [,end]])</H5>
<P class="docText">Return a MatchObject corresponding to the leftmost substring of the first argument <TT>string</TT> that matches the PatternObject. If no match is possible, return None. A matched string can be of zero length if the pattern allows that (usually not what is actually desired). A MatchObject, if returned, has a variety of methods and attributes to manipulate the matched pattern—but notably a MatchObject is <span class="docEmphasis">not</span> itself a string.</P>
<P class="docText">In contrast to the similar function <span class="docEmphasis"><TT>re.search()</TT> ,</span> this method accepts optional second and third arguments <TT>start</TT> and <TT>end</TT> that limit the match to a substring within <TT>s</TT>. In most respects specifying <TT>start</TT> and <TT>end</TT> is similar to taking a slice of <TT>s</TT> as the first argument. But when <TT>start</TT> and <TT>end</TT> are used, "^" will only match the true start of <TT>s</TT>. For example:</P>
<pre>
&gt;&gt;&gt; import re
&gt;&gt;&gt; s = 'abcdefg'
&gt;&gt;&gt; c = re.compile('^b')
&gt;&gt;&gt; c = re.compile('^b')
&gt;&gt;&gt; print c.search(s, 1),c.search(s[1:])
None &lt;SRE_Match object at 0x117980&gt;
&gt;&gt;&gt; c = re.compile('.*f$')
&gt;&gt;&gt; print c.search(s[:-1]),c.search(s,1,6)
&lt;SRE_Match object at Ox51040&gt; &lt;SRE_Match object at 0x51040&gt;
</pre>
<p class="docText"><span class="docEmphRoman">S<span class="docEmphSmaller">EE</span> A<span class="docEmphSmaller">LSO</span></span>: 
re.search() <span class="docEmphasis">249</span>; re.compile.match() <span class="docEmphasis">250</span>;</p>
<A NAME="ch03lev4sec65"></A><H5 class="docSection4Title"> re.compile.split(s [,maxsplit])</H5>
<P class="docText">Return a list of substrings of the first argument <TT>s</TT>. If thePatternObject contains groups, the groups are included in the resultant list. Otherwise, those substrings that match PatternObject are dropped, and only the substrings between occurrences of <TT>pattern</TT> are returned.</P>
<P class="docText">If the second argument <TT>maxsplit</TT> is specified as a positive integer, no more than <TT>maxsplit</TT> items are parsed into the list, with any leftover contained in the final list element.</P>
<P class="docText"><span class="docEmphasis"><TT>re.compile.split()</TT></span> is identical in behavior to <span class="docEmphasis"><TT>re.split()</TT></span> , simply spelled slightly differently. See the documentation of the latter for examples of usage.</P>
<p class="docText"><span class="docEmphRoman">S<span class="docEmphSmaller">EE</span> A<span class="docEmphSmaller">LSO</span></span>: 
re.split() <span class="docEmphasis">246</span>;</p>
<A NAME="ch03lev4sec66"></A><H5 class="docSection4Title"> re.compile.sub(repl, s [,count=0])</H5>
<P class="docText">Return the string produced by replacing every nonoverlapping occurrence of the PatternObject with the first argument <TT>repl</TT> in the second argument <TT>string</TT>. If the third argument <TT>count</TT> is specified, no more than <TT>count</TT> replacements will be made.</P>
<P class="docText">The first argument <TT>repl</TT> may be either a regular expression pattern as a string or a callback function. Backreferences may be named or enumerated.</P>
<P class="docText"><span class="docEmphasis"><TT>re.compile.sub ()</TT></span> is identical in behavior to <span class="docEmphasis"><TT>re.sub()</TT></span>, simply spelled slightly differently. See the documentation of the latter for a number of examples of usage.</P>
<p class="docText"><span class="docEmphRoman">S<span class="docEmphSmaller">EE</span> A<span class="docEmphSmaller">LSO</span></span>: 
re.sub() <span class="docEmphasis">246</span>; re.compile.subn() <span class="docEmphasis">252</span>;</p>
<A NAME="ch03lev4sec67"></A><H5 class="docSection4Title"> re.compile.subn()</H5>
<P class="docText">Identical to <span class="docEmphasis"><TT>re.compile.sub()</TT></span> , except return a 2-tuple with the new string and the number of replacements made.</P>
<P class="docText"><span class="docEmphasis"><TT>re.compile.subn()</TT></span> is identical in behavior to <span class="docEmphasis"><TT>re.subn()</TT></span>, simply spelled slightly differently. See the documentation of the latter for examples of usage.</P>
<p class="docText"><span class="docEmphRoman">S<span class="docEmphSmaller">EE</span> A<span class="docEmphSmaller">LSO</span></span>: 
re.subn() <span class="docEmphasis">248</span>; re.compile.sub() <span class="docEmphasis">251</span>;</p>
<P class="docText">Note: The arguments to each "MatchObject" method are listed on the <span class="docEmphasis"><TT>re.match()</TT></span> line, with ellipses given on the <span class="docEmphasis"><TT>re.search()</TT></span> line. All arguments are identical since <span class="docEmphasis"><TT>re.match()</TT></span> and <span class="docEmphasis"><TT>re.search()</TT></span> return the very same type of object.</P>
<A NAME="ch03lev4sec68"></A><H5 class="docSection4Title"> re.match.end([group])<br>re.search.end ([group])</H5>
<P class="docText">The index of the end of the target substring matched by the MatchObject. If the argument <TT>group</TT> is specified, return the ending index of that specific enumerated group. Otherwise, return the ending index of group 0 (i.e., the whole match). If <TT>group</TT> exists but is the part of an alternation operator that is not used in the current match, return -1. If <span class="docEmphasis"><TT>re.search.end()</TT></span> returns the same non-negative value as <span class="docEmphasis"><TT>re.search.start ()</TT></span> , then <TT>group</TT> is a zero-width substring.</P>
<pre>
&gt;&gt;&gt; import  re
&gt;&gt;&gt; m = re.search('(\w+)((\d*)| )(\w+)','The Cat in the Hat')
&gt;&gt;&gt; m.groups()
('The', ' ', None, 'Cat')
&gt;&gt;&gt; m.end(0), m.end(1), m.end(2), m.end(3), m.end(4)
(7, 3, 4, -1, 7)
</pre>
<A NAME="ch03lev4sec69"></A><H5 class="docSection4Title"> re.match.endpos, re.search.endpos</H5>
<P class="docText">The end position of the search. If <span class="docEmphasis"><TT>re.compile.search()</TT></span> specified an <TT>end</TT> argument, this is the value, otherwise it is the length of the target string. If <span class="docEmphasis"><TT>re.search()</TT></span> or <span class="docEmphasis"><TT>re.match()</TT></span> are used for the search, the value is always the length of the target string.</P>
<p class="docText"><span class="docEmphRoman">S<span class="docEmphSmaller">EE</span> A<span class="docEmphSmaller">LSO</span></span>: 
re.compile.search() <span class="docEmphasis">250</span>; re.search() <span class="docEmphasis">249</span>; re.match() <span class="docEmphasis">248</span>;</p>
<A NAME="ch03lev4sec70"></A><H5 class="docSection4Title"> re.match.expand(template)<br>re.search.expand(template)</H5>
<P class="docText">Expand backreferences and escapes in the argument <TT>template</TT> based on the patterns matched by the MatchObject. The expansion rules are the same as for the <TT>repl </TT>argument to <span class="docEmphasis"><TT>re.sub ()</TT></span>. Any nonescaped characters may also be included as part of the resultant string. For example:</P>
<pre>
&gt;&gt;&gt; import re
&gt;&gt;&gt; m = re.search('(\w+) (\w+)','The Cat in the Hat')
&gt;&gt;&gt; m.expand(r'\g&lt;2&gt; : \1')
'Cat : The'
</pre>
<A NAME="ch03lev4sec71"></A><H5 class="docSection4Title"> re.match.group([group [,...]])<br>re.search.group([group [,...]])</H5>
<P class="docText">Return a group or groups from the MatchObject. If no arguments are specified, return the entire matched substring. If one argument <TT>group</TT> is specified, return the corresponding substring of the target string. If multiple arguments <TT>group1, group2, ...</TT> are specified, return a tuple of corresponding substrings of the target.</P>
<pre>
&gt;&gt;&gt; import re
&gt;&gt;&gt; m = re.search(r'(\w+)(/)(\d+)','abc/123')
&gt;&gt;&gt; m.group()
'abc/123'
&gt;&gt;&gt; m.group(1)
'abc'
&gt;&gt;&gt; m.group(1,3)
('abc', '123')
</pre>
<p class="docText"><span class="docEmphRoman">S<span class="docEmphSmaller">EE</span> A<span class="docEmphSmaller">LSO</span></span>: 
re.search.groups() <span class="docEmphasis">253</span>; re.search.groupdict() <span class="docEmphasis">253</span>;</p>
<A NAME="ch03lev4sec72"></A><H5 class="docSection4Title"> re.match.groupdict([defval])<br>re.search.groupdict([defval])</H5>
<P class="docText">Return a dictionary whose keys are the named groups in the pattern used for the match. Enumerated but unnamed groups are not included in the returned dictionary. The values of the dictionary are the substrings matched by each group in the MatchObject. If a named group is part of an alternation operator that is not used in the current match, the value corresponding to that key is None, or <TT>defval</TT> if an argument is specified.</P>
<pre>
&gt;&gt;&gt; import re
&gt;&gt;&gt; m = re.search(r'(?P&lt;one&gt;\w+)((?P&lt;tab&gt;\t)|( ))(?P&lt;two&gt;\d+)','abc 123')
&gt;&gt;&gt; m.groupdict()
{'one': 'abc', 'tab': None, 'two': '123'}
&gt;&gt;&gt; m.groupdict('---')
{'one': 'abc', 'tab': '---', 'two': '123'}
</pre>
<p class="docText"><span class="docEmphRoman">S<span class="docEmphSmaller">EE</span> A<span class="docEmphSmaller">LSO</span></span>: 
re.search.groups() <span class="docEmphasis">253</span>;</p>
<A NAME="ch03lev4sec73"></A><H5 class="docSection4Title"> re.match.groups([defval])<br>re.search.groups([defval])</H5>
<P class="docText">Return a tuple of the substrings matched by groups in the MatchObject. If a group is part of an alternation operator that is not used in the current match, the tuple element at that index is None, or <TT>defval</TT> if an argument is specified.</P>
<pre>
&gt;&gt;&gt; import re
&gt;&gt;&gt; m = re.search(r'(\w+)((\t)|(/))(\d+)','abc/123')
&gt;&gt;&gt; m.groups()
('abc', '/', None, '/', '123')
&gt;&gt;&gt; m.groups('---')
('abc', '/', '---', '/', '123')
</pre>
<p class="docText"><span class="docEmphRoman">S<span class="docEmphSmaller">EE</span> A<span class="docEmphSmaller">LSO</span></span>: 
re.search.group() <span class="docEmphasis">253</span>; re.search.groupdict() <span class="docEmphasis">253</span>;</p>
<A NAME="ch03lev4sec74"></A><H5 class="docSection4Title"> re.match.lastgroup, re.search.lastgroup</H5>
<P class="docText">The name of the last matching group, or None if the last group is not named or if no groups compose the match.</P>
<A NAME="ch03lev4sec75"></A><H5 class="docSection4Title"> re.match.lastindex, re.search.lastindex</H5>
<P class="docText">The index of the last matching group, or None if no groups compose the match.</P>
<A NAME="ch03lev4sec76"></A><H5 class="docSection4Title"> re.match.pos, re.search.pos</H5>
<P class="docText">The start position of the search. If <span class="docEmphasis"><TT>re.compile.search()</TT></span> specified a <TT>start</TT> argument, this is the value, otherwise it is 0. If <span class="docEmphasis"><TT>re.search()</TT></span> or <span class="docEmphasis"><TT>re.match()</TT></span> are used for the search, the value is always 0.</P>
<p class="docText"><span class="docEmphRoman">S<span class="docEmphSmaller">EE</span> A<span class="docEmphSmaller">LSO</span></span>: 
re.compile.search() <span class="docEmphasis">250;</span> re.search() <span class="docEmphasis">249</span>; re.match() <span class="docEmphasis">248</span>;</p>
<A NAME="ch03lev4sec77"></A><H5 class="docSection4Title"> re.match.re, re.search.re</H5>
<P class="docText">The PatternObject used to produce the match. The actual regular expression pattern string must be retrieved from the PatternObject's <TT>pattern</TT> method:</P>
<pre>
&gt;&gt;&gt; import re
&gt;&gt;&gt; m = re.search('a','The Cat in the Hat')
&gt;&gt;&gt; m.re.pattern
'a'
</pre>
<A NAME="ch03lev4sec78"></A><H5 class="docSection4Title"> re.match.span ([group])<br>re.search.span([group])</H5>
<P class="docText">Return the tuple composed of the return values of <TT>re.search.start (group)</TT> and <TT>re.search.end (group)</TT>. If the argument <TT>group</TT> is not specified, it defaults to 0.</P>
<pre>
&gt;&gt;&gt; import re
&gt;&gt;&gt; m = re.search('(\w+)((\d*)| )(\w+)','The Cat in the Hat')
&gt;&gt;&gt; m.groups()
('The', ' ', None, 'Cat')
&gt;&gt;&gt; m.span(0), m.span(1), m.span(2), m.span(3), m.span(4)
((0, 7), (0, 3), (3, 4), (-1, -1), (4, 7))
</pre>
<A NAME="ch03lev4sec79"></A><H5 class="docSection4Title"> re.match.start ([group])<br>re.search.start ([group])</H5>
<P class="docText">The index of the end of the target substring matched by the MatchObject. If the argument <TT>group</TT> is specified, return the ending index of that specific enumerated group. Otherwise, return the ending index of group 0 (i.e., the whole match). If <TT>group</TT> exists but is the part of an alternation operator that is not used in the current match, return -1. If <span class="docEmphasis"><TT>re.search.end()</TT></span> returns the same non-negative value as <span class="docEmphasis"><TT>re.search.start()</TT> ,</span> then <TT>group</TT> is a zero-width substring.</P>
<pre>
&gt;&gt;&gt; import re
&gt;&gt;&gt; m = re.search('(\w+)((\d*)| )(\w+)','The Cat in the Hat')
&gt;&gt;&gt; m.groups()
('The', ' ', None, 'Cat')
&gt;&gt;&gt; m.start(0), m.start(1), m.start(2), m.start(3), m.start(4)
(0, 0, 3, -1, 4)
</pre>
<A NAME="ch03lev4sec80"></A><H5 class="docSection4Title"> re.match.string, re.search.string</H5>
<P class="docText">The target string in which the match occurs.</P>
<pre>
&gt;&gt;&gt; import re
&gt;&gt;&gt; m = re.search('a','The Cat in the Hat')
&gt;&gt;&gt; m.string
'The Cat in the Hat'
</pre>
<A NAME="ch03lev3sec11"></A><H5 class="docSection3Title"> EXCEPTIONS</H5>
<A NAME="ch03lev4sec81"></A><H5 class="docSection4Title"> re.error</H5>
<P class="docText">Exception raised when an invalid regular expression string is passed to a function that would produce a compiled regular expression (including implicitly).</P>
<ul></ul></td></tr></table>
<td></td>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<td class="tt1"><a href="NFO/lib.html">[ Team LiB ]</a></td><td valign="top" class="tt1" align="right">
          <a href="0321112547_ch03lev1sec2.html"><img src="FILES/btn_prev.gif" width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a>
          <a href="0321112547_ch04.html"><img src="FILES/btn_next.gif" width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a>
</td></table>
</body></html>
