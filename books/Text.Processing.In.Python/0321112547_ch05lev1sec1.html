<html><head>
<META http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<!--SafClassName="docSection1Title"--><!--SafTocEntry="5.1 Working with Email and Newsgroups"-->
<link rel="STYLESHEET" type="text/css" href="FILES/style.css">
<link rel="STYLESHEET" type="text/css" href="FILES/docsafari.css">
<style type="text/css">	.tt1    {font-size: 10pt;}</style>
</head>
<body>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<td class="tt1"><a href="NFO/lib.html">[ Team LiB ]</a></td><td valign="top" class="tt1" align="right">
	<a href="0321112547_ch05.html"><img src="FILES/btn_prev.gif" width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a>
	<a href="0321112547_ch05lev1sec2.html"><img src="FILES/btn_next.gif" width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a>
</td></table>
<br>
<table width="100%" border="0" cellspacing="0" cellpadding="0"><tr><td valign="top"><A NAME="ch05lev1sec1"></A><H3 class="docSection1Title">5.1 Working with Email and Newsgroups</H3>
<P class="docText">Python provides extensive support in its standard library for working with email (and newsgroup) messages. There are three general aspects to working with email, each supported by one or more Python modules.</P>
<span style="font-weight:bold"><OL class="docList" TYPE="1"><LI><span style="font-weight:normal"><P class="docList">Communicating with network servers to actually transmit and receive messages. The modules <span class="docEmphasis"><TT>poplib</TT>, <TT>imaplib</TT>, <TT>smtplib</TT></span>, and <span class="docEmphasis"><TT>nntplib</TT></span> each address the protocol contained in its name. These tasks do not have a lot to do with text processing per se, but are often important for applications that deal with email. The discussion of each of these modules is incomplete, addressing only those methods necessary to conduct basic transactions in the case of the first three modules/protocols. The module <span class="docEmphasis"><TT>nntplib</TT></span> is not documented here under the assumption that email is more likely to be automatically processed than are Usenet articles. Indeed, robot newsgroup posters are almost always frowned upon, while automated mailing is frequently desirable (within limits).</P></span></LI><LI><span style="font-weight:normal"><P class="docList">Examining the contents of message folders. Various email and news clients store messages in a variety of formats, many providing hierarchical and structured folders. The module <span class="docEmphasis"><TT>mailbox</TT></span> provides a uniform API for reading the messages stored in all the most popular folder formats. In a way, <span class="docEmphasis"><TT>imaplib</TT></span> serves an overlapping purpose, insofar as an IMAP4 server can also structure folders, but folder manipulation with IMAP4 is discussed only cursorily듮hat topic also falls afield of text processing. However, local mailbox folders are definitely text formats, and <span class="docEmphasis"><TT>mailbox</TT></span> makes manipulating them a lot easier.</P></span></LI><LI><span style="font-weight:normal"><P class="docList">The core text processing task in working with email is parsing, modifying, and creating the actual messages. RFC-822 describes a format for email messages and is the lingua franca for Internet communication. Not every Mail User Agent (MUA) and Mail Transport Agent (MTA) strictly conforms to the RFC-822 (and superset/clarification RFC-2822) standard득ut they all generally try to do so. The newer <span class="docEmphasis"><TT>email</TT></span> package and the older <span class="docEmphasis"><TT>rfc822</TT>, <TT>rfc1822</TT>, <TT>mimify</TT>, <TT>mimetools</TT>, <TT>MimeWriter</TT></span>, and <span class="docEmphasis"><TT>multifile</TT></span> modules all deal with parsing and processing email messages.</P></span></LI></OL></span>
<P class="docText">Although existing applications are likely to use <span class="docEmphasis"><TT>rfc822</TT>, <TT>mimify</TT>, <TT>mimetools</TT>, <TT>MimeWriter</TT></span>, and <span class="docEmphasis"><TT>multifile</TT></span>, the package <span class="docEmphasis"><TT>email</TT></span> contains more up-to-date and better-designed implementations of the same capabilities. The former modules are discussed only in synopsis while the various subpackages of <span class="docEmphasis"><TT>email</TT></span> are documented in detail.</P>
<P class="docText">There is one aspect of working with email that all good-hearted people wish was unnecessary. Unfortunately, in the real-world, a large percentage of email is spam, viruses, and frauds; any application that works with collections of messages practically demands a way to filter out the junk messages. While this topic generally falls outside the scope of this discussion, readers might benefit from my article, "Spam Filtering Techniques," at:</P>
<BLOCKQUOTE><P><P class="docList"><TT>&lt;</TT><A class="docLink" target="_blank" HREF="http://gnosis.cx/publish/programming/filtering-spam.html">http://gnosis.cx/publish/programming/filtering-spam.html</A><TT>&gt;</TT></P></P></BLOCKQUOTE>
<P class="docText">A flexible Python project for statistical analysis of message corpora, based on naive Bayesian and related models, is SpamBayes:</P>
<BLOCKQUOTE><P><P class="docList"><TT>&lt;</TT><A class="docLink" target="_blank" HREF="http://spambayes.sourceforge.net/default.htm">http://spambayes.sourceforge.net/</A><TT>&gt;</TT></P></P></BLOCKQUOTE>
<A NAME="ch05lev2sec1"></A><H4 class="docSection2Title">5.1.1 Manipulating and Creating Message Texts</H4>
<P><A NAME="ch05sb01"></A><TABLE CELLSPACING="0" WIDTH="90%" BORDER="1"><TR><TD>
<P class="docText"><span class="docEmphStrong">email </span>&#8226; <span class="docEmphStrong">Work with email messages</span></P></TD></TR></TABLE></P>
<P class="docText">Without repeating the whole of RFC-2822, it is worth mentioning the basic structure of an email or newsgroup message. Messages may themselves be stored in larger text files that impose larger-level structure, but here we are concerned with the structure of a single message. An RFC-2822 message, like most Internet protocols, has a textual format, often restricted to true 7-bit ASCII.</P>
<P class="docText">A message consists of a header and a body. A body in turn can contain one or more "payloads." In fact, MIME <TT>multipart/*</TT> type payloads can themselves contain nested payloads, but such nesting is comparatively unusual in practice. In textual terms, each payload in a body is divided by a simple, but fairly long, delimiter; however, the delimiter is pseudo-random, and you need to examine the header to find it. A given payload can either contain text or binary data using base64, quoted printable, or another ASCII encoding (even 8-bit, which is not generally safe across the Internet). Text payloads may either have MIME type <TT>text/*</TT> or compose the whole of a message body (without any payload delimiter).</P>
<P class="docText">An RFC-2822 header consists of a series of fields. Each field name begins at the beginning of a line and is followed by a colon and a space. The field value comes after the field name, starting on the same line, but potentially spanning subsequence lines. A continued field value cannot be left aligned, but must instead be indented with at least one space or tab. There are some moderately complicated rules about when field contents can split between lines, often dependent upon the particular type of value a field holds. Most field names occur only once in a header (or not at all), and in those cases their order of occurrence is not important to email or news applications. However, a few field names듩otably <TT>Received</TT>듮ypically occur multiple times and in a significant order. Complicating headers further, field values can contain encoded strings from outside the ASCII character set.</P>
<P class="docText">The most important element of the <span class="docEmphasis"><TT>email</TT></span> package is the class <span class="docEmphasis"><TT>email.Message.Message</TT></span>, whose instances provide a data structure and convenience methods suited to the generic structure of RFC-2822 messages. Various capabilities for dealing with different parts of a message, and for parsing a whole message into an <span class="docEmphasis"><TT>email.Message.Message</TT></span> object, are contained in subpackages of the <span class="docEmphasis"><TT>email</TT></span> package. Some of the most common facilities are wrapped in convenience functions in the top-level namespace.</P>
<P class="docText">A version of the <span class="docEmphasis"><TT>email</TT></span> package was introduced into the standard library with Python 2.1. However, <span class="docEmphasis"><TT>email</TT></span> has been independently upgraded and developed between Python releases. At the time this chapter was written, the current release of <span class="docEmphasis"><TT>email</TT></span> was 2.4.3, and this discussion reflects that version (and those API details that the author thinks are most likely to remain consistent in later versions). I recommend that, rather than simply use the version accompanying your Python installation, you download the latest version of the <span class="docEmphasis"><TT>email</TT></span> package from <TT>&lt;</TT><A class="docLink" target="_blank" HREF="http://mimelib.sourceforge.net/default.htm">http://mimelib.sourceforge.net</A><TT>&gt;</TT> if you intend to use this package. The current (and expected future) version of the <span class="docEmphasis"><TT>email</TT></span> package is directly compatible with Python versions back to 2.1. See this book's Web site, <TT>&lt;</TT><A class="docLink" target="_blank" HREF="http://gnosis.cx/TPiP/default.htm">http://gnosis.cx/TPiP/</A><TT>&gt;</TT>, for instructions on using <span class="docEmphasis"><TT>email</TT></span> with Python 2.0. The package is incompatible with versions of Python before 2.0.</P>
<A NAME="ch05lev3sec1"></A><H5 class="docSection3Title"> CLASSES</H5>
<P class="docText">Several children of <span class="docEmphasis"><TT>email.Message.Message</TT></span> allow you to easily construct message objects with special properties and convenient initialization arguments. Each such class is technically contained in a module named in the same way as the class rather than directly in the <span class="docEmphasis"><TT>email</TT></span> namespace, but each is very similar to the others.</P>
<A NAME="ch05lev4sec1"></A><H5 class="docSection4Title"> email.MIMEBase.MIMEBase(maintype, subtype, **params)</H5>
<P class="docText">Construct a message object with a <TT>Content-Type</TT> header already built. Generally this class is used only as a parent for further subclasses, but you may use it directly if you wish:</P>
<pre>
&gt;&gt;&gt; mess = email.MIMEBase.MIMEBase('text','html',charset='us-ascii')
&gt;&gt;&gt; print mess
From nobody Tue Nov 12 03:32:33 2002
Content-Type: text/html; charset="us-ascii"
MIME-Version: 1.0
</pre>
<A NAME="ch05lev4sec2"></A><H5 class="docSection4Title"> email.MIMENonMultipart.MIMENonMultipart(maintype, subtype, **params)</H5>
<P class="docText">Child of <span class="docEmphasis"><TT>email.MIMEBase.MIMEBase</TT></span>, but raises <TT>MultipartConversionError</TT> on calls to .<TT>attach()</TT>. Generally this class is used for further subclassing.</P>
<A NAME="ch05lev4sec3"></A><H5 class="docSection4Title"> email.MIMEMultipart.MIMEMultipart([subtype="mixed" [boundary, [,*subparts [,**params]]]])</H5>
<P class="docText">Construct a multipart message object with subtype <TT>subtype</TT>. You may optionally specify a boundary with the argument <TT>boundary</TT>, but specifying <TT>None will</TT> cause a unique boundary to be calculated. If you wish to populate the message with payload object, specify them as additional arguments. Keyword arguments are taken as parameters to the <TT>Content-Type</TT> header.</P>
<pre>
&gt;&gt;&gt; from email.MIMEBase import MIMEBase
&gt;&gt;&gt; from email.MIMEMultipart import MIMEMultipart
&gt;&gt;&gt; mess = MIMEBase('audio','midi')
&gt;&gt;&gt; combo = MIMEMultipart('mixed', None, mess, charset='utf-8')
&gt;&gt;&gt; print combo
From nobody Tue Nov 12 03:50:50 2002
Content-Type: multipart/mixed; charset="utf-8";
        boundary="===============5954819931142521=="
MIME-Version: 1.0

--===============5954819931142521==
Content-Type: audio/midi
MIME-Version: 1.0

--===============5954819931142521==--
</pre>
<A NAME="ch05lev4sec4"></A><H5 class="docSection4Title"> email.MIMEAudio.MIMEAudio(audiodata [,subtype [,encoder [,**params]]])</H5>
<P class="docText">Construct a single part message object that holds audio data. The audio data stream is specified as a string in the argument <TT>audiodata</TT>. The Python standard library module <span class="docEmphasis"><TT>sndhdr</TT></span> is used to detect the signature of the audio subtype, but you may explicitly specify the argument <TT>subtype</TT> instead. An encoder other than base64 may be specified with the <TT>encoder</TT> argument (but usually should not be). Keyword arguments are taken as parameters to the <TT>Content-Type</TT> header.</P>
<pre>
&gt;&gt;&gt; from email.MIMEAudio import MIMEAudio
&gt;&gt;&gt; mess = MIMEAudio(open('melody.midi').read())
</pre>
<p class="docText"><span class="docEmphRoman">S<span class="docEmphSmaller">EE</span> A<span class="docEmphSmaller">LSO</span></span>: 
sndhdr <span class="docEmphasis">397</span>;</p>
<A NAME="ch05lev4sec5"></A><H5 class="docSection4Title"> email.MIMEImage.MIMEImage(imagedata [,subtype [,encoder [,**params]]])</H5>
<P class="docText">Construct a single part message object that holds image data. The image data is specified as a string in the argument <TT>imagedata</TT>. The Python standard library module <span class="docEmphasis"><TT>imghdr</TT></span> is used to detect the signature of the image subtype, but you may explicitly specify the argument <TT>subtype</TT> instead. An encoder other than base64 may be specified with the <TT>encoder</TT> argument (but usually should not be). Keyword arguments are taken as parameters to the <TT>Content-Type</TT> header.</P>
<pre>
&gt;&gt;&gt; from email.MIMEImage import MIMEImage
&gt;&gt;&gt; mess = MIMEImage(open('landscape.png').read())
</pre>
<p class="docText"><span class="docEmphRoman">S<span class="docEmphSmaller">EE</span> A<span class="docEmphSmaller">LSO</span></span>: 
imghdr <span class="docEmphasis">396</span>;</p>
<A NAME="ch05lev4sec6"></A><H5 class="docSection4Title"> email.MIMEText.MIMEText(text [,subtype [,charset]])</H5>
<P class="docText">Construct a single part message object that holds text data. The data is specified as a string in the argument <TT>text</TT>. A character set may be specified in the <TT>charset</TT> argument:</P>
<pre>
&gt;&gt;&gt; from email.MIMEText import MIMEText
&gt;&gt;&gt; mess = MIMEText(open('TPiP.tex').read(),'latex')
</pre>
<A NAME="ch05lev3sec2"></A><H5 class="docSection3Title"> FUNCTIONS</H5>
<A NAME="ch05lev4sec7"></A><H5 class="docSection4Title"> email.message_from_file(file [,_class=email.Message.Message [,strict=0]])</H5>
<P class="docText">Return a message object based on the message text contained in the file-like object <TT>file</TT>. This function call is exactly equivalent to:</P>
<pre>
email.Parser.Parser(_class, strict).parse(file)
</pre>
<p class="docText"><span class="docEmphRoman">S<span class="docEmphSmaller">EE</span> A<span class="docEmphSmaller">LSO</span></span>: 
email.Parser.Parser.parse() <span class="docEmphasis">363</span>;</p>
<A NAME="ch05lev4sec8"></A><H5 class="docSection4Title"> email.message_from_string(s [,_class=email.Message.Message [,strict=0]])</H5>
<P class="docText">Return a message object based on the message text contained in the string <TT>s</TT>. This function call is exactly equivalent to:</P>
<pre>
email.Parser.Parser(_class, strict).parsestr(file)
</pre>
<p class="docText"><span class="docEmphRoman">S<span class="docEmphSmaller">EE</span> A<span class="docEmphSmaller">LSO</span></span>: 
email.Parser.Parser.parsestr() <span class="docEmphasis">363</span>;</p>
<P><A NAME="ch05sb02"></A><TABLE CELLSPACING="0" WIDTH="90%" BORDER="1"><TR><TD>
<P class="docText"><span class="docEmphStrong">email.Encoders</span> &#8226; <span class="docEmphStrong">Encoding message payloads</span></P></TD></TR></TABLE></P>
<P class="docText">The module <span class="docEmphasis"><TT>email.Encoder</TT></span> contains several functions to encode message bodies of single part message objects. Each of these functions sets the <TT>Content-Transfer-Encoding</TT> header to an appropriate value after encoding the body. The <TT>decode</TT> argument of the <TT>.get_payload()</TT> message method can be used to retrieve unencoded text bodies.</P>
<A NAME="ch05lev3sec3"></A><H5 class="docSection3Title"> FUNCTIONS</H5>
<A NAME="ch05lev4sec9"></A><H5 class="docSection4Title"> email.Encoders.encode_quopri(mess)</H5>
<P class="docText">Encode the message body of message object <TT>mess</TT> using quoted printable encoding. Also sets the header <TT>Content-Transfer-Encoding</TT>.</P>
<A NAME="ch05lev4sec10"></A><H5 class="docSection4Title"> email.Encoders.encode_base64(mess)</H5>
<P class="docText">Encode the message body of message object <TT>mess</TT> using base64 encoding. Also sets the header <TT>Content-Transfer-Encoding</TT>.</P>
<A NAME="ch05lev4sec11"></A><H5 class="docSection4Title"> email.Encoders.encode_7or8bit(mess)</H5>
<P class="docText">Set the <TT>Content-Transfer-Encoding</TT> to <TT>7bit</TT> or <TT>8bit</TT> based on the message payload; does not modify the payload itself. If message <TT>mess</TT> already has a <TT>Content-Transfer-Encoding</TT> header, calling this will create a second one들t is probably best to delete the old one before calling this function.</P>
<p class="docText"><span class="docEmphRoman">S<span class="docEmphSmaller">EE</span> A<span class="docEmphSmaller">LSO</span></span>: 
email.Message.Message.get_payload() <span class="docEmphasis">360</span>; quopri <span class="docEmphasis">162</span>; base64 <span class="docEmphasis">158</span>;</p>
<P><A NAME="ch05sb03"></A><TABLE CELLSPACING="0" WIDTH="90%" BORDER="1"><TR><TD>
<P class="docText"><span class="docEmphStrong">email.Errors </span>&#8226; <span class="docEmphStrong">Exceptions for [email] package</span></P></TD></TR></TABLE></P>
<P class="docText">Exceptions within the <span class="docEmphasis"><TT>email</TT></span> package will raise specific errors and may be caught at the desired level of generality. The exception hierarchy of <span class="docEmphasis"><TT>email.Errors</TT></span> is shown in <A class="docLink" HREF="#ch05fig01">Figure 5.1</A>.</P>
<CENTER><H5 class="docFigureTitle"><A NAME="ch05fig01"></A>Figure 5.1. Standard email.Errors exceptions</H5>
<p class="docText"><IMG BORDER="0" WIDTH="500" HEIGHT="114" src="FILES/05fig01.gif" ALT="graphics/05fig01.gif"></p></CENTER>
<p class="docText"><span class="docEmphRoman">S<span class="docEmphSmaller">EE</span> A<span class="docEmphSmaller">LSO</span></span>: 
exceptions <span class="docEmphasis">44</span><TT>;</TT></p>
<P><A NAME="ch05sb04"></A><TABLE CELLSPACING="0" WIDTH="90%" BORDER="1"><TR><TD>
<P class="docText"><span class="docEmphStrong">email.Generator &#8226; Create text representation of messages</span></P></TD></TR></TABLE></P>
<P class="docText">The module <span class="docEmphasis"><TT>email.Generator</TT></span> provides support for the serialization of <span class="docEmphasis"><TT>email.Message.Message</TT></span> objects. In principle, you could create other tools to output message objects to specialized formats듡or example, you might use the fields of an <span class="docEmphasis"><TT>email.Message.Message</TT></span> object to store values to an XML format or to an RDBMS. But in practice, you almost always want to write message objects to standards-compliant RFC-2822 message texts. Several of the methods of <span class="docEmphasis"><TT>email.Message.Message</TT></span> automatically utilize <span class="docEmphasis"><TT>email.Generator</TT></span>.</P>
<A NAME="ch05lev3sec4"></A><H5 class="docSection3Title"> CLASSES</H5>
<A NAME="ch05lev4sec12"></A><H5 class="docSection4Title"> email.Generator.Generator(file [,mangle_from_=l [,maxheaderlen=78]])</H5>
<P class="docText">Construct a generator instance that writes to the file-like object <TT>file</TT>. If the argument <TT>mangle_from_</TT> is specified as a true value, any occurrence of a line in the body that begins with the string <TT>From</TT> followed by a space is prepended with <TT>&gt;</TT>. This (non-reversible) transformation prevents BSD mailboxes from being parsed incorrectly. The argument <TT>maxheaderlen</TT> specifies where long headers will be split into multiple lines (if such is possible).</P>
<A NAME="ch05lev4sec13"></A><H5 class="docSection4Title"> email.Generator.DecodedGenerator(file [,mangle_from_ [,maxheaderlen [,fmt]]])</H5>
<P class="docText">Construct a generator instance that writes RFC-2822 messages. This class has the same initializers as its parent <span class="docEmphasis"><TT>email.Generator.Generator</TT></span>, with the addition of an optional argument <TT>fmt</TT>.</P>
<P class="docText">The class <span class="docEmphasis"><TT>email.Generator.DecodedGenerator</TT></span> only writes out the contents of <TT>text/*</TT> parts of a multipart message payload. Nontext parts are replaced with the string <TT>fmt</TT>, which may contain keyword replacement values. For example, the default value of <TT>fmt</TT> is:</P>
<pre>
[Non-text (%(type)s) part of message omitted, filename %(filename)s]
</pre>
<P class="docText">Any of the keywords <TT>type</TT>, <TT>maintype</TT>, <TT>subtype</TT>, <TT>filename</TT>, description, or <TT>encoding</TT> may be used as keyword replacements in the string <TT>fmt</TT>. If any of these values is undefined by the payload, a simple description of its unavailability is substituted.</P>
<A NAME="ch05lev3sec5"></A><H5 class="docSection3Title"> METHODS</H5>
<A NAME="ch05lev4sec14"></A><H5 class="docSection4Title"> email.Generator.Generator.clone()<br>email.Generator.DecodedGenerator.clone()</H5>
<P class="docText">Return a copy of the instance with the same options.</P>
<A NAME="ch05lev4sec15"></A><H5 class="docSection4Title"> email.Generator.Generator.flatten(mess [,unixfrom=0])<br>email.Generator.DecodedGenerator.flatten(mess [,unixfrom=0])</H5>
<P class="docText">Write an RFC-2822 serialization of message object <TT>mess</TT> to the file-like object the instance was initialized with. If the argument <TT>unixfrom</TT> is specified as a true value, the BSD mailbox <TT>From</TT>_ header is included in the serialization.</P>
<A NAME="ch05lev4sec16"></A><H5 class="docSection4Title"> email.Generator.Generator.write(s)<br>email.Generator.DecodedGenerator.write(s)</H5>
<P class="docText">Write the string s to the file-like object the instance was initialized with. This lets a generator object itself act in a file-like manner, as an implementation convenience.</P>
<p class="docText"><span class="docEmphRoman">S<span class="docEmphSmaller">EE</span> A<span class="docEmphSmaller">LSO</span></span>: 
email.Message <span class="docEmphasis">355</span>; mailbox <span class="docEmphasis">372</span>;</p>
<P><A NAME="ch05sb05"></A><TABLE CELLSPACING="0" WIDTH="90%" BORDER="1"><TR><TD>
<P class="docText"><span class="docEmphStrong">email.Header &#8226; Manage headers with non-</span><span class="docEmphStrong">ASCII</span> <span class="docEmphStrong">values</span></P></TD></TR></TABLE></P>
<P class="docText">The module <span class="docEmphasis"><TT>email.Charset</TT></span> provides fine-tuned capabilities for managing character set conversions and maintaining a character set registry. The much higher-level interface provided by <span class="docEmphasis"><TT>email.Header</TT></span> provides all the capabilities that almost all users need in a friendlier form.</P>
<P class="docText">The basic reason why you might want to use the <span class="docEmphasis"><TT>email.Header</TT></span> module is because you want to encode multinational (or at least non-US) strings in email headers. Message bodies are somewhat more lenient than headers, but RFC-2822 headers are still restricted to using only 7-bit ASCII to encode other character sets. The module <span class="docEmphasis"><TT>email.Header</TT></span> provides a single class and two convenience functions. The encoding of non-ASCII characters in email headers is described in a number of RFCs, including RFC-2045, RFC-2046, RFC-2047, and most directly RFC-2231.</P>
<A NAME="ch05lev3sec6"></A><H5 class="docSection3Title"> CLASSES</H5>
<A NAME="ch05lev4sec17"></A><H5 class="docSection4Title"> email.Header.Header([s="" [,charset [,maxlinelen=76 [,header_name=""[,continuation_ws=" "]]]]])</H5>
<P class="docText">Construct an object that holds the string or Unicode string <TT>s</TT>. You may specify an optional <TT>charset</TT> to use in encoding <TT>s;</TT> absent any argument, either <TT>us-ascii</TT> or <TT>utf-8</TT> will be used, as needed.</P>
<P class="docText">Since the encoded string is intended to be used as an email header, it may be desirable to wrap the string to multiple lines (depending on its length). The argument <TT>maxlinelen</TT> specifies where the wrapping will occur; <TT>header_name</TT> is the name of the header you anticipate using the encoded string with들t is significant only for its length. Without a specified <TT>header_name</TT>, no width is set aside for the header field itself. The argument <TT>continuation_ws</TT> specified what whitespace string should be used to indent continuation lines; it must be a combination of spaces and tabs.</P>
<P class="docText">Instances of the class <span class="docEmphasis"><TT>email.Header.Header</TT></span> implement a .<TT>__str__()</TT> method and therefore respond to the built-in <span class="docEmphasis"><TT>str()</TT></span> function and the <span class="docEmphasis"><TT>print</TT></span> command. Normally the built-in techniques are more natural, but the method <span class="docEmphasis"><TT>email.Header.Header.encode()</TT></span> performs an identical action. As an example, let us first build a non-ASCII string:</P>
<pre>
&gt;&gt;&gt; from unicodedata import lookup
&gt;&gt;&gt; lquot = lookup("LEFT-POINTING DOUBLE ANGLE QUOTATION MARK")
&gt;&gt;&gt; rquot = lookup("RIGHT-POINTING DOUBLE ANGLE QUOTATION MARK")
&gt;&gt;&gt; s = lquot + "Euro-style" + rquot + " quotation"
&gt;&gt;&gt; s
u'\xabEuro-style\xbb quotation'
&gt;&gt;&gt; print s.encode('iso-8859-1')
Euro-style quotation
</pre>
<P class="docText">Using the string <TT>s</TT>, let us encode it for an RFC-2822 header:</P>
<pre>
&gt;&gt;&gt; from email.Header import Header
&gt;&gt;&gt; print Header(s)
=?utf-8?q?=C2=ABEuro-style=C2=BB_quotation?=
&gt;&gt;&gt; print Header(s,'iso-8859-1')
=?iso-8859-1?q?=ABEuro-style=BB_quotation?=
&gt;&gt;&gt; print Header(s, 'utf-16')
=?utf-16?b?/v8AqwBFAHUAcgBvACOAcwBOAHkAbABl?=
 =?utf-16?b?/v8AuwAgAHEAdQBvAHQAYQBOAGkAbwBu?=
&gt;&gt;&gt; print Header(s,'us-ascii')
=?utf-8?q?=C2=ABEuro-style=C2=BB_quotation?=
</pre>
<P class="docText">Notice that in the last case, the <span class="docEmphasis"><TT>email.Header.Header</TT></span> initializer did not take too seriously my request for an ASCII character set, since it was not adequate to represent the string. However, the class is happy to skip the encoding strings where they are not needed:</P>
<pre>
&gt;&gt;&gt; print Header('"US-style" quotation')
"US-style" quotation
&gt;&gt;&gt; print Header('"US-style" quotation','utf-8')
=?utf-8?q?=22US-style=22_quotation?=
&gt;&gt;&gt; print Header('"US-style" quotation','us-ascii')
"US-style" quotation
</pre>
<A NAME="ch05lev3sec7"></A><H5 class="docSection3Title"> METHODS</H5>
<A NAME="ch05lev4sec18"></A><H5 class="docSection4Title"> email.Header.Header.append(s [,charset])</H5>
<P class="docText">Add the string or Unicode string s to the end of the current instance content, using character set <TT>charset</TT>. Note that the charset of the added text need not be the same as that of the existing content.</P>
<pre>
&gt;&gt;&gt; subj = Header(s,'latin-1',65)
&gt;&gt;&gt; print subj
=?iso-8859-1?q?=ABEuro-style=BB_quotation?=
&gt;&gt;&gt; unicodedata.name(omega), unicodedata.name(Omega)
('GREEK SMALL LETTER OMEGA', 'GREEK CAPITAL LETTER OMEGA')
&gt;&gt;&gt; subj.append(', Greek: ', 'us-ascii')
&gt;&gt;&gt; subj.append(Omega, 'utf-8')
&gt;&gt;&gt; subj.append(omega, 'utf-16')
&gt;&gt;&gt; print subj
=?iso-8859-1?q?=ABEuro-style=BB_quotation?=, Greek:
 =?utf-8?b?zqk=?= =?utf-16?b?/v8DyQ==?=
 &gt;&gt;&gt; unicode(subj)
 u'\xabEuro-style\xbb quotation, Greek: \u03a9\u03c9'
</pre>
<A NAME="ch05lev4sec19"></A><H5 class="docSection4Title"> email.Header.Header.encode()<br>email.Header.Header.__str__()</H5>
<P class="docText">Return an ASCII string representation of the instance content.</P>
<A NAME="ch05lev3sec8"></A><H5 class="docSection3Title"> FUNCTIONS</H5>
<A NAME="ch05lev4sec20"></A><H5 class="docSection4Title"> email.Header.decode_header(header)</H5>
<P class="docText">Return a list of pairs describing the components of the RFC-2231 string held in the header object <TT>header</TT>. Each pair in the list contains a Python string (not Unicode) and an encoding name.</P>
<pre>
&gt;&gt;&gt; email.Header.decode_header(Header('spam and eggs'))
[('spam and eggs', None)]
&gt;&gt;&gt; print subj
=?iso-8859-1?q?=ABEuro-style=BB_quotation?=, Greek:
 =?utf-8?b?zqk=?= =?utf-16?b?/v8DyQ==?=
&gt;&gt;&gt; for tup in email.Header.decode_header(subj): print tup
...
('\xabEuro-style\xbb quotation', 'iso-8859-1')
(', Greek:', None)
('\xce\xa9', 'utf-8')
('\xfe\xff\x03\xc9', 'utf-16')
</pre>
<P class="docText">These pairs may be used to construct Unicode strings using the built-in <span class="docEmphasis"><TT>unicode()</TT></span> function. However, plain ASCII strings show an encoding of <TT>None</TT>, which is not acceptable to the <span class="docEmphasis"><TT>unicode()</TT></span> function.</P>
<pre>
&gt;&gt;&gt; for s,enc in email.Header.decode_header(subj):
...     enc = enc or 'us-ascii'
...     print `unicode(s, enc)'
...
u'\xabEuro-style\xbb quotation'
u', Greek:'
u'\u03a9'
u'\u03c9'
</pre>
<p class="docText"><span class="docEmphRoman">S<span class="docEmphSmaller">EE</span> A<span class="docEmphSmaller">LSO</span></span>: 
unicode() <span class="docEmphasis">423</span>; email.Header.make_header() <span class="docEmphasis">354</span>;</p>
<A NAME="ch05lev4sec21"></A><H5 class="docSection4Title"> email.Header.make_header(decoded_seq [,maxlinelen [,header_name [,continuation_ws]]])</H5>
<P class="docText">Construct a header object from a list of pairs of the type returned by the function <span class="docEmphasis"><TT>email.Header.decode-header()</TT></span>. You may also, of course, easily construct the list <TT>decoded_seq</TT> manually, or by other means. The three arguments <TT>maxlinelen</TT>, <TT>header_name</TT>, and <TT>continuation_ws</TT> are the same as with the <span class="docEmphasis"><TT>email.Header.Header</TT></span> class.</P>
<pre>
&gt;&gt;&gt; email.Header.make.header([('\xce\xa9','utf-8'),
...                           ('-man','us-ascii')]).encode()
'=?utf-8?b?zqk=?=-man'
</pre>
<p class="docText"><span class="docEmphRoman">S<span class="docEmphSmaller">EE</span> A<span class="docEmphSmaller">LSO</span></span>: 
email.Header.decode_header() <span class="docEmphasis">353</span>; email.Header.Header <span class="docEmphasis">351</span>;</p>
<P><A NAME="ch05sb06"></A><TABLE CELLSPACING="0" WIDTH="90%" BORDER="1"><TR><TD>
<P class="docText"><span class="docEmphStrong">email.Iterators &#8226; Iterate through components of messages</span></P></TD></TR></TABLE></P>
<P class="docText">The module <span class="docEmphasis"><TT>email.Iterators</TT></span> provides several convenience functions to walk through messages in ways different from <span class="docEmphasis"><TT>email.Message.Message.get_payload()</TT></span> or <span class="docEmphasis"><TT>email.Message.Message.walk()</TT></span>.</P>
<A NAME="ch05lev3sec9"></A><H5 class="docSection3Title"> FUNCTIONS</H5>
<A NAME="ch05lev4sec22"></A><H5 class="docSection4Title"> email.Iterators.body_line_iterator(mess)</H5>
<P class="docText">Return a generator object that iterates through each content line of the message object <TT>mess</TT>. The entire body that would be produced by <TT>str(mess)</TT> is reached, regardless of the content types and nesting of parts. But any MIME delimiters are omitted from the returned lines.</P>
<pre>
&gt;&gt;&gt; import email.MIMEText, email.Iterators
&gt;&gt;&gt; mess1 = email.MIMEText.MIMEText('message one')
&gt;&gt;&gt; mess2 = email.MIMEText.MIMEText('message two')
&gt;&gt;&gt; combo = email.Message.Message()
&gt;&gt;&gt; combo.set_type('multipart/mixed')
&gt;&gt;&gt; combo.attach(mess1)
&gt;&gt;&gt; combo.attach(mess2)
&gt;&gt;&gt; for line in email.Iterators.body_line_iterator(combo):
...     print line
...
message one
message two
</pre>
<A NAME="ch05lev4sec23"></A><H5 class="docSection4Title"> email.Iterators.typed_subpart_iterator(mess [,maintype="text" [,subtype]])</H5>
<P class="docText">Return a generator object that iterates through each subpart of message whose type matches <TT>maintype</TT>. If a subtype <TT>subtype</TT> is specified, the match is further restricted to <TT>maintype/subtype</TT>.</P>
<A NAME="ch05lev4sec24"></A><H5 class="docSection4Title"> email.Iterators._structure(mess [,file=sys.stdout])</H5>
<P class="docText">Write a "pretty-printed" representation of the structure of the body of message <TT>mess</TT>. Output to the file-like object <TT>file</TT>.</P>
<pre>
&gt;&gt;&gt; email.Iterators._structure(combo)
multipart/mixed
    multipart/digest
        image/png
        text/plain
    audio/mp3
    text/html
</pre>
<p class="docText"><span class="docEmphRoman">S<span class="docEmphSmaller">EE</span> A<span class="docEmphSmaller">LSO</span></span>: 
email.Message.Message.get_payload() <span class="docEmphasis">360</span>; email.Message.Message.walk() <span class="docEmphasis">362</span>;</p>
<P><A NAME="ch05sb07"></A><TABLE CELLSPACING="0" WIDTH="90%" BORDER="1"><TR><TD>
<P class="docText"><span class="docEmphStrong">email.Message &#8226; Class representing an email message</span></P></TD></TR></TABLE></P>
<P class="docText">A message object that utilizes the <span class="docEmphasis"><TT>email.Message</TT></span> module provides a large number of syntactic conveniences and support methods for manipulating an email or news message. The class <span class="docEmphasis"><TT>email.Message.Message</TT></span> is a very good example of a customized datatype. The built-in <span class="docEmphasis"><TT>str()</TT></span> function드nd therefore also the <TT>print</TT> command듞ause a message object to produce its RFC-2822 serialization.</P>
<P class="docText">In many ways, a message object is dictionary-like. The appropriate magic methods are implemented in it to support keyed indexing and assignment, the built-in <TT>len()</TT> function, containment testing with the in keyword, and key deletion. Moreover, the methods one expects to find in a Python dict are all implemented by <span class="docEmphasis"><TT>email.Message.Message</TT></span><TT>:has_key()</TT>, <TT>.keys()</TT>, <TT>.values ()</TT>, <TT>.items()</TT>, and .<TT>get()</TT>. Some usage examples are helpful:</P>
<pre>
&gt;&gt;&gt; import mailbox, email, email.Parser
&gt;&gt;&gt; mbox = mailbox.PortableUnixMailbox(open('mbox'),
...                        email.Parser.Parser().parse)
&gt;&gt;&gt; mess = mbox.next()
&gt;&gt;&gt; len(mess)                 # number of headers
16
&gt;&gt;&gt; 'X-Status' in mess        # membership testing
1
&gt;&gt;&gt; mess.has_key('X-AGENT')   # also membership test
0
&gt;&gt;&gt; mess['x-agent'] = "Python Mail Agent"
&gt;&gt;&gt; print mess['X-AGENT']     # access by key
Python Mail Agent
&gt;&gt;&gt; del mess['X-Agent']       # delete key/val pair
&gt;&gt;&gt; print mess['X-AGENT']
None
&gt;&gt;&gt; [fld for (fld,val) in mess.items() if fld=='Received']
['Received', 'Received', 'Received', 'Received', 'Received']
</pre>
<P class="docText">This is dictionary-like behavior, but only to an extent. Keys are case-insensitive to match email header rules. Moreover, a given key may correspond to multiple values들ndexing by key will return only the first such value, but methods like .<TT>keys()</TT>, <TT>.items()</TT>, or <TT>.get_all() will</TT> return a list of all the entries. In some other ways, an <span class="docEmphasis"><TT>email.Message.Message</TT></span> object is more like a list of tuples, chiefly in guaranteeing to retain a specific order to header fields.</P>
<P class="docText">A few more details of keyed indexing should be mentioned. Assigning to a keyed field will add an <span class="docEmphasis">additional</span> header, rather than replace an existing one. In this respect, the operation is more like a <span class="docEmphasis"><TT>list.append()</TT></span> method. Deleting a keyed field, however, deletes every matching header. If you want to replace a header completely, delete first, then assign.</P>
<P class="docText">The special syntax defined by the <span class="docEmphasis"><TT>email.Message.Message</TT></span> class is all for manipulating headers. But a message object will typically also have a body with one or more payloads. If the <TT>Content-Type</TT> header contains the value <TT>multipart/*</TT>, the body should consist of zero or more payloads, each one itself a message object. For single part content types (including where none is explicitly specified), the body should contain a string, perhaps an encoded one. The message instance method <TT>.get_payload()</TT>, therefore, can return either a list of message objects or a string. Use the method <TT>.is_multipart()</TT> to determine which return type is expected.</P>
<P class="docText">As the epigram to this chapter suggests, you should strictly follow content typing rules in messages you construct yourself. But in real-world situations, you are likely to encounter messages with badly mismatched headers and bodies. Single part messages might claim to be multipart, and vice versa. Moreover, the MIME type claimed by headers is only a loose indication of what payloads actually contain. Part of the mismatch comes from spammers and virus writers trying to exploit the poor standards compliance and lax security of Microsoft applications드 malicious payload can pose as an innocuous type, and Windows will typically launch apps based on filenames instead of MIME types. But other problems arise not out of malice, but simply out of application and transport errors. Depending on the source of your processed messages, you might want to be lenient about the allowable structure and headers of messages.</P>
<p class="docText"><span class="docEmphRoman">S<span class="docEmphSmaller">EE</span> A<span class="docEmphSmaller">LSO</span></span>: 
UserDict <span class="docEmphasis">24</span>; UserList <span class="docEmphasis">28</span>;</p>
<A NAME="ch05lev3sec10"></A><H5 class="docSection3Title"> CLASSES</H5>
<A NAME="ch05lev4sec25"></A><H5 class="docSection4Title"> email.Message.Message()</H5>
<P class="docText">Construct a message object. The class accepts no initialization arguments.</P>
<A NAME="ch05lev3sec11"></A><H5 class="docSection3Title"> METHODS AND ATTRIBUTES</H5>
<A NAME="ch05lev4sec26"></A><H5 class="docSection4Title"> email.Message.Message.add_header(field, value [,**params])</H5>
<P class="docText">Add a header to the message headers. The header field is <TT>field</TT>, and its <TT>value</TT> is value.The effect is the same as keyed assignment to the object, but you may optionally include parameters using Python keyword arguments.</P>
<pre>
&gt;&gt;&gt; import email.Message
&gt;&gt;&gt; msg = email.Message.Message()
&gt;&gt;&gt; msg['Subject'] = "Report attachment"
&gt;&gt;&gt; msg.add_header('Content-Disposition','attachment',
...                 filename='report17.txt')
&gt;&gt;&gt; print msg
From nobody Mon Nov 11 15:11:43 2002
Subject: Report attachment
Content-Disposition: attachment; filename="report17.txt"
</pre>
<A NAME="ch05lev4sec27"></A><H5 class="docSection4Title"> email.Message.Message.as_string([unixfrom=0])</H5>
<P class="docText">Serialize the message to an RFC-2822-compliant text string. If the <TT>unixfrom</TT> argument is specified with a true value, include the BSD mailbox "From_" envelope header. Serialization with <span class="docEmphasis"><TT>str()</TT></span> or <span class="docEmphasis"><TT>print</TT></span> includes the "From_" envelope header.</P>
<A NAME="ch05lev4sec28"></A><H5 class="docSection4Title"> email.Message.Message.attach(mess)</H5>
<P class="docText">Add a payload to a message. The argument <TT>mess</TT> must specify an <span class="docEmphasis"><TT>email.Message.Message</TT></span> object. After this call, the payload of the message will be a list of message objects (perhaps of length one, if this is the first object added). Even though calling this method causes the method <TT>.is_multipart ()</TT> to return a true value, you still need to separately set a correct <TT>multipart/*</TT> content type for the message to serialize the object.</P>
<pre>
&gt;&gt;&gt; mess = email.Message.Message()
&gt;&gt;&gt; mess.is_multipart()
0
&gt;&gt;&gt; mess.attach(email.Message.Message())
&gt;&gt;&gt; mess. is_multipart ()
1
&gt;&gt;&gt; mess.get_payload()
[&lt;email.Message.Message instance at 0x3b2ab0&gt;]
&gt;&gt;&gt; mess.get_content_type()
'text/plain'
&gt;&gt;&gt; mess.set_type('multipart/mixed')
&gt;&gt;&gt; mess.get_content_type()
'multipart/mixed'
</pre>
<P class="docText">If you wish to create a single part payload for a message object, use the method <span class="docEmphasis"><TT>email.Message.Message.set-payload()</TT></span>.</P>
<p class="docText"><span class="docEmphRoman">S<span class="docEmphSmaller">EE</span> A<span class="docEmphSmaller">LSO</span></span>: 
email.Message.Message.set_payload() <span class="docEmphasis">362</span>;</p>
<A NAME="ch05lev4sec29"></A><H5 class="docSection4Title"> email.Message.Message.del_param(param [,header=" Content-Type" [,requote=1]])</H5>
<P class="docText">Remove the parameter <TT>param</TT> from a header. If the parameter does not exist, no action is taken, but also no exception is raised. Usually you are interested in the <TT>Content-Type</TT> header, but you may specify a different <TT>header</TT> argument to work with another one. The argument <TT>requote</TT> controls whether the parameter value is quoted (a good idea that does no harm).</P>
<pre>
&gt;&gt;&gt; mess = email.Message.Message()
&gt;&gt;&gt; mess.set_type('text/plain')
&gt;&gt;&gt; mess.set_param('charset','us-ascii')
&gt;&gt;&gt; print mess
From nobody Mon Nov 11 16:12:38 2002
MIME-Version: 1.0
Content-Type: text/plain; charset="us-ascii"

&gt;&gt;&gt; mess.del_param('charset')
&gt;&gt;&gt; print mess
From nobody Mon Nov 11 16:13:11 2002
MIME-Version: 1.0
content-type: text/plain
</pre>
<A NAME="ch05lev4sec30"></A><H5 class="docSection4Title"> email.Message.Message.epilogue</H5>
<P class="docText">Message bodies that contain MIME content delimiters can also have text that falls outside the area between the first and final delimiter. Any text at the very end of the body is stored in <span class="docEmphasis"><TT>email.Message.Message.epilogue</TT></span>.</P>
<p class="docText"><span class="docEmphRoman">S<span class="docEmphSmaller">EE</span> A<span class="docEmphSmaller">LSO</span></span>: 
email.Message.Message.preamble <span class="docEmphasis">361</span>;</p>
<A NAME="ch05lev4sec31"></A><H5 class="docSection4Title"> email.Message.Message.get_all(field [,failobj=None])</H5>
<P class="docText">Return a list of all the headers with the field name <TT>field</TT>. If no matches exist, return the value specified in argument <TT>failobj</TT>. In most cases, header fields occur just once (or not at all), but a few fields such as <TT>Received</TT> typically occur multiple times.</P>
<P class="docText">The default nonmatch return value of <TT>None</TT> is probably not the most useful choice. Returning an empty list will let you use this method in both <TT>if</TT> tests and iteration context:</P>
<pre>
&gt;&gt;&gt; for rcv in mess.get_all('Received',[]):
...     print rcv
...
About that time
A little earlier
&gt;&gt;&gt; if mess.get_all('Foo',[]):
...     print "Has Foo header(s)"
</pre>
<A NAME="ch05lev4sec32"></A><H5 class="docSection4Title"> email.Message.Message.get_boundary([failobj=None])</H5>
<P class="docText">Return the MIME message boundary delimiter for the message. Return <TT>failobj</TT> if no boundary is defined; this <span class="docEmphasis">should</span> always be the case if the message is not multipart.</P>
<A NAME="ch05lev4sec33"></A><H5 class="docSection4Title"> email.Message.Message.get_charsets([failobj=None])</H5>
<P class="docText">Return a list of string descriptions of contained character sets.</P>
<A NAME="ch05lev4sec34"></A><H5 class="docSection4Title"> email.Message.Message.get_content_charset([failobj=None])</H5>
<P class="docText">Return a string description of the message character set.</P>
<A NAME="ch05lev4sec35"></A><H5 class="docSection4Title"> email.Message.Message.get_content_maintype()</H5>
<P class="docText">For message <TT>mess</TT>, equivalent to <TT>mess.get_content_type().split ("/") [0]</TT>.</P>
<A NAME="ch05lev4sec36"></A><H5 class="docSection4Title"> email.Message.Message.get_content_subtype()</H5>
<P class="docText">For message <TT>mess</TT>, equivalent to <TT>mess.get_content_type().split ("/") [1]</TT>.</P>
<A NAME="ch05lev4sec37"></A><H5 class="docSection4Title"> email.Message.Message.get_content_type()</H5>
<P class="docText">Return the MIME content type of the message object. The return string is normalized to lowercase and contains both the type and subtype, separated by a <TT>/</TT>.</P>
<pre>
&gt;&gt;&gt; msg_photo.get_content_type()
'image/png'
&gt;&gt;&gt; msg_combo.get_content_type()
'multipart/mixed'
&gt;&gt;&gt; msg_simple.get_content_type()
'text/plain'
</pre>
<A NAME="ch05lev4sec38"></A><H5 class="docSection4Title"> email.Message.Message.get_default_type()</H5>
<P class="docText">Return the current default type of the message. The default type will be used in decoding payloads that are not accompanied by an explicit <TT>Content-Type</TT> header.</P>
<A NAME="ch05lev4sec39"></A><H5 class="docSection4Title"> email.Message.Message.get_filename([failobj=None])</H5>
<P class="docText">Return the <TT>filename</TT> parameter of the <TT>Content-Disposition</TT> header. If no such parameter exists (perhaps because no such header exists), <TT>failobj</TT> is returned instead.</P>
<A NAME="ch05lev4sec40"></A><H5 class="docSection4Title"> email.Message.Message.get_param(param [,failobj [,header=...[,unquote=1]]])</H5>
<P class="docText">Return the parameter <TT>param</TT> of the header <TT>header</TT>. By default, use the <TT>Content-Type</TT> header. If the parameter does not exist, return <TT>failobj</TT>. If the argument <TT>unquote</TT> is specified as a true value, the quote marks are removed from the parameter.</P>
<pre>
&gt;&gt;&gt; print mess.get_param('charset',unquote=l)
us-ascii
&gt;&gt;&gt; print mess.get_param('charset',unquote=0)
"us-ascii"
</pre>
<p class="docText"><span class="docEmphRoman">S<span class="docEmphSmaller">EE</span> A<span class="docEmphSmaller">LSO</span></span>: 
email.Message.Message.set_param() <span class="docEmphasis">362</span>;</p>
<A NAME="ch05lev4sec41"></A><H5 class="docSection4Title"> email.Message.Message.get_params([,failobj=None [,header=...[,unquote=1]]])</H5>
<P class="docText">Return all the parameters of the header <TT>header</TT>. By default, examine the Content-Type header. If the header does not exist, return <TT>failobj</TT> instead. The return value consists of a list of key/val pairs. The argument <TT>unquote</TT> removes extra quotes from values.</P>
<pre>
&gt;&gt;&gt; print mess.get_params(header="To")
[('&lt;mertz@gnosis.cx&gt;', '')]
&gt;&gt;&gt; print mess.get_params(unquote=0)
[('text/plain', ''), ('charset', '"us-ascii"')]
</pre>
<A NAME="ch05lev4sec42"></A><H5 class="docSection4Title"> email.Message.Message.get_payload([i [,decode=0]])</H5>
<P class="docText">Return the message payload. If the message method <TT>is_multipart()</TT> returns true, this method returns a list of component message objects. Otherwise, this method returns a string with the message body. Note that if the message object was created using <span class="docEmphasis"><TT>email.Parser.HeaderParser</TT></span>, then the body is treated as single part, even if it contains MIME delimiters.</P>
<P class="docText">Assuming that the message is multipart, you may specify the <TT>i</TT> argument to retrieve only the indexed component. Specifying the i argument is equivalent to indexing on the returned list without specifying <TT>i</TT>. If <TT>decode</TT> is specified as a true value, and the payload is single part, the returned payload is decoded (i.e., from quoted printable or base64).</P>
<P class="docText">I find that dealing with a payload that may be either a list or a text is somewhat awkward. Frequently, you would like to simply loop over all the parts of a message body, whether or not MIME multiparts are contained in it. A wrapper function can provide uniformity:</P>
<H5 class="docExampleTitle"><A NAME="ch05list01"></A> write_payload_list.py</H5>

<PRE>
#!/usr/bin/env python
"Write payload list to separate files"
import email, sys
def get_payload_list(msg, decode=l):
    payload = msg.get_payload(decode=decode)
    if type(payload) in [type(""), type(u"")]:
        return [payload]
    else:
        return payload
mess = email.message_from_file(sys.stdin)
for part,num in zip(get_payload_list(mess),range(1000)):
    file = open('%s.%d' % (sys.argv[1], num), 'w')
    print &gt;&gt; file, part
</PRE>
<p class="docText"><span class="docEmphRoman">S<span class="docEmphSmaller">EE</span> A<span class="docEmphSmaller">LSO</span></span>: 
email.Parser <span class="docEmphasis">363</span>; email.Message.Message.is_multipart() <span class="docEmphasis">361</span>; email.Message.Message.walk() <span class="docEmphasis">362</span>;</p>
<A NAME="ch05lev4sec43"></A><H5 class="docSection4Title"> email.Message.Message.get_unixfrom()</H5>
<P class="docText">Return the BSD mailbox "From_" envelope header, or <TT>None</TT> if none exists.</P>
<p class="docText"><span class="docEmphRoman">S<span class="docEmphSmaller">EE</span> A<span class="docEmphSmaller">LSO</span></span>: 
mailbox <span class="docEmphasis">372</span>;</p>
<A NAME="ch05lev4sec44"></A><H5 class="docSection4Title"> email.Message.Message.is_multipart()</H5>
<P class="docText">Return a true value if the message is multipart. Notice that the criterion for being multipart is having multiple message objects in the payload; the <TT>Content-Type</TT> header is not guaranteed to be <TT>multipart/*</TT> when this method returns a true value (but if all is well, it <span class="docEmphasis">should</span> be).</P>
<p class="docText"><span class="docEmphRoman">S<span class="docEmphSmaller">EE</span> A<span class="docEmphSmaller">LSO</span></span>: 
email.Message.Message.get_payload() <span class="docEmphasis">360</span>;</p>
<A NAME="ch05lev4sec45"></A><H5 class="docSection4Title"> email.Message.Message.preamble</H5>
<P class="docText">Message bodies that contain MIME content delimiters can also have text that falls outside the area between the first and final delimiter. Any text at the very beginning of the body is stored in <span class="docEmphasis"><TT>email.Message.Message.preamble</TT></span>.</P>
<p class="docText"><span class="docEmphRoman">S<span class="docEmphSmaller">EE</span> A<span class="docEmphSmaller">LSO</span></span>: 
email.Message.Message.epilogue <span class="docEmphasis">358</span>;</p>
<A NAME="ch05lev4sec46"></A><H5 class="docSection4Title"> email.Message.Message.replace_header(field, value)</H5>
<P class="docText">Replaces the first occurrence of the header with the name <TT>field</TT> with the value value. If no matching header is found, raise <TT>KeyError</TT>.</P>
<A NAME="ch05lev4sec47"></A><H5 class="docSection4Title"> email.Message.Message.set_boundary(s)</H5>
<P class="docText">Set the boundary parameter of the <TT>Content-Type</TT> header to s. If the message does not have a <TT>Content-Type</TT> header, raise <TT>HeaderParserError</TT>. There is generally no reason to create a boundary manually, since the <span class="docEmphasis"><TT>email</TT></span> module creates good unique boundaries on it own for multipart messages.</P>
<A NAME="ch05lev4sec48"></A><H5 class="docSection4Title"> email.Message.Message.set_default_type(ctype)</H5>
<P class="docText">Set the current default type of the message to <TT>ctype</TT>. The default type will be used in decoding payloads that are not accompanied by an explicit <TT>Content-Type</TT> header.</P>
<A NAME="ch05lev4sec49"></A><H5 class="docSection4Title"> email.Message.Message.set_param(param, value [,header=" Content-Type" [,requote=1 [,charset [,language]]]])</H5>
<P class="docText">Set the parameter <TT>param</TT> of the header <TT>header</TT> to the value <TT>value</TT>. If the argument <TT>requote</TT> is specified as a true value, the parameter is quoted. The arguments <TT>charset</TT> and <TT>language</TT> may be used to encode the parameter according to RFC-2231.</P>
<A NAME="ch05lev4sec50"></A><H5 class="docSection4Title"> email.Message.Message.set_payload(payload [,charset=None])</H5>
<P class="docText">Set the message payload to a string or to a list of message objects. This method overwrites any existing payload the message has. For messages with single part content, you must use this method to configure the message body (or use a convenience message subclass to construct the message in the first place).</P>
<p class="docText"><span class="docEmphRoman">S<span class="docEmphSmaller">EE</span> A<span class="docEmphSmaller">LSO</span></span>: 
email.Message.Message.attach() <span class="docEmphasis">357</span>; email.MIMEText.MIMEText <span class="docEmphasis">348</span>; email.MIMEImage.MIMEImage <span class="docEmphasis">348</span>; email.MIMEAudio.MIMEAudio <span class="docEmphasis">347</span>;</p>
<A NAME="ch05lev4sec51"></A><H5 class="docSection4Title"> email.Message.Message.set_type(ctype [,header="Content-Type" [,requote=1]])</H5>
<P class="docText">Set the content type of the message to <TT>ctype</TT>, leaving any parameters to the header as is. If the argument <TT>requote</TT> is specified as a true value, the parameter is quoted. You may also specify an alternative header to write the content type to, but for the life of me, I cannot think of any reason you would want to.</P>
<A NAME="ch05lev4sec52"></A><H5 class="docSection4Title"> email.Message.Message.set_unixfrom(s)</H5>
<P class="docText">Set the BSD mailbox envelope header. The argument s should include the word From and a space, usually followed by a name and a date.</P>
<p class="docText"><span class="docEmphRoman">S<span class="docEmphSmaller">EE</span> A<span class="docEmphSmaller">LSO</span></span>: 
mailbox <span class="docEmphasis">372</span>;</p>
<A NAME="ch05lev4sec53"></A><H5 class="docSection4Title"> email.Message.Message.walk()</H5>
<P class="docText">Recursively traverse all message parts and subparts of the message. The returned iterator will yield each nested message object in depth-first order.</P>
<pre>
&gt;&gt;&gt; for part in mess.walk():
...    print part.get_content_type()
multipart/mixed
text/html
audio/midi
</pre>
<p class="docText"><span class="docEmphRoman">S<span class="docEmphSmaller">EE</span> A<span class="docEmphSmaller">LSO</span></span>: 
email.Message.Message.get_payload() <span class="docEmphasis">360</span>;</p>
<P><A NAME="ch05sb08"></A><TABLE CELLSPACING="0" WIDTH="90%" BORDER="1"><TR><TD>
<P class="docText"><span class="docEmphStrong">email.Parser &#8226; Parse a text message into a message object</span></P></TD></TR></TABLE></P>
<P class="docText">There are two parsers provided by the <span class="docEmphasis"><TT>email.Parser</TT></span> module: <span class="docEmphasis"><TT>email.Parser.Parser</TT></span> and its child <span class="docEmphasis"><TT>email.Parser.HeaderParser</TT></span>. For general usage, the former is preferred, but the latter allows you to treat the body of an RFC-2822 message as an unparsed block. Skipping the parsing of message bodies can be much faster and is also more tolerant of improperly formatted message bodies (something one sees frequently, albeit mostly in spam messages that lack any content value as well).</P>
<P class="docText">The parsing methods of both classes accept an optional <TT>headersonly</TT> argument. Specifying <TT>headersonly</TT> has a stronger effect than using the <span class="docEmphasis"><TT>email.Parser.HeaderParser</TT></span> class. If <TT>headersonly</TT> is specified in the parsing methods of either class, the message body is skipped altogether듮he message object created has an entirely empty body. On the other hand, if <span class="docEmphasis"><TT>email.Parser.HeaderParser</TT></span> is used as the parser class, but <TT>headersonly </TT>is specified as false (the default), the body is always read as a single part text, even if its content type is <TT>multipart/*</TT>.</P>
<A NAME="ch05lev3sec12"></A><H5 class="docSection3Title"> CLASSES</H5>
<A NAME="ch05lev4sec54"></A><H5 class="docSection4Title"> email.Parser.Parser([_class=email.Message.Message [,strict=0]])</H5>
<P class="docText">Construct a parser instance that uses the class <TT>_class</TT> as the message object constructor. There is normally no reason to specify a different message object type. Specifying strict parsing with the <TT>strict</TT> option will cause exceptions to be raised for messages that fail to conform fully to the RFC-2822 specification. In practice, "lax" parsing is much more useful.</P>
<A NAME="ch05lev4sec55"></A><H5 class="docSection4Title"> email.Parser.HeaderParser([_class=email.Message.Message [,strict=0]])</H5>
<P class="docText">Construct a parser instance that is the same as an instance of <span class="docEmphasis"><TT>email.Parser.Parser</TT></span> except that multipart messages are parsed as if they were single part.</P>
<A NAME="ch05lev3sec13"></A><H5 class="docSection3Title"> METHODS</H5>
<A NAME="ch05lev4sec56"></A><H5 class="docSection4Title"> email.Parser.Parser.parse(file [,headersonly=0])<br>email.Parser.HeaderParser.parse(file [,headersonly=0])</H5>
<P class="docText">Return a message object based on the message text found in the file-like object <TT>file</TT>. If the optional argument <TT>headersonly</TT> is given a true value, the body of the message is discarded.</P>
<A NAME="ch05lev4sec57"></A><H5 class="docSection4Title"> email.Parser.Parser.parsestr(s [,headersonly=0])<br>email.Parser.HeaderParser.parsestr(s [,headersonly=0])</H5>
<P class="docText">Return a message object based on the message text found in the string <TT>s</TT>. If the optional argument <TT>headersonly</TT> is given a true value, the body of the message is discarded.</P>
<P><A NAME="ch05sb09"></A><TABLE CELLSPACING="0" WIDTH="90%" BORDER="1"><TR><TD>
<P class="docText"><span class="docEmphStrong">email.Utils &#8226; Helper functions for working with messages</span></P></TD></TR></TABLE></P>
<P class="docText">The module <span class="docEmphasis"><TT>email.Utils</TT></span> contains a variety of convenience functions, mostly for working with special header fields.</P>
<A NAME="ch05lev3sec14"></A><H5 class="docSection3Title"> FUNCTIONS</H5>
<A NAME="ch05lev4sec58"></A><H5 class="docSection4Title"> email.Utils.decode_rfc2231(s)</H5>
<P class="docText">Return a decoded string for RFC-2231 encoded string s:</P>
<pre>
&gt;&gt;&gt; Omega = unicodedata.lookup("GREEK CAPITAL LETTER OMEGA")
&gt;&gt;&gt; print email.Utils.encode_rfc2231(Omega+'-man@gnosis.cx')
%3A9-man%40gnosis.cx
&gt;&gt;&gt; email.Utils.decode_rfc2231("utf-8"%3A9-man%40gnosis.cx")
('utf-8', '', ':9-man@gnosis.cx')
</pre>
<A NAME="ch05lev4sec59"></A><H5 class="docSection4Title"> email.Utils.encode_rfc2231(s [,charset [,language]])</H5>
<P class="docText">Return an RFC-2231-encoded string from the string <TT>s</TT>. A charset and language may optionally be specified.</P>
<A NAME="ch05lev4sec60"></A><H5 class="docSection4Title"> email.Utils.formataddr(pair)</H5>
<P class="docText">Return a formatted address from pair <TT>(realname,addr):</TT></P>
<pre>
&gt;&gt;&gt; email.Utils.formataddr(('David Mertz','mertz@gnosis.cx'))
'David Mertz &lt;mertz@gnosis.cx&gt;'
</pre>
<A NAME="ch05lev4sec61"></A><H5 class="docSection4Title"> email.Utils.formataddr([timeval [,localtime=0]])</H5>
<P class="docText">Return an RFC-2822-formatted date based on a time value as returned by <span class="docEmphasis"><TT>time.localtime()</TT></span>. If the argument <TT>localtime</TT> is specified with a true value, use the local timezone rather than UTC. With no options, use the current time.</P>
<pre>
&gt;&gt;&gt; email.Utils.formatdate()
'Wed, 13 Nov 2002 07:08:01 -0000'
</pre>
<A NAME="ch05lev4sec62"></A><H5 class="docSection4Title"> email.Utils.getaddresses(addresses)</H5>
<P class="docText">Return a list of pairs <TT>(realname,addr)</TT> based on the list of compound addresses in argument <TT>addresses</TT>.</P>
<pre>
&gt;&gt;&gt; addrs = ['"Joe" &lt;jdoe@nowhere.lan&gt;','Jane &lt;jroe@other.net&gt;']
&gt;&gt;&gt; email.Utils.getaddresses(addrs)
[('Joe', 'jdoe@nowhere.lan'), ('Jane', 'jroe@other.net')]
</pre>
<A NAME="ch05lev4sec63"></A><H5 class="docSection4Title"> email.Utils.make_msgid([seed])</H5>
<P class="docText">Return a unique string suitable for a <TT>Message-ID</TT> header. If the argument <TT>seed</TT> is given, incorporate that string into the returned value; typically a <TT>seed</TT> is the sender's domain name or other identifying information.</P>
<pre>
&gt;&gt;&gt; email.Utils.make_msgid('gnosis')
'&lt;20021113071050.3861.13687.gnosis@localhost&gt;'
</pre>
<A NAME="ch05lev4sec64"></A><H5 class="docSection4Title"> email.Utils.mktime_tz(tuple)</H5>
<P class="docText">Return a timestamp based on an <span class="docEmphasis"><TT>email.Utils.parsedate_tz()</TT></span> style tuple.</P>
<pre>
&gt;&gt;&gt; email.Utils.mktime_tz((2001, 1, 11, 14, 49, 2, 0, 0, 0, 0))
979224542.0
</pre>
<A NAME="ch05lev4sec65"></A><H5 class="docSection4Title"> email.Utils.parseaddr(address)</H5>
<P class="docText">Parse a compound address into the pair <TT>(realname,addr)</TT>.</P>
<pre>
&gt;&gt;&gt; email.Utils.parseaddr('David Mertz &lt;mertz@gnosis.cx&gt;')
('David Mertz', 'mertz@gnosis.cx')
</pre>
<A NAME="ch05lev4sec66"></A><H5 class="docSection4Title"> email.Utils.parsedate(datestr)</H5>
<P class="docText">Return a date tuple based on an RFC-2822 date string.</P>
<pre>
&gt;&gt;&gt; email.Utils.parsedate('11 Jan 2001 14:49:02 -0000')
(2001, 1, 11, 14, 49, 2, 0, 0, 0)
</pre>
<p class="docText"><span class="docEmphRoman">S<span class="docEmphSmaller">EE</span> A<span class="docEmphSmaller">LSO</span></span>: 
time <span class="docEmphasis">86</span>;</p>
<A NAME="ch05lev4sec67"></A><H5 class="docSection4Title"> email.Utils.parsedate_tz(datestr)</H5>
<P class="docText">Return a date tuple based on an RFC-2822 date string. Same as <span class="docEmphasis"><TT>email.Utils.parsedate()</TT></span>, but adds a tenth tuple field for offset from UTC (or <TT>None</TT> if not determinable).</P>
<A NAME="ch05lev4sec68"></A><H5 class="docSection4Title"> email.Utils.quote(s)</H5>
<P class="docText">Return a string with backslashes and double quotes escaped.</P>
<pre>
&gt;&gt;&gt; print email.Utils.quote(r'"MyPath" is d:\this\that')
\"MYPath\" is d:\\this\\that
</pre>
<A NAME="ch05lev4sec69"></A><H5 class="docSection4Title"> email.Utils.unquote(s)</H5>
<P class="docText">Return a string with surrounding double quotes or angle brackets removed.</P>
<pre>
&gt;&gt;&gt; print email.Utils.unquote('&lt;mertz@gnosis.cx&gt;')
mertz@gnosis.cx
&gt;&gt;&gt; print email.Utils.unquote('"us-ascii"')
us-ascii
</pre>
<A NAME="ch05lev2sec2"></A><H4 class="docSection2Title">5.1.2 Communicating with Mail Servers</H4>
<P><A NAME="ch05sb10"></A><TABLE CELLSPACING="0" WIDTH="90%" BORDER="1"><TR><TD>
<P class="docText"><span class="docEmphStrong">imaplib &#8226; IMAP4 client</span></P></TD></TR></TABLE></P>
<P class="docText">The module <span class="docEmphasis"><TT>imaplib</TT></span> supports implementing custom IMAP clients. This protocol is detailed in RFC-1730 and RFC-2060. As with the discussion of other protocol libraries, this documentation aims only to cover the basics of communicating with an IMAP server듨any methods and functions are omitted here. In particular, of interest here is merely being able to retrieve messages듞reating new mailboxes and messages is outside the scope of this book.</P>
<P class="docText">The <span class="docEmphasis">Python Library Reference</span> describes the POP3 protocol as obsolescent and recommends the use of IMAP4 if your server supports it. While this advice is not incorrect technically듈MAP indeed has some advantages들n my experience, support for POP3 is far more widespread among both clients and servers than is support for IMAP4. Obviously, your specific requirements will dictate the choice of an appropriate support library.</P>
<P class="docText">Aside from using a more efficient transmission strategy (POP3 is line-by-line, IMAP4 sends whole messages), IMAP4 maintains multiple mailboxes on a server and also automates filtering messages by criteria. A typical (simple) IMAP4 client application might look like the one below. To illustrate a few methods, this application will print all the promising subject lines, after deleting any that look like spam. The example does not itself retrieve regular messages, only their headers.</P>
<H5 class="docExampleTitle"><A NAME="ch05list02"></A> check_imap_subjects.py</H5>

<PRE>
#!/usr/bin/env python
import imaplib, sys
if len(sys.argv) == 4:
    sys.argv.append('INBOX')
(host, user, passwd, mbox) = sys.argv[1:]
i = imaplib.IMAP4(host, port=143)
i.login(user, passwd)
resp = i.select(mbox)
if r[0] &lt;&gt; 'OK':
    sys.stderr.write("Could not select %s\n" % mbox)
    sys.exit()
# delete some spam messages
typ, spamlist = i.search(None, '(SUBJECT) "URGENT"')
i.store(','.join(spamlist.split()),'+FLAGS.SILENT','\deleted')
i.expunge()
typ, messnums = i.search(None,'ALL').split()
for mess in messnums:
    typ, header = i.fetch(mess, 'RFC822.HEADER')
    for line in header[0].split('\n'):
        if string.upper(line[:9]) == 'SUBJECT: ':
            print line[9:]
i.close()
i.logout()
</PRE>
<P class="docText">There is a bit more work to this than in the POP3 example, but you can also see some additional capabilities. Unfortunately, much of the use of the <span class="docEmphasis"><TT>imaplib</TT></span> module depends on passing strings with flags and commands, none of which are well-documented in the <span class="docEmphasis">Python Library Reference</span> or in the source to the module. A separate text on the IMAP protocol is probably necessary for complex client development.</P>
<A NAME="ch05lev3sec15"></A><H5 class="docSection3Title"> CLASSES</H5>
<A NAME="ch05lev4sec70"></A><H5 class="docSection4Title"> imaplib.IMAP4([host="localhost" [port=143]])</H5>
<P class="docText">Create an IMAP instance object to manage a host connection.</P>
<A NAME="ch05lev3sec16"></A><H5 class="docSection3Title"> METHODS</H5>
<A NAME="ch05lev4sec71"></A><H5 class="docSection4Title"> imaplib.IMAP4.close()</H5>
<P class="docText">Close the currently selected mailbox, and delete any messages marked for deletion. The method <span class="docEmphasis"><TT>imaplib.IMAP4.logout()</TT></span> is used to actually disconnect from the server.</P>
<A NAME="ch05lev4sec72"></A><H5 class="docSection4Title"> imaplib.IMAP4.expunge()</H5>
<P class="docText">Permanently delete any messages marked for deletion in the currently selected mailbox.</P>
<A NAME="ch05lev4sec73"></A><H5 class="docSection4Title"> imaplib.IMAP4.fetch(message_set, message_parts)</H5>
<P class="docText">Return a pair <TT>(typ,datalist)</TT>. The first field <TT>typ</TT> is either <TT>OK</TT> or <TT>NO</TT>, indicating the status. The second field <TT>datalist</TT> is a list of returned strings from the fetch request. The argument <TT>message_set</TT> is a comma-separated list of message numbers to retrieve. The <TT>message_parts</TT> describe the components of the messages retrieved듣eader, body, date, and so on.</P>
<A NAME="ch05lev4sec74"></A><H5 class="docSection4Title"> imaplib.IMAP4.list([dirname="" [,pattern="*"])</H5>
<P class="docText">Return a <TT>(typ,datalist)</TT> tuple of all the mailboxes in directory <TT>dirname</TT> that match the glob-style pattern <TT>pattern. datalist</TT> contains a list of string names of mailboxes. Contrast this method with <span class="docEmphasis"><TT>imaplib.IMAP4.search()</TT></span>, which returns numbers of individual messages from the currently selected mailbox.</P>
<A NAME="ch05lev4sec75"></A><H5 class="docSection4Title"> imaplib.IMAP4.login(user, passwd)</H5>
<P class="docText">Connect to the IMAP server specified in the instance initialization, using the authentication information given by <TT>user</TT> and <TT>passwd</TT>.</P>
<A NAME="ch05lev4sec76"></A><H5 class="docSection4Title"> imaplib.IMAP4.logout()</H5>
<P class="docText">Disconnect from the IMAP server specified in the instance initialization.</P>
<A NAME="ch05lev4sec77"></A><H5 class="docSection4Title"> imaplib.IMAP4.search(charset, criterion1 [,criterion2 [,...]])</H5>
<P class="docText">Return a <TT>(typ,messnums)</TT> tuple where <TT>messnums</TT> is a space-separated string of message numbers of matching messages. Message criteria specified in <TT>criterion1</TT>, and so on may either be <TT>ALL</TT> for all messages or flags indicating the fields and values to match.</P>
<A NAME="ch05lev4sec78"></A><H5 class="docSection4Title"> imaplib.lMAP4.select([mbox="INBOX" [,readonly=0])</H5>
<P class="docText">Select the current mailbox for operations such as <span class="docEmphasis"><TT>imaplib.IMAP4.search()</TT></span> and <span class="docEmphasis"><TT>imaplib.IMAP4.expunge()</TT></span>. The argument <TT>mbox</TT> gives the name of the mailbox, and <TT>readonly</TT> allows you to prevent modification to a mailbox.</P>
<p class="docText"><span class="docEmphRoman">S<span class="docEmphSmaller">EE</span> A<span class="docEmphSmaller">LSO</span></span>: 
email <span class="docEmphasis">345</span>; poplib <span class="docEmphasis">368</span>; smtplib <span class="docEmphasis">370</span>;</p>
<P><A NAME="ch05sb11"></A><TABLE CELLSPACING="0" WIDTH="90%" BORDER="1"><TR><TD>
<P class="docText"><span class="docEmphStrong">poplib &#8226; A POP3 client class</span></P></TD></TR></TABLE></P>
<P class="docText">The module <span class="docEmphasis"><TT>poplib</TT></span> supports implementing custom POP3 clients. This protocol is detailed in RFC-1725. As with the discussion of other protocol libraries, this documentation aims only to cover the basics of communicating with a POP3 server듭ome methods or functions may be omitted here.</P>
<P class="docText">The <span class="docEmphasis">Python Library Reference</span> describes the POP3 protocol as obsolescent and recommends the use of IMAP4 if your server supports it. While this advice is not incorrect technically듈MAP indeed has some advantages들n my experience, support for POP3 is far more widespread among both clients and servers than is support for IMAP4. Obviously, your specific requirements will dictate the choice of an appropriate support library.</P>
<P class="docText">A typical (simple) POP3 client application might look like the one below. To illustrate a few methods, this application will print all the promising subject lines, and retrieve and delete any that look like spam. The example does not itself retrieve regular messages, only their headers.</P>
<H5 class="docExampleTitle"><A NAME="ch05list03"></A> new_email_subjects.py</H5>

<PRE>
#!/usr/bin/env python
import poplib, sys, string
spamlist = []
(host, user, passwd) = sys.argv[1:]
mbox = poplib.POP3(host)
mbox.user(user)
mbox.pass_(passwd)

for i in range(1, mbox.stat()[0]+1):
    # messages use one-based indexing
    headerlines = mbox.top(i, 0)[1]    # No body lines
    for line in headerlines:
        if string.upper(line[:9]) == 'SUBJECT: ':
            if -1 &lt;&gt; string.find(line,'URGENT'):
                spam = string.join(mbox.retr(i)[1],'\n')
                spamlist.append(spam)
                mbox.dele(i)
            else:
                 print line[9:]

mbox.quit()
for spam in spamlist:
    report_to_spamcop(spam)     # assuming this func exists
</PRE>
<A NAME="ch05lev3sec17"></A><H5 class="docSection3Title"> CLASSES</H5>
<A NAME="ch05lev4sec79"></A><H5 class="docSection4Title"> poplib.POP3(host [,port=110])</H5>
<P class="docText">The <span class="docEmphasis"><TT>poplib</TT></span> module provides a single class that establishes a connection to a POP3 server at host <TT>host</TT>, using port <TT>port</TT>.</P>
<A NAME="ch05lev3sec18"></A><H5 class="docSection3Title"> METHODS</H5>
<A NAME="ch05lev4sec80"></A><H5 class="docSection4Title"> poplib.POP3.apop(user, secret)</H5>
<P class="docText">Log in to a server using APOP authentication.</P>
<A NAME="ch05lev4sec81"></A><H5 class="docSection4Title"> poplib.POP3.dele(messnum)</H5>
<P class="docText">Mark a message for deletion. Normally the actual deletion does not occur until you log off with <span class="docEmphasis"><TT>poplib.POP3.quit()</TT></span>, but server implementations differ.</P>
<A NAME="ch05lev4sec82"></A><H5 class="docSection4Title"> poplib.POP3.pass_(password)</H5>
<P class="docText">Set the password to use when communicating with the POP server.</P>
<A NAME="ch05lev4sec83"></A><H5 class="docSection4Title"> poplib.POP3.quit()</H5>
<P class="docText">Log off from the connection to the POP server. Logging off will cause any pending deletions to be carried out. Call this method as soon as possible after you establish a connection to the POP server; while you are connected, the mailbox is locked against receiving any incoming messages.</P>
<A NAME="ch05lev4sec84"></A><H5 class="docSection4Title"> poplib.POP3.retr(messnum)</H5>
<P class="docText">Return the message numbered <TT>messnum</TT> (using one-based indexing). The return value is of the form <TT>(resp,linelist,octets)</TT>, where <TT>linelist</TT> is a list of the individual lines in the message. To re-create the whole message, you will need to join these lines.</P>
<A NAME="ch05lev4sec85"></A><H5 class="docSection4Title"> poplib.POP3.rset()</H5>
<P class="docText">Unmark any messages marked for deletion. Since server implementations differ, it is not good practice to mark messages using <span class="docEmphasis"><TT>poplib.POP3.dele()</TT></span> unless you are pretty confident you want to erase them. However, <span class="docEmphasis"><TT>poplib.POP3.rset()</TT></span> can usually save messages should unusual circumstances occur before the connection is logged off.</P>
<A NAME="ch05lev4sec86"></A><H5 class="docSection4Title"> poplib.POP3.top(messnum, lines)</H5>
<P class="docText">Retrieve the initial lines of message <TT>messnum</TT>. The header is always included, along with lines lines from the body. The return format is the same as with <span class="docEmphasis"><TT>poplib.POP3.retr()</TT></span>, and you will typically be interested in offset 1 of the returned tuple.</P>
<A NAME="ch05lev4sec87"></A><H5 class="docSection4Title"> poplib.POP3.stat()</H5>
<P class="docText">Retrieve the status of the POP mailbox in the format <TT>(messcount,mbox_size). messcount</TT> gives you the total number of message pending; <TT>mbox_size</TT> is the total size of all pending messages.</P>
<A NAME="ch05lev4sec88"></A><H5 class="docSection4Title"> poplib.POP3.user(username)</H5>
<P class="docText">Set the username to use when communicating with the POP server.</P>
<p class="docText"><span class="docEmphRoman">S<span class="docEmphSmaller">EE</span> A<span class="docEmphSmaller">LSO</span></span>: 
email <span class="docEmphasis">345</span>; smtplib <span class="docEmphasis">370</span>; imaplib <span class="docEmphasis">366</span>;</p>
<P><A NAME="ch05sb12"></A><TABLE CELLSPACING="0" WIDTH="90%" BORDER="1"><TR><TD>
<P class="docText"><span class="docEmphStrong">smtplib &#8226; </span><span class="docEmphStrong">SMTP</span><span class="docEmphStrong">/ESMTP client class</span></P></TD></TR></TABLE></P>
<P class="docText">The module <span class="docEmphasis"><TT>smtplib</TT></span> supports implementing custom SMTP clients. This protocol is detailed in RFC-821 and RFC-1869. As with the discussion of other protocol libraries, this documentation aims only to cover the basics of communicating with an SMTP server듨ost methods and functions are omitted here. The modules <span class="docEmphasis"><TT>poplib</TT></span> and <span class="docEmphasis"><TT>imaplib</TT></span> are used to retrieve incoming email, and the module <span class="docEmphasis"><TT>smtplib</TT></span> is used to send outgoing email.</P>
<P class="docText">A typical (simple) SMTP client application might look like the one below. This example is a command-line tool that accepts as a parameters the mandatory <TT>To</TT> message envelope header, constructs the <TT>From</TT> using environment variables, and sends whatever text is on STDIN. The <TT>To</TT> and <TT>From</TT> are also added as RFC-822 headers in the message header.</P>
<H5 class="docExampleTitle"><A NAME="ch05list04"></A> send_email.py</H5>

<PRE>
#!/usr/bin/env python
import smtplib
from sys import argv, stdin
from os import getenv
host = getenv('HOST', 'localhost')
if len(argv) &gt;= 2:
    to_ = argv[1]
else:
    to_ = raw_input('To: ').strip()
if len(argv) &gt;=3:
    subject = argv[2]
    body = stdin.read()
else:
    subject = stdin.readline()
    body = subject + stdin.read()
from_ = "%s@%s" % (getenv('USER', 'user'), host)
mess = '''From: %s\nTo: %s\n\n%s' % (to_, from_, body)
server = smtp.SMTP(host)
server.login
server.sendmail(from_, to_, mess)
server.quit()
</PRE>
<A NAME="ch05lev3sec19"></A><H5 class="docSection3Title"> CLASSES</H5>
<A NAME="ch05lev4sec89"></A><H5 class="docSection4Title"> smtplib.SMTP([host="localhost" [,port=25]])</H5>
<P class="docText">Create an instance object that establishes a connection to an SMTP server at host <TT>host</TT>, using port <TT>port</TT>.</P>
<A NAME="ch05lev3sec20"></A><H5 class="docSection3Title"> METHODS</H5>
<A NAME="ch05lev4sec90"></A><H5 class="docSection4Title"> smtplib.SMTP.login(user, passwd)</H5>
<P class="docText">Login to an SMTP server that requires authentication. Raises an error if authentication fails.</P>
<P class="docText">Not all듪r even most듑MTP servers use password authentication. Modern servers support direct authentication, but since not all clients support SMTP authentication, the option is often disabled. One commonly used strategy to prevent "open relays" (servers that allow malicious/spam messages to be sent through them) is "POP before SMTP." In this arrangement, an IP address is authorized to use an SMTP server for a period of time after that same address has successfully authenticated with a POP3 server on the same machine. The timeout period is typically a few minutes to hours.</P>
<A NAME="ch05lev4sec91"></A><H5 class="docSection4Title"> smtplib.SMTP.quit()</H5>
<P class="docText">Terminate an SMTP connection.</P>
<A NAME="ch05lev4sec92"></A><H5 class="docSection4Title"> smtplib.SMTP.sendmail(from_, to_, mess [,mail_options=[] [,rcpt_options=[]]])</H5>
<P class="docText">Send the message <TT>mess</TT> with <TT>From</TT> envelope <TT>from_</TT>, to recipients <TT>to_</TT>. The argument <TT>to_</TT> may either be a string containing a single address or a Python list of addresses. The message should include any desired RFC-822 headers. ESMTP options may be specified in arguments <TT>mail_options</TT> and <TT>rcpt_options</TT>.</P>
<p class="docText"><span class="docEmphRoman">S<span class="docEmphSmaller">EE</span> A<span class="docEmphSmaller">LSO</span></span>: 
email <span class="docEmphasis">345</span>; poplib <span class="docEmphasis">368</span>; imaplib <span class="docEmphasis">366</span>;</p>
<A NAME="ch05lev2sec3"></A><H4 class="docSection2Title">5.1.3 Message Collections and Message Parts</H4>
<P><A NAME="ch05sb13"></A><TABLE CELLSPACING="0" WIDTH="90%" BORDER="1"><TR><TD>
<P class="docText"><span class="docEmphStrong">mailbox &#8226; Work with mailboxes in various formats</span></P></TD></TR></TABLE></P>
<P class="docText">The module <span class="docEmphasis"><TT>mailbox</TT></span> provides a uniform interface to email messages stored in a variety of popular formats. Each class in the <span class="docEmphasis"><TT>mailbox</TT></span> module is initialized with a mailbox of an appropriate format, and returns an instance with a single method .<TT>next()</TT>. This instance method returns each consecutive message within a mailbox upon each invocation. Moreover, the .<TT>next ()</TT> method is conformant with the iterator protocol in Python 2.2+, which lets you loop over messages in recent versions of Python.</P>
<P class="docText">By default, the messages returned by <TT>mailbox</TT> instances are objects of the class <span class="docEmphasis"><TT>rfc822.Mailbox</TT></span>. These message objects provide a number of useful methods and attributes. However, the recommendation of this book is to use the newer <span class="docEmphasis"><TT>email</TT></span> module in place of the older <span class="docEmphasis"><TT>rfc822</TT></span>. Fortunately, you may initialize a <span class="docEmphasis"><TT>mailbox</TT></span> class using an optional message constructor. The only constraint on this constructor is that it is a callable object that accepts a file-like object as an argument듮he <span class="docEmphasis"><TT>email</TT></span> module provides two logical choices here.</P>
<pre>
&gt;&gt;&gt; import mailbox, email, email.Parser
&gt;&gt;&gt; mbox = mailbox.PortableUnixMailbox(open('mbox'))
&gt;&gt;&gt; mbox.next()
&lt;rfc822.Message instance at Ox41d770&gt;
&gt;&gt;&gt; mbox = mailbox.PortableUnixMailbox(open('mbox'),
...                        email.message_from_file)
&gt;&gt;&gt; mbox.next()
&lt;email.Message.Message instance at Ox5e43eO&gt;
&gt;&gt;&gt; mbox = mailbox.PortableUnixMailbox(open('mbox'),
...                        email.Parser.Parser().parse)
&gt;&gt;&gt; mbox.next()
&lt;email.Message.Message instance at Ox6ee630&gt;
</pre>
<P class="docText">In Python 2.2+ you might structure your application as:</P>
<H5 class="docExampleTitle"><A NAME="ch05list05"></A> Looping through a mailbox in 2.2+</H5>

<PRE>
#!/usr/bin/env python
from mailbox import PortableUnixMailbox
from email import message_from_file as mff
import sys
folder = open(sys.argv[1])
for message in PortableUnixMailbox(folder, mff):
    # do something with the message...
    print message['Subject']
</PRE>
<P class="docText">However, in earlier versions, this same code will raise an <TT>AttributeError</TT> for the missing <TT>.__getitem__()</TT> magic method. The slightly less elegant way to write the same application in an older Python is:</P>
<H5 class="docExampleTitle"><A NAME="ch05list06"></A> Looping through a mailbox in any version</H5>

<PRE>
#!/usr/bin/env python
"Subject printer, older Python and rfc822.Message objects"
import sys
from mailbox import PortableUnixMailbox
mbox = PortableUnixMailbox(open(sys.argv[1]))
while 1:
    message = mbox.next()
    if message is None:
        break
    print message.getheader('Subject')
</PRE>
<A NAME="ch05lev3sec21"></A><H5 class="docSection3Title"> CLASSES</H5>
<A NAME="ch05lev4sec93"></A><H5 class="docSection4Title"> mailbox.UnixMailbox(file [,factory=rfc822.Message])</H5>
<P class="docText">Read a BSD-style mailbox from the file-like object <TT>file</TT>. If the optional argument <TT>factory</TT> is specified, it must be a callable object that accepts a file-like object as its single argument (in this case, that object is a portion of an underlying file).</P>
<P class="docText">A BSD-style mailbox divides messages with a blank line followed by a "Unix From_" line. In this strict case, the "From_" line must have <TT>name</TT> and <TT>time</TT> information on it that matches a regular expression. In most cases, you are better off using <span class="docEmphasis"><TT>mailbox.PortableUnixMailbox</TT></span>, which relaxes the requirement for recognizing the next message in a file.</P>
<A NAME="ch05lev4sec94"></A><H5 class="docSection4Title"> mailbox.PortableUnixMailbox(file [,factory=rfc822.Message])</H5>
<P class="docText">The arguments to this class are the same as for <span class="docEmphasis"><TT>mailbox.UnixMailbox</TT></span>. Recognition of the messages within the mailbox <TT>file</TT> depends only on finding <TT>From</TT> followed by a space at the beginning of a line. In practice, this is as much as you can count on if you cannot guarantee that all mailboxes of interest will be created by a specific application and version.</P>
<A NAME="ch05lev4sec95"></A><H5 class="docSection4Title"> mailbox.BabylMailbox(file [,factory=rfc822.Message])</H5>
<P class="docText">The arguments to this class are the same as for <span class="docEmphasis"><TT>mailbox.UnixMailbox</TT></span>. Handles mailbox files in Babyl format.</P>
<A NAME="ch05lev4sec96"></A><H5 class="docSection4Title"> mailbox.MmdfMailbox(file [,factory=rfc822.Message])</H5>
<P class="docText">The arguments to this class are the same as for <span class="docEmphasis"><TT>mailbox.UnixMailbox</TT></span>. Handles mailbox files in MMDF format.</P>
<A NAME="ch05lev4sec97"></A><H5 class="docSection4Title"> mailbox.MHMailbox(dirname [,factory=rfc822.Message])</H5>
<P class="docText">The MH format uses the directory structure of the underlying native filesystem to organize mail folders. Each message is held in a separate file. The initializer argument for <span class="docEmphasis"><TT>mailbox.MHMailbox</TT></span> is a string giving the name of the directory to be processed. The <TT>factory</TT> argument is the same as with <span class="docEmphasis"><TT>mailbox.UnixMailbox</TT></span>.</P>
<A NAME="ch05lev4sec98"></A><H5 class="docSection4Title"> mailbox.Maildir(dirname [,factory=rfc822.Message])</H5>
<P class="docText">The QMail format, like the MH format, uses the directory structure of the underlying native filesystem to organize mail folders. The initializer argument for <span class="docEmphasis"><TT>mailbox.Maildir</TT></span> is a string giving the name of the directory to be processed. The <TT>factory</TT> argument is the same as with <span class="docEmphasis"><TT>mailbox.UnixMailbox</TT></span>.</P>
<p class="docText"><span class="docEmphRoman">S<span class="docEmphSmaller">EE</span> A<span class="docEmphSmaller">LSO</span></span>: 
email <span class="docEmphasis">345</span>; poplib <span class="docEmphasis">368</span>; imaplib <span class="docEmphasis">366</span>; nntplib <span class="docEmphasis">397</span>; smtplib <span class="docEmphasis">370</span>; rfc822 <span class="docEmphasis">397</span>;</p>
<P><A NAME="ch05sb14"></A><TABLE CELLSPACING="0" WIDTH="90%" BORDER="1"><TR><TD>
<P class="docText"><span class="docEmphStrong">mimetypes &#8226; Guess the MIME type of a file</span></P></TD></TR></TABLE></P>
<P class="docText">The <span class="docEmphasis"><TT>mimetypes</TT></span> module maps file extensions to MIME datatypes. At its heart, the module is a dictionary, but several convenience functions let you work with system configuration files containing additional mappings, and also query the mapping in some convenient ways. As well as actual MIME types, the <span class="docEmphasis"><TT>mimetypes</TT></span> module tries to guess file encodings, for example, compression wrapper.</P>
<P class="docText">In Python 2.2+, the <span class="docEmphasis"><TT>mimetypes</TT></span> module also provides a <span class="docEmphasis"><TT>mimetypes.MimeTypes</TT></span> class that lets instances each maintain their own MIME types mapping, but the requirement for multiple distinct mapping is rare enough not to be worth covering here.</P>
<A NAME="ch05lev3sec22"></A><H5 class="docSection3Title"> FUNCTIONS</H5>
<A NAME="ch05lev4sec99"></A><H5 class="docSection4Title"> mimetypes.guess_type(url [,strict=0])</H5>
<P class="docText">Return a pair <TT>(typ, encoding)</TT> based on the file or Uniform Resource Locator (URL) named by <TT>url</TT>. If the <TT>strict</TT> option is specified with a true value, only officially specified types are considered. Otherwise, a larger number of widespread MIME types are examined. If either <TT>type</TT> or <TT>encoding</TT> cannot be guessed, <TT>None </TT>is returned for that value.</P>
<pre>
&gt;&gt;&gt; import mimetypes
&gt;&gt;&gt; mimetypes.guess_type('x.abc.gz')
(None, 'gzip')
&gt;&gt;&gt; mimetypes.guess_type('x.tgz')
('application/x-tar', 'gzip')
&gt;&gt;&gt; mimetypes.guess_type('x.ps.gz')
('application/postscript', 'gzip')
&gt;&gt;&gt; mimetypes.guess_type('x.txt')
('text/plain', None)
&gt;&gt;&gt; mimetypes.guess_type('a.xyz')
(None, None)
</pre>
<A NAME="ch05lev4sec100"></A><H5 class="docSection4Title"> mimetypes.guess_extension(type [,strict=0])</H5>
<P class="docText">Return a string indicating a likely extension associated with the MIME type. If multiple file extensions are possible, one is returned (generally the one that is first alphabetically, but this is not guaranteed). The argument <TT>strict</TT> has the same meaning as in <span class="docEmphasis"><TT>mimetypes.guess-type()</TT></span>.</P>
<pre>
&gt;&gt;&gt; print mimetypes.guess_extension('application/EDI-Consent')
None
&gt;&gt;&gt; print mimetypes.guess_extension('application/pdf')
.pdf
&gt;&gt;&gt; print mimetypes.guess_extension('application/postscript')
.ai
</pre>
<A NAME="ch05lev4sec101"></A><H5 class="docSection4Title"> mimetypes.init([list-of-files])</H5>
<P class="docText">Add the definitions from each filename listed in <TT>list-of-files</TT> to the MIME type mapping. Several default files are examined even if this function is not called, but additional configuration files may be added as needed on your system. For example, on my MacOSX system, which uses somewhat different directories than a Linux system, I find it useful to run:</P>
<pre>
&gt;&gt;&gt; mimetypes.init(['/private/etc/httpd/mime.types.default',
...                 '/private/etc/httpd/mime.types'])
</pre>
<P class="docText">Notice that even if you are specifying only one additional configuration file, you must enclose its name inside a list.</P>
<A NAME="ch05lev4sec102"></A><H5 class="docSection4Title"> mimetypes.read_mime_types(fname)</H5>
<P class="docText">Read the single file named <TT>fname</TT> and return a dictionary mapping extensions to MIME types.</P>
<pre>
&gt;&gt;&gt; from mimetypes import read_mime_types
&gt;&gt;&gt; types = read_mime_types('/private/etc/httpd/mime.types')
&gt;&gt;&gt; for _ in range(5): print types.popitem()
...
('.wbxml', 'application/vnd.wap.wbxml')
('.aiff', 'audio/x-aiff')
('.rm', 'audio/x-pn-realaudio')
('.xbm', 'image/x-xbitmap')
('.avi', 'video/x-msvideo')
</pre>
<A NAME="ch05lev3sec23"></A><H5 class="docSection3Title"> ATTRIBUTES</H5>
<A NAME="ch05lev4sec103"></A><H5 class="docSection4Title"> mimetypes.common_types</H5>
<P class="docText">Dictionary of widely used, but unofficial MIME types.</P>
<A NAME="ch05lev4sec104"></A><H5 class="docSection4Title"> mimetypes.inited</H5>
<P class="docText">True value if the module has been initialized.</P>
<A NAME="ch05lev4sec105"></A><H5 class="docSection4Title"> mimetypes.encodings_map</H5>
<P class="docText">Dictionary of encodings.</P>
<A NAME="ch05lev4sec106"></A><H5 class="docSection4Title"> mimetypes.knownfiles</H5>
<P class="docText">List of files checked by default.</P>
<A NAME="ch05lev4sec107"></A><H5 class="docSection4Title"> mimetypes.suffix_map</H5>
<P class="docText">Dictionary of encoding suffixes.</P>
<A NAME="ch05lev4sec108"></A><H5 class="docSection4Title"> mimetypes.types_map</H5>
<P class="docText">Dictionary mapping extensions to MIME types.</P>
<a href="0321112547_10061533.html"><img src="FILES/pixel.gif" width="1" height="1" border="0"></a><ul></ul></td></tr></table>
<td></td>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<td class="tt1"><a href="NFO/lib.html">[ Team LiB ]</a></td><td valign="top" class="tt1" align="right">
          <a href="0321112547_ch05.html"><img src="FILES/btn_prev.gif" width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a>
          <a href="0321112547_ch05lev1sec2.html"><img src="FILES/btn_next.gif" width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a>
</td></table>
</body></html>
