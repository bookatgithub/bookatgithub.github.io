<html><head>
<META http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<!--SafClassName="docSection1Title"--><!--SafTocEntry="5.2 World Wide Web Applications"-->
<link rel="STYLESHEET" type="text/css" href="FILES/style.css">
<link rel="STYLESHEET" type="text/css" href="FILES/docsafari.css">
<style type="text/css">	.tt1    {font-size: 10pt;}</style>
</head>
<body>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<td class="tt1"><a href="NFO/lib.html">[ Team LiB ]</a></td><td valign="top" class="tt1" align="right">
	<a href="0321112547_ch05lev1sec1.html"><img src="FILES/btn_prev.gif" width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a>
	<a href="0321112547_ch05lev1sec3.html"><img src="FILES/btn_next.gif" width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a>
</td></table>
<br>
<table width="100%" border="0" cellspacing="0" cellpadding="0"><tr><td valign="top"><A NAME="ch05lev1sec2"></A><H3 class="docSection1Title">5.2 World Wide Web Applications</H3>
<A NAME="ch05lev2sec4"></A><H4 class="docSection2Title">5.2.1 Common Gateway Interface</H4>
<P><A NAME="ch05sb15"></A><TABLE CELLSPACING="0" WIDTH="90%" BORDER="1"><TR><TD>
<P class="docText"><span class="docEmphStrong">cgi &#8226; Support for Common Gateway Interface scripts</span></P></TD></TR></TABLE></P>
<P class="docText">The module <span class="docEmphasis"><TT>cgi</TT></span> provides a number of helpful tools for creating CGI scripts. There are two elements to CGI, basically: (1) Reading query values. (2) Writing the results back to the requesting browser. The first of these elements is aided by the <span class="docEmphasis"><TT>cgi</TT></span> module, the second is just a matter of formatting suitable text to return. The <span class="docEmphasis"><TT>cgi</TT></span> module contains one class that is its primary interface; it also contains several utility functions that are not documented here because their use is uncommon (and not hard to replicate and customize for your specific needs). See the <span class="docEmphasis">Python Library Reference</span> for details on the utility functions.</P>
<A NAME="ch05lev3sec24"></A><H5 class="docSection3Title"> A CGI PRIMER</H5>
<P class="docText">A primer on the Common Gateway Interface is in order. A CGI script is just an application—in any programming language—that runs on a Web server. The server software recognizes a request for a CGI application, sets up a suitable environment, then passes control to the CGI application. By default, this is done by spawning a new process space for the CGI application to run in, but technologies like <span class="docEmphasis"><TT>FastCGI</TT></span> and <span class="docEmphasis"><TT>mod-python</TT></span> perform some tricks to avoid extra process creation. These latter techniques speed performance but change little from the point of view of the CGI application creator.</P>
<P class="docText">A Python CGI script is called in exactly the same way any other URL is. The only difference between a CGI and a static URL is that the former is marked as executable by the Web server—conventionally, such scripts are confined to a <TT>./cgi-bin/</TT> subdirectory (sometimes another directory name is used); Web servers generally allow you to configure where CGI scripts may live. When a CGI script runs, it is expected to output a <TT>Content-Type</TT> header to STDOUT, followed by a blank line, then finally some content of the appropriate type—most often an HTML document. That is really all there is to it.</P>
<P class="docText">CGI requests may utilize one of two methods: POST or GET. A POST request sends any associated query data to the STDIN of the CGI script (the Web server sets this up for the script). A GET request puts the query in an environment variable called <TT>QUERY_STRING</TT>. There is not a lot of difference between the two methods, but GET requests encode their query information in a Uniform Resource Identifier (URI) and may therefore be composed without HTML forms and saved/bookmarked. For example, the following is an HTTP GET query to a script example discussed below:</P>
<BLOCKQUOTE><P><P class="docList"><TT>&lt;</TT><A class="docLink" target="_blank" HREF="http://gnosis.cx/cgi-bin/simple.cgi@this=that&spam=eggs+are+good">http://gnosis.cx/cgi-bin/simple.cgi?this=that&amp;spam=eggs+are+good</A><TT>&gt;</TT></P></P></BLOCKQUOTE>
<P class="docText">You do not actually <span class="docEmphasis">need</span> the <span class="docEmphasis"><TT>cgi</TT></span> module to create CGI scripts. For example, let us look at the script <TT>simple.cgi</TT> mentioned above:</P>
<H5 class="docExampleTitle"><A NAME="ch05list07"></A> simple.cgi</H5>

<PRE>
#!/usr/bin/python
import os,sys
print "Content-Type: text/html"
print
print "&lt;html&gt;&lt;head&gt;&lt;title&gt;Environment test&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;pre&gt;"
for k,v in os.environ.items():
    print k, "::",
    if len(v)&lt;=40: print v
    else:          print v[:37]+"..."
print "&amp;lt;STDIN&amp;gt; ::", sys.stdin.read()
print "&lt;/pre&gt;&lt;/body&gt;&lt;/html&gt;"
</PRE>
<P class="docText">I happen to have composed the above sample query by hand, but you will often call a CGI script from another Web page. Here is one that does so:</P>
<H5 class="docExampleTitle"><A NAME="ch05list08"></A> http://gnosis.cx/simpleform.html</H5>

<PRE>
&lt;html&gt;&lt;head&gt;&lt;title&gt;Test simple.cgi&lt;/title&gt;&lt;/head&gt;&lt;body&gt;
&lt;form action="cgi-bin/simple.cgi" method="GET" name="form"&gt;
&lt;input type="hidden" name="this" value="that"&gt;
&lt;input type="text" value="" name="spam" size="55" maxlength="256"&gt;
&lt;input type="submit" value="GET"&gt;
&lt;/form&gt;
&lt;form action="cgi-bin/simple.cgi" method="POST" name="form"&gt;
&lt;input type="hidden" name="this" value="that"&gt;
&lt;input type="text" value="" name="spam" size="55" maxlength="256"&gt;
&lt;input type="submit" value="POST"&gt;
&lt;/form&gt;
&lt;/body&gt;&lt;/html&gt;
</PRE>
<P class="docText">It turns out that the script <TT>simple.cgi</TT> is moderately useful; it tells the requester exactly what it has to work with. For example, the query above (which could be generated exactly by the GET form on <TT>simpleform.html)</TT> returns a Web page that looks like the one below (edited):</P>
<pre>
DOCUMENT_ROOT :: /www/gnosis
HTTP_ACCEPT_ENCODING :: gzip, deflate, compress;q=0.9
CONTENT_TYPE :: application/x-www-form-urlencoded
SERVER_PORT :: 80
REMOTE_ADDR :: 151.203.xxx.xxx
SERVER_NAME :: www.gnosis.cx
HTTP_USER_AGENT :: Mozilla/5.0 (Macintosh; U; PPC Mac OS...
REQUEST_URI :: /cgi-bin/simple.cgi?this=that&amp;spam=eg...
QUERY_STRING :: this=that&amp;spam=eggs+are+good
SERVER_PROTOCOL :: HTTP/1.1
HTTP_HOST :: gnosis.cx
REQUEST_METHOD :: GET
SCRIPT_NAME :: /cgi-bin/simple.cgi
SCRIPT_FILENAME :: /www/gnosis/cgi-bin/simple.cgi
HTTP_REFERER :: http://gnosis.cx/simpleform.html
&lt;STDIN&gt; ::
</pre>
<P class="docText">A few environment variables have been omitted, and those available will differ between Web servers and setups. The most important variable is <TT>QUERY_STRING;</TT> you may perhaps want to make other decisions based on the requesting <TT>REMOTE_ADDR</TT>, <TT>HTTP_USER_AGENT</TT>, or <TT>HTTP_REFERER</TT> (yes, the variable name is spelled wrong). Notice that STDIN is empty in this case. However, using the POST form on the sample Web page will give a slightly different response (trimmed):</P>
<pre>
CONTENT_LENGTH :: 28
REQUEST_URI :: /cgi-bin/simple.cgi
QUERY_STRING ::
REQUEST_METHOD :: POST
&lt;STDIN&gt; :: this=that&amp;spam=eggs+are+good
</pre>
<P class="docText">The <TT>CONTENT_LENGTH</TT> environment variable is new, <TT>QUERY_STRING</TT> has become empty, and STDIN contains the query. The rest of the omitted variables are the same.</P>
<P class="docText">A CGI script need not utilize any query data and need not return an HTML page. For example, on some of my Web pages, I utilize a "Web bug"—a 1x1 transparent gif file that reports back who "looks" at it. Web bugs have a less-honorable use by spammers who send HTML mail and want to verify receipt covertly; but in my case, I only want to check some additional information about visitors to a few of my own Web pages. A Web page might contain, at bottom:</P>
<pre>
&lt;img src="http://gnosis.cx/cgi-bin/visitor.cgi"&gt;
</pre>
<P class="docText">The script itself is:</P>
<H5 class="docExampleTitle"><A NAME="ch05list09"></A> visitor.cgi</H5>

<PRE>
#!/usr/bin/python
import os
from sys import stdout
addr = os.environ.get("REMOTE_ADDR","Unknown IP Address")
agent = os.environ.get("HTTP_USER_AGENT","No Known Browser")
fp = open('visitor.log','a')
fp.write('%s\t%s\n' % (addr, agent))
fp.close()
stdout.write("Content-type: image/gif\n\n")
stdout.write('GIF89a\001\000\001\000\370\000\000\000\000\000')
stdout.write('\000\000\000!\371\004\001\000\000\000\000,\000')
stdout.write('\000\000\000\001\000\001\000\000\002\002D\001\000;')
</PRE>
<A NAME="ch05lev3sec25"></A><H5 class="docSection3Title"> CLASSES</H5>
<P class="docText">The point where the <span class="docEmphasis"><TT>cgi</TT></span> module becomes useful is in automating form processing. The class <span class="docEmphasis"><TT>cgi.FieldStorage</TT></span> will determine the details of whether a POST or GET request was made, and decode the urlencoded query into a dictionary-like object. You could perform these checks manually, but <span class="docEmphasis"><TT>cgi</TT></span> makes it much easier to do.</P>
<A NAME="ch05lev4sec109"></A><H5 class="docSection4Title"> cgi.FieldStorage([fp=sys.stdin [,headers [,ob [,environ=os.environ [,keep_blank_values=0 [,strict_parsing=0]]]]]])</H5>
<P class="docText">Construct a mapping object containing query information. You will almost always use the default arguments and construct a standard instance. A <span class="docEmphasis"><TT>cgi.FieldStorage</TT></span> object allows you to use name indexing and also supports several custom methods. On initialization, the object will determine all relevant details of the current CGI invocation.</P>
<pre>
import cgi
query = cgi.FieldStorage()
eggs = query.getvalue('eggs','default_eggs')
numfields = len(query)
if query.has_key('spam'):
    spam = query['spam']
[...]
</pre>
<P class="docText">When you retrieve a <span class="docEmphasis"><TT>cgi.FieldStorage</TT></span> value by named indexing, what you get is not a string, but either an instance of <span class="docEmphasis"><TT>cgi.FieldStorage</TT></span> objects (or maybe <span class="docEmphasis"><TT>cgi.MiniFieldStorage</TT></span>) or a list of such objects. The string query is in their <TT>.value</TT> attribute. Since HTML forms may contain multiple fields with the same name, multiple values might exist for a key—a list of such values is returned. The safe way to read the actual strings in queries is to check whether a list is returned:</P>
<pre>
if type(eggs) is type([]): # several eggs
    for egg in eggs:
        print "&lt;dt&gt;Egg&lt;/dt&gt;\n&lt;dd&gt;", egg.value, "&lt;/dd&gt;"
else:
    print "&lt;dt&gt;Eggs&lt;/dt&gt;\n&lt;dd&gt;", eggs.value, "&lt;/dd&gt;"
</pre>
<P class="docText">For special circumstances you might wish to change the initialization of the instance by specifying an optional (named) argument. The argument <TT>fp</TT> specifies the input stream to read for POST requests. The argument <TT>headers</TT> contains a dictionary mapping HTTP headers to values—usually consisting of <TT>{"Content-Type":...}</TT>; the type is determined from the environment if no argument is given. The argument <TT>environ</TT> specified where the environment mapping is found. If you specify a true value for <TT>keep_blank_values</TT>, a key will be included for a blank HTML form field—mapping to an empty string. If <TT>string_parsing</TT> is specified, a <TT>ValueError</TT> will be raised if there are any flaws in the query string.</P>
<A NAME="ch05lev3sec26"></A><H5 class="docSection3Title"> METHODS</H5>
<P class="docText">The methods <TT>.keys()</TT>, <TT>.values()</TT>, and <TT>.has_key()</TT> work as with a standard dictionary object. The method <TT>.items()</TT>, however, is not supported.</P>
<A NAME="ch05lev4sec110"></A><H5 class="docSection4Title"> cgi.FieldStorage.getfirst(key [,default=None])</H5>
<P class="docText">Python 2.2+ has this method to return exactly one string corresponding to the key <TT>key</TT>. You cannot rely on which such string value will be returned if multiple submitting HTML form fields have the same name—but you are assured of this method returning a string, not a list.</P>
<A NAME="ch05lev4sec111"></A><H5 class="docSection4Title"> cgi.FieldStorage.getlist(key [,default=None])</H5>
<P class="docText">Python 2.2+ has this method to return a list of strings whether there are one or several matches on the key <TT>key</TT>. This allows you to loop over returned values without worrying about whether they are a list or a single string.</P>
<pre>
&gt;&gt;&gt; spam = form.getlist('spam')
&gt;&gt;&gt; for s in spam:
...     print s
</pre>
<A NAME="ch05lev4sec112"></A><H5 class="docSection4Title"> cgi.FieldStorage.getvalue(key [,default=None])</H5>
<P class="docText">Return a string or list of strings that are the value(s) corresponding to the key <TT>key</TT>. If the argument <TT>default</TT> is specified, return the specified value in case of key miss. In contrast to indexing by name, this method retrieves actual strings rather than storage objects with a <TT>.value</TT> attribute.</P>
<pre>
&gt;&gt;&gt; import sys, cgi, os
&gt;&gt;&gt; from cStringIO import StringIO
&gt;&gt;&gt; sys.stdin = StringIO("this=that&amp;this=other&amp;spam=good+eggs")
&gt;&gt;&gt; os.environ['REQUEST_METHOD'] = 'POST'
&gt;&gt;&gt; form = cgi.FieldStorage()
&gt;&gt;&gt; form.getvalue('this')
['that', 'other']
&gt;&gt;&gt; form['this']
[MiniFieldStorage('this','that'),MiniFieldStorage('this','other')]
</pre>
<A NAME="ch05lev3sec27"></A><H5 class="docSection3Title"> ATTRIBUTES</H5>
<A NAME="ch05lev4sec113"></A><H5 class="docSection4Title"> cgi.FieldStorage.file</H5>
<P class="docText">If the object handled is an uploaded file, this attribute gives the file handle for the file. While you can read the entire file contents as a string from the <TT>cgi.FieldStorage.value</TT> attribute, you may want to read it line-by-line instead. To do this, use the <TT>.readline()</TT> or <TT>.readlines()</TT> method of the file object.</P>
<A NAME="ch05lev4sec114"></A><H5 class="docSection4Title"> cgi.FieldStorage.filename</H5>
<P class="docText">If the object handled is an uploaded file, this attribute contains the name of the file. An HTML form to upload a file looks something like:</P>
<pre>
&lt;form action="upload.cgi" method="POST"
      enctype="multipart/form-data"&gt;
  Name: &lt;input name="" type="file" size="50"&gt;
  &lt;input type="submit" value="Upload"&gt;
&lt;/form&gt;
</pre>
<P class="docText">Web browsers typically provide a point-and-click method to fill in a file-upload form.</P>
<A NAME="ch05lev4sec115"></A><H5 class="docSection4Title"> cgi.FieldStorage.list</H5>
<P class="docText">This attribute contains the list of mapping object within a <span class="docEmphasis"><TT>cgi.FieldStorage</TT></span> object. Typically, each object in the list is itself a <span class="docEmphasis"><TT>cgi.MiniStorage</TT></span> object instead (but this can be complicated if you upload files that themselves contain multiple parts).</P>
<pre>
&gt;&gt;&gt; form.list
[MiniFieldStorage('this', 'that'),
MiniFieldStorage('this', 'other'),
MiniFieldStorage('spam', 'good eggs')]
</pre>
<p class="docText"><span class="docEmphRoman">S<span class="docEmphSmaller">EE</span> A<span class="docEmphSmaller">LSO</span></span>: 
cgi.FieldStorage.getvalue() <span class="docEmphasis">380</span>;</p>
<A NAME="ch05lev4sec116"></A><H5 class="docSection4Title"> cgi.FieldStorage.value<br>cgi.MiniFieldStorage.value</H5>
<P class="docText">The string value of a storage object.</P>
<p class="docText"><span class="docEmphRoman">S<span class="docEmphSmaller">EE</span> A<span class="docEmphSmaller">LSO</span></span>: 
urllib <span class="docEmphasis">388</span>; cgitb <span class="docEmphasis">382</span>; dict <span class="docEmphasis">24</span>;</p>
<P><A NAME="ch05sb16"></A><TABLE CELLSPACING="0" WIDTH="90%" BORDER="1"><TR><TD>
<P class="docText"><span class="docEmphStrong">cgitb &#8226; Traceback manager for </span><span class="docEmphStrong">CGI</span> <span class="docEmphStrong">scripts</span></P></TD></TR></TABLE></P>
<P class="docText">Python 2.2 added a useful little module for debugging CGI applications. You can download it for earlier Python versions from <TT>&lt;</TT><A class="docLink" target="_blank" HREF="http://lfw.org/python/cgitb.py">http://lfw.org/python/cgitb.py</A><TT>&gt;</TT>. A basic difficulty with developing CGI scripts is that their normal output is sent to STDOUT, which is caught by the underlying Web server and forwarded to an invoking Web browser. However, when a traceback occurs due to a script error, that output is sent to STDERR (which is hard to get at in a CGI context). A more useful action is either to log errors to server storage or display them in the client browser.</P>
<P class="docText">Using the <span class="docEmphasis"><TT>cgitb</TT></span> module to examine CGI script errors is almost embarrassingly simple. At the top of your CGI script, simply include the lines:</P>
<H5 class="docExampleTitle"><A NAME="ch05list10"></A> Traceback enabled CGI script</H5>

<PRE>
import cgitb
cgitb.enable()
</PRE>
<P class="docText">If any exceptions are raised, a pretty-formatted report is produced (and possibly logged to a name starting with @).</P>
<A NAME="ch05lev3sec28"></A><H5 class="docSection3Title"> METHODS</H5>
<A NAME="ch05lev4sec117"></A><H5 class="docSection4Title"> cgitb.enable([display=1 [,logdir=None [context=5]]])</H5>
<P class="docText">Turn on traceback reporting. The argument <TT>display</TT> controls whether an error report is sent to the browser—you might not want this to happen in a production environment, since users will have little idea what to make of such a report (and there may be security issues in letting them see it). If <TT>logdir</TT> is specified, tracebacks are logged into files in that directory. The argument <TT>context</TT> indicates how many lines of code are displayed surrounding the point where an <TT>error</TT> occurred.</P>
<P class="docText">For earlier versions of Python, you will have to do your own error catching. A simple approach is:</P>
<H5 class="docExampleTitle"><A NAME="ch05list11"></A> Debugging CGI script in Python</H5>

<PRE>
import sys
sys.stderr = sys.stdout
def main():
    import cgi
    # ...do the actual work of the CGI...
    # perhaps ending with:
    print template % script_dictionary
print "Content-type: text/html\n\n"
main()
</PRE>
<P class="docText">This approach is not bad for quick debugging; errors go back to the browser. Unfortunately, though, the traceback (if one occurs) gets displayed as HTML, which means that you need to go to "View Source" in a browser to see the original line breaks in the traceback. With a few more lines, we can add a little extra sophistication.</P>
<H5 class="docExampleTitle"><A NAME="ch05list12"></A> Debugging/logging CGI script in Python</H5>

<PRE>
import sys, traceback
print "Content-type: text/html\n\n"
try:               # use explicit exception handling
    import my_cgi  # main CGI functionality in 'my_cgi.py'
    my_cgi.main()
except:
    import time
    errtime = '--- '+ time.ctime(time.time()) +' ---\n'
    errlog = open('cgi_errlog', 'a')
    errlog.write(errtime)
    traceback.print_exc(None, errlog)
    print "&lt;html&gt;\n&lt;head&gt;"
    print "&lt;title&gt;CGI Error Encountered!&lt;/title&gt;\n&lt;/head&gt;"
    print "&lt;body&gt;&lt;p&gt;A problem was encountered running MyCGI&lt;/p&gt;"
    print "&lt;p&gt;Please check the server error log for details&lt;/p&gt;"
    print "&lt;/body&gt;&lt;/html&gt;"
</PRE>
<P class="docText">The second approach is quite generic as a wrapper for any real CGI functionality we might write. Just <TT>import</TT> a different CGI module as needed, and maybe make the error messages more detailed or friendlier.</P>
<p class="docText"><span class="docEmphRoman">S<span class="docEmphSmaller">EE</span> A<span class="docEmphSmaller">LSO</span></span>: 
cgi <span class="docEmphasis">376</span>;</p>
<A NAME="ch05lev2sec5"></A><H4 class="docSection2Title">5.2.2 Parsing, Creating, and Manipulating HTML Documents</H4>
<P><A NAME="ch05sb17"></A><TABLE CELLSPACING="0" WIDTH="90%" BORDER="1"><TR><TD>
<P class="docText"><span class="docEmphStrong">htmlentitydefs &#8226; </span><span class="docEmphStrong">HTML</span> <span class="docEmphStrong">character entity references</span></P></TD></TR></TABLE></P>
<P class="docText">The module <span class="docEmphasis"><TT>htmlentitydefs</TT></span> provides a mapping between ISO-8859-1 characters and the symbolic names of corresponding HTML 2.0 entity references. Not all HTML named entities have equivalents in the ISO-8859-1 character set; in such cases, names are mapped the HTML numeric references instead.</P>
<A NAME="ch05lev3sec29"></A><H5 class="docSection3Title"> ATTRIBUTES</H5>
<A NAME="ch05lev4sec118"></A><H5 class="docSection4Title"> htmlentitydefs.entitydefs</H5>
<P class="docText">A dictionary mapping symbolic names to character entities.</P>
<pre>
&gt;&gt;&gt; import htmlentitydefs
&gt;&gt;&gt; htmlentitydefs.entitydefs['omega']
'&amp;#969;'
&gt;&gt;&gt; htmlentitydefs.entitydefs['uuml']
'\xfc'
</pre>
<P class="docText">For some purposes, you might want a reverse dictionary to find the HTML entities for ISO-8859-1 characters.</P>
<pre>
&gt;&gt;&gt; from htmlentitydefs import entitydefs
&gt;&gt;&gt; iso8859_1 = dict([(v,k) for k,v in entitydefs.items()])
&gt;&gt;&gt; iso8859_1['\xfc']
'uuml'
</pre>
<P><A NAME="ch05sb18"></A><TABLE CELLSPACING="0" WIDTH="90%" BORDER="1"><TR><TD>
<P class="docText"><span class="docEmphStrong">HTMLParser &#8226; Simple </span><span class="docEmphStrong">HTML</span> <span class="docEmphStrong">and XHTML parser</span></P></TD></TR></TABLE></P>
<P class="docText">The module <span class="docEmphasis"><TT>HTMLParser</TT></span> is an event-based framework for processing HTML files. In contrast to <span class="docEmphasis"><TT>htmllib</TT></span>, which is based on <span class="docEmphasis"><TT>sgmllib</TT>, <TT>HTMLParser</TT></span> simply uses some regular expressions to identify the parts of an HTML document—starttag, text, endtag, comment, and so on. The different internal implementation, however, makes little difference to users of the modules.</P>
<P class="docText">I find the module <span class="docEmphasis"><TT>HTMLParser</TT></span> much more straightforward to use than <span class="docEmphasis"><TT>htmllib</TT></span>, and therefore <span class="docEmphasis"><TT>HTMLParser</TT></span> is documented in detail in this book, while <span class="docEmphasis"><TT>htmllib</TT></span> is not. While <span class="docEmphasis"><TT>htmllib</TT></span> more or less <span class="docEmphasis">requires</span> the use of the ancillary module <span class="docEmphasis"><TT>formatter</TT></span> to operate, there is no extra difficultly in letting <span class="docEmphasis"><TT>HTMLParser</TT></span> make calls to a formatter object. You might want to do this, for example, if you have an existing formatter/writer for a complex document format.</P>
<P class="docText">Both <span class="docEmphasis"><TT>HTMLParser</TT></span> and <span class="docEmphasis"><TT>htmllib</TT></span> provide an interface that is very similar to that of <TT>SAX</TT> or <TT>expat</TT> XML parsers. That is, a document—HTML or XML—is processed purely as a sequence of events, with no data structure created to represent the document as a whole. For XML documents, another processing API is the Document Object Model (DOM), which treats the document as an in-memory hierarchical data structure.</P>
<P class="docText">In principle, you could use <span class="docEmphasis"><TT>xml.sax</TT></span> or <span class="docEmphasis"><TT>xml.dom</TT></span> to process HTML documents that conformed with XHTML—that is, tightened up HTML that is actually an XML application The problem is that very little existing HTML is XHTML compliant. A syntactic issue is that HTML does not require closing tags in many cases, where XML/XHTML requires every tag to be closed. But implicit closing tags can be inferred from subsequent opening tags (e.g., with certain names). A popular tool like <TT>tidy</TT> does an excellent job of cleaning up HTML in this way. The more significant problem is semantic. A whole lot of actually existing HTML is quite lax about tag matching—Web browsers that successfully display the majority of Web pages are quite complex software projects.</P>
<P class="docText">For example, a snippet like that below is quite likely to occur in HTML you come across:</P>
<pre>
&lt;p&gt;The &lt;a href="http://ietf.org"&gt;IETF admonishes:
   &lt;i&gt;Be lenient in what you &lt;b&gt;accept&lt;/i&gt;&lt;/a&gt;.&lt;/b&gt;
</pre>
<P class="docText">If you know even a little HTML, you know that the author of this snippet presumably wanted the whole quote in italics, the word <TT>accept</TT> in bold. But converting the snippet into a data structure such as a DOM object is difficult to generalize. Fortunately, <span class="docEmphasis"><TT>HTMLParser</TT></span> is fairly lenient about what it will process; however, for sufficiently badly formed input (or any other problem), the module will raise the exception <TT>HTMLParser.HTMLParseError</TT>.</P>
<p class="docText"><span class="docEmphRoman">S<span class="docEmphSmaller">EE</span> A<span class="docEmphSmaller">LSO</span></span>: 
htmllib <span class="docEmphasis">285</span>; xml.sax <span class="docEmphasis">405</span>;</p>
<A NAME="ch05lev3sec30"></A><H5 class="docSection3Title"> CLASSES</H5>
<A NAME="ch05lev4sec119"></A><H5 class="docSection4Title"> HTMLParser.HTMLParser()</H5>
<P class="docText">The <span class="docEmphasis"><TT>HTMLParser</TT></span> module contains the single class <span class="docEmphasis"><TT>HTMLParser.HTMLParser</TT></span>. The class itself is fairly useful, since it does not actually do anything when it encounters any event. Utilizing <span class="docEmphasis"><TT>HTMLParser.HTMLParser()</TT></span> is a matter of subclassing it and providing methods to handle the events you are interested in.</P>
<P class="docText">If it is important to keep track of the structural position of the current event within the document, you will need to maintain a data structure with this information. If you are certain that the document you are processing is well-formed XHTML, a stack suffices. For example:</P>
<H5 class="docExampleTitle"><A NAME="ch05list13"></A> HTMLParser_stack.py</H5>

<PRE>
#!/usr/bin/env python
import HTMLParser
html = """&lt;html&gt;&lt;head&gt;&lt;title&gt;Advice&lt;/title&gt;&lt;/head&gt;&lt;body&gt;
&lt;p&gt;The &lt;a href="http://ietf.org"&gt;IETF admonishes:
   &lt;i&gt;Be strict in what you &lt;b&gt;send&lt;/b&gt;.&lt;/i&gt;&lt;/a&gt;&lt;/p&gt;
&lt;/body&gt;&lt;/html&gt;
"""
tagstack = []
class ShowStructure(HTMLParser.HTMLParser):
    def handle_starttag(self, tag, attrs): tagstack.append(tag)
    def handle_endtag(self, tag): tagstack.pop()
    def handle_data(self, data):
        if data.strip():
            for tag in tagstack: sys.stdout.write('/'+tag)
            sys.stdout.write(' &gt;&gt; %s\n' % data[:40].strip())
ShowStructure().feed(html)
</PRE>
<P class="docText">Running this optimistic parser produces:</P>
<pre>
% ./HTMLParser_stack.py
/html/head/title &gt;&gt; Advice
/html/body/p &gt;&gt; The
/html/body/p/a &gt;&gt; IETF admonishes:
/html/body/p/a/i &gt;&gt; Be strict in what you
/html/body/p/a/i/b &gt;&gt; send
/html/body/p/a/i &gt;&gt; .
</pre>
<P class="docText">You could, of course, use this context information however you wished when processing a particular bit of content (or when you process the tags themselves).</P>
<P class="docText">A more pessimistic approach is to maintain a "fuzzy" tagstack. We can define a new object that will remove the most recent starttag corresponding to an endtag and will also prevent <TT>&lt;p&gt;</TT> and <TT>&lt;blockquote&gt;</TT> tags from nesting if no corresponding endtag is found. You could do more along this line for a production application, but a class like <TT>TagStack</TT> makes a good start:</P>
<pre>
class TagStack:
    def __init__(self, lst=[]): self.lst  = lst
    def __getitem__(self, pos): return self.lst[pos]
    def append(self, tag):
        # Remove every paragraph-level tag if this is one
        if tag.lower() in ('p','blockquote'):
            self.lst = [t for t in self.lst
                          if t not in ('p','blockquote')]
        self.lst.append(tag)
    def pop(self, tag):
        # "Pop" by tag from nearest pos, not only last item
        self.lst.reverse()
        try:
            pos = self.lst.index(tag)
        except ValueError:
            raise HTMLParser.HTMLParseError, "Tag not on stack"
        del self.lst[pos]
        self.lst.reverse()
tagstack = TagStack()
</pre>
<P class="docText">This more lenient stack structure suffices to parse badly formatted HTML like the example given in the module discussion.</P>
<A NAME="ch05lev3sec31"></A><H5 class="docSection3Title"> METHODS AND ATTRIBUTES</H5>
<A NAME="ch05lev4sec120"></A><H5 class="docSection4Title"> HTMLParser.HTMLParser.close()</H5>
<P class="docText">Close all buffered data, and treat any current data as if an EOF was encountered.</P>
<A NAME="ch05lev4sec121"></A><H5 class="docSection4Title"> HTMLParser.HTMLParser.feed(data)</H5>
<P class="docText">Send some additional HTML data to the parser instance from the string in the argument <TT>data</TT>. You may feed the instance with whatever size chunks of data you wish, and each will be processed, maintaining the previous state.</P>
<A NAME="ch05lev4sec122"></A><H5 class="docSection4Title"> HTMLParser.HTMLParser.getpos()</H5>
<P class="docText">Return the current line number and offset. Generally called within a <TT>.handle_*(</TT>) method to report or analyze the state of the processing of the HTML text.</P>
<A NAME="ch05lev4sec123"></A><H5 class="docSection4Title"> HTMLParser.HTMLParser.handle_charref(name)</H5>
<P class="docText">Method called when a character reference is encountered, such as <TT>&amp;#971;</TT>. Character references may be interspersed with element text, much as with entity references. You can construct a Unicode character from a character reference, and you may want to pass the Unicode (or raw character reference) to <span class="docEmphasis"><TT>HTMLParser.HTMLParser.handle_data()</TT></span>.</P>
<pre>
class CharacterData(HTMLParser.HTMLParser):
    def handle_charref(self, name):
        import unicodedata
        char = unicodedata.name(unichr(int(name)))
        self.handle_data(char)
    [...other methods...]
</pre>
<A NAME="ch05lev4sec124"></A><H5 class="docSection4Title"> HTMLParser.HTMLParser.handle_comment(data)</H5>
<P class="docText">Method called when a comment is encountered. HTML comments begin with <TT>&lt;!---</TT> and end with <TT>---&gt;</TT>. The argument <TT>data</TT> contains the contents of the comment.</P>
<A NAME="ch05lev4sec125"></A><H5 class="docSection4Title"> HTMLParser.HTMLParser.handle_data(data)</H5>
<P class="docText">Method called when content data is encountered. All the text between tags is contained in the argument <TT>data</TT>, but if character or entity references are interspersed with text, the respective handler methods will be called in an interspersed fashion.</P>
<A NAME="ch05lev4sec126"></A><H5 class="docSection4Title"> HTMLParser.HTMLParser.handle_decl(data)</H5>
<P class="docText">Method called when a declaration is encountered. HTML declarations with <TT>&lt;</TT>! and end with <TT>&gt;</TT>. The argument <TT>data</TT> contains the contents of the comment. Syntactically, comments look like a type of declaration, but are handled by the <span class="docEmphasis"><TT>HTMLParser.HTMLParser.handle_comment()</TT></span> method.</P>
<A NAME="ch05lev4sec127"></A><H5 class="docSection4Title"> HTMLParser.HTMLParser.handle_endtag(tag)</H5>
<P class="docText">Method called when an endtag is encountered. The argument <TT>tag</TT> contains the tag name (without brackets).</P>
<A NAME="ch05lev4sec128"></A><H5 class="docSection4Title"> HTMLParser.HTMLParser.handle_entityref(name)</H5>
<P class="docText">Method called when an entity reference is encountered, such as <TT>&amp;amp;</TT>. When entity references occur in the middle of an element text, calls to this method are interspersed with calls to <span class="docEmphasis"><TT>HTMLParser.HTMLParser.handle_data()</TT></span>. In many cases, you will want to call the latter method with decoded entities; for example:</P>
<pre>
class EntityData(HTMLParser.HTMLParser):
    def handle_entityref(self, name):
        import htmlentitydefs
        self.handle_data(htmlentitydefs.entitydefs[name])
    [...other methods...]
</pre>
<A NAME="ch05lev4sec129"></A><H5 class="docSection4Title"> HTMLParser.HTMLParser.handle_pi(data)</H5>
<P class="docText">Method called when a processing instruction (PI) is encountered. PIs begin with <TT>&lt;?</TT> and end with <TT>?&gt;</TT>. They are less common in HTML than in XML, but are allowed. The argument <TT>data</TT> contains the contents of the PI.</P>
<A NAME="ch05lev4sec130"></A><H5 class="docSection4Title"> HTMLParser.HTMLParser.handle_startendtag(tag, attrs)</H5>
<P class="docText">Method called when an XHTML-style empty tag is encountered, such as:</P>
<pre>
&lt;img src="foo.png" alt="foo"/&gt;
</pre>
<P class="docText">The arguments <TT>tag</TT> and <TT>attrs</TT> are identical to those passed to <span class="docEmphasis"><TT>HTMLParser.HTMLParser.handle_starttag()</TT></span>.</P>
<A NAME="ch05lev4sec131"></A><H5 class="docSection4Title"> HTMLParser.HTMLParser.handle_starttag(tag, attrs)</H5>
<P class="docText">Method called when a starttag is encountered. The argument <TT>tag</TT> contains the tag name (without brackets), and the argument <TT>attrs</TT> contains the tag attributes as a list of pairs, such as <TT>[(''href'',"http://ietf.org)]</TT>.</P>
<A NAME="ch05lev4sec132"></A><H5 class="docSection4Title"> HTMLParser.HTMLParser.lasttag</H5>
<P class="docText">The last tag—start or end—that was encountered. Generally maintaining some sort of stack structure like those discussed is more useful. But this attribute is available automatically. You should treat it as read-only.</P>
<A NAME="ch05lev4sec133"></A><H5 class="docSection4Title"> HTMLParser.HTMLParser.reset()</H5>
<P class="docText">Restore the instance to its initial state, lose any unprocessed data (for example, content within unclosed tags).</P>
<A NAME="ch05lev2sec6"></A><H4 class="docSection2Title">5.2.3 Accessing Internet Resources</H4>
<P><A NAME="ch05sb19"></A><TABLE CELLSPACING="0" WIDTH="90%" BORDER="1"><TR><TD>
<P class="docText"><span class="docEmphStrong">urllib &#8226; Open an arbitrary </span><span class="docEmphStrong">URL</span></P></TD></TR></TABLE></P>
<P class="docText">The module <span class="docEmphasis"><TT>urllib</TT></span> provides convenient, high-level access to resources on the Internet. While <span class="docEmphasis"><TT>urllib</TT></span> lets you connect to a variety of protocols, to manage low-level details of connections—especially issues of complex authentication—you should use the module <span class="docEmphasis"><TT>urllib2</TT></span> instead. However, <span class="docEmphasis"><TT>urllib</TT> does</span> provide hooks for HTTP basic authentication.</P>
<P class="docText">The interface to <span class="docEmphasis"><TT>urllib</TT></span> objects is file-like. You can substitute an object representing a URL connection for almost any function or class that expects to work with a read-only file. All of the World Wide Web, File Transfer Protocol (FTP) directories, and gopherspace can be treated, almost transparently, as if it were part of your local filesystem.</P>
<P class="docText">Although the module provides two classes that can be utilized or subclassed for more fine-tuned control, generally in practice the function <span class="docEmphasis"><TT>urllib.urlopen()</TT></span> is the only interface you need to the <span class="docEmphasis"><TT>urllib</TT></span> module.</P>
<A NAME="ch05lev3sec32"></A><H5 class="docSection3Title"> FUNCTIONS</H5>
<A NAME="ch05lev4sec134"></A><H5 class="docSection4Title"> urllib.urlopen(url [,data])</H5>
<P class="docText">Return a file-like object that connects to the Uniform Resource Locator (URL) resource named in <TT>url</TT>. This resource may be an HTTP, FTP, Gopher, or local file. The optional argument <TT>data</TT> can be specified to make a POST request to an HTTP URL. This data is a urlencoded string, which may be created by the <span class="docEmphasis"><TT>urllib.urlencode()</TT></span> method. If no <TT>postdata</TT> is specified with an HTTP URL, the GET method is used.</P>
<P class="docText">Depending on the type of resource specified, a slightly different class is used to construct the instance, but each provides the methods: <TT>.read()</TT>, <TT>.readline()</TT>, <TT>.readlines()</TT>, <TT>.fileno()</TT>, <TT>.close()</TT>, <TT>.info()</TT>, and <TT>.geturl()</TT> (but not <TT>.xreadlines()</TT>, <TT>.seek()</TT>, or <TT>.tell())</TT>.</P>
<P class="docText">Most of the provided methods are shared by file objects, and each provides the same interface—arguments and return values—as actual file objects. The method <TT>.geturl()</TT> simply contains the URL that the object connects to, usually the same string as the <TT>url</TT> argument.</P>
<P class="docText">The method <TT>.info()</TT> returns <span class="docEmphasis"><TT>mimetools.Message</TT></span> object. While the <span class="docEmphasis"><TT>mimetools</TT></span> module is not documented in detail in this book, this object is generally similar to an <span class="docEmphasis"><TT>email.Message.Message</TT></span> object—specifically, it responds to both the built-in <span class="docEmphasis"><TT>str()</TT></span> function and dictionary-like indexing:</P>
<pre>
&gt;&gt;&gt; u = urllib.urlopen('urlopen.py')
&gt;&gt;&gt; print 'u.info() '
&lt;mimetools.Message instance at 0x62f800&gt;
&gt;&gt;&gt; print u.info()
Content-Type: text/x-python
Content-Length: 577
Last-modified: Fri, 10 Aug 2001 06:03:04 GMT

&gt;&gt;&gt; u.info().keys()
['last-modified', 'content-length', 'content-type']
&gt;&gt;&gt; u. info() ['content-type']
'text/x-python'
</pre>
<p class="docText"><span class="docEmphRoman">S<span class="docEmphSmaller">EE</span> A<span class="docEmphSmaller">LSO</span></span>: 
urllib.urlretrieve() <span class="docEmphasis">390</span>; urllib.urlencode() <span class="docEmphasis">390</span>;</p>
<A NAME="ch05lev4sec135"></A><H5 class="docSection4Title"> urllib.urlretrieve(url [,fname [,reporthook [,data]]])</H5>
<P class="docText">Save the resources named in the argument <TT>url</TT> to a local file. If the optional argument <TT>fname</TT> is specified, that filename will be used; otherwise, a unique temporary filename is generated. The optional argument <TT>data</TT> may contain a urlencoded string to pass to an HTTP POST request, as with <span class="docEmphasis"><TT>urllib.urlopen()</TT></span>.</P>
<P class="docText">The optional argument <TT>reporthook</TT> may be used to specify a callback function, typically to implement a progress meter for downloads. The function <TT>reporthook()</TT> will be called repeatedly with the arguments <TT>bl_transferred</TT>, <TT>bl_size</TT>, and file_size. Even remote files smaller than the block size will typically call <TT>reporthook()</TT> a few times, but for larger files, <TT>file_size</TT> will <span class="docEmphasis">approximately</span> equal <TT>bl_transferred*bl_size</TT>.</P>
<P class="docText">The return value of <span class="docEmphasis"><TT>urllib.urlretrieve()</TT></span> is a pair <TT>(fname, info)</TT>. The returned <TT>fname</TT> is the name of the created file—the same as the <TT>fname</TT> argument if it was specified. The <TT>info</TT> return value is a <span class="docEmphasis"><TT>mimetools.Message</TT></span> object, like that returned by the <TT>.info()</TT> method of a <span class="docEmphasis"><TT>urllib.urlopen</TT></span> object.</P>
<p class="docText"><span class="docEmphRoman">S<span class="docEmphSmaller">EE</span> A<span class="docEmphSmaller">LSO</span></span>: 
urllib.urlopen() <span class="docEmphasis">389</span>; urllib.urlencode() <span class="docEmphasis">390</span>;</p>
<A NAME="ch05lev4sec136"></A><H5 class="docSection4Title"> urllib.quote(s [,safe="/"])</H5>
<P class="docText">Return a string with special characters escaped. Exclude any characters in the string safe for being quoted.</P>
<pre>
&gt;&gt;&gt; urllib.quote('/<SUP>~</SUP>username/special&amp;odd!')
'/%7Eusername/special%26odd%21'
</pre>
<A NAME="ch05lev4sec137"></A><H5 class="docSection4Title"> urllib.quote_plus(s [,safe="/"])</H5>
<P class="docText">Same as <span class="docEmphasis"><TT>urllib.quote()</TT></span>, but encode spaces as + also.</P>
<A NAME="ch05lev4sec138"></A><H5 class="docSection4Title"> urllib.unquote(s)</H5>
<P class="docText">Return an unquoted string. Inverse operation of <span class="docEmphasis"><TT>urllib.quote()</TT></span>.</P>
<A NAME="ch05lev4sec139"></A><H5 class="docSection4Title"> urllib.unquote_plus(s)</H5>
<P class="docText">Return an unquoted string. Inverse operation of <span class="docEmphasis"><TT>urllib.quote_plus()</TT></span>.</P>
<A NAME="ch05lev4sec140"></A><H5 class="docSection4Title"> urllib.urlencode(query)</H5>
<P class="docText">Return a urlencoded query for an HTTP POST or GET request. The argument <TT>query</TT> may be either a dictionary-like object or a sequence of pairs. If pairs are used, their order is preserved in the generated query.</P>
<pre>
&gt;&gt;&gt; query = urllib.urlencode([('hl','en'),
...                           ('q','Text Processing in Python')])
&gt;&gt;&gt; print query
hl=en&amp;q=Text+Processing+in+Python
&gt;&gt;&gt; u = urllib.urlopen('http://google.com/search?'+query)
</pre>
<P class="docText">Notice, however, that at least as of the moment of this writing, Google will refuse to return results on this request because a Python shell is not a recognized browser (Google provides a SOAP interface that is more lenient, however). You <span class="docEmphasis">could,</span> but <span class="docEmphasis">should not,</span> create a custom <span class="docEmphasis"><TT>urllib</TT></span> class that spoofed an accepted browser.</P>
<A NAME="ch05lev3sec33"></A><H5 class="docSection3Title"> CLASSES</H5>
<P class="docText">You can change the behavior of the basic <span class="docEmphasis"><TT>urllib.urlopen()</TT></span> and <span class="docEmphasis"><TT>urllib.urlretrieve()</TT></span> functions by substituting your own class into the module namespace. Generally this is the best way to use <span class="docEmphasis"><TT>urllib</TT></span> classes:</P>
<pre>
import urllib
class MyOpener(urllib.FancyURLopener):
    pass
urllib._urlopener = MyOpener()
u = urllib.urlopen("http://some.url") # uses custom class
</pre>
<A NAME="ch05lev4sec141"></A><H5 class="docSection4Title"> urllib.URLopener([proxies [,**x509]])</H5>
<P class="docText">Base class for reading URLs. Generally you should subclass from the class <span class="docEmphasis"><TT>urllib.FancyURLopener</TT></span> unless you need to implement a nonstandard protocol from scratch.</P>
<P class="docText">The argument <TT>proxies</TT> may be specified with a mapping if you need to connect to resources through a proxy. The keyword arguments may be used to configure HTTPS authentication; specifically, you should give named arguments <TT>key_file</TT> and <TT>cert_file</TT> in this case.</P>
<pre>
import urllib
proxies = {'http':'http://192.168.1.1','ftp':'ftp://192.168.256.1'}
urllib._urlopener = urllib.URLopener(proxies, key_file='mykey',
                                     cert_file='mycert')
</pre>
<A NAME="ch05lev4sec142"></A><H5 class="docSection4Title"> urllib.FancyURLopener([proxies [,**x509]])</H5>
<P class="docText">The optional initialization arguments are the same as for <span class="docEmphasis"><TT>urllib.URLopener</TT></span>, unless you subclass further to use other arguments. This class knows how to handle 301 and 302 HTTP redirect codes, as well as 401 authentication requests. The class <span class="docEmphasis"><TT>urllib.FancyURLopener</TT></span> is the one actually used by the <span class="docEmphasis"><TT>urllib</TT></span> module, but you may subclass it to add custom capabilities.</P>
<A NAME="ch05lev3sec34"></A><H5 class="docSection3Title"> METHODS AND ATTRIBUTES</H5>
<A NAME="ch05lev4sec143"></A><H5 class="docSection4Title"> urllib.URLFancyopener.get_user_passwd(host, realm)</H5>
<P class="docText">Return the pair <TT>(user,passwd)</TT> to use for authentication. The default implementation calls the method <TT>.prompt_user_passwd()</TT> in turn. In a subclass you might want to either provide a GUI login interface or obtain authentication information from some other source, such as a database.</P>
<A NAME="ch05lev4sec144"></A><H5 class="docSection4Title"> urllib.URLopener.open(url [,data])<br>urllib.URLFancyopener.open(url [,data])</H5>
<P class="docText">Open the URL <TT>url</TT>, optionally using HTTP POST query <TT>data</TT>.</P>
<p class="docText"><span class="docEmphRoman">S<span class="docEmphSmaller">EE</span> A<span class="docEmphSmaller">LSO</span></span>: 
urllib.urlopen() <span class="docEmphasis">389</span>;</p>
<A NAME="ch05lev4sec145"></A><H5 class="docSection4Title"> urllib.URLopener.open_unknown (url [,data])<br>urllib.URLFancyopener.open_unknown (url [,data])</H5>
<P class="docText">If the scheme is not recognized, the <TT>.open()</TT> method passes the request to this method. You can implement error reporting or fallback behavior here.</P>
<A NAME="ch05lev4sec146"></A><H5 class="docSection4Title"> urllib.URLFancyopener.prompt_user_passwd(host, realm)</H5>
<P class="docText">Prompt for the authentication pair <TT>(user,passwd)</TT> at the terminal. You may override this to prompt within a GUI. If the authentication is not obtained interactively, but by other means, directly overriding <TT>.get_user_passwd()</TT> is more logical.</P>
<A NAME="ch05lev4sec147"></A><H5 class="docSection4Title"> urllib.URLopener.retrieve(url [,fname [,reporthook [,data]]])<br>urllib.URLFancyopener.retrieve(url [,fname [,reporthook [,data]]])</H5>
<P class="docText">Copies the URL <TT>url</TT> to the local file named <TT>fname</TT>. Callback to the progress function <TT>reporthook</TT> if specified. Use the optional HTTP POST query data in <TT>data</TT>.</P>
<p class="docText"><span class="docEmphRoman">S<span class="docEmphSmaller">EE</span> A<span class="docEmphSmaller">LSO</span></span>: 
urllib.urlretrieve() <span class="docEmphasis">390</span>;</p>
<A NAME="ch05lev4sec148"></A><H5 class="docSection4Title"> urllib.URLopener.version<br>urllib.URFancyLopener.version</H5>
<P class="docText">The User Agent string reported to a server is contained in this attribute. By default it is <TT>urllib/###</TT>, where the <span class="docEmphasis"><TT>urllib</TT></span> version number is used rather than <TT>###</TT>.</P>
<P><A NAME="ch05sb20"></A><TABLE CELLSPACING="0" WIDTH="90%" BORDER="1"><TR><TD>
<P class="docText"><span class="docEmphStrong">urlparse &#8226; Parse Uniform Resource Locators</span></P></TD></TR></TABLE></P>
<P class="docText">The module <span class="docEmphasis"><TT>urlparse</TT></span> support just one fairly simple task, but one that is just complicated enough for quick implementations to get wrong. URLs describe a number of aspects of resources on the Internet: access protocol, network location, path, parameters, query, and fragment. Using <span class="docEmphasis"><TT>urlparse</TT></span>, you can break out and combine these components to manipulate or generate URLs. The format of URLs is based on RFC-1738, RFC-1808, and RFC-2396.</P>
<P class="docText">Notice that the <span class="docEmphasis"><TT>urlparse</TT></span> module does not parse the components of the network location, but merely returns them as a field. For example, the URL <TT>ftp://guest:gnosis@192.168.1.102:21//tmp/MAIL.MSG</TT> is a valid identifier on my local network (at least at the moment this is written). Tools like Mozilla and wget are happy to retrieve this file. Parsing this fairly complicated URL with <span class="docEmphasis"><TT>urlparse</TT></span> gives us:</P>
<pre>
&gt;&gt;&gt; import urlparse
&gt;&gt;&gt; url = 'ftp://guest:gnosis@192.168.1.102:21//tmp/MAIL.MSG'
&gt;&gt;&gt; urlparse.urlparse(url)
('ftp', 'guest:gnosis@192.168.1.102:21', '//tmp/MAIL.MSG',
'', '', '',)
</pre>
<P class="docText">While this information is not incorrect, this network location itself contains multiple fields; all but the host are optional. The actual structure of a network location, using square bracket nesting to indicate optional components, is:</P>
<pre>
[user[:password]@]host[:port]
</pre>
<P class="docText">The following mini-module will let you further parse these fields:</P>
<H5 class="docExampleTitle"><A NAME="ch05list14"></A> location_parse.py</H5>

<PRE>
#!/usr/bin/env python
def location_parse(netloc):
    "Return tuple (user, passwd, host, port) for netloc"
    if '@' not in netloc:
        netloc = ':@' + netloc
    login, net = netloc.split('@')
    if ':' not in login:
        login += ':'
    user, passwd = login.split(':')
    if ':' not in net:
        net += ':'
    host, port = net.split(':')
    return (user, passwd, host, port)

#-- specify network location on command-line
if __name__=='__main__':
    import sys
    print location_parse(sys.argv[1])
</PRE>
<A NAME="ch05lev3sec35"></A><H5 class="docSection3Title"> FUNCTIONS</H5>
<A NAME="ch05lev4sec149"></A><H5 class="docSection4Title"> urlparse.urlparse(url [,def_scheme="" [,fragments=1]])</H5>
<P class="docText">Return a tuple consisting of six components of the URL <TT>url</TT>, <TT>(scheme, netloc, path, params, query, fragment)</TT>. A URL is assumed to follow the pattern <TT>scheme://netloc/path;params?query#fragment</TT>. If a default scheme <TT>def_scheme</TT> is specified, that string will be returned in case no scheme is encoded in the URL itself. If <TT>fragments</TT> is set to a false value, any fragments will not be split from other fields.</P>
<pre>
&gt;&gt;&gt; from urlparse import urlparse
&gt;&gt;&gt; urlparse('gnosis.cx/path/sub/file.html#sect', 'http', 1)
('http', '', 'gnosis.cx/path/sub/file.html', '', '', 'sect')
&gt;&gt;&gt; urlparse('gnosis.cx/path/sub/file.html#sect', 'http', 0)
('http', '', 'gnosis.cx/path/sub/file.html#sect', '', '', '')
&gt;&gt;&gt; urlparse('http://gnosis.cx/path/file.cgi?key=val#sect',
...          'gopher', 1)
('http', 'gnosis.cx', '/path/file.cgi', '' , 'key=val', 'sect')
&gt;&gt;&gt; urlparse('http://gnosis.cx/path/file.cgi?key=val#sect',
...          'gopher', 0)
('http', 'gnosis.cx', '/path/file.cgi', '', 'key=val#sect', '')
</pre>
<A NAME="ch05lev4sec150"></A><H5 class="docSection4Title"> urlparse.urlunparse(tup)</H5>
<P class="docText">Construct a URL from a tuple containing the fields returned by <span class="docEmphasis"><TT>urIparse.urlparse()</TT></span>. The returned URL has canonical form (redundancy eliminated) so <span class="docEmphasis"><TT>urlparse.urlparse()</TT></span> and <span class="docEmphasis"><TT>urlparse.urlunparse()</TT></span> are not precisely inverse operations; however, the composed <TT>urlunparse (urlparse (s))</TT> should be idempotent.</P>
<A NAME="ch05lev4sec151"></A><H5 class="docSection4Title"> urlparse.urljoin(base, file)</H5>
<P class="docText">Return a URL that has the same base path as <TT>base</TT> but has the file component <TT>file</TT>. For example:</P>
<pre>
&gt;&gt;&gt; from urlparse import urljoin
&gt;&gt;&gt; urljoin('http://somewhere.lan/path/file.html',
...                  'sub/other.html')
'http://somewhere.lan/path/sub/other.html'
</pre>
<P class="docText">In Python 2.2+ the functions <span class="docEmphasis"><TT>urlparse.urlsplit()</TT></span> and <span class="docEmphasis"><TT>urlparse.urlunsplit()</TT></span> are available. These differ from <span class="docEmphasis"><TT>urlparse.urlparse()</TT></span> and <span class="docEmphasis"><TT>urlparse.urlunparse()</TT></span> in returning a 5-tuple that does not split out <TT>params</TT> from <TT>path</TT>.</P>
<a href="0321112547_10061533.html"><img src="FILES/pixel.gif" width="1" height="1" border="0"></a><ul></ul></td></tr></table>
<td></td>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<td class="tt1"><a href="NFO/lib.html">[ Team LiB ]</a></td><td valign="top" class="tt1" align="right">
          <a href="0321112547_ch05lev1sec1.html"><img src="FILES/btn_prev.gif" width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a>
          <a href="0321112547_ch05lev1sec3.html"><img src="FILES/btn_next.gif" width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a>
</td></table>
</body></html>
