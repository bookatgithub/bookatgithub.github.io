<html><head>
<META http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<!--SafClassName="docSection1Title"--><!--SafTocEntry="5.4 Understanding XML"-->
<link rel="STYLESHEET" type="text/css" href="FILES/style.css">
<link rel="STYLESHEET" type="text/css" href="FILES/docsafari.css">
<style type="text/css">	.tt1    {font-size: 10pt;}</style>
</head>
<body>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<td class="tt1"><a href="NFO/lib.html">[ Team LiB ]</a></td><td valign="top" class="tt1" align="right">
	<a href="0321112547_ch05lev1sec3.html"><img src="FILES/btn_prev.gif" width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a>
	<a href="0321112547_app01.html"><img src="FILES/btn_next.gif" width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a>
</td></table>
<br>
<table width="100%" border="0" cellspacing="0" cellpadding="0"><tr><td valign="top"><A NAME="ch05lev1sec4"></A><H3 class="docSection1Title">5.4 Understanding XML</H3>
<P class="docText">Extensible Markup Language (XML) is a text format increasingly used for a wide variety of storage and transport requirements. Parsing and processing XML is an important element of many text processing applications. This section discusses the most common techniques for dealing with XML in Python. While XML held an initial promise of simplifying the exchange of complex and hierarchically organized data, it has itself grown into a standard of considerable complexity. This book will not cover most of the API details of XML tools; an excellent book dedicated to that subject is:</P>
<blockquote>
<p class="docText"><span class="docEmphasis">Python &amp; XML</span>, Christopher A. Jones &amp; Fred L. Drake, Jr., O'Reilly 2002. ISBN: 0-596-00128-2.</p></blockquote>
<P class="docText">The XML format is sufficiently rich to represent any structured data, some forms more straightforwardly than others. A task that XML is quite natural at is in representing marked-up text—documentation, books, articles, and the like—as is its parent SGML. But XML is probably used more often to represent <span class="docEmphasis">data</span> than texts—record sets, OOP data containers, and so on. In many of these cases, the fit is more awkward and requires extra verbosity. XML itself is more like a metalanguage than a language—there are a set of syntax constraints that any XML document must obey, but typically particular APIs and document formats are defined as XML <span class="docEmphasis">dialects.</span> That is, a dialect consists of a particular set of tags that are used within a type of document, along with rules for when and where to use those tags. What I refer to as an XML dialect is also sometimes more formally called "an <span class="docEmphasis">application</span> of XML."</P>
<A NAME="ch05lev3sec36"></A><H4 class="docSection2Title"> THE DATA MODEL</H4>
<P class="docText">At base, XML has two ways to represent data. Attributes in XML tags map names to values. Both names and values are Unicode strings (as are XML documents as a whole), but values frequently encode other basic datatypes, especially when specified in W3C XML Schemas. Attribute names are mildly restricted by the special characters used for XML markup; attribute values can encode any strings once a few characters are properly escaped. XML attribute values are whitespace normalized when parsed, but whitespace can itself also be escaped. A bare example is:</P>
<pre>
&gt;&gt;&gt; from xml.dom import minidom
&gt;&gt;&gt; x = '''&lt;x a="b" d="e f g" num="38" /&gt;'''
&gt;&gt;&gt; d = minidom.parseString(x)
&gt;&gt;&gt; d.firstChild.attributes.items()
[(u'a', u'b'), (u'num', u'38'), (u'd', u'e f g')]
</pre>
<P class="docText">As with a Python dictionary, no order is defined for the list of key/value attributes of one tag.</P>
<P class="docText">The second way XML represents data is by nesting tags inside other tags. In this context, a tag together with a corresponding "close tag" is called an <span class="docEmphasis">element</span>, and it may contain an ordered sequence of <span class="docEmphasis">subelements.</span> The subelements themselves may also contain nested subelements. A general term for any part of an XML document, whether an element, an attribute, or one of the special parts discussed below, is a "node." A simple example of an element that contains some subelements is:</P>
<pre>
&gt;&gt;&gt; x = '''&lt;?xml version="1.0" encoding="UTF-8"?&gt;
... &lt;root&gt;
...   &lt;a&gt;Some data&lt;/a&gt;
...   &lt;b data="more data" /&gt;
...   &lt;c data="a list"&gt;
...     &lt;d&gt;item 1&lt;/d&gt;
...     &lt;d&gt;item 2&lt;/d&gt;
...   &lt;/c&gt;
... &lt;/root&gt;'''
&gt;&gt;&gt; d = minidom.parseString(x)
&gt;&gt;&gt; d.normalize()
&gt;&gt;&gt; for node in d.documentElement.childNodes:
...     print node
...
&lt;DOM Text node "
  "&gt;
&lt;DOM Element: a at 7033280&gt;
&lt;DOM Text node "
  "&gt;
&lt;DOM Element: b at 7051088&gt;
&lt;DOM Text node "
  "&gt;
&lt;DOM Element: c at 7053696&gt;
&lt;DOM Text node "
"&gt;
&gt;&gt;&gt; d.documentElement.childNodes[3].attributes.items()
[(u'data', u'more data')]
</pre>
<P class="docText">There are several things to notice about the Python session above.</P>
<span style="font-weight:bold"><OL class="docList" TYPE="1"><LI><span style="font-weight:normal"><P class="docList">The "document element," named <TT>root</TT> in the example, contains three ordered subelement nodes, named <TT>a</TT>, <TT>b</TT>, and <TT>c</TT>.</P></span></LI><LI><span style="font-weight:normal"><P class="docList">Whitespace is preserved within elements. Therefore the spaces and newlines that come between the subelements make up several text nodes. Text and subelements can intermix, each potentially meaningful. Spacing in XML documents is significant, but it is nonetheless also often used for visual clarity (as above).</P></span></LI><LI><span style="font-weight:normal"><P class="docList">The example contains an XML declaration, <TT>&lt;?xml...?&gt;</TT>, which is optional but generally included.</P></span></LI><LI><span style="font-weight:normal"><P class="docList">Any given element may contain attributes <span class="docEmphasis">and</span> subelements <span class="docEmphasis">and</span> text data.</P></span></LI></OL></span>
<A NAME="ch05lev3sec37"></A><H4 class="docSection2Title"> OTHER XML FEATURES</H4>
<P class="docText">Besides regular elements and text nodes, XML documents can contain several kinds of "special" nodes. Comments are common and useful, especially in documents intended to be hand edited at some point (or even potentially). Processing instructions may indicate how a document is to be handled. Document type declarations may indicate expected validity rules for where elements and attributes may occur. A special type of node called CDATA lets you embed mini-XML documents or other special codes inside of other XML documents, while leaving markup untouched. Examples of each of these forms look like:</P>
<pre>
&lt;?xml version="1.0" ?&gt;
&lt;!DOCTYPE root SYSTEM "sometype.dtd"&gt;
&lt;root&gt;
&lt;!-- This is a comment --&gt;
This is text data inside the &amp;lt;root&amp;gt; element
&lt;![CDATA[Embedded (not well-formed) XML:
         &lt;this&gt;&lt;that&gt; &gt;&gt;string&lt;&lt; &lt;/that&gt;]]&gt;
&lt;/root&gt;
</pre>
<P class="docText">XML documents may be either "well-formed" or "valid." The first characterization simply indicates that a document obeys the proper syntactic rules for XML documents in general: All tags are either self-closed or followed by a matching endtag; reserved characters are escaped; tags are properly hierarchically nested; and so on. Of course, particular documents can also fail to be well-formed—but in that case they are not XML documents sensu stricto, but merely fragments or near-XML. A formal description of well-formed XML can be found at <TT>&lt;</TT><A class="docLink" target="_blank" HREF="http://www.w3.org/TR/REC-xml">http://www.w3.org/TR/REC-xml</A><TT>&gt;</TT> and <TT>&lt;</TT><A class="docLink" target="_blank" HREF="http://www.w3.org/TR/xml11/default.htm">http://www.w3.org/TR/xml11/</A><TT>&gt;</TT>.</P>
<P class="docText">Beyond well-formedness, some XML documents are also valid. Validity means that a document matches a further grammatical specification given in a Document Type Definition (DTD), or in an XML Schema. The most popular style of XML Schema is the W3C XML Schema specification, found in formal detail at <TT>&lt;</TT><A class="docLink" target="_blank" HREF="http://www.w3.org/TR/xmlschema-0/default.htm">http://www.w3.org/TR/xmlschema-0/</A><TT>&gt;</TT> and in linked documents. There are competing schema specifications, however—one popular alternative is RELAX NG, which is documented at <TT>&lt;</TT><A class="docLink" target="_blank" HREF="http://www.oasis-open.org/committees/relax-ng/default.htm">http://www.oasis-open.org/committees/relax-ng/</A><TT>&gt;</TT>.</P>
<P class="docText">The grammatical specifications indicated by DTDs are strictly structural. For example, you can specify that certain subelements must occur within an element, with a certain cardinality and order. Or, certain attributes may or must occur with a certain tag. As a simple case, the following DTD is one that the prior example of nested subelements would conform to. There are an infinite number of DTDs that the sample <span class="docEmphasis">could</span> match, but each one describes a slightly different <span class="docEmphasis">range</span> of valid XML documents:</P>
<pre>
&lt;!ELEMENT root ((a|OTHER-A)?, b, c*)&gt;
&lt;!ELEMENT a (#PCDATA)&gt;
&lt;!ELEMENT b EMPTY&gt;
&lt;!ATTLIST b data CDATA #REQUIRED
            NOT-THERE (this | that) #IMPLIED&gt;
&lt;!ELEMENT c (d+)&gt;
&lt;!ATTLIST c data CDATA #IMPLIED&gt;
&lt;!ELEMENT d (#PCDATA)&gt;
</pre>
<P class="docText">The W3C recommendation on the XML standard also formally specifies DTD rules. A few features of the above DTD example can be noted here. The element <TT>OTHER-A</TT> and the attribute <TT>NOT-THERE</TT> are permitted by this DTD, but were not utilized in the previous sample XML document. The quantifications <TT>?</TT>, <TT>*</TT>, and <TT>+</TT>; the alternation |; and the comma sequence operator have similar meaning as in regular expressions and BNF grammars. Attributes may be required or optional as well and may contain any of several specific value types; for example, the <TT>data</TT> attribute must contain any string, while the <TT>NOT-THERE</TT> attribute may contain <TT>this</TT> or <TT>that</TT> only.</P>
<P class="docText">Schemas go farther than DTDs, in a way. Beyond merely specifying that elements or attributes must contain strings describing particular datatypes, such as numbers or dates, schemas allow more flexible quantification of subelement occurrences. For example, the following W3C XML Schema might describe an XML document for purchases:</P>
<pre>
&lt;xsd:element name="item"&gt;
  &lt;xsd:complexType&gt;
    &lt;xsd:sequence&gt;
      &lt;xsd:element name="USPrice" type="xsd:decimal"/&gt;
      &lt;xsd:element name="shipDate" type="xsd:date"
                   minOccurs="0" maxOccurs=3 /&gt;
    &lt;/xsd:sequence&gt;
    &lt;xsd:attribute name="partNum" type="SKU"/&gt;
  &lt;/xsd:complexType&gt;
&lt;/xsd:element&gt;
&lt;!-- Stock Keeping Unit, a code for identifying products --&gt;
&lt;xsd:simpleType name="SKU"&gt;
   &lt;xsd:restriction base="xsd:string"&gt;
      &lt;xsd:pattern value="\d{3}-[A-Z]{2}"/&gt;
   &lt;/xsd:restriction&gt;
&lt;/xsd:simpleType&gt;
</pre>
<P class="docText">An XML document that is valid under this schema is:</P>
<pre>
&lt;item partNum="123-XQ"&gt;
  &lt;USPrice&gt;21.95&lt;/USPrice&gt;
  &lt;shipDate&gt;2002-11-26&lt;/shipDate&gt;
&lt;/item&gt;
</pre>
<P class="docText">Formal specifications of schema languages can be found at the above-mentioned URLs; this example is meant simply to illustrate the types of capabilities they have.</P>
<P class="docText">In order to check the validity of an XML document to a DTD or schema, you need to use a <span class="docEmphasis">validating parser.</span> Some stand-alone tools perform validation, generally with diagnostic messages in cases of invalidity. As well, certain libraries and modules support validation within larger applications. As a rule, however, <span class="docEmphasis">most</span> Python XML parsers are nonvalidating and check only for well-formedness.</P>
<P class="docText">Quite a number of technologies have been built on top of XML, many endorsed and specified by W3C, OASIS, or other standards groups. One in particular that you should be aware of is XSLT. There are a number of thick books available that discuss XSLT, so the matter is too complex to document here. But in shortest characterization, XSLT is a declarative programming language whose syntax is itself an XML application. An XML document is processed using a set of rules in an XSLT stylesheet, to produce a new output, often a different XML document. The elements in an XSLT stylesheet each describe a pattern that might occur in a source document and contain an output block that will be produced if that pattern is encountered. That is the simple characterization, anyway; in the details, "patterns" can have loops, recursions, calculations, and so on. I find XSLT to be more complicated than genuinely powerful and would rarely choose the technology for my own purposes, but you are fairly likely to encounter existing XSLT processes if you work with existing XML applications.</P>
<A NAME="ch05lev2sec9"></A><H4 class="docSection2Title">5.4.1 Python Standard Library XML Modules</H4>
<P class="docText">There are two principle APIs for accessing and manipulating XML documents that are in widespread use: DOM and SAX. Both are supported in the Python standard library, and these two APIs make up the bulk of Python's XML support. Both of these APIs are programming language neutral, and using them in other languages is substantially similar to using them in Python.</P>
<P class="docText">The Document Object Model (DOM) represents an XML document as a tree of <span class="docEmphasis">nodes.</span> Nodes may be of several types—a document type declaration, processing instructions, comments, elements, and attribute maps—but whatever the type, they are arranged in a strictly nested hierarchy. Typically, nodes have children attached to them; of course, some nodes are <span class="docEmphasis">leaf nodes</span> without children. The DOM allows you to perform a variety of actions on nodes: delete nodes, add nodes, find sibling nodes, find nodes by tag name, and other actions. The DOM itself does not specify anything about how an XML document is transformed (parsed) into a DOM representation, nor about how a DOM can be serialized to an XML document. In practice, however, all DOM libraries—including <span class="docEmphasis"><TT>xml.dom</TT></span>—incorporate these capabilities. Formal specification of DOM can be found at:</P>
<BLOCKQUOTE><P><P class="docList"><TT>&lt;</TT><A class="docLink" target="_blank" HREF="http://www.w3.org/DOM/default.htm">http://www.w3.org/DOM/</A><TT>&gt;</TT></P></P></BLOCKQUOTE>
<P class="docText">and:</P>
<BLOCKQUOTE><P><P class="docList"><TT>&lt;</TT><A class="docLink" target="_blank" HREF="http://www.w3.org/TR/2000/REC-DOM-Level-2-Core-20001113/default.htm">http://www.w3.org/TR/2000/REC-DOM-Level-2-Core-20001113/</A><TT>&gt;</TT></P></P></BLOCKQUOTE>
<P class="docText">The Simple API for XML (SAX) is an <span class="docEmphasis">event-based</span> API for XML documents. Unlike DOM, which envisions XML as a rooted tree of nodes, SAX sees XML as a sequence of events occurring linearly in a file, text, or other stream. SAX is a very minimal interface, both in the sense of telling you very little inherently about the <span class="docEmphasis">structure</span> of an XML documents, and also in the sense of being extremely memory friendly. SAX itself is forgetful in the sense that once a tag or content is processed, it is no longer in memory (unless you manually save it in a data structure). However, SAX does maintain a basic stack of tags to assure well-formedness of parsed documents. The module <span class="docEmphasis"><TT>xml.sax</TT></span> raises exceptions in case of problems in well-formedness; you may define your own custom error handlers for these. Formal specification of SAX can be found at:</P>
<BLOCKQUOTE><P><P class="docList"><TT>&lt;</TT><A class="docLink" target="_blank" HREF="http://www.saxproject.org/default.htm">http://www.saxproject.org/</A><TT>&gt;</TT></P></P></BLOCKQUOTE>
<p class="docText"><IMG BORDER="0" WIDTH="500" HEIGHT="17" src="FILES/common.gif" ALT="graphics/common.gif"></p><A NAME="ch05lev4sec180"></A><H5 class="docSection3Title"> xml.dom</H5>
<P class="docText">The module <TT>xml.dom</TT> is a Python implementation of most of the W3C Document Object Model, Level 2. As much as possible, its API follows the DOM standard, but a few Python conveniences are added as well. A brief example of usage is below:</P>
<pre>
&gt;&gt;&gt; from xml.dom import minidom
&gt;&gt;&gt; dom = minidom.parse('address.xml')
&gt;&gt;&gt; addrs = dom.getElementsByTagName('address')
&gt;&gt;&gt; print addrs[1].toxml()
&lt;address city="New York" number="344" state="NY" street="118 St."/&gt;
&gt;&gt;&gt; jobs = dom.getElementsByTagName('job-info')
&gt;&gt;&gt; for key, val in jobs[3].attributes.items():
...     print key,'=',val
employee-type = Part-Time
is-manager = no
job-description = Hacker
</pre>
<p class="docText"><span class="docEmphRoman">S<span class="docEmphSmaller">EE</span> A<span class="docEmphSmaller">LSO</span></span>: 
gnosis.xml.objectify <span class="docEmphasis">409</span>;</p>
<A NAME="ch05lev4sec181"></A><H5 class="docSection3Title"> xml.dom.minidom</H5>
<P class="docText">The module <span class="docEmphasis"><TT>xml.dom.minidom</TT></span> is a lightweight DOM implementation built on top of SAX. You may pass in a custom SAX parser object when you parse an XML document; by default, <span class="docEmphasis"><TT>xml.dom.minidom</TT></span> uses the fast, nonvalidating <span class="docEmphasis"><TT>xml.parser.expat</TT></span> parser.</P>
<A NAME="ch05lev4sec182"></A><H5 class="docSection3Title"> xml.dom.pulldom</H5>
<P class="docText">The module <span class="docEmphasis"><TT>xml.dom.pulldom</TT></span> is a DOM implementation that conserves memory by only building the portions of a DOM tree that are requested by calls to accessor methods. In some cases, this approach can be considerably faster than building an entire tree with <span class="docEmphasis"><TT>xml.dom.minidom</TT></span> or another DOM parser; however, the <span class="docEmphasis"><TT>xml.dom.pulldom</TT></span> remains somewhat underdocumented and experimental at the time of this writing.</P>
<A NAME="ch05lev4sec183"></A><H5 class="docSection3Title"> xml.parsers.expat</H5>
<P class="docText">Interface to the expat nonvalidating XML parser. Both the <span class="docEmphasis">xml.sax</span> and the <span class="docEmphasis"><TT>xml.dom.minidom</TT></span> modules utilize the services of the fast expat parser, whose functionality lives mostly in a C library. You can use <span class="docEmphasis"><TT>xml.parser.expat</TT></span> directly if you wish, but since the interface uses the same general event-driven style of the standard <span class="docEmphasis"><TT>xml.sax</TT></span>, there is usually no reason to.</P>
<A NAME="ch05lev4sec184"></A><H5 class="docSection3Title"> xml.sax</H5>
<P class="docText">The package <span class="docEmphasis"><TT>xml.sax</TT></span> implements the Simple API for XML. By default, <span class="docEmphasis"><TT>xml.sax</TT></span> relies on the underlying <span class="docEmphasis"><TT>xml.parser.expat</TT></span> parser, but any parser supporting a set of interface methods may be used instead. In particular, the validating parser <span class="docEmphasis"><TT>xmlproc</TT></span> is included in the <span class="docEmphasis"><TT>PyXML</TT></span> package.</P>
<P class="docText">When you create a SAX application, your main task is to create one or more callback handlers that will process events generated during SAX parsing. The most important handler is a <TT>ContentHandler</TT>, but you may also define a <TT>DTDHandler</TT>, <TT>EntityResolver</TT>, or <TT>ErrorHandler</TT>. Generally you will specialize the base handlers in <span class="docEmphasis"><TT>xml.sax.handler</TT></span> for your own applications. After defining and registering desired handlers, you simply call the <TT>.parse()</TT> method of the parser that you registered handlers with. Or alternately, for incremental processing, you can use the <TT>feed()</TT> method.</P>
<P class="docText">A simple example illustrates usage. The application below reads in an XML file and writes an equivalent, but not necessarily identical, document to STDOUT. The output can be used as a canonical form of the document:</P>
<H5 class="docExampleTitle"><A NAME="ch05list15"></A> xmlcat.py</H5>

<PRE>
#!/usr/bin/env python
import sys
from xml.sax import handler, make_parser
from xml.sax.saxutils import escape

class ContentGenerator(handler.ContentHandler):
    def __init__(self, out=sys.stdout):
        handler.ContentHandler.__init__(self)
        self._out = out
    def startDocument(self):
        xml_decl = '&lt;?xml version="1.0" encoding="iso-8859-1"?&gt;\n'
        self._out.write(xml_decl)
    def endDocument(self):
        sys.stderr.write("Bye bye!\n")
    def startElement(self, name, attrs):
        self._out.write('&lt;' + name)
        name_val = attrs.items()
        name_val.sort()                 # canonicalize attributes
        for (name, value) in name_val:
            self._out.write(' %s="%s"' % (name, escape(value)))
        self._out.write('&gt;')
    def endElement(self, name):
        self._out.write('&lt;/%s&gt;' % name)
    def characters(self, content):
        self._out.write(escape(content))
    def ignorableWhitespace(self, content):
        self._out.write(content)
    def processingInstruction(self, target, data):
        self._out.write('&lt;?%s %s?&gt;' % (target, data))

if __name__=='__main__':
    parser = make_parser()
    parser.setContentHandler(ContentGenerator())
    parser.parse(sys.argv[1])
</PRE>
<A NAME="ch05lev4sec185"></A><H5 class="docSection3Title"> xml.sax.handler</H5>
<P class="docText">The module <span class="docEmphasis"><TT>xml.sax.handler</TT></span> defines classes <TT>ContentHandler</TT>, <TT>DTDHandler</TT>, <TT>EntityResolver</TT>, and <TT>ErrorHandler</TT> that are normally used as parent classes of custom SAX handlers.</P>
<A NAME="ch05lev4sec186"></A><H5 class="docSection3Title"> xml.sax.saxutils</H5>
<P class="docText">The module <span class="docEmphasis"><TT>xml.sax.saxutils</TT></span> contains utility functions for working with SAX events. Several functions allow escaping and munging special characters.</P>
<A NAME="ch05lev4sec187"></A><H5 class="docSection3Title"> xml.sax.xmlreader</H5>
<P class="docText">The module <span class="docEmphasis"><TT>xml.sax.xmlreader</TT></span> provides a framework for creating new SAX parsers that will be usable by the <span class="docEmphasis"><TT>xml.sax</TT></span> module. Any new parser that follows a set of API conventions can be plugged in to the <span class="docEmphasis"><TT>xml.sax.make_parser()</TT></span> class factory.</P>
<A NAME="ch05lev4sec188"></A><H5 class="docSection3Title"> xmllib</H5>
<P class="docText">Deprecated module for XML parsing. Use <span class="docEmphasis"><TT>xml.sax</TT></span> or other XML tools in Python 2.0+.</P>
<A NAME="ch05lev4sec189"></A><H5 class="docSection3Title"> xmlrpclib<br>SimpleXMLRPCServer</H5>
<P class="docText">XML-RPC is an XML-based protocol for remote procedure calls, usually layered over HTTP. For the most part, the XML aspect is hidden from view. You simply use the module <span class="docEmphasis"><TT>xmlrpclib</TT></span> to call remote methods and the module <span class="docEmphasis"><TT>SimpleXMLRPCServer</TT></span> to implement your own server that supports such method calls. For example:</P>
<pre>
&gt;&gt;&gt; import xmlrpclib
&gt;&gt;&gt; betty = xmlrpclib.Server("http://betty.userland.com")
&gt;&gt;&gt; print betty.examples.getStateName(41)
South Dakota
</pre>
<P class="docText">The XML-RPC format itself is a bit verbose, even as XML goes. But it is simple and allows you to pass argument values to a remote method:</P>
<pre>
&gt;&gt;&gt; import xmlrpclib
&gt;&gt;&gt; print xmlrpclib.dumps((xmlrpclib.True,37,(11.2,'spam')))
&lt;params&gt;
&lt;param&gt;
&lt;value&gt;&lt;boolean&gt;1&lt;/boolean&gt;&lt;/value&gt;
&lt;/param&gt;
&lt;param&gt;
&lt;value&gt;&lt;int&gt;37&lt;/int&gt;&lt;/value&gt;
&lt;/param&gt;
&lt;param&gt;
&lt;value&gt;&lt;array&gt;&lt;data&gt;
&lt;value&gt;&lt;double&gt;11.199999999999999&lt;/double&gt;&lt;/value&gt;
&lt;value&gt;&lt;string&gt;spam&lt;/string&gt;&lt;/value&gt;
&lt;/data&gt;&lt;/array&gt;&lt;/value&gt;
&lt;/param&gt;
&lt;/params&gt;
</pre>
<p class="docText"><span class="docEmphRoman">S<span class="docEmphSmaller">EE</span> A<span class="docEmphSmaller">LSO</span></span>: 
gnosis.xml.pickle <span class="docEmphasis">410</span>;</p>
<A NAME="ch05lev2sec10"></A><H4 class="docSection2Title">5.4.2 Third-Party XML-Related Tools</H4>
<P class="docText">A number of projects extend the XML capabilities in the Python standard library. I am the principle author of several XML-related modules that are distributed with the <span class="docEmphasis"><TT>gnosis</TT></span> package. Information on the current release can be found at:</P>
<BLOCKQUOTE><P><P class="docList"><TT>&lt;</TT><A class="docLink" target="_blank" HREF="http://gnosis.cx/download/Gnosis_Utils.ANNOUNCE">http://gnosis.cx/download/Gnosis_Utils.ANNOUNCE</A><TT>&gt;</TT></P></P></BLOCKQUOTE>
<P class="docText">The package itself can be downloaded as a <span class="docEmphasis">distutils</span> package tarball from:</P>
<BLOCKQUOTE><P><P class="docList"><TT>&lt;</TT><A class="docLink" target="_blank" HREF="http://gnosis.cx/download/Gnosis_Utils-current.tar.gz">http://gnosis.cx/download/Gnosis_Utils-current.tar.gz</A><TT>&gt;</TT></P></P></BLOCKQUOTE>
<P class="docText">The Python XML-SIG (special interest group) produces a package of XML tools known as <span class="docEmphasis"><TT>PyXML</TT></span>. The work of this group is incorporated into the Python standard library with new Python releases—not every <span class="docEmphasis"><TT>PyXML</TT></span> tool, however, makes it into the standard library. At any given moment, the most sophisticated—and often experimental—capabilities can be found by downloading the latest <span class="docEmphasis"><TT>PyXML</TT></span> package. Be aware that installing the latest <span class="docEmphasis"><TT>PyXML</TT></span> overrides the default Python XML support and may break other tools or applications.</P>
<BLOCKQUOTE><P><P class="docList"><TT>&lt;</TT><A class="docLink" target="_blank" HREF="http://pyxml.sourceforge.net/default.htm">http://pyxml.sourceforge.net/</A><TT>&gt;</TT></P></P></BLOCKQUOTE>
<P class="docText">Fourthought, Inc. produces the <span class="docEmphasis"><TT>4Suite</TT></span> package, which contains a number of XML tools. Fourthought releases <span class="docEmphasis"><TT>4Suite</TT></span> as free software, and many of its capabilities are incorporated into the <span class="docEmphasis"><TT>PyXML</TT></span> project (albeit at a varying time delay); however, Fourthought is a for-profit company that also offers customization and technical support for <span class="docEmphasis"><TT>4Suite</TT></span>. The community page for <span class="docEmphasis"><TT>4Suite</TT></span> is:</P>
<BLOCKQUOTE><P><P class="docList"><TT>&lt;</TT><A class="docLink" target="_blank" HREF="http://4suite.org/index.xhtml">http://4suite.org/index.xhtml</A><TT>&gt;</TT></P></P></BLOCKQUOTE>
<P class="docText">The Fourthought company Web site is:</P>
<BLOCKQUOTE><P><P class="docList"><TT>&lt;</TT><A class="docLink" target="_blank" HREF="http://fourthought.com/default.htm">http://fourthought.com/</A><TT>&gt;</TT></P></P></BLOCKQUOTE>
<P class="docText">Two other modules are discussed briefly below. Neither of these are XML tools per se. However, both <span class="docEmphasis"><TT>PYX</TT></span> and <span class="docEmphasis"><TT>yaml</TT></span> fill many of the same requirements as XML does, while being easier to manipulate with text processing techniques, easier to read, and easier to edit by hand. There is a contrast between these two formats, however. <span class="docEmphasis"><TT>PYX</TT></span> is semantically identical to XML, merely using a different syntax. YAML, on the other hand, has a quite different semantics from XML—I present it here because in many of the concrete applications where developers might instinctively turn to XML (which has a lot of "buzz"), YAML is a better choice.</P>
<P class="docText">The home page for <span class="docEmphasis"><TT>PYX</TT></span> is:</P>
<BLOCKQUOTE><P><P class="docList"><TT>&lt;</TT><A class="docLink" target="_blank" HREF="http://pyxie.sourceforge.net/default.htm">http://pyxie.sourceforge.net/</A><TT>&gt;</TT></P></P></BLOCKQUOTE>
<P class="docText">I have written an article explaining PYX in more detail than in this book at:</P>
<BLOCKQUOTE><P><P class="docList"><TT>&lt;</TT><A class="docLink" target="_blank" HREF="http://gnosis.cx/publish/programming/xml_matters_17.html">http://gnosis.cx/publish/programming/xml_matters_17.html</A><TT>&gt;</TT></P></P></BLOCKQUOTE>
<P class="docText">The home page for YAML is:</P>
<BLOCKQUOTE><P><P class="docList"><TT>&lt;</TT><A class="docLink" target="_blank" HREF="http://yaml.org/default.htm">http://yaml.org</A><TT>&gt;</TT></P></P></BLOCKQUOTE>
<P class="docText">I have written an article contrasting the utility and semantics of YAML and XML at:</P>
<BLOCKQUOTE><P><P class="docList"><TT>&lt;</TT><A class="docLink" target="_blank" HREF="http://gnosis.cx/publish/programming/xml_matters_23.html">http://gnosis.cx/publish/programming/xml_matters_23.html</A><TT>&gt;</TT></P></P></BLOCKQUOTE>
<p class="docText"><IMG BORDER="0" WIDTH="500" HEIGHT="17" src="FILES/common.gif" ALT="graphics/common.gif"></p>
<A NAME="ch05lev4sec190"></A><H5 class="docSection3Title"> gnosis.xml.indexer</H5>
<P class="docText">The module <span class="docEmphasis"><TT>gnosis.xml.indexer</TT></span> builds on the full-text indexing program presented as an example in <A class="docLink" HREF="0321112547_ch02.html#ch02">Chapter 2</A> (and contained in the <span class="docEmphasis"><TT>gnosis</TT></span> package as <span class="docEmphasis"><TT>gnosis.indexer</TT>).</span> Instead of file contents, <span class="docEmphasis"><TT>gnosis.xml.indexer</TT></span> creates indices of (large) XML documents. This allows for a kind of "reverse XPath" search. That is, where a tool like <span class="docEmphasis"><TT>4xpath</TT></span>, in the <span class="docEmphasis"><TT>4Suite</TT></span> package, lets you see the contents of an XML node specified by XPath, <span class="docEmphasis"><TT>gnosis.xml.indexer</TT></span> identifies the XPaths to the point where a word or words occur. This module may be used either in a larger application or as a command-line tool; for example:</P>
<pre>
% indexer symmetric
./crypto1.xml::/section[2]/panel[8]/title
./crypto1.xml::/section[2]/panel[8]/body/text_column/code_listing
./crypto1.xml::/section[2]/panel[7]/title
./crypto2.xml::/section[4]/panel[6]/body/text_column/p[1]
4 matched wordlist: ['symmetric']
Processed in 0.100 seconds (SlicedZPickleIndexer)

% indexer "-filter=*::/*/title" symmetric
./cryptol.xml::/section[2]/panel[8]/title
./cryptol.xml::/section[2]/panel[7]/title
2 matched wordlist: ['symmetric']
Processed in 0.080 seconds (SlicedZPickleIndexer)
</pre>
<P class="docText">Indexed searches, as the example shows, are very fast. I have written an article with more details on this module:</P>
<BLOCKQUOTE><P><P class="docList"><TT>&lt;</TT><A class="docLink" target="_blank" HREF="http://gnosis.cx/publish/programming/xml_matters_10.html">http://gnosis.cx/publish/programming/xml_matters_10.html</A><TT>&gt;</TT></P></P></BLOCKQUOTE>
<A NAME="ch05lev4sec191"></A><H5 class="docSection3Title"> gnosis.xml.objectify</H5>
<P class="docText">The module <span class="docEmphasis"><TT>gnosis.xml.objectify</TT></span> transforms arbitrary XML documents into Python objects that have a "native" feel to them. Where XML is used to encode a data structure, I believe that using <span class="docEmphasis"><TT>gnosis.xml.objectify</TT></span> is the quickest and simplest way to utilize that data in a Python application.</P>
<P class="docText">The Document Object Model defines an OOP model for working with XML, across programming languages. But while DOM is nominally object-oriented, its access methods are distinctly un-Pythonic. For example, here is a typical "drill down" to a DOM value (skipping whitespace text nodes for some indices, which is far from obvious):</P>
<pre>
&gt;&gt;&gt; from xml.dom import minidom
&gt;&gt;&gt; dom_obj = minidom.parse('address.xml')
&gt;&gt;&gt; dom_obj.normalize()
&gt;&gt;&gt; print dom_obj.documentElement.childNodes[1].childNodes[3]\
...                              .attributes.get('city').value
Los Angeles
</pre>
<P class="docText">In contrast, <span class="docEmphasis"><TT>gnosis.xml.objectify</TT></span> feels like you are using Python:</P>
<pre>
&gt;&gt;&gt; from gnosis.xml.objectify import XML_Objectify
&gt;&gt;&gt; xml_obj = XML_Objectify('address.xml')
&gt;&gt;&gt; py_obj = xml_obj.make_instance()
&gt;&gt;&gt; py_obj.person[2].address.city
u'Los Angeles'
</pre>
<A NAME="ch05lev4sec192"></A><H5 class="docSection3Title"> gnosis.xml.pickle</H5>
<P class="docText">The module <span class="docEmphasis"><TT>gnosis.xml.pickle</TT></span> lets you serialize arbitrary Python objects to an XML format. In most respects, the purpose is the same as for the <span class="docEmphasis"><TT>pickle</TT></span> module, but an XML target is useful for certain purposes. You may process the data in an xml_pickle using standard XML parsers, XSLT processors, XML editors, validation utilities, and other tools.</P>
<P class="docText">In several respects, <span class="docEmphasis"><TT>gnosis.xml.pickle</TT></span> offers finer-grained control than the standard <span class="docEmphasis"><TT>pickle</TT></span> module does. You can control security permissions accurately; you can customize the representation of object types within an XML file; you can substitute compatible classes during the pickle/unpickle cycle; and several other "guru-level" manipulations are possible. However, in basic usage, <span class="docEmphasis"><TT>gnosis.xml.pickle</TT></span> is fully API compatible with <span class="docEmphasis"><TT>pickle</TT></span>. An example illustrates both the usage and the format:</P>
<pre>
&gt;&gt;&gt; class Container: pass
...
&gt;&gt;&gt; inst = Container()
&gt;&gt;&gt; dct = {1.7:2.5, ('t','u','p'):'tuple'}
&gt;&gt;&gt; inst.this, inst.num, inst.dct = 'that', 38, dct
&gt;&gt;&gt; import gnosis.xml.pickle
&gt;&gt;&gt; print gnosis.xml.pickle.dumps(inst)
&lt;?xml version="1.0"?&gt;
&lt;!DOCTYPE PyObject SYSTEM "PyObjects.dtd"&gt;
&lt;PyObject module="__main__" class="Container" id="5999664"&gt;
&lt;attr name="this" type="string" value="that" /&gt;
&lt;attr name="dct" type="dict" id="6008464" &gt;
  &lt;entry&gt;
    &lt;key type="tuple" id="5973680" &gt;
      &lt;item type="string" value="t" /&gt;
      &lt;item type="string" value="u" /&gt;
      &lt;item type="string" value="p" /&gt;
    &lt;/key&gt;
    &lt;val type="string" value="tuple" /&gt;
  &lt;/entry&gt;
  &lt;entry&gt;
    &lt;key type="numeric" value="1.7" /&gt;
    &lt;val type="numeric" value="2.5" /&gt;
  &lt;/entry&gt;
&lt;/attr&gt;
&lt;attr name="num" type="numeric" value="38" /&gt;
&lt;/PyObject&gt;
</pre>
<p class="docText"><span class="docEmphRoman">S<span class="docEmphSmaller">EE</span> A<span class="docEmphSmaller">LSO</span></span>: 
pickle <span class="docEmphasis">93</span>; cPickle <span class="docEmphasis">93</span>; yaml <span class="docEmphasis">415</span>; pprint <span class="docEmphasis">94</span>;</p>
<A NAME="ch05lev4sec193"></A><H5 class="docSection3Title"> gnosis.xml.validity</H5>
<P class="docText">The module <span class="docEmphasis"><TT>gnosis.xml.validity</TT></span> allows you to define Python container classes that restrict their containment according to XML validity constraints. Such validity-enforcing classes <span class="docEmphasis">always</span> produce string representations that are valid XML documents, not merely well-formed ones. When you attempt to add an item to a <span class="docEmphasis"><TT>gnosis.xml.validity</TT></span> container object that is not permissible, a descriptive exception is raised. Constraints, as with DTDs, may specify quantification, subelement types, and sequence.</P>
<P class="docText">For example, suppose you wish to create documents that conform with a "dissertation" Document Type Definition:</P>
<H5 class="docExampleTitle"><A NAME="ch05list16"></A> dissertation.dtd</H5>

<PRE>
&lt;!ELEMENT dissertation (dedication?, chapter+, appendix*)&gt;
&lt;!ELEMENT dedication (#PCDATA)&gt;
&lt;!ELEMENT chapter (title, paragraph+)&gt;
&lt;!ELEMENT title (#PCDATA)&gt;
&lt;!ELEMENT paragraph (#PCDATA I figure I table)+&gt;
&lt;!ELEMENT figure EMPTY&gt;
&lt;!ELEMENT table EMPTY&gt;
&lt;!ELEMENT appendix (#PCDATA)&gt;
</PRE>
<P class="docText">You can use <span class="docEmphasis"><TT>gnosis.xml.validity</TT></span> to assure your application produced only conformant XML documents. First, you create a Python version of the DTD:</P>
<H5 class="docExampleTitle"><A NAME="ch05list17"></A> dissertation.py</H5>

<PRE>
from gnosis.xml.validity import *
class appendix(PCDATA):   pass
class table(EMPTY):       pass
class figure(EMPTY):      pass
class _mixedpara(Or):     _disjoins = (PCDATA, figure, table)
class paragraph(Some):    _type = _mixedpara
class title(PCDATA):      pass
class _paras(Some):       _type = paragraph
class chapter(Seq):       _order = (title, _paras)
class dedication(PCDATA): pass
class _apps(Any):         _type = appendix
class _chaps(Some):       _type = chapter
class _dedi(Maybe):       _type = dedication
class dissertation(Seq):  _order = (_dedi, _chaps, _apps)
</PRE>
<P class="docText">Next, import your Python validity constraints, and use them in an application:</P>
<pre>
&gt;&gt;&gt; from dissertation import *
&gt;&gt;&gt; chap1 = LiftSeq(chapter,('About Validity','It is a good thing'))
&gt;&gt;&gt; paras_ch1 = chap1[1]
&gt;&gt;&gt; paras_ch1 += [paragraph('OOP can enforce it')]
&gt;&gt;&gt; print chap1
&lt;chapter&gt;&lt;title&gt;About Validity&lt;/title&gt;
&lt;paragraph&gt;It is a good thing&lt;/paragraph&gt;
&lt;paragraph&gt;OOP can enforce it&lt;/paragraph&gt;
&lt;/chapter&gt;
</pre>
<P class="docText">If you attempt an action that violates constraints, you get a relevant exception; for example:</P>
<pre>
&gt;&gt;&gt; try:
..     paras_ch1.append(dedication("To my advisor"))
.. except ValidityError, x:
...    print x
Items in _paras must be of type &lt;class 'dissertation.paragraph'&gt;
(not &lt;class 'dissertation.dedication'&gt;)
</pre>
<A NAME="ch05lev4sec194"></A><H5 class="docSection3Title"> PyXML</H5>
<P class="docText">The <span class="docEmphasis"><TT>PyXML</TT></span> package contains a number of capabilities in advance of those in the Python standard library. <span class="docEmphasis"><TT>PyXML</TT></span> was at version 0.8.1 at the time this was written, and as the number indicates, it remains an in-progress/beta project. Moreover, as of this writing, the last released version of Python was 2.2.2, with 2.3 in preliminary stages. When you read this, <span class="docEmphasis"><TT>PyXML</TT></span> will probably be at a later number and have new features, and some of the current features will have been incorporated into the standard library. Exactly what is where is a moving target.</P>
<P class="docText">Some of the significant features currently available in <span class="docEmphasis"><TT>PyXML</TT></span> but not in the standard library are listed below. You may install <span class="docEmphasis"><TT>PyXML</TT></span> on any Python 2.0+ installation, and it will override the existing XML support.</P>
<UL><LI><P class="docList">A validating XML parser written in Python called <span class="docEmphasis"><TT>xmlproc</TT></span>. Being a pure Python program rather than a C extension, <span class="docEmphasis"><TT>xmlproc</TT></span> is slower than <span class="docEmphasis"><TT>xml.sax</TT></span> (which uses the underlying <span class="docEmphasis"><TT>expat</TT></span> parser).</P></LI><LI><P class="docList">A SAX extension called <span class="docEmphasis"><TT>xml.sax.writers</TT></span> that will reserialize SAX events to either XML or other formats.</P></LI><LI><P class="docList">A fully compliant DOM Level 2 implementation called <span class="docEmphasis"><TT>4DOM</TT></span>, borrowed from <span class="docEmphasis"><TT>4Suite</TT></span>.</P></LI><LI><P class="docList">Support for canonicalization. That is, two XML documents can be semantically identical even though they are not byte-wise identical. You have freedom in choice of quotes, attribute orders, character entities, and some spacing that change nothing about the <span class="docEmphasis">meaning</span> of the document. Two canonicalized XML documents are semantically identical if and only if they are byte-wise identical.</P></LI><LI><P class="docList">XPath and XSLT support, with implementations written in pure Python. There are faster XSLT implementations around, however, that call C extensions.</P></LI><LI><P class="docList">A DOM implementation, called <span class="docEmphasis"><TT>xml.dom.pulldom</TT></span>, that supports lazy instantiation of nodes has been incorporated into recent versions of the standard library. For older Python versions, this is available in <span class="docEmphasis"><TT>PyXML</TT></span>.</P></LI><LI><P class="docList">A module with several options for serializing Python objects to XML. This capability is comparable to <span class="docEmphasis"><TT>gnosis.xml.pickle</TT></span>, but I like the tool I created better in several ways.</P></LI></UL>
<A NAME="ch05lev4sec195"></A><H5 class="docSection3Title"> PYX</H5>
<P class="docText">PYX is both a document format and a Python module to support working with that format. As well as the Python module, tools written in C are available to transform documents between XML and PYX format.</P>
<P class="docText">The idea behind PYX is to eliminate the need for complex parsing tools like <span class="docEmphasis"><TT>xml.sax</TT></span>. Each node in an XML document is represented, in the PYX format on a separate line, using a prefix character to indicate the node type. Most of XML semantics is preserved, with the exception of document type declarations, comments, and namespaces. These features could be incorporated into an updated PYX format, in principle.</P>
<P class="docText">Documents in the PYX format are easily processed using traditional line-oriented text processing tools like <TT>sed</TT>, <TT>grep</TT>, <TT>awk</TT>, <TT>sort</TT>, <TT>wc</TT>, and the like. Python applications that use a basic <span class="docEmphasis"><TT>FILE.readline()</TT></span> loop are equally able to process PYX nodes, one per line. This makes it much easier to use familiar text processing programming styles with PYX than it is with XML. A brief example illustrates the PYX format:</P>
<pre>
% cat test.xml
&lt;?xml version="1.0"?&gt;
&lt;?xml-stylesheet href="test.css" type="text/css"?&gt;
&lt;Spam flavor="pork"&gt;
  &lt;Eggs&gt;Some text about eggs.&lt;/Eggs&gt;
  &lt;MoreSpam&gt;Ode to Spam (spam="smoked-pork")&lt;/MoreSpam&gt;
&lt;/Spam&gt;
% ./xmln test.xml
?xml-stylesheet href="test.css" type="text/css" (Spam
Aflavor pork
-\n
(Eggs
-Some text about eggs. )Eggs
-\n
(MoreSpam
-Ode to Spam (spam="smoked-pork")
)MoreSpam
-\n
)Spam
</pre>
<A NAME="ch05lev4sec196"></A><H5 class="docSection3Title"> 4Suite</H5>
<P class="docText">The tools in <span class="docEmphasis"><TT>4Suite</TT></span> focus on the use of XML documents for knowledge management. The server element of the <span class="docEmphasis"><TT>4Suite</TT></span> software is useful for working with catalogs of XML documents, searching them, transforming them, and so on. The base <span class="docEmphasis"><TT>4Suite</TT></span> tools address a variety of XML technologies. In some cases <span class="docEmphasis"><TT>4Suite</TT></span> implements standards and technologies not found in the Python standard library or in <span class="docEmphasis"><TT>PyXML</TT></span>, while in other cases <span class="docEmphasis"><TT>4Suite</TT></span> provides more advanced implementations.</P>
<P class="docText">Among the XML technologies implemented in <span class="docEmphasis"><TT>4Suite</TT></span> are DOM, RDF, XSLT, XInclude, XPointer, XLink and XPath, and SOAP. Among these, of particular note is <span class="docEmphasis"><TT>4xslt</TT></span> for performing XSLT transformations. <span class="docEmphasis"><TT>4xpath</TT></span> lets you find XML nodes using concise and powerful XPath descriptions of how to reach them. <span class="docEmphasis"><TT>4rdf</TT></span> deals with "meta-data" that documents use to identify their semantic characteristics.</P>
<P class="docText">I detail <span class="docEmphasis"><TT>4Suite</TT></span> technologies in a bit more detail in an article at:</P>
<BLOCKQUOTE><P><P class="docList"><TT>&lt;</TT><A class="docLink" target="_blank" HREF="http://gnosis.cx/publish/programming/xml_matters_15.html">http://gnosis.cx/publish/programming/xml_matters_15.html</A><TT>&gt;</TT></P></P></BLOCKQUOTE>
<A NAME="ch05lev4sec197"></A><H5 class="docSection3Title"> yaml</H5>
<P class="docText">The native data structures of object-oriented programming languages are not straightforward to represent in XML. While XML is in principle powerful enough to represent any compound data, the only inherent mapping in XML is within attributes—but that only maps strings to strings. Moreover, even when a suitable XML format is found for a given data structure, the XML is quite verbose and difficult to scan visually, or especially to edit manually.</P>
<P class="docText">The YAML format is designed to match the structure of datatypes prevalent in scripting languages: Python, Perl, Ruby, and Java all have support libraries at the time of this writing. Moreover, the YAML format is extremely concise and unobtrusive—in fact, the acronym cutely stands for "YAML Ain't Markup Language." In many ways, YAML can act as a better pretty-printer than <span class="docEmphasis"><TT>pprint</TT></span>, while simultaneously working as a format that can be used for configuration files or to exchange data between different programming languages.</P>
<P class="docText">There is no fully general and clean way, however, to convert between YAML and XML. You can use the <span class="docEmphasis"><TT>yaml</TT></span> module to read YAML data files, then use the <span class="docEmphasis"><TT>gnosis.xml.pickle</TT></span> module to read and write to one particular XML format. But when XML data starts out in other XML dialects than <span class="docEmphasis"><TT>gnosis.xml.pickle</TT></span>, there are ambiguities about the best Python native and YAML representations of the same data. On the plus side—and this can be a very big plus—there is essentially a straight-forward and one-to-one correspondence between Python data structures and YAML representations.</P>
<P class="docText">In the YAML example below, refer back to the same Python instance serialized using <span class="docEmphasis"><TT>gnosis.xml.pickle</TT></span> and <span class="docEmphasis"><TT>pprint</TT></span> in their respective discussions. As with <span class="docEmphasis"><TT>gnosis.xml.pickle</TT></span>—but in this case unlike <span class="docEmphasis"><TT>pprint</TT></span>—the serialization can be read back in to re-create an identical object (or to create a different object after editing the text, by hand or by application).</P>
<pre>
&gt;&gt;&gt; class Container: pass
...
&gt;&gt;&gt; inst = Container()
&gt;&gt;&gt; dct = {1.7:2.5, ('t','u','p'):'tuple'}
&gt;&gt;&gt; inst.this, inst.num, inst.dct = 'that', 38, dct
&gt;&gt;&gt; import yaml
&gt;&gt;&gt; print yaml.dump(inst)
--- !!__main__.Container
dct:
    1.7: 2.5
    ?
        - t
        - u
        - p
: tuple
num: 38
this: that
</pre>
<p class="docText"><span class="docEmphRoman">S<span class="docEmphSmaller">EE</span> A<span class="docEmphSmaller">LSO</span></span>: 
pprint <span class="docEmphasis">94</span>; gnosis.xml.pickle <span class="docEmphasis">410</span>;</p>
<a href="0321112547_11061533.html"><img src="FILES/pixel.gif" width="1" height="1" border="0"></a><ul></ul></td></tr></table>
<td></td>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<td class="tt1"><a href="NFO/lib.html">[ Team LiB ]</a></td><td valign="top" class="tt1" align="right">
          <a href="0321112547_ch05lev1sec3.html"><img src="FILES/btn_prev.gif" width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a>
          <a href="0321112547_app01.html"><img src="FILES/btn_next.gif" width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a>
</td></table>
</body></html>
