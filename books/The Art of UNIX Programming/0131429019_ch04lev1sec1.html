<html><head>
<META http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<!--SafClassName="docSection1Title"--><!--SafTocEntry="4.1 Encapsulation and Optimal Module Size"-->
<link rel="STYLESHEET" type="text/css" href="FILES/style.css">
<link rel="STYLESHEET" type="text/css" href="FILES/docsafari.css">
<style type="text/css">	.tt1    {font-size: 10pt;}</style>
</head>
<body>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<td class="tt1"><a href="NFO/lib.html">[ Team LiB ]</a></td><td valign="top" class="tt1" align="right">
	<a href="0131429019_ch04.html"><img src="FILES/btn_prev.gif" width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a>
	<a href="0131429019_ch04lev1sec2.html"><img src="FILES/btn_next.gif" width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a>
</td></table>
<br>
<table width="100%" border="0" cellspacing="0" cellpadding="0"><tr><td valign="top"><A NAME="ch04lev1sec1"></A>
<H3 class="docSection1Title" id="162666-980">4.1 Encapsulation and Optimal Module Size</H3>
<P class="docText"><A NAME="idd1e9748"></A><A NAME="idd1e9751"></A><A NAME="idd1e9756"></A><A NAME="idd1e9761"></A>The first and most important quality of modular code is <span class="docEmphasis">encapsulation</span>. Well-encapsulated modules don't expose their internals to each other. They don't call into the middle of each others' implementations, and they don't promiscuously share global data. They communicate using application programming interfaces (APIs<A NAME="idd1e9771"></A>)—narrow, well-defined sets of procedure calls and data structures. This is what the Rule of Modularity is about.</P>
<P class="docText">The APIs between modules have a dual role. On the implementation level, they function as choke points between the modules, preventing the internals of each from leaking into its neighbors. On the design level, it is the APIs (not the bits of implementation between them) that really define your architecture.</P>
<P class="docText">One good test for whether an API is well designed is this one: if you try to write a description of it in purely human language (with no source-code extracts allowed), does it make sense? It is a very good idea to get into the habit of writing informal descriptions of your APIs before you code them. Indeed, some of the most able developers start by defining their interfaces, writing brief comments to describe them, and then writing the code—since the process of writing the comment clarifies what the code must do. Such descriptions help you organize your thoughts, they make useful module comments, and eventually you might want to turn them into a roadmap document for future readers of the code.</P>
<P class="docText">As you push module decomposition harder, the pieces get smaller and the definition of the APIs gets more important. Global complexity, and consequent vulnerability to bugs, decreases. It has been received wisdom in computer science since the 1970s (exemplified in papers such as <A class="docLink" HREF="0131429019_app02.html#biblio61">[Parnas]</A>) that you ought to design your software systems as hierarchies of nested modules, with the grain size of the modules at each level held to a minimum.</P>
<P class="docText">It is possible, however, to push this kind of decomposition too hard and make your modules too small. There is evidence <A class="docLink" HREF="0131429019_app02.html#biblio33">[Hatton97]</A> that when one plots defect density versus module size, the curve is U-shaped and concave upwards (see <A class="docLink" HREF="#ch04fig01">Figure 4.1</A>). Very small and very large modules are associated with more bugs than those of intermediate size. A different way of viewing the same data is to plot lines of code per module versus total bugs. The curve looks roughly logarithmic up to a 'sweet spot' where it flattens (corresponding to the minimum in the defect density curve), after which it goes up as the square of the number of the lines of code (which is what one might intuitively expect for the whole curve, following Brooks's Law<A NAME="idd1e9812"></A><sup class="docFootnote"><A class="docLink" HREF="#ch04en01">[1]</A></sup>).</P><blockquote><p class="docFootnote"><sup><A NAME="ch04en01">[1]</A></sup> Brooks's Law predicts that adding programmers to a late project makes it later. More generally, it predicts that costs and error rates rise as the square of the number of programmers on a project.</p></blockquote>
<CENTER>
<H5 class="docFigureTitle"><A NAME="ch04fig01"></A>Figure 4.1. Qualitative plot of defect count and density vs. module size.</H5>

<p class="docText">
<IMG BORDER="0" WIDTH="300" HEIGHT="335" src="FILES/04fig01.gif" ALT="graphics/04fig01.gif"></p>

</CENTER>
<P class="docText">This unexpectedly increasing incidence of bugs at small module sizes holds across a wide variety of systems implemented in different languages. Hatton has proposed a model relating this nonlinearity to the chunk size of human short-term memory.<sup class="docFootnote"><A class="docLink" HREF="#ch04en02">[2]</A></sup> Another way to interpret the nonlinearity is that at small module grain sizes, the increasing complexity of the interfaces becomes the dominating term; it's difficult to read the code because you have to understand everything before you can understand anything. In <A class="docLink" HREF="0131429019_ch07.html#ch07">Chapter 7</A> we'll examine more advanced forms of program partitioning; there, too, the complexity of interface protocols comes to dominate the total complexity of the system as the component processes get smaller.</P><blockquote><p class="docFootnote"><sup><A NAME="ch04en02">[2]</A></sup> In Hatton's model, small differences in the maximum chunk size a programmer can hold in short-term memory have a large multiplicative effect on the programmer's efficiency. This might be a major contributor to the order-of-magnitude (or larger) variations in effectiveness observed by Fred Brooks<A NAME="idd1e9838"></A> and others.</p></blockquote>
<P class="docText">In nonmathematical terms, Hatton's empirical results imply a sweet spot between 200 and 400 logical lines of code that minimizes probable defect density, all other factors (such as programmer skill) being equal. This size is independent of the language being used—an observation which strongly reinforces the advice given elsewhere in this book to program with the most powerful languages and tools you can. Beware of taking these numbers too literally however. Methods for counting lines of code vary considerably according to what the analyst considers a logical line, and other biases (such as whether comments are stripped). Hatton himself suggests as a rule of thumb a 2x conversion between logical and physical lines, suggesting an optimal range of 400–800 physical lines.</P>

<ul></ul></td></tr></table>
<td></td>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<td class="tt1"><a href="NFO/lib.html">[ Team LiB ]</a></td><td valign="top" class="tt1" align="right">
          <a href="0131429019_ch04.html"><img src="FILES/btn_prev.gif" width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a>
          <a href="0131429019_ch04lev1sec2.html"><img src="FILES/btn_next.gif" width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a>
</td></table>
</body></html>
