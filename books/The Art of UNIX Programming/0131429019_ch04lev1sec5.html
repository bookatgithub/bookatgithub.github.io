<html><head>
<META http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<!--SafClassName="docSection1Title"--><!--SafTocEntry="4.5 Unix and Object-Oriented Languages"-->
<link rel="STYLESHEET" type="text/css" href="FILES/style.css">
<link rel="STYLESHEET" type="text/css" href="FILES/docsafari.css">
<style type="text/css">	.tt1    {font-size: 10pt;}</style>
</head>
<body>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<td class="tt1"><a href="NFO/lib.html">[ Team LiB ]</a></td><td valign="top" class="tt1" align="right">
	<a href="0131429019_ch04lev1sec4.html"><img src="FILES/btn_prev.gif" width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a>
	<a href="0131429019_ch04lev1sec6.html"><img src="FILES/btn_next.gif" width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a>
</td></table>
<br>
<table width="100%" border="0" cellspacing="0" cellpadding="0"><tr><td valign="top"><A NAME="ch04lev1sec5"></A>
<H3 class="docSection1Title">4.5 Unix and Object-Oriented Languages</H3>
<P class="docText"><A NAME="idd1e10971"></A><A NAME="idd1e10974"></A><A NAME="idd1e10977"></A>Since the mid-1980s most new language designs have included native support for <span class="docEmphasis">object-oriented programming</span> (OO). Recall that in object-oriented programming, the functions that act on a particular data structure are encapsulated with the data in an object that can be treated as a unit. By contrast, modules in non-OO languages make the association between data and the functions that act on it rather accidental, and modules frequently leak data or bits of their internals into each other.</P>
<P class="docText">The OO design concept initially proved valuable in the design of graphics systems, graphical user interfaces, and certain kinds of simulation. To the surprise and gradual disillusionment of many, it has proven difficult to demonstrate significant benefits of OO outside those areas. It's worth trying to understand why.</P>
<P class="docText">There is some tension and conflict between the Unix tradition of modularity and the usage patterns that have developed around OO languages. Unix programmers have always tended to be a bit more skeptical about OO than their counterparts elsewhere. Part of this is because of the Rule of Diversity<A NAME="idd1e10992"></A><A NAME="idd1e10995"></A>; OO has far too often been promoted as the One True Solution to the software-complexity problem. But there is something else behind it as well, an issue which is worth exploring as background before we evaluate specific OO (object-oriented) languages in <A class="docLink" HREF="0131429019_ch14.html#ch14">Chapter 14</A>. It will also help throw some characteristics of the Unix style of non-OO programming into sharper relief.</P>
<P class="docText">We observed above that the Unix tradition of modularity is one of thin glue, a minimalist approach with few layers of abstraction<A NAME="idd1e11006"></A> between the hardware and the top-level objects of a program. Part of this is the influence of C. It takes serious effort to simulate true objects in C. Because that's so, piling up abstraction layers is an exhausting thing to do. Thus, object hierarchies in C tend to be relatively flat and transparent<A NAME="idd1e11010"></A>. Even when Unix programmers use other languages, they tend to want to carry over the thin-glue/shallow-layering style that Unix models have taught them.</P>
<P class="docText">OO languages make abstraction easy—perhaps too easy. They encourage architectures with thick glue and elaborate layers. This can be good when the problem domain is truly complex and demands a lot of abstraction, but it can backfire badly if coders end up doing simple things in complex ways just because they can.</P>
<P class="docText">All OO languages show some tendency to suck programmers into the trap of excessive layering. Object frameworks and object browsers are not a substitute for good design or documentation, but they often get treated as one. Too many layers destroy transparency<A NAME="idd1e11022"></A>: It becomes too difficult to see down through them and mentally model what the code is actually doing. The Rules of Simplicity<A NAME="idd1e11028"></A><A NAME="idd1e11031"></A>, Clarity<A NAME="idd1e11035"></A><A NAME="idd1e11040"></A>, and Transparency<A NAME="idd1e11044"></A><A NAME="idd1e11047"></A> get violated wholesale, and the result is code full of obscure bugs and continuing maintenance problems.</P>
<P class="docText">This tendency is probably exacerbated because a lot of programming courses teach thick layering as a way to satisfy the Rule of Representation<A NAME="idd1e11056"></A><A NAME="idd1e11059"></A>. In this view, having lots of classes is equated with embedding knowledge in your data. The problem with this is that too often, the 'smart data' in the glue layers is not actually about any natural entity in whatever the program is manipulating—it's just about being glue. (One sure sign of this is a proliferation of abstract subclasses or 'mixins'.)</P>
<P class="docText">Another side effect of OO abstraction is that opportunities for optimization<A NAME="idd1e11066"></A> tend to disappear. For example, <span class="docEmphasis">a</span> + <span class="docEmphasis">a</span> + <span class="docEmphasis">a</span> + <span class="docEmphasis">a</span> can become <span class="docEmphasis">a</span> * 4 and even <span class="docEmphasis">a</span> &lt;&lt; 2 if a is an integer. But if one creates a class with operators, there is nothing to indicate if they are commutative, distributive, or associative. Since one isn't supposed to look inside the object, it's not possible to know which of two equivalent expressions is more efficient. This isn't in itself a good reason to avoid using OO techniques on new projects; that would be premature optimization<A NAME="idd1e11088"></A>. But it is reason to think twice before transforming non-OO code into a class hierarchy.</P>
<P class="docText">Unix programmers tend to share an instinctive sense of these problems. This tendency appears to be one of the reasons that, under Unix, OO languages have failed to displace non-OO workhorses like C<A NAME="idd1e11097"></A>, Perl<A NAME="idd1e11101"></A> (which actually has OO facilities, but they're not heavily used), and shell<A NAME="idd1e11105"></A>. There is more vocal criticism of OO in the Unix world than orthodoxy permits elsewhere; Unix programmers know when <span class="docEmphasis">not</span> to use OO; and when they do use OO languages, they spend more effort on trying to keep their object designs uncluttered. As the author of <span class="docEmphasis">The Elements of Networking Style</span> once observed in a slightly different context <A class="docLink" HREF="0131429019_app02.html#biblio60">[Padlipsky]</A>: "If you know what you're doing, three layers is enough; if you don't, even seventeen levels won't help".</P>
<P class="docText">One reason that OO has succeeded most where it has (GUIs, simulation, graphics) may be because it's relatively difficult to get the ontology of types wrong in those domains. In GUIs and graphics, for example, there is generally a rather natural mapping between manipulable visual objects and classes. If you find yourself proliferating classes that have no obvious mapping to what goes on in the display, it is correspondingly easy to notice that the glue has gotten too thick.</P>
<P class="docText">One of the central challenges of design in the Unix style is how to combine the virtue of detachment (simplifying and generalizing problems from their original context) with the virtue of thin glue and shallow, flat, transparent hierarchies of code and design<A NAME="idd1e11124"></A>.</P>
<P class="docText">We'll return to some of these points and apply them when we discuss object-oriented languages in <A class="docLink" HREF="0131429019_ch14.html#ch14">Chapter 14</A>.</P>

<a href="0131429019_18071533.html"><img src="FILES/pixel.gif" width="1" height="1" border="0"></a><ul></ul></td></tr></table>
<td></td>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<td class="tt1"><a href="NFO/lib.html">[ Team LiB ]</a></td><td valign="top" class="tt1" align="right">
          <a href="0131429019_ch04lev1sec4.html"><img src="FILES/btn_prev.gif" width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a>
          <a href="0131429019_ch04lev1sec6.html"><img src="FILES/btn_next.gif" width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a>
</td></table>
</body></html>
