<html><head>
<META http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<!--SafClassName="docSection1Title"--><!--SafTocEntry="5.4 Application Protocol Metaformats"-->
<link rel="STYLESHEET" type="text/css" href="FILES/style.css">
<link rel="STYLESHEET" type="text/css" href="FILES/docsafari.css">
<style type="text/css">	.tt1    {font-size: 10pt;}</style>
</head>
<body>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<td class="tt1"><a href="NFO/lib.html">[ Team LiB ]</a></td><td valign="top" class="tt1" align="right">
	<a href="0131429019_ch05lev1sec3.html"><img src="FILES/btn_prev.gif" width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a>
	<a href="0131429019_ch06.html"><img src="FILES/btn_next.gif" width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a>
</td></table>
<br>
<table width="100%" border="0" cellspacing="0" cellpadding="0"><tr><td valign="top"><A NAME="ch05lev1sec4"></A>
<H3 class="docSection1Title">5.4 Application Protocol Metaformats</H3>
<P class="docText"><A NAME="idd1e13206"></A><A NAME="idd1e13209"></A>Just as data file metaformats have evolved to simplify serialization for storage, application protocol metaformats have evolved to simplify serialization for transactions across networks. The tradeoffs are a little different in this case; because network bandwidth is more expensive than storage, there is more of a premium on transaction economy. Still, the transparency and interoperability benefits of textual formats are sufficiently strong that most designers have resisted the temptation to optimize for performance at the cost of readability.</P>
<A NAME="ch05lev2sec15"></A>
<H4 class="docSection2Title">5.4.1 The Classical Internet Application Metaprotocol</H4>
<P class="docText"><A NAME="idd1e13222"></A><A NAME="idd1e13229"></A><A NAME="idd1e13234"></A>Marshall Rose's RFC 3117, <span class="docEmphasis">On the Design of Application Protocols</span><A NAME="idd1e13243"></A>,<sup class="docFootnote"><A class="docLink" HREF="#ch05en05">[5]</A></sup> provides an excellent overview of the design issues in Internet application protocols. It makes explicit several of the tropes in classical Internet application protocols that we observed in our examination of SMTP, POP, and IMAP, and provides an instructive taxonomy of such protocols. It is recommended reading.</P><blockquote><p class="docFootnote"><sup><A NAME="ch05en05">[5]</A></sup> See RFC 3117 &lt;<A class="docLink" target="_blank" HREF="ftp://ftp.rfc-editor.org/in-notes/rfc3117.txt">ftp://ftp.rfc-editor.org/in-notes/rfc3117.txt</A>&gt;.</p></blockquote>
<P class="docText">The classical Internet metaprotocol is textual. It uses single-line requests and responses, except for payloads which may be multiline. Payloads are shipped either with a preceding length in octets or with a terminator that is the line <TT>".\r\n"</TT>. In the latter case the payload is <span class="docEmphasis">byte-stuffed</span><A NAME="idd1e13262"></A>; all lines that start with a period get another period prepended, and the receiver side is responsible for both recognizing the termination and stripping away the stuffing. Response lines consist of a status code followed by a human-readable message.</P>
<P class="docText">One final advantage of this classical style is that it is readily extensible. The parsing and state-machine framework doesn't need to change much to accommodate new requests, and it is easy to code implementations so that they can parse unknown requests and return an error or simply ignore them. SMTP, POP3, and IMAP have all been extended in minor ways fairly often during their lifetimes, with minimal interoperability problems. Na&iuml;vely designed binary protocols are, by contrast, notoriously brittle.</P>

<A NAME="ch05lev2sec16"></A>
<H4 class="docSection2Title">5.4.2 HTTP as a Universal Application Protocol</H4>
<P class="docText"><A NAME="idd1e13277"></A><A NAME="idd1e13284"></A><A NAME="idd1e13289"></A>Ever since the World Wide Web reached critical mass around 1993, application protocol designers have shown an increasing tendency to layer their special-purpose protocols on top of HTTP, using web servers as generic service platforms.</P>
<P class="docText">This is a viable option because, at the transaction layer, HTTP is very simple and general. An HTTP request is a message in an RFC-822/MIME-like format<A NAME="idd1e13299"></A>; typically, the headers contain identification and authentication information, and the first line is a method call on some resource specified by a Universal Resource Indicator (URI). The most important methods are GET (fetch the resource), PUT (modify the resource) and POST (ship data to a form or back-end process). The most important form of URI<A NAME="idd1e13308"></A> is a URL<A NAME="idd1e13314"></A> or Uniform Resource Locator, which identifies the resource by service type, host name, and a location on the host. An HTTP response is simply an RFC-822/MIME message and can contain arbitrary content to be interpreted by the client.</P>
<P class="docText">Web servers handle the transport and request-multiplexing layers of HTTP, as well as standard service types like http and ftp. It is relatively easy to write web server plugins that will handle custom service types, and to dispatch on other elements of the URI format.</P>
<P class="docText">Besides avoiding a lot of lower-level details, this method means the application protocol will tunnel through the standard HTTP service port and not need a TCP/IP<A NAME="idd1e13332"></A> service port of its own. This can be a distinct advantage; most firewalls leave port 80 open, but trying to punch another hole through can be fraught with both technical and political difficulties.</P>
<P class="docText">With this advantage comes a risk. It means that your web server and its plugins grow more complex, and cracks in any of that code can have large security implications. It may become more difficult to isolate and shut down problem services. The usual tradeoffs between security and convenience apply.</P>
<P class="docText">RFC 3205, <span class="docEmphasis">On the Use of HTTP As a Substrate</span>,<sup class="docFootnote"><A class="docLink" HREF="#ch05en06">[6]</A></sup> has good design advice for anyone considering using HTTP as the underlayer of an application protocol, including a summary of the tradeoffs and problems involved.</P><blockquote><p class="docFootnote"><sup><A NAME="ch05en06">[6]</A></sup> See RFC 3205 &lt;<A class="docLink" target="_blank" HREF="http://www.faqs.org/rfcs/rfc3205.html">http://www.faqs.org/rfcs/rfc3205.html</A>&gt;.</p></blockquote>
<A NAME="ch05lev3sec1"></A>
<H5 class="docSection3Title">5.4.2.1 Case Study: The <TT>CDDB/freedb.org</TT> Database</H5>
<P class="docText"><A NAME="idd1e13367"></A><A NAME="idd1e13374"></A><A NAME="idd1e13379"></A>Audio CDs consist of a sequence of music tracks in a digital format called CDDA-WAV. They were designed to be played by very simple consumer-electronics devices a few years before general-purpose computers developed enough raw speed and sound capability to decode them on the fly. Because of this, there is no provision in the format for even simple metainformation such as the album and track titles. But modern computer-hosted CD players want this information so the user can assemble and edit play lists.</P>
<P class="docText">Enter the Internet. There are (at least two) repositories that provide a mapping between a hash code computed from the track-length table on a CD and artist/album-title/track-title records. The original was <TT>cddb.org</TT>, but another site called <TT>freedb.org</TT> which is probably now more complete and widely used. Both sites rely on their users for the enormous task of keeping the database current as new CDs come out; <TT>freedb.org</TT> arose from a developer revolt after CDDB elected to take all that user-contributed information proprietary.</P>
<P class="docText">Queries to these services could have been implemented as a custom application protocol on top of TCP/IP, but that would have required steps such as getting a new TCP/IP port number assigned and fighting to get a hole for it punched through thousands of firewalls. Instead, the service is implemented over HTTP as a simple CGI query (as if the CD's hash code had been supplied by a user filling in a Web form).</P>
<P class="docText">This choice makes all the existing infrastructure of HTTP and Web-access libraries in various programming languages available to support programs for querying and updating this database. As a result, adding such support to a software CD player is nearly trivial, and effectively every software CD player knows how to use them.</P>

<A NAME="ch05lev3sec2"></A>
<H5 class="docSection3Title">5.4.2.2 Case Study: Internet Printing Protocol</H5>
<P class="docText"><A NAME="idd1e13412"></A><A NAME="idd1e13415"></A>Internet Printing Protocol (IPP) is a successful, widely implemented standard for the control of network-accessible printers. Pointers to RFCs, implementations, and much other related material are available at the IETF's Printer Working Group &lt;<A class="docLink" target="_blank" HREF="http://www.pwg.org/ipp/default.htm">http://www.pwg.org/ipp/</A>&gt; site.<A NAME="idd1e13430"></A><A NAME="idd1e13435"></A></P>
<P class="docText">IPP uses HTTP 1.1 as a transport layer. All IPP requests are passed via an HTTP POST method call; responses are ordinary HTTP responses. (<A class="docLink" HREF="0131429019_ch04lev1sec2.html#ch04lev1sec2">Section 4.2</A> of RFC 2568<A NAME="idd1e13453"></A>, <span class="docEmphasis">Rationale for the Structure of the Model and Protocol for the Internet Printing Protocol</span>, does an excellent job of explaining this choice; it repays study by anyone considering writing a new application protocol.)</P>
<P class="docText">From the software side, HTTP 1.1 is widely deployed. It already solves many of the transport-level problems that would otherwise distract protocol developers and implementers from concentrating on the domain semantics of printing. It is cleanly extensible, so there is room for IPP to grow. The CGI programming model for handling the POST requests is well understood and development tools are widely available.</P>
<P class="docText">Most network-aware printers already embed a web server, because that's the natural way to make the status of the printer remotely queryable by human beings. Thus, the incremental cost of adding IPP service to the printer firmware is not large. (This is an argument that could be applied to a remarkably wide range of other network-aware hardware, including vending machines and coffee makers<sup class="docFootnote"><A class="docLink" HREF="#ch05en07">[7]</A></sup> and hot tubs!)</P><blockquote><p class="docFootnote"><sup><A NAME="ch05en07">[7]</A></sup> See RFC 2324 &lt;<A class="docLink" target="_blank" HREF="http://www.ietf.org/rfc/rfc2324.txt">http://www.ietf.org/rfc/rfc2324.txt</A>&gt; and RFC 2325 &lt;<A class="docLink" target="_blank" HREF="http://www.ietf.org/rfc/rfc2325.txt">http://www.ietf.org/rfc/rfc2325.txt</A>&gt;.</p></blockquote>
<P class="docText">About the only serious drawback of layering IPP over HTTP is that the protocol is completely driven by client requests. Thus there is no space in the model for printers to ship asynchronous alert messages back to clients. (However, smarter clients could run a trivial HTTP server to receive such alerts formatted as HTTP requests from the printer.)</P>


<A NAME="ch05lev2sec17"></A>
<H4 class="docSection2Title">5.4.3 BEEP: Blocks Extensible Exchange Protocol</H4>
<P class="docText"><A NAME="idd1e13506"></A><A NAME="idd1e13509"></A>BEEP (formerly BXXP) is a generic protocol machine that competes with HTTP for the role of universal underlayer for application protocols. There is a niche open because there is not as yet any other more established metaprotocol that is appropriate for truly peer-to-peer applications, as opposed to the client-server applications that HTTP handles well. A project website &lt;<A class="docLink" target="_blank" HREF="http://www.beepcore.org/beepcore/docs/sl-beep.jsp">http://www.beepcore.org/beepcore/docs/sl-beep.jsp</A>&gt; provides access to standards and open-source<A NAME="idd1e13520"></A> implementations in several languages.</P>
<P class="docText">BEEP has features to support both client-server and peer-to-peer modes. The authors designed the BEEP protocol and support library so that picking the right options abstracts away messy issues like data encoding, flow control, congestion-handling, support of end-to-end encryption, and assembling a large response composed of multiple transmissions,</P>
<P class="docText">Internally, BEEP peers exchange sequences of self-describing binary packets not unlike chunk types in PNG<A NAME="idd1e13532"></A>. The design is tuned more for economy and less for transparency<A NAME="idd1e13536"></A> than the classical Internet protocols or HTTP, and might be a better choice when data volumes are large. BEEP also avoids the HTTP problem that all requests have to be client-initiated; it would be better in situations in which a server needs to send asynchronous status messages back to the client.</P>
<P class="docText">BEEP is still new technology in mid-2003, and has only a few demonstration projects. But the BEEP papers are good analytical surveys of best practice in protocol design; even if BEEP itself fails to gain widespread adoption, the papers will retain considerable tutorial value.</P>

<A NAME="ch05lev2sec18"></A>
<H4 class="docSection2Title">5.4.4 XML-RPC, SOAP, and Jabber</H4>
<P class="docText"><A NAME="idd1e13551"></A><A NAME="idd1e13558"></A><A NAME="idd1e13565"></A><A NAME="idd1e13572"></A><A NAME="idd1e13575"></A><A NAME="idd1e13578"></A>There is a developing trend in application protocol design toward using XML within MIME<A NAME="idd1e13582"></A> to structure requests and payloads. BEEP peers use this format for channel negotiations. Three major protocols are going the XML route throughout: XML-RPC and SOAP (Simple Object Access Protocol) for remote procedure calls, and Jabber for instant messaging and presence. All three are XML document types.</P>
<P class="docText">XML-RPC is very much in the Unix spirit (its author observes that he learned how to program in the 1970s by reading the original source code for Unix). It's deliberately minimalist but nevertheless quite powerful, offering a way for the vast majority of RPC applications that can get by on passing around scalar boolean/integer/float/string datatypes to do their thing in a way that is lightweight and easy to understand and monitor. XML-RPC's type ontology is richer than that of a text stream, but still simple and portable enough to act as a valuable check on interface complexity. Open-source implementations<A NAME="idd1e13601"></A> are available. An excellent XML-RPC home page &lt;<A class="docLink" target="_blank" HREF="http://www.xmlrpc.com/default.htm">http://www.xmlrpc.com/</A>&gt; points to specifications and multiple open-source implementations.</P>
<P class="docText">SOAP is a more heavyweight RPC protocol with a richer type ontology that includes arrays and C-like structs. It was inspired by XML-RPC, but has been plausibly accused of being an overdesigned victim of the second-system effect. As of mid-2003 the SOAP standard is still a work in progress, but a trial implementation in Apache<A NAME="idd1e13620"></A> is tracking the drafts. Open-source client modules in Perl<A NAME="idd1e13624"></A>, Python<A NAME="idd1e13628"></A>, Tcl<A NAME="idd1e13632"></A>, and Java<A NAME="idd1e13636"></A> are readily discoverable by a Web search. The W3C draft specification is available on the Web &lt;<A class="docLink" target="_blank" HREF="http://www.w3.org/TR/SOAP/default.htm">http://www.w3.org/TR/SOAP/</A>&gt;.</P>
<P class="docText">XML-RPC and SOAP, considered as remote procedure call methods, have some associated risks that we discuss at the end of <A class="docLink" HREF="0131429019_ch07.html#ch07">Chapter 7</A>.</P>
<P class="docText">Jabber is a peer-to-peer protocol designed to support instant messaging and presence. What makes it interesting as an application protocol is that it supports passing around XML forms and live documents. Specifications, documentation, and open-source implementations are available at the Jabber Software Foundation &lt;<A class="docLink" target="_blank" HREF="http://www.jabber.org/about/overview.html">http://www.jabber.org/about/overview.html</A>&gt; site.</P>


<ul></ul></td></tr></table>
<td></td>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<td class="tt1"><a href="NFO/lib.html">[ Team LiB ]</a></td><td valign="top" class="tt1" align="right">
          <a href="0131429019_ch05lev1sec3.html"><img src="FILES/btn_prev.gif" width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a>
          <a href="0131429019_ch06.html"><img src="FILES/btn_next.gif" width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a>
</td></table>
</body></html>
