<html><head>
<META http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<!--SafClassName="docSection1Title"--><!--SafTocEntry="6.2 Designing for Transparency and Discoverability"-->
<link rel="STYLESHEET" type="text/css" href="FILES/style.css">
<link rel="STYLESHEET" type="text/css" href="FILES/docsafari.css">
<style type="text/css">	.tt1    {font-size: 10pt;}</style>
</head>
<body>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<td class="tt1"><a href="NFO/lib.html">[ Team LiB ]</a></td><td valign="top" class="tt1" align="right">
	<a href="0131429019_ch06lev1sec1.html"><img src="FILES/btn_prev.gif" width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a>
	<a href="0131429019_ch06lev1sec3.html"><img src="FILES/btn_next.gif" width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a>
</td></table>
<br>
<table width="100%" border="0" cellspacing="0" cellpadding="0"><tr><td valign="top"><A NAME="ch06lev1sec2"></A>
<H3 class="docSection1Title">6.2 Designing for Transparency and Discoverability</H3>
<P class="docText"><A NAME="idd1e14527"></A><A NAME="idd1e14532"></A>To design for transparency<A NAME="idd1e14538"></A> and discoverability, you need to apply every tactic for keeping your code simple, and also concentrate on the ways in which your code is a communication to other human beings. The first questions to ask, after "Will this design work?" are "Will it be readable to other people? Is it elegant?" We hope it is clear by now that these questions are not fluff and that elegance is not a luxury. These qualities in the human reaction to software are essential for reducing its bugginess and increasing its long-term maintainability.</P>
<A NAME="ch06lev2sec8"></A>
<H4 class="docSection2Title">6.2.1 The Zen of Transparency</H4>
<P class="docText"><A NAME="idd1e14551"></A><A NAME="idd1e14554"></A>One pattern that emerges from the examples we've examined so far in this chapter is this: If you want transparent code, the most effective route is simply not to layer too much abstraction over what you are manipulating with the code.</P>
<P class="docText">In <A class="docLink" HREF="0131429019_ch04.html#ch04">Chapter 4</A>'s section on the value of detachment, our advice was to abstract and simplify and generalize, to try and detach from the particular, accidental conditions under which a design problem was posed. The advice to abstract does not actually contradict the advice against excessive abstractions we're developing here, because there is a difference between getting free of assumptions and forgetting the problem you're trying to solve. This is part of what we were driving at when we developed the idea that glue layers need to be kept thin.</P>
<P class="docText">One of the main lessons of Zen is that we ordinarily see the world through a haze of preconceptions and fixed ideas that proceed from our desires. To achieve enlightenment, we must follow the Zen teaching not merely to let go of desire and attachment, but to experience reality exactly as it is—without the preconceptions and the fixed ideas getting in the way.</P>
<P class="docText">This is excellent pragmatic advice for software designers. It's part of what's implicit in the classic Unix advice to be minimalist. Software designers are clever people who form ideas (abstractions) about the application domains they deal with. They organize the software they write around those ideas. Then, when debugging, they often find they have great trouble seeing through those ideas to what is actually going on.</P>
<P class="docText">Any Zen master would recognize this problem instantly, yell "Three pounds of flax!", and probably clout the student a good one.<sup class="docFootnote"><A class="docLink" HREF="#ch06en06">[6]</A></sup> Consciously designing for transparency is a slightly less mystical way of addressing it.</P><blockquote><p class="docFootnote"><sup><A NAME="ch06en06">[6]</A></sup> See the koan called <span class="docEmphasis">Tozan's Three Pounds</span> in the <span class="docEmphasis">Gateless Gate</span> <A class="docLink" HREF="0131429019_app02.html#biblio55">[Mumon]</A>.</p></blockquote>
<P class="docText">In <A class="docLink" HREF="0131429019_ch04.html#ch04">Chapter 4</A> we criticized object-oriented programming in terms likely to prove a bit shocking to programmers who were raised on the 1990s gospel of OO<A NAME="idd1e14596"></A>. Object-oriented design doesn't have to be over-complicated design, but we've observed that too often it is. Too many OO designs are spaghetti-like tangles of is-a and has-a relationships, or feature thick layers of glue in which many of the objects seem to exist simply to hold places in a steep-sided pyramid of abstractions. Such designs are the opposite of transparent; they are (notoriously) opaque and difficult to debug.</P>
<P class="docText">As we've previously noted, Unix programmers are the original zealots about modularity, but tend to go about it in a quieter way. Keeping glue layers thin is part of it; more generally, our tradition teaches us to build lower, hugging the ground with algorithms and structures that are designed to be simple and transparent.</P>
<P class="docText">As with Zen art, the simplicity of good Unix code depends on exacting self-discipline and a high level of craft, neither of which are necessarily apparent on casual inspection. Transparency is hard work, but worth the effort for more than merely artistic reasons. Unlike Zen art, software requires debugging—and usually needs continuing maintenance, forward-porting, and adaptation throughout its lifetime. Transparency is therefore more than an esthetic triumph; it is a victory that will be reflected in lower costs throughout the software's life cycle.</P>

<A NAME="ch06lev2sec9"></A>
<H4 class="docSection2Title">6.2.2 Coding for Transparency and Discoverability</H4>
<P class="docText"><A NAME="idd1e14614"></A><A NAME="idd1e14619"></A>Transparency and discoverability<A NAME="idd1e14625"></A>, like modularity, are primarily properties of designs, not code. It is not sufficient to get right the low-level elements of style, such as indenting code in a clear and consistent way or having good variable-naming conventions. These qualities have much more to do with code properties that are less obvious to inspection. Here are a few to think about:</P>
<UL><LI><P class="docList">What is the maximum static depth of your procedure-call hierarchy? That is, leaving out recursions, how many levels of call might a human have to model mentally to understand the operation of the code? Hint: If it's more than four, beware.</P></LI><LI><P class="docList">Does the code have invariant properties<sup class="docFootnote"><A class="docLink" HREF="#ch06en07">[7]</A></sup> that are both strong and visible? Invariant properties help human beings reason about code and detect problem cases.</P><blockquote><p class="docFootnote"><sup><A NAME="ch06en07">[7]</A></sup> An invariant is a property of a software design that is preserved by every operation in it. For example, in most databases it is an invariant that no two records may have the same key. In a C<A NAME="idd1e14642"></A> program that correctly manipulates strings, every string buffer must contain a terminating NUL byte on exit from each string function. In an inventory system, no parts count can hold a number less than zero.</p></blockquote></LI><LI><P class="docList">Are the function calls in your APIs<A NAME="idd1e14654"></A> individually orthogonal, or do they have too many magic flags and mode bits that have a single call doing multiple tasks? Avoiding mode flags entirely can lead to a cluttered API with too many nigh-identical functions, but the obverse error (lots of easily-forgotten and confusable mode flags) is even more common.</P></LI><LI><P class="docList">Are there a handful of prominent data structures or a single global scoreboard that captures the high-level state of the system? Is this state easy to visualize and inspect, or is it diffused among many individual global variables or objects that are hard to find?</P></LI><LI><P class="docList">Is there a clean, one-to-one mapping between data structures or classes in your program and the entities in the world that they represent?</P></LI><LI><P class="docList">Is it easy to find the portion of the code responsible for any given function? How much attention have you paid to the readability not just of individual functions and modules but of the whole codebase?</P></LI><LI><P class="docList">Does the code proliferate special cases or avoid them? Every special case could interact with every other special case; all those potential collisions are bugs waiting to happen. But even more importantly, special cases make the code harder to understand.</P></LI><LI><P class="docList">How many magic numbers (unexplained constants) does the code have in it? Is it easy to discover the implementation's limits (such as critical buffer sizes) by inspection?</P></LI></UL>
<P class="docText">It's best for code to be simple. But if it answers these sorts of questions well, it can be very complex without putting an impossible cognitive burden on a human maintainer.</P>
<P class="docText">The reader might find it instructive to compare these with our checklist questions about modularity in <A class="docLink" HREF="0131429019_ch04.html#ch04">Chapter 4</A>.</P>

<A NAME="ch06lev2sec10"></A>
<H4 class="docSection2Title">6.2.3 Transparency and Avoiding Overprotectiveness</H4>
<P class="docText"><A NAME="idd1e14700"></A>Close kin to the programmer tendency to build overelaborate castles of abstractions is a tendency to overprotect others from the low-level details. While it's not bad practice to hide those details in the program's normal mode of operation (<span class="docEmphasis">fetchmail</span>'s <TT>-v</TT> switch<A NAME="idd1e14712"></A> is off by default), they should be discoverable. There's an important difference between hiding them and making them inaccessible.</P>
<P class="docText">Programs that <span class="docEmphasis">cannot</span> reveal what they are doing make troubleshooting far more difficult. Thus, experienced Unix users actually take the presence of debugging and instrumentation switches as a good sign, and their absence as possibly a bad one. Absence suggests an inexperienced or careless developer; presence suggests one with enough wisdom to follow the Rule of Transparency.<A NAME="idd1e14726"></A><A NAME="idd1e14731"></A></P>
<P class="docText">The temptation to overprotect is especially strong in GUI applications targeted for end users, like mail readers. One reason Unix developers have been cool toward GUI interfaces is that, in their designers' haste to make them 'user-friendly' each one often becomes frustratingly opaque to anyone who has to solve user problems—or, indeed, interact with it anywhere outside the narrow range predicted by the user-interface designer.</P>
<P class="docText">Worse, programs that are opaque about what they are doing tend to have a lot of assumptions baked into them, and to be frustrating or brittle or both in any use case not anticipated by the designer. Tools that look glossy but shatter under stress are not good long-term value.</P>
<P class="docText">Unix tradition pushes for programs that are flexible for a broader range of uses and troubleshooting situations, including the ability to present as much state and activity information to the user as the user indicates he is willing to handle. This is good for troubleshooting; it is also good for growing smarter, more self-reliant users.</P>

<A NAME="ch06lev2sec11"></A>
<H4 class="docSection2Title">6.2.4 Transparency and Editable Representations</H4>
<P class="docText"><A NAME="idd1e14751"></A>Another theme that emerges from these examples is the value of programs that flip a problem out of a domain in which transparency is hard into one in which it is easy. Audacity, <span class="docEmphasis">sng</span>(1) and the <span class="docEmphasis">tic</span>(1)/<span class="docEmphasis">infocmp</span>(1) pair all have this property. The objects they manipulate are not readily conformable to the hand and eye; audio files are not visual objects, and although images expressed in PNG<A NAME="idd1e14768"></A> format are visual, the complexities of PNG annotation chunks are not. All three applications turn manipulation of their binary file formats into a problem to which human beings can more readily apply intuition and competences gained from everyday experience.</P>
<P class="docText">A rule all these examples follow is that they degrade the representation as little as possible—in fact, they translate it reversibly and losslessly. This property is very important, and worth implementing even if there is no obvious application demand for that kind of 100% fidelity. It gives potential users confidence that they can experiment without degrading their data.</P>
<P class="docText">All the advantages of textual data-file formats that we discussed in <A class="docLink" HREF="0131429019_ch05.html#ch05">Chapter 5</A> also apply to the textual formats that <span class="docEmphasis">sng</span>(1), <span class="docEmphasis">infocmp</span>(1) and their kin generate. One important application for <span class="docEmphasis">sng</span>(1) is robotic generation of PNG<A NAME="idd1e14796"></A> image annotations by scripts—because <span class="docEmphasis">sng</span>(1) exists, such scripts are easier to write.</P>
<P class="docText">Whenever you face a design problem that involves editing some kind of complex binary object, the Unix tradition encourages asking first off whether you can write a tool analogous to <span class="docEmphasis">sng</span>(1)<A NAME="idd1e14809"></A> or the <span class="docEmphasis">tic</span>(1)/<span class="docEmphasis">infocmp</span>(1)<A NAME="idd1e14819"></A> pair that can do a lossless mapping to an editable textual format and back. There is no established term for programs of this kind, but we'll call them <span class="docEmphasis">textualizers</span><A NAME="idd1e14825"></A>.</P>
<P class="docText">If the binary object is dynamically generated or very large, then it may not be practical or possible to capture all the state with a textualizer. In that case, the equivalent task is to write a browser. The paradigm example is <span class="docEmphasis">fsdb</span>(1)<A NAME="idd1e14835"></A>, the file-system debugger supported under various Unixes; there is a Linux<A NAME="idd1e14839"></A> equivalent called <span class="docEmphasis">debugfs</span>(1)<A NAME="idd1e14846"></A>. The <span class="docEmphasis">psql</span>(1)<A NAME="idd1e14853"></A> used to browse PostgreSQL databases, and the <span class="docEmphasis">smbclient</span>(1)<A NAME="idd1e14860"></A> program that can be used to query Windows<A NAME="idd1e14864"></A> file shares on a SAMBA-equipped Linux machine, are two more. All five are simple CLI programs that could be driven by scripts and test harnesses.</P>
<P class="docText">Writing a textualizer or browser is a valuable exercise for at least four reasons:</P>
<UL><LI><p class="docText"><span class="docEmphasis">You gain an excellent learning experience.</span> There may be other ways that are as good to learn about the structure of the object, but none that are obviously better.</p></LI><LI><p class="docText"><span class="docEmphasis">You gain the ability to dump the contents of the structure for inspection and debugging.</span> Because such a tool makes dumping easy, you'll do it more. You'll get more information, probably leading to more insight.</p></LI><LI><p class="docText"><span class="docEmphasis">You gain the ability to easily generate test loads and unusual cases.</span> This means you are more likely to probe the odd corners of the object's state space—and to break the associated software, so you can fix it before your users break it.</p></LI><LI><p class="docText"><span class="docEmphasis">You gain code you may be able to reuse.</span> If you're careful about how you write the browser/textualizer and keep the CLI interpreter properly separated from the marshaling/unmarshaling library, you may find you have code that can be reused for your actual application.</p></LI></UL>
<P class="docText">After you've done this, you may well discover that it's possible to apply the "separated engine and interface" pattern (see <A class="docLink" HREF="0131429019_ch11.html#ch11">Chapter 11</A>) using your textualizer/debugger as the engine. All the usual benefits of this pattern will apply.</P>
<blockquote>

<p class="docText"><A NAME="idd1e14926"></A>It is desirable, although often difficult, for a textualizer to be able to read and write even a damaged binary object. For one thing, it lets you generate damaged test cases to stress-test software; for another, it can make emergency repairs a whole lot easier. It may be hard to handle cases in which the <span class="docEmphasis">structure</span> of the object is messed up, but at least you should handle cases in which the <span class="docEmphasis">content</span> of the structure is nonsense, e.g., by showing nonsense values in hex and converting the hex back to the values.</p>
<p class="docText">—Henry Spencer</p></blockquote>

<A NAME="ch06lev2sec12"></A>
<H4 class="docSection2Title">6.2.5 Transparency, Fault Diagnosis, and Fault Recovery</H4>
<P class="docText"><A NAME="idd1e14945"></A><A NAME="idd1e14950"></A>Yet another benefit of transparency, related to ease of debugging, is that transparent systems are easier to perform recovery actions on after a bug bites—and, often, more resistant to damage from bugs in the first place.</P>
<P class="docText">In comparing the terminfo database with Windows<A NAME="idd1e14959"></A> registries we noted that registries are notoriously subject to being corrupted by buggy application code. This can make the entire system unusable. Even if it doesn't, recovery can be difficult if the corruption confuses the specialized registry-editing tools.</P>
<P class="docText">Our Unix case studies illustrate ways that designing for transparency can prevent this class of problem. Because the terminfo database is not one big file, botching one terminfo entry does not make the whole terminfo data set unusable. Fully textual one-big-file formats like termcap are usually parsed with methods which (unlike block reads of binary structure dumps) can recover from single-point errors. Syntax errors in an SNG file<A NAME="idd1e14969"></A> can be corrected by hand without requiring specialized editors that might refuse to load a damaged PNG<A NAME="idd1e14975"></A> image.</P>
<P class="docText">Going back to the <span class="docEmphasis">kmail</span><A NAME="idd1e14984"></A> case study, that program makes fault diagnosis easier because it obeys the Rule of Repair<A NAME="idd1e14988"></A><A NAME="idd1e14991"></A>: SMTP failures are noisy, usefully so. You don't have to decode a layer of obfuscatory messages generated by <span class="docEmphasis">kmail</span> itself to see what the interaction with the SMTP server looks like. All you have to do is look in the right place, because <span class="docEmphasis">kmail</span> is being transparent and not throwing away information about the error state. (It helps that SMTP itself is textual and includes human-readable status messages in its transactions.)</P>
<P class="docText">Discoverability tools like textualizers and browsers also make fault diagnosis easier. We've already touched on one reason: they make inspecting the state of the system easier. But there is another effect at work as well; textualized versions of data tend to have useful redundancies (such as using whitespace for visual separation as well as explicit delimiters for parsing). These are present to make them easier to read for humans, but also have the effect of making them more resistant to being irreparably trashed by point failures. A corrupted chunk in a PNG file is seldom recoverable, but the human capacity for pattern recognition and reasoning from context might be able to repair the equivalent SNG form.<A NAME="idd1e15010"></A></P>
<P class="docText">Over and over again, the Rule of Robustness<A NAME="idd1e15016"></A><A NAME="idd1e15019"></A> is clear. Simplicity plus transparency lowers costs, reduces everybody's stress, and frees people to concentrate on new problems rather than cleaning up after old mistakes.</P>


<ul></ul></td></tr></table>
<td></td>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<td class="tt1"><a href="NFO/lib.html">[ Team LiB ]</a></td><td valign="top" class="tt1" align="right">
          <a href="0131429019_ch06lev1sec1.html"><img src="FILES/btn_prev.gif" width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a>
          <a href="0131429019_ch06lev1sec3.html"><img src="FILES/btn_next.gif" width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a>
</td></table>
</body></html>
