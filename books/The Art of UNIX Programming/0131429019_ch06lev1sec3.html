<html><head>
<META http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<!--SafClassName="docSection1Title"--><!--SafTocEntry="6.3 Designing for Maintainability"-->
<link rel="STYLESHEET" type="text/css" href="FILES/style.css">
<link rel="STYLESHEET" type="text/css" href="FILES/docsafari.css">
<style type="text/css">	.tt1    {font-size: 10pt;}</style>
</head>
<body>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<td class="tt1"><a href="NFO/lib.html">[ Team LiB ]</a></td><td valign="top" class="tt1" align="right">
	<a href="0131429019_ch06lev1sec2.html"><img src="FILES/btn_prev.gif" width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a>
	<a href="0131429019_ch07.html"><img src="FILES/btn_next.gif" width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a>
</td></table>
<br>
<table width="100%" border="0" cellspacing="0" cellpadding="0"><tr><td valign="top"><A NAME="ch06lev1sec3"></A>
<H3 class="docSection1Title">6.3 Designing for Maintainability</H3>
<P class="docText"><A NAME="idd1e15032"></A><A NAME="idd1e15035"></A>Software is maintainable to the extent that people who are not its author can successfully understand and modify it. Maintainability demands more than code that works; it demands code that follows the Rule of Clarity<A NAME="idd1e15041"></A><A NAME="idd1e15046"></A> and communicates successfully to human beings as well as the computer.</P>
<P class="docText">Unix programmers have a lot of implicit knowledge available to them about what makes for maintainable code, because Unix hosts source code that goes back decades. For reasons we'll discuss in <A class="docLink" HREF="0131429019_ch17.html#ch17">Chapter 17</A>, Unix programmers learn a tendency to scrap and rebuild rather than patching grubby code (see Rob Pike's<A NAME="idd1e15057"></A> meditation on this subject in <A class="docLink" HREF="0131429019_ch01.html#ch01">Chapter 1</A>). Thus, any sources that have survived more than a decade of evolutionary pressure have been selected for maintainability. These old, successful, well-established projects with maintainable code are the community's models for practice.</P>
<P class="docText">A question Unix programmers—and especially Unix programmers in the open-source<A NAME="idd1e15068"></A> world—learn to ask about tools they are evaluating for use is: "Is this code live, dormant, or dead?" Live code<A NAME="idd1e15072"></A> has an active developer community attached to it. Dormant code<A NAME="idd1e15076"></A> has often become dormant because the pain of maintaining it exceeded its utility to its originators. Dead code<A NAME="idd1e15080"></A> has been dormant for so long that it would be easier to reimplement an equivalent from scratch. If you want your code to live, investing effort to make it maintainable (and therefore attractive to future maintainers) will be one of the most effective ways you can spend your time.</P>
<P class="docText">Code that is designed to be both transparent and discoverable<A NAME="idd1e15087"></A> has gone a long way toward being maintainable. But there are other practices we can observe in the model projects in this chapter that are worth emulating.</P>
<P class="docText">One very important practice is an application of the Rule of Clarity<A NAME="idd1e15094"></A><A NAME="idd1e15099"></A>: choosing simple algorithms. In <A class="docLink" HREF="0131429019_ch01.html#ch01">Chapter 1</A> we quoted Ken Thompson: "When in doubt, use brute force". Thompson<A NAME="idd1e15107"></A> understood the full cost of complicated algorithms—not just that they're more bug-prone when initially implemented, but that they're harder for maintainers down the line to understand.</P>
<P class="docText">Another important practice is the inclusion of hacker's guides<A NAME="idd1e15114"></A>. It has always been highly approved behavior for source code distributions to include guide documents informally describing the key data structures and algorithms in the code. In fact, Unix programmers have often been better about producing hacker's guides than they are about writing end-user documentation.</P>
<P class="docText">The open-source community has seized on and elaborated this custom. Besides being advice to future maintainers, hacker's guides for open-source projects are also designed to make it easy for casual contributors to add features or fix bugs. The Design Notes file shipped with <span class="docEmphasis">fetchmail</span><A NAME="idd1e15123"></A> is representative. The Linux<A NAME="idd1e15127"></A> kernel sources include literally dozens of these.</P>
<P class="docText">In <A class="docLink" HREF="0131429019_ch19.html#ch19">Chapter 19</A> we'll describe conventions that Unix developers have evolved for making source code distributions easy to examine and easy to build running code from. These practices, too, promote maintainability.</P>

<ul></ul></td></tr></table>
<td></td>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<td class="tt1"><a href="NFO/lib.html">[ Team LiB ]</a></td><td valign="top" class="tt1" align="right">
          <a href="0131429019_ch06lev1sec2.html"><img src="FILES/btn_prev.gif" width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a>
          <a href="0131429019_ch07.html"><img src="FILES/btn_next.gif" width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a>
</td></table>
</body></html>
