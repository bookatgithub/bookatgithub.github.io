<html><head>
<META http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<!--SafClassName="docSection1Title"--><!--SafTocEntry="7.2 Taxonomy of Unix IPC Methods"-->
<link rel="STYLESHEET" type="text/css" href="FILES/style.css">
<link rel="STYLESHEET" type="text/css" href="FILES/docsafari.css">
<style type="text/css">	.tt1    {font-size: 10pt;}</style>
</head>
<body>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<td class="tt1"><a href="NFO/lib.html">[ Team LiB ]</a></td><td valign="top" class="tt1" align="right">
	<a href="0131429019_ch07lev1sec1.html"><img src="FILES/btn_prev.gif" width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a>
	<a href="0131429019_ch07lev1sec3.html"><img src="FILES/btn_next.gif" width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a>
</td></table>
<br>
<table width="100%" border="0" cellspacing="0" cellpadding="0"><tr><td valign="top"><A NAME="ch07lev1sec2"></A>
<H3 class="docSection1Title">7.2 Taxonomy of Unix IPC Methods</H3>
<P class="docText"><A NAME="idd1e15375"></A>As in single-process program architectures, the simplest organization is the best. The remainder of this chapter will present IPC techniques roughly in order of escalating complexity of programming them. Before using a later, more complex technique, you should prove by demonstration등ith prototypes and benchmark results듮hat no earlier and simpler technique will do. Often you will surprise yourself.</P>
<A NAME="ch07lev2sec1"></A>
<H4 class="docSection2Title">7.2.1 Handing off Tasks to Specialist Programs</H4>
<P class="docText"><A NAME="idd1e15391"></A>In the simplest form of interprogram cooperation enabled by inexpensive process spawning, a program runs another to accomplish a specialized task. Because the called program is often specified as a Unix shell command through the <span class="docEmphasis">system</span>(3)<A NAME="idd1e15400"></A> call, this is often called <span class="docEmphasis">shelling out</span><A NAME="idd1e15406"></A> to the called program. The called program inherits the user's keyboard and display and runs to completion. When it exits, the calling program resumes control of the keyboard and display and resumes execution.<sup class="docFootnote"><A class="docLink" HREF="#ch07en04">[4]</A></sup> Because the calling program does not communicate with the called program during the callee's execution, protocol design is not an issue in this kind of cooperation, except in the trivial sense that the caller may pass command-line arguments to the callee to change its behavior.</P><blockquote><p class="docFootnote"><sup><A NAME="ch07en04">[4]</A></sup> A common error in programming shellouts is to forget to block signals in the parent while the subprocess runs. Without this precaution, an interrupt typed to the subprocess can have unwanted side effects on the parent process.</p></blockquote>
<P class="docText">The classic Unix case of shelling out is calling an editor from within a mail or news program. In the Unix tradition one does <span class="docEmphasis">not</span> bundle purpose-built editors into programs that require general text-edited input. Instead, one allows the user to specify an editor of his or her choice to be called when editing needs to be done.</P>
<P class="docText">The specialist program usually communicates with its parent through the file system, by reading or modifying file(s) with specified location(s); this is how editor or mailer shellouts work.</P>
<P class="docText">In a common variant of this pattern, the specialist program may accept input on its standard input, and be called with the C<A NAME="idd1e15426"></A> library entry point <TT>popen(..., "w")</TT> or as part of a shellscript. Or it may send output to its standard output, and be called with <TT>popen(..., "r")</TT> or as part of a shellscript. (If it both reads from standard input and writes to standard output, it does so in a batch mode, completing all reads before doing any writes.) This kind of child process is not usually referred to as a shellout; there is no standard jargon for it, but it might well be called a 'bolt-on'.</P>
<P class="docText">They key point about all these cases is that the specialist programs don't handshake with the parent while they are running. They have an associated protocol only in the trivial sense that whichever program (master or slave) is accepting input from the other has to be able to parse it.</P>
<A NAME="ch07lev3sec1"></A>
<H5 class="docSection3Title">7.2.1.1 Case Study: The <span class="docEmphasis">mutt</span> Mail User Agent</H5>
<P class="docText"><A NAME="idd1e15449"></A><A NAME="idd1e15454"></A>The <span class="docEmphasis">mutt</span><A NAME="idd1e15460"></A> mail user agent is the modern representative of the most important design tradition in Unix email programs. It has a simple screen-oriented interface with single-keystroke commands for browsing and reading mail.</P>
<P class="docText">When you use <span class="docEmphasis">mutt</span><A NAME="idd1e15469"></A> as a mail composer (either by calling it with an address as a command-line argument or by using one of the reply commands), it examines the process environment variable <TT>EDITOR</TT>, and then generates a temporary file name. The value of the <TT>EDITOR</TT> variable is called as a command with the tempfile name as an argument.<sup class="docFootnote"><A class="docLink" HREF="#ch07en05">[5]</A></sup> When that command terminates, <span class="docEmphasis">mutt</span> resumes on the assumption that the temporary file contains the desired mail text.</P><blockquote><p class="docFootnote"><sup><A NAME="ch07en05">[5]</A></sup> Actually, the above is a slight oversimplification. See the discussion of <TT>EDITOR</TT> and <TT>VISUAL</TT> in <A class="docLink" HREF="0131429019_ch10.html#ch10">Chapter 10</A> for the rest of the story.</p></blockquote>
<P class="docText">Almost all Unix mail- and netnews-composition programs observe the same convention. Because they do, composer implementers don't need to write a hundred inevitably diverging editors, and users don't need to learn a hundred divergent interfaces. Instead, users can carry their chosen editors with them.</P>
<P class="docText">An important variant of this strategy shells out to a small proxy program that passes the specialist job to an already-running instance of a big program, like an editor or a Web browser. Thus, developers who normally have an instance of <span class="docEmphasis">emacs</span> running on their X display can set <span class="docEmphStrong"><TT>EDITOR=emacsclient</TT></span>, and have a buffer pop open in their <span class="docEmphasis">emacs</span> when they request editing in <span class="docEmphasis">mutt</span>. The point of this is not really to save memory or other resources, it's to enable the user to unify all editing in a single <span class="docEmphasis">emacs</span> process (so that, for example, cut and paste among buffers can carry along internal <span class="docEmphasis">emacs</span> state information like font highlighting).</P>


<A NAME="ch07lev2sec2"></A>
<H4 class="docSection2Title">7.2.2 Pipes, Redirection, and Filters</H4>
<P class="docText"><A NAME="idd1e15530"></A><A NAME="idd1e15533"></A><A NAME="idd1e15536"></A><A NAME="idd1e15539"></A><A NAME="idd1e15544"></A><A NAME="idd1e15549"></A><A NAME="idd1e15552"></A><A NAME="idd1e15557"></A>After Ken Thompson<A NAME="idd1e15561"></A> and Dennis Ritchie<A NAME="idd1e15565"></A>, the single most important formative figure of early Unix was probably Doug McIlroy<A NAME="idd1e15569"></A>. His invention of the <span class="docEmphasis">pipe</span> construct reverberated through the design of Unix, encouraging its nascent do-one-thing-well philosophy and inspiring most of the later forms of IPC in the Unix design (in particular, the socket abstraction used for networking).</P>
<P class="docText">Pipes depend on the convention that every program has initially available to it (at least) two I/O data streams: standard input and standard output (numeric file descriptors 0 and 1 respectively). Many programs can be written as <span class="docEmphasis">filters</span>, which read sequentially from standard input and write only to standard output.</P>
<P class="docText">Normally these streams are connected to the user's keyboard and display, respectively. But Unix shells universally support <span class="docEmphasis">redirection</span> operations which connect these standard input and output streams to files. Thus, typing</P>
<pre>

</pre><pre>
ls &gt;foo
</pre><pre>
</pre>
<P class="docText">sends the output of the directory lister <span class="docEmphasis">ls</span>(1) to a file named 'foo'. On the other hand, typing:</P>
<pre>

</pre><pre>
wc &lt;foo
</pre><pre>
</pre>
<P class="docText">causes the word-count utility <span class="docEmphasis">wc</span>(1)<A NAME="idd1e15615"></A> to take its standard input from the file 'foo', and deliver a character/word/line count to standard output.</P>
<P class="docText">The pipe operation connects the standard output of one program to the standard input of another. A chain of programs connected in this way is called a <span class="docEmphasis">pipeline</span>. If we write</P>
<pre>

</pre><pre>
ls | wc
</pre><pre>
</pre>
<P class="docText">we'll see a character/word/line count for the current directory listing. (In this case, only the line count is really likely to be useful.)</P>
<blockquote>

<p class="docText"><A NAME="idd1e15641"></A>One favorite pipeline was "<span class="docEmphStrong"><TT>bc | speak</TT></span>"드 talking desk calculator. It knew number names up to a vigintillion.</p>
<p class="docText">듃oug McIlroy</p></blockquote>
<P class="docText">It's important to note that all the stages in a pipeline run concurrently. Each stage waits for input on the output of the previous one, but no stage has to exit before the next can run. This property will be important later on when we look at interactive uses of pipelines, like sending the lengthy output of a command to <span class="docEmphasis">more</span>(1).</P>
<P class="docText">It's easy to underestimate the power of combining pipes and redirection. As an instructive example, <span class="docEmphasis">The Unix Shell As a 4GL</span> [Schaffer-Wolf] shows that with these facilities as a framework, a handful of simple utilities can be combined to support creating and manipulating relational databases expressed as simple textual tables.</P>
<P class="docText">The major weakness of pipes is that they are unidirectional. It's not possible for a pipeline component to pass control information back up the pipe other than by terminating (in which case the previous stage will get a <span class="docEmphStrong"><TT>SIGPIPE</TT></span> signal on the next write). Accordingly, the protocol for passing data is simply the receiver's input format.</P>
<P class="docText">So far, we have discussed anonymous pipes created by the shell. There is a variant called a <span class="docEmphasis">named pipe</span> which is a special kind of file. If two programs open the file, one for reading and the other for writing, a named pipe acts like a pipe-fitting between them. Named pipes<A NAME="idd1e15675"></A> are a bit of a historical relic; they have been largely displaced from use by named <span class="docEmphasis">sockets</span><A NAME="idd1e15681"></A>, which we'll discuss below. (For more on the history of this relic, see the discussion of System V IPC below.)</P>
<A NAME="ch07lev3sec2"></A>
<H5 class="docSection3Title">7.2.2.1 Case Study: Piping to a Pager</H5>
<P class="docText"><A NAME="idd1e15695"></A><A NAME="idd1e15698"></A>Pipelines have many uses. For one example, Unix's process lister <span class="docEmphasis">ps</span>(1) lists processes to standard output without caring that a long listing might scroll off the top of the user's display too quickly for the user to see it. Unix has another program, <span class="docEmphasis">more</span>(1), which displays its standard input in screen-sized chunks, prompting for a user keystroke after displaying each screenful.</P>
<P class="docText">Thus, if the user types "<span class="docEmphStrong"><TT>ps | more</TT></span>", piping the output of <span class="docEmphasis">ps</span>(1) to the input of <span class="docEmphasis">more</span>(1), successive page-sized pieces of the list of processes will be displayed after each keystroke.</P>
<P class="docText">The ability to combine programs like this can be extremely useful. But the real win here is not cute combinations; it's that because both pipes and <span class="docEmphasis">more</span>(1)<A NAME="idd1e15729"></A> exist, <span class="docEmphasis">other programs can be simpler</span>. Pipes mean that programs like <span class="docEmphasis">ls</span>(1)<A NAME="idd1e15739"></A> (and other programs that write to standard out) don't have to grow their own pagers드nd we're saved from a world of a thousand built-in pagers (each, naturally, with its own divergent look and feel). Code bloat is avoided and global complexity reduced.</P>
<P class="docText">As a bonus, if anyone needs to customize pager behavior, it can be done in <span class="docEmphasis">one</span> place, by changing <span class="docEmphasis">one</span> program. Indeed, multiple pagers can exist, and will all be useful with every application that writes to standard output.</P>
<P class="docText">In fact, this has actually happened. On modern Unixes, <span class="docEmphasis">more</span>(1)<A NAME="idd1e15758"></A> has been largely replaced by <span class="docEmphasis">less</span>(1)<A NAME="idd1e15765"></A>, which adds the capability to scroll back in the displayed file rather than just forward.<sup class="docFootnote"><A class="docLink" HREF="#ch07en06">[6]</A></sup> Because <span class="docEmphasis">less</span>(1) is decoupled from the programs that use it, it's possible to simply alias 'more' to 'less' in your shell, set the environment variable <TT>PAGER</TT> to 'less' (see <A class="docLink" HREF="0131429019_ch10.html#ch10">Chapter 10</A>), and get all the benefits of a better pager with all properly-written Unix programs.</P><blockquote><p class="docFootnote"><sup><A NAME="ch07en06">[6]</A></sup> The <span class="docEmphasis">less</span>(1) man page explains the name by observing "Less is more".</p></blockquote>

<A NAME="ch07lev3sec3"></A>
<H5 class="docSection3Title">7.2.2.2 Case Study: Making Word Lists</H5>
<P class="docText"><A NAME="idd1e15794"></A>A more interesting example is one in which pipelined programs cooperate to do some kind of data transformation for which, in less flexible environments, one would have to write custom code.</P>
<P class="docText">Consider the pipeline</P>
<pre>

</pre><pre>
tr -c '[:alnum:]' '[\n*]' | sort -iu | grep -v '^[0-9]*$'
</pre><pre>
</pre>
<P class="docText">The first command translates non-alphanumerics on standard input to newlines on standard output. The second sorts lines on standard input and writes the sorted data to standard output, discarding all but one copy of spans of adjacent identical lines. The third discards all lines consisting solely of digits. Together, these generate a sorted wordlist to standard output from text on standard input.</P>

<A NAME="ch07lev3sec4"></A>
<H5 class="docSection3Title">7.2.2.3 Case Study: <span class="docEmphasis">pic2graph</span></H5>
<P class="docText"><A NAME="idd1e15822"></A><A NAME="idd1e15827"></A><A NAME="idd1e15830"></A>Shell source code for the program <span class="docEmphasis">pic2graph</span>(1) ships with the <span class="docEmphasis">groff</span><A NAME="idd1e15839"></A> suite of text-formatting tools from the Free Software Foundation<A NAME="idd1e15843"></A>. It translates diagrams written in the PIC language to bitmap images. <A class="docLink" HREF="#ch07ex01">Example 7.1</A> shows the pipeline at the heart of this code.</P>

<H5 class="docExampleTitle"><A NAME="ch07ex01"></A>Example 7.1 The <span class="docEmphasis">pic2graph</span> pipeline.</H5>

<PRE>
(echo ".EQ"; echo $eqndelim; echo ".EN"; echo ".PS";cat;echo ".PE")|\
     groff -e -p $groffpic_opts -Tps &gt;${tmp}.ps \
     &amp;&amp; convert -crop 0x0 $convert_opts ${tmp}.ps ${tmp}.${format} \
     &amp;&amp; cat ${tmp}.${format}
</PRE>

<P class="docText">The <span class="docEmphasis">pic2graph</span>(1) implementation illustrates how much one pipeline can do purely by calling pre-existing tools. It starts by massaging its input into an appropriate form, continues by feeding it through <span class="docEmphasis">groff</span>(1) to produce PostScript<A NAME="idd1e15872"></A>, and finishes by converting the PostScript to a bitmap. All these details are hidden from the user, who simply sees PIC source go in one end and a bitmap ready for inclusion in a Web page come out the other.</P>
<P class="docText">This is an interesting example because it illustrates how pipes<A NAME="idd1e15879"></A> and filtering can adapt programs to unexpected uses. The program that interprets PIC, <span class="docEmphasis">pic</span>(1), was originally designed only to be used for embedding diagrams in typeset documents. Most of the other programs in the toolchain it was part of are now semiobsolescent. But PIC remains handy for new uses, such as describing diagrams to be embedded in HTML. It gets a renewed lease on life because tools like <span class="docEmphasis">pic2graph</span>(1) can bundle together all the machinery needed to convert the output of <span class="docEmphasis">pic</span>(1) into a more modern format.</P>
<P class="docText">We'll examine <span class="docEmphasis">pic</span>(1) more closely, as a minilanguage design, in <A class="docLink" HREF="0131429019_ch08.html#ch08">Chapter 8</A>.</P>

<A NAME="ch07lev3sec5"></A>
<H5 class="docSection3Title">7.2.2.4 Case Study: <span class="docEmphasis">bc</span>(1) and <span class="docEmphasis">dc</span>(1)</H5>
<P class="docText"><A NAME="idd1e15916"></A>Part of the classic Unix toolkit dating back to Version 7 is a pair of calculator programs. The <span class="docEmphasis">dc</span>(1)<A NAME="idd1e15929"></A> program is a simple calculator that accepts text lines consisting of reverse-Polish notation (RPN) on standard input and emits calculated answers to standard output. The <span class="docEmphasis">bc</span>(1)<A NAME="idd1e15936"></A> program accepts a more elaborate infix syntax resembling conventional algebraic notation; it includes as well the ability to set and read variables and define functions for elaborate formulas.</P>
<P class="docText">While the modern GNU implementation of <span class="docEmphasis">bc</span>(1) is standalone, the classic version passed commands to <span class="docEmphasis">dc</span>(1) over a pipe. In this division of labor, <span class="docEmphasis">bc</span>(1) does variable substitution and function expansion and translates infix notation into reverse-Polish득ut doesn't actually do calculation itself, instead passing RPN translations of input expressions to <span class="docEmphasis">dc</span>(1) for evaluation.</P>
<P class="docText">There are clear advantages to this separation of function. It means that users get to choose their preferred notation, but the logic for arbitrary-precision numeric calculation (which is moderately tricky) does not have to be duplicated. Each of the pair of programs can be less complex than one calculator with a choice of notations would be. The two components can be debugged and mentally modeled independently of each other.</P>
<P class="docText">In <A class="docLink" HREF="0131429019_ch08.html#ch08">Chapter 8</A> we will reexamine these programs from a slightly different example, as examples of domain-specific minilanguages.</P>

<A NAME="ch07lev3sec6"></A>
<H5 class="docSection3Title">7.2.2.5 Anti-Case Study: Why Isn't <span class="docEmphasis">fetchmail</span> a Pipeline?</H5>
<P class="docText"><A NAME="idd1e15976"></A><A NAME="idd1e15981"></A>In Unix terms, <span class="docEmphasis">fetchmail</span> is an uncomfortably large program that bristles with options. Thinking about the way mail transport works, one might think it would be possible to decompose it into a pipeline. Suppose for a moment it were broken up into several programs: a couple of fetch programs to get mail from POP3 and IMAP sites, and a local SMTP injector. The pipeline could pass Unix mailbox format. The present elaborate <span class="docEmphasis">fetchmail</span> configuration could be replaced by a shellscript containing command lines. One could even insert filters in the pipeline to block spam.</P>
<pre>

</pre><pre>
#!/bin/sh
imap jrandom@imap.ccil.org | spamblocker | smtp jrandom
imap jrandom@imap.netaxs.com | smtp jrandom
# pop ed@pop.tems.com | smtp jrandom
</pre><pre>
</pre>
<P class="docText">This would be very elegant and Unixy. Unfortunately, it can't work. We touched on the reason earlier; pipelines are unidirectional.</P>
<P class="docText">One of the things the fetcher program (<span class="docEmphasis">imap</span> or <span class="docEmphasis">pop</span>) would have to do is decide whether to send a delete request for each message it fetches. In <span class="docEmphasis">fetchmail</span>'s present organization, it can delay sending that request to the POP or IMAP server until it knows that the local SMTP listener has accepted responsibility for the message. The pipelined, small-component version would lose that property.</P>
<P class="docText">Consider, for example, what would happen if the <span class="docEmphasis">smtp</span> injector fails because the SMTP listener reports a disk-full condition. If the fetcher has already deleted the mail, we lose. This means the fetcher cannot delete mail until it is notified to do so by the <span class="docEmphasis">smtp</span> injector. This in turn raises a host of questions. How would they communicate? What message, exactly, would the injector pass back? The global complexity of the resulting system, and its vulnerability to subtle bugs, would almost certainly be higher than that of a monolithic program.</P>
<P class="docText">Pipelines are a marvelous tool, but not a universal one.</P>


<A NAME="ch07lev2sec3"></A>
<H4 class="docSection2Title">7.2.3 Wrappers</H4>
<P class="docText"><A NAME="idd1e16037"></A><A NAME="idd1e16040"></A>The opposite of a shellout is a <span class="docEmphasis">wrapper</span>. A wrapper creates a new interface for a called program, or specializes it. Often, wrappers are used to hide the details of elaborate shell pipelines<A NAME="idd1e16049"></A>. We'll discuss interface wrappers in <A class="docLink" HREF="0131429019_ch11.html#ch11">Chapter 11</A>. Most specialization wrappers are quite simple, but nevertheless very useful.</P>
<P class="docText">As with shellouts, there is no associated protocol because the programs do not communicate during the execution of the callee; but the wrapper usually exists to specify arguments that modify the callee's behavior.</P>
<A NAME="ch07lev3sec7"></A>
<H5 class="docSection3Title">7.2.3.1 Case Study: Backup Scripts</H5>
<P class="docText"><A NAME="idd1e16067"></A><A NAME="idd1e16070"></A><A NAME="idd1e16075"></A>Specialization wrappers are a classic use of the Unix shell and other scripting languages<A NAME="idd1e16083"></A><A NAME="idd1e16086"></A>. One kind of specialization wrapper that is both common and representative is a backup script. It may be a one-liner as simple as this:</P>
<pre>

</pre><pre>
tar -czvf /dev/st0 "$@"
</pre><pre>
</pre>
<P class="docText">This is a wrapper for the <span class="docEmphasis">tar</span>(1)<A NAME="idd1e16102"></A> tape archiver utility which simply supplies one fixed argument (the tape device <TT>/dev/st0</TT>) and passes to tar all the other arguments supplied by the user ("<TT>$@</TT>").<sup class="docFootnote"><A class="docLink" HREF="#ch07en07">[7]</A></sup></P><blockquote><p class="docFootnote"><sup><A NAME="ch07en07">[7]</A></sup> A common error is to use <TT>$*</TT> rather than "<TT>$@</TT>". This does bad things when handed a filename with embedded spaces.</p></blockquote>


<A NAME="ch07lev2sec4"></A>
<H4 class="docSection2Title">7.2.4 Security Wrappers and Bernstein Chaining</H4>
<P class="docText"><A NAME="idd1e16130"></A><A NAME="idd1e16133"></A><A NAME="idd1e16136"></A><A NAME="idd1e16141"></A><A NAME="idd1e16148"></A>One common use of wrapper scripts is as <span class="docEmphasis">security wrappers</span>. A security script may call a gatekeeper program to check some sort of credential, then conditionally execute another based on the status value returned by the gatekeeper.</P>
<P class="docText">Bernstein chaining is a specialized security-wrapper technique first invented by Daniel J. Bernstein, who has employed it in a number of his packages. (A similar pattern appears in commands like <span class="docEmphasis">nohup</span>(1) and <span class="docEmphasis">su</span>(1), but the conditionality is absent.) Conceptually, a Bernstein chain is like a pipeline<A NAME="idd1e16166"></A>, but each successive stage replaces the previous one rather than running concurrently with it.</P>
<P class="docText">The usual application is to confine security-privileged applications to some sort of gatekeeper program, which can then hand state to a less privileged one. The technique pastes several programs together using execs, or possibly a combination of forks and execs. The programs are all named on one command line. Each program performs some function and (if successful) runs <span class="docEmphasis">exec</span>(2) on the rest of its command line.</P>
<P class="docText">Bernstein's <span class="docEmphasis">rblsmtpd</span><A NAME="idd1e16181"></A> package is a prototypical example. It serves to look up a host in the antispam DNS zone of the Mail Abuse Prevention System. It does this by doing a DNS query on the IP address passed into it in the <TT>TCPREMOTEIP</TT> environment variable. If the query is successful, then <span class="docEmphasis">rblsmtpd</span> runs its own SMTP that discards the mail. Otherwise the remaining command-line arguments are presumed to constitute a mail transport agent that knows the SMTP protocol, and are handed to <span class="docEmphasis">exec</span>(2) to be run.</P>
<P class="docText">Another example can be found in Bernstein's <span class="docEmphasis">qmail</span> package. It contains a program called <span class="docEmphasis">condredirect</span><A NAME="idd1e16202"></A>. The first parameter is an email address, and the remainder a gatekeeper program and arguments. <span class="docEmphasis">condredirect</span> forks and execs the gatekeeper with its arguments. If the gatekeeper exits successfully, <span class="docEmphasis">condredirect</span> forwards the email pending on stdin to the specified email address. In this case, opposite to that of <span class="docEmphasis">rblsmtpd</span>, the security decision is made by the child; this case is a bit more like a classical shellout.</P>
<P class="docText">A more elaborate example is the <span class="docEmphasis">qmail</span><A NAME="idd1e16220"></A> POP3 server. It consists of three programs, <span class="docEmphasis">qmail-popup</span><A NAME="idd1e16228"></A>, <span class="docEmphasis">checkpassword</span><A NAME="idd1e16234"></A>, and <span class="docEmphasis">qmail-pop3d</span>. <span class="docEmphasis">Checkpassword</span> comes from a separate package cleverly called <span class="docEmphasis">checkpassword</span>, and unsurprisingly it checks the password. The POP3 protocol has an authentication phase and mailbox phase; once you enter the mailbox phase you cannot go back to the authentication phase. This is a perfect application for Bernstein chaining.</P>
<P class="docText">The first parameter of <span class="docEmphasis">qmail-popup</span> is the hostname to use in the POP3 prompts. The rest of its parameters are forked and passed to <span class="docEmphasis">exec</span>(2), after the POP3 username and password have been fetched. If the program returns failure, the password must be wrong, so <span class="docEmphasis">qmail-popup</span> reports that and waits for a different password. Otherwise, the program is presumed to have finished the POP3 conversation, so <span class="docEmphasis">qmail-popup</span> exits.</P>
<P class="docText">The program named on <span class="docEmphasis">qmail-popup</span>'s command line is expected to read three null-terminated strings from file descriptor 3.<sup class="docFootnote"><A class="docLink" HREF="#ch07en08">[8]</A></sup> These are the username, password, and response to a cryptographic challenge, if any. This time it's <span class="docEmphasis">checkpassword</span><A NAME="idd1e16276"></A> which accepts as parameters the name of <span class="docEmphasis">qmail-pop3d</span> and its parameters. The <span class="docEmphasis">checkpassword</span> program exits with failure if the password does not match; otherwise it changes to the user's uid, gid, and home directory, and executes the rest of its command line on behalf of that user.</P><blockquote><p class="docFootnote"><sup><A NAME="ch07en08">[8]</A></sup> <span class="docEmphasis">qmail-popup</span>'s standard input and standard output are the socket, and standard error (which will be file descriptor 2) goes to a log file. File descriptor 3 is guaranteed to be the next to be allocated. As an infamous kernel comment once observed: "You are not expected to understand this".</p></blockquote>
<P class="docText">Bernstein chaining is useful for situations in which the application needs setuid or setgid privileges to initialize a connection, or to acquire some credential, and then drop those privileges so that following code does not have to be trusted. Following the exec, the child program cannot set its real user ID back to root. It's also more flexible than a single process, because you can modify the behavior of the system by inserting another program into the chain.</P>
<P class="docText">For example, <span class="docEmphasis">rblsmtpd</span><A NAME="idd1e16294"></A> (mentioned above) can be inserted into a Bernstein chain, in between tcpserver (from the <span class="docEmphasis">ucspi-tcp</span><A NAME="idd1e16300"></A> package) and the real SMTP server, typically <span class="docEmphasis">qmail-smtpd</span><A NAME="idd1e16306"></A>. However, it works with <span class="docEmphasis">inetd</span>(8) and <span class="docEmphStrong"><TT>sendmail -bs</TT></span> as well.</P>

<A NAME="ch07lev2sec5"></A>
<H4 class="docSection2Title">7.2.5 Slave Processes</H4>
<P class="docText"><A NAME="idd1e16325"></A><A NAME="idd1e16330"></A>Occasionally, child programs both accept data from and return data to their callers through pipes<A NAME="idd1e16334"></A> connected to standard input and output, interactively. Unlike simple shellouts and what we have called 'bolt-ons' above, both master and slave processes need to have internal state machines to handle a protocol between them without deadlocking or racing. This is a drastically more complex and more difficult-to-debug organization than a simple shellout.</P>
<P class="docText">Unix's <span class="docEmphasis">popen</span>(3)<A NAME="idd1e16344"></A> call can set up either an input pipe or an output pipe for a shellout, but not both for a slave process듮his seems intended to encourage simpler programming. And, in fact, interactive master-slave communication is tricky enough that it is normally only used when either (a) the implied protocol is utterly trivial, or (b) the slave process has been designed to speak an application protocol along the lines we discussed in <A class="docLink" HREF="0131429019_ch05.html#ch05">Chapter 5</A>. We'll return to this issue, and ways to cope with it, in <A class="docLink" HREF="0131429019_ch08.html#ch08">Chapter 8</A>.</P>
<P class="docText">When writing a master/slave pair, it is good practice for the master to support a command-line switch or environment variable that allows callers to set their own slave command. Among other things, this is useful for debugging; you will often find it handy during development to invoke the real slave process from within a harness that monitors and logs transactions between slave and master.</P>
<P class="docText">If you find that master/slave interactions in your program are becoming nontrivial, it may be time to think about going the rest of the way to a more peer-to-peer organization, using techniques like sockets or shared memory.</P>
<A NAME="ch07lev3sec8"></A>
<H5 class="docSection3Title">7.2.5.1 Case Study: <span class="docEmphasis">scp</span> and <span class="docEmphasis">ssh</span></H5>
<P class="docText"><A NAME="idd1e16374"></A><A NAME="idd1e16377"></A><A NAME="idd1e16380"></A><A NAME="idd1e16391"></A>One common case in which the implied protocol really is trivial is progress meters. The <span class="docEmphasis">scp</span>(1) secure-copy command calls <span class="docEmphasis">ssh</span>(1) as a slave process, intercepting enough information from ssh's standard output to reformat the reports as an ASCII animation of a progress bar.<sup class="docFootnote"><A class="docLink" HREF="#ch07en09">[9]</A></sup></P><blockquote><p class="docFootnote"><sup><A NAME="ch07en09">[9]</A></sup> The friend who suggested this case study comments: "Yes, you can get away with this technique...if there are just a few easily-recognizable nuggets of information coming back from the slave process, and you have tongs and a radiation suit".</p></blockquote>


<A NAME="ch07lev2sec6"></A>
<H4 class="docSection2Title">7.2.6 Peer-to-Peer Inter-Process Communication</H4>
<P class="docText"><A NAME="idd1e16419"></A><A NAME="idd1e16422"></A>All the communication methods we've discussed so far have a sort of implicit hierarchy about them, with one program effectively controlling or driving another and zero or limited feedback passing in the opposite direction. In communications and networking we frequently need channels that are <span class="docEmphasis">peer-to-peer</span>, usually (but not necessarily) with data flowing freely in both directions. We'll survey peer-to-peer communications methods under Unix here, and develop some case studies in later chapters.</P>
<A NAME="ch07lev3sec9"></A>
<H5 class="docSection3Title">7.2.6.1 Tempfiles</H5>
<P class="docText"><A NAME="idd1e16438"></A><A NAME="idd1e16443"></A>The use of tempfiles as communications drops between cooperating programs is the oldest IPC technique there is. Despite drawbacks, it's still useful in shellscripts, and in one-off programs where a more elaborate and coordinated method of communication would be overkill.</P>
<P class="docText">The most obvious problem with using tempfiles as an IPC technique is that it tends to leave garbage lying around if processing is interrupted before the tempfile can be deleted. A less obvious risk is that of collisions between multiple instances of a program using the same name for a tempfile. This is why it is conventional for shellscripts that make tempfiles to include $$ in their names; this shell variable expands to the process-ID of the enclosing shell and effectively guarantees that the filename will be unique (the same trick is supported in Perl).</P>
<P class="docText">Finally, if an attacker knows the location to which a tempfile will be written, it can overwrite on that name and possibly either read the producer's data or spoof the consumer process by inserting modified or spurious data into the file.<sup class="docFootnote"><A class="docLink" HREF="#ch07en10">[10]</A></sup> This is a security risk. If the processes involved have root privileges, this is a very serious risk. It can be mitigated by setting the permissions on the tempfile directory carefully, but such arrangements are notoriously likely to spring leaks.</P><blockquote><p class="docFootnote"><sup><A NAME="ch07en10">[10]</A></sup> A particularly nasty variant of this attack is to drop in a named Unix-domain socket where the producer and consumer programs are expecting the tempfile to be.</p></blockquote>
<P class="docText">All these problems aside, tempfiles still have a niche because they're easy to set up, they're flexible, and they're less vulnerable to deadlocks or race conditions than more elaborate methods. And sometimes, nothing else will do. The calling conventions of your child process may require that it be handed a file to operate on. Our first example of a shellout to an editor demonstrates this perfectly.</P>

<A NAME="ch07lev3sec10"></A>
<H5 class="docSection3Title">7.2.6.2 Signals</H5>
<P class="docText"><A NAME="idd1e16478"></A><A NAME="idd1e16483"></A>The simplest and crudest way for two processes on the same machine to communicate with each other is for one to send the other a <span class="docEmphasis">signal</span>. Unix signals are a form of soft interrupt; each one has a default effect on the receiving process (usually to kill it). A process can declare a <span class="docEmphasis">signal handler</span><A NAME="idd1e16496"></A> that overrides the default action for the signal; the handler is a function that is executed asynchronously when the signal is received.</P>
<P class="docText">Signals were originally designed into Unix as a way for the operating system to notify programs of certain errors and critical events, not as an IPC facility. The <span class="docEmphStrong"><TT>SIGHUP</TT></span> signal, for example, is sent to every program started from a given terminal session when that session is terminated. The <span class="docEmphStrong"><TT>SIGINT</TT></span> signal is sent to whatever process is currently attached to the keyboard when the user enters the currently-defined interrupt character (often control-C). Nevertheless, signals can be useful for some IPC situations (and the POSIX-standard signal set includes two signals, <span class="docEmphStrong"><TT>SIGUSR1</TT></span> and <span class="docEmphStrong"><TT>SIGUSR2</TT></span>, intended for this use)<A NAME="idd1e16525"></A>. They are often employed as a control channel for <span class="docEmphasis">daemons</span><A NAME="idd1e16531"></A> (programs that run constantly, invisibly, in background), a way for an operator or another program to tell a daemon that it needs to either reinitialize itself, wake up to do work, or write internal-state/debugging information to a known location.</P>
<blockquote>

<p class="docText"><A NAME="idd1e16542"></A>I insisted <span class="docEmphStrong"><TT>SIGUSR1</TT></span> and <span class="docEmphStrong"><TT>SIGUSR2</TT></span> be invented for BSD. People were grabbing system signals to mean what they needed them to mean for IPC, so that (for example) some programs that segfaulted would not coredump because <span class="docEmphStrong"><TT>SIGSEGV</TT></span> had been hijacked.</p>
<p class="docText">This is a general principle듫eople will want to hijack any tools you build, so you have to design them to either be un-hijackable or to be hijacked cleanly. Those are your only choices. Except, of course, for being ignored드 highly reliable way to remain unsullied, but less satisfying than might at first appear.</p>
<p class="docText">듊en Arnold</p></blockquote>
<P class="docText">A technique often used with signal IPC is the so-called <span class="docEmphasis">pidfile</span><A NAME="idd1e16573"></A>. Programs that will need to be signaled will write a small file to a known location (often in <TT>/var/run</TT> or the invoking user's home directory) containing their process ID or PID. Other programs can read that file to discover that PID. The pidfile may also function as an implicit <span class="docEmphasis">lock file</span><A NAME="idd1e16582"></A> in cases where no more than one instance of the daemon should be running simultaneously.</P>
<P class="docText">There are actually two different flavors of signals. In the older implementations (notably V7, System III<A NAME="idd1e16589"></A>, and early System V<A NAME="idd1e16593"></A>), the handler for a given signal is reset to the default for that signal whenever the handler fires. The result of sending two of the same signal in quick succession is therefore usually to kill the process, no matter what handler was set.</P>
<P class="docText">The BSD 4.x <A NAME="idd1e16600"></A> versions of Unix changed to "reliable" signals, which do not reset unless the user explicitly requests it. They also introduced primitives to block or temporarily suspend processing of a given set of signals. Modern Unixes support both styles. You should use the BSD-style nonresetting entry points for new code, but program defensively in case your code is ever ported to an implementation that does not support them.</P>
<P class="docText">Receiving N signals does not necessarily invoke the signal handler N times. Under the older System V signal model, two or more signals spaced very closely together (that is, within a single timeslice of the target process) can result in various race conditions<sup class="docFootnote"><A class="docLink" HREF="#ch07en11">[11]</A></sup> or anomalies. Depending on what variant of signals semantics the system supports, the second and later instances may be ignored, may cause an unexpected process kill, or may have their delivery delayed until earlier instances have been processed (on modern Unixes the last is most likely).</P><blockquote><p class="docFootnote"><sup><A NAME="ch07en11">[11]</A></sup> A 'race condition'<A NAME="idd1e16612"></A> is a class of problem in which correct behavior of the system relies on two independent events happening in the right order, but there is no mechanism for ensuring that they actually will. Race conditions produce intermittent, timing-dependent problems that can be devilishly difficult to debug.</p></blockquote>
<P class="docText">The modern signals API is portable across all recent Unix versions, but not to Windows<A NAME="idd1e16623"></A> or classic (pre-OS X) MacOS.</P>

<A NAME="ch07lev3sec11"></A>
<H5 class="docSection3Title">7.2.6.3 System Daemons and Conventional Signals</H5>
<P class="docText"><A NAME="idd1e16635"></A><A NAME="idd1e16642"></A>Many well-known system daemons accept <span class="docEmphStrong"><TT>SIGHUP</TT></span> (originally the signal sent to programs on a serial-line drop, such as was produced by hanging up a modem connection) as a signal to reinitialize (that is, reload their configuration files); examples include Apache<A NAME="idd1e16652"></A> and the Linux implementations of <span class="docEmphasis">bootpd</span>(8)<A NAME="idd1e16659"></A>, <span class="docEmphasis">gated</span>(8)<A NAME="idd1e16666"></A>, <span class="docEmphasis">inetd</span>(8)<A NAME="idd1e16673"></A>, <span class="docEmphasis">mountd</span>(8)<A NAME="idd1e16680"></A>, <span class="docEmphasis">named</span>(8)<A NAME="idd1e16687"></A>, <span class="docEmphasis">nfsd</span>(8)<A NAME="idd1e16694"></A>, and <span class="docEmphasis">ypbind</span>(8)<A NAME="idd1e16701"></A>. In a few cases, <span class="docEmphStrong"><TT>SIGHUP</TT></span> is accepted in its original sense of a session-shutdown signal (notably in Linux<A NAME="idd1e16709"></A> <span class="docEmphasis">pppd</span>(8))<A NAME="idd1e16716"></A>, but that role nowadays generally goes to <span class="docEmphStrong"><TT>SIGTERM</TT></span>.</P>
<P class="docText"><span class="docEmphStrong"><TT>SIGTERM</TT></span> ('terminate') is often accepted as a graceful-shutdown signal (this is as distinct from <span class="docEmphStrong"><TT>SIGKILL</TT></span>, which does an immediate process kill and cannot be blocked or handled). <span class="docEmphStrong"><TT>SIGTERM</TT></span> actions often involve cleaning up tempfiles, flushing final updates out to databases, and the like.</P>
<P class="docText">When writing daemons, follow the Rule of Least Surprise: use these conventions, and read the manual pages to look for existing models.</P>

<A NAME="ch07lev3sec12"></A>
<H5 class="docSection3Title">7.2.6.4 Case Study: <span class="docEmphasis">fetchmail's</span> Use of Signals</H5>
<P class="docText"><A NAME="idd1e16752"></A><A NAME="idd1e16755"></A><A NAME="idd1e16762"></A>The <span class="docEmphasis">fetchmail</span> utility is normally set up to run as a daemon<A NAME="idd1e16775"></A> in background, periodically collecting mail from all remote sites defined in its run-control file and passing the mail to the local SMTP listener on port 25 without user intervention. <span class="docEmphasis">fetchmail</span> sleeps for a user-defined interval (defaulting to 15 minutes) between collection attempts, so as to avoid constantly loading the network.</P>
<P class="docText">When you invoke <span class="docEmphStrong"><TT>fetchmail</TT></span> with no arguments, it checks to see if you have a <span class="docEmphasis">fetchmail</span> daemon already running (it does this by looking for a pidfile). If no daemon is running, <span class="docEmphasis">fetchmail</span> starts up normally using whatever control information has been specified in its run-control file. If a daemon is running, on the other hand, the new <span class="docEmphasis">fetchmail</span> instance just signals the old one to wake up and collect mail immediately; then the new instance terminates. In addition, <span class="docEmphStrong"><TT>fetchmail -q</TT></span> sends a termination signal to any running <span class="docEmphasis">fetchmail</span> daemon.</P>
<P class="docText">Thus, typing <span class="docEmphStrong"><TT>fetchmail</TT></span> means, in effect, "poll now and leave a daemon running to poll later; don't bother me with the detail of whether a daemon was already running or not". Observe that the detail of which particular signals are used for wakeup and termination is something the user doesn't have to know.</P>

<A NAME="ch07lev3sec13"></A>
<H5 class="docSection3Title">7.2.6.5 Sockets</H5>
<P class="docText"><A NAME="idd1e16822"></A><A NAME="idd1e16825"></A><A NAME="idd1e16830"></A>Sockets<A NAME="idd1e16838"></A> were developed in the BSD<A NAME="idd1e16842"></A> lineage of Unix as a way to encapsulate access to data networks. Two programs communicating over a socket typically see a bidirectional byte stream<A NAME="idd1e16846"></A> (there are other socket modes and transmission methods, but they are of only minor importance). The byte stream is both sequenced (that is, even single bytes will be received in the same order sent) and reliable (socket users are guaranteed that the underlying network will do error detection and retry to ensure delivery). Socket descriptors, once obtained, behave essentially like file descriptors.</P>
<blockquote>

<p class="docText"><A NAME="idd1e16857"></A>Sockets differ from read/write in one important case. If the bytes you send arrive, but the receiving machine fails to ACK, the sending machine's TCP/IP stack will time out. So getting an error does <span class="docEmphasis">not</span> necessarily mean that the bytes didn't arrive; the receiver may be using them. This problem has profound consequences for the design of reliable protocols, because you have to be able to work properly when you don't know what was received in the past. Local I/O is 'yes/no'. Socket I/O is 'yes/no/maybe'. And nothing can ensure delivery듮he remote machine might have been destroyed by a comet.</p>
<p class="docText">듊en Arnold</p></blockquote>
<P class="docText">At the time a socket is created, you specify a <span class="docEmphasis">protocol family</span><A NAME="idd1e16870"></A> which tells the network layer how the name of the socket is interpreted. Sockets are usually thought of in connection with the Internet, as a way of passing data between programs running on different hosts; this is the AF_INET socket family<A NAME="idd1e16874"></A>, in which addresses are interpreted as host-address and service-number pairs. However, the AF_UNIX (aka AF_LOCAL) protocol family supports the same socket abstraction for communication between two processes on the same machine (names are interpreted as the locations of special files analogous to bidirectional named pipes). As an example, client programs and servers using the X windowing system<A NAME="idd1e16878"></A> typically use AF_LOCAL sockets to communicate.</P>
<P class="docText">All modern Unixes support BSD-style <A NAME="idd1e16885"></A> sockets, and as a matter of design they are usually the right thing to use for bidirectional IPC no matter where your cooperating processes are located. Performance pressure may push you to use shared memory or tempfiles or other techniques that make stronger locality assumptions, but under modern conditions it is best to assume that your code will need to be scaled up to distributed operation. More importantly, those locality assumptions may mean that portions of your system get chummier with each others' internals than ought to be the case in a good design. The separation of address spaces that sockets enforce is a feature, not a bug.</P>
<P class="docText">To use sockets gracefully, in the Unix tradition, start by designing an <span class="docEmphasis">application protocol</span><A NAME="idd1e16897"></A> for use between them드 set of requests and responses which expresses the semantics of what your programs will be communicating about in a succinct way. We've already discussed the some major issues in the design of application protocols in <A class="docLink" HREF="0131429019_ch05.html#ch05">Chapter 5</A>.</P>
<P class="docText">Sockets are supported in all recent Unixes, under Windows<A NAME="idd1e16908"></A>, and under classic MacOS as well.</P>
<A NAME="ch07lev4sec1"></A>
<H5 class="docSection4Title">7.2.6.5.1 Case Study: PostgreSQL</H5>
<P class="docText"><A NAME="idd1e16919"></A><A NAME="idd1e16922"></A>PostgreSQL is an open-source database program<A NAME="idd1e16928"></A>. Had it been implemented as a monster monolith, it would be a single program with an interactive interface that manipulates database files on disk directly. Interface would be welded together with implementation, and two instances of the program attempting to manipulate the same database at the same time would have serious contention and locking issues.</P>
<P class="docText">Instead, the PostgreSQL suite includes a server called <span class="docEmphasis">postmaster</span> and at least three client applications. One <span class="docEmphasis">postmaster</span> server process per machine runs in background and has exclusive access to the database files. It accepts requests in the SQL query minilanguage through TCP/IP<A NAME="idd1e16941"></A> sockets, and returns answers in a textual format as well. When the user runs a PostgreSQL client, that client opens a session to <span class="docEmphasis">postmaster</span> and does SQL transactions with it. The server can handle several client sessions at once, and sequences requests so that they don't interfere with each other.</P>
<P class="docText">Because the front end and back end are separate, the server doesn't need to know anything except how to interpret SQL requests from a client and send SQL reports back to it. The clients, on the other hand, don't need to know anything about how the database is stored. Clients can be specialized for different needs and have different user interfaces.</P>
<P class="docText">This organization is quite typical for Unix databases듭o much so that it is often possible to mix and match SQL clients and SQL servers. The interoperability issues are the SQL server's TCP/IP<A NAME="idd1e16954"></A> port number, and whether client and server support the same dialect of SQL.</P>

<A NAME="ch07lev4sec2"></A>
<H5 class="docSection4Title">7.2.6.5.2 Case Study: Freeciv</H5>
<P class="docText"><A NAME="idd1e16966"></A><A NAME="idd1e16969"></A>In <A class="docLink" HREF="0131429019_ch06.html#ch06">Chapter 6</A>, we introduced Freeciv as an example of transparent data formats. But more critical to the way it supports multiplayer gaming is the client/server partitioning of the code. This is a representative example of a program in which the application needs to be distributed over a wide-area network and handles communication through TCP/IP sockets.</P>
<P class="docText">The state of a running Freeciv game is maintained by a server process, the game engine. Players run GUI clients which exchange information and commands with the server through a packet protocol. All game logic is handled in the server. The details of GUI are handled in the client; different clients support different interface styles.</P>
<P class="docText">This is a very typical organization for a multiplayer online game. The packet protocol uses TCP/IP<A NAME="idd1e16985"></A> as a transport, so one server can handle clients running on different Internet hosts. Other games that are more like real-time simulations (notably first-person shooters) use raw Internet datagram protocol (UDP) and trade lower latency for some uncertainty about whether any given packet will be delivered. In such games, users tend to be issuing control actions continuously, so sporadic dropouts are tolerable, but lag is fatal.</P>


<A NAME="ch07lev3sec14"></A>
<H5 class="docSection3Title">7.2.6.6 Shared Memory</H5>
<P class="docText"><A NAME="idd1e16998"></A><A NAME="idd1e17001"></A><A NAME="idd1e17006"></A><A NAME="idd1e17013"></A>Whereas two processes using sockets to communicate may live on different machines (and, in fact, be separated by an Internet connection spanning half the globe), shared memory requires producers and consumers to be co-resident on the same hardware. But, if your communicating processes can get access to the same physical memory, shared memory will be the fastest way to pass information between them.</P>
<P class="docText">Shared memory may be disguised under different APIs, but on modern Unixes the implementation normally depends on the use of <span class="docEmphasis">mmap</span>(2)<A NAME="idd1e17026"></A> to map files into memory that can be shared between processes. POSIX<A NAME="idd1e17030"></A> defines a shm_<span class="docEmphasis">open</span>(3) facility with an API that supports using files as shared memory; this is mostly a hint to the operating system that it need not flush the pseudofile data to disk.</P>
<P class="docText">Because access to shared memory is not automatically serialized by a discipline resembling read and write calls, programs doing the sharing must handle contention and deadlock issues themselves, typically by using semaphore variables located in the shared segment. The issues here resemble those in multithreading (see the end of this chapter for discussion) but are more manageable because default is <span class="docEmphasis">not</span> to share memory. Thus, problems are better contained.</P>
<P class="docText">On systems where it is available and reliable, the Apache<A NAME="idd1e17049"></A> web server's scoreboard facility uses shared memory for communication between an Apache master process and the load-sharing pool of Apache images that it manages. Modern X implementations also use shared memory, to pass large images between client and server when they are resident on the same machine, to avoid the overhead of socket communication. Both uses are performance hacks justified by experience and testing, rather than being architectural choices.</P>
<P class="docText">The <span class="docEmphasis">mmap</span>(2) call is supported under all modern Unixes, including Linux<A NAME="idd1e17059"></A> and the open-source<A NAME="idd1e17063"></A> BSD<A NAME="idd1e17067"></A> versions; this is described in the Single Unix Specification<A NAME="idd1e17073"></A>. It will not normally be available under Windows<A NAME="idd1e17077"></A>, MacOS classic, and other operating systems.</P>
<P class="docText">Before purpose-built <span class="docEmphasis">mmap</span>(2) was available, a common way for two processes to communicate was for them to open the same file, and then delete that file. The file wouldn't go away until all open filehandles were closed, but some old Unixes took the link count falling to zero as a hint that they could stop updating the on-disk copy of the file. The downside was that your backing store was the file system rather than a swap device, the file system the deleted file lived on couldn't be unmounted until the programs using it closed, and attaching new processes to an existing shared memory segment faked up in this way was tricky at best.</P>
<P class="docText">After Version 7 and the split between the BSD<A NAME="idd1e17090"></A> and System V<A NAME="idd1e17094"></A> lineages, the evolution of Unix interprocess communication took two different directions. The BSD direction led to sockets. The AT&amp;T<A NAME="idd1e17098"></A> lineage, on the other hand, developed named pipes<A NAME="idd1e17102"></A> (as previously discussed) and an IPC facility, specifically designed for passing binary data and based on shared-memory bidirectional message queues. This is called 'System V IPC'듪r, among old timers, 'Indian Hill' IPC after the AT&amp;T facility where it was first written.</P>
<P class="docText">The upper, message-passing layer of System V IPC<A NAME="idd1e17120"></A> has largely fallen out of use. The lower layer, which consists of shared memory and semaphores, still has significant applications under circumstances in which one needs to do mutual-exclusion locking and some global data sharing among processes running on the same machine. These System V shared memory facilities evolved into the POSIX<A NAME="idd1e17124"></A> shared-memory API, supported under Linux, the BSDs, MacOS X and Windows<A NAME="idd1e17131"></A><A NAME="idd1e17134"></A>, but not classic MacOS<A NAME="idd1e17140"></A>.</P>
<P class="docText">By using these shared-memory and semaphore facilities (<span class="docEmphasis">shmget</span>(2), <span class="docEmphasis">semget</span>(2), and friends) one can avoid the overhead of copying data through the network stack. Large commercial databases (including Oracle, DB2, Sybase, and Informix) use this technique heavily.</P>



<a href="0131429019_18071533.html"><img src="FILES/pixel.gif" width="1" height="1" border="0"></a><ul></ul></td></tr></table>
<td></td>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<td class="tt1"><a href="NFO/lib.html">[ Team LiB ]</a></td><td valign="top" class="tt1" align="right">
          <a href="0131429019_ch07lev1sec1.html"><img src="FILES/btn_prev.gif" width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a>
          <a href="0131429019_ch07lev1sec3.html"><img src="FILES/btn_next.gif" width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a>
</td></table>
</body></html>
