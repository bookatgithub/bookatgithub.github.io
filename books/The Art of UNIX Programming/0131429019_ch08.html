<html><head>
<META http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<!--SafClassName="docChapterTitle"--><!--SafTocEntry="Chapter 8. Minilanguages: Finding a Notation That Sings"-->
<link rel="STYLESHEET" type="text/css" href="FILES/style.css">
<link rel="STYLESHEET" type="text/css" href="FILES/docsafari.css">
<style type="text/css">	.tt1    {font-size: 10pt;}</style>
</head>
<body>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<td class="tt1"><a href="NFO/lib.html">[ Team LiB ]</a></td><td valign="top" class="tt1" align="right">
	<a href="0131429019_ch07lev1sec4.html"><img src="FILES/btn_prev.gif" width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a>
	<a href="0131429019_ch08lev1sec1.html"><img src="FILES/btn_next.gif" width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a>
</td></table>
<br>
<table width="100%" border="0" cellspacing="0" cellpadding="0"><tr><td valign="top"><A NAME="ch08"></A>
<H2 class="docChapterTitle">Chapter 8. Minilanguages: Finding a Notation That Sings</H2>
<blockquote>

<p class="docText">A good notation has a subtlety and suggestiveness which at times makes it almost seem like a live teacher.</p>
<p class="docText"><span class="docEmphasis">The World of Mathematics (1956)</span><A NAME="idd1e17748"></A><A NAME="idd1e17751"></A><A NAME="idd1e17754"></A></p>
<p class="docText">—Bertrand Russell</p></blockquote>
<P class="docText">One of the most consistent results from large-scale studies of error patterns in software is that programmer error rates in defects per hundreds of lines are largely independent of the language in which the programmers are coding.<sup class="docFootnote"><A class="docLink" HREF="#ch08en01">[1]</A></sup> Higher-level languages, which allow you to get more done in fewer lines, mean fewer bugs as well.</P><blockquote><p class="docFootnote"><sup><A NAME="ch08en01">[1]</A></sup> Les Hatton<A NAME="idd1e17766"></A> reports by email on the analysis in his book in preparation, <span class="docEmphasis">Software Failure</span>: "Provided you use executable line counts for the density measure, the injected defect densities vary less between languages than they do between engineers by about a factor of 10".</p></blockquote>
<P class="docText">Unix has a long tradition of hosting little languages specialized for a particular application domain, languages that can enable you to drastically reduce the line count of your programs. Domain-specific language examples include the numerous Unix typesetting languages (<span class="docEmphasis">troff</span><A NAME="idd1e17779"></A>, <span class="docEmphasis">eqn</span><A NAME="idd1e17785"></A>, <span class="docEmphasis">tbl</span><A NAME="idd1e17791"></A>, <span class="docEmphasis">pic</span><A NAME="idd1e17797"></A>, <span class="docEmphasis">grap</span><A NAME="idd1e17803"></A>), shell utilities (<span class="docEmphasis">awk</span><A NAME="idd1e17809"></A>, <span class="docEmphasis">sed</span><A NAME="idd1e17815"></A>, <span class="docEmphasis">dc</span><A NAME="idd1e17821"></A>, <span class="docEmphasis">bc</span><A NAME="idd1e17827"></A>), and software development tools (<span class="docEmphasis">make</span><A NAME="idd1e17833"></A>, <span class="docEmphasis">yacc</span><A NAME="idd1e17839"></A>, <span class="docEmphasis">lex</span><A NAME="idd1e17845"></A>). There is a fuzzy boundary between domain-specific languages and the more flexible sort of application run-control file (<span class="docEmphasis">sendmail</span><A NAME="idd1e17851"></A>, BIND<A NAME="idd1e17855"></A>, X<A NAME="idd1e17859"></A>); another with data-file formats; and another with scripting languages<A NAME="idd1e17863"></A><A NAME="idd1e17866"></A> (which we'll survey in <A class="docLink" HREF="0131429019_ch14.html#ch14">Chapter 14</A>).</P>
<P class="docText">Historically, domain-specific languages<A NAME="idd1e17877"></A> of this kind have been called 'little languages' or 'minilanguages' in the Unix world, because early examples were small and low in complexity relative to general-purpose languages (all three terms for the category are in common use). But if the application domain is complex (in that it has lots of different primitive operations or involves manipulation of intricate data structures), an application language for it may have to be rather more complex than some general-purpose languages. We'll keep the traditional term 'minilanguage' to emphasize that the wise course is usually to keep these designs as small and simple as possible.</P>
<P class="docText">The domain-specific little language is an extremely powerful design idea. It allows you to define your own higher-level language to specify the appropriate methods, rules, and algorithms for the task at hand, reducing global complexity relative to a design that uses hardwired lower-level code for the same ends. You can get to a minilanguage design<A NAME="idd1e17884"></A> in at least three ways, two of them good and one of them dangerous.</P>
<P class="docText">One right way to get there is to realize up front that you can use a minilanguage design to push a given specification of a programming problem up a level, into a notation that is more compact and expressive than you could support in a general-purpose language. As with code generation and data-driven programming, a minilanguage lets you take practical advantage of the fact that the defect rate in your software will be largely independent of the level of the language you are using; more expressive languages mean shorter programs and fewer bugs.</P>
<P class="docText">The second right way to get to a minilanguage design is to notice that one of your specification file formats is looking more and more like a minilanguage—that is, it is developing complex structures and implying actions in the application you are controlling. Is it trying to describe control flow as well as data layouts? If so, it may be time to promote that control flow from being implicit to being explicit in your specification language.</P>
<P class="docText">The wrong way to get to a minilanguage design is to extend your way to it, one patch and crufty added feature at a time. On this path, your specification file keeps sprouting more implied control flow and more tangled special-purpose structures until it has become an ad-hoc language without your noticing it. Some legendary nightmares have been spawned this way; the example every Unix guru will think of (and shudder over) is the <TT>sendmail.cf</TT> configuration file associated with the <span class="docEmphasis">sendmail</span><A NAME="idd1e17904"></A> mail transport.</P>
<P class="docText">Sadly, most people do their first minilanguage the wrong way, and only realize later what a mess it is. Then the question is: how to clean it up? Sometimes the answer implies rethinking the entire application design. Another notorious example of language-by-feature creep was the editor <span class="docEmphasis">TECO</span><A NAME="idd1e17913"></A>, which grew first macros and then loops and conditionals as programmers wanted to use it to package increasingly complex editing routines. The resulting ugliness was eventually fixed by a redesign of the entire editor to be based on an intentional language; this is how Emacs Lisp<A NAME="idd1e17917"></A> (which we'll survey below) evolved.</P>
<P class="docText">All sufficiently complicated specification files aspire to the condition of minilanguages. Therefore, it will often be the case that your only defense against designing a bad minilanguage is knowing how to design a good one. This need not be a huge step or involve knowing a lot of formal language theory; with modern tools, learning a few relatively simple techniques and bearing good examples in mind as you design should be sufficient.</P>
<P class="docText">In this chapter we'll examine all the kinds of minilanguages normally supported under Unix, and try to identify the kinds of situation in which each of them represents an effective design solution. This chapter is not meant to be an exhaustive catalog of Unix languages, but rather to bring out the design principles involved in structuring an application around a minilanguage. We'll have much more to say about languages for general-purpose programming in <A class="docLink" HREF="0131429019_ch14.html#ch14">Chapter 14</A>.</P>
<P class="docText">We'll need to start by doing a little taxonomy, so we'll know what we're talking about later on.</P>

<ul></ul></td></tr></table>
<td></td>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<td class="tt1"><a href="NFO/lib.html">[ Team LiB ]</a></td><td valign="top" class="tt1" align="right">
          <a href="0131429019_ch07lev1sec4.html"><img src="FILES/btn_prev.gif" width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a>
          <a href="0131429019_ch08lev1sec1.html"><img src="FILES/btn_next.gif" width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a>
</td></table>
</body></html>
