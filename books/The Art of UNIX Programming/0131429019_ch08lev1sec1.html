<html><head>
<META http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<!--SafClassName="docSection1Title"--><!--SafTocEntry="8.1 Understanding the Taxonomy of Languages"-->
<link rel="STYLESHEET" type="text/css" href="FILES/style.css">
<link rel="STYLESHEET" type="text/css" href="FILES/docsafari.css">
<style type="text/css">	.tt1    {font-size: 10pt;}</style>
</head>
<body>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<td class="tt1"><a href="NFO/lib.html">[ Team LiB ]</a></td><td valign="top" class="tt1" align="right">
	<a href="0131429019_ch08.html"><img src="FILES/btn_prev.gif" width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a>
	<a href="0131429019_ch08lev1sec2.html"><img src="FILES/btn_next.gif" width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a>
</td></table>
<br>
<table width="100%" border="0" cellspacing="0" cellpadding="0"><tr><td valign="top"><A NAME="ch08lev1sec1"></A>
<H3 class="docSection1Title">8.1 Understanding the Taxonomy of Languages</H3>
<P class="docText"><A NAME="idd1e17941"></A>All the languages in <A class="docLink" HREF="#ch08fig01">Figure 8.1</A> are described in case studies, either in this chapter or elsewhere in this book. For the general-purpose interpreters near the right-hand side, see <A class="docLink" HREF="0131429019_ch14.html#ch14">Chapter 14</A>.</P>
<CENTER>
<H5 class="docFigureTitle"><A NAME="ch08fig01"></A>Figure 8.1. Taxonomy of languages.</H5>

<p class="docText">
<IMG BORDER="0" WIDTH="500" HEIGHT="164" src="FILES/08fig01.gif" ALT="graphics/08fig01.gif"></p>

</CENTER>
<P class="docText">In <A class="docLink" HREF="0131429019_ch05.html#ch05">Chapter 5</A> we looked at Unix conventions for data files. There's a spectrum of complexity in these. At the low end are files that make simple associations between names and properties; the <TT>/etc/passwd</TT> and <TT>.newsrc</TT> formats are good examples. Further up the scale we start to get formats that marshal or serialize data structures; the PNG<A NAME="idd1e17983"></A><A NAME="idd1e17986"></A> and SNG formats<A NAME="idd1e17995"></A> are (equivalent) good examples of this.</P>
<P class="docText">A structured data-file format starts to border on being a minilanguage when it expresses not just structure but actions performed on some interpretive context (that is, memory that is outside the data file itself). XML markups tend to straddle this border; the example we'll look at here is <span class="docEmphasis">Glade</span><A NAME="idd1e18004"></A>, a code generator for building GUI interfaces. Formats that are both designed to be read and written by humans (rather than just programs) and are used to generate code, are firmly in the realm of minilanguages. <span class="docEmphasis">yacc</span><A NAME="idd1e18010"></A> and <span class="docEmphasis">lex</span><A NAME="idd1e18016"></A> are the classic examples. We'll discuss <span class="docEmphasis">glade</span>, <span class="docEmphasis">yacc</span> and <span class="docEmphasis">lex</span> in <A class="docLink" HREF="0131429019_ch09.html#ch09">Chapter 9</A>.</P>
<P class="docText">The Unix macro processor, <span class="docEmphasis">m4</span><A NAME="idd1e18038"></A>, is another very simple declarative minilanguage (that is, one in which the program is expressed as a set of desired relationships or constraints rather than explicit actions). It has often been used as a preprocessing stage for other minilanguages.</P>
<P class="docText">Unix makefiles, which are designed to automate build processes, express dependency relationships between source and derived files<sup class="docFootnote"><A class="docLink" HREF="#ch08en02">[2]</A></sup> and the commands required to make each derived file from its sources. When you run make, it uses those declarations to walk the implied tree of dependencies, doing the least work necessary to bring your build up to date. Like <span class="docEmphasis">yacc</span> and <span class="docEmphasis">lex</span> specifications, makefiles are a declarative minilanguage; they set up constraints that imply actions performed on an interpretive context (in this case, the portion of the file system where the source and generated files live). We'll return to makefiles in <A class="docLink" HREF="0131429019_ch15.html#ch15">Chapter 15</A>.</P><blockquote><p class="docFootnote"><sup><A NAME="ch08en02">[2]</A></sup> For less technical readers: the compiled form of a C<A NAME="idd1e18048"></A> program is derived from its C source form by compilation and linkage. The PostScript version of a troff document is derived from the troff source; the command to make the former from the latter is a <span class="docEmphasis">troff</span><A NAME="idd1e18054"></A> invocation. There are many other kinds of derivation; makefiles can express almost all of them.</p></blockquote>
<P class="docText">XSLT<A NAME="idd1e18072"></A>, the language used to describe transformations of XML, is at the high end of complexity for declarative minilanguages. It's complex enough that it's not normally thought of as a minilanguage at all, but it shares some important characteristic of such languages which we'll examine when we look at it in more detail below.</P>
<P class="docText">The spectrum of minilanguages<A NAME="idd1e18079"></A> ranges from declarative (with implicit actions) to imperative (with explicit actions). The run-control syntax of <span class="docEmphasis">fetchmail</span>(1)<A NAME="idd1e18088"></A><A NAME="idd1e18091"></A> can be viewed as either a very weak imperative language or a declarative language with implied control flow. The troff and PostScript<A NAME="idd1e18097"></A> typesetting languages are imperative languages with a lot of special-purpose domain expertise baked into them.</P>
<P class="docText">Some task-specific imperative minilanguages start to border on being general-purpose interpreters. They reach this level when they are explicitly <span class="docEmphasis">Turing-complete</span><A NAME="idd1e18106"></A>—that is, they can do both conditionals and loops (or recursion)<sup class="docFootnote"><A class="docLink" HREF="#ch08en03">[3]</A></sup> with features that are designed to be used as control structures. Some languages, by contrast, are only accidentally Turing-complete—they have features that can be used to implement control structures as a sort of side effect of what they are actually designed to do.</P><blockquote><p class="docFootnote"><sup><A NAME="ch08en03">[3]</A></sup> Any Turing-complete language could theoretically be used for general-purpose programming, and is theoretically exactly as powerful as any other Turing-complete language. In practice, some Turing-complete languages would be far too painful to use for anything outside a specified and narrow problem domain.</p></blockquote>
<P class="docText">The <span class="docEmphasis">bc</span>(1)<A NAME="idd1e18120"></A> and <span class="docEmphasis">dc</span>(1)<A NAME="idd1e18127"></A> interpreters we looked at in <A class="docLink" HREF="0131429019_ch07.html#ch07">Chapter 7</A> are good examples of specialized imperative minilanguages that are explicitly Turing-complete.</P>
<P class="docText">We are over the border into general-purpose interpreters when we reach languages like Emacs Lisp<A NAME="idd1e18138"></A> and JavaScript<A NAME="idd1e18142"></A> that are designed to be full programming languages run in specialized contexts. We'll have more to say about these when we discuss embedded scripting languages<A NAME="idd1e18146"></A><A NAME="idd1e18149"></A> later on.</P>
<P class="docText">The spectrum in interpreters is one of increasing generality; the flip side of this is that a more general-purpose interpreter embodies fewer assumptions about the context in which it runs. With increasing generality there usually comes a richer ontology of data types. Shell<A NAME="idd1e18156"></A> and Tcl<A NAME="idd1e18160"></A> have relatively simple ontologies; Perl<A NAME="idd1e18164"></A>, Python<A NAME="idd1e18168"></A>, and Java<A NAME="idd1e18172"></A> more complex ones. We'll return to these general-purpose languages in <A class="docLink" HREF="0131429019_ch14.html#ch14">Chapter 14</A>.</P>

<a href="0131429019_18071533.html"><img src="FILES/pixel.gif" width="1" height="1" border="0"></a><ul></ul></td></tr></table>
<td></td>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<td class="tt1"><a href="NFO/lib.html">[ Team LiB ]</a></td><td valign="top" class="tt1" align="right">
          <a href="0131429019_ch08.html"><img src="FILES/btn_prev.gif" width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a>
          <a href="0131429019_ch08lev1sec2.html"><img src="FILES/btn_next.gif" width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a>
</td></table>
</body></html>
