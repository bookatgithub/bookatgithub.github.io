<html><head>
<META http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<!--SafClassName="docSection1Title"--><!--SafTocEntry="8.2 Applying Minilanguages"-->
<link rel="STYLESHEET" type="text/css" href="FILES/style.css">
<link rel="STYLESHEET" type="text/css" href="FILES/docsafari.css">
<style type="text/css">	.tt1    {font-size: 10pt;}</style>
</head>
<body>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<td class="tt1"><a href="NFO/lib.html">[ Team LiB ]</a></td><td valign="top" class="tt1" align="right">
	<a href="0131429019_ch08lev1sec1.html"><img src="FILES/btn_prev.gif" width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a>
	<a href="0131429019_ch08lev1sec3.html"><img src="FILES/btn_next.gif" width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a>
</td></table>
<br>
<table width="100%" border="0" cellspacing="0" cellpadding="0"><tr><td valign="top"><A NAME="ch08lev1sec2"></A>
<H3 class="docSection1Title" id="162666-947">8.2 Applying Minilanguages</H3>
<P class="docText"><A NAME="idd1e18188"></A>Designing with minilanguages involves two distinct challenges. One is having existing minilanguages handy in your toolkit, and recognizing when they can be applied as-is. The other is knowing when it is appropriate to design a custom minilanguage for an application. To help you develop both aspects of your design sense, about half of this chapter will consist of case studies.</P>
<A NAME="ch08lev2sec1"></A>
<H4 class="docSection2Title">8.2.1 Case Study: <span class="docEmphasis">sng</span></H4>
<P class="docText"><A NAME="idd1e18203"></A><A NAME="idd1e18206"></A>In <A class="docLink" HREF="0131429019_ch06.html#ch06">Chapter 6</A> we looked at <span class="docEmphasis">sng</span>(1), which translates between PNG<A NAME="idd1e18221"></A> and an editable all-text representation of the same bits. The SNG data-file format is worth reexamining for contrast here because it is not quite a domain-specific minilanguage. It describes a data layout, but doesn't associate any implied sequence of actions with the data.</P>
<P class="docText">SNG does, however, share one important characteristic with domain-specific minilanguages that binary structured data formats like PNG do not—transparency<A NAME="idd1e18236"></A>. Structured data files make it possible for editing, conversion, and generation tools to cooperate without knowing about each others' design assumptions other than through the medium of the minilanguage. What SNG adds is that, like a domain-specific minilanguage, it's designed to be easy to parse by eyeball and edit with general-purpose tools.</P>

<A NAME="ch08lev2sec2"></A>
<H4 class="docSection2Title">8.2.2 Case Study: Regular Expressions</H4>
<P class="docText"><A NAME="idd1e18253"></A><A NAME="idd1e18256"></A>A kind of specification that turns up repeatedly in Unix tools and scripting languages<A NAME="idd1e18262"></A> is the <span class="docEmphasis">regular expression</span> ('regexp' for short). We consider it here as a declarative minilanguage for describing text patterns; it is often embedded in other minilanguages. Regexps are so ubiquitous that the are hardly thought of as a minilanguage, but they replace what would otherwise be huge volumes of code implementing different (and incompatible) search capabilities.</P>
<P class="docText">This introduction skates over some details like POSIX <A NAME="idd1e18272"></A> extensions, back-references, and internationalization features; for a more complete treatment, see <span class="docEmphasis">Mastering Regular Expressions</span> <A class="docLink" HREF="0131429019_app02.html#biblio22">[Friedl]</A>.</P>
<P class="docText">Regular expressions describe patterns that may either match or fail to match against strings. The simplest regular-expression tool is <span class="docEmphasis">grep</span>(1), a filter that passes through to its output every line in its input matching a specified regexp. Regexp notation is summarized in <A class="docLink" HREF="#ch08table01">Table 8.1</A>.</P>
<P class="docText">There are a number of minor variants of regexp notation:</P>
<span style="font-weight:bold"><OL class="docList" TYPE="1"><LI><span style="font-weight:normal"><p class="docText"><span class="docEmphasis">Glob expressions.</span> <A NAME="idd1e18304"></A><A NAME="idd1e18309"></A><A NAME="idd1e18316"></A> This is the limited set of wildcard conventions used by early Unix shells for filename matching. There are only three wildcards: <TT>*</TT>, which matches any sequence of characters (like <TT>.*</TT> in the other variants); <TT>?</TT>, which matches any single character (like <TT>.</TT> in the other variants); and <TT>[...]</TT>, which matches a character class just as in the other variants. Some shells (<TT>csh</TT>, <TT>bash</TT>, <TT>zsh</TT>) later added <TT>{}</TT> for alternation. Thus, <TT>x{a,b}c</TT> matches <TT>xac</TT> or <TT>xbc</TT> but not <TT>xc</TT>. Some shells further extend globs in the direction of extended regular expressions.</p></span></LI><LI><span style="font-weight:normal"><p class="docText"><span class="docEmphasis">Basic regular expressions.</span> <A NAME="idd1e18372"></A><A NAME="idd1e18377"></A> This is the notation accepted by the original <span class="docEmphasis">grep</span>(1) utility for extracting lines matching a given regexp from a file. The line editor <span class="docEmphasis">ed</span>(1)<A NAME="idd1e18391"></A>, the stream editor <span class="docEmphasis">sed</span>(1)<A NAME="idd1e18398"></A>, also use these. Old Unix hands think of these as the basic or 'vanilla' flavor of regexp; people first exposed to the more modern tools tend to assume the extended form described next.</p></span></LI><LI><span style="font-weight:normal"><p class="docText"><span class="docEmphasis">Extended regular expressions.</span> <A NAME="idd1e18409"></A><A NAME="idd1e18414"></A> This is the notation accepted by the extended grep utility <span class="docEmphasis">egrep</span>(1) for extracting lines matching a given regexp from a file. Regular expressions in Lex and the <span class="docEmphasis">Emacs</span> editor are very close to the <span class="docEmphasis">egrep</span><A NAME="idd1e18430"></A> flavor.</p></span></LI><LI><span style="font-weight:normal"><p class="docText"><span class="docEmphasis">Perl regular expressions.</span> <A NAME="idd1e18441"></A><A NAME="idd1e18446"></A> This is the notation accepted by Perl<A NAME="idd1e18454"></A> and Python<A NAME="idd1e18458"></A> regexp functions. These are quite a bit more powerful than the <span class="docEmphasis">egrep</span> flavor.</p></span></LI></OL></span>
<A NAME="ch08table01"></A><P><TABLE CELLSPACING="0" FRAME="below" RULES="groups" CELLPADDING="5" WIDTH="100%"><CAPTION><h5 class="docTableTitle">Table 8.1. Regular-expression examples.</h5></CAPTION><COLGROUP align="left" span="2"><THEAD><TR><TH class="docTableHeader" valign="top"><P class="docText"><span class="docEmphasis">Regexp</span></P></TH><TH class="docTableHeader" valign="top"><P class="docText"><span class="docEmphasis">Matches</span></P></TH></TR></THEAD><TR><TD class="docTableCell" valign="top"><P class="docText"><TT>"x.y"</TT></P></TD><TD class="docTableCell" valign="top"><P class="docText"><TT>x</TT> followed by any character followed by <TT>y</TT>.</P></TD></TR><TR><TD class="docTableCell" valign="top"><P class="docText"><TT>"x\.y"</TT></P></TD><TD class="docTableCell" valign="top"><P class="docText"><TT>x</TT> followed by a literal period followed by <TT>y</TT>.</P></TD></TR><TR><TD class="docTableCell" valign="top"><P class="docText"><TT>"xz?y"</TT></P></TD><TD class="docTableCell" valign="top"><P class="docText"><TT>x</TT> followed by at most one <TT>z</TT> followed by <TT>y</TT>; thus, <TT>"xy"</TT> or <TT>"xzy"</TT> but not <TT>"xz"</TT> or <TT>"xdy"</TT>.</P></TD></TR><TR><TD class="docTableCell" valign="top"><P class="docText"><TT>"xz*y"</TT></P></TD><TD class="docTableCell" valign="top"><P class="docText"><TT>x</TT> followed by any number of instances of <TT>z</TT>, followed by <TT>y</TT>; thus, <TT>"xy"</TT> or <TT>"xzy"</TT> or <TT>"xzzzy"</TT> but not <TT>"xz"</TT> or <TT>"xdy"</TT>.</P></TD></TR><TR><TD class="docTableCell" valign="top"><P class="docText"><TT>"xz+y"</TT></P></TD><TD class="docTableCell" valign="top"><P class="docText"><TT>x</TT> followed by one or more instances of <TT>z</TT>, followed by <TT>y</TT>; thus, <TT>"xzy"</TT> or <TT>"xzzy"</TT> but not <TT>"xy"</TT> or <TT>"xz"</TT> or <TT>"xdy"</TT>.</P></TD></TR><TR><TD class="docTableCell" valign="top"><P class="docText"><TT>"s[xyz]t"</TT></P></TD><TD class="docTableCell" valign="top"><P class="docText"><TT>s</TT> followed by any of the characters <TT>x</TT> or <TT>y</TT> or <TT>z</TT>, followed by <TT>t</TT>; thus, <TT>"sxt"</TT> or <TT>"syt"</TT> or <TT>"szt"</TT> but not <TT>"st"</TT> or <TT>"sat"</TT>.</P></TD></TR><TR><TD class="docTableCell" valign="top"><P class="docText"><TT>"a[x0-9]b"</TT></P></TD><TD class="docTableCell" valign="top"><P class="docText"><TT>a</TT> followed by either <TT>x</TT> or characters in the range <TT>0</TT>–<TT>9</TT>, followed by <TT>b</TT>; thus, <TT>"axb"</TT> or <TT>"a0b"</TT> or <TT>"a4b"</TT> but not <TT>"ab"</TT> or <TT>"aab"</TT>.</P></TD></TR><TR><TD class="docTableCell" valign="top"><P class="docText"><TT>"s[^xyz]t"</TT></P></TD><TD class="docTableCell" valign="top"><P class="docText"><TT>s</TT> followed by any character that is not <TT>x</TT> or <TT>y</TT> or <TT>z</TT>, followed by <TT>t</TT>; thus, <TT>"sdt"</TT> or <TT>"set"</TT> but not <TT>"sxt"</TT> or <TT>"syt"</TT> or <TT>"szt"</TT>.</P></TD></TR><TR><TD class="docTableCell" valign="top"><P class="docText"><TT>"s[^x0-9]t"</TT></P></TD><TD class="docTableCell" valign="top"><P class="docText"><TT>s</TT> followed by any character that is not <TT>x</TT> or in the range <TT>0</TT>–<TT>9</TT>, followed by <TT>t</TT>; thus, <TT>"slt"</TT> or <TT>"smt"</TT> but not <TT>"sxt"</TT> or <TT>"s0t"</TT> or <TT>"s4t"</TT>.</P></TD></TR><TR><TD class="docTableCell" valign="top"><P class="docText"><TT>"^x"</TT></P></TD><TD class="docTableCell" valign="top"><P class="docText"><TT>x</TT> at the beginning of a string; thus, <TT>"xzy"</TT> or <TT>"xzzy"</TT> but not <TT>"yzy"</TT> or <TT>"yxy"</TT>.</P></TD></TR><TR><TD class="docTableCell" valign="top"><P class="docText"><TT>"x$"</TT></P></TD><TD class="docTableCell" valign="top"><P class="docText"><TT>x</TT> at the end of a string; thus, <TT>"yzx"</TT> or <TT>"yx"</TT> but not <TT>"yxz"</TT> or <TT>"zxy"</TT>.</P></TD></TR></COLGROUP></TABLE></P>
<P class="docText">Now that we've looked at some motivating examples<A NAME="idd1e18853"></A><A NAME="idd1e18858"></A>, <A class="docLink" HREF="#ch08table02">Table 8.2</A> is a summary of the standard regular-expression wildcards. Note: we're not including the glob variant in this table, so a value of "All" implies only all three of the basic, extended/Emacs, and Perl/Python variants.<sup class="docFootnote"><A class="docLink" HREF="#ch08en04">[4]</A></sup></P><blockquote><p class="docFootnote"><sup><A NAME="ch08en04">[4]</A></sup> The POSIX<A NAME="idd1e18873"></A> standard for regular expressions introduces some symbolic ranges like <TT>[[:lower;;]]</TT> and <TT>[[:digit:]]</TT>, and some specific tools have extra wildcards not covered here, but these will suffice to interpret most regexps.</p></blockquote>
<A NAME="ch08table02"></A><P><TABLE CELLSPACING="0" FRAME="below" RULES="groups" CELLPADDING="5" WIDTH="100%"><CAPTION><h5 class="docTableTitle">Table 8.2. Introduction to regular-expression operations.</h5></CAPTION><COLGROUP align="left" span="3"><THEAD><TR><TH class="docTableHeader" valign="top"><P class="docText"><span class="docEmphasis">Wildcard<A NAME="idd1e18905"></A><A NAME="idd1e18910"></A></span></P></TH><TH class="docTableHeader" valign="top"><P class="docText"><span class="docEmphasis">Supported in</span></P></TH><TH class="docTableHeader" valign="top"><P class="docText"><span class="docEmphasis">Matches</span></P></TH></TR></THEAD><TR><TD class="docTableCell" valign="top"><P class="docText"><TT>\</TT></P></TD><TD class="docTableCell" valign="top"><P class="docText">All</P></TD><TD class="docTableCell" valign="top"><P class="docText">Escape next character. Toggles whether following punctuation is treated as a wildcard or not. Following letters or digits are interpreted in various different ways depending on the program.</P></TD></TR><TR><TD class="docTableCell" valign="top"><P class="docText"><TT>.</TT></P></TD><TD class="docTableCell" valign="top"><P class="docText">All</P></TD><TD class="docTableCell" valign="top"><P class="docText">Any character.</P></TD></TR><TR><TD class="docTableCell" valign="top"><P class="docText"><TT>^</TT></P></TD><TD class="docTableCell" valign="top"><P class="docText">All</P></TD><TD class="docTableCell" valign="top"><P class="docText">Beginning of line</P></TD></TR><TR><TD class="docTableCell" valign="top"><P class="docText"><TT>$</TT></P></TD><TD class="docTableCell" valign="top"><P class="docText">All</P></TD><TD class="docTableCell" valign="top"><P class="docText">End of line</P></TD></TR><TR><TD class="docTableCell" valign="top"><P class="docText"><TT>[...]</TT></P></TD><TD class="docTableCell" valign="top"><P class="docText">All</P></TD><TD class="docTableCell" valign="top"><P class="docText">Any of the characters between the brackets</P></TD></TR><TR><TD class="docTableCell" valign="top"><P class="docText"><TT>[^...]</TT></P></TD><TD class="docTableCell" valign="top"><P class="docText">All</P></TD><TD class="docTableCell" valign="top"><P class="docText">Any characters <span class="docEmphasis">except those</span> between the brackets.</P></TD></TR><TR><TD class="docTableCell" valign="top"><P class="docText"><TT>*</TT></P></TD><TD class="docTableCell" valign="top"><P class="docText">All</P></TD><TD class="docTableCell" valign="top"><P class="docText">Accept any number of instances of the previous element.</P></TD></TR><TR><TD class="docTableCell" valign="top"><P class="docText"><TT>?</TT></P></TD><TD class="docTableCell" valign="top"><P class="docText">egrep/Emacs, Perl/Python</P></TD><TD class="docTableCell" valign="top"><P class="docText">Accept zero or one instances of the previous element.</P></TD></TR><TR><TD class="docTableCell" valign="top"><P class="docText"><TT>+</TT></P></TD><TD class="docTableCell" valign="top"><P class="docText">egrep/Emacs, Perl/Python</P></TD><TD class="docTableCell" valign="top"><P class="docText">Accept one or more instances of the previous element.</P></TD></TR><TR><TD class="docTableCell" valign="top"><P class="docText"><TT>{n}</TT></P></TD><TD class="docTableCell" valign="top"><P class="docText">egrep, Perl/Python; as <TT>\{n\}</TT> in Emacs</P></TD><TD class="docTableCell" valign="top"><P class="docText">Accept exactly <TT>n</TT> repetitions of the previous element. Not supported by some older regexp engines.</P></TD></TR><TR><TD class="docTableCell" valign="top"><P class="docText"><TT>{n,}</TT></P></TD><TD class="docTableCell" valign="top"><P class="docText">egrep, Perl/Python; as <TT>\{n,\}</TT> in Emacs</P></TD><TD class="docTableCell" valign="top"><P class="docText">Accept <TT>n</TT> or more repetitions of the previous element. Not supported by some older regexp engines.</P></TD></TR><TR><TD class="docTableCell" valign="top"><P class="docText"><TT>{m,n}</TT></P></TD><TD class="docTableCell" valign="top"><P class="docText">egrep, Perl/Python; as <TT>\{m,n\}</TT> in Emacs</P></TD><TD class="docTableCell" valign="top"><P class="docText">Accept at least <TT>m</TT> and at most <TT>n</TT> repetitions of the previous element. Not supported by some older regexp engines.</P></TD></TR><TR><TD class="docTableCell" valign="top"><P class="docText"><TT>|</TT></P></TD><TD class="docTableCell" valign="top"><P class="docText">egrep, Perl/Python; as <TT>\|</TT> in Emacs</P></TD><TD class="docTableCell" valign="top"><P class="docText">Accept the element to the left or the element to the right. This is usually used with some form of pattern-grouping delimiters.</P></TD></TR><TR><TD class="docTableCell" valign="top"><P class="docText"><TT>(...)</TT></P></TD><TD class="docTableCell" valign="top"><P class="docText">Perl/Python; as <TT>\(...\)</TT> in older versions.</P></TD><TD class="docTableCell" valign="top"><P class="docText">Treat this pattern as a group (in newer regexp engines like Perl and Python's). Older regexp engines such as those in Emacs and grep require <TT>\(...\)</TT>.</P></TD></TR></COLGROUP></TABLE></P>
<P class="docText">Design practice in new languages with regexp support has stabilized on the Perl/Python variant. It is more transparent than the others, notably because backlash before a non-alphanumeric character always means that character as a literal, so there is much less confusion about how to quote elements of regexps.</P>
<P class="docText">Regular expressions are an extreme example of how concise a minilanguage can be. Simple regular expressions express recognition behavior that would otherwise have to be implenented with hundreds of lines of fussy, bug-prone code.</P>

<A NAME="ch08lev2sec3"></A>
<H4 class="docSection2Title">8.2.3 Case Study: <span class="docEmphasis">Glade</span></H4>
<P class="docText"><A NAME="idd1e19207"></A><A NAME="idd1e19210"></A><span class="docEmphasis">Glade</span> is an interface builder for the open-source GTK toolkit library<A NAME="idd1e19218"></A> for X<A NAME="idd1e19222"></A>.<sup class="docFootnote"><A class="docLink" HREF="#ch08en05">[5]</A></sup> <span class="docEmphasis">Glade</span> allows you to develop a GUI interface by interactively picking, placing, and modifying widgets on an interface panel. The GUI editor produces an XML file describing the interface; this, in turn, can be fed to one of several code generators that will actually grind out C<A NAME="idd1e19237"></A>, C++<A NAME="idd1e19243"></A>, Python<A NAME="idd1e19247"></A> or Perl<A NAME="idd1e19251"></A> code for the interface. The generated code then calls functions you write to supply behavior to the interface.</P><blockquote><p class="docFootnote"><sup><A NAME="ch08en05">[5]</A></sup> For non-Unix programmers, an X toolkit is a graphics library that supplies GUI widgets (like labels, buttons, and pull-down menus) to the programs that link to it. Under most other graphical operating systems, the OS supplies one toolkit that everyone uses. Unix and X support multiple toolkits; this is part of the separation of policy from mechanism that we called out as a design goal of X in <A class="docLink" HREF="0131429019_ch01.html#ch01">Chapter 1</A>. GTK and Qt are the two most popular open-source X toolkits.</p></blockquote>
<P class="docText"><span class="docEmphasis">Glade</span>'s XML format for describing GUIs is a good example of a simple domain-specific minilanguage. See <A class="docLink" HREF="#ch08ex01">Example 8.1</A> for a "Hello, world!" GUI in Glade format.</P>

<H5 class="docExampleTitle"><A NAME="ch08ex01"></A>Example 8.1 Glade "Hello, World".</H5>

<PRE>
&lt;?xml version="1.0"?&gt;
&lt;GTK-Interface&gt;

&lt;widget&gt;
  &lt;class&gt;GtkWindow&lt;/class&gt;
  &lt;name&gt;HelloWindow&lt;/name&gt;
  &lt;border_width&gt;5&lt;/border_width&gt;
  &lt;Signal&gt;
    &lt;name&gt;destroy&lt;/name&gt;
    &lt;handler&gt;gtk_main_quit&lt;/handler&gt;
  &lt;/Signal&gt;
  &lt;title&gt;Hello&lt;/title&gt;
  &lt;type&gt;GTK_WINDOW_TOPLEVEL&lt;/type&gt;
  &lt;position&gt;GTK_WIN_POS_NONE&lt;/position&gt;
  &lt;allow_shrink&gt;True&lt;/allow_shrink&gt;
  &lt;allow_grow&gt;True&lt;/allow_grow&gt;
  &lt;auto_shrink&gt;False&lt;/auto_shrink&gt;

  &lt;widget&gt;
    &lt;class&gt;GtkButton&lt;/class&gt;
    &lt;name&gt;Hello World&lt;/name&gt;
    &lt;can_focus&gt;True&lt;/can_focus&gt;
    &lt;Signal&gt;
      &lt;name&gt;clicked&lt;/name&gt;
      &lt;handler&gt;gtk_widget_destroy&lt;/handler&gt;
      &lt;object&gt;HelloWindow&lt;/object&gt;
    &lt;/Signal&gt;
    &lt;label&gt;Hello World&lt;/label&gt;
  &lt;/widget&gt;
&lt;/widget&gt;

&lt;/GTK-Interface&gt;
</PRE>

<P class="docText">A valid specification in <span class="docEmphasis">Glade</span> format implies a repertoire of actions by the GUI in response to user behavior. The <span class="docEmphasis">Glade</span> GUI treats these specifications as structured data files; <span class="docEmphasis">Glade</span> code generators, on the other hand, use them to write programs implementing a GUI. For some languages (including Python<A NAME="idd1e19285"></A>), there are runtime libraries that allow you to skip the code-generation step and simply instantiate the GUI directly at runtime from the XML specification (interpreting Glade markup, rather than compiling it to the host language). Thus, you get the choice of trading space efficiency for startup speed or vice versa.</P>
<P class="docText">Once you get past the verbosity of XML, <span class="docEmphasis">Glade</span> markup is a fairly simple language. It does just two things: declare GUI-widget hierarchies and associate properties with widgets. You don't actually have to know a lot about how <span class="docEmphasis">glade</span> works to read the specification above. In fact, if you have any experience programming in GUI toolkits, reading it will immediately give you a fairly good visualization of what <span class="docEmphasis">glade</span> does with the specification. (Hands up everyone who predicted that this particular specification will give you a single button widget in a window frame.)</P>
<P class="docText">This kind of transparency and simplicity is the mark of a good minilanguage design<A NAME="idd1e19304"></A>. The mapping between the notation and domain objects is very clear. The relationships between objects are expressed directly, rather than through name references or some other sort of indirection that you have to think to follow.</P>
<P class="docText">The ultimate functional test of a minilanguage like this one is simple: can I hack it without reading the manual? For a significant range of cases, the <span class="docEmphasis">Glade</span> answer is yes. For example, if you know the C-level constants that GTK uses to describe window-positioning hints, you'll recognize <span class="docEmphStrong"><TT>GTK_WIN_POS_NONE</TT></span> as one and instantly be able to change the positioning hint associated with this GUI.</P>
<P class="docText">The advantage of using <span class="docEmphasis">Glade</span> should be clear. It specializes in code generation so you don't have to. That's one less routine task you have to hand-code, and one fewer source of hand-coded bugs.</P>
<P class="docText">More information, including source code and documentation and links to sample applications, is available at the Glade project page &lt;<A class="docLink" target="_blank" HREF="http://www.glade.gnome.org/default.htm">http://glade.gnome.org/</A>&gt;. <span class="docEmphasis">Glade</span> has been ported to Windows<A NAME="idd1e19335"></A>.</P>

<A NAME="ch08lev2sec4"></A>
<H4 class="docSection2Title">8.2.4 Case Study: <span class="docEmphasis">m4</span></H4>
<P class="docText"><A NAME="idd1e19349"></A><A NAME="idd1e19352"></A>The <span class="docEmphasis">m4</span>(1) macro processor interprets a declarative minilanguage for describing transformations of text. An <span class="docEmphasis">m4</span> program is a set of macros that specifies ways to expand text strings into other strings. Applying those declarations to an input text with <span class="docEmphasis">m4</span> performs macro expansion and yields an output text. (The C<A NAME="idd1e19367"></A> preprocessor performs similar services for C compilers, though in a rather different style.)</P>
<P class="docText"><A class="docLink" HREF="#ch08ex02">Example 8.2</A> shows an <span class="docEmphasis">m4</span> macro that directs <span class="docEmphasis">m4</span> to expand each occurrence of the string "OS" in its input into the string "operating system" on output. This is a trivial example; <span class="docEmphasis">m4</span> supports macros with arguments that can be used to do more than transform one fixed string into another. Typing <span class="docEmphStrong"><TT>info m4</TT></span> at your shell prompt will probably display on-line documentation for this language.</P>

<H5 class="docExampleTitle"><A NAME="ch08ex02"></A>Example 8.2 A sample <span class="docEmphasis">m4</span> macro.</H5>

<PRE>
define('OS', 'operating system')
</PRE>

<P class="docText">The <span class="docEmphasis">m4</span> macro language supports conditionals and recursion. The combination can be used to implement loops, and this was intended; <span class="docEmphasis">m4</span> is deliberately Turing-complete. But actually trying to use <span class="docEmphasis">m4</span> as a general-purpose language would be deeply perverse.</P>
<P class="docText">The <span class="docEmphasis">m4</span> macro processor is usually employed as a preprocessor for minilanguages that lack a built-in notion of named procedures or a built-in file-inclusion feature. It's an easy way to extend the syntax of the base language so the combination with <span class="docEmphasis">m4</span> supports both these features.</P>
<P class="docText">One well-known use of <span class="docEmphasis">m4</span> has been to clean up (or at least effectively hide) another minilanguage design that was called out as a bad example earlier in this chapter. Most system administrators now generate their <TT>sendmail.cf</TT><A NAME="idd1e19433"></A> configuration files using an <span class="docEmphasis">m4</span> macro package supplied with the <span class="docEmphasis">sendmail</span> distribution. The macros start from feature names (or name/value pairs) and generate the corresponding (much uglier) strings in the <span class="docEmphasis">sendmail</span> configuration language.</P>
<P class="docText">Use <span class="docEmphasis">m4</span> with caution, however. Unix experience has taught minilanguage designers to be wary of macro expansion<A NAME="idd1e19452"></A>,<sup class="docFootnote"><A class="docLink" HREF="#ch08en06">[6]</A></sup> for reasons we'll discuss later in the chapter.</P><blockquote><p class="docFootnote"><sup><A NAME="ch08en06">[6]</A></sup> Whether or not "macro expansion" should be spelled "macroexpansion" is a matter for some dispute. The latter is found mainly among Lisp programmers.<A NAME="idd1e19459"></A></p></blockquote>

<A NAME="ch08lev2sec5"></A>
<H4 class="docSection2Title">8.2.5 Case Study: XSLT</H4>
<P class="docText"><A NAME="idd1e19471"></A><A NAME="idd1e19476"></A>XSLT, like <span class="docEmphasis">m4</span> macros, is a language for describing transformations of a text stream. But it does much more than simple macro substitution; it describes transformations of XML data, including query and report generation. It is the language used to write XML stylesheets. For practical applications, see the description of XML document processing in <A class="docLink" HREF="0131429019_ch18.html#ch18">Chapter 18</A>. XSLT is described by a World Wide Web Consortium standard and has several open-source implementations.<A NAME="idd1e19487"></A></P>
<P class="docText">XSLT and <span class="docEmphasis">m4</span> macros are both purely declarative and Turing-complete, but XSLT supports only recursions and not loops. It is quite complex, certainly the most difficult language to master of any in this chapter's case studies—and probably the most difficult of any language mentioned in this book.<sup class="docFootnote"><A class="docLink" HREF="#ch08en07">[7]</A></sup></P><blockquote><p class="docFootnote"><sup><A NAME="ch08en07">[7]</A></sup> It is not clear that XSLT could be any simpler and still do its job, however, so we cannot characterize it as a bad design.</p></blockquote>
<P class="docText">Despite its complexity, XSLT really is a minilanguage. It shares important (though not universal) characteristics of the breed:</P>
<UL><LI><P class="docList">A restricted ontology of types, with (in particular) no analog of record structures or arrays.</P></LI><LI><P class="docList">Restricted interface to the rest of the world. XSLT processors are designed to filter standard input to standard output, with a limited ability to read and write files. They can't open sockets or run subcommands.</P></LI></UL>

<H5 class="docExampleTitle"><A NAME="ch08ex03"></A>Example 8.3 A sample XSLT program.</H5>

<PRE>
&lt;?xml version="1.0"?&gt;
&lt;xsl:stylesheet xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
                version="1.0"&gt;
  &lt;xsl:output method="xml"/&gt;
  &lt;xsl:template match="*"&gt;
    &lt;xsl:element name="{name()}"&gt;
      &lt;xsl:for-each select="@*"&gt;
        &lt;xsl:element name="{name()}"&gt;
          &lt;xsl:value-of select="."/&gt;
        &lt;/xsl:element&gt;
      &lt;/xsl:for-each&gt;
      &lt;xsl:apply-templates select="*|text()"/&gt;
    &lt;/xsl:element&gt;
  &lt;/xsl:template&gt;
&lt;/xsl:stylesheet&gt;
</PRE>

<P class="docText">The program in <A class="docLink" HREF="#ch08ex03">Example 8.3</A> transforms an XML document so that each attribute of every element is transformed into a new tag pair directly enclosed by that element, with the attribute value as the tag pair's content.</P>
<P class="docText">We've included a glance at XSLT here partly to illustrate the point that 'declarative' does not imply either 'simple' or 'weak', and mostly because if you have to work with XML documents, you will someday have to face the challenge that is XSLT.</P>
<P class="docText"><span class="docEmphasis">XSLT: Mastering XML Transformations</span> <A class="docLink" HREF="0131429019_app02.html#biblio84">[Tidwell]</A> is a good introduction to the language. A brief tutorial with examples is available on the Web.<sup class="docFootnote"><A class="docLink" HREF="#ch08en08">[8]</A></sup></P><blockquote><p class="docFootnote"><sup><A NAME="ch08en08">[8]</A></sup> XSL Concepts and Practical Use &lt;<A class="docLink" target="_blank" HREF="http://www.nwalsh.com/docs/tutorials/xsl/xsl/slides.html">http://nwalsh.com/docs/tutorials/xsl/xsl/slides.html</A>&gt;.</p></blockquote>

<A NAME="ch08lev2sec6"></A>
<H4 class="docSection2Title">8.2.6 Case Study: The Documenter's Workbench Tools</H4>
<P class="docText"><A NAME="idd1e19554"></A><A NAME="idd1e19557"></A>The <span class="docEmphasis">troff</span>(1)<A NAME="idd1e19566"></A> typesetting formatter was, as we noted in <A class="docLink" HREF="0131429019_ch02.html#ch02">Chapter 2</A>, Unix's original killer application. <span class="docEmphasis">troff</span> is the center of a suite of formatting tools (collectively called Documenter's Workbench or DWB), all of which are domain-specific minilanguages of various kinds. Most are either preprocessors or postprocessors for troff markup. Open-source Unixes<A NAME="idd1e19580"></A> host an enhanced implementation of Documenter's Workbench called <span class="docEmphasis">groff</span>(1)<A NAME="idd1e19587"></A>, from the Free Software Foundation<A NAME="idd1e19591"></A>.</P>
<P class="docText">We'll examine <span class="docEmphasis">troff</span> in more detail in <A class="docLink" HREF="0131429019_ch18.html#ch18">Chapter 18</A>; for now, it's sufficient to note that it is a good example of an imperative minilanguage that borders on being a full-fledged interpreter (it has conditionals and recursion but not loops; it is accidentally Turing-complete).</P>
<P class="docText">The postprocessors ('drivers' in DWB terminology) are normally not visible to <span class="docEmphasis">troff</span> users. The original troff emitted codes for the particular typesetter the Unix development group had available in 1970; later in the 1970s these were cleaned up into a device-independent minilanguage for placing text and simple graphics on a page. The postprocessors translate this language (called "ditroff" for "device-independent troff") into something modern imaging printers can actually accept—the most important of these (and the modern default) is PostScript.</P>
<P class="docText">The preprocessors are more interesting, because they actually add capabilities to the troff language. There are three common ones: <span class="docEmphasis">tbl</span>(1)<A NAME="idd1e19620"></A> for making tables, <span class="docEmphasis">eqn</span>(1)<A NAME="idd1e19627"></A> for typesetting mathematical equations, and <span class="docEmphasis">pic</span>(1)<A NAME="idd1e19634"></A> for drawing diagrams. Less used, but still live, are <span class="docEmphasis">grn</span>(1)<A NAME="idd1e19641"></A> for graphics, and <span class="docEmphasis">refer</span>(1)<A NAME="idd1e19648"></A> and <span class="docEmphasis">bib</span>(1)<A NAME="idd1e19655"></A> for formatting bibliographies. Open-source equivalents of all of these ship with <span class="docEmphasis">groff</span><A NAME="idd1e19661"></A>. The <span class="docEmphasis">grap</span>(1)<A NAME="idd1e19668"></A> preprocessor provided a rather versatile plotting facility; there is an open-source implementation separate from <span class="docEmphasis">groff</span>.</P>
<P class="docText">Some other preprocessors have no open-source implementation<A NAME="idd1e19678"></A> and are no longer in common use. Best known of these was <span class="docEmphasis">ideal</span>(1)<A NAME="idd1e19685"></A>, for graphics. A younger sibling of the family, <span class="docEmphasis">chem</span>(1)<A NAME="idd1e19692"></A>, draws chemical structural formulas; it is available as part of Bell Labs's<A NAME="idd1e19696"></A> netlib code.<sup class="docFootnote"><A class="docLink" HREF="#ch08en09">[9]</A></sup></P><blockquote><p class="docFootnote"><sup><A NAME="ch08en09">[9]</A></sup> <A class="docLink" target="_blank" HREF="http://www.netlib.org/default.htm">http://www.netlib.org/</A></p></blockquote>
<P class="docText">Each of these preprocessors is a little program that accepts a minilanguage and compiles it into troff requests. Each one recognizes the markup it is supposed to interpret by looking for a unique start and end request, and passes through unaltered any markup outside those (<span class="docEmphasis">tbl</span><A NAME="idd1e19711"></A> looks for <TT>.TS</TT>/<TT>.TE</TT>, <span class="docEmphasis">pic</span><A NAME="idd1e19723"></A> looks for <TT>.PS</TT>/<TT>.PE</TT>, etc.). Thus, most of the preprocessors can normally be run in any order without stepping on each other. There are some exceptions: in particular, <span class="docEmphasis">chem</span> and <span class="docEmphasis">grap</span> both issue <span class="docEmphasis">pic</span> commands, and so must come before it in the pipeline.</P>
<pre>

</pre><pre>
cat thesis.ms | chem | tbl | refer | grap | pic | eqn \
                                             | groff -Tps &gt;thesis.ps
</pre><pre>
</pre>
<P class="docText">The preceding is a full-Monty example of a Documenter's Workbench processing pipeline<A NAME="idd1e19751"></A>, for a hypothetical thesis incorporating chemical formulas, mathematical equations, tables, bibliographies, plots, and diagrams. (The <span class="docEmphasis">cat</span>(1)<A NAME="idd1e19758"></A> command simply copies its input or a file argument to its output; we use it here to emphasize the order of operations.) In practice modern troff implementations tend to support command-line options that can invoke at least <span class="docEmphasis">tbl</span>(1)<A NAME="idd1e19765"></A>, <span class="docEmphasis">eqn</span>(1)<A NAME="idd1e19772"></A> and <span class="docEmphasis">pic</span>(1)<A NAME="idd1e19779"></A>, so it isn't necessary to write such an elaborate pipeline. Even if it were, these sorts of build recipes are normally composed just once and stashed away in a makefile or shellscript wrapper for repeated use.</P>
<P class="docText">The document markup of Documenter's Workbench is in some ways obsolete, but the range of problems these preprocessors address gives some indication of the power of the minilanguage model—it would be extremely difficult to embed equivalent knowledge into a WYSIWYG<A NAME="idd1e19786"></A> word processor. There are some ways in which modern XML-based document<A NAME="idd1e19790"></A> markups and toolchains are still, in 2003, playing catch-up with capabilities that Documenter's Workbench had in 1979. We'll discuss these issues in more detail in <A class="docLink" HREF="0131429019_ch18.html#ch18">Chapter 18</A>.</P>
<P class="docText">The design themes that gave Documenter's Workbench so much power should by now be familiar ones; all the tools share a common text-stream representation of documents, and the formatting system is broken up into independent components that can be debugged and improved separately. The pipeline architecture supports plugging in new, experimental preprocessors and postprocessors without disturbing old ones. It is modular and extensible.</P>
<P class="docText">The architecture of Documenter's Workbench as a whole teaches us some things about how to fit multiple specialist minilanguages into a cooperating system. One preprocessor can build on another. Indeed, the Documenter's Workbench tools were an early exemplar of the power of pipes<A NAME="idd1e19804"></A>, filtering, and minilanguages that influenced a lot of later Unix design by example. The design of the individual preprocessors has more lessons to teach about what effective minilanguage designs look like.</P>
<P class="docText">One of these lessons is negative. Sometimes users writing descriptions in the minilanguages do unclean things with low-level troff markup inserted by hand. This can produce interactions and bugs that are hard to diagnose, because the generated troff coming out of the pipeline is not visible—and would not be readable if it were. This is analogous to the sorts of bugs that happen in code that mixes C with snippets of in-line assembler. It might have been better to separate the language layers more completely, if that were possible. Minilanguage designers should take note of this.</P>
<P class="docText">All the preprocessor languages (though not troff markup itself) have relatively clean, shell-like syntaxes that follow many of the conventions we described in <A class="docLink" HREF="0131429019_ch05.html#ch05">Chapter 5</A> for the design of data-file formats. There are a few embarrassing exceptions; notably, <span class="docEmphasis">tbl</span>(1)<A NAME="idd1e19821"></A> defaults to using a tab as a field separator between table columns, replicating an infamous botch in the design of <span class="docEmphasis">make</span>(1)<A NAME="idd1e19828"></A> and causing annoying bugs when editors or other tools invisibly change the composition of whitespace.</P>
<P class="docText">While troff itself is a specialized imperative language, one theme that runs through at least three of the Documenter's Workbench minilanguages is declarative semantics: doing layout from constraints. This is an idea that shows up in modern GUI toolkits<A NAME="idd1e19835"></A> as well—that, instead of giving pixel coordinates for graphical objects, what you really want to do is declare spatial relationships among them ("widget A is above widget B, which is to the left of widget C") and have your software compute a best-fit layout for A, B, and C according to those constraints.</P>
<P class="docText">The <span class="docEmphasis">pic</span>(1)<A NAME="idd1e19845"></A> program uses this approach to lay out elements for diagrams. The language taxonomy diagram at <A class="docLink" HREF="0131429019_ch08lev1sec1.html#ch08fig01">Figure 8.1</A> was produced with the <span class="docEmphasis">pic</span> source code in <A class="docLink" HREF="#ch08ex04">Example 8.4</A><sup class="docFootnote"><A class="docLink" HREF="#ch08en10">[10]</A></sup> run through <TT>pic2graph</TT>, one of our case studies in <A class="docLink" HREF="0131429019_ch07.html#ch07">Chapter 7</A>.</P><blockquote><p class="docFootnote"><sup><A NAME="ch08en10">[10]</A></sup> It is also quite traditional for Unix books that describe <span class="docEmphasis">pic</span>(1) to include their own illustrations as coding examples.</p></blockquote>

<H5 class="docExampleTitle"><A NAME="ch08ex04"></A>Example 8.4 Taxonomy of languages—the <span class="docEmphasis">pic</span> source.</H5>

<PRE>
# Minilanguage taxonomy
#
# Base ellipses
define smallellipse {ellipse width 3.0 height 1.5}
M: ellipse width 3.0 height 1.8 fill 0.2
line from M.n to M.s dashed
D: smallellipse() with .e at M.w + (0.8, 0)
line from D.n to D.s dashed
I: smallellipse() with .w at M.e - (0.8, 0)
#
# Captions
"" "Data formats" at D.s
"" "Minilanguages" at M.s
"" "Interpreters" at I.s
#
# Heads
arrow from D.w + (0.4, 0.8) to D.e + (-0.4, 0.8)
"flat to structured" "" at last arrow.c
arrow from M.w + (0.4, 1.0) to M.e + (-0.4, 1.0)
"declarative to imperative" "" at last arrow.c
arrow from I.w + (0.4, 0.8) to I.e + (-0.4, 0.8)
"less to more general" "" at last arrow.c
#
# The arrow of loopiness
arrow from D.w + (0, 1.2) to I.e + (0, 1.2)
"increasing loopiness" "" at last arrow.c
#
# Flat data files
"/etc/passwd" ".newsrc" at 0.5 between D.c and D.w
# Structured data files
"SNG" at 0.5 between D.c and M.w
# Datafile/minilanguage borderline cases
"regexps" "Glade" at 0.5 between M.w and D.e
# Declarative minilanguages
"m4" "Yacc" "Lex" "make" "XSLT" "pic" "tbl" "eqn" \
   at 0.5 between M.c and D.e
# Imperative minilanguages
"fetchmail" "awk" "troff" "Postscript" at 0.5 between M.c and I.w
# Minilanguage/interpreter borderline cases
"dc" "bc" at 0.5 between I.w and M.e
# Interpreters
"Emacs Lisp" "JavaScript" at 0.25 between M.e and I.e
"sh" "tcl" at 0.55 between M.e and I.e
"Perl" "Python" "Java" at 0.8 between M.e and I.e
</PRE>

<P class="docText">This is a very typical Unix minilanguage design, and as such has some points of interest even on the purely syntactic level. Notice how much it looks like a shell program: # leads comments, and the syntax is obviously token-oriented with the simplest possible convention for strings. The designer of <span class="docEmphasis">pic</span>(1)<A NAME="idd1e19891"></A> knew that Unix programmers expect minilanguage syntaxes to look like this unless there is a strong and specific reason they should not. The Rule of Least Surprise<A NAME="idd1e19895"></A><A NAME="idd1e19898"></A> is in full operation here.</P>
<P class="docText">It probably doesn't take a lot of effort to discern that the first line of code is a macro definition; the later references to <TT>smallellipse()</TT> encapsulate a repeated design element of the diagram. Nor will it take much scrutiny to deduce that <TT>box invis</TT> declares a box with invisible borders, actually just a frame for text to be stacked inside. The <TT>arrow</TT> command is equally obvious.</P>
<P class="docText">With these as clues and one eye on the actual diagram, the meaning of the remaining pieces of the syntax (position references like <TT>M.s</TT> and constructions like <TT>last arrow</TT> or <TT>at 0.25 between M.e and I.e</TT> or the addition of vector offsets to a location) should become rapidly apparent. As with Glade markup and <span class="docEmphasis">m4</span>, an example like this one can teach a good bit of the language without any reference to a manual (a compactness property <span class="docEmphasis">troff</span>(1)<A NAME="idd1e19932"></A> markup, unfortunately, does <span class="docEmphasis">not</span> have).</P>
<P class="docText">The example of <span class="docEmphasis">pic</span>(1)<A NAME="idd1e19945"></A> reflects a common design theme in minilanguages, which we also saw reflected in Glade—the use of a minilanguage interpreter to encapsulate some form of constraint-based reasoning and turn it into actions. We could actually choose to view <span class="docEmphasis">pic</span>(1) as an imperative language rather than a declarative one; it has elements of both, and the dispute would quickly grow theological.</P>
<P class="docText">The combination of macros with constraint-based layout gives <span class="docEmphasis">pic</span>(1)<A NAME="idd1e19958"></A> the ability to express the structure of diagrams in a way that more modern vector-based markups like SVG cannot. It is therefore fortunate that one effect of the Documenter's Workbench design is to make it relatively easy to keep <span class="docEmphasis">pic</span>(1) useful outside the DWB context. The <TT>pic2graph</TT> script we used as a case study in <A class="docLink" HREF="0131429019_ch07.html#ch07">Chapter 7</A> was an ad-hoc way to accomplish this, using the retrofitted PostScript capability of <span class="docEmphasis">groff</span>(1)<A NAME="idd1e19978"></A> as a half-way step to a modern bitmap format.</P>
<P class="docText">A cleaner solution is the <span class="docEmphasis">pic2plot</span>(1)<A NAME="idd1e19988"></A> utility distributed with the GNU plotutils package<A NAME="idd1e19992"></A>, which exploited the internal modularity of the GNU <span class="docEmphasis">pic</span>(1)<A NAME="idd1e19999"></A> code. The code was split into a parsing front end and a back end that generated troff markup, the two communicating through a layer of drawing primitives. Because this design obeyed the Rule of Modularity, <span class="docEmphasis">pic2plot</span>(1) implementers were able to split off the GNU <span class="docEmphasis">pic</span> parsing stage and reimplement the drawing primitives using a modern plotting library. Their solution has the disadvantage, however, that text in the output is generated with fonts built into <span class="docEmphasis">pic2plot</span> that won't match those of troff.</P>

<A NAME="ch08lev2sec7"></A>
<H4 class="docSection2Title">8.2.7 Case Study: <span class="docEmphasis">fetchmail</span> Run-Control Syntax</H4>
<P class="docText"><A NAME="idd1e20023"></A><A NAME="idd1e20026"></A><A NAME="idd1e20031"></A> See <A class="docLink" HREF="#ch08ex05">Example 8.5</A> for an example.</P>

<H5 class="docExampleTitle"><A NAME="ch08ex05"></A>Example 8.5 Synthetic example of a <TT>fetchmailrc</TT>.</H5>

<PRE>
# Poll this site first each cycle.
poll pop.provider.net proto pop3
    user "jsmith" with pass "secret1" is "smith" here
    user jones with pass "secret2" is "jjones" here with options keep

# Poll this site second, unless Lord Voldemort zaps us first.
poll billywig.hogwarts.com with proto imap:
    user harry_potter with pass "floo" is harry_potter here

# Poll this site third in the cycle.
# Password will be fetched from ~/.netrc
poll mailhost.net with proto imap:
    user esr is esr here
</PRE>

<P class="docText">This run-control file can be viewed as an imperative minilanguage. There is an implied flow of execution: cycle through the list of poll commands repeatedly (sleeping for a while at the end of each cycle), and for each site entry collect mail for each associated user in sequence. It is far from being general-purpose; all it can do is sequence the program's polling behavior.</P>
<P class="docText">As with <span class="docEmphasis">pic</span>(1), one could choose to view this minilanguage as either declarations or a very weak imperative language, and argue endlessly over the distinction. On the one hand, it has neither conditionals nor recursion nor loops; in fact, it has no explicit control structures at all. On the other hand, it does describe actions rather than just relationships, which distinguishes it from a purely declarative syntax like Glade GUI descriptions.</P>
<P class="docText">Run-control minilanguages for complex programs often straddle this border. We're making a point of this fact because not having explicit control structures in an imperative minilanguage can be a tremendous simplification if the problem domain lets you get away with it.</P>
<P class="docText">One notable feature of <TT>.fetchmailrc</TT> syntax is the use of optional noise keywords that are supported simply in order to make the specifications read a bit more like English. The 'with' keywords and single occurrence of 'options' in the example aren't actually necessary, but they help make the declarations easier to read at a glance.</P>
<P class="docText">The traditional term for this sort of thing is <span class="docEmphasis">syntactic sugar</span><A NAME="idd1e20078"></A>; the maxim that goes with this is a famous quip that "syntactic sugar causes cancer of the semicolon".<sup class="docFootnote"><A class="docLink" HREF="#ch08en11">[11]</A></sup> Indeed, syntactic sugar needs to be used sparingly lest it obscure more than help.</P><blockquote><p class="docFootnote"><sup><A NAME="ch08en11">[11]</A></sup> The line is owed to Alan Perlis<A NAME="idd1e20085"></A>, who did some of the pioneering work in software modularity around 1970. The semicolon in question was the statement separator or terminator in various Algol-descended languages, including Pascal and C.</p></blockquote>
<P class="docText">In <A class="docLink" HREF="0131429019_ch09.html#ch09">Chapter 9</A> we'll see how data-driven programming helps provide an elegant solution to the problem of editing <span class="docEmphasis">fetchmail</span><A NAME="idd1e20099"></A> run-control files through a GUI.</P>

<A NAME="ch08lev2sec8"></A>
<H4 class="docSection2Title">8.2.8 Case Study: <span class="docEmphasis">awk</span></H4>
<P class="docText"><A NAME="idd1e20113"></A><A NAME="idd1e20116"></A>The <span class="docEmphasis">awk</span> minilanguage is an old-school Unix tool, formerly much used in shellscripts. Like <span class="docEmphasis">m4</span>, it's intended for writing small but expressive programs to transform textual input into textual output. Versions ship with all Unixes, several in open source<A NAME="idd1e20128"></A>; the command <span class="docEmphStrong"><TT>info gawk</TT></span> at your Unix shell prompt is quite likely to take you to on-line documentation.</P>
<P class="docText">Programs in <span class="docEmphasis">awk</span> consist of pattern/action pairs. Each pattern is a <span class="docEmphasis">regular expression</span>, a concept we'll describe in detail in <A class="docLink" HREF="0131429019_ch09.html#ch09">Chapter 9</A>. When an <span class="docEmphasis">awk</span> program is run, it steps through each line of the input file. Each line is checked against every pattern/action pair in order. If the pattern matches the line, the associated action is performed.</P>
<P class="docText">Each action is coded in a language resembling a subset of C, with variables and conditionals and loops and an ontology of types including integers, strings, and (unlike C) dictionaries.<sup class="docFootnote"><A class="docLink" HREF="#ch08en12">[12]</A></sup></P><blockquote><p class="docFootnote"><sup><A NAME="ch08en12">[12]</A></sup> For those who have never programmed in a modern scripting language<A NAME="idd1e20158"></A>, a dictionary is a lookup table of key-to-value associations, often implemented through a hash table. C<A NAME="idd1e20162"></A> programmers spend a lot of their coding time implementing dictionaries in various elaborate ways.</p></blockquote>
<P class="docText">The <span class="docEmphasis">awk</span> action language is Turing-complete<A NAME="idd1e20172"></A>, and can read and write files. In some versions it can open and use network sockets. But <span class="docEmphasis">awk</span> has primarily seen use as a report generator, especially for interpreting and reducing tabular data. It is seldom used standalone, but rather embedded in scripts. There is an example <span class="docEmphasis">awk</span> program in the case study on HTML generation included in <A class="docLink" HREF="0131429019_ch09.html#ch09">Chapter 9</A>.</P>
<P class="docText">A case study of <span class="docEmphasis">awk</span> is included to point out that it is <span class="docEmphasis">not</span> a model for emulation; in fact, since 1990 it has largely fallen out of use. It has been superseded by new-school scripting languages<A NAME="idd1e20195"></A>—notably Perl<A NAME="idd1e20199"></A>, which was explicitly designed to be an <span class="docEmphasis">awk</span> killer. The reasons are worthy of examination, because they constitute a bit of a cautionary tale for minilanguage designers.</P>
<P class="docText">The <span class="docEmphasis">awk</span> language was originally designed to be a small, expressive special-purpose language for report generation. Unfortunately, it turns out to have been designed at a bad spot on the complexity-vs.-power curve. The action language is noncompact<A NAME="idd1e20212"></A>, but the pattern-driven framework it sits inside keeps it from being generally applicable—that's the worst of both worlds. And the new-school scripting languages can do anything <span class="docEmphasis">awk</span> can; their equivalent programs are usually just as readable, if not more so.</P>
<blockquote>

<p class="docText"><A NAME="idd1e20226"></A>Awk has also fallen out of use because more modern shells have floating point arithmetic, associative arrays, RE pattern matching, and substring capabilities, so that equivalents of small awk scripts can be done without the overhead of process creation.</p>
<p class="docText">—David Korn</p></blockquote>
<P class="docText">For a few years after the release of Perl in 1987, <span class="docEmphasis">awk</span> remained competitive simply because it had a smaller, faster implementation. But as the cost of compute cycles and memory dropped, the economic reasons for favoring a special-purpose language that was relatively thrifty with both lost their force. Programmers increasingly chose to do awklike things with Perl<A NAME="idd1e20237"></A> or (later) Python, rather than keep two different scripting languages<A NAME="idd1e20241"></A><A NAME="idd1e20244"></A> in their heads.<sup class="docFootnote"><A class="docLink" HREF="#ch08en13">[13]</A></sup> By the year 2000 <span class="docEmphasis">awk</span> had become little more than a memory for most old-school Unix hackers<A NAME="idd1e20261"></A><A NAME="idd1e20264"></A>, and not a particularly nostalgic one.</P><blockquote><p class="docFootnote"><sup><A NAME="ch08en13">[13]</A></sup> I was at one time an <span class="docEmphasis">awk</span> wizard, but I had to be reminded by someone else that the language was applicable to the HTML-generation problem where this book's only <span class="docEmphasis">awk</span> example occurs.</p></blockquote>
<P class="docText">Falling costs have changed the tradeoffs in minilanguage design. Restricting your design's capabilities to buy compactness<A NAME="idd1e20271"></A><A NAME="idd1e20274"></A> may still be a good idea, but doing so to economize on machine resources is a bad one. Machine resources get cheaper over time, but space in programmers' heads only gets more expensive. Modern minilanguages can either be general but noncompact, or specialized but very compact<A NAME="idd1e20278"></A>; specialized but noncompact simply won't compete.</P>

<A NAME="ch08lev2sec9"></A>
<H4 class="docSection2Title">8.2.9 Case Study: PostScript</H4>
<P class="docText"><A NAME="idd1e20290"></A><A NAME="idd1e20293"></A>PostScript is a minilanguage specialized for describing typeset text and graphics to imaging devices. It is an import into Unix, based on design work done at the legendary Xerox Palo Alto Research Center<A NAME="idd1e20299"></A> along with the earliest laser printers. For years after its first commercial release in 1984, it was available only as a proprietary product from Adobe, Inc., and was primarily associated with Apple computers. It was cloned under license terms very close to open-source<A NAME="idd1e20303"></A> in 1988, and has since become the de-facto standard for printer control under Unix. A fully open-source version is shipped with most most modern Unixes.<sup class="docFootnote"><A class="docLink" HREF="#ch08en14">[14]</A></sup> A good technical introduction to PostScript is also available.<sup class="docFootnote"><A class="docLink" HREF="#ch08en15">[15]</A></sup></P><blockquote><p class="docFootnote"><sup><A NAME="ch08en14">[14]</A></sup> There is a GhostScript Project<A NAME="idd1e20310"></A> site &lt;<A class="docLink" target="_blank" HREF="http://www.cs.wisc.edu/~ghost/default.htm">http://www.cs.wisc.edu/~ghost/</A>&gt;.</p></blockquote><blockquote><p class="docFootnote"><sup><A NAME="ch08en15">[15]</A></sup> A First Guide To PostScript &lt;<A class="docLink" target="_blank" HREF="http://www.cs.indiana.edu/docproject/programming/postscript/postscript.html">http://www.cs.indiana.edu/docproject/programming/postscript/postscript.html</A>&gt;<A NAME="idd1e20324"></A>.</p></blockquote>
<P class="docText">PostScript bears some functional resemblance to troff markup; both are intended to control printers and other imaging devices, and both are normally generated by programs or macro packages rather than being hand-written by humans. But where troff requests are a jumped-up set of format-control codes with some language features tacked on as an afterthought, PostScript was designed from the ground up as a language and is far more expressive and powerful. The main thing that makes Postscript useful is that algorithmic descriptions of images written in it are far smaller than the bitmaps they render to, and so take up less storage and communication bandwidth.</P>
<P class="docText">PostScript is explicitly Turing-complete, supporting conditionals and loops and recursion and named procedures. The ontology of types includes integers, reals, strings, and arrays (each element of an array may be of any type) but no equivalent of structures. Technically, PostScript is a stack-based language; arguments of PostScript's primitive procedures (operators) are normally popped off a push-down stack of arguments, and the result(s) are pushed back onto it.</P>
<P class="docText">There are about 40 basic operators out of a total of around 400. The one that does most of the work is <span class="docEmphStrong"><TT>show</TT></span>, which draws a string onto the page. Others set the current font, change the gray level or color, draw lines or arcs or Bezier curves, fill closed regions, set clipping regions, etc. A PostScript interpreter is supposed to be able to interpret these commands into bitmaps to be thrown on a display or print medium.</P>
<P class="docText">Other PostScript operators implement arithmetic, control structures, and procedures. These allow repetitive or stereotyped images (such as text, which is composed of repeated letterforms) to be expressed as programs that combine images. Part of the utility of PostScript comes from the fact that PostScript programs to print text or simple vector graphics are much less bulky than the bitmaps the text or vectors render to, are device-resolution independent, and travel more quickly over a network cable or serial line.</P>
<P class="docText">Historically, PostScript's stack-based interpretation resembles a language called FORTH<A NAME="idd1e20347"></A>, originally designed to control telescope motors in real time, which was briefly popular in the 1980s. Stack-based languages are famous for supporting extremely tight, economical coding and infamous for being difficult to read. PostScript shares both traits.</P>
<P class="docText">PostScript is often implemented as firmware built into a printer. The open-source implementation Ghostscript<A NAME="idd1e20354"></A> can translate PostScript to various graphics formats and (weaker) printer-control languages. Most other software treats PostScript as a final output format, meant to be handed to a PostScript-capable imaging device but not edited or eyeballed.</P>
<P class="docText">PostScript (either in the original or the trivial variant EPSF<A NAME="idd1e20361"></A>, with a bounding box declared around it so it can be embedded in other graphics) is a very well designed example of a special-purpose control language and deserves careful study as a model. It is a component of other standards such as PDF, the Portable Document Format.</P>

<A NAME="ch08lev2sec10"></A>
<H4 class="docSection2Title">8.2.10 Case Study: <span class="docEmphasis">bc</span> and <span class="docEmphasis">dc</span></H4>
<P class="docText"><A NAME="idd1e20381"></A><A NAME="idd1e20384"></A><A NAME="idd1e20387"></A>We first examined <span class="docEmphasis">bc</span>(1) and <span class="docEmphasis">dc</span>(1) in <A class="docLink" HREF="0131429019_ch07.html#ch07">Chapter 7</A> as a case study in shellouts. They are examples of domain-specific minilanguages of the imperative type.</P>
<blockquote>

<p class="docText"><A NAME="idd1e20414"></A><span class="docEmphasis">dc</span> is the oldest language on Unix; it was written on the PDP-7 and ported to the PDP-11 before Unix [itself] was ported.</p>
<p class="docText">—Ken Thompson</p></blockquote>
<P class="docText">The domain of these two languages is unlimited-precision arithmetic. Other programs can use them to do such calculations without having to worry about the special techniques needed to do those calculations.</P>
<blockquote>

<p class="docText"><A NAME="idd1e20431"></A>In fact, the original motivation for dc had nothing to do with providing a general-purpose interactive calculator, which could have been done with a simple floating-point program. The motivation was Bell Labs' long interest in numerical analysis: calculating constants for numerical algorithms, <span class="docEmphasis">accurately</span> is greatly aided by being able to work to much higher precision than the algorithm itself will use. Hence dc's arbitrary-precision arithmetic.</p>
<p class="docText">—Henry Spencer</p></blockquote>
<P class="docText">Like SNG and <span class="docEmphasis">Glade</span> markup, one of the strengths of both of these languages is their simplicity. Once you know that <span class="docEmphasis">dc</span>(1) is a reverse-Polish-notation calculator and <span class="docEmphasis">bc</span>(1) an algebraic-notation calculator, very little about interactive use of either of these languages is going to be novel. We'll return to the importance of the Rule of Least Surprise in interfaces in <A class="docLink" HREF="0131429019_ch11.html#ch11">Chapter 11</A>.</P>
<P class="docText">These minilanguages have both conditionals and loops; they are Turing-complete, but have a very restricted ontology of types including only unlimited-precision integers and strings. This puts them in the borderland between interpreted minilanguages and full scripting languages<A NAME="idd1e20461"></A><A NAME="idd1e20464"></A>. The programming features have been designed not to intrude on the common use as a calculator; indeed, most <span class="docEmphasis">dc</span>/<span class="docEmphasis">bc</span> users are probably unaware of them.</P>
<P class="docText">Normally, <span class="docEmphasis">dc</span>/<span class="docEmphasis">bc</span> are used conversationally, but their capacity to support libraries of user-defined procedures gives them an additional kind of utility—programmability. This is actually the most important advantage of imperative minilanguages, one that we observed in the case study of the Documenter's Workbench tools<A NAME="idd1e20483"></A> to be very powerful whether or not a program's normal mode is conversational; you can use them to write high-level programs that embody task-specific intelligence.</P>
<P class="docText">Because the interface of <span class="docEmphasis">dc</span>/<span class="docEmphasis">bc</span> is so simple (send a line containing an expression, get back a line containing a value) other programs and scripts can easily get access to all these capabilities by calling these programs as slave processes. <A class="docLink" HREF="#ch08ex06">Example 8.6</A> is one famous example, an implementation of the Rivest-Shamir-Adelman public-key cipher in Perl<A NAME="idd1e20500"></A> that was widely published in signature blocks and on T-shirts as a protest against U.S. export retrictions on cryptography, c. 1995; it shells out to <span class="docEmphasis">dc</span> to do the unlimited-precision arithmetic required.</P>

<H5 class="docExampleTitle"><A NAME="ch08ex06"></A>Example 8.6 RSA implementation using <span class="docEmphasis">dc</span>.</H5>

<PRE>
print pack"C*",split/\D+/,`echo "16iII*o\U@{$/=$z;[(pop,pop,unpack
"H*",&lt;&gt;)]}\EsMsKsN0[lN*1lK[d2%Sa2/d0&lt;X+d*lMLa^*lN%0]dsXx++\
lMlN/dsM0&lt;J]dsJxp"|dc`
</PRE>


<A NAME="ch08lev2sec11"></A>
<H4 class="docSection2Title">8.2.11 Case Study: Emacs Lisp</H4>
<P class="docText"><A NAME="idd1e20527"></A><A NAME="idd1e20530"></A>Rather than merely being run as a slave process to accomplish specific tasks, a special-purpose interpreted language can become the core of an entire architecture; we'll consider the advantages and disadvantages of this approach in <A class="docLink" HREF="0131429019_ch13.html#ch13">Chapter 13</A>. troff requests were an early example; today, the <span class="docEmphasis">Emacs</span><A NAME="idd1e20542"></A> editor is one of the best-known and most powerful modern ones. It's built around a dialect of Lisp<A NAME="idd1e20546"></A> with primitives for both describing actions on editing buffers and controlling slave processes.</P>
<P class="docText">The fact that Emacs is built around a powerful language for describing editing actions or front ends for other programs means that it can be used for many other things besides ordinary editing. We'll examine the applications of Emacs's task-specific intelligence for day-to-day program development (compilation, debugging, version control) in <A class="docLink" HREF="0131429019_ch15.html#ch15">Chapter 15</A>. Emacs 'modes' are user-defined libraries—programs written in Emacs Lisp that specialize the editor for a particular job—usually, but not necessarily, one related to editing.</P>
<P class="docText">Thus there are specialized modes that know the syntax of a large number of programming languages, and of markup languages like SGML<A NAME="idd1e20560"></A>, XML<A NAME="idd1e20564"></A>, and HTML<A NAME="idd1e20568"></A>. But many people also use Emacs modes to send and receive email (these use Unix system mail utilities as slaves) or Usenet news<A NAME="idd1e20572"></A>. Emacs can browse the web, or act as a front-end for various chat programs. There is also a calendaring package, Emacs's own calculator program, and even a fairly wide selection of games written as Emacs Lisp modes (including a descendant of the famous ELIZA program<A NAME="idd1e20576"></A> that simulates a Rogersian psychiatrist).<sup class="docFootnote"><A class="docLink" HREF="#ch08en16">[16]</A></sup></P><blockquote><p class="docFootnote"><sup><A NAME="ch08en16">[16]</A></sup> One of the silliest things you can do with a modern Unix machine is run the Eliza mode of Emacs against random quotes from Zippy the Pinhead. <span class="docEmphStrong"><TT>M-x psychoanalyze-pinhead</TT></span>; type control-G when you've had enough.</p></blockquote>

<A NAME="ch08lev2sec12"></A>
<H4 class="docSection2Title">8.2.12 Case Study: JavaScript</H4>
<P class="docText"><A NAME="idd1e20595"></A><A NAME="idd1e20598"></A><A NAME="idd1e20601"></A><A NAME="idd1e20606"></A>JavaScript is an open-source language designed to be embedded in C<A NAME="idd1e20610"></A> programs. Though it is also embedded in web servers, its original and best-known manifestation is client-side JavaScript, which allows you to embed executable code in Web pages to be run by any JavaScript-capable browser. That is the version we will survey here.</P>
<P class="docText">JavaScript is a fully Turing-complete interpreted language<A NAME="idd1e20617"></A> with integers, real numbers, booleans, strings, and lightweight dictionary-based objects resembling those of Python<A NAME="idd1e20621"></A>. Values are typed, but variables can hold any type; conversions between types are automatic in many contexts. Syntactically JavaScript resembles Java<A NAME="idd1e20625"></A> with some influence from Perl<A NAME="idd1e20629"></A>, and features Perl-like regular expressions.</P>
<P class="docText">Despite all these features, client-side JavaScript is not quite a general-purpose language. Its capabilities are severely restricted to prevent attacks on the browser user through Web pages containing JavaScript code. It can accept input from the user and generate or modify Web pages, but it cannot directly alter the contents of disk files and cannot open its own network connections.</P>
<P class="docText">Over time, the JavaScript language has become more general and less bound to its client-side environment. This is something that can be expected to happen to any successful specialized language as its possibilities unfold in the minds of developers and users. Client JavaScript now interacts with its environment by reading and writing values in a single special object called the browser DOM<A NAME="idd1e20639"></A> (Document Object Model). The language still has some legacy APIs to the browser that don't go through the DOM, but these are deprecated, not present in the ECMA-262 standard for JavaScript, and may not be supported in future versions.</P>
<P class="docText">The standard reference for JavaScript is <span class="docEmphasis">JavaScript: The Definitive Guide</span> <A class="docLink" HREF="0131429019_app02.html#biblio20">[FlanaganJavaScript]</A>. Source code is downloadable.<sup class="docFootnote"><A class="docLink" HREF="#ch08en17">[17]</A></sup> JavaScript makes an interesting study for two reasons. First, it's about as close to being a general-purpose language as one can get without actually being there. Second, the binding between client-side JavaScript and its browser environment via a single DOM object is well designed, and could serve as a model for other embedding situations.</P><blockquote><p class="docFootnote"><sup><A NAME="ch08en17">[17]</A></sup> Open-source JavaScript implementations in C and Java are available &lt;<A class="docLink" target="_blank" HREF="http://www.mozilla.org/js/default.htm">http://www.mozilla.org/js/</A>&gt;.</p></blockquote>


<ul></ul></td></tr></table>
<td></td>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<td class="tt1"><a href="NFO/lib.html">[ Team LiB ]</a></td><td valign="top" class="tt1" align="right">
          <a href="0131429019_ch08lev1sec1.html"><img src="FILES/btn_prev.gif" width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a>
          <a href="0131429019_ch08lev1sec3.html"><img src="FILES/btn_next.gif" width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a>
</td></table>
</body></html>
