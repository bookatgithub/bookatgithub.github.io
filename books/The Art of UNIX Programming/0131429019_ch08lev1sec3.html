<html><head>
<META http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<!--SafClassName="docSection1Title"--><!--SafTocEntry="8.3 Designing Minilanguages"-->
<link rel="STYLESHEET" type="text/css" href="FILES/style.css">
<link rel="STYLESHEET" type="text/css" href="FILES/docsafari.css">
<style type="text/css">	.tt1    {font-size: 10pt;}</style>
</head>
<body>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<td class="tt1"><a href="NFO/lib.html">[ Team LiB ]</a></td><td valign="top" class="tt1" align="right">
	<a href="0131429019_ch08lev1sec2.html"><img src="FILES/btn_prev.gif" width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a>
	<a href="0131429019_ch09.html"><img src="FILES/btn_next.gif" width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a>
</td></table>
<br>
<table width="100%" border="0" cellspacing="0" cellpadding="0"><tr><td valign="top"><A NAME="ch08lev1sec3"></A>
<H3 class="docSection1Title">8.3 Designing Minilanguages</H3>
<P class="docText"><A NAME="idd1e20671"></A>When is designing a minilanguage appropriate? We've observed that minilanguages offer a way to push problem specifications to a higher level, and seen how this operates in several case studies. The flip side of this observation is that a minilanguage is likely to be a good approach whenever the domain primitives in your application area are simple and stereotyped, but the ways in which users are likely to want to apply them are fluid and varying.</P>
<P class="docText">For some related ideas, find a description of the Alternate Hard And Soft Layers &lt;<A class="docLink" target="_blank" HREF="http://www.c2.com/cgi/wiki@AlternateHardAndSoftLayers">http://www.c2.com/cgi/wiki?AlternateHardAndSoftLayers</A>&gt; and Scripted Components &lt;<A class="docLink" target="_blank" HREF="http://www.doc.ic.ac.uk/~np2/patterns/scripting/scripting.html">http://www.doc.ic.ac.uk/~np2/patterns/scripting/scripting.html</A>&gt; design patterns.</P>
<P class="docText">An interesting survey of design styles and techniques in minilanguages is <A NAME="idd1e20689"></A> <span class="docEmphasis">Notable Design Patterns for Domain-Specific Languages</span> <A class="docLink" HREF="0131429019_app02.html#biblio77">[Spinellis]</A>.</P>
<A NAME="ch08lev2sec13"></A>
<H4 class="docSection2Title">8.3.1 Choosing the Right Complexity Level</H4>
<P class="docText"><A NAME="idd1e20706"></A><A NAME="idd1e20709"></A>The first important thing to bear in mind when designing a minilanguage is, as usual, to keep it as simple as possible. The taxonomy diagram we used to organize the case studies implies a hierarchy of complexity; you want to keep your design as far toward the left-hand edge as possible. If you can get away with designing a structured data file rather than a minilanguage that is going to modify external data when it's interpreted, by all means do so.</P>
<P class="docText">One very pragmatic reason to stick with structured data rather than a minilanguage is that in a networked world, embedded minilanguage facilities are subject to abuses that can be inconvenient or even dangerous. JavaScript<A NAME="idd1e20720"></A><A NAME="idd1e20723"></A> is a prime example in the 'inconvenient' category; its designers didn't anticipate that it would be used for pop-up advertisements so obnoxious as to create a demand for browser features that suppress JavaScript interpretation.</P>
<P class="docText">Microsoft Word<A NAME="idd1e20730"></A><A NAME="idd1e20735"></A> macro viruses<A NAME="idd1e20739"></A> show how this sort of thing can become actively dangerous, a security hole that costs billions of dollars in downtime and lost productivity annually. It is instructive to note that despite the existence of at least twenty million Unix users worldwide<sup class="docFootnote"><A class="docLink" HREF="#ch08en18">[18]</A></sup> there has never been any Unix equivalent of Windows's frequent macro-virus outbreaks. There are a number of reasons for this, including the fundamentally better security design of Unix; but at least one is the fact that Unix mail agents do <span class="docEmphasis">not</span> default to executing live content in any document that the user views.<sup class="docFootnote"><A class="docLink" HREF="#ch08en19">[19]</A></sup></P><blockquote><p class="docFootnote"><sup><A NAME="ch08en18">[18]</A></sup> 20M is a conservative estimate based on mid-2003 figures from the Linux<A NAME="idd1e20748"></A> Counter and elsewhere.</p></blockquote><blockquote><p class="docFootnote"><sup><A NAME="ch08en19">[19]</A></sup> <span class="docEmphasis">Kmail</span>, which we looked at in <A class="docLink" HREF="0131429019_ch06.html#ch06">Chapter 6</A>, won't even chase off-site links in HTML for this reason.</p></blockquote>
<P class="docText">If there is any way that your application's users might end up running programs from untrusted sources, risky features of your application minilanguage might end up having to be suppressed. Languages like Java<A NAME="idd1e20768"></A> and JavaScript are explicitly <span class="docEmphasis">sandboxed</span><A NAME="idd1e20774"></A>—that is, they have limited access to their environment not merely to simplify their design but to try to prevent potentially destructive operations by buggy or malicious code.</P>
<P class="docText">On the other hand, a lot of bad designs have been botched by designers who failed to face up to the fact that they really needed a minilanguage rather than a data-file format. Too often, language-like features get pasted on as an afterthought. The two most common symptoms of this problem are weak, ad-hoc control structures and poor or nonexistent facilities for declaring procedures.</P>
<P class="docText">It's risky to design minilanguages that are only accidentally Turing-complete. If you do this the odds are good that, sometime in the future, some clever fellow is going to think he needs to press your language into doing loops and conditionals for him. Because these are only available in an obfuscated way, he'll produce obfuscated code. The results may be serviceable in the short term, but are likely to be a nightmare for those who come after him.</P>
<P class="docText">Minilanguage design is both powerful and esthetically rewarding, but it's also full of similar traps. There are kinds of design in which it is appropriate to take the bottom-up approach of pasting together a bunch of low-level services and worrying about their organization after you have explored the problem domain for a while. One of the virtues of minilanguages is that they can help you get a good design out of bottom-up programming by allowing you to defer some top-down decisions into the control flow of programs in your minilanguage. But if you take a bottom-up approach to the minilanguage design <span class="docEmphasis">itself</span>, you are likely to end up with an ugly syntax reflecting a weak language and a poorly-thought-out implementation.</P>
<P class="docText">There are many places in a minilanguage design where small choices make a large difference in the useability and ease of the tool:</P>
<blockquote>

<p class="docText"><A NAME="idd1e20800"></A>As a language designer, it is a good principle to consider the alternatives to giving an error message. When there is true ambiguity in the intent of the programmer an error message is appropriate, but in many cases the intent is clear, and making the language silently do the right thing is a great boon. A good example is C accommodating an extra comma at the end of an array initializer list, which makes both editing and machine generation of array initializers much easier. Anti-examples are the pickiness of various HTML readers, especially their habit of silently discarding parts of your document because of trivial nesting errors.</p>
<p class="docText">—Steve Johnson</p></blockquote>
<P class="docText">On this issue, as elsewhere, there is no substitute for good taste and engineering judgment. If you're going to design a minilanguage, don't do it halfway. Declarative minilanguages should have a clear, consistent language-like syntax designed to be readable by humans. Imperative ones should add a full range of control structures adapted from language models you can expect your users to be familiar with. Think about the language <span class="docEmphasis">as</span> a language; ask yourself esthetic questions like "Will this be comfortable to program in?" and even "Will it be pleasant to look at?" Here, as elsewhere in software design, David Gelernter's<A NAME="idd1e20811"></A> maxim is apt: beauty is the ultimate defense against complexity.</P>

<A NAME="ch08lev2sec14"></A>
<H4 class="docSection2Title">8.3.2 Extending and Embedding Languages</H4>
<P class="docText"><A NAME="idd1e20823"></A><A NAME="idd1e20826"></A>One fundamentally important question is whether you can implement your minilanguage by extending or embedding an existing scripting language<A NAME="idd1e20834"></A>. This is often the right way to go for an imperative minilanguage, but much less appropriate for a declarative one.</P>
<P class="docText">Sometimes it's possible to write your imperative language simply by coding service functions in an interpreted language, which we'll call the 'host' language for purposes of this discussion. Your minilanguage programs are then just scripts that load your service library and use the host language's control structures and other facilities as a framework. Every facility the host language supplies is one you don't have to write.</P>
<P class="docText">This is the easiest way to write a minilanguage. Old-school Lisp<A NAME="idd1e20844"></A> programmers (including me) love this technique and use it heavily. It underlies the design of the <span class="docEmphasis">Emacs</span> editor, and has been rediscovered in the new-school scripting languages like Tcl<A NAME="idd1e20851"></A>, Python<A NAME="idd1e20855"></A>, and Perl<A NAME="idd1e20859"></A>. There are drawbacks to it, however.</P>
<P class="docText">Your host language may be unable to interface to a code library that you need. Or, internally, its ontology of data types may be inadequate for the kind of computation you need to do. Or, after measuring the performance of a prototype, you discover that it's too slow. When any of these things happen, your solution is usually going to involve coding in C<A NAME="idd1e20866"></A> (or C++<A NAME="idd1e20870"></A>) and integrating the results into your minilanguage.</P>
<P class="docText">The option of extending a scripting language<A NAME="idd1e20877"></A> with C code, or of embedding a scripting language in a C program, relies on the existence of scripting languages designed for it. You extend a scripting language by telling it to dynamically load a C library or module in such a way that the C entry points become visible as functions in the extended language. You embed a scripting language in a C program by sending commands to an instance of the interpreter and receiving the results back as values in C.</P>
<P class="docText">Both techniques also rely on the ability to move data between the type ontology of C and the type ontology of your scripting language. Some scripting languages are designed from the ground up to support this. One such is Tcl<A NAME="idd1e20884"></A>, which we'll cover in <A class="docLink" HREF="0131429019_ch14.html#ch14">Chapter 14</A>. Another is <span class="docEmphasis">Guile</span><A NAME="idd1e20894"></A>, an open-source dialect<A NAME="idd1e20898"></A> of the Lisp<A NAME="idd1e20902"></A> variant Scheme. <span class="docEmphasis">Guile</span> is shipped as a library and specifically designed to be embedded in C<A NAME="idd1e20909"></A> programs.</P>
<P class="docText">It is possible (though in 2003 still rather painful and difficult) to extend or embed Perl<A NAME="idd1e20916"></A>. It is very easy to extend Python<A NAME="idd1e20920"></A> and only slightly more difficult to embed it; C extension is especially heavily used in the Python world. Java<A NAME="idd1e20924"></A> has an interface to call 'native methods' in C, though the practice is explicitly discouraged because it tends to break portability. Most versions of shell are not designed for embeddability and extension, but the Korn shell<A NAME="idd1e20928"></A> (ksh93 and later versions) is a notable exception.</P>
<P class="docText">There are lots of bad reasons not to piggyback your imperative minilanguage on an existing scripting language<A NAME="idd1e20935"></A><A NAME="idd1e20938"></A>. One of the few good ones is that you actually want to implement your own custom grammar for error checking. If that's the case, then see the advice about <span class="docEmphasis">yacc</span> and <span class="docEmphasis">lex</span> below.</P>

<A NAME="ch08lev2sec15"></A>
<H4 class="docSection2Title">8.3.3 Writing a Custom Grammar</H4>
<P class="docText"><A NAME="idd1e20956"></A><A NAME="idd1e20959"></A>For declarative minilanguages, one major question is whether or not you should use XML as a base syntax and specify your grammar as an XML document type. This may well be the right thing for elaborately structured declarative minilanguages, but the same caveats we noted in <A class="docLink" HREF="0131429019_ch05.html#ch05">Chapter 5</A> about the design of data-file formats apply—XML might be overkill. If you don't use XML, follow the Rule of Least Surprise<A NAME="idd1e20971"></A><A NAME="idd1e20974"></A> by supporting the Unix conventions we described for data files (simple token-oriented syntax, supporting C<A NAME="idd1e20978"></A> backslash conventions, etc.).</P>
<P class="docText">If you do need a custom grammar, <span class="docEmphasis">yacc</span><A NAME="idd1e20987"></A> and <span class="docEmphasis">lex</span><A NAME="idd1e20993"></A> (or their local equivalent in the language you're using) should probably be your best friends, unless the grammar of your language is so simple that hand-coding a recursive-descent parser is trivial. Even then, <span class="docEmphasis">yacc</span> may give you better error recovery, and a <span class="docEmphasis">yacc</span> specification will be easier to modify as the language syntax evolves. See <A class="docLink" HREF="0131429019_ch09.html#ch09">Chapter 9</A> for a look at the <span class="docEmphasis">yacc</span>- and <span class="docEmphasis">lex</span>-derived tools available in different implementation languages.</P>
<P class="docText">Even if you decide you must implement your own syntax, consider what mileage you can get from reusing existing tools. If you need a macro facility, consider whether preprocessing with <span class="docEmphasis">m4</span>(1) might be the right answer—but consider the cautions in the next section first.</P>

<A NAME="ch08lev2sec16"></A>
<H4 class="docSection2Title">8.3.4 Macros—Beware!</H4>
<P class="docText"><A NAME="idd1e21027"></A><A NAME="idd1e21034"></A>Macro expansion<A NAME="idd1e21038"></A> facilities were a favored tactic for language designers in early Unix; the C<A NAME="idd1e21042"></A> language has one, of course, and we have seen them show up in some of the more complex special-purpose minilanguages like <span class="docEmphasis">pic</span>(1)<A NAME="idd1e21051"></A>. The <span class="docEmphasis">m4</span><A NAME="idd1e21057"></A> preprocessor provides a generic tool for implementing macro-expanding preprocessors.</P>
<P class="docText">Macro expansion is easy to specify and implement, and you can do a lot of cute tricks with it. Those early designers appear to have been influenced by experience with assemblers, in which macro facilities were often the only device available for structuring programs.</P>
<P class="docText">The strength of macro expansion is that it knows nothing about the underlying syntax of the base language, and can be used to extend that syntax. Unfortunately, this power is very easily abused to produce code that is opaque, surprising, and a fertile source of hard-to-characterize bugs.</P>
<P class="docText">In C, the classic example of this sort of problem is a macro such as this:</P>
<pre>

</pre><pre>
#define max(x, y)        x &gt; y ? x : y
</pre><pre>
</pre>
<P class="docText">There are at least two problems with this macro. One is that it can produce surprising results if either of the arguments is an expression including an operator of lower precedence than <TT>&gt;</TT> or <TT>?:</TT>. Consider the expression <TT>max(a = b, ++c)</TT>. If the programmer has forgotten that <TT>max</TT> is a macro, he will be expecting the assignment <TT>a = b</TT> and the preincrement operation on <TT>c</TT> to be executed before the resulting values are passed as arguments to <TT>max</TT>.</P>
<P class="docText">But that's not what will happen. Instead, the preprocessor will expand this expression to <TT>a = b &gt; ++c ? a = b : ++c</TT>, which the C compiler's precedence rules make it interpret as <TT>a = (b &gt; ++c ? a = b : ++c)</TT>. The effect will be to assign to <TT>a</TT>!</P>
<P class="docText">This sort of bad interaction can be headed off by coding the macro definition more defensively.</P>
<pre>

</pre><pre>
#define max(x, y)        ((x) &gt; (y) ? (x) : (y))
</pre><pre>
</pre>
<P class="docText">With this definition, the expansion would be <TT>((a = b) &gt; (++c) ? (a = b) : (++c))</TT>. This solves one problem—but notice that <TT>c</TT> may be incremented twice! There are subtler versions of this trap, such as passing the macro a function-call with side effects.</P>
<P class="docText">In general, interactions between macros and expressions with side effects can lead to unfortunate results that are hard to diagnose. C's macro processor is a deliberately lightweight and simple one; more powerful ones can actually get you in worse trouble.</P>
<P class="docText">The TEX<A NAME="idd1e21136"></A> formatting language (see <A class="docLink" HREF="0131429019_ch18.html#ch18">Chapter 18</A>) well illustrates the general problem. TEX is intentionally Turing-complete (it has conditionals, loops, and recursion), but while it can be made to do amazing things, TEX code tends to be unreadable and painful to debug. The sources for LATEX<A NAME="idd1e21144"></A>, the the most widely used TEX macro package, are an instructive example: they're in very good TEX style, but even so are extremely difficult to follow.</P>
<P class="docText">A minor problem, compared to this one, is that macro expansion tends to screw up error diagnostics. The base language processor generates its error reports relative to the macro expanded text, not the original the programmer is looking at. If the relationship between the two has been obfuscated by macro expansion, the emitted diagnostic can be very difficult to associate with the actual location of the error.</P>
<P class="docText">This is especially a problem with preprocessors and macros that can have multiline expansions, conditionally include or exclude text, or otherwise change line numbers in the expanded text.</P>
<P class="docText">Macro expansion stages that are built into a language can do their own compensation, fiddling line numbers to refer back to the preexpanded text. The macro facility in <span class="docEmphasis">pic</span>(1) does this, for example. This problem is more difficult to solve when the macro expansion is done by a preprocessor.</P>
<P class="docText">The C preprocessor<A NAME="idd1e21163"></A> addresses this problem by emitting <TT>#line</TT> directives whenever it does an inclusion or multiline expansion. The C compiler is expected to interpret these and adjust the line numbers in its error reports accordingly. Unfortunately, <span class="docEmphasis">m4</span> has no such facility.</P>
<P class="docText">These are reasons to use macro expansion with extreme caution. One of the long-term lessons of the Unix experience is that macros tend to create more problems than they solve. Modern language and minilanguage designs have moved away from them.</P>

<A NAME="ch08lev2sec17"></A>
<H4 class="docSection2Title">8.3.5 Language or Application Protocol?</H4>
<P class="docText"><A NAME="idd1e21186"></A><A NAME="idd1e21193"></A>Another important question you need to ask is whether your minilanguage engine will be called interactively by other programs, as a slave process. If so, your design should probably look less like a conversational language for human interaction and more like the kind of application protocols we looked at in <A class="docLink" HREF="0131429019_ch05.html#ch05">Chapter 5</A>.</P>
<P class="docText">The main difference is how carefully marked the boundaries of transactions are. Human beings are good at spotting where conversational output from a CLI ends, and where the prompt for the next input is. They can use context to tell what's significant and what should be ignored. Computer programs have much more trouble with this. Without either unambiguous end markers on output or advance knowledge of the length of the output, they can't tell when to stop reading.</P>
<blockquote>

<p class="docText"><A NAME="idd1e21214"></A>Even worse is when a program's input is buffered (often inadvertently, as by stdio). A program that stops overtly reading at the right place can nonetheless eat past it.</p>
<p class="docText">—Doug McIlroy</p></blockquote>
<P class="docText">Programs in which master processes are trying to do interactive things with slaved minilanguages that are not carefully designed around this problem are prone to deadlock as the master and slave fall out of synchronization (a problem we first noted in <A class="docLink" HREF="0131429019_ch07.html#ch07">Chapter 7</A>).</P>
<P class="docText">There are workarounds for driving minilanguages that are not so carefully designed. The prototype for most of them is the Tcl<A NAME="idd1e21229"></A> <span class="docEmphasis">expect</span> package<A NAME="idd1e21236"></A>. This package assists conversation with CLIs. It's built around the following operation: read from slave until either a given regular-expression pattern is matched or a specified timeout elapses. With this (and, of course, a send-to-slave operation) it's often possible to construct master programs to do reliable dialogues with slave processes even when the latter have not been tailored for the role.</P>
<P class="docText">Workalikes of the <span class="docEmphasis">expect</span> package in other languages are available; a Web search for the name of your favorite language with the added keywords "Tcl expect" is quite likely to turn up something useful. As a minilanguage designer, however, you would be unwise to assume that all your users will be <span class="docEmphasis">expect</span> gurus. Even if they are, this is an extra glue layer and a place for things to go wrong.</P>
<P class="docText">Be aware of this issue when designing your minilanguage. It may be a good idea to add an option that changes its conversational behavior to make it respond more like an application protocol, with unambiguous end-of-output delimiters and an analog of byte stuffing.</P>


<a href="0131429019_18071533.html"><img src="FILES/pixel.gif" width="1" height="1" border="0"></a><ul></ul></td></tr></table>
<td></td>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<td class="tt1"><a href="NFO/lib.html">[ Team LiB ]</a></td><td valign="top" class="tt1" align="right">
          <a href="0131429019_ch08lev1sec2.html"><img src="FILES/btn_prev.gif" width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a>
          <a href="0131429019_ch09.html"><img src="FILES/btn_next.gif" width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a>
</td></table>
</body></html>
