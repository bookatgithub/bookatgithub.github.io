<html><head>
<META http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<!--SafClassName="docSection1Title"--><!--SafTocEntry="11.3 Evaluating Interface Designs"-->
<link rel="STYLESHEET" type="text/css" href="FILES/style.css">
<link rel="STYLESHEET" type="text/css" href="FILES/docsafari.css">
<style type="text/css">	.tt1    {font-size: 10pt;}</style>
</head>
<body>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<td class="tt1"><a href="NFO/lib.html">[ Team LiB ]</a></td><td valign="top" class="tt1" align="right">
	<a href="0131429019_ch11lev1sec2.html"><img src="FILES/btn_prev.gif" width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a>
	<a href="0131429019_ch11lev1sec4.html"><img src="FILES/btn_next.gif" width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a>
</td></table>
<br>
<table width="100%" border="0" cellspacing="0" cellpadding="0"><tr><td valign="top"><A NAME="ch11lev1sec3"></A>
<H3 class="docSection1Title">11.3 Evaluating Interface Designs</H3>
<P class="docText"><A NAME="idd1e25481"></A><A NAME="idd1e25486"></A>All these interface styles survive because they are adapted for different jobs. When making design decisions about a project, it's important to know how to pick a style (or combine styles) that will be appropriate to your application and your user population.</P>
<P class="docText">We will use five basic metrics to categorize interface styles: <span class="docEmphasis">concision</span><A NAME="idd1e25497"></A>, <span class="docEmphasis">expressiveness</span><A NAME="idd1e25503"></A>, <span class="docEmphasis">ease</span><A NAME="idd1e25509"></A>, <span class="docEmphasis">transparency</span><A NAME="idd1e25515"></A>, and <span class="docEmphasis">scriptability</span><A NAME="idd1e25523"></A>. We've already used some of these terms earlier in this book in ways that were preparation for defining them here. They are comparatives, not absolutes; they have to be evaluated with respect to a particular problem domain and with some knowledge of the users' skill base. Nevertheless, they will help organize our thinking in useful ways.</P>
<P class="docText">A program interface is 'concise' when the length and complexity<A NAME="idd1e25530"></A> of actions required to do a transaction with it has a low upper bound (the measurement might be in keystrokes, gestures, or seconds of attention required). Concise interfaces pack a lot of leverage into a relatively few bits or state changes.</P>
<P class="docText">Interfaces<A NAME="idd1e25537"></A> are 'expressive' when they can readily be used to command a wide variety of actions. The <span class="docEmphasis">most</span> expressive interfaces can command combinations of actions not anticipated by the designer of the program, but which nevertheless give the user useful and consistent results.</P>
<P class="docText">The difference between concision and expressiveness is an important one. Consider two different ways of entering text: from a keyboard, or by picking characters from a screen display with mouse clicks. These have equal expressiveness, but the keyboard is more concise (as we can easily verify by comparing average text-entry speeds). On the other hand, consider two dialects of the same programming language, one with a complex-number type and one not. Within the problem domain they have in common, their concision will be identical; but for a mathematician or electrical engineer, the dialect with complex numbers will be much more expressive.</P>
<P class="docText">The 'ease' of an interface<A NAME="idd1e25550"></A> is inversely proportional to the mnemonic load it puts on the user—how many things (commands, gestures, primitive concepts) the user has to remember specifically to support using that interface. Programming languages have a high mnemonic load and low ease; menus and well-labeled on-screen buttons are simpler.</P>
<P class="docText">Recall that we devoted an entire earlier chapter to 'transparency'. In that chapter we touched on the idea of interface transparency, and gave the <span class="docEmphasis">audacity audio editor</span><A NAME="idd1e25559"></A> as one superb example of it. But we were then much more interested in transparency of a different kind, one that relates to the structure of code rather than of user interfaces. We therefore described UI transparency in terms of its effect (nothing obtrudes between the user and the problem domain) rather than the specific features of design that produce it. Now it's time to zero in on these.</P>
<P class="docText">The 'transparency' of an interface is how few things the user has to remember about the state of his problem, his data, or his program while <span class="docEmphasis">using</span> the interface<A NAME="idd1e25569"></A>. An interface has high transparency when it naturally presents intermediate results, useful feedback, and error notifications on the effects of a user's actions. So-called WYSIWYG<A NAME="idd1e25575"></A> (What You See Is What You Get) interfaces are intended to maximize transparency, but sometimes backfire—especially by presenting an over-simplified view of the domain.</P>
<P class="docText">The related concept of discoverability<A NAME="idd1e25582"></A> applies to interface design, as well. A discoverable interface provides the user with assistance in learning it, such as a greeting message pointing to context-sensitive help, or explanatory balloon popups. Though discoverability has to be implemented in rather different ways for each of the interface styles we shall consider, the degree to which it is achievable is largely independent of interface style. Thus, we shall not use it as a metric in this discussion.</P>
<P class="docText">Note that transparency of code and design does not automatically imply transparency of interface, or vice versa! It is all too easy to point to code that has one but not the other.</P>
<P class="docText">The 'scriptability' of an interface<A NAME="idd1e25592"></A> is the ease with which it can be manipulated by other programs (e.g., through the IPC mechanisms discussed in <A class="docLink" HREF="0131429019_ch07.html#ch07">Chapter 7</A>). Scriptable programs are readily usable as components by other programs, reducing the need for costly custom coding and making it relatively easy to automate repetitive tasks.</P>
<P class="docText">That last point—automating repetitive tasks—deserves more attention than it usually gets. Unix programmers, administrators, and users develop a habit of thinking through the routine procedures they use, then packaging them so they no longer have to manually execute or even think about them any more. This habit depends on scriptable interfaces. It is a quiet but tremendous productivity booster not available in most other software environments.</P>
<P class="docText">It will be useful to bear in mind that humans and computer programs have very different cost functions with respect to these metrics. So do novice and expert human users in a particular problem domain. We'll explore how the tradeoffs between them change for different user populations.</P>

<ul></ul></td></tr></table>
<td></td>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<td class="tt1"><a href="NFO/lib.html">[ Team LiB ]</a></td><td valign="top" class="tt1" align="right">
          <a href="0131429019_ch11lev1sec2.html"><img src="FILES/btn_prev.gif" width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a>
          <a href="0131429019_ch11lev1sec4.html"><img src="FILES/btn_next.gif" width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a>
</td></table>
</body></html>
