<html><head>
<META http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<!--SafClassName="docSection1Title"--><!--SafTocEntry="12.4 Throughput vs. Latency"-->
<link rel="STYLESHEET" type="text/css" href="FILES/style.css">
<link rel="STYLESHEET" type="text/css" href="FILES/docsafari.css">
<style type="text/css">	.tt1    {font-size: 10pt;}</style>
</head>
<body>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<td class="tt1"><a href="NFO/lib.html">[ Team LiB ]</a></td><td valign="top" class="tt1" align="right">
	<a href="0131429019_ch12lev1sec3.html"><img src="FILES/btn_prev.gif" width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a>
	<a href="0131429019_ch13.html"><img src="FILES/btn_next.gif" width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a>
</td></table>
<br>
<table width="100%" border="0" cellspacing="0" cellpadding="0"><tr><td valign="top"><A NAME="ch12lev1sec4"></A>
<H3 class="docSection1Title" id="162593-952">12.4 Throughput vs. Latency</H3>
<P class="docText"><A NAME="idd1e28190"></A><A NAME="idd1e28195"></A>Another effect of fast processors is that performance is usually bounded by the cost of I/O and—especially with programs that use the Internet—network transactions. It's therefore valuable to know how to design network protocols for good performance.</P>
<P class="docText">The most important issue is avoiding protocol round trips as much as possible. Every protocol transaction that requires a handshake turns any latency in the connection into a potentially serious slowdown. Avoiding such handshakes is not specifically a Unix-tradition practice, but it's one that needs mention here because so many protocol designs lose huge amounts of performance to them.</P>
<blockquote>

<p class="docText"><A NAME="idd1e28209"></A>I cannot say enough about latency. X11 went well beyond X10 in avoiding round trip requests: the Render extension goes even further. X (and these days, HTTP/1.1) is a streaming protocol. For example, on my laptop, I can execute over 4 <span class="docEmphasis">million</span> 1x1 rectangle requests (8 million no-op requests) per second. But round trips are hundreds or thousands of times more expensive. Anytime you can get a client to do something without having to contact the server, you have a tremendous win.</p>
<p class="docText">—Jim Gettys</p></blockquote>
<P class="docText">In fact, a good rule of thumb is to design for the lowest possible latency and ignore bandwidth costs until your profiling tells you otherwise. Bandwidth problems can be solved later in development by tricks like compressing a protocol stream on the fly; but getting rid of high latency baked into an existing design is much, much harder (often, effectively impossible).</P>
<P class="docText">While this effect shows up most clearly in network protocol design, throughput vs. latency tradeoffs are a much more general phenomenon. In writing applications, you will sometimes face a choice between doing an expensive computation once in anticipation that it will be used several times, or computing only when actually needed (even if that means you will often recompute results). In most cases where you face a tradeoff like this, the right thing to do is bias toward low latency. That is, don't try to precompute expensive operations unless you have a throughput requirement and know by actual measurement that the throughput you are getting is too low. Precomputation may seem efficient because it minimizes total use of processor cycles, but processor cycles are cheap. Unless you are doing one of a handful of monstrously compute-intensive applications like data mining, animation rendering, or the aforementioned bomb simulations, it is usually better to opt for short startup times and quick response.</P>
<P class="docText">In Unix's early days this advice might have been considered heretical. Processors were much slower and cost ratios were very different then; also, the pattern of Unix use was tilted rather more strongly toward server operations. The point about the value of low latency needs to be made partly because even newer Unix developers sometimes inherit an old-time cultural prejudice toward optimizing for throughput. But times have changed.</P>
<P class="docText">Three general strategies for reducing latency are (a) batching transactions that can share startup costs, (b) allowing transactions to overlap, and (c) caching.</P>
<A NAME="ch12lev2sec1"></A>
<H4 class="docSection2Title">12.4.1 Batching Operations</H4>
<P class="docText"><A NAME="idd1e28236"></A><A NAME="idd1e28241"></A>Graphics APIs are frequently written on the assumption that the fixed setup cost for a physical screen update is large. Consequently, the write operations actually modify an internal buffer. It is up to the programmer to decide when enough of these updates have been batched and to issue the call that turns them into a physical screen update. Picking the right spacing of physical updates can make a great deal of difference to the feel of the graphics client. Both the X server and the <span class="docEmphasis">curses</span>(3)<A NAME="idd1e28255"></A> library used by roguelike programs are organized in this way.</P>
<P class="docText">Persistent service daemons are a more Unix-specific example of batching. There are two reasons, one obvious and one subtle, to write persistent daemons (as opposed to CLI servers that are started up fresh for each session). The obvious reason is to manage updates to a shared resource. The less obvious reason, which obtains even for daemons that don't handle updates, is to amortize the cost of reading in the daemon's database across multiple requests. A perfect example of this is the DNS service daemon <span class="docEmphasis">named</span>(8), which must sometimes handle thousands of requests per second, each one of which may actually be blocking a user's Web page load. One of the tactics that makes <span class="docEmphasis">named</span>(8) fast is that it replaces parses of expensive on-disk text files describing DNS zones with accesses to a cache held in memory.</P>

<A NAME="ch12lev2sec2"></A>
<H4 class="docSection2Title">12.4.2 Overlapping Operations</H4>
<P class="docText"><A NAME="idd1e28279"></A><A NAME="idd1e28284"></A>In <A class="docLink" HREF="0131429019_ch05.html#ch05">Chapter 5</A> we compared the POP3<A NAME="idd1e28296"></A> and IMAP<A NAME="idd1e28300"></A> protocols for querying remote-mail servers. We noted that IMAP requests (unlike POP3 requests) are tagged with a request identifier generated by the client; the server, when it ships back a response, includes the tag of the request it pertains to.</P>
<P class="docText">POP3 requests have to be processed in lockstep by both client and server; the client sends a request, waits for the response to that request, and only then can prepare and ship the next one. IMAP requests, on the other hand, are are tagged so they can be overlapped. If an IMAP client knows that it wants to fetch multiple messages, it can stream several fetch requests (each with a different tag) to the IMAP server, without waiting for responses between them. Responses, each tagged, will come back when the server is ready; responses to early requests may come in while the client is still shipping later ones.</P>
<P class="docText">This strategy is general to more areas than network protocols. If you want to cut latency, blocking or waiting on intermediate results is deadly.</P>

<A NAME="ch12lev2sec3"></A>
<H4 class="docSection2Title">12.4.3 Caching Operation Results</H4>
<P class="docText"><A NAME="idd1e28318"></A><A NAME="idd1e28323"></A>Sometimes you can get the best of both worlds (low latency and good throughput) by computing expensive results as needed and caching them for later use. Earlier we mentioned that <span class="docEmphasis">named</span> reduces latency by batching; it also reduces latency by caching the results of previous network transactions with other DNS servers.</P>
<P class="docText">Caching has its own problems and tradeoffs, which are well illustrated by one application: the use of binary caches to eliminate parsing overhead associated with text database files. Some variants of Unix have used this technique to speed up access to their password information (the usual motivation was to cut latency on logins at very large sites).</P>
<P class="docText">To make this work, all code that looks at the binary cache has to know that it should check the timestamps on both files and regenerate the cache if the text master is newer. Alternatively, all changes to the textual master must be made through a wrapper that will update the binary format.</P>
<P class="docText">While this approach can be made to work, it has all the disadvantages that the SPOT<A NAME="idd1e28343"></A> rule would lead us to expect. The duplication of data means that it doesn't yield any economy of storage—it's purely a speed optimization<A NAME="idd1e28347"></A>. But the real problem with it is that the code to ensure coherency between cache and master is notoriously leaky and bug-prone. Very frequently updated cache files can lead to subtle race conditions simply because of the 1-second resolution of timestamps.</P>
<P class="docText">Coherency can be guaranteed in simple cases. One such is the Python interpreter<A NAME="idd1e28354"></A><A NAME="idd1e28357"></A>, which compiles and deposits on disk a p-code file with extension <TT>.pyc</TT> when a Python library file is first imported. On subsequent runs the cached copy of the p-code is loaded unless the source has since changed (this avoids reparsing the library source code on every run). Emacs Lisp uses a similar technique with <TT>.el</TT> and <TT>.elc</TT> files. This technique works because both read and write accesses to the cache go through a single program.</P>
<P class="docText">When the update pattern of the master is more complex, however, the synchronization code tends to spring leaks. The Unix variants that used this technique to speed up access to critical system databases were infamous for spawning system-administrator horror stories that reflected this.</P>
<P class="docText">In general, binary cache files are a brittle technique and probably best avoided. The work that went into implementing a special-purpose hack to reduce latency in this one case would have been better spent improving the application design so it doesn't have a bottleneck there—or even on tuning to improve the speed of the file system or the virtual-memory implementation.</P>
<P class="docText">When you think you are in a situation that demands caching, it is wise to look one level deeper and ask why the caching is necessary. It may well be no more difficult to solve that problem than it would be to get all the edge cases in the caching software right.</P>


<ul></ul></td></tr></table>
<td></td>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<td class="tt1"><a href="NFO/lib.html">[ Team LiB ]</a></td><td valign="top" class="tt1" align="right">
          <a href="0131429019_ch12lev1sec3.html"><img src="FILES/btn_prev.gif" width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a>
          <a href="0131429019_ch13.html"><img src="FILES/btn_next.gif" width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a>
</td></table>
</body></html>
