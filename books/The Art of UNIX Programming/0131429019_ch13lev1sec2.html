<html><head>
<META http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<!--SafClassName="docSection1Title"--><!--SafTocEntry="13.2 A Tale of Five Editors"-->
<link rel="STYLESHEET" type="text/css" href="FILES/style.css">
<link rel="STYLESHEET" type="text/css" href="FILES/docsafari.css">
<style type="text/css">	.tt1    {font-size: 10pt;}</style>
</head>
<body>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<td class="tt1"><a href="NFO/lib.html">[ Team LiB ]</a></td><td valign="top" class="tt1" align="right">
	<a href="0131429019_ch13lev1sec1.html"><img src="FILES/btn_prev.gif" width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a>
	<a href="0131429019_ch13lev1sec3.html"><img src="FILES/btn_next.gif" width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a>
</td></table>
<br>
<table width="100%" border="0" cellspacing="0" cellpadding="0"><tr><td valign="top"><A NAME="ch13lev1sec2"></A>
<H3 class="docSection1Title">13.2 A Tale of Five Editors</H3>
<P class="docText">Now we're going to use five different Unix editors as case studies. It will be helpful to bear in mind a set of benchmark tasks as we examine these designs:</P>
<UL><LI><p class="docText"><span class="docEmphasis">Plain-text editing.</span> <A NAME="idd1e28801"></A><A NAME="idd1e28804"></A> Manipulating plain ASCII (or, in this internationalized age, perhaps Unicode) files with no structure known to the editor above byte level, or perhaps line level.</p></LI><LI><p class="docText"><span class="docEmphasis">Rich-text editing.</span> <A NAME="idd1e28817"></A><A NAME="idd1e28820"></A> Editing of text with attributes; these might include font changes, color, or other sorts of properties of text spans (such as being a hyperlink). Editors that can do this have to be able to translate between some presentation of the attributes in the user interface and some on-disk representation of the data (such as HTML, XML, or other rich-text formats.)</p></LI><LI><p class="docText"><span class="docEmphasis">Syntax awareness.</span> <A NAME="idd1e28833"></A><A NAME="idd1e28836"></A> An editor that is syntax-aware knows that input events have a grammar, and does things like automatically changing the indent level when it recognizes the beginning or end of a block scope in a programming language. Editors that are syntax-aware also commonly highlight syntax with colors or distinguished fonts.</p></LI><LI><p class="docText"><span class="docEmphasis">Output parsing</span> <span class="docEmphRoman">of batch command output.</span> <A NAME="idd1e28848"></A><A NAME="idd1e28853"></A>The commonest case of this in the Unix world is running a C compilation from inside the editor, trapping the error messages, and then being able to step through the error locations without leaving the editor.</p></LI><LI><p class="docText"><span class="docEmphasis">Interaction</span> <span class="docEmphRoman">with helper subprocesses that persist and maintain state between editor commands</span>. <A NAME="idd1e28867"></A>This capability, when present, has powerful consequences:</p><UL><LI><P class="docList">It's possible to drive a version-control system from inside the editor, performing file checkins and checkouts without dropping out to a shell window or separate utility.</P></LI><LI><P class="docList">It's possible to front-end a symbolic debugger inside the editor, such that (for example) when the run stops on a breakpoint the appropriate file and line is automatically visited.</P></LI><LI><P class="docList">It's possible to edit remote files within the editor, by having it recognize when a filename refers to another host (recognizing some syntax like <TT>/user@host:/path/to-file</TT>). Provided you have the right access, such an editor can automatically run a utility like <span class="docEmphasis">scp</span>(1) or <span class="docEmphasis">ftp</span>(1) to fetch a local copy, then automatically copy the edited version back to the remote location at file-save time.</P></LI></UL></LI></UL>
<P class="docText">All our case studies can edit plain text. (The reader should not take this capability for granted—there are many things called editors, such as 'word processors' that are too specialized to do this!) We begin seeing variable degrees of optional complexity in how they handle the more complex tasks.</P>
<A NAME="ch13lev2sec6"></A>
<H4 class="docSection2Title">13.2.1 <span class="docEmphasis">ed</span></H4>
<P class="docText"><A NAME="idd1e28915"></A><A NAME="idd1e28920"></A><span class="docEmphasis">ed</span>(1) is the truly Unix-minimalist way of plain-text editing. It dates from the days of teletypes.<sup class="docFootnote"><A class="docLink" HREF="#ch13en03">[3]</A></sup> It has a simple, austere CLI, and there is no screen display. In the following listing, computer output is <span class="docEmphasis">emphasized</span>.</P><blockquote><p class="docFootnote"><sup><A NAME="ch13en03">[3]</A></sup> Younger readers may not be aware that terminals used to print. On paper. Very slowly.</p></blockquote>
<pre>

</pre><pre>
ed sample.txt
<span class="docEmphasis">sample.txt: No such file or directory</span>
# This is a comment line, not a command.
# The message above warns that the sample.txt file is newly created.
a
<span class="docEmphasis">the quick brown fox</span>
<span class="docEmphasis">jumped over the lazy dog</span>
.
# That was an append command, which added text to the file.
# The dot on a line by itself terminated the append.
1s/f[a-z]x/dragon/
# On line 1, replace the first substring matching an f followed by a
# lowercase alphabetic followed by x with 'dragon'. The
# substitute command accepts basic regular expressions.
1,$p
the quick brown dragon
jumped over the lazy dog
# Print all lines from 1 to the last.
w
<span class="docEmphasis">51</span>
# That wrote the file to disk. The 'q' command ends the
# editing session.
q
</pre><pre>
</pre>
<P class="docText">Unbelievable as it may seem to a modern reader, most of Unix's original code was written with this editor. The reader with DOS experience may recognize here the original on which <span class="docEmphasis">EDLIN</span> was (crudely) modeled.</P>
<P class="docText">If one defines the job of an editor simply as enabling the user to create and modify plain text files, <span class="docEmphasis">ed</span>(1) is entirely sufficient for the job. Importantly to the Unix view of design correctness, it does nothing else. Many old-school Unix programmers half-seriously maintain that all editors with more features than ed has are simply bloated—and a few still who seriously believe this.</P>
<P class="docText">Appropriately, <span class="docEmphasis">ed</span> was Ken Thompson's<A NAME="idd1e28972"></A> deliberate simplification of the earlier <span class="docEmphasis">qed</span><A class="docLink" HREF="0131429019_app02.html#biblio72">[RitchieQED]</A> editor<A NAME="idd1e28981"></A>—which was very similar (and the first editor to use regular expressions in the characteristic Unix way) but had multiple-buffer capability that Ken deliberately discarded. He judged it not worth the additional complexity.</P>
<P class="docText">A notable characteristic of <span class="docEmphasis">ed</span>(1) and all its descendants is the object-operation format of its commands (the session example shows an explicit range on the 'p' command). There is a relatively powerful syntax for specifying line ranges, either numerically, or by regular-expression pattern match, or by special shorthands for the current and last line. Most editor operations can be applied to any range. This is a good example of orthogonality<A NAME="idd1e28991"></A>.</P>
<P class="docText">Nowadays, <span class="docEmphasis">ed</span>(1) is primarily used as a program-driven editing tool in scripts—a role to which editors with more elaborate modes of interactivity are unsuited. There is a close variant called <span class="docEmphasis">ex</span>(1) which adds a few useful interactivity features such as command prompts; it is occasionally useful in rare cases when editing must be done over a slow serial line, or in certain unusual crash-recovery situations where the library support needed to run other editors is not accessible. For these reasons, every Unix includes an <span class="docEmphasis">ed</span> implementation and most include <span class="docEmphasis">ex</span> as well.</P>
<P class="docText">The <span class="docEmphasis">sed</span>(1) stream editor mentioned in <A class="docLink" HREF="0131429019_ch09.html#ch09">Chapter 9</A> is also closely related to ed; many of the basic commands are the same, though designed to be invoked through command-line switches rather than from standard input.</P>
<P class="docText">Almost all Unix programmers have strayed from the path of austerity and minimalist virtue enough to normally use editors that at least present a roguelike, screen-oriented interface. However, the fact that the religion of ed persists<sup class="docFootnote"><A class="docLink" HREF="#ch13en04">[4]</A></sup> says a great deal that is worth noting about the Unix mindset.</P><blockquote><p class="docFootnote"><sup><A NAME="ch13en04">[4]</A></sup> The religion of ed is exemplified by a famous Usenet<A NAME="idd1e29026"></A> posting which the reader may be able to find with a Web search for "Ed is the standard editor". While it is clearly intended as parody, it is by no means clear that the author was entirely joking. Most Unix hackers<A NAME="idd1e29030"></A> would read it as an example of "Ha ha, only serious".</p></blockquote>

<A NAME="ch13lev2sec7"></A>
<H4 class="docSection2Title">13.2.2 vi</H4>
<P class="docText"><A NAME="idd1e29043"></A><A NAME="idd1e29046"></A>The original <span class="docEmphasis">vi</span>(1) editor was the first attempt to bolt a visual, roguelike interface onto the command set of <span class="docEmphasis">ed</span>(1). Like ed, its commands are generally single keystrokes, and it is particularly well suited to use by touch-typists.</P>
<P class="docText">The original vi didn't have mouse support, editing menus, macros, assignable key bindings, or any form of user customization. In line with the religion of ed, vi's partisans considered the lack of these features a virtue. On this view, one of vi's most important virtues is that you can start editing immediately on a new Unix system without having to carry along your customizations or worrying that the default command bindings will be dangerously different from what you're used to.</P>
<P class="docText">One characteristic of vi that beginners tend to find frustrating is a result of its terse single-keystroke commands. It has a <span class="docEmphasis">moded</span><A NAME="idd1e29068"></A> interface—you are either in command mode or in text-insertion mode. In text-insertion mode, the only commands that work are the ESC key for mode exit and (on newer versions) the cursor-movement keys. In command mode, typing text will be interpreted as commands and do odd (and probably destructive) things to your content.</P>
<P class="docText">On the other hand, one property of the command set that vi fans particularly tout is the object-operation format it inherited from ed. Most of the extended commands also operate in a natural way on any line range.</P>
<P class="docText">Over the years, vi has bulked up considerably. Modern versions add mouse support, editing menus, unlimited undo (the original vi could only undo the last command), multiple files in separate buffers, and customization with a run-control file. However, the use of run-control files is still unusual, and in contrast to Emacs<A NAME="idd1e29078"></A>, the use of embedded general-purpose scripting has never caught on. Instead, vi implementations have grown individual capabilities to do things, like syntax awareness of C code and output parsing of C compiler error messages, by adding C code to vi itself. Subprocess interaction is not supported.</P>

<A NAME="ch13lev2sec8"></A>
<H4 class="docSection2Title">13.2.3 <span class="docEmphasis">Sam</span></H4>
<P class="docText"><A NAME="idd1e29091"></A>The <span class="docEmphasis">Sam</span> editor<sup class="docFootnote"><A class="docLink" HREF="#ch13en05">[5]</A></sup> was written by Rob Pike at Bell Labs in the mid-1980s. Sam was designed for the Plan 9<A NAME="idd1e29107"></A> operating system<A NAME="idd1e29111"></A>, which we'll survey in <A class="docLink" HREF="0131429019_ch20.html#ch20">Chapter 20</A>. While the Sam editor is not widely known outside the Labs, it's favored by many of the original Unix developers who went on to work on Plan 9, including Ken Thompson himself.</P><blockquote><p class="docFootnote"><sup><A NAME="ch13en05">[5]</A></sup> &lt;<A class="docLink" target="_blank" HREF="http://www.plan9.bell-labs.com/sys/doc/sam/sam.html">http://plan9.bell-labs.com/sys/doc/sam/sam.html</A>&gt;</p></blockquote>
<P class="docText">Sam is a fairly straightforward descendant of ed, remaining much closer to its parent than vi. Sam incorporates only two new concepts: a curses-style text display and text selection with the mouse.</P>

<P class="docText">Each Sam session has exactly one command window, and one or more text windows. Text windows edit text, and command windows accept ed-style editing commands. The mouse is used to move between windows, and to select text regions within text windows. This is a clean, orthogonal, modeless design that discards most of the interface complexity of vi.</P>
<P class="docText">Most commands operate by default on a select region that can be painted with a mouse drag operation. The select region for a command can also be set by specifying a line range in the fashion of ed, but Sam gains considerable power from the fact that the user can select at finer granularity than a line range. Because the mouse is available to do selections and rapidly change focus between buffers (including the command buffer), Sam needs no equivalent of the default (command) mode of vi. The hundreds of extended vi commands are unnecessary and, therefore, omitted. Overall, Sam adds only about a dozen commands to the seventeen or so in the ed set, for a total of about thirty.</P>
<P class="docText">Four of the new commands in Sam join two inherited from <span class="docEmphasis">ed</span>(1) and <span class="docEmphasis">vi</span>(1), as ways to apply regular expressions to the task of selecting files and file regions to operate on. These provide limited but effective loop and conditional facilities to the command language. There is, however, no way to name or parameterize command-language procedures. Nor can the language do interactive control of a subprocess.</P>
<P class="docText">An interesting feature of Sam is that it's split into two parts. separating a back end that manipulates files and does searches from a front end that handles the screen interface. This instance of the "separated engine and interface" chapter has the immediate practical benefit that, though the program has a GUI, it can run easily over a low-bandwidth connection to edit files on a remote server. Also, the front and back ends can be retargeted relatively easily.</P>
<P class="docText">Sam, like recent versions of vi, has infinite undo. By design, it supports neither rich-text editing, nor output parsing, nor subprocess interaction.</P>

<A NAME="ch13lev2sec9"></A>
<H4 class="docSection2Title">13.2.4 Emacs</H4>
<P class="docText"><A NAME="idd1e29151"></A><A NAME="idd1e29154"></A><A NAME="idd1e29159"></A><span class="docEmphasis">Emacs</span> is undoubtedly the most powerful programmer's editor in existence. It's a big, feature-laden program with a great deal of flexibility and customizability. As we observed in the <A class="docLink" HREF="0131429019_ch14.html#ch14">Chapter 14</A> section on Emacs Lisp, Emacs has an entire programming language inside it that can be used to write arbitrarily powerful editor functions.</P>
<P class="docText">Unlike vi<A NAME="idd1e29172"></A>, Emacs doesn't have interface modes; instead, commands are normally control characters or prefixed with an ESC. However, in Emacs it is possible to bind just about any key sequence to any command, and commands can be stock or customized Lisp programs.</P>
<P class="docText">Emacs can edit multiple files, each in a separate buffer, and supports moving text among the buffers. Versions running under X have native mouse support.</P>
<P class="docText">The Lisp programs bound to Emacs keystrokes can perform arbitrary text transformations on a buffer. This capability is heavily used, among other things to define syntax-aware and rich-text editing modes for dozens of different languages and markup formats (beginning with support and color highlighting of C code as in vi, but going way beyond that). Each mode is simply a library file of Lisp code that is loaded on demand.</P>
<P class="docText">Emacs Lisp programs can also interactively control arbitrary subprocesses. Some notable consequences of this capability were listed earlier, including the ability to serve as a front end for version-control systems, debuggers, and the like.</P>
<P class="docText">The designers of Emacs<sup class="docFootnote"><A class="docLink" HREF="#ch13en06">[6]</A></sup> built a programmable editor that could have task-related intelligence customized into it for hundreds of different specialized editing jobs. They then gave it the ability to drive other tools. As a result, Emacs supports dealing with all things textual in one shared context—files, mail, news, debugger symbols. It can serve as a customizable front end to any command with an interactive textual interface.</P><blockquote><p class="docFootnote"><sup><A NAME="ch13en06">[6]</A></sup> The designers of Emacs were Richard M. Stallman<A NAME="idd1e29191"></A>, Bernie Greenberg, and Richard M. Stallman. The original Emacs was Stallman's invention, the first version with an embedded Lisp was Greenberg's, and the now-definitive version is Stallman's derived from Greenberg's. No complete account of the design history has been written in 2003, but Greenberg's <span class="docEmphasis">Multics Emacs: The History, Design, and Implementation</span><A NAME="idd1e29197"></A> is illuminating and readily discoverable via keyword search on the Web.</p></blockquote>
<P class="docText">It is a common joke, both among fans and detractors of Emacs, to describe it as an operating system masquerading as an editor. That overstates the case, but Emacs certainly does fulfill the role occupied by integrated development environments (IDEs) under non-Unix operating systems (a theme to which we shall return in <A class="docLink" HREF="0131429019_ch15.html#ch15">Chapter 15</A>).</P>
<P class="docText">This power comes at a price in complexity. To use a customized Emacs you have to carry around the Lisp files that define your personal Emacs preferences. Learning how to customize Emacs is an entire art in itself. Emacs is correspondingly harder to learn than vi.</P>

<A NAME="ch13lev2sec10"></A>
<H4 class="docSection2Title">13.2.5 Wily</H4>
<P class="docText"><A NAME="idd1e29223"></A><A NAME="idd1e29226"></A>The <span class="docEmphasis">wily</span> editor<sup class="docFootnote"><A class="docLink" HREF="#ch13en07">[7]</A></sup> is a clone of the Plan 9<A NAME="idd1e29242"></A><A NAME="idd1e29245"></A> editor <span class="docEmphasis">acme</span>.<sup class="docFootnote"><A class="docLink" HREF="#ch13en08">[8]</A></sup> It shares some facilities with Sam, but is intended to provide a fundamentally different user experience. Although Wily probably sees the least widespread use of any of these editors, it is interesting because it illustrates a different and arguably more Unixy way of implementing an Emacs-like programmable editor.</P><blockquote><p class="docFootnote"><sup><A NAME="ch13en07">[7]</A></sup> &lt;<A class="docLink" target="_blank" HREF="http://www.cs.yorku.ca/~oz/wily">http://www.cs.yorku.ca/~oz/wily</A>&gt;</p></blockquote><blockquote><p class="docFootnote"><sup><A NAME="ch13en08">[8]</A></sup> &lt;<A class="docLink" target="_blank" HREF="http://www.plan9.bell-labs.com/sys/doc/acme/acme.html">http://plan9.bell-labs.com/sys/doc/acme/acme.html</A>&gt;</p></blockquote>
<P class="docText">Wily could be described as a minimalist IDE, an implementation of Emacs-style extensibility<A NAME="idd1e29265"></A> without the decades of accompanying cruft. In Wily, even global search and replace, that <span class="docEmphasis">sine qua non</span> of Unix editors, is supplied by an external program. The built-in commands relate almost exclusively to windowing operations. Wily is designed from the ground up to use the mouse as much, and as well, as possible.</P>
<P class="docText">Wily attempts to replace not only conventional editors but conventional terminal windows such as <span class="docEmphasis">xterm</span>(1) as well. In Wily, any piece of text within the main window (which contains multiple non-overlapping Wily windows) can be an action or a search expression. The left mouse button is used to select text, the middle button to execute text as a command (either built-in or external), and the right button to search either Wily's buffers or the file system for text. No permanent or popup menus are required.</P>
<P class="docText">In Wily, the keyboard is used <span class="docEmphasis">only</span> to enter text. Shortcuts are achieved not by special use of the keyboard, but by holding down more than one mouse button at the same time. These shortcuts are always equivalent to using the middle button on some built-in command.</P>
<P class="docText">Wily can also be used as the front end for C, Python, or Perl programs, reporting to them whenever a window is changed or an execute or search command is performed with the mouse. These plugins function analogously to Emacs modes, but don't run in the same address space with Wily; instead, they communicate with it via a very simple set of remote procedure calls. Wily comes packaged with an <span class="docEmphasis">xterm</span> analog and a mail tool which uses it as the editing front end.</P>
<P class="docText">Because Wily depends on the mouse so heavily, it cannot be used on a character-cell-only console display; nor can it be used over a remote link without X forwarding. As an editor, Wily is designed for editing plain text; it has only two fonts (one proportional and one fixed-width) and has no mechanism that could support rich-text editing or syntax awareness.</P>


<ul></ul></td></tr></table>
<td></td>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<td class="tt1"><a href="NFO/lib.html">[ Team LiB ]</a></td><td valign="top" class="tt1" align="right">
          <a href="0131429019_ch13lev1sec1.html"><img src="FILES/btn_prev.gif" width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a>
          <a href="0131429019_ch13lev1sec3.html"><img src="FILES/btn_next.gif" width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a>
</td></table>
</body></html>
