<html><head>
<META http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<!--SafClassName="docSection1Title"--><!--SafTocEntry="14.4 Language Evaluations"-->
<link rel="STYLESHEET" type="text/css" href="FILES/style.css">
<link rel="STYLESHEET" type="text/css" href="FILES/docsafari.css">
<style type="text/css">	.tt1    {font-size: 10pt;}</style>
</head>
<body>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<td class="tt1"><a href="NFO/lib.html">[ Team LiB ]</a></td><td valign="top" class="tt1" align="right">
	<a href="0131429019_ch14lev1sec3.html"><img src="FILES/btn_prev.gif" width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a>
	<a href="0131429019_ch14lev1sec5.html"><img src="FILES/btn_next.gif" width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a>
</td></table>
<br>
<table width="100%" border="0" cellspacing="0" cellpadding="0"><tr><td valign="top"><A NAME="ch14lev1sec4"></A>
<H3 class="docSection1Title">14.4 Language Evaluations</H3>
<P class="docText"><A NAME="idd1e29954"></A>Mixing languages is a knowledge-intensive (rather than coding-intensive) style of programming. To make it work, you have to have both working knowledge of a suitable variety of languages and expertise about what they're best at and how to fit them together. In this section, we will try to point you at references to help you with the first and an overview to convey the second. For each language surveyed we will include case studies of successful programs that exemplify its strengths.</P>
<A NAME="ch14lev2sec1"></A>
<H4 class="docSection2Title">14.4.1 C</H4>
<P class="docText"><A NAME="idd1e29967"></A><A NAME="idd1e29970"></A>Despite the memory-management problem, there are some application niches for which C is still king<A NAME="idd1e29978"></A>. Programs that require maximum speed, have real-time requirements, or are tightly coupled to the OS kernel are good candidates for C.</P>
<P class="docText">Programs that must be portable across multiple operating systems may also be good candidates for C. Some of the alternatives to C that we shall discuss below are, however, increasingly penetrating major non-Unix operating systems; in the near future, portability may be less a distinguishing advantage of C.</P>
<P class="docText">Sometimes the leverage to be gained from existing programs like parser generators or GUI builders that generate C code is so great that it justifies C coding of the rest of a small application.</P>
<P class="docText">And, of course, C proved indispensable to the developers of all its alternatives. Dig down through enough implementation layers under any of the other languages surveyed here and you will find a core implemented in pure, portable C. These languages inherit many of the advantages of C.</P>
<P class="docText">Under modern conditions, it's perhaps best to think of C as a high-level assembler for the Unix virtual machine (recall the discussion of the success of C as a case study in <A class="docLink" HREF="0131429019_ch04.html#ch04">Chapter 4</A>). C standards have exported many of the facilities of this virtual machine, such as the standard I/O library, to other operating systems. C is where you go when you want to get as close as possible to the bare metal but stay portable.</P>
<P class="docText">One good reason to learn C, even if your programming needs are satisfied by a higher-level language, is that it can help you learn to think at hardware-architecture level. The best reference and tutorial on C for people who are already programmers is still <span class="docEmphasis">The C Programming Language</span> [Kernighan-Ritchie].</P>
<P class="docText">Porting C code between Unix variants is almost always possible and usually easy, but specific areas of variation (like signals and process control) can be tricky to get right. We highlight some of these issues in <A class="docLink" HREF="0131429019_ch17.html#ch17">Chapter 17</A>. Differing C bindings on other operating systems can of course cause C portability problems, although Windows NT at least theoretically supports an ANSI/POSIX-compliant C API.<A NAME="idd1e30016"></A></P>
<P class="docText">High-quality C compilers are available as open-source software<A NAME="idd1e30022"></A> over the Internet; the best-known and most widely used is the Free Software Foundation's GNU C compiler<A NAME="idd1e30026"></A> (part of GCC, the GNU Compiler Collection<A NAME="idd1e30033"></A><A NAME="idd1e30036"></A>), which has become the native C of all open-source Unix systems and many even in the closed-source world. GCC ports are even available for Microsoft's<A NAME="idd1e30043"></A> family of operating systems. GCC sources are available at the FSF's FTP site &lt;<A class="docLink" target="_blank" HREF="ftp://ftp.gnu.org/pub/gnu">ftp://ftp.gnu.org/pub/gnu</A>&gt;.<A NAME="idd1e30059"></A></P>
<P class="docText">Summing up: C's best side is resource efficiency and closeness to the machine. Its worst side is that programming in it is a resource-management hell.</P>
<A NAME="ch14lev3sec1"></A>
<H5 class="docSection3Title">14.4.1.1 C Case Study: <span class="docEmphasis">fetchmail</span></H5>
<P class="docText"><A NAME="idd1e30074"></A><A NAME="idd1e30077"></A>The best case study for C is the Unix kernel itself, for which a language that naturally supports hardware-level operations is actually a strong advantage. But <span class="docEmphasis">fetchmail</span> is a good example of the kind of user-land utility that is still best coded in C.</P>
<P class="docText"><span class="docEmphasis">fetchmail</span> does only the simplest kind of dynamic-memory management; its only complex data structure is a singly-linked list of per-mailserver control blocks built just once, at startup time, and changed only in fairly trivial ways afterwards. This substantially erodes the case against using C by sidestepping C's greatest weakness.</P>
<P class="docText">On the other hand, these control blocks are fairly complex (including all of string, flag, and numeric data) and would be difficult to handle as coherent fast-access objects in an implementation language without an equivalent of the C struct feature. Most of the alternatives to C are weaker than C in this respect (Python<A NAME="idd1e30094"></A> and Java<A NAME="idd1e30098"></A> being notable exceptions).</P>
<P class="docText">Finally, <span class="docEmphasis">fetchmail</span> requires the ability to parse a fairly complex specification syntax for per-mail-server control information. In the Unix world this sort of thing is classically handled by using C code generators that grind out source code for a tokenizer and grammar parser from declarative specifications. The existence of <span class="docEmphasis">yacc</span> and <span class="docEmphasis">lex</span> was a point in favor of C.</P>
<P class="docText"><span class="docEmphasis">fetchmail</span> might reasonably have been coded in Python<A NAME="idd1e30119"></A>, albeit with possibly significant loss of performance. Its size and data-structure complexity would have excluded shell and Tcl<A NAME="idd1e30123"></A> right off and strongly counterindicated Perl<A NAME="idd1e30127"></A>, and the application domain is outside the natural scope of Emacs Lisp<A NAME="idd1e30131"></A>. A Java<A NAME="idd1e30135"></A> implementation wouldn't have been an unreasonable path, but Java's object-oriented style and garbage collection would have offered little purchase on <span class="docEmphasis">fetchmail</span>'s specific problems over what C<A NAME="idd1e30142"></A> already yields. Nor could C++<A NAME="idd1e30146"></A> have done much to simplify the relatively simple internal logic of <span class="docEmphasis">fetchmail</span>.</P>
<P class="docText">However, the real reason <span class="docEmphasis">fetchmail</span> is a C program is that it evolved by gradual mutation from an ancestor already written in C. The existing implementation has been extensively tested on many different platforms and against many odd and quirky servers. Carrying all that implicit knowledge through to a re-implementation in a different language would be messy and difficult. Furthermore, <span class="docEmphasis">fetchmail</span> depends on imported code for functions (like NTLM authentication) that don't seem to be available above C level.</P>
<P class="docText"><span class="docEmphasis">fetchmail</span>'s interactive configurator, which did not have a C legacy problem, is written in Python; we'll discuss that case along with that language.</P>


<A NAME="ch14lev2sec2"></A>
<H4 class="docSection2Title">14.4.2 C++</H4>
<P class="docText"><A NAME="idd1e30176"></A><A NAME="idd1e30179"></A>When C++ was first released to the world in the mid-1980s object-oriented (OO)<A NAME="idd1e30187"></A> languages were being widely touted as the silver bullet for the software-complexity problem. C++'s OO features appeared to be an overwhelming advantage over the ancestral C, and partisans expected that it would rapidly make the older language obsolete.</P>
<P class="docText">This has not happened. Part of the fault can be laid to problems in C++ itself; the requirement that it be backward-compatible with C forced a great many compromises on the design. Among other things, that requirement prevented C++ from going to fully automatic dynamic-memory management and addressing C's most serious problem. Later, feature arms races between different compiler implementers, unconstrained by a weak and premature standardization effort, pushed C++ to become rather baroque and excessively complicated.</P>
<P class="docText">Another part of the fault must be laid to the failure of OO<A NAME="idd1e30197"></A> itself to live up to expectations. We examined this problem in <A class="docLink" HREF="0131429019_ch04.html#ch04">Chapter 4</A>, observing the tendency of OO methods to lead to thick glue layers and maintenance problems. Today (2003), inspection of open-source archives<A NAME="idd1e30205"></A> (in which choice of language reflects developers' judgments rather than corporate mandates) reveals that C++ usage is still heavily concentrated in GUIs, multimedia toolkits and games (the major success areas for OO design), and little used elsewhere.</P>
<P class="docText">It may be that C++'s realization of OO<A NAME="idd1e30212"></A> is particularly problem-prone. There is some evidence that C++ programs have higher life-cycle costs than equivalents in C, FORTRAN<A NAME="idd1e30216"></A>, or Ada<A NAME="idd1e30220"></A>. Whether this is a problem with OO<A NAME="idd1e30224"></A> or specifically with C++ or both remains unclear, though there is reason to suspect both are implicated <A class="docLink" HREF="0131429019_app02.html#biblio34">[Hatton98]</A>.</P>
<P class="docText">In recent years, C++ has incorporated some important non-OO ideas. It has exceptions similar to those in Lisp<A NAME="idd1e30234"></A>; that is, it is possible to throw an object or value up the call stack until it is caught by a handler. STL (Standard Template Library)<A NAME="idd1e30241"></A> provides generic programming; that is, it is possible to code algorithms that are independent of the type signature of their data and have them compiled to do the right thing at runtime. (Only languages that do compile-time static type-checking need this; more dynamic languages simply pass around typeless references and support type identification at runtime.)</P>
<P class="docText">Efficient compiled language; upward-compatible with C; object-oriented platform; vehicle for cutting-edge techniques like STL and generics—C++ tries to be all things to all people, but the cost is more complexity than the mind of any individual programmer can handle. As we noted in <A class="docLink" HREF="0131429019_ch04.html#ch04">Chapter 4</A>, the language's principal designer has conceded that he doesn't expect any one programmer to grasp it all. Unix hackers<A NAME="idd1e30255"></A> do not react well to this; one anonymous but famous characterization is "C++: an octopus made by nailing extra legs onto a dog".</P>
<P class="docText">When all is said and done, however, C++'s most fundamental problem is that it is basically just another conventional language. It confines the memory-management problem better than it did before the invention of the Standard Template Library, and a lot better than C does, but the confinement is brittle; it breaks unless your code uses objects and only objects. For many types of application its OO<A NAME="idd1e30262"></A> features are not significant, and simply add complexity to C without yielding much advantage. Open-source<A NAME="idd1e30266"></A> C++ compilers are available; if C++ were unequivocally superior to C it would now dominate.</P>
<P class="docText">Summing up: C++'s best side is its combination of compiled efficiency with facilities for OO<A NAME="idd1e30273"></A> and generic programming. Its worst side is that it is baroque and complex, and tends to encourage over-complex designs.</P>
<P class="docText">Consider using C++ if an existing C++ toolkit or service library offers powerful leverage for your application, or if you're in one of the application areas mentioned above for which an OO<A NAME="idd1e30280"></A> language is known to be a large win.</P>
<P class="docText">The classic C++ reference is Stroustrup's <span class="docEmphasis">The C++ Programming Language</span> <A class="docLink" HREF="0131429019_app02.html#biblio82">[Stroustrup]</A>. You will find an excellent beginner's tutorial on C++ and basic OO methods in <span class="docEmphasis">C++: A Dialog</span> <A class="docLink" HREF="0131429019_app02.html#biblio36">[Heller]</A>. <span class="docEmphasis">C++ Annotations</span> <A class="docLink" HREF="0131429019_app02.html#biblio06">[Brokken]</A> is a condensed introduction to C++ for expert C programmers.</P>
<P class="docText">The Gnu Compiler Collection<A NAME="idd1e30308"></A> includes a C++ compiler. The language is therefore universally available on Unix and on Microsoft<A NAME="idd1e30312"></A> operating systems; comments made under C above also apply here. Strong collections of open-source support libraries &lt;<A class="docLink" target="_blank" HREF="http://www.boost.org/default.htm">http://www.boost.org/</A>&gt; are available. However, portability is compromised by the fact that (as of mid-2003) actual C++ implementations implement widely varying subsets of the draft ISO standard now in preparation.<sup class="docFootnote"><A class="docLink" HREF="#ch14en04">[4]</A></sup></P><blockquote><p class="docFootnote"><sup><A NAME="ch14en04">[4]</A></sup> The last C++ standard, dating from 1998, was widely implemented but weak, especially in the area of libraries.</p></blockquote>
<A NAME="ch14lev3sec2"></A>
<H5 class="docSection3Title">14.4.2.1 C++ Case Study: The Qt Toolkit</H5>
<P class="docText"><A NAME="idd1e30332"></A><A NAME="idd1e30335"></A>The Qt interface toolkit is one of the notable C++ success stories in today's open-source world. It provides a widget set and API for writing graphical user interfaces under X, one deliberately (and rather effectively) designed to emulate the visual look and feel of Motif, MacOS Platinum<A NAME="idd1e30344"></A>, or the Microsoft Windows<A NAME="idd1e30348"></A> interface. Qt actually provides more than just GUI services; it also provides a portable application layer, with classes for XML, file access, sockets, threads, timers, time/date handling, database access, various abstract data types, and Unicode.</P>
<P class="docText">The Qt toolkit is a critical and visible component of the KDE project, the senior of the open-source world's two efforts to produce a competitive GUI and integrated set of desktop productivity tools.</P>
<P class="docText">Qt's C++ implementation exhibits the strengths of an OO<A NAME="idd1e30358"></A> language for encapsulating user-interface components. In a language supporting objects, a visual hierarchy of interface widgets can be cleanly expressed in the code by a hierarchy of class instances. While this sort of thing can be simulated in C<A NAME="idd1e30362"></A> with explicit indirection through hand-rolled method tables, such code is much cleaner in C++. Comparison with the notoriously baroque C API of Motif is instructive.</P>
<P class="docText">The Qt source code and reference documentation are available at the Trolltech site &lt;<A class="docLink" target="_blank" HREF="http://www.trolltech.com/default.htm">http://www.trolltech.com/</A>&gt;.</P>


<A NAME="ch14lev2sec3"></A>
<H4 class="docSection2Title">14.4.3 Shell</H4>
<P class="docText"><A NAME="idd1e30384"></A><A NAME="idd1e30387"></A><A NAME="idd1e30394"></A>The 'Bourne shell' (<TT>sh</TT>) of Version 7 Unix was Unix's first (and for many years its only) portable interpreted language. Today the ancestral Bourne shell has largely been displaced by variants of the upward-compatible Korn Shell<A NAME="idd1e30403"></A><A NAME="idd1e30406"></A> (<TT>ksh</TT>); the single most important of these is the Bourne Again Shell, bash.</P>
<P class="docText">A few other shells exist and are used interactively, but are not significant as programming languages; of these, the best known is probably the C shell <TT>csh</TT>, which is notoriously<sup class="docFootnote"><A class="docLink" HREF="#ch14en05">[5]</A></sup> unsuitable for writing scripts.</P><blockquote><p class="docFootnote"><sup><A NAME="ch14en05">[5]</A></sup> See Tom Christiansen's essay <span class="docEmphasis">Csh Programming Considered Harmful</span>, which should be readily findable via Web search.</p></blockquote>
<P class="docText">Simple shell programs are extremely easy and natural to write. The Unix tradition of rapid prototyping in interpretive languages began with shell.</P>
<blockquote>

<p class="docText"><A NAME="idd1e30436"></A>I wrote the very first version of netnews as a 150-line shellscript. It had multiple newsgroups and cross-posting; newsgroups were directories and cross-posting was implemented as multiple links to the article. It was far too slow to use for production, but the flexibility permitted endless experimentation with the protocol design.</p>
<p class="docText">—Steven M. Bellovin</p></blockquote>
<P class="docText">As program size gets larger, however, they tend to become rather ad hoc. Some parts of shell syntax (notably its quoting and statement-syntax rules) can be very confusing. These drawbacks generally relate to compromises in the programming-language part of the shell's design made to preserve its utility as an interactive command-line interpreter.</P>
<P class="docText">Programs are described as being 'in shell' even when they are not pure shell but include heavy use of C<A NAME="idd1e30447"></A> filters like <span class="docEmphasis">sort</span>(1)<A NAME="idd1e30454"></A> and of standard text-processing minilanguages like <span class="docEmphasis">sed</span>(1)<A NAME="idd1e30461"></A> or <span class="docEmphasis">awk</span>(1)<A NAME="idd1e30468"></A>. This sort of programming has been in decline for some years, however; nowadays such elaborate glue logic is generally written in Perl<A NAME="idd1e30472"></A> or Python<A NAME="idd1e30476"></A>, with shell being reserved for the simplest kinds of wrappers<A NAME="idd1e30480"></A> (for which these languages would be overkill) and system boot-time initialization scripts (which cannot assume they are available).</P>
<P class="docText">Such basic shell programming should be adequately covered in any introductory Unix book. <span class="docEmphasis">The Unix Programming Environment</span> [Kernighan-Pike84] remains one of the best sources on intermediate and advanced shell programming. Korn shell implementations or clones are present on every Unix.</P>
<P class="docText">Complex shellscripts often have portability problems, not so much because of the shell itself but because they make assumptions about what other programs are available as components. While Bourne and Korn-shell clones have been sporadically available on non-Unix operating systems, shell programs are not (practically speaking) at all portable off Unix.</P>
<P class="docText">Summing up: shell's best side is that it is very natural and quick for small scripts. Its worst side is that large shellscripts depend on lots of auxiliary commands that aren't necessarily identically behaved nor even present on all target machines. Nor is it easy to analyze the dependencies in a large shellscript.</P>
<P class="docText">It is almost never necessary to build or install a shell, since all Unix systems and Unix emulators come equipped with them. The standard shell on Linux<A NAME="idd1e30499"></A> and other leading-edge Unix variants is now <TT>bash</TT>.</P>
<A NAME="ch14lev3sec3"></A>
<H5 class="docSection3Title">14.4.3.1 Case Study: <TT>xmlto</TT></H5>
<P class="docText"><A NAME="idd1e30515"></A><A NAME="idd1e30522"></A><A NAME="idd1e30525"></A><A NAME="idd1e30528"></A><TT>xmlto</TT> is a driver script that calls all the commands needed to render an XML-DocBook document as HTML<A NAME="idd1e30534"></A>, PostScript<A NAME="idd1e30538"></A>, plain text, or in any one of several other formats (we'll take a closer look at DocBook in <A class="docLink" HREF="0131429019_ch18.html#ch18">Chapter 18</A>). It is written in bash.</P>
<P class="docText"><TT>xmlto</TT> handles the details of calling an XSLT engine with appropriate stylesheet<A NAME="idd1e30551"></A>, then handing off the result to a postprocessor. For HTML and XHTML the XSLT transformation does the entire job. For plain text, the XML is also processed into HTML, but then handed to a postprocessor—<span class="docEmphasis">lynx</span>(1) in its <TT>-dump</TT> mode, which renders HTML to flat text. For PostScript, the XML<A NAME="idd1e30561"></A> is transformed to XML FO (formatting objects)<A NAME="idd1e30565"></A><A NAME="idd1e30568"></A> which a postprocessor then massages into TEX macros, to DVI<A NAME="idd1e30572"></A> format via <span class="docEmphasis">tex</span>(1), and then finally to PostScript via the well-known <span class="docEmphasis">dvi2ps</span>(1) tool.</P>
<P class="docText"><TT>xmlto</TT> consists of a single front-end shellscript. It calls any one of several script plugins, each named after the target format. Each plugin is a shellscript. Depending on how it's called, it either supplies a stylesheet for the front end to apply, or calls the appropriate postprocessor(s) with various canned arguments.</P>
<P class="docText">This architecture means that all the information about a given output format lives in one place (the corresponding script plugin), so adding new output types can be done without disturbing the front-end code at all.</P>
<P class="docText"><TT>xmlto</TT> is a good example of a medium-sized shell application. Neither C<A NAME="idd1e30595"></A> nor C++ would have made sense because they are awkward for scripting. Any of the other scripting languages in this chapter could have been used for this job; but it's all simple command dispatching, with no internal data structures or complex logic, so shell is good enough. Shell has the significant advantage of being ubiquitous on the intended target systems.</P>
<P class="docText">In theory this script could run on any system supporting <TT>bash</TT>. The real constraint is the requirement for one of the XSLT engines and all the postprocessors needed to be present on the system. In practice, this script is not likely to run anywhere but under one of the modern open-source Unixes.<A NAME="idd1e30607"></A></P>

<A NAME="ch14lev3sec4"></A>
<H5 class="docSection3Title">14.4.3.2 Case Study: Sorcery Linux</H5>
<P class="docText">Sorcerer GNU/Linux is a Linux<A NAME="idd1e30619"></A><A NAME="idd1e30622"></A><A NAME="idd1e30627"></A><A NAME="idd1e30630"></A><A NAME="idd1e30635"></A> distribution that you install as a small, bootable foothold system just powerful enough to run <span class="docEmphasis">bash</span>(1) and a couple of download utilities. With this code in place, you can invoke Sorcery, the Sorcerer package system.</P>
<P class="docText">Sorcery handles installing, removing, and integrity-checking software packages. When you "cast spells", Sorcery downloads the source code, compiles it, installs it, and saves a list of files that were installed (along with a build log and checksums for all the files). Installed packages can be "dispelled" or removed. Package listing and integrity checks are also available. More details are available at the Sorcery project site &lt;<A class="docLink" target="_blank" HREF="http://www.sorcerer.wox.org/default.htm">http://sorcerer.wox.org</A>&gt;.</P>
<P class="docText">The Sorcery system is written entirely in shell. Program installation procedures tend to be small, simple programs for which shell is appropriate. In this particular application, the main drawback of shell is neutralized because Sorcery's authors can guarantee that the helper programs they need will be present in the foothold system.</P>


<A NAME="ch14lev2sec4"></A>
<H4 class="docSection2Title">14.4.4 Perl</H4>
<P class="docText"><A NAME="idd1e30664"></A><A NAME="idd1e30667"></A>Perl is shell on steroids. It was specifically designed to replace <span class="docEmphasis">awk</span>(1), and expanded to replace shell as the 'glue' for mixed-language script programming.<A NAME="idd1e30678"></A> It was first released in 1987.</P>
<P class="docText">Perl's strongest point is its extremely powerful built-in facilities for pattern-directed processing of textual, line-oriented data formats; it is unsurpassed at this. It also includes far stronger data structures than shell, including dynamic arrays of mixed element types and a 'hash' or 'dictionary' type that supports convenient and fast lookup of name-value pairs.</P>
<P class="docText">Additionally, Perl includes a rather complete and well-thought-out internal binding of virtually the entire Unix API, drastically reducing the need for C<A NAME="idd1e30691"></A> and making it suitable for jobs like simple TCP/IP<A NAME="idd1e30695"></A> clients and even servers. Another strong advantage of Perl is that a large and vigorous open-source community has grown up around it. Its home on the net is the Comprehensive Perl Archive Network &lt;<A class="docLink" target="_blank" HREF="http://www.cpan.org/default.htm">http://www.cpan.org</A>&gt;<A NAME="idd1e30702"></A>. Dedicated Perl hackers<A NAME="idd1e30706"></A> have written hundreds of freely reusable Perl modules for many different programming tasks. These include everything from structure-walking of directory trees through X toolkits for GUI building, through excellent canned facilities for supporting HTTP robots and CGI programming.</P>
<P class="docText">Perl's main drawback is that parts of it are irredeemably ugly, complicated, and must be used with caution and in stereotyped ways lest they bite (its argument-passing conventions for functions are a good example of all three problems). It is harder to get started in Perl than it is in shell<A NAME="idd1e30716"></A>. Though small programs in Perl can be extremely powerful, careful discipline is required to maintain modularity and keep a design under control as program size increases. Because some limiting design decisions early in Perl's history could not be reversed, many of the more advanced features have a fragile, klugey feel about them.</P>
<P class="docText">The definitive reference on Perl is <span class="docEmphasis">Programming Perl</span> <A class="docLink" HREF="0131429019_app02.html#biblio88">[Wall2000]</A>. This book has nearly everything you will ever need to know in it, but is notoriously badly organized; you will have to dig to find what you want. A more introductory and narrative treatment is available in <span class="docEmphasis">Learning Perl</span> [Schwartz-Christiansen].</P>
<P class="docText">Perl is universal on Unix systems. Perl scripts at the same major release level tend to be readily portable between Unixes (provided they don't use extension modules). Perl implementations are available (and even well documented) for the Microsoft<A NAME="idd1e30735"></A> family of operating systems and on MacOS<A NAME="idd1e30739"></A> as well. Perl/Tk provides cross-platform GUI capability.</P>
<P class="docText">Summing up: Perl's best side is as a power tool for small glue scripts involving a lot of regular-expression grinding. Its worst side is that it is ugly, spiky, and nigh-unmaintainable in large volumes.</P>
<A NAME="ch14lev3sec5"></A>
<H5 class="docSection3Title">14.4.4.1 A Small Perl Case Study: <TT>blq</TT></H5>
<P class="docText"><A NAME="idd1e30755"></A><A NAME="idd1e30758"></A>The <TT>blq</TT> script is a tool for querying block lists (lists of Internet sites that have been identified as habitual sources of unsolicited bulk email, aka spam). You can find current sources at the <TT>blq</TT> project page &lt;<A class="docLink" target="_blank" HREF="http://www.unicom.com/sw/blq/default.htm">http://www.unicom.com/sw/blq/</A>&gt;.</P>
<P class="docText"><TT>blq</TT> is a good example of a small Perl script, illustrating both the strengths and weaknesses of the language. It makes intensive use of regular-expression matching. On the other hand, the Net::DNS Perl extension module it uses has to be conditionally included, because it is not guaranteed to be present in any given Perl installation.</P>
<P class="docText"><TT>blq</TT> is exceptionally clean and disciplined as Perl code goes, and I recommend it as an example of good style (the other Perl tools referenced from the <TT>blq</TT> project page are good examples as well). But parts of the code are unreadable unless you are familiar with very specific Perl idioms—the very first line of code, <span class="docEmphStrong"><TT>$0 =~ s!.*/!!;</TT></span>, is an example. While all languages have some of this kind of opacity, Perl has it worse than most.</P>
<P class="docText">Tcl<A NAME="idd1e30793"></A> and Python<A NAME="idd1e30797"></A> are both good for small scripts of this type, but both lack the Perl convenience features for regular-expression matching that <TT>blq</TT> uses heavily; an implementation in either would have been reasonable, but probably less compact<A NAME="idd1e30804"></A> and expressive. An Emacs Lisp<A NAME="idd1e30808"></A> implementation would have been even faster to write and more compact than the Perl one, but probably painfully slow to use.</P>

<A NAME="ch14lev3sec6"></A>
<H5 class="docSection3Title">14.4.4.2 A Large Perl Case Study: <TT>keeper</TT></H5>
<P class="docText"><A NAME="idd1e30822"></A><A NAME="idd1e30825"></A><TT>keeper</TT> is the tool used to file incoming packages and maintain both FTP and WWW index files for the huge Linux<A NAME="idd1e30839"></A> free-software archives at ibiblio. You can find sources and documentation in the search tools subdirectory of the ibiblio archive &lt;<A class="docLink" target="_blank" HREF="http://www.ibiblio.org/default.htm">http://www.ibiblio.org</A>&gt;.</P>
<P class="docText"><TT>keeper</TT> is a good example of a medium-to-large interactive Perl application. The command-line interface is line-oriented and patterned after a specialized shell or directory editor; note the embedded help facilities. The working parts make heavy use of file and directory handling, pattern matching, and pattern-directed editing. Note the ease with which <TT>keeper</TT> generates Web pages and electronic-mail notifications from programmatic templates. Note also the use of a canned Perl module to automate walking various functions over directory trees.</P>
<P class="docText">At about 3300 lines, this application is probably pushing the size and complexity limit of what one should attempt in a single Perl program. Nevertheless, most of it was written in a period of six days. In C<A NAME="idd1e30857"></A><A NAME="idd1e30862"></A>, C++<A NAME="idd1e30866"></A> or Java<A NAME="idd1e30870"></A> it would have taken a minimum of six weeks and been extremely difficult to debug or modify after the fact. It is way too large for pure Tcl<A NAME="idd1e30874"></A>. A Python<A NAME="idd1e30878"></A> version would probably be structurally cleaner, more readable, and more maintainable—but also more verbose (especially near the pattern-matching parts). An Emacs Lisp<A NAME="idd1e30882"></A> mode could readily do the job, but Emacs is not well suited for use over a telnet link that is often slowed to a crawl by server congestion.</P>


<A NAME="ch14lev2sec5"></A>
<H4 class="docSection2Title">14.4.5 Tcl</H4>
<P class="docText"><A NAME="idd1e30895"></A><A NAME="idd1e30898"></A>Tcl (Tool Command Language) is a small language interpreter designed to link with compiled C<A NAME="idd1e30906"></A> libraries, providing scripted control of C code (<span class="docEmphasis">extended scripts</span>)<A NAME="idd1e30913"></A>. Its original application was to control libraries for electronic simulators (SPICE-like applications). Tcl is also suitable for <span class="docEmphasis">embedded scripts</span>—that is, scripts<A NAME="idd1e30920"></A> called from within C programs and returning values to those programs. Tcl had its first general public release in 1990.</P>
<P class="docText">Some facilities built on top of Tcl have achieved wide use outside the Tcl community itself. The two most important of these are:</P>
<UL><LI><P class="docList">The Tk toolkit<A NAME="idd1e30933"></A>, a kinder and gentler X interface that makes it easy to rapidly build buttons, dialog boxes, menu trees, and scrolling text widgets and collect input from them.</P></LI><LI><P class="docList">Expect, a language that makes it relatively easy to script fully interactive programs with widely variable responses.</P></LI></UL>
<P class="docText">The Tk toolkit is so important that the language is often referred to as Tcl/Tk. Tk is also frequently used with Perl<A NAME="idd1e30945"></A> and Python<A NAME="idd1e30949"></A>.</P>
<P class="docText">The main advantage of Tcl itself is that it is extremely flexible and radically simple. The syntax is very odd (based on a positional parser) but totally consistent. There are no reserved words, and there is no syntactic distinction between a function call and 'built in' syntax; thus the Tcl language interpreter itself can be effectively redefined from within Tcl (which is what makes projects like <TT>Expect</TT> reasonable).</P>
<P class="docText">The main drawback of Tcl is that the pure language has only weak facilities for namespace control and modularity, and two of them (<span class="docEmphStrong"><TT>upvar</TT></span> and <span class="docEmphStrong"><TT>uplevel</TT></span>) are rather dangerous if not used with great caution. Also, there are no data structures other than association lists. Tcl therefore scales up very poorly—it is difficult to organize and debug pure Tcl programs of even moderate size (more than a few hundred lines) without tripping over your own feet. In practice, almost all large Tcl programs use one of several OO<A NAME="idd1e30970"></A> extensions to the language.</P>
<P class="docText">The oddities of the syntax can at first be a problem as well; the distinction between string quotes and braces will probably give you headaches for a while, and the rules for when things need to be quoted or braced are a bit tricky.</P>
<P class="docText">Pure Tcl only provides access to a relatively small and commonly used part of the Unix API (essentially just file handling, process-spawning, and sockets). Indeed, Tcl has the flavor of an experiment in seeing how small a scripting language<A NAME="idd1e30983"></A> can get and still be useful. Tcl extensions (similar to Perl modules) provide a richer set of capabilities, but are (like CPAN modules) not guaranteed to be installed everywhere.</P>
<P class="docText">The original Tcl reference is <span class="docEmphasis">Tcl and the Tk Toolkit</span> <A class="docLink" HREF="0131429019_app02.html#biblio58">[Ousterhout94]</A>, but that book has been largely superseded by <span class="docEmphasis">Practical Programming in Tcl and Tk</span> <A class="docLink" HREF="0131429019_app02.html#biblio89">[Welch]</A>. Brian Kernighan<A NAME="idd1e31002"></A> has written a description of a real-world Tcl project <A class="docLink" HREF="0131429019_app02.html#biblio38">[Kernighan95]</A> that summarizes Tcl's strengths and weaknesses as a rapid-prototyping and production tool; his contrast with Microsoft Visual Basic is particularly balanced and instructive.</P>
<P class="docText">The Tcl world doesn't have one central repository run by a core group analogous to Perl's or Python's, but several excellent websites both point to each other and cover most Tcl tool and extension development. Look at the Tcl Developer Xchange &lt;<A class="docLink" target="_blank" HREF="http://www.tcltk.com/default.htm">http://www.tcltk.com</A>&gt; first; among other things, it offers Tcl sources of an interactive Tcl tutorial. There is also a Tcl foundry at SourceForge &lt;<A class="docLink" target="_blank" HREF="http://www.sourceforge.net/foundry/tcl-foundry/default.htm">http://sourceforge.net/foundry/tcl-foundry/</A>&gt;.</P>
<P class="docText">Tcl scripts have portability problems similar to those of shell scripts; the language itself is highly portable, but the components it calls may not be. Tcl implementations exist for the Microsoft family of operating systems<A NAME="idd1e31021"></A>, MacOS<A NAME="idd1e31025"></A>, and many other platforms. Tcl/Tk scripts will run on any platform with GUI capabilities.</P>
<P class="docText">Summing up: Tcl's best side is its spare, compact<A NAME="idd1e31032"></A> design and the extensibility<A NAME="idd1e31036"></A><A NAME="idd1e31039"></A> of the Tcl interpreter. Its worst side is the odd positional parser and the weakness of its data structures and namespace controls; the latter defect makes it scale poorly for large projects.</P>
<A NAME="ch14lev3sec7"></A>
<H5 class="docSection3Title">14.4.5.1 Case Study: <span class="docEmphasis">TkMan</span></H5>
<P class="docText"><A NAME="idd1e31052"></A><A NAME="idd1e31057"></A><span class="docEmphasis">TkMan</span> is a browser for Unix man pages and Texinfo documents. At roughly 1200 lines, it is quite large to be written in pure Tcl, but the code is unusually well-modularized and mature. It uses Tk to provide a GUI interface quite a bit nicer than either the stock <span class="docEmphasis">man</span>(1) or <span class="docEmphasis">xman</span>(1) utilities support.</P>
<P class="docText">TkMan makes a good case study because it exhibits almost the full gamut of Tcl techniques. Highlights include Tk integration, scripted control of other Unix applications (such as the Glimpse search engine), and the use of Tcl to parse Texinfo markup.</P>
<P class="docText">Any of the other languages would have made for a less direct interface to the Tk GUI that constitutes most of this code.</P>
<P class="docText">A Web search for "TkMan" should turn up sources and documentation.</P>

<A NAME="ch14lev3sec8"></A>
<H5 class="docSection3Title">14.4.5.2 Moodss: A Large Tcl Case Study</H5>
<P class="docText"><A NAME="idd1e31086"></A><A NAME="idd1e31091"></A>The Moodss system is a graphical monitoring application for system administrators. It can watch logs and gather statistics for MySQL, Linux, SNMP networks, and Apache<A NAME="idd1e31095"></A>, and presents a digested view of them through spreadsheet-like GUI panels called 'dashboards'. Monitoring modules can be written in Python<A NAME="idd1e31099"></A> or Perl<A NAME="idd1e31103"></A> as well as Tcl. The code is polished, mature, and considered an exemplar in the Tcl community. There is a project website &lt;<A class="docLink" target="_blank" HREF="http://www.jfontain.free.fr/moodss/default.htm">http://jfontain.free.fr/moodss/</A>&gt;.</P>
<P class="docText">The Moodss core consists of about 18,000 lines of Tcl. It uses several Tcl extensions including a custom object system; the Moodss author admits that without these "writing such a big application would not have been possible".</P>
<P class="docText">Again, any of the other languages would have made for a less direct interface to the Tk GUI that constitutes most of this code.</P>


<A NAME="ch14lev2sec6"></A>
<H4 class="docSection2Title">14.4.6 Python</H4>
<P class="docText"><A NAME="idd1e31125"></A><A NAME="idd1e31128"></A>Python is a scripting language<A NAME="idd1e31136"></A> designed for close integration with C<A NAME="idd1e31140"></A>. It can both import data from and export data to dynamically loaded C libraries, and can be called as an embedded scripting language from C. Its syntax is rather like a cross between that of C and the Modula family, but has the unusual feature that block structure is actually controlled by indentation (there is no analog of explicit begin/end or C curly brackets). Python was first publicly released in 1991.</P>
<P class="docText">The Python language is a very clean, elegant design with excellent modularity features. It offers designers the option to write in an object-oriented style but does not force that choice (it can be coded in a more classically procedural C-like way). It has a type system comparable in expressive power to Perl's<A NAME="idd1e31147"></A>, including dynamic container objects and association lists, but less idiosyncratic (actually, it is a matter of record that Perl's<A NAME="idd1e31151"></A> object system was built in imitation of Python's). It even pleases Lisp<A NAME="idd1e31155"></A> hackers<A NAME="idd1e31159"></A> with anonymous lambdas (function-valued objects that can be passed around and used by iterators). Python ships with the Tk toolkit, which can be used to easily build GUI interfaces.</P>
<P class="docText">The standard Python distribution includes client classes for most of the important Internet protocols (SMTP, FTP, POP3, IMAP, HTTP) and generator classes for HTML. It is therefore very well suited to building protocol robots and network administrative plumbing. It is also excellent for Web CGI work, and competes successfully with Perl<A NAME="idd1e31172"></A> at the high-complexity end of that application area.</P>
<P class="docText">Of all the interpreted languages we describe, Python and Java<A NAME="idd1e31179"></A> are the two most clearly suited for scaling up to large complex projects with many cooperating developers. In many ways Python is simpler than Java, and its friendliness to rapid prototyping may give it an edge over Java for standalone use in applications that are neither hugely complex nor speed critical. An implementation of Python in Java, designed to facilitate mixed use of these two languages, is available and in production use; it is called Jython<A NAME="idd1e31183"></A>.</P>
<P class="docText">Python cannot compete with C<A NAME="idd1e31190"></A><A NAME="idd1e31195"></A> or C++<A NAME="idd1e31199"></A> on raw execution speed (though using a mixed-language strategy on today's fast processors probably makes that relatively unimportant). In fact it's generally thought to be the least efficient and slowest of the major scripting languages<A NAME="idd1e31203"></A>, a price it pays for runtime type polymorphism. Beware of rejecting Python on these grounds, however; most applications do not actually need better performance than Python offers, and even those that appear to are generally limited by external latencies such as network or disk waits that entirely swamp the effects of Python's interpretive overhead. Also, by way of compensation, Python is exceptionally easy to combine with C, so performance-critical Python modules can be readily translated into that language for substantial speed gains.</P>
<P class="docText">Python loses in expressiveness to Perl<A NAME="idd1e31210"></A> for small projects and glue scripts heavily dependent on regular-expression capability. It would be overkill for tiny projects, to which shell<A NAME="idd1e31214"></A> or Tcl<A NAME="idd1e31218"></A> might be better suited.</P>
<P class="docText">Like Perl, Python has a well-established development community with a central website &lt;<A class="docLink" target="_blank" HREF="http://www.python.org/default.htm">http://www.python.org</A>&gt; carrying a great many useful Python implementations, tools and extension modules.</P>
<P class="docText">The definitive Python reference is <span class="docEmphasis">Programming Python</span> <A class="docLink" HREF="0131429019_app02.html#biblio51">[Lutz]</A>. Extensive on-line documentation on Python extensions is also available at the Python website.</P>
<P class="docText">Python programs tend to be quite portable between Unixes and even across other operating systems; the standard library is powerful enough to significantly cut the use of nonportable helper programs. Python implementations are available for Microsoft<A NAME="idd1e31240"></A> operating systems and for MacOS<A NAME="idd1e31244"></A>. Cross-platform GUI development is possible with either Tk or two other toolkits. Python/C applications can be 'frozen', quasi-compiled into pure C sources that should be portable to systems with no Python installed.</P>
<P class="docText">Summing up: Python's best side is that it encourages clean, readable code and combines accessibility with scaling up well to large projects. Its worst side is inefficiency and slowness, not just relative to compiled languages but relative to other scripting languages as well.<A NAME="idd1e31251"></A></P>
<A NAME="ch14lev3sec9"></A>
<H5 class="docSection3Title">14.4.6.1 A Small Python Case Study: <TT>imgsizer</TT></H5>
<P class="docText"><A NAME="idd1e31263"></A>Imgsizer is a utility that rewrites WWW pages so that image-inclusion tags get the right image size parameters automatically plugged in (this speeds up page loading on many browsers). You can find sources and documentation in the URL WWW tools subdirectory of the ibiblio archive &lt;<A class="docLink" target="_blank" HREF="http://www.ibiblio.org/default.htm">http://www.ibiblio.org</A>&gt;.</P>
<P class="docText"><TT>imgsizer</TT> was originally written in Perl<A NAME="idd1e31286"></A>, and was a nearly ideal example of the sort of small, pattern-driven text-processing tool at which Perl excels. It was later translated to Python to take advantage of Python's library support for HTTP fetching; this eliminated a dependency on an external page-fetching utility. Observe the use of <span class="docEmphasis">file</span>(1)<A NAME="idd1e31293"></A> and ImageMagick <span class="docEmphasis">identify</span>(1)<A NAME="idd1e31300"></A> as specialist tools for extracting the pixel sizes of images.</P>
<P class="docText">The dynamic string handling and sophisticated regular-expression matching required would have made <TT>imgsizer</TT><A NAME="idd1e31309"></A> quite painful to write in C<A NAME="idd1e31313"></A><A NAME="idd1e31318"></A> or C++<A NAME="idd1e31322"></A>; that version would also have been much larger and harder to read. Java would have solved the implicit memory-management problem, but is hardly more expressive than C or C++<A NAME="idd1e31326"></A> at text pattern matching.</P>

<A NAME="ch14lev3sec10"></A>
<H5 class="docSection3Title">14.4.6.2 A Medium-Sized Python Case Study: <span class="docEmphasis">fetchmailconf</span></H5>
<P class="docText"><A NAME="idd1e31340"></A><A NAME="idd1e31343"></A>In <A class="docLink" HREF="0131429019_ch11.html#ch11">Chapter 11</A> we examined the <span class="docEmphasis">fetchmail</span>/<span class="docEmphasis">fetchmailconf</span> pair as an example of one way to separate implementation from interface. Python's strengths are well illustrated by <span class="docEmphasis">fetchmailconf</span>.</P>
<P class="docText"><span class="docEmphasis">fetchmailconf</span> uses the Tk toolkit to implement a multi-panel GUI configuration editor (Python bindings also exist for GTK+ and other toolkits, but Tk bindings ship with every Python interpreter).</P>
<P class="docText">In expert mode, the GUI supports editing of about sixty attributes divided among three panel levels. Attribute widgets include a mix of checkboxes, radio buttons, text fields, and scrolling listboxes. Despite this complexity, the first fully-functional version of the configurator took me less than a week to design and code, counting the four days it took to learn Python and Tk.</P>
<P class="docText">Python excels at rapid prototyping of GUI interfaces, and (as <span class="docEmphasis">fetchmailconf</span> illustrates) such prototypes are often deliverable. Perl<A NAME="idd1e31376"></A> and Tcl<A NAME="idd1e31380"></A> have similar strengths in this area (including the Tk toolkit, which was written for Tcl) but are hard to control at the complexity level (approximately 1400 lines) of <span class="docEmphasis">fetchmailconf</span>. Emacs Lisp<A NAME="idd1e31387"></A> is not suited for GUI programming. Choosing Java<A NAME="idd1e31391"></A> would have increased the complexity overhead of this programming task without delivering significant benefits for this nonspeed-intensive application.</P>

<A NAME="ch14lev3sec11"></A>
<H5 class="docSection3Title">14.4.6.3 A Large Python Case Study: PIL</H5>
<P class="docText"><A NAME="idd1e31403"></A>PIL, the Python Imaging Library, supports the manipulation of bitmap graphics. It supports many popular formats, including PNG<A NAME="idd1e31413"></A>, JPEG, BMP, TIFF, PPM, XBM, and GIF. Python programs can use it to convert and transform images; supported transformations include cropping, rotation, scaling, and shearing. Pixel editing, image convolution, and color-space conversions are also supported. The PIL distribution includes Python programs that make these library facilities available from the command line. Thus PIL can be used either for batch-mode image transformation or as a strong toolkit over which to implement program-driven image processing of bitmaps.</P>
<P class="docText">The implementation of PIL illustrates the way Python can be readily augmented with loadable object-code extensions to the Python interpreter. The library core, implementing fundamental operations on bitmap objects, is written in C<A NAME="idd1e31429"></A> for speed. The upper levels and sequencing logic are in Python, slower but much easier to read and modify and extend.</P>
<P class="docText">The analogous toolkit would be difficult or impossible to write in Emacs Lisp<A NAME="idd1e31436"></A> or shell<A NAME="idd1e31440"></A>, which don't have or don't document a C extension interface at all. Tcl<A NAME="idd1e31444"></A> has a good C extension facility, but PIL would be an uncomfortably large project in Tcl. Perl<A NAME="idd1e31451"></A> has such facilities (Perl XS<A NAME="idd1e31455"></A>), but they are ad-hoc, poorly documented, complex, and unstable by comparison to Python's and use of them is rare. Java's<A NAME="idd1e31459"></A> Native Method Interface<A NAME="idd1e31463"></A> appears to provide a facility roughly comparable to Python's; PIL would probably have made a reasonable Java project.</P>
<P class="docText">The PIL code and documentation is available at the project website &lt;<A class="docLink" target="_blank" HREF="http://www.pythonware.com/products/pil/default.htm">http://www.pythonware.com/products/pil/</A>&gt;.</P>


<A NAME="ch14lev2sec7"></A>
<H4 class="docSection2Title">14.4.7 Java</H4>
<P class="docText"><A NAME="idd1e31490"></A><A NAME="idd1e31493"></A>The Java programming language was designed to be "write once, run anywhere" and to support embedding interactive programs (or <span class="docEmphasis">applets</span><A NAME="idd1e31503"></A>) in Web pages that would be runnable from any browser. Thanks to a series of technical and strategic blunders by its owner, Sun Microsystems<A NAME="idd1e31507"></A>, it has failed in both its original objectives. But it is still sufficiently strong at both systems and applications programming to be seriously challenging C<A NAME="idd1e31511"></A><A NAME="idd1e31516"></A> and C++<A NAME="idd1e31520"></A>. Java was announced in 1995.</P>
<P class="docText">Java is cleverly designed to capture the huge benefit of automatic memory management and the lesser but not insignificant benefit of supporting OO<A NAME="idd1e31527"></A> design, while being far smaller and simpler than C++<A NAME="idd1e31531"></A>. It retains a broadly C-like syntax that most programmers will find comfortable. It includes support for callouts to dynamically-loaded C and calling Java as an embedded language from C. Nor is it trivial that Sun<A NAME="idd1e31535"></A> has done an excellent job of making good Java documentation available on the Web.</P>
<P class="docText">Against Java, we can say that (compared to, say, Python<A NAME="idd1e31542"></A>) some parts of it appear over-complex and others deficient. Java's class-visibility and implicit-scoping rules are baroque. The interface facility avoids complex problems with multiple inheritance at the cost of being only slightly less difficult to understand and use in itself. Features like inner and anonymous classes can lead to very confusing code. The absence of reliable destructor methods means that it is difficult to ensure proper management of resources other than memory, such as mutexes and file locks. Significant parts of the Unix operating-system facilities are not accessible from stock Java, including signals, poll, and select. While Java's I/O facilities are very powerful, simple reading of text files is not simple.</P>
<P class="docText">There is a particularly invidious problem, resembling Windows<A NAME="idd1e31549"></A> DLL hell, with libraries. Java has no method to manage different library versions. This can create huge problems in environments like application servers, where the server might come equipped with one version of (say) an XML library, but the application ships with a different (usually newer) version. The only handle on such problems is the <TT>CLASSPATH</TT> environment variable, a source of chronic deployment problems.</P>
<P class="docText">Furthermore, Sun's handling of the Java language has been both politically and technically obtuse. Java's first GUI toolkit, AWT, was a mess that had to be essentially replaced. Withdrawing the language from ECMA/ISO standardization further nettled many developers already upset by features of the Sun Community Source License (SCSL)<A NAME="idd1e31562"></A>. Restrictions in the SCSL continue to hamper open-source implementations<A NAME="idd1e31566"></A> of Java 1.2 and their J2EE (Java 2 Enterprise Edition) specification. This compromises Java's original objective of universal portability.</P>
<P class="docText">Sadly, browser applets are dead. Microsoft's<A NAME="idd1e31573"></A> decision not to support Java 1.2 in Internet Explorer effectively killed them. However, Java seems to have found a secure niche in the computing ecology, for 'servlets' running within Web application servers. It has also become commonly used for a lot of in-house corporate programming not directly tied to databases or webservers. It has become major competition for both Microsoft's ASP/COM platform and Perl CGIs. Finally, it is in widespread and increasing use as a language for teaching introductory programming (a role for which it is extremely well suited).</P>
<P class="docText">Overall, we can fairly judge Java to be superior to C++<A NAME="idd1e31583"></A> (which is both far more complex and does less to attack the memory-management problem) for all but systems programming and the most speed-critical applications. Experience seems to show that Java programmers are somewhat less likely to fall into the trap of excessive OO<A NAME="idd1e31587"></A> layering than are C++ programmers, though this remains a significant problem.</P>
<P class="docText">How Java will fare in equilibrium with the other languages we describe here is unclear as yet, and may depend largely on project scale. We may expect its proper niche to resemble Python's<A NAME="idd1e31594"></A>. Like Python, it cannot compete with C<A NAME="idd1e31598"></A> or C++<A NAME="idd1e31602"></A> on raw execution speed, nor against Perl<A NAME="idd1e31606"></A> on small projects that use pattern-driven editing heavily. It is (more definitely than Python) overkill for small projects. We may guess that Python will have an edge in smaller projects and Java in larger ones, but the verdict of experience is not yet in.</P>
<P class="docText">The best single reference on paper is probably <span class="docEmphasis">Java In A Nutshell</span> <A class="docLink" HREF="0131429019_app02.html#biblio19">[FlanaganJava]</A>, but this is not the best tutorial introduction; that would probably be <span class="docEmphasis">Thinking in Java</span> <A class="docLink" HREF="0131429019_app02.html#biblio17">[Eckel]</A>. Trails to all the world's Java websites begin at Sun's Java site &lt;<A class="docLink" target="_blank" HREF="http://www.java.sun.com/default.htm">http://java.sun.com</A>&gt;, which also has complete HTML documentation available for download for free. The Open Directory Java Page &lt;<A class="docLink" target="_blank" HREF="http://www.dmoz.org/Computers/Programming/Languages/Java/default.htm">http://dmoz.org/Computers/Programming/Languages/Java/</A>&gt; also collects useful Java links.</P>
<P class="docText">Java implementations are available for all Unixes, for Microsoft operating systems<A NAME="idd1e31634"></A>, MacOS<A NAME="idd1e31638"></A>, and many other platforms.</P>
<P class="docText">Sources for Kaffe, an open-source Java implementation<A NAME="idd1e31645"></A> with class libraries conforming to most of JDK 1.1 and portions of JDK 1.2, are available at the Kaffe project site &lt;<A class="docLink" target="_blank" HREF="http://www.kaffe.org/default.htm">http://www.kaffe.org/</A>&gt;.</P>
<P class="docText">There is a Java front end for GCC. GCJ can compile Java code to either Java bytecode or native code, and can compile Java bytecode to native code as well. It comes packaged with open-source class libraries that implement most of JDK 1.2, and a Java bytecode interpreter called <span class="docEmphasis">gij</span>. Details are at the GCJ project page &lt;<A class="docLink" target="_blank" HREF="http://www.gcc.gnu.org/java/default.htm">http://gcc.gnu.org/java/</A>&gt;.</P>
<P class="docText">There is a Java IDE for Emacs at the JDEE project site &lt;<A class="docLink" target="_blank" HREF="http://www.jdee.sunsite.dk/default.htm">http://jdee.sunsite.dk/</A>&gt;.</P>
<P class="docText">Java portability is excellent at the language level. Incomplete library implementations (especially older JDK 1.1 versions that don't support the newer JDK 1.2) can be an issue.</P>
<P class="docText">Java's best side is that it comes close enough to achieving write-once-run-anywhere to be useful as an OS-independent environment of its own. Its worst side is that the Java 1/Java 2 split compromises that goal in deeply frustrating ways.</P>
<A NAME="ch14lev3sec12"></A>
<H5 class="docSection3Title">14.4.7.1 Case Study: FreeNet</H5>
<P class="docText"><A NAME="idd1e31686"></A><A NAME="idd1e31689"></A>Freenet is a peer-to-peer networking project that is intended to make censorship and content suppression impossible.<sup class="docFootnote"><A class="docLink" HREF="#ch14en06">[6]</A></sup> Freenet developers envision the following applications:</P><blockquote><p class="docFootnote"><sup><A NAME="ch14en06">[6]</A></sup> There is a Freenet project website &lt;<A class="docLink" target="_blank" HREF="http://www.freenetproject.org/default.htm">http://freenetproject.org</A>&gt;.</p></blockquote>
<UL><LI><P class="docList">Uncensorable dissemination of controversial information: Freenet protects freedom of speech by enabling anonymous and uncensorable publication of material ranging from grassroots alternative journalism to banned expos&eacute;s.</P></LI><LI><P class="docList">Efficient distribution of high-bandwidth content: Freenet's adaptive caching and mirroring is being used to distribute Debian Linux software updates.</P></LI><LI><P class="docList">Universal personal publishing: Freenet enables anyone to have a website, without space restrictions or compulsory advertising, even if the would-be webmaster doesn't own a computer.</P></LI></UL>
<P class="docText">Freenet addresses these goals by providing a virtual space in which to publish documents that is not tied to any specific machine. Published information and Freenet's own internal data indexes are replicated and distributed across the network in such a way that even Freenet administrators don't know at any given time where all the physical copies are located. Privacy for people browsing or submitting to Freenet is protected by strong cryptography.</P>
<P class="docText">Java was a good choice for this project for at least two reasons. First: the goals of the project put a heavy premium on having compatible implementations on the widest possible variety of machines, so Java's high portability is a dominating advantage. Second: the nature of the project is such that the network API is important, and Java has a strong one built in.</P>
<P class="docText">C is traditional for infrastructure projects of this kind that have high performance demands, but the lack of a standardized network API would have made porting a significant difficulty. C++ would have had the same difficulty. Tcl<A NAME="idd1e31732"></A>, Perl<A NAME="idd1e31736"></A>, or Python<A NAME="idd1e31740"></A> might have reduced the porting burden, but at a greater cost in performance. Emacs Lisp <A NAME="idd1e31744"></A> would have been painfully slow and totally inappropriate.</P>


<A NAME="ch14lev2sec8"></A>
<H4 class="docSection2Title">14.4.8 Emacs Lisp</H4>
<P class="docText"><A NAME="idd1e31757"></A><A NAME="idd1e31760"></A>Emacs Lisp is a scripting language<A NAME="idd1e31768"></A> used to program the behavior of the Emacs text editor. Its first public release was in 1984.</P>
<P class="docText">Emacs Lisp is not a general-purpose language in quite the same way as the others surveyed in this chapter; while it is powerful enough to theoretically be used as such, it is traditionally employed only to write control programs for the Emacs editor itself and does not communicate as fluently with other software as would a modern scripting language.</P>
<P class="docText">Nevertheless, there is a significant range of applications in which Emacs Lisp is more effective than anything else. Many of these have to do with providing a front-end for development tools such as the C compiler and linker, <span class="docEmphasis">make</span>(1), version-control systems, and symbolic debuggers; we'll discuss these in <A class="docLink" HREF="0131429019_ch15.html#ch15">Chapter 15</A>.</P>
<P class="docText">More generally, Emacs is to pattern- or syntax-directed <span class="docEmphasis">interactive</span> editing what Perl<A NAME="idd1e31791"></A> is to pattern-directed <span class="docEmphasis">batch</span> editing. Any application that involves interactively hacking a special file format or text database is an excellent candidate to be prototyped (and possibly delivered) as an Emacs mode (an Emacs Lisp program that specializes the editor's behavior).</P>
<P class="docText">Emacs Lisp is also valuable for building applications that have to be closely integrated with a text editor, or that function primarily as text browsers with some editing capability. User agents for email and Usenet<A NAME="idd1e31801"></A> news fall in this category. So do certain kinds of database front ends.</P>
<P class="docText">Emacs Lisp is a Lisp. It follows as the night the day that it manages memory automatically and is far more elegant and powerful than most conventional languages, or indeed most <span class="docEmphasis">unconventional</span> languages; it can compete with Java<A NAME="idd1e31811"></A> or Python<A NAME="idd1e31815"></A> on this level and laugh at C<A NAME="idd1e31819"></A> or C++<A NAME="idd1e31825"></A>, Perl<A NAME="idd1e31829"></A>, shell or Tcl<A NAME="idd1e31833"></A>. Lisp's perennial problem of lacking a standardized OS binding for portability<A NAME="idd1e31837"></A> is solved by the Emacs core, which in effect <span class="docEmphasis">is</span> its OS binding.</P>
<P class="docText">Lisp's other perennial problem—being a resource hog—is no longer a real issue on modern machines. Parody expansions like 'Emacs Makes A Computer Slow' and 'Eventually Munches All Computer Storage' used to be common (in fact the Emacs distribution itself includes a list of them). But many other commonly used categories of programs (such as Web browsers) have nowadays grown larger and more complex than Emacs, which has come to appear rather moderate by comparison.</P>
<P class="docText">The definitive Emacs Lisp reference is <span class="docEmphasis">The GNU Emacs Lisp Reference Manual</span><A NAME="idd1e31854"></A>, which may be browseable through your Emacs's 'info' help system. If not, it can be downloaded from the FSF FTP<A NAME="idd1e31863"></A> site &lt;<A class="docLink" target="_blank" HREF="ftp://ftp.gnu.org/pub/gnu">ftp://ftp.gnu.org/pub/gnu</A>&gt;. If you find that impenetrable, <span class="docEmphasis">Writing GNU Emacs Extensions</span> <A class="docLink" HREF="0131429019_app02.html#biblio30">[Glickstein]</A> may help.</P>
<P class="docText">Portability of Emacs Lisp programs is excellent. Emacs implementations are available for all Unixes, the Microsoft operating systems<A NAME="idd1e31879"></A>, and Mac OS<A NAME="idd1e31883"></A>.</P>
<P class="docText">Summing up: Emacs Lisp's best point is that it combines an excellent base language, Lisp<A NAME="idd1e31890"></A>, with powerful domain primitives for text manipulation. Its worst point is poor performance and difficulties using it in communication with other programs.</P>
<P class="docText">For more information, see the discussion of <span class="docEmphasis">Emacs</span> under editors in the next chapter.</P>


<a href="0131429019_18071533.html"><img src="FILES/pixel.gif" width="1" height="1" border="0"></a><ul></ul></td></tr></table>
<td></td>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<td class="tt1"><a href="NFO/lib.html">[ Team LiB ]</a></td><td valign="top" class="tt1" align="right">
          <a href="0131429019_ch14lev1sec3.html"><img src="FILES/btn_prev.gif" width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a>
          <a href="0131429019_ch14lev1sec5.html"><img src="FILES/btn_next.gif" width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a>
</td></table>
</body></html>
