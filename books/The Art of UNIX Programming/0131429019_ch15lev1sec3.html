<html><head>
<META http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<!--SafClassName="docSection1Title"--><!--SafTocEntry="15.3 Special-Purpose Code Generators"-->
<link rel="STYLESHEET" type="text/css" href="FILES/style.css">
<link rel="STYLESHEET" type="text/css" href="FILES/docsafari.css">
<style type="text/css">	.tt1    {font-size: 10pt;}</style>
</head>
<body>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<td class="tt1"><a href="NFO/lib.html">[ Team LiB ]</a></td><td valign="top" class="tt1" align="right">
	<a href="0131429019_ch15lev1sec2.html"><img src="FILES/btn_prev.gif" width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a>
	<a href="0131429019_ch15lev1sec4.html"><img src="FILES/btn_next.gif" width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a>
</td></table>
<br>
<table width="100%" border="0" cellspacing="0" cellpadding="0"><tr><td valign="top"><A NAME="ch15lev1sec3"></A>
<H3 class="docSection1Title">15.3 Special-Purpose Code Generators</H3>
<P class="docText"><A NAME="idd1e33026"></A>Unix has a long-standing tradition of hosting tools that are specifically designed to generate code for various special purposes. The venerable monuments of this tradition, which go back to Version 7 and earlier days, and were actually used to write the original Portable C Compiler back in the 1970s, are <span class="docEmphasis">lex</span>(1)<A NAME="idd1e33035"></A> and <span class="docEmphasis">yacc</span>(1)<A NAME="idd1e33042"></A> Their modern, upward-compatible successors are <span class="docEmphasis">flex</span>(1)<A NAME="idd1e33049"></A> and <span class="docEmphasis">bison</span>(1)<A NAME="idd1e33056"></A>, part of the GNU<A NAME="idd1e33060"></A> toolkit and still heavily used today. These programs have set an example that is carried forward in projects like GNOME's <span class="docEmphasis">Glade</span><A NAME="idd1e33066"></A> interface builder.</P>
<A NAME="ch15lev2sec4"></A>
<H4 class="docSection2Title">15.3.1 <span class="docEmphasis">yacc</span> and <span class="docEmphasis">lex</span></H4>
<P class="docText"><A NAME="idd1e33081"></A><A NAME="idd1e33088"></A><A NAME="idd1e33095"></A><A NAME="idd1e33098"></A><span class="docEmphasis">yacc</span> and <span class="docEmphasis">lex</span> are tools for generating language parsers. We observed in <A class="docLink" HREF="0131429019_ch08.html#ch08">Chapter 8</A> that your first minilanguage is all too likely to be an accident rather than a design. That accident is likely to have a hand-coded parser that costs you far too much maintenance and debugging time—especially if you have not realized it is a parser, and have thus failed to properly separate it from the remainder of your application code. Parser generators are tools for doing better than an accidental, ad-hoc implementation; they don't just let you express your grammar specification at a higher level, they also wall off all the parser's implementation complexity from the rest of your code.</P>
<P class="docText">If you reach a point where you are planning to implement a minilanguage from scratch, rather than by extending or embedding an existing scripting language<A NAME="idd1e33114"></A> or parsing XML, <span class="docEmphasis">yacc</span> and <span class="docEmphasis">lex</span> will probably be your most important tools after your C<A NAME="idd1e33124"></A> compiler.</P>
<P class="docText"><span class="docEmphasis">lex</span> and <span class="docEmphasis">yacc</span> each generate code for a single function—respectively, "get a token from the input stream" and "parse a sequence of tokens to see if it matches a grammar". Usually, the <span class="docEmphasis">yacc</span>-generated parser function calls a Lex-generated tokenizer function each time it wants to get another token. If there are no user-written C callbacks at all in the <span class="docEmphasis">yacc</span>-generated parser, all it will do is a syntax check; the value returned will tell the caller if the input matched the grammar it was expecting.</P>
<P class="docText">More usually, the user's C code, embedded in the generated parser, populates some runtime data structures as a side-effect of parsing the input. If the minilanguage is declarative, your application can use these runtime data structures directly. If your design was an imperative minilanguage, the data structures might include a parse tree which is immediately fed to some kind of evaluation function.</P>
<P class="docText"><span class="docEmphasis">yacc</span> has a rather ugly interface, through exported global variables with the name prefix <TT>yy_</TT>. This is because it predates structs in C; in fact, <span class="docEmphasis">yacc</span> predates C itself; the first implementation was written in C's predecessor B. The crude though effective algorithm <span class="docEmphasis">yacc</span>-generated parsers use to try to recover from parse errors (pop tokens until an explicit error production is matched) can also lead to problems, including memory leaks.</P>
<blockquote>

<p class="docText"><A NAME="idd1e33166"></A>If you are building parse trees, using malloc to make nodes, and you start popping things off the stack in error recovery, you don't get to recover (free) the storage. In general, Yacc can't do it, since it doesn't know enough about what's on the stack. If the yacc parser were in C++<A NAME="idd1e33170"></A>, it could assume that the values were classes and "destruct" them. In "real" compilers, parse tree nodes are generated using an arena-based allocator, so the nodes don't leak, but there is a logical leak anyway that needs to be thought about to make industrial-strength error recovery.</p>
<p class="docText">—Steve Johnson</p></blockquote>
<P class="docText"><span class="docEmphasis">lex</span> is a lexical analyzer generator. It's a member of the same functional family as <span class="docEmphasis">grep</span>(1)<A NAME="idd1e33183"></A> and <span class="docEmphasis">awk</span>(1)<A NAME="idd1e33190"></A>, but more powerful because it enables you to arrange for arbitrary C code to be executed on each match. It accepts a declarative minilanguage and emits skeleton C code.</P>
<P class="docText">A crude but useful way to think about what a <span class="docEmphasis">lex</span>-generated tokenizer does is as a sort of inverse <span class="docEmphasis">grep</span>(1). Where <span class="docEmphasis">grep</span>(1) takes a single regular expression and returns a list of matches in the incoming data stream, each call to a <span class="docEmphasis">lex</span>-generated tokenizer takes a list of regular expressions and indicates which expression occurs next in the datastream.</P>
<blockquote>

<p class="docText"><A NAME="idd1e33216"></A>Splitting input analysis into tokenizing input and parsing the token stream is a useful tactic even if you're not using Yacc and Lex and your "tokens" are nothing like the usual ones in a compiler. More than once I've found that splitting input handling into two levels made the code much simpler and easier to understand, despite the complexity added by the split itself.</p>
<p class="docText">—Henry Spencer</p></blockquote>
<P class="docText"><span class="docEmphasis">lex</span> was written to automate the task of generating lexical analyzers (tokenizers) for compilers. It turned out to have a surprisingly wide range of uses for other kinds of pattern recognition, and has since been described as "the Swiss-army knife of Unix programming".<sup class="docFootnote"><A class="docLink" HREF="#ch15en01">[1]</A></sup></P><blockquote><p class="docFootnote"><sup><A NAME="ch15en01">[1]</A></sup> The common latter-day description of Perl as a "Swiss-army chainsaw" is derivative.</p></blockquote>
<P class="docText">If you are attacking any kind of pattern-recognition or state-machine problem in which all the possible input stimuli will fit in a byte, <span class="docEmphasis">lex</span> may enable you to generate code that will be more efficient and reliable than a hand-crafted state machine.</P>
<blockquote>

<p class="docText"><A NAME="idd1e33242"></A>John Jarvis at Holmdel [an AT&amp;T laboratory] used <span class="docEmphasis">lex</span> to find faults in circuit boards, by scanning the board, using a chain-encoding technique to represent the edges of areas on the board, and then using Lex to define patterns that would catch common fabrication errors.</p>
<p class="docText">—Mike Lesk</p></blockquote>
<P class="docText">Most importantly, the <span class="docEmphasis">lex</span> specification minilanguage is much higher-level and more compact<A NAME="idd1e33256"></A> than equivalent handcrafted C. Modules are available to use <span class="docEmphasis">flex</span><A NAME="idd1e33262"></A>, the open-source version<A NAME="idd1e33266"></A>, with Perl<A NAME="idd1e33270"></A> (find them with a Web search for "lex perl"), and a work-alike implementation is part of <span class="docEmphasis">PLY</span><A NAME="idd1e33276"></A> in Python<A NAME="idd1e33280"></A>.</P>
<P class="docText"><span class="docEmphasis">lex</span> generates parsers that are up to an order of magnitude slower than hand-coded parsers. This is not a good reason to hand-code, however; it's an argument for prototyping with <span class="docEmphasis">lex</span> and hand-hacking only if prototyping reveals an actual bottleneck.</P>
<P class="docText"><span class="docEmphasis">yacc</span> is a parser generator. It, too, was written to automate part of the job of writing compilers. It takes as input a grammar specification in a declarative minilanguage resembling BNF (Backus-Naur Form)<A NAME="idd1e33297"></A> with C code associated with each element of the grammar. It generates code for a parser function that, when called, accepts text matching the grammar from an input stream. As each grammar element is recognized, the parser function runs the associated C code.</P>
<P class="docText">The combination of <span class="docEmphasis">lex</span> and <span class="docEmphasis">yacc</span> is very effective for writing language interpreters of all kinds. Though most Unix programmers never get to do the kind of general-purpose compiler-building that these tools were meant to assist, they're extremely useful for writing parsers for run-control file syntaxes and domain-specific minilanguages.</P>
<P class="docText"><span class="docEmphasis">lex</span>-generated tokenizers are very fast at recognizing low-level patterns in input streams, but the regular-expression minilanguage that <span class="docEmphasis">lex</span> knows is not good at counting things, or recognizing recursively nested structures. For parsing those, you want <span class="docEmphasis">yacc</span>. On the other hand, while you theoretically could write a <span class="docEmphasis">yacc</span> grammar to do its own token-gathering, the grammar to specify that would be hugely bloated and the parser extremely slow. For tokenizing input, you want <span class="docEmphasis">lex</span>. Thus, these tools are symbiotic.</P>
<P class="docText">If you can implement your parser in a higher-level language than C (which we recommend you do; see <A class="docLink" HREF="0131429019_ch14.html#ch14">Chapter 14</A> for discussion), then look for equivalent facilities like Python's PLY (which covers both <span class="docEmphasis">lex</span> and <span class="docEmphasis">yacc</span>)<sup class="docFootnote"><A class="docLink" HREF="#ch15en02">[2]</A></sup> or Perl's<A NAME="idd1e33347"></A> PY and Parse::Yapp modules, or Java's<A NAME="idd1e33351"></A> CUP<A NAME="idd1e33355"></A>,<sup class="docFootnote"><A class="docLink" HREF="#ch15en03">[3]</A></sup> Jack<A NAME="idd1e33366"></A>,<sup class="docFootnote"><A class="docLink" HREF="#ch15en04">[4]</A></sup> or Yacc/M<A NAME="idd1e33377"></A><sup class="docFootnote"><A class="docLink" HREF="#ch15en05">[5]</A></sup> packages.</P><blockquote><p class="docFootnote"><sup><A NAME="ch15en02">[2]</A></sup> PLY is downloadable &lt;<A class="docLink" target="_blank" HREF="http://www.systems.cs.uchicago.edu/ply/default.htm">http://systems.cs.uchicago.edu/ply/</A>&gt;.</p></blockquote><blockquote><p class="docFootnote"><sup><A NAME="ch15en03">[3]</A></sup> CUP is downloadable &lt;<A class="docLink" target="_blank" HREF="http://www.cs.princeton.edu/~appel/modern/java/CUP/default.htm">http://www.cs.princeton.edu/~appel/modern/java/CUP/</A>&gt;.</p></blockquote><blockquote><p class="docFootnote"><sup><A NAME="ch15en04">[4]</A></sup> Jack is downloadable &lt;<A class="docLink" target="_blank" HREF="http://www.javaworld.com/javaworld/jw-12-1996/jw-12-jack.html">http://www.javaworld.com/javaworld/jw-12-1996/jw-12-jack.html</A>&gt;.</p></blockquote><blockquote><p class="docFootnote"><sup><A NAME="ch15en05">[5]</A></sup> Yacc/M is downloadable &lt;<A class="docLink" target="_blank" HREF="http://www.david.tribble.com/yaccm.html">http://david.tribble.com/yaccm.html</A>&gt;.</p></blockquote>
<P class="docText">As with macro processors, one of the problems with code generators and preprocessors is that compile-time errors in the generated code may carry line numbers that are relative to the generated code (which you don't want to edit) rather than the generator input (which is where you need to make corrections). <span class="docEmphasis">yacc</span> and <span class="docEmphasis">lex</span> address this by generating the same <TT>#line</TT> constructs that the C<A NAME="idd1e33399"></A> preprocessor does; these set the current line number for error reporting so the numbers will come out right. Any program that generates C<A NAME="idd1e33405"></A> or C++<A NAME="idd1e33411"></A> should do likewise.</P>
<P class="docText">More generally, well-designed procedural-code generators should never require the user to hand-alter or even look at the generated parts. Getting those right is the code generator's job.</P>
<A NAME="ch15lev3sec1"></A>
<H5 class="docSection3Title">15.3.1.1 Case Study: The <TT>fetchmailrc</TT> Grammar</H5>
<P class="docText"><A NAME="idd1e33428"></A>The canonical demonstration example that seems to have appeared in every <span class="docEmphasis">lex</span><A NAME="idd1e33438"></A><A NAME="idd1e33445"></A> and <span class="docEmphasis">yacc</span><A NAME="idd1e33451"></A><A NAME="idd1e33458"></A> tutorial ever written is a toy interactive calculator program that parses and evaluates arithmetic expressions entered by the user. We will spare you yet another repetition of this cliche; if you are interested, consult the source code of the <span class="docEmphasis">bc</span>(1)<A NAME="idd1e33465"></A> and <span class="docEmphasis">dc</span>(1)<A NAME="idd1e33472"></A> calculator implementations from the GNU project<A NAME="idd1e33476"></A>, or the paradigm example 'hoc'<sup class="docFootnote"><A class="docLink" HREF="#ch15en06">[6]</A></sup> from [Kernighan-Pike84].</P><blockquote><p class="docFootnote"><sup><A NAME="ch15en06">[6]</A></sup> &lt;<A class="docLink" target="_blank" HREF="http://www.cm.bell-labs.com/cm/cs/upe/default.htm">http://cm.bell-labs.com/cm/cs/upe/</A>&gt;</p></blockquote>
<P class="docText">Instead, the grammar of <span class="docEmphasis">fetchmail</span>'s<A NAME="idd1e33493"></A><A NAME="idd1e33496"></A> run-control-file parser provides a good medium-sized case study in <span class="docEmphasis">lex</span> and <span class="docEmphasis">yacc</span> usage. There are a couple of points of interest here.</P>
<P class="docText">The <span class="docEmphasis">lex</span> specification, in <TT>rcfile_l.l</TT>, is a very typical implementation of a shell-like syntax. Note how two complementary rules support either single or double-quoted strings; this is a good idea in general. The rules for accepting (possibly signed) integer literals and discarding comments are also pretty generic.</P>
<P class="docText">The <span class="docEmphasis">yacc</span> specification, in <TT>rcfile_y.y</TT>, is long but straightforward. It does not perform any <span class="docEmphasis">fetchmail</span> actions, just sets bits in a list of internal control blocks. After startup, <span class="docEmphasis">fetchmail</span>'s normal mode of operation is just to repeatedly walk that list, using each record to drive a retrieval session with a remote site.</P>


<A NAME="ch15lev2sec5"></A>
<H4 class="docSection2Title">15.3.2 Case Study: <span class="docEmphasis">Glade</span></H4>
<P class="docText"><A NAME="idd1e33543"></A><A NAME="idd1e33550"></A>We looked at <span class="docEmphasis">Glade</span> in <A class="docLink" HREF="0131429019_ch08.html#ch08">Chapter 8</A> as a good example of a declarative minilanguage. We also noted that its back end produces a result by generating code in any one of several languages.</P>
<P class="docText"><span class="docEmphasis">Glade</span> is a good modern example of an application-code generator. What makes it Unixy in spirit are the following features, which most GUI builders (especially most proprietary GUI builders) don't have:</P>
<UL><LI><P class="docList">Rather than being glued together as one monster monolith, the <span class="docEmphasis">Glade</span> GUI and <span class="docEmphasis">Glade</span> code generator obey the Rule of Separation (following the "separated engine and interface" design pattern).</P></LI><LI><P class="docList">The GUI and code generator are connected by an (XML-based) textual data file format that can be read and modified by other tools.</P></LI><LI><P class="docList">Multiple target languages (as opposed to just C<A NAME="idd1e33586"></A> or C++<A NAME="idd1e33592"></A>) are supported. More could easily be added.</P></LI></UL>
<P class="docText">The design implies that it should also be possible to replace the <span class="docEmphasis">Glade</span> GUI editor component, should that ever become desirable.</P>


<ul></ul></td></tr></table>
<td></td>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<td class="tt1"><a href="NFO/lib.html">[ Team LiB ]</a></td><td valign="top" class="tt1" align="right">
          <a href="0131429019_ch15lev1sec2.html"><img src="FILES/btn_prev.gif" width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a>
          <a href="0131429019_ch15lev1sec4.html"><img src="FILES/btn_next.gif" width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a>
</td></table>
</body></html>
