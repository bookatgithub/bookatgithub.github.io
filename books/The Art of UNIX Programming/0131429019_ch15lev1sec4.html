<html><head>
<META http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<!--SafClassName="docSection1Title"--><!--SafTocEntry="15.4 'make': Automating Your Recipes"-->
<link rel="STYLESHEET" type="text/css" href="FILES/style.css">
<link rel="STYLESHEET" type="text/css" href="FILES/docsafari.css">
<style type="text/css">	.tt1    {font-size: 10pt;}</style>
</head>
<body>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<td class="tt1"><a href="NFO/lib.html">[ Team LiB ]</a></td><td valign="top" class="tt1" align="right">
	<a href="0131429019_ch15lev1sec3.html"><img src="FILES/btn_prev.gif" width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a>
	<a href="0131429019_ch15lev1sec5.html"><img src="FILES/btn_next.gif" width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a>
</td></table>
<br>
<table width="100%" border="0" cellspacing="0" cellpadding="0"><tr><td valign="top"><A NAME="ch15lev1sec4"></A>
<H3 class="docSection1Title" id="162666-851">15.4 <span class="docEmphasis">make</span>: Automating Your Recipes</H3>
<P class="docText"><A NAME="idd1e33614"></A><A NAME="idd1e33617"></A>Program sources by themselves don't make an application. The way you put them together and package them for distribution matters, too. Unix provides a tool for semi-automating these processes; <span class="docEmphasis">make</span>(1). <span class="docEmphasis">Make</span> is covered in most introductory Unix books. For a really thorough reference, you can consult <span class="docEmphasis">Managing Projects with Make</span> [Oram-Talbot]. If you're using <span class="docEmphasis">GNU make</span> (the most advanced make, and the one normally shipped with open-source Unixes<A NAME="idd1e33635"></A>) the treatment in <span class="docEmphasis">Programming with GNU Software</span> [Loukides-Oram] may be better in some respects. Most Unixes that carry <span class="docEmphasis">GNU make</span> will also support GNU Emacs; if yours does you will probably find a complete make manual on-line through Emacs's <span class="docEmphasis">info</span> documentation system.</P>
<P class="docText">Ports of <span class="docEmphasis">GNU make</span> to DOS and Windows are available from the FSF<A NAME="idd1e33656"></A>.</P>
<A NAME="ch15lev2sec6"></A>
<H4 class="docSection2Title">15.4.1 Basic Theory of <span class="docEmphasis">make</span></H4>
<P class="docText"><A NAME="idd1e33669"></A><A NAME="idd1e33674"></A>If you're developing in C<A NAME="idd1e33682"></A> or C++<A NAME="idd1e33686"></A>, an important part of the recipe for building your application will be the collection of compilation and linkage commands needed to get from your sources to working binaries. Entering these commands is a lot of tedious detail work, and most modern development environments include a way to put them in command files or databases that can automatically be re-executed to build your application.</P>
<P class="docText">Unix's <span class="docEmphasis">make</span>(1) program, the original of all these facilities, was designed specifically to help C programmers manage these recipes. It lets you write down the dependencies between files in a project in one or more 'makefiles'. Each makefile consists of a series of <span class="docEmphasis">productions</span>; each one tells <span class="docEmphasis">make</span> that some given target file depends on some set of source files, and says what to do if any of the sources are newer than the target. You don't actually have to write down all dependencies, as the <span class="docEmphasis">make</span> program can deduce a lot of the obvious ones from filenames and extensions.</P>
<P class="docText">For example: You might put in a makefile that the binary <TT>myprog</TT> depends on three object files <TT>myprog.o</TT>, <TT>helper.o</TT>, and <TT>stuff.o</TT>. If you have source files <TT>myprog.c</TT>, <TT>helper.c</TT>, and <TT>stuff.c</TT>, <span class="docEmphasis">make</span> will know without being told that each <TT>.o</TT> file depends on the corresponding <TT>.c</TT> file, and supply its own standard recipe for building a <TT>.o</TT> file from a <TT>.c</TT> file.</P>
<blockquote>

<p class="docText"><A NAME="idd1e33751"></A>Make originated with a visit from Steve Johnson (author of <span class="docEmphasis">yacc</span>, etc.), storming into my office, cursing the Fates that had caused him to waste a morning debugging a correct program (bug had been fixed, file hadn't been compiled, <span class="docEmphStrong"><TT>cc *.o</TT></span> was therefore unaffected). As I had spent a part of the previous evening coping with the same disaster on a project I was working on, the idea of a tool to solve it came up. It began with an elaborate idea of a dependency analyzer, boiled down to something much simpler, and turned into Make that weekend. Use of tools that were still wet was part of the culture. Makefiles were text files, not magically encoded binaries, because that was the Unix ethos: printable, debuggable, understandable stuff.</p>
<p class="docText">—Stuart Feldman</p></blockquote>
<P class="docText">When you run <span class="docEmphStrong"><TT>make</TT></span> in a project directory, the <span class="docEmphasis">make</span> program looks at all productions and timestamps and does the minimum amount of work necessary to make sure derived files are up to date.</P>
<P class="docText">You can read a good example of a moderately complex makefile in the sources for <span class="docEmphasis">fetchmail</span><A NAME="idd1e33778"></A>. In the subsections below we'll refer to it again.</P>
<P class="docText">Very complex makefiles, especially when they call subsidiary makefiles, can become a source of complications rather than simplifying the build process. A now-classic warning is issued in <span class="docEmphasis">Recursive Make Considered Harmful</span>.<sup class="docFootnote"><A class="docLink" HREF="#ch15en07">[7]</A></sup> The argument in this paper has become widely accepted since it was written in 1997, and has come near to reversing previous community practice.</P><blockquote><p class="docFootnote"><sup><A NAME="ch15en07">[7]</A></sup> Available on the Web &lt;<A class="docLink" target="_blank" HREF="http://www.tip.net.au/~millerp/rmch/recu-make-cons-harm.html">http://www.tip.net.au/~millerp/rmch/recu-make-cons-harm.html</A>&gt;.</p></blockquote>
<P class="docText">No discussion of <span class="docEmphasis">make</span>(1) would be complete without an acknowledgement that it includes one of the worst design botches in the history of Unix. The use of tab characters as a required leader for command lines associated with a production means that the interpretation of a makefile can change drastically on the basis of invisible differences in whitespace.</P>
<blockquote>

<p class="docText"><A NAME="idd1e33808"></A>Why the tab in column 1? Yacc was new, Lex was brand new. I hadn't tried either, so I figured this would be a good excuse to learn. After getting myself snarled up with my first stab at Lex, I just did something simple with the pattern newline-tab. It worked, it stayed. And then a few weeks later I had a user population of about a dozen, most of them friends, and I didn't want to screw up my embedded base. The rest, sadly, is history.</p>
<p class="docText">—Stuart Feldman</p></blockquote>

<A NAME="ch15lev2sec7"></A>
<H4 class="docSection2Title">15.4.2 <span class="docEmphasis">make</span> in Non-C/C++ Development</H4>
<P class="docText"><A NAME="idd1e33823"></A><A NAME="idd1e33828"></A><span class="docEmphasis">make</span> is not just useful for C/C++ recipes, however. Scripting languages<A NAME="idd1e33838"></A> like those we described in <A class="docLink" HREF="0131429019_ch14.html#ch14">Chapter 14</A> may not require conventional compilation and link steps, but there are often other kinds of dependencies that <span class="docEmphasis">make</span>(1) can help you with.</P>
<P class="docText">Suppose, for example, that you actually generate part of your code from a specification file, using one of the techniques from <A class="docLink" HREF="0131429019_ch09.html#ch09">Chapter 9</A>. You can use <span class="docEmphasis">make</span> to tie the spec file and the generated source together. This will ensure that whenever you change the spec and remake, the generated code will automatically be rebuilt.</P>
<P class="docText">It's quite common to use makefile productions to express recipes for making documentation as well as code. You'll often see this approach used to automatically generate PostScript or other derived documentation from masters written in some markup language (like HTML or one of the Unix document-macro languages we'll survey in <A class="docLink" HREF="0131429019_ch18.html#ch18">Chapter 18</A>). In fact, this sort of use is so common that it's worth illustrating with a case study.</P>
<A NAME="ch15lev3sec2"></A>
<H5 class="docSection3Title">15.4.2.1 Case Study: <span class="docEmphasis">make</span> for Document-File Translation</H5>
<P class="docText"><A NAME="idd1e33876"></A><A NAME="idd1e33881"></A>In the fetchmail<A NAME="idd1e33889"></A> makefile, for example, you'll see three productions that relate files named <TT>FAQ</TT>, <TT>FEATURES</TT>, and <TT>NOTES</TT> to HTML sources <TT>fetchmail-FAQ.html</TT>, <TT>fetchmail-features.html</TT>, and <TT>design-notes.html</TT>.</P>
<P class="docText">The HTML files are meant to be accessible on the fetchmail Web page, but all the HTML markup makes them uncomfortable to look at unless you're using a browser. So the <TT>FAQ</TT>, <TT>FEATURES</TT>, and <TT>NOTES</TT> are flat-text files meant to be flipped through quickly with an editor or pager program by someone reading the <span class="docEmphasis">fetchmail</span> sources themselves (or, perhaps, distributed to FTP sites that don't support Web access).</P>
<P class="docText">The flat-text forms can be made from their HTML masters by using the common open-source program<A NAME="idd1e33932"></A> <span class="docEmphasis">lynx</span>(1)<A NAME="idd1e33939"></A>. <span class="docEmphasis">lynx</span> is a Web browser for text-only displays; but when invoked with the <TT>-dump</TT> option it functions reasonably well as an HTML-to-ASCII formatter.</P>
<P class="docText">With the productions in place, the developer can edit the HTML masters without having to remember to manually rebuild the flat-text forms afterwards, secure in the knowledge that <TT>FAQ</TT>, <TT>FEATURES</TT>, and <TT>NOTES</TT> will be properly rebuilt whenever they are needed.</P>


<A NAME="ch15lev2sec8"></A>
<H4 class="docSection2Title">15.4.3 Utility Productions</H4>
<P class="docText"><A NAME="idd1e33970"></A><A NAME="idd1e33973"></A><A NAME="idd1e33978"></A>Some of the most heavily used productions in typical makefiles don't express file dependencies at all. They're ways to bundle up little procedures that a developer wants to mechanize, like making a distribution package or removing all object files in order to do a build from scratch.</P>
<blockquote>

<p class="docText"><A NAME="idd1e33993"></A>Nonfile productions were intentional and in there from day one. 'Make all' and 'clean' were my own conventions from earliest days. One of the older Unix jokes is "Make love" which results in "Don't know how to make love".</p>
<p class="docText">—Stuart Feldman</p></blockquote>
<P class="docText">There is a well-developed set of conventions about what utility productions should be present and how they should be named. Following these will make your makefile much easier to understand and use.</P>
<P class="docText"><span class="docEmphBoldItalic">all</span></P>
<BLOCKQUOTE><P><P class="docList">Your <span class="docEmphasis">all</span> production should make every executable of your project. Usually the <span class="docEmphasis">all</span> production doesn't have an explicit rule; instead it refers to all of your project's top-level targets (and, not accidentally, documents what those are). Conventionally, this should be the first production in your makefile, so it will be the one executed when the developer types <span class="docEmphStrong"><TT>make</TT></span> with no argument.</P></P></BLOCKQUOTE>
<P class="docText"><span class="docEmphBoldItalic">test</span></P>
<BLOCKQUOTE><P><P class="docList">Run the program's automated test suite, typically consisting of a set of unit tests<sup class="docFootnote"><A class="docLink" HREF="#ch15en08">[8]</A></sup> to find regressions, bugs, or other deviations from expected behavior during the development process. The 'test' production can also be used by end-users of the software to ensure that their installation is functioning correctly.</P><blockquote><p class="docFootnote"><sup><A NAME="ch15en08">[8]</A></sup> A unit test is test code attached to a module to verify correct performance. Use of the term 'unit test' suggests that the test is written concurrently with the code by the developer of the code, and implies a discipline in which module releases aren't considered complete until they have attached test code. The term and the concept originated in the "Extreme Programming" methodology popularized by Kent Beck<A NAME="idd1e34033"></A>, but has gained wide acceptance among Unix programmers since about 2001.</p></blockquote></P></BLOCKQUOTE>
<P class="docText"><span class="docEmphBoldItalic">clean</span></P>
<BLOCKQUOTE><P><P class="docList">Remove all files (such as binary executables and object files) that are normally created when you <span class="docEmphStrong"><TT>make all</TT></span>. A <span class="docEmphStrong"><TT>make clean</TT></span> should reset the process of building the software to a good initial state.</P></P></BLOCKQUOTE>
<P class="docText"><span class="docEmphBoldItalic">dist</span></P>
<BLOCKQUOTE><P><P class="docList">Make a source archive (usually with the <span class="docEmphasis">tar</span>(1) program) that can be shipped as a unit and used to rebuild the program on another machine. This target should do the equivalent of depending on <span class="docEmphStrong"><TT>all</TT></span> so that a <span class="docEmphStrong"><TT>make dist</TT></span> automatically rebuilds the whole project before making the distribution archive—this is a good way to avoid last-minute embarrassments, like not shipping derived files that are actually needed (like the flat-text <TT>README</TT> in <span class="docEmphasis">fetchmail</span>, which is actually generated from an HTML source).</P></P></BLOCKQUOTE>
<P class="docText"><span class="docEmphBoldItalic">distclean</span></P>
<BLOCKQUOTE><P><P class="docList">Throw away everything but what you would include if you were bundling up the source with <span class="docEmphStrong"><TT>make dist</TT></span>. This may be the the same as <span class="docEmphStrong"><TT>make clean</TT></span> but should be included as a production of its own anyway, to document what's going on. When it's different, it usually differs by throwing away local configuration files that aren't part of the normal <span class="docEmphStrong"><TT>make all</TT></span> build sequence (such as those generated by <span class="docEmphasis">autoconf</span>(1); we'll talk about <span class="docEmphasis">autoconf</span>(1) in <A class="docLink" HREF="0131429019_ch17.html#ch17">Chapter 17</A>).</P></P></BLOCKQUOTE>
<P class="docText"><span class="docEmphBoldItalic">realclean</span></P>
<BLOCKQUOTE><P><P class="docList">Throw away everything you can rebuild using the makefile. This may be the same as <span class="docEmphStrong"><TT>make distclean</TT></span>, but should be included as a production of its own anyway, to document what's going on. When it's different, it usually differs by throwing away files that are derived but (for whatever reason) shipped with the project sources anyway.</P></P></BLOCKQUOTE>
<P class="docText"><span class="docEmphBoldItalic">install</span></P>
<BLOCKQUOTE><P><P class="docList">Install the project's executables and documentation in system directories so they will be accessible to general users (this typically requires root privileges). Initialize or update any databases or libraries that the executables require in order to function.</P></P></BLOCKQUOTE>
<P class="docText"><span class="docEmphBoldItalic">uninstall</span></P>
<BLOCKQUOTE><P><P class="docList">Remove files installed in system directories by <span class="docEmphStrong"><TT>make install</TT></span> (this typically requires root privileges). This should completely and perfectly reverse a <span class="docEmphStrong"><TT>make install</TT></span>. The presence of an uninstall production implies a kind of humility that experienced Unix hands look for as a sign of thoughtful design; conversely, not having an uninstall production is at best careless, and (when, for example, an installation creates large database files) can be quite rude and thoughtless.</P></P></BLOCKQUOTE>
<P class="docText">Working examples of all the standard targets are available for inspection in the <span class="docEmphasis">fetchmail</span><A NAME="idd1e34163"></A> makefile. By studying all of them together you will see a pattern emerge, and (not incidentally) learn much about the <span class="docEmphasis">fetchmail</span> package's structure. One of the benefits of using these standard productions is that they form an implicit roadmap of their project.</P>
<P class="docText">But you need not limit yourself to these utility productions. Once you master <span class="docEmphasis">make</span>, you'll find yourself more and more often using the makefile machinery to automate little tasks that depend on your project file state. Your makefile is a convenient central place to put these; using it makes them readily available for inspection and avoids cluttering up your workspace with trivial little scripts.</P>

<A NAME="ch15lev2sec9"></A>
<H4 class="docSection2Title">15.4.4 Generating Makefiles</H4>
<P class="docText"><A NAME="idd1e34184"></A><A NAME="idd1e34187"></A><A NAME="idd1e34192"></A>One of the subtle advantages of Unix <span class="docEmphasis">make</span> over the dependency databases built into many IDEs is that makefiles are simple text files—files that can be generated by programs.</P>
<P class="docText">In the mid-1980s it was fairly common for large Unix program distributions to include elaborate custom shellscripts that would probe their environment and use the information they gathered to construct custom makefiles. These custom configurators reached absurd sizes. I wrote one once that was 3000 lines of shell, about twice as large as any single module in the program it was configuring—and this was not unusual.</P>
<P class="docText">The community eventually said "Enough!" and various people set out to write tools that would automate away part or all of the process of maintaining makefiles. These tools generally tried to address two issues:</P>
<P class="docText">One issue is <span class="docEmphasis">portability</span><A NAME="idd1e34217"></A>. Makefile generators are commonly built to run on many different hardware platforms and Unix variants. They generally try to deduce things about the local system (including everything from machine word size up to which tools, languages, service libraries, and even document formatters it has available). They then try to use those deductions to write makefiles that exploit the local system's facilities and compensate for its quirks.</P>
<P class="docText">The other issue is <span class="docEmphasis">dependency derivation</span><A NAME="idd1e34226"></A>. It's possible to deduce a great deal about the dependencies of a collection of C sources by analyzing the sources themselves (especially by looking at what include files they use and share). Many makefile generators do this in order to mechanically generate <span class="docEmphasis">make</span> dependencies.</P>
<P class="docText">Each different makefile generator tackles these objectives in a slightly different way. Probably a dozen or more generators have been attempted, but most proved inadequate or too difficult to drive or both, and only a few are still in live use. We'll survey the major ones here. All are available as open-source software<A NAME="idd1e34236"></A> on the Internet.</P>
<A NAME="ch15lev3sec3"></A>
<H5 class="docSection3Title">15.4.4.1 <span class="docEmphasis">makedepend</span></H5>
<P class="docText"><A NAME="idd1e34248"></A><A NAME="idd1e34251"></A><A NAME="idd1e34258"></A>Several small tools have tackled the rule automation part of the problem exclusively. This one, distributed along with the X windowing system from MIT<A NAME="idd1e34266"></A>, is the fastest and most useful and comes preinstalled under all modern Unixes, including all Linuxes<A NAME="idd1e34270"></A>.</P>
<P class="docText"><span class="docEmphasis">makedepend</span> takes a collection of C<A NAME="idd1e34279"></A> sources and generates dependencies for the corresponding <TT>.o</TT> files from their <TT>#include</TT> directives. These can be appended directly to a makefile, and in fact makedepend is defined to do exactly that.</P>
<P class="docText"><span class="docEmphasis">makedepend</span> is useless for anything but C projects. It doesn't try to solve more than one piece of the makefile-generation problem. But what it does it does quite well.</P>
<P class="docText"><span class="docEmphasis">makedepend</span> is sufficiently documented by its manual page. If you type <span class="docEmphStrong"><TT>man makedepend</TT></span> at a terminal window you will quickly learn what you need to know about invoking it.</P>

<A NAME="ch15lev3sec4"></A>
<H5 class="docSection3Title">15.4.4.2 <span class="docEmphasis">Imake</span></H5>
<P class="docText"><A NAME="idd1e34312"></A><A NAME="idd1e34315"></A><A NAME="idd1e34322"></A><span class="docEmphasis">Imake</span> was written in an attempt to mechanize makefile generation for the X window system<A NAME="idd1e34332"></A>. It builds on <span class="docEmphasis">makedepend</span> to tackle both the dependency-derivation and portability problems.</P>
<P class="docText"><span class="docEmphasis">Imake</span> system effectively replaces conventional makefiles with Imakefiles. These are written in a more compact and powerful notation which is (effectively) compiled into makefiles. The compilation uses a rules file which is system-specific and includes a lot of information about the local environment.</P>
<P class="docText"><span class="docEmphasis">Imake</span> is well suited to X's particular portability and configuration challenges and universally used in projects that are part of the X distribution. However, it has not achieved much popularity outside the X developer community. It's hard to learn, hard to use, hard to extend, and produces generated makefiles of mind-numbing size and complexity.</P>
<P class="docText">The <span class="docEmphasis">Imake</span> tools will be available on any Unix that supports X, including Linux<A NAME="idd1e34355"></A>. There has been one heroic effort <A class="docLink" HREF="0131429019_app02.html#biblio16">[DuBois]</A> to make the mysteries of <span class="docEmphasis">Imake</span> comprehensible to non-X-programming mortals. These are worth learning if you are going to do X programming.</P>

<A NAME="ch15lev3sec5"></A>
<H5 class="docSection3Title">15.4.4.3 <span class="docEmphasis">autoconf</span></H5>
<P class="docText"><A NAME="idd1e34374"></A><A NAME="idd1e34381"></A><A NAME="idd1e34388"></A><span class="docEmphasis">autoconf</span> was written by people who had seen and rejected the <span class="docEmphasis">Imake</span> approach. It generates per-project <TT>configure</TT> shellscripts that are like the old-fashioned custom script configurators. These <TT>configure</TT> scripts can generate makefiles (among other things).</P>
<P class="docText"><span class="docEmphasis">Autoconf</span> is focused on portability and does no built-in dependency derivation at all. Although it is probably as complex as <span class="docEmphasis">Imake</span>, it is much more flexible and easier to extend. Rather than relying on a per-system database of rules, it generates <TT>configure</TT> shell code that goes out and searches your system for things.</P>
<P class="docText">Each <TT>configure</TT> shellscript is built from a per-project template that you have to write, called <TT>configure.in</TT>. Once generated, though, the <TT>configure</TT> script will be self-contained and can configure your project on systems that don't carry <span class="docEmphasis">autoconf</span>(1) itself.</P>
<P class="docText">The <span class="docEmphasis">autoconf</span> approach to makefile generation is like imake's in that you start by writing a makefile template for your project. But <span class="docEmphasis">autoconf</span>'s <TT>Makefile.in</TT> files are basically just makefiles with placeholders in them for simple text substitution; there's no second notation to learn. If you want dependency derivation, you must take explicit steps to call <span class="docEmphasis">makedepend</span>(1) or some similar tool—or use <span class="docEmphasis">automake</span>(1).</P>
<P class="docText"><span class="docEmphasis">autoconf</span> is documented by an on-line manual in the GNU <span class="docEmphasis">info</span> format. The source scripts of autoconf are available from the FSF<A NAME="idd1e34457"></A> archive site, but are also preinstalled on many Unix and Linux<A NAME="idd1e34461"></A> versions. You should be able to browse this manual through your Emacs's help system.</P>
<P class="docText">Despite its lack of direct support for dependency derivation, and despite its generally ad-hoc approach, in mid-2003 <span class="docEmphasis">autoconf</span> is clearly the most popular of the makefile generators, and has been for some years. It has eclipsed <span class="docEmphasis">Imake</span> and driven at least one major competitor (<span class="docEmphasis">metaconfig</span>) out of use.</P>
<P class="docText">A reference, <span class="docEmphasis">GNU Autoconf, Automake and Libtool</span> is available <A class="docLink" HREF="0131429019_app02.html#biblio86">[Vaughan]</A>. We'll have more to say about <span class="docEmphasis">autoconf</span>, from a slightly different angle, in <A class="docLink" HREF="0131429019_ch17.html#ch17">Chapter 17</A>.</P>

<A NAME="ch15lev3sec6"></A>
<H5 class="docSection3Title">15.4.4.4 <span class="docEmphasis">automake</span></H5>
<P class="docText"><A NAME="idd1e34502"></A><A NAME="idd1e34509"></A><A NAME="idd1e34516"></A><span class="docEmphasis">automake</span> is an attempt to add <span class="docEmphasis">Imake</span>-like dependency derivation as a layer on top of <span class="docEmphasis">autoconf</span>(1). You write <TT>Makefile.am</TT> templates in a broadly <span class="docEmphasis">Imake</span>-like notation; <span class="docEmphasis">automake</span>(1) compiles them to <TT>Makefile.in</TT> files, which <span class="docEmphasis">autoconf</span>'s <TT>configure</TT> scripts then operate on.</P>
<P class="docText"><span class="docEmphasis">automake</span> is still relatively new technology in mid-2003. It is used in several FSF<A NAME="idd1e34553"></A> projects but has not yet been widely adopted elsewhere. While its general approach looks promising, it is as yet rather brittle—it works when used in stereotyped ways but tends to break badly if you try to do anything unusual with it.</P>
<P class="docText">Complete on-line documentation is shipped with <span class="docEmphasis">automake</span>, which can be downloaded from the FSF<A NAME="idd1e34565"></A> archive site.</P>



<ul></ul></td></tr></table>
<td></td>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<td class="tt1"><a href="NFO/lib.html">[ Team LiB ]</a></td><td valign="top" class="tt1" align="right">
          <a href="0131429019_ch15lev1sec3.html"><img src="FILES/btn_prev.gif" width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a>
          <a href="0131429019_ch15lev1sec5.html"><img src="FILES/btn_next.gif" width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a>
</td></table>
</body></html>
