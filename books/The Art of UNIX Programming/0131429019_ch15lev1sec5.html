<html><head>
<META http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<!--SafClassName="docSection1Title"--><!--SafTocEntry="15.5 Version-Control Systems"-->
<link rel="STYLESHEET" type="text/css" href="FILES/style.css">
<link rel="STYLESHEET" type="text/css" href="FILES/docsafari.css">
<style type="text/css">	.tt1    {font-size: 10pt;}</style>
</head>
<body>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<td class="tt1"><a href="NFO/lib.html">[ Team LiB ]</a></td><td valign="top" class="tt1" align="right">
	<a href="0131429019_ch15lev1sec4.html"><img src="FILES/btn_prev.gif" width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a>
	<a href="0131429019_ch15lev1sec6.html"><img src="FILES/btn_next.gif" width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a>
</td></table>
<br>
<table width="100%" border="0" cellspacing="0" cellpadding="0"><tr><td valign="top"><A NAME="ch15lev1sec5"></A>
<H3 class="docSection1Title">15.5 Version-Control Systems</H3>
<P class="docText"><A NAME="idd1e34579"></A><A NAME="idd1e34586"></A>Code evolves. As a project moves from first-cut prototype to deliverable, it goes through multiple cycles in which you explore new ground, debug, and then stabilize what you've accomplished. And this evolution doesn't stop when you first deliver for production. Most projects will need to be maintained and enhanced past the 1.0 stage, and will be released multiple times. Tracking all that detail is just the sort of thing computers are good at and humans are not.</P>
<A NAME="ch15lev2sec10"></A>
<H4 class="docSection2Title">15.5.1 Why Version Control?</H4>
<P class="docText"><A NAME="idd1e34599"></A><A NAME="idd1e34606"></A>Code evolution raises several practical problems that can be major sources of friction and drudgery—thus a serious drain on productivity. Every moment spent on these problems is a moment not spent on getting the design and function of your project right.</P>
<P class="docText">Perhaps the most important problem is <span class="docEmphasis">reversion</span>. If you make a change, and discover it's not viable, how can you revert to a code version that is known good? If reversion is difficult or unreliable, it's hard to risk making changes at all (you could trash the whole project, or make many hours of painful work for yourself).</P>
<P class="docText">Almost as important is <span class="docEmphasis">change tracking</span><A NAME="idd1e34623"></A>. You know your code has changed; do you know why? It's easy to forget the reasons for changes and step on them later. If you have collaborators on a project, how do you know what they have changed while you weren't looking, and who was responsible for each change?</P>
<blockquote>

<p class="docText"><A NAME="idd1e34634"></A>Amazingly often, it is useful to ask what <span class="docEmphasis">you</span> have changed since the last known-good version, even if you have no collaborators. This often uncovers unwanted changes, such as forgotten debugging code. I now do this routinely before checking in a set of changes.</p>
<p class="docText">—Henry Spencer</p></blockquote>
<P class="docText">Another issue is <span class="docEmphasis">bug tracking</span><A NAME="idd1e34647"></A>. It's quite common to get new bug reports for a particular version after the code has mutated away from it considerably. Sometimes you can recognize immediately that the bug has already been stomped, but often you can't. Suppose it doesn't reproduce under the new version. How do you get back the state of the code for the old version in order to reproduce and understand it?</P>
<P class="docText">To address these problems, you need procedures for keeping a history of your project, and annotating it with comments that explain the history. If your project has more than one developer, you also need mechanisms for making sure developers don't overwrite each others' versions.</P>

<A NAME="ch15lev2sec11"></A>
<H4 class="docSection2Title">15.5.2 Version Control by Hand</H4>
<P class="docText"><A NAME="idd1e34662"></A><A NAME="idd1e34665"></A><A NAME="idd1e34670"></A>The most primitive (but still very common) method is all hand-hacking. You snapshot the project periodically by manually copying everything in it to a backup. You include history comments in source files. You make verbal or email arrangements with other developers to keep their hands off certain files while you hack them.</P>
<P class="docText">The hidden costs of this hand-hacking method are high, especially when (as frequently happens) it breaks down. The procedures take time and concentration; they're prone to error, and tend to get slipped under pressure or when the project is in trouble—that is, exactly when they are most needed.</P>
<P class="docText">As with most hand-hacking, this method does not scale well. It restricts the granularity of change tracking, and tends to lose metadata details such as the order of changes, who did them, and why. Reverting just a part of a large change can be tedious and time consuming, and often developers are forced to back up farther than they'd like after trying something that doesn't work.</P>

<A NAME="ch15lev2sec12"></A>
<H4 class="docSection2Title">15.5.3 Automated Version Control</H4>
<P class="docText"><A NAME="idd1e34692"></A><A NAME="idd1e34695"></A><A NAME="idd1e34700"></A>To avoid these problems, you can use a <span class="docEmphasis">version-control system</span> (VCS), a suite of programs that automates away most of the drudgery involved in keeping an annotated history of your project and avoiding modification conflicts.</P>
<P class="docText">Most VCSs share the same basic logic. To use one, you start by <span class="docEmphasis">registering</span> a collection of source files—that is, telling your VCS to start archive files describing their change histories. Thereafter, when you want to edit one of these files, you have to <span class="docEmphasis">check out</span> the file—assert an exclusive lock on it. When you're done, you <span class="docEmphasis">check in</span> the file, adding your changes to the archive, releasing the lock, and entering a change comment explaining what you did.</P>
<P class="docText">The history of the project is not necessarily linear. All VCSs in common use actually allow you to maintain a tree of variant versions (for ports to different machines, say) with tools for merging branches back into the main "trunk" version. This feature becomes important as the size and dispersion of the development group increases. It needs to be used with care, however; multiple active variants of the code base can be very confusing (just associated bug reports to the right version are not necessarily easy), and automated merging of branches does not guaranteed that the combined code works.</P>
<P class="docText">Most of the rest of what a VCS does is convenience: labeling, and reporting features surrounding these basic operations, and tools which allow you to view differences between versions, or to group a given set of versions of files as a named <span class="docEmphasis">release</span> that can be examined or reverted to at any time without losing later changes.</P>
<P class="docText">VCSs have their problems. The biggest one is that using a VCS involves extra steps every time you want to edit a file, steps that developers in a hurry tend to want to skip if they have to be done by hand. Near the end of this chapter we'll discuss a way to solve this problem.</P>
<P class="docText">Another problem is that some kinds of natural operations tend to confuse VCSs. Renaming files is a notorious trouble spot; it's not easy to automatically ensure that a file's version history will be carried along with it when it is renamed. Renaming problems are particularly difficult to resolve when the VCS supports branching.</P>
<P class="docText">Despite these difficulties, VCSs are a huge boon to productivity and code quality in many ways, even for small single-developer projects. They automate away many procedures that are just tedious work. They help a lot in recovering from mistakes. Perhaps most importantly, they free programmers to experiment by guaranteeing that reversion to a known-good state will always be easy.</P>
<P class="docText">(VCSs, by the way, are not merely good for program code; the manuscript of this book was maintained as a collection of files under <span class="docEmphasis">RCS</span> while it was being written.)</P>

<A NAME="ch15lev2sec13"></A>
<H4 class="docSection2Title">15.5.4 Unix Tools for Version Control</H4>
<P class="docText"><A NAME="idd1e34788"></A><A NAME="idd1e34793"></A>Historically, three VCSs have been of major significance in the Unix world, and we'll survey them here. For an extended introduction and tutorial, consult <span class="docEmphasis">Applying RCS and SCCS</span> [Bolinger-Bronson].</P>
<A NAME="ch15lev3sec7"></A>
<H5 class="docSection3Title">15.5.4.1 Source Code Control System (SCCS)</H5>
<P class="docText"><A NAME="idd1e34817"></A><A NAME="idd1e34824"></A><A NAME="idd1e34831"></A>The first was <span class="docEmphasis">SCCS</span>, the original Source Code Control System developed by Bell Labs<A NAME="idd1e34838"></A> around 1980 and featured in System III<A NAME="idd1e34842"></A> Unix. <span class="docEmphasis">SCCS</span> seems to have been the first serious attempt at a unified source-code management system; concepts that it pioneered are still found at some level in all later ones, including commercial Unix and Windows<A NAME="idd1e34849"></A> products such as ClearCase.</P>
<P class="docText"><span class="docEmphasis">SCCS</span> itself is, however, now obsolete; it was proprietary Bell Labs software. Superior open-source alternatives<A NAME="idd1e34858"></A> have since been developed, and most of the Unix world has converted to those. <span class="docEmphasis">SCCS</span> is still in use to manage old projects at some commercial vendors, but can no longer be recommended for new projects.</P>
<P class="docText">No complete open-source implementation of <span class="docEmphasis">SCCS</span> exists. A clone called CSSC (Compatibly Stupid Source Control)<A NAME="idd1e34871"></A> is in development under the sponsorship of the FSF<A NAME="idd1e34877"></A>.</P>

<A NAME="ch15lev3sec8"></A>
<H5 class="docSection3Title">15.5.4.2 Revision Control System (RCS)</H5>
<P class="docText"><A NAME="idd1e34889"></A><A NAME="idd1e34896"></A><A NAME="idd1e34903"></A>The superior open-source alternatives began with RCS (Revision Control System), born at Purdue University a few years after <span class="docEmphasis">SCCS</span> and originally distributed with 4.3BSD Unix<A NAME="idd1e34913"></A>. It is logically similar to <span class="docEmphasis">SCCS</span> but has a cleaner command interface, and good facilities for grouping together entire project releases under symbolic names.</P>
<P class="docText"><span class="docEmphasis">RCS</span> is currently the most widely used version control system in the Unix world. Some other Unix version-control systems use it as a back end or underlayer. It is well suited for single-developer or small-group projects hosted at a single development shop.</P>
<P class="docText">The <span class="docEmphasis">RCS</span> sources are maintained and distributed by the FSF<A NAME="idd1e34935"></A>. Free ports are available for Microsoft operating systems<A NAME="idd1e34939"></A> and VAX VMS<A NAME="idd1e34943"></A><A NAME="idd1e34946"></A>.</P>

<A NAME="ch15lev3sec9"></A>
<H5 class="docSection3Title">15.5.4.3 Concurrent Version System (CVS)</H5>
<P class="docText"><A NAME="idd1e34958"></A><A NAME="idd1e34965"></A><A NAME="idd1e34972"></A>CVS (Concurrent Version System) began life as a front end to <span class="docEmphasis">RCS</span> developed in the early 1990s, but the model of version control it uses was different enough that it immediately qualified as a new design. Modern implementations don't rely on <span class="docEmphasis">RCS</span>.</P>
<P class="docText">Unlike <span class="docEmphasis">RCS</span> and <span class="docEmphasis">SCCS</span>, <span class="docEmphasis">CVS</span> doesn't exclusively lock files when they're checked out. Instead, it tries to reconcile nonconflicting changes mechanically when they're checked back in, and requests human help on conflicts. The design works because patch conflicts are much less common than one might intuitively think.</P>
<P class="docText">The interface of <span class="docEmphasis">CVS</span> is significantly more complex than that of <span class="docEmphasis">RCS</span>, and it needs a lot more disk space. These properties make it a poor choice for small projects. On the other hand, <span class="docEmphasis">CVS</span> is well suited to large multideveloper efforts distributed across several development sites connected by the Internet. <span class="docEmphasis">CVS</span> tools on a client machine can easily be told to direct their operations to a repository located on a different host.</P>
<P class="docText">The open-source community<A NAME="idd1e35022"></A> makes heavy use of <span class="docEmphasis">CVS</span> for projects such as GNOME and Mozilla. Typically, such <span class="docEmphasis">CVS</span> repositories allow anyone to check out sources remotely. Anyone can, therefore, make a local copy of a project, modify it, and mail change patches to the project maintainers. Actual write access to the repository is more limited and has to be explicitly granted by the project maintainers. A developer who has such access can perform a commit option from his modified local copy, which will cause the local changes to get made directly to the remote repository.</P>
<P class="docText">You can see an example of a well-run <span class="docEmphasis">CVS</span> repository, accessible over the Internet, at the GNOME CVS site &lt;<A class="docLink" target="_blank" HREF="http://www.cvs.gnome.org/default.htm">http://cvs.gnome.org</A>&gt;. This site illustrates the use of <span class="docEmphasis">CVS</span>-aware browsing tools such as Bonsai, which are useful in helping a large and decentralized group of developers coordinate their work.</P>
<P class="docText">The social machinery and philosophy accompanying the use of <span class="docEmphasis">CVS</span> is as important as the details of the tools. The assumption is that projects <span class="docEmphasis">will</span> be open and decentralized, with code subject to peer review and inspection even by developers who are not officially members of the project group.</P>
<P class="docText">Just as importantly, <span class="docEmphasis">CVS</span>'s nonlocking philosophy means that projects can't be blocked by a lock if a programmer disappears in the middle of making some changes. <span class="docEmphasis">CVS</span> thus allows developers to avoid the "single person point of failure" problem; in turn, this means that project boundaries can be fluid, casual contributions are relatively easy, and projects are not required to have an elaborate hierarchy of control.</P>
<P class="docText">The <span class="docEmphasis">CVS</span> sources are maintained and distributed by the FSF<A NAME="idd1e35081"></A>.</P>
<P class="docText"><span class="docEmphasis">CVS</span> has significant problems. Some are merely implementation bugs, but one basic problem is that your project's file namespace is not versioned in the same way changes to files themselves are. Thus, <span class="docEmphasis">CVS</span> is easily confused by file renamings, deletions, and additions. Also, <span class="docEmphasis">CVS</span> records changes on a per-file basis, rather than as <span class="docEmphasis">sets</span> of changes made to files. This makes it harder to back out to specific versions, and harder to handle partial check-ins. Fortunately, none of these problems are intrinsic to the nonlocking style, and they have been successfully addressed by newer version-control systems.</P>

<A NAME="ch15lev3sec10"></A>
<H5 class="docSection3Title">15.5.4.4 Other Version-Control Systems</H5>
<P class="docText"><span class="docEmphasis">CVS</span>'s design problems are sufficient to have created demand for a better open-source VCS. Several such efforts are under way as of 2003. The most notable of these are <span class="docEmphasis">Aegis</span><A NAME="idd1e35119"></A><A NAME="idd1e35122"></A><A NAME="idd1e35127"></A> and <span class="docEmphasis">Subversion</span><A NAME="idd1e35137"></A><A NAME="idd1e35140"></A><A NAME="idd1e35145"></A>.</P>
<P class="docText">Aegis &lt;<A class="docLink" target="_blank" HREF="http://www.pcug.org.au/~millerp/aegis/aegis.html">http://www.pcug.org.au/~millerp/aegis/aegis.html</A>&gt; has the longest history of any of these alternatives, has hosted its own development since 1991, and is a mature production system. It features a heavy emphasis on regression-testing and validation.</P>
<P class="docText">Subversion &lt;<A class="docLink" target="_blank" HREF="http://www.subversion.tigris.org/default.htm">http://subversion.tigris.org/</A>&gt;<A NAME="idd1e35165"></A> is positioned as "CVS done right", with the known design problems fully addressed, and in 2003 probably has the best near-term prospect of replacing <span class="docEmphasis">CVS</span>.</P>
<P class="docText">The BitKeeper &lt;<A class="docLink" target="_blank" HREF="http://www.bitkeeper.com/default.htm">http://www.bitkeeper.com</A>&gt; project explores some interesting design ideas related to change-sets and multiple distributed code repositories. Linus Torvalds uses Bitkeeper for the Linux kernel sources. Its non-open-source license is, however, controversial, and has significantly retarded the acceptance of the product.</P>



<a href="0131429019_18071533.html"><img src="FILES/pixel.gif" width="1" height="1" border="0"></a><ul></ul></td></tr></table>
<td></td>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<td class="tt1"><a href="NFO/lib.html">[ Team LiB ]</a></td><td valign="top" class="tt1" align="right">
          <a href="0131429019_ch15lev1sec4.html"><img src="FILES/btn_prev.gif" width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a>
          <a href="0131429019_ch15lev1sec6.html"><img src="FILES/btn_next.gif" width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a>
</td></table>
</body></html>
