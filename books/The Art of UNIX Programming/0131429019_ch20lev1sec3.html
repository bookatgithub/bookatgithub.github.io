<html><head>
<META http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<!--SafClassName="docSection1Title"--><!--SafTocEntry="20.3 Problems in the Design of Unix"-->
<link rel="STYLESHEET" type="text/css" href="FILES/style.css">
<link rel="STYLESHEET" type="text/css" href="FILES/docsafari.css">
<style type="text/css">	.tt1    {font-size: 10pt;}</style>
</head>
<body>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<td class="tt1"><a href="NFO/lib.html">[ Team LiB ]</a></td><td valign="top" class="tt1" align="right">
	<a href="0131429019_ch20lev1sec2.html"><img src="FILES/btn_prev.gif" width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a>
	<a href="0131429019_ch20lev1sec4.html"><img src="FILES/btn_next.gif" width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a>
</td></table>
<br>
<table width="100%" border="0" cellspacing="0" cellpadding="0"><tr><td valign="top"><A NAME="ch20lev1sec3"></A>
<H3 class="docSection1Title">20.3 Problems in the Design of Unix</H3>
<P class="docText">Plan 9 cleans up Unix, but only really adds one new concept (private namespaces) to its basic set of design ideas. But are there serious problems with those basic design ideas? In <A class="docLink" HREF="0131429019_ch01.html#ch01">Chapter 1</A> we touched on several issues that Unix arguably got wrong. Now that the open-source movement has put the design future of Unix back in the hands of programmers and technical people, these are no longer decisions we have to live with forever. We'll reexamine them in order to get a better handle on how Unix might evolve in the future.</P>
<A NAME="ch20lev2sec1"></A>
<H4 class="docSection2Title">20.3.1 A Unix File Is Just a Big Bag of Bytes</H4>
<P class="docText"><A NAME="idd1e42494"></A>A Unix file is just a big bag of bytes, with no other attributes. In particular, there is no capability to store information about the file type or a pointer to an associated application program outside the file's actual data.</P>
<P class="docText">More generally, everything is a byte stream<A NAME="idd1e42503"></A>; even hardware devices are byte streams. This metaphor was a tremendous success of early Unix, and a real advance over a world in which (for example) compiled programs could not produce output that could be fed back to the compiler. Pipes<A NAME="idd1e42507"></A><A NAME="idd1e42510"></A> and shell programming<A NAME="idd1e42514"></A> sprang from this metaphor.</P>
<P class="docText">But Unix's byte-stream metaphor is <span class="docEmphasis">so</span> central that Unix has trouble integrating software objects with operations that don't fit neatly into the byte stream or file repertoire of operations (create, open, read, write, delete). This is especially a problem for GUI objects such as icons, windows, and 'live' documents. Within a classical Unix model of the world, the only way to extend the everything-is-a-byte-stream metaphor is through <TT>ioctl</TT> calls, a notoriously ugly collection of back doors into kernel space.</P>
<P class="docText">Fans of the Macintosh<A NAME="idd1e42530"></A> family of operating systems tend to be vociferous about this. They advocate a model in which a single filename may have both data and resource 'forks', the data fork corresponding to the Unix byte stream and the resource fork being a collection of name/value pairs. Unix partisans prefer approaches that make file data self-describing so that effectively the same sort of metadata is stored within the file.</P>
<P class="docText">The problem with the Unix approach is that every program that writes the file has to know about it. Thus, for example, if we want the file to carry type information inside it, every tool that touches it has to take care to either preserve the type field unaltered or interpret and then rewrite it. While this would be theoretically possible to arrange, in practice it would be far too fragile.</P>
<P class="docText">On the other hand, supporting file attributes raises awkward questions about which file operations should preserve them. It's clear that a copy of a named file to another name should copy the source file's attributes as well as its data—but suppose we <span class="docEmphasis">cat</span>(1)<A NAME="idd1e42543"></A> the file, redirecting the output of <span class="docEmphasis">cat</span>(1) to a new name?</P>
<P class="docText">The answer to this question depends on whether the attributes are actually properties of filenames or are in some magical way bundled with the file's data as a sort of invisible preamble or postamble. Then the question becomes: Which operations make the properties visible?</P>
<P class="docText">Xerox PARC<A NAME="idd1e42556"></A> filesystem designs grappled with this problem as far back as the 1970s. They had an 'open serialized' call that returned a byte stream containing both attributes and content. If applied to a directory, it returned a serialization of the directory's attributes plus the serialization of all the files in it. It is not clear that this approach has ever been bettered.</P>
<P class="docText">Linux 2.5<A NAME="idd1e42563"></A> already supports attaching arbitrary name/value pairs as properties of a filename, but at time of writing this capability is not yet much used by applications. Recent versions of Solaris have a roughly equivalent feature.</P>

<A NAME="ch20lev2sec2"></A>
<H4 class="docSection2Title">20.3.2 Unix Support for GUIs Is Weak</H4>
<P class="docText">The Unix experience proves that using a handful of metaphors as the basis for a framework is a powerful strategy (recall the discussion of frameworks and shared context in <A class="docLink" HREF="0131429019_ch13.html#ch13">Chapter 13</A>). The visual metaphor at the heart of modern GUIs (files represented by icons, and opened by clicking which invokes some designated handler program, typically able to create and edit these files) has proven both successful and long-lived, exerting a strong hold on users and interface designers ever since Xerox PARC<A NAME="idd1e42580"></A> pioneered it in the 1970s.</P>
<P class="docText">Despite considerable recent effort, in 2003 Unix still supports this metaphor only poorly and grudgingly—there are lots of layers, few conventions, and only weak construction utilities. A typical reaction from a Unix old hand is to suspect that this reflects deeper problems with the GUI<A NAME="idd1e42587"></A> metaphor itself.</P>
<blockquote>

<p class="docText"><A NAME="idd1e42598"></A>I think part of the problem is that we still don't have the metaphor right. For example, on the Mac I drag a file to the trashcan to delete it, but when I drag it to a disc it gets copied, and can't drag it to a printer icon to print it because that's done through the menus. I could go on and on. It's like files were in OS/360, before Unix came along with its simple (but not too simple), file idea.</p>
<p class="docText">—Steve Johnson</p></blockquote>
<P class="docText">We quoted Brian Kernighan and Mike Lesk to similar effect in <A class="docLink" HREF="0131429019_ch11.html#ch11">Chapter 11</A>. But the inquiry can't stop with indicting the GUI, because with all its flaws there is tremendous demand for GUIs from end users. Supposing we could get the metaphor right at the level of the design of user interactions, would Unix be capable of supporting it gracefully?</P>
<P class="docText">The answer is: probably not. We touched on this problem in considering whether the bag-of-bytes model is adequate. Macintosh-style file attributes may help provide the mechanism for richer support of GUIs, but it seems very unlikely that they are the whole answer. Unix's object model doesn't include the right fundamental constructs. We need to think through what a really strong framework for GUIs would be like—and, just as importantly, how it can be integrated with the existing frameworks of Unix. This is a hard problem, demanding fundamental insights that have yet to emerge from the noise and confusion of ordinary software engineering or academic research.</P>

<A NAME="ch20lev2sec3"></A>
<H4 class="docSection2Title">20.3.3 File Deletion Is Forever</H4>
<P class="docText">People with VMS<A NAME="idd1e42622"></A> experience, or who remember TOPS-20<A NAME="idd1e42626"></A><A NAME="idd1e42629"></A> often miss these systems' file-versioning facilities. Opening an existing file for write or deleting it actually renamed it in a predictable way including a version number; only an explicit removal operation on a version file actually erased data.</P>
<P class="docText">Unix does without this, at a not inconsiderable cost in user irritation when the wrong files get deleted through a typo or unexpected effects of shell wildcarding.</P>
<P class="docText">There does not seem to be any foreseeable prospect that this will change at the operating system level. Unix developers like clear, simple operations that do what the user tells them to do, even if the user's instructions could amount to commanding "shoot me in the foot". Their instinct is to say that protecting the user from himself should be done at the GUI or application level, not in the operating system.</P>

<A NAME="ch20lev2sec4"></A>
<H4 class="docSection2Title">20.3.4 Unix Assumes a Static Filesystem</H4>
<P class="docText">Unix has, in one sense, a very static model of the world. Programs are implicitly assumed to run only briefly, so the background of files and directories can be assumed static during their execution. There is no standard, well-established way to ask the system to notify an application if and when a specified file or directory changes. This becomes a significant issue when writing long-lived user-interface software which wants to know about changes to the background.</P>
<P class="docText">Linux has file- and directory-change notification features,<sup class="docFootnote"><A class="docLink" HREF="#ch20en04">[4]</A></sup> and some versions of BSD have copied them, but these are not yet portable to other Unixes.</P><blockquote><p class="docFootnote"><sup><A NAME="ch20en04">[4]</A></sup> Look for <span class="docEmphStrong"><TT>F_NOTIFY</TT></span> under <span class="docEmphasis">fcntl</span>(2)<A NAME="idd1e42661"></A>.</p></blockquote>

<A NAME="ch20lev2sec5"></A>
<H4 class="docSection2Title">20.3.5 The Design of Job Control Was Badly Botched</H4>
<P class="docText">Apart from the ability to suspend processes (in itself a trivial addition to the scheduler which could be made fairly inoffensive) what job control is about is switching a terminal among multiple processes. Unfortunately, it does the easiest part—deciding where keystrokes go—and punts all the hard parts, like saving and restoring the state of the screen, to the application.</P>
<P class="docText">A really good implementation of such a facility would be completely invisible to user processes: no dedicated signals, no need to save and restore terminal modes, no need for the applications to redraw the screen at random times. The model ought to be a virtual keyboard that is sometimes connected to the real one (and blocks you if you ask for input when it isn't connected) and a virtual screen which is sometimes visible on the real one (and might or might not block on output when it's not), with the system doing the multiplexing in the same way it multiplexes access to the disk, the processor, etc... and no impact on user programs at all.<sup class="docFootnote"><A class="docLink" HREF="#ch20en05">[5]</A></sup></P><blockquote><p class="docFootnote"><sup><A NAME="ch20en05">[5]</A></sup> This paragraph is based on a 1984 analysis by Henry Spencer<A NAME="idd1e42681"></A>. He went on to note that job control was necessary and appropriate for POSIX.1<A NAME="idd1e42685"></A> and later Unix standards to consider precisely <span class="docEmphasis">because</span> it oozes its way into every program, and hence has to be thought about in any application-to-system interface. Hence, POSIX's endorsement of a misdesign, while proper solutions were "out of scope" and hence were not even considered.</p></blockquote>
<P class="docText">Doing it right would have required the Unix tty driver to track the entire current screen state rather than just maintaining a line buffer, and to know about terminal types at kernel level (possibly with help from a daemon process) so it could do restores properly when a suspended process is foregrounded again. A consequence of doing it wrong is that the Unix kernel can't detach a session, such as an <span class="docEmphasis">xterm</span> or <span class="docEmphasis">Emacs</span> job, from one terminal and reattach it to another (which could be of a different type).</P>
<P class="docText">As Unix usage has shifted to X displays and terminal emulators, job control has become relatively less important, and this issue does not have quite the force it once did. It is still annoying that there is no suspend/attach/detach, however; this feature could be useful for saving the state of terminal sessions between logins.</P>
<P class="docText">A common open-source program called <span class="docEmphasis">screen</span>(1)<A NAME="idd1e42710"></A> solves several of these problems.<sup class="docFootnote"><A class="docLink" HREF="#ch20en06">[6]</A></sup> However, since it has to be called explicitly by the user, its facilities are not guaranteed to be present in every terminal session; also, the kernel-level code that overlaps with it in function has not been removed.</P><blockquote><p class="docFootnote"><sup><A NAME="ch20en06">[6]</A></sup> There is a project site for <span class="docEmphasis">screen</span>(1) at <A class="docLink" target="_blank" HREF="http://www.math.fu-berlin.de/~guckes/screen/default.htm">http://www.math.fu-berlin.de/~guckes/screen/</A>.</p></blockquote>

<A NAME="ch20lev2sec6"></A>
<H4 class="docSection2Title">20.3.6 The Unix API Doesn't Use Exceptions</H4>
<P class="docText">C lacks a facility for throwing named exceptions with attached data.<sup class="docFootnote"><A class="docLink" HREF="#ch20en07">[7]</A></sup> Thus, the C functions in the Unix API indicate errors by returning a distinguished value (usually –1 or a NULL character pointer) and setting a global errno variable.</P><blockquote><p class="docFootnote"><sup><A NAME="ch20en07">[7]</A></sup> For nonprogrammers, <span class="docEmphasis">throwing an exception</span><A NAME="idd1e42738"></A> is a way for a program to bail out in the middle of a procedure. It's not quite an exit because the throw can be intercepted by catcher code in an enclosing procedure. Exceptions are normally used to signal errors or unexpected conditions that mean it would be pointless to try to continue normal processing.</p></blockquote>
<P class="docText">In retrospect, this is the source of many subtle errors. Programmers in a hurry often neglect to check return values. Because no exception is thrown, the Rule of Repair is violated; program flow continues until the error condition manifests as some kind of failure or data corruption later in execution.</P>
<P class="docText">The absence of exceptions also means that some tasks which ought to be simple idioms—like aborting from a signal handler on a version with Berkeley-style signals—have to be performed with code that is complex, subject to portability glitches, and bug-prone.</P>
<P class="docText">This problem can be (and normally is) hidden by bindings of the Unix API in languages such as Python or Java that have exceptions.</P>
<P class="docText">The lack of exceptions is actually an indicator of a problem with larger immediate implications; C's weak type ontology makes communication between higher-level languages implemented in it problematic. Most of the more modern languages, for example, have lists and dictionaries as primary data types—but, because these don't have any canonical representation in the universe of C, attempting to pass lists between (say) Perl and Python is an unnatural act requiring a lot of glue.</P>
<P class="docText">There are technologies that address the larger problem, such as CORBA, but they tend to involve a lot of runtime translation and be unpleasantly heavyweight.</P>

<A NAME="ch20lev2sec7"></A>
<H4 class="docSection2Title">20.3.7 <span class="docEmphasis">ioctl</span>(2) and <span class="docEmphasis">fcntl</span>(2) Are an Embarrassment</H4>
<P class="docText">The <span class="docEmphasis">ioctl</span>(2)<A NAME="idd1e42781"></A> and <span class="docEmphasis">fcntl</span>(2)<A NAME="idd1e42788"></A> mechanisms provide a way to write hooks into a device driver. The original, historical use of <span class="docEmphasis">ioctl</span>(2) was to set parameters like baud rate and number of framing bits in a serial-communications driver, thus the name (for 'I/O control'). Later, ioctl calls were added for other driver functions, and <span class="docEmphasis">fcntl</span>(2) was added as a hook into the filesystem.</P>
<P class="docText">Over the years, <TT>ioctl</TT> and <TT>fcntl</TT> calls have proliferated. They are often poorly documented, and often a source of portability problems as well. With each one comes a grubby pile of macro definitions describing operation types and special argument values.</P>
<P class="docText">The underlying problem is the same as 'big bag of bytes'; Unix's object model is weak, leaving no natural places to put many auxiliary operations. Designers have an untidy choice among unsatisfactory alternatives; <TT>fcntl</TT>/<TT>ioctl</TT><A NAME="idd1e42815"></A><A NAME="idd1e42818"></A> going through devices in <TT>/dev</TT>, new special-purpose system calls, or hooks through special-purpose virtual file systems that hook into the kernel (e.g., <TT>/proc</TT> under Linux and elsewhere).</P>
<P class="docText">It is not clear whether or how Unix's object model will be enriched in the future. If MacOS-like<A NAME="idd1e42831"></A> file attributes become a common feature of Unix, tweaking magic named attributes on device drivers may take over the role <TT>ioctl</TT>/<TT>fcntl</TT> now have (this would at least have the merit of not requiring piles of macro definitions before the interface could be used). We've already seen that Plan 9<A NAME="idd1e42841"></A>
, which uses the named file server or filesystem as its basic object, rather than the file/bytestream, presents another possible path.</P>

<A NAME="ch20lev2sec8"></A>
<H4 class="docSection2Title">20.3.8 The Unix Security Model May Be Too Primitive</H4>
<P class="docText">Perhaps root is too powerful, and Unix should have finer-grained capabilities or ACLs (Access Control Lists)<A NAME="idd1e42854"></A> for system-administration functions, rather than one superuser that can do anything. People who take this position argue that too many system programs have permanent root privileges through the set-user-ID mechanism; if even one can be compromised, intrusions everywhere will follow.</P>
<P class="docText">This argument is weak, however. Modern Unixes allow any given user account to belong to multiple security groups. Through use of the execute-permission and set-group-ID bits on program executables, each group can in effect function as an ACL for files or programs.</P>
<P class="docText">This theoretical possibility is very little used, however, suggesting that the demand for ACLs is much less in practice than it is in theory.</P>

<A NAME="ch20lev2sec9"></A>
<H4 class="docSection2Title">20.3.9 Unix Has Too Many Different Kinds of Names</H4>
<P class="docText">Unix unified files and local devices—they're all just byte streams. But network devices accessed through sockets have different semantics in a different namespace. Plan 9<A NAME="idd1e42873"></A><A NAME="idd1e42876"></A> demonstrates that files can be smoothly unified with both local and remote (network) devices, and all of these things can be managed through a namespace that is dynamically adjustable per-user and even per-program.</P>

<A NAME="ch20lev2sec10"></A>
<H4 class="docSection2Title">20.3.10 File Systems Might Be Considered Harmful</H4>
<P class="docText">Was having a file system at all the wrong thing? Since the late 1970s there has been an intriguing history of research into persistent object stores and operating systems that don't have a shared global filesystem at all, but rather treat disk storage as a huge swap area and do everything through virtualized object pointers.</P>
<P class="docText">Modern efforts in this line (such as EROS<A NAME="idd1e42892"></A><sup class="docFootnote"><A class="docLink" HREF="#ch20en08">[8]</A></sup>) hint that such designs can offer large benefits including both provable conformance to a security policy and higher performance. It must be noted, however, that if this is a failure of Unix, it is equally a failure of all of its competitors; no major production operating system has yet followed EROS's lead.<sup class="docFootnote"><A class="docLink" HREF="#ch20en09">[9]</A></sup></P><blockquote><p class="docFootnote"><sup><A NAME="ch20en08">[8]</A></sup> <A class="docLink" target="_blank" HREF="http://www.eros-os.org/default.htm">http://www.eros-os.org/</A></p></blockquote><blockquote><p class="docFootnote"><sup><A NAME="ch20en09">[9]</A></sup> The operating systems of the Apple Newton, the AS/400 minicomputer and the Palm handheld could be considered exceptions.</p></blockquote>

<A NAME="ch20lev2sec11"></A>
<H4 class="docSection2Title">20.3.11 Towards a Global Internet Address Space</H4>
<P class="docText">Perhaps URLs don't go far enough. We'll leave the last word on possible future directions of Unix to Unix's inventor:</P>
<blockquote>

<p class="docText"><A NAME="idd1e42922"></A>My ideal for the future is to develop a filesystem remote interface (a la Plan 9) and then have it implemented across the Internet as the standard rather than HTML. That would be ultimate cool.</p>
<p class="docText">—Ken Thompson</p></blockquote>


<a href="0131429019_18071533.html"><img src="FILES/pixel.gif" width="1" height="1" border="0"></a><ul></ul></td></tr></table>
<td></td>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<td class="tt1"><a href="NFO/lib.html">[ Team LiB ]</a></td><td valign="top" class="tt1" align="right">
          <a href="0131429019_ch20lev1sec2.html"><img src="FILES/btn_prev.gif" width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a>
          <a href="0131429019_ch20lev1sec4.html"><img src="FILES/btn_next.gif" width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a>
</td></table>
</body></html>
