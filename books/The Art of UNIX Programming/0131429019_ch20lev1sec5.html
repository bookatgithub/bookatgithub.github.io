<html><head>
<META http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<!--SafClassName="docSection1Title"--><!--SafTocEntry="20.5 Problems in the Culture of Unix"-->
<link rel="STYLESHEET" type="text/css" href="FILES/style.css">
<link rel="STYLESHEET" type="text/css" href="FILES/docsafari.css">
<style type="text/css">	.tt1    {font-size: 10pt;}</style>
</head>
<body>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<td class="tt1"><a href="NFO/lib.html">[ Team LiB ]</a></td><td valign="top" class="tt1" align="right">
	<a href="0131429019_ch20lev1sec4.html"><img src="FILES/btn_prev.gif" width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a>
	<a href="0131429019_ch20lev1sec6.html"><img src="FILES/btn_next.gif" width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a>
</td></table>
<br>
<table width="100%" border="0" cellspacing="0" cellpadding="0"><tr><td valign="top"><A NAME="ch20lev1sec5"></A>
<H3 class="docSection1Title">20.5 Problems in the Culture of Unix</H3>
<P class="docText"><A NAME="idd1e43031"></A><A NAME="idd1e43034"></A>Just as important as the technical problems with Unix itself and the challenges consequent on its success are the cultural problems of the community around it. There are at least two serious ones: a lesser challenge of internal transition, and a greater one of overcoming our historical elitism.</P>
<P class="docText">The lesser challenge is that of friction between the old-school Unix gurus and the new-school open-source crowd. The success of Linux<A NAME="idd1e43045"></A>, in particular, is not an entirely comfortable phenomenon for a lot of older Unix programmers. This is partly a generational problem. The raucous energy, na&iuml;vete and gleeful zealotry of the Linux kids sometimes grates on elders who have been around since the 1970s and (often rightly) consider themselves wiser. It's only exacerbated by the fact that the kids are succeeding where the elders failed.</P>
<P class="docText">The greater problem of psychology only became clear to me after spending three days at a Macintosh developer conference in 2000. It was a very enlightening experience to be immersed in a programming culture with assumptions diametrically opposed to those of the Unix world.</P>
<P class="docText">Macintosh programmers are all about the user experience. They're architects and decorators. They design from the outside in, asking first "What kind of interaction do we want to support?" and then building the application logic behind it to meet the demands of the user-interface design<A NAME="idd1e43057"></A>. This leads to programs that are very pretty and infrastructure that is weak and rickety. In one notorious example, as late as Release 9 the MacOS memory manager sometimes required the user to manually deallocate memory by manually chucking out exited but still-resident programs. Unix people are viscerally revolted by this kind of maldesign; they don't understand how Macintosh people could live with it.</P>
<P class="docText">By contrast, Unix people are all about infrastructure. We are plumbers and stonemasons. We design from the inside out, building mighty engines to solve abstractly defined problems (like "How do we get reliable packet-stream delivery from point A to point B over unreliable hardware and links?"). We then wrap thin and often profoundly ugly interfaces around the engines. The commands <span class="docEmphasis">date</span>(1)<A NAME="idd1e43067"></A>, <span class="docEmphasis">find</span>(1)<A NAME="idd1e43074"></A>, and <span class="docEmphasis">ed</span>(1)<A NAME="idd1e43081"></A> are notorious examples, but there are hundreds of others. Macintosh people are viscerally revolted by this kind of maldesign; they don't understand how Unix people can live with it.</P>
<P class="docText">Both design philosophies have some validity, but the two camps have a great deal of difficulty seeing each other's points. The typical Unix developer's reflex is to dismiss Macintosh software as gaudy fluff, eye-candy for the ignorant, and to continue building software that appeals to other Unix developers. If end-users don't like it, so much the worse for the end users; they will come around when they get a clue.</P>
<P class="docText">In many ways this kind of parochialism has served us well. We are the keepers of the Internet<A NAME="idd1e43091"></A> and the World Wide Web<A NAME="idd1e43095"></A>. Our software and our traditions dominate serious computing, the applications where 24/7 reliability and minimal downtime is a must. We really are extremely good at building solid infrastructure; not perfect by any means, but there is no other software technical culture that has anywhere close to our track record, and it is one to be proud of.</P>
<P class="docText">The problem is that we increasingly face challenges that demand a more inclusive view. Most of the computers in the world don't live in server rooms, but rather in the hands of those end users. In early Unix days, before personal computers, our culture defined itself partly as a revolt against the priesthood of the mainframes, the keepers of the big iron. Later, we absorbed the power-to-the-people idealism of the early microcomputer enthusiasts. But today <span class="docEmphasis">we</span> are the priesthood; <span class="docEmphasis">we</span> are the people who run the networks and the big iron. And our implicit demand is that if you want to use our software, you must learn to think like us.</P>
<P class="docText">In 2003, there is a deep ambivalence in our attitude—a tension between elitism and missionary populism. We want to reach and convert the 92% of the world for whom computing means games and multimedia and glossy GUI interfaces<A NAME="idd1e43111"></A> and (at their most technical) light email and word processing and spreadsheets. We are spending major effort on projects like GNOME<A NAME="idd1e43115"></A> and KDE<A NAME="idd1e43119"></A> designed to give Unix a pretty face. But we are still elitists at heart, deeply reluctant and in many cases unable to identify with or listen to the needs of the Aunt Tillies of the world.</P>
<P class="docText">To nontechnical end users, the software we build tends to be either bewildering and incomprehensible, or clumsy and condescending, or both at the same time. Even when we try to do the user-friendliness thing as earnestly as possible, we're woefully inconsistent at it. Many of the attitudes and reflexes we've inherited from old-school Unix are just wrong for the job. Even when we want to listen to and help Aunt Tillie, we don't know how—we project our categories and our concerns onto her and give her 'solutions' that she finds as daunting as her problems.</P>
<P class="docText">Our greatest challenge as a culture is whether we can outgrow the assumptions that have served us so well—whether we can acknowledge, not merely intellectually but in the sinew of daily practice, that the Macintosh people have a point. Their point is made in more general, less Mac-specific way in <span class="docEmphasis">The Inmates Are Running the Asylum</span> <A class="docLink" HREF="0131429019_app02.html#biblio13">[Cooper]</A>, an insightful and argumentative book about what its author calls <span class="docEmphasis">interaction design</span> that (despite occasional crotchets) contains a good deal of hard truth that every Unix programmer ought to know.</P>
<P class="docText">We can turn aside from this; we can remain a priesthood appealing to a select minority of the best and brightest, a geek meritocracy focused on our historical role as the keepers of the software infrastructure and the networks. But if we do this, we will very likely go into decline and eventually lose the dynamism that has sustained us through decades. Someone else will serve the people; someone else will put themselves where the power and the money are, and own the future of 92% of all software. The odds are, whether that someone else is Microsoft<A NAME="idd1e43141"></A> or not, that they will do it using practices and software we don't much like.</P>
<P class="docText">Or we can truly accept the challenge. The open-source movement is trying hard to do so. But the kind of sustained work and intelligence we have brought to other problems in the past will not alone suffice. Our attitudes must change in a fundamental and difficult way.</P>
<P class="docText">In <A class="docLink" HREF="0131429019_ch04.html#ch04">Chapter 4</A> we discussed the importance of throwing away limiting assumptions and discarding the past in solving technical problems, suggesting a parallel with the Zen<A NAME="idd1e43155"></A> ideas of detachment and 'beginner's mind'. We have a larger kind of detachment to work on now. We must learn humility before Aunt Tillie, and relinquish some of the long-held prejudices that have made us so successful in the past.</P>
<P class="docText">Tellingly, the Macintosh culture has begun to converge<A NAME="idd1e43162"></A> with ours—MacOS X<A NAME="idd1e43168"></A> has Unix underneath, and in 2003 Mac developers are (albeit with a struggle in some cases) making the mental adjustment to learn the infrastructure-focused virtues of Unix. Our challenge will be, reciprocally, to embrace the user-centered virtues of the Macintosh.</P>
<P class="docText">There are other signs that the Unix culture is shedding its insularity as well. One is the convergence that seems to be going on between the Unix/open-source community and the movement called "agile programming"<A NAME="idd1e43175"></A>.<sup class="docFootnote"><A class="docLink" HREF="#ch20en12">[12]</A></sup> We noted in <A class="docLink" HREF="0131429019_ch04.html#ch04">Chapter 4</A> that Unix programmers have seized happily on the concept of refactoring, one of the preoccupations of the agile-programming thinkers. Refactoring, and other agile concepts like unit-testing and design around stories, seem to articulate and sharpen practices that have heretofore been widespread but only implicit in the Unix tradition. The Unix tradition, on the other hand, can bring groundedness and the lessons of long experience to the agile-programming party. As open-source software gains market share it is even conceivable that these cultures will fuse, much as the old-time Internet and early Unix cultures did after 1980.</P><blockquote><p class="docFootnote"><sup><A NAME="ch20en12">[12]</A></sup> For an introduction to agile programming, see the Agile Manifesto &lt;<A class="docLink" target="_blank" HREF="http://www.agilemanifesto.org/default.htm">http://agilemanifesto.org/</A>&gt;</p></blockquote>

<a href="0131429019_18071533.html"><img src="FILES/pixel.gif" width="1" height="1" border="0"></a><ul></ul></td></tr></table>
<td></td>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<td class="tt1"><a href="NFO/lib.html">[ Team LiB ]</a></td><td valign="top" class="tt1" align="right">
          <a href="0131429019_ch20lev1sec4.html"><img src="FILES/btn_prev.gif" width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a>
          <a href="0131429019_ch20lev1sec6.html"><img src="FILES/btn_next.gif" width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a>
</td></table>
</body></html>
