<HTML><HEAD><META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=iso-8859-1">
<!--SafClassName="docSection1Title"--><!--SafTocEntry="13.7 Formatting"-->
<LINK REL="stylesheet" href="FILES/sbolM.css">
</HEAD>
<BODY link="#354278" vlink="#000066" alink="#000080" topmargin="0">
<table width="100%" border="0" cellspacing="0" cellpadding="0" bgcolor="#CCCCCC">
<td><font color="black" size=1>I l<font color="#FF0000">@</font>ve RuBoard</td>
<td valign="top" class="v2" align="right"><a href="0201379260_snode106.html"><img src="FILES/previous.gif" width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a> <a href="0201379260_snode108.html"><img src="FILES/next.gif" width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a></td></table>
<FONT><h3>13.7
Formatting</h3>
			<p>Two concepts influence the definition of I/O formats: Most obviously, there are format flags that define, for example, numeric precision, the fill character, or the numeric base. Apart from this, there exists the possibility of adjusting the formats to meet special national conventions. This section introduces the format flags. <a href="0201379260_snode108.html">Section 13.8</a>, and <a href="0201379260_cnode115.html">Chapter 14</A> describe the aspects of internationalized formatting.</P>

			<h4>13.7.1
Format Flags</h4>
				<p>The class <tT CLAss="monofont">ios_base</tt> has several members that are used for the definition of various I/O formats. For example, it has members that store the minimum field width, the precision of floating-point numbers, or the fill character. A member of type <tt class="monofont">ios::fmtflags</tt> stores configuration flags defining, for example, whether positive numbers should be preceded by a positive sign or whether Boolean values should be printed numerically or as words.</p>

				<p>Some of the format flags form groups. For example, the flags for octal, decimal, and hexadecimal formats of integer numbers form a group. Special masks are defined to make dealing with such groups easier.</p>

				<a name="2"></A><P><TABLe BOrDEr="1" CELLSPacinG="0" CELlpadDING="1" widtH="100%">
<CAPtion><h5>Table 13.9. Member Function to Access Format Flags</h5></caption><colgroup ALIGN="left" SpAN="2">
<tR>
<Th VALIGN="top">
<font SIZE="2"><b>Member Function</b>
								</foNT></TH>
<th vaLIGN="top">
<font size="2"><b>Meaning</b>
								</font></th>
</tr>
<tr>
<tD VALIGn="top">
<FOnT SiZE="2"><TT CLass="monofont">setf</tT> (<I>flags</I>)
</Font></tD>
<TD ValigN="top">
<FONt size="2">Sets <i>flags</i> as additional format flags and returns the previous state of all flags
</font></td>
</tr>
<tr>
<td vaLIGN="top">
<FOnT SiZE="2"><tT CLASS="monofont">setf</tt> (<i>flags, mask</i>)
</FONT></td>
<td VALIgn="top">
<foNT SIze="2">Sets <i>flags</i> as the new format flags of the group identified by <i>mask</i> and returns the previous state of all flags
</font></td>
</tr>
<tr>
<td valIGN="top">
<FONt SIzE="2"><Tt CLASS="monofont">unsetf</Tt> (<i>flags</i>)
</fONT></Td>
<td vALIGn="top">
<fonT SIZe="2">Clears <i>flags</i>
								</font></td>
</tr>
<tr>
<td valign="top">
<FONT SIzE="2"><Tt CLaSS="monofont">flags()</TT>
								</FOnt></td>
<TD VAlign="top">
<FONT size="2">Returns all set format flags</FONT></td>
</tr>
<tr>
<td valign="top">
<font sizE="2"><TT CLAsS="monofont">flags </Tt>(<I>flags</I>)
</fONT></TD>
<Td valIGN="top">
<Font sIZE="2">Sets <I>flags</i> as the new format flags and returns the previous state of all flags
</fonT></TD>
</Tr>
<tr>
<td valign="top">
<font size="2"><tt CLASS="monofont">copyfmt</Tt> (<I>stream</I>)
</fONt></TD>
<TD VAlign="top">
<FONT size="2">Copies <I>all</I> format definitions from <I>stream</I>
								</font></TD>
</TR>
</colgroup>
</table></p>

				<p>Several member functions can be used to handle all of the format definitions of a stream. These are presented in <a href="0201379260_snode107.html#2">Table 13.9</a>. The functions <TT CLASs="monofont">setf()</TT> and <tT ClASS="monofont">unsetf()</TT> set or clear, respectively, one or more flags. You can manipulate multiple flags at once by combining them using the "binary or" operator; that is, operator <Tt claSS="monofont">|.</TT> The function <tt clASS="monofont">setf()</Tt> can take a mask as the second argument to clear all flags in a group before setting the flags of the first argument, which are also limited to a group. This does not happen with the version of <tt cLASS="monofont">setf()</tt> that takes only one argument. For example:</p>

				<pre>
					
   <i>// set flags</i> showpos <i>and</i> uppercase
   std::cout.setf (std::ios::showpos | std::ios::uppercase);

   <i>// set only the flag</i> hex <i>in the group</i> basefield
   std::cout.setf (std::ios::hex, std::ios::basefield);

   <i>// clear the flag</i> uppercase
   std::cout.unsetf (std::ios::uppercase);

				</pre>

				<p>Using <tT CLASS="monofont">flags()</tT> you can manipulate all format flags at once. Calling <Tt CLaSS="monofont">flags()</TT> without an argument returns the current format flags. Calling <TT clasS="monofont">flags()</TT> with an argument takes this argument as the new state of all format flags and returns the old state. Thus, <Tt claSS="monofont">flags()</TT> with an argument clears all flags and sets the flags that were passed. Using <tt clASS="monofont">flags()</Tt> is useful, for example, for saving the current state of the flags to restore the original state later. The following statements demonstrate an example:</p>

				<pre>
					
   using std::ios, std::cout;


   <i>// save actual format flags</i>
   ios::fmtflags oldFlags = cout.flags();


   <i>// do some changes</i>
   cout.setf(ios::showpos | ios::showbase | ios::uppercase);
   cout.setf(ios::internal, ios::adjustfield);
   cout &lt;&lt; std::hex &lt;&lt; x &lt;&lt; std::endl;


   <i>// restore saved format flag</i>
   cout.flags(oldFlags);

				</pre>

				<p>By using <tt clasS="monofont">copyfmt()</TT> you can copy all the format information from one stream to another. See page 653 for an example.</P>

				<P>You can also use manipulators to set and clear format flags. These are presented in <A href="0201379260_snode107.html#3">Table 13.10</A>.</P>

				<a NAME="3"></A><P><tablE BORder="1" cELLSpaciNG="0" CEllpadding="1" width="100%">
<caption><H5>Table 13.10. Manipulators to Access Format Flags</H5></CAPTiON><cOLgROUP ALign="left" sPAN="2">
<Tr>
<th vALIGn="top">
<fonT SIZe="2"><b>Manipulator</b>
								</font></th>
<th valign="top">
<font SIZE="2"><B>Effect</B>
								</fONt></TH>
</tR>
<TR>
<TD ValigN="top">
<FONt sizE="2"><TT Class="monofont">setiosflags</TT> (<I>flags</I>)
</font></td>
<td valign="top">
<font sizE="2">Sets<I> flags</I> as format flags (calls <TT ClASs="monofont">setf</TT> (<i>flags</I>) for the stream)
</FONT></Td>
</tr>
<tR>
<TD ValigN="top">
<FONt sizE="2"><TT Class="monofont">resetiosflags</tt> (<i>mask</i>)
</font></td>
<td valigN="top">
<FONT SiZE="2">Clears all flags of the group identified by <i>mask</I> (calls <Tt CLASS="monofont">setf</Tt> (0,<i>mask</i>) for the stream)
</fONT></Td>
</tr>
</cOLGRoup>
</tABLE></p>

				<p>The manipulators <tt class="monofont">setiosflags()</tt> and <tt class="monofont">resetiosflags()</tt> provide the possibility of setting or clearing, respectively, one or more flags in a write or read statement with operator <tT CLASS="monofont">&lt;&lt;</tT> or <Tt CLaSS="monofont">&gt;&gt;</TT> respectively. To use one of these manipulators, you must include the header file <TT clasS="monofont">&lt;iomanip&gt;.</TT> For example:</P>

				<pre>
					
   #include &lt;iostream&gt;
   #include &lt;iomanip&gt;
   ...
   std::cout &lt;&lt; resetiosflags(std::ios::adjustfield) <i>// clear adjustm. flags</I>
             &lt;&lt; setiosflags(std::ios::left);         <I>// left-adjust values</I>

				</Pre>

				<p>Some flag manipulations are performed by specialized manipulators. These manipulators are used often because they are more convenient and more readable. They are discussed in the following subsections.</p>

			
			<H4>13.7.2
Input/Output Format of Boolean Values</H4>
				<P>The <Tt class="monofont">boolalpha</tt> flag defines the format used to read or to write Boolean values. It defines whether a numeric or a textual representation is used for Boolean values (<a href="0201379260_snode107.html#5">Table 13.11</a>).</p>

				<a name="5"></a><P><TABLE bORdER="1" cELLSPAcing="0" CELLpaddING="1" Width="100%">
<CAPTion><h5>Table 13.11. Flag for Boolean Representation</h5></caption><colgroup aLIGN="left" SPaN="2">
<Tr>
<TH vALIGN="top">
<Font sIZE="2"><B>Flag</b>
								</fonT></TH>
<Th valIGN="top">
<Font size="2"><b>Meaning</b>
								</font></th>
</tr>
<tr>
<td VALIGN="top">
<fONt SIzE="2"><TT CLAss="monofont">boolalpha</tt>
								</FONT></td>
<td VALIgn="top">
<foNT SIze="2">It set, specifies the use of textual representation; if not set, specifies the use of numeric representation</font></td>
</tr>
</colgroup>
</tabLE></P>

				<P>If the flag is not set (this is the default), Boolean values are represented using numeric strings. In this case, the value <TT cLAsS="monofont">0</Tt> is always used for <TT CLASs="monofont">false</tt> and the value <tT CLAss="monofont">1</tt> is always used for <TT CLass="monofont">true.</tT> When reading a Boolean value as a numeric string it is considered to be an error (setting <TT Class="monofont">failbit</tt> for the stream) if the value is different from <tt class="monofont">0</tt> or <tt clasS="monofont">1.</TT></P>

				<P>If the flag is set, Boolean values are written using a textual representation. When a Boolean value is read, the string has to match the textual representation of either <Tt CLaSS="monofont">true</tT> or <TT CLAss="monofont">false.</tt> The stream's locale object is used to + the strings used to represent <TT CLass="monofont">true</tT> and <TT Class="monofont">false</TT> (see page 626 and page 698). The standard <TT class="monofont">"C"</tt> locale object uses the strings <tt class="monofont">"true"</tt> and <tt claSS="monofont">"false"</TT> as representations of the Boolean values.</P>

				<P>Special manipulators are defined for the convenient manipulation of this flag (<a href="0201379260_snode107.html#6">Table 13.12</A>).</p>

				<A NAME="6"></A><p><tabLE BOrder="1" CELLspacING="0" Cellpadding="1" width="100%">
<captioN><H5>Table 13.12. Manipulation for Boolean Representation</H5></CAPtIOn><COlGROUP Align="left" SPAN="2">
<tr>
<th VALIgn="top">
<foNT SIze="2"><b>Manipulator</b>
								</font></th>
<th valign="top">
<fonT SIZE="2"><B>Meaning</b>
								</FOnT></Th>
</TR>
<TR>
<TD valiGN="top">
<FOnt siZE="2"><TT clasS="monofont">boolalpha</TT>
								</Font></td>
<td valign="top">
<font size="2">Forces textual representation (sets the flag <TT CLASs="monofont">ios::boolalpha</TT>)
</fONt></TD>
</TR>
<TR>
<td vaLIGN="top">
<font SIZE="2"><tt clASS="monofont">noboolalpha</Tt>
								</font></td>
<td valign="top">
<font siZE="2">Forces numeric representation (clears the flag <TT CLaSS="monofont">ios::boolalpha</tT>)
</FoNT></TD>
</TR>
</colgROUP>
</tablE></P>

				<P>For example, the following statements print <Tt claSS="monofont">b</TT> first in numeric representation and then in textual representation:</p>

				<pre>
					
   bool b;
   ...
   cout &lt;&lt; noboolalpha &lt;&lt; b &lt;&lt; " == " &lt;&lt; boolalpha &lt;&lt; b &lt;&lt; endl;

				</pre>

			
			<a name="7"></a><h4>13.7.3
Field Width, Fill Character, and Adjustment</h4>
				<p>Two member functions are used to define the field width and the fill character: <tt claSS="monofont">width()</TT> and <TT cLAsS="monofont">fill()</Tt> (<A href="0201379260_snode107.html#8">Table 13.13</A>).</p>

				<a naME="8"></A><P><tablE BORder="1" cELLSpacing="0" cellpadding="1" widtH="100%">
<CAPTIoN><H5>Table 13.13. Member Functions for the Field Width and the Fill Character</h5></CApTION><COlgroUP ALign="left" sPAN="2">
<Tr>
<th vALIGn="top">
<font size="2"><b>Member Function</b>
								</font></th>
<th vaLIGN="top">
<FOnT SiZE="2"><b>Meaning</B>
								</FONT></Th>
</tr>
<tR>
<TD ValigN="top">
<FONt sizE="2"><TT Class="monofont">width()</tt>
								</font></td>
<td valign="top">
<fONT SIZe="2">Returns the actual field width</FOnT></Td>
</TR>
<TR>
<TD valiGN="top">
<FOnt siZE="2"><TT clasS="monofont">width</TT><I>(val)</i>
								</font></td>
<td valign="top">
<font siZE="2">Sets the field width to <I>val</I> and returns the previous field width
</FOnT></Td>
</TR>
<tR>
<TD VALign="top">
<fONT Size="2"><tT CLAss="monofont">fill()</tt>
								</FONT></td>
<td valign="top">
<font size="2">Returns the actual fill character</fonT></TD>
</TR>
<Tr>
<TD vALiGN="top">
<FONT size="2"><TT CLass="monofont">fill</tT><I>(c)</I>
								</Font></tD>
<TD Valign="top">
<font size="2">Defines <i>c</i> as the fill character and returns the previous fill character
</font></td>
</TR>
</COLGrOUp>
</TAbLE></P>

				<H5>Using Field Width, Fill Character, and Adjustment for Output</H5>
					<P>For the output <tt clASS="monofont">width()</Tt> defines a minimum field. This definition applies only to the next formatted field written. Calling <tt cLASS="monofont">width()</tt> without arguments returns the current field width. Calling <tt CLASs="monofont">width()</tt> with an integral argument changes the width and returns the former value. The default value for the minimum field width is <tt class="monofont">0,</tt> which means that the field may have any length. This is also the value to which the field width is set after a value was written.</p>

					<p>Note that the field width is never used to truncate output. Thus, you can't specify a maximum field width. Instead, you have to program it. For example, you could write to a string and output only a certain number of characters.</p>

					<p><tt claSS="monofont">fill()</TT> defines the fill character that is used to fill the difference between the formatted representation of a value and the minimum field width. The default fill character is a space.</P>

					<P>To adjust values within a field, three flags are defined, as shown in <a href="0201379260_snode107.html#10">Table 13.14</A>. These flags are defined in the class <tT CLASS="monofont">ios_base</tt> together with the corresponding mask.</p>

					<a NAME="10"></a><p><taBLE BordeR="1" CELlspacing="0" cellpadding="1" wiDTH="100%">
<CAPtIOn><H5>Table 13.14. Masks to Adjust Values within a Field</H5></cAPTION><colgROUP aligN="left" SPAn="4">
<tr>
<tH VALign="top">
<font size="2"><b>Mask</b>
									</font></th>
<th VALIGN="top">
<fONt SIzE="2"><B>Flag</B>
									</FONt></th>
<tH VALign="top" cOLSPan="2">
<foNT SIze="2"><b>Meaning</b>
									</font></th>
</tr>
<tr>
<td valigN="top">
<FONT SiZE="2"><tT ClASS="monofont">adjustfield</TT>
									</Font></tD>
<TD ValigN="top">
<FONt sizE="2"><TT Class="monofont">left</tt>
									</font></td>
<td valign="top" cOLSPAN="2">
<fONt SIzE="2">Left-adjusts the value</FONT></Td>
</tr>
<tR>
<TD ValigN="top">
<FONt sizE="2"> </FONt></td>
<td valign="top">
<font size="2"><tt CLASS="monofont">right</Tt>
									</FOnT></Td>
<TD VALIgn="top" coLSPAn="2">
<fonT SIZe="2">Right-adjusts the value</fonT></TD>
</Tr>
<tr>
<td valign="top">
<font size="2"> </foNT></TD>
<TD vALiGN="top">
<fONT SIZe="2"><tt cLASS="monofont">internal</tt>
									</foNT></TD>
<td vaLIGN="top" colspan="2">
<font size="2">Left-adjusts the sign and right-adjusts the value</font></td>
</TR>
<TR>
<TD vALiGN="top">
<fONT SIZe="2"> </fonT></TD>
<Td valIGN="top">
<Font sIZE="2">None</Font></td>
<td valign="top" colspan="2">
<fONT SIZe="2">Right-adjusts the value (the default)</FOnT></Td>
</TR>
</COLGroup>
</TABLe></p>

					<p>After any formatted I/O operation is performed, the default field width is restored. The values of the fill character and the adjustment remain unchanged until they are modified explicitly.</p>

					<P><A href="0201379260_snode107.html#11">Table 13.15</a> presents the effect of the functions and the flags used for different values. The underscore is used as the fill character.</p>

					<A NAMe="11"></a><p><table border="1" cellspaCING="0" CElLPaDDiNG="1" WIDTh="100%">
<capTION><h5>Table 13.15. Examples of Adjustment</h5></caPTIOn><colGROUp align="left" span="6">
<tr>
<th valign="top">
<fONT SIZe="2"><B>Adjustment</B>
									</fONt></TH>
<TH VAlign="top">
<FONT size="2"><B><TT Class="monofont">width()</TT></B>
									</Font></th>
<th valign="top">
<font size="2"><B>-42</B>
									</FONT></tH>
<Th VAlIGN="top">
<FONt sizE="2"><B>0.12</B>
									</Font></tH>
<TH ValigN="top">
<FONt size="2"><b>"Q"</b>
									</font></th>
<th valign="top">
<FONT SIzE="2"><B>'Q'</b>
									</FOnT></TH>
</TR>
<Tr>
<td vALIGn="top">
<fonT SIZe="2"><tt cLASS="monofont">left</tt>
									</font></td>
<td valign="top">
<font sIZE="2">6</FONt></TD>
<tD VaLIGN="top">
<FOnt siZE="2">-42<SUb>---</sub>
									</FONT></td>
<td VALIgn="top">
<font size="2">0.12<sub>--</sub>
									</font></tD>
<TD VALiGN="top">
<fONt SIZE="2">Q<SUb>-----</sub>
									</FONT></td>
<td VALIgn="top">
<foNT SIze="2">Q<sub>-----</sub>
									</font></td>
</tr>
<tr>
<td vALIGN="top">
<FoNT sIZe="2"><TT CLASs="monofont">right</tt>
									</fONT></Td>
<td vALIGn="top">
<fonT SIZe="2">6</font></td>
<td valign="top">
<font siZE="2"><SUB>----</SuB>42
</FoNT></tD>
<TD VALign="top">
<fONT Size="2"><sUB>--</SUb>0.12
</fonT></TD>
<Td valign="top">
<font size="2"><sub>-----</sub>Q
</FONT></TD>
<tD VaLIgN="top">
<FONT Size="2"><sUB>-----</SUb>Q
</fonT></TD>
</Tr>
<tr>
<tD VALign="top">
<font size="2"><tt class="monofont">internal</tt>
									</fONT></TD>
<Td VAlIGn="top">
<FONT SIze="2">6</foNT></TD>
<td vaLIGN="top">
<font SIZE="2">-<sub>---</sub>42
</font></td>
<td valign="top">
<fONT SIZe="2"><SUb>--</SUb>0.12
</FONT></TD>
<td vaLIGN="top">
<font SIZE="2"><sub>-----</sUB>Q
</FOnt></td>
<td valign="top">
<font size="2"><sUB>-----</SUB>Q
</FoNT></tD>
</Tr>
</COLGROup>
</taBLE></P>

					<p>Note that the adjustment for single characters has changed during the standardization. Before standardization, the field width was ignored if single characters were written. It was used for the next formatted output that was not a single character. This bug was fixed. However, for programs that used this bug as a feature, the fix breaks backward compatibility.</p>

					<p>Several manipulators are defined to handle the field width, the fill character, and the adjustment (<a href="0201379260_snode107.html#12">Table 13.16</a>).</p>

					<a nAME="12"></A><p><table border="1" cellspaciNG="0" CELLpADdINg="1" WIDTH="100%">
<CaptiON><H5>Table 13.16. Manipulators for Adjustment</H5></captION><ColgrOUP Align="left" span="2">
<tr>
<th valign="top">
<fonT SIZE="2"><B>Manipulator</b>
									</FOnT></Th>
<TH VALIgn="top">
<foNT SIze="2"><b>Meaning</b>
									</FONT></th>
</tr>
<TR>
<TD valign="top">
<font size="2"><tt class="monofont">setw(val)</TT>
									</FONT></tD>
<Td VAlIGN="top">
<FONt sizE="2">Sets the field width for input and output to <I>val</I> (corresponds to <Tt claSS="monofont">width()</TT> )
</font></TD>
</TR>
<tr>
<td valign="top">
<font size="2"><tt cLASS="monofont">setfill(c)</TT>
									</fONt></TD>
<tD VALIGn="top">
<fonT SIZe="2">Defines <i>c</i> as the fill character (corresponds to <tT CLAss="monofont">fill()</tt>)
</FONT></td>
</tr>
<tr>
<td valign="top">
<font sizE="2"><TT CLAsS="monofont">left</Tt>
									</FOnT></TD>
<TD ValigN="top">
<FONt sizE="2">Left-adjusts the value</FONt></td>
</tR>
<TR>
<Td valign="top">
<font size="2"><tt clasS="monofont">right</TT>
									</FONt></TD>
<tD VaLIGN="top">
<FOnt siZE="2">Right-adjusts the value</FOnt></td>
</TR>
<TR>
<td vaLIGN="top">
<font size="2"><tt class="monofont">internal</tt>
									</font></TD>
<TD VAlIGn="top">
<FOnT SIZE="2">Left-adjusts the sign and right-adjusts the value</Font></tD>
</TR>
</ColgrOUP>
</Table></P>

					<P>The manipulators <TT class="monofont">setw()</tt> and <tt class="monofont">setfill()</tt> use an argument, so you must include the header file <tt claSS="monofont">&lt;iomanip&gt;</TT> to use them. For example, the statements</P>

					<PrE>
						
   #include &lt;iostream&gt;
   #include &lt;iomanip&gt;
   ...
   std::cout &lt;&lt; std::setw(8) &lt;&lt; std::setfill('_') &lt;&lt;-3.14
             &lt;&lt; ' ' &lt;&lt; 42 &lt;&lt; std::endl;
   std::cout &lt;&lt; std::setw(8) &lt;&lt; "sum: "
             &lt;&lt; std::setw(8) &lt;&lt; 42 &lt;&lt; std::endl;

					</PrE>

					<P>produce this output:</p>

					<PRE>
						
   <SUB>---</sub>-3.14 42
   <sUB>---</SUb>sum: <sub>------</SUB>42

					</Pre>

				
				<h5>Using Field Width for Input</h5>
					<P>You can use the field width also to define the maximum number of characters read when character sequences of type <TT Class="monofont">char*</tt> are read. If the value of <tt class="monofont">width()</tt> is not <tt clasS="monofont">0,</TT> then at most <TT ClASs="monofont">width()-1</TT> characters are read.</p>

					<P>Because of the fact that ordinary C-strings can't grow while values are read, <TT CLAss="monofont">width()</tt> or <TT CLass="monofont">setw()</tT> should always be used when reading them with operator <TT Class="monofont">&gt;&gt;.</TT> For example:</P>

					<Pre>
						
   char buffer [81];


   <i>// read, at most, 80 characters:</i>
   cin &gt;&gt; setw (sizeof (buffer)) &gt;&gt; buffer;

					</pre>

					<p>This reads, at most, 80 characters, although <tt class="monofont">sizeof (buffer)</tt> is 81 because one character is used for the string termination character (which is appended automatically). Note that the following code is a common error:</p>

					<pre>
						
   char* s;
   cin &gt;&gt; setw (sizeof (s)) &gt;&gt; s;      <I>//RUNTIME ERROR</I>

					</PRE>

					<P>This is because s is only declared as a pointer without any storage for characters, and <tT ClASs="monofont">sizeof(s)</TT> is the size of the pointer instead of the size of the storage to which it points. This is a typical example of the problems you encounter if you use C-strings. By using strings, you won't run into these problems:</P>

					<PRE>
						
   string buffer;
   cin &gt;&gt; buffer;                <i>//OK</i>

					</prE>

				
			
			<H4>13.7.4
Positive Sign and Uppercase Letters</H4>
				<P>Two format flags are defined to influence the general appearance of numeric values: <tt clASS="monofont">showpos</Tt> and <tt cLASS="monofont">uppercase</tt> (<a href="0201379260_snode107.html#15">Table 13.17</a>).</p>

				<a name="15"></a><p><table BORDER="1" cELlSPaCING="0" CEllpaDDINg="1" widTH="100%">
<CAptioN><H5>Table 13.17. Flags Affecting Sign and Letters of Numeric Values</H5></Caption><colgroup align="left" spAN="2">
<TR>
<TH vALiGN="top">
<fONT SIZe="2"><b>Flag</b>
								</fONT></Th>
<th vALIGn="top">
<fonT SIZe="2"><b>Meaning</b>
								</font></th>
</tr>
<tr>
<td valign="top">
<FONT SIzE="2"><Tt CLaSS="monofont">showpos</TT>
								</FOnt></td>
<TD VAlign="top">
<FONT size="2">Writes a positive sign on positive numbers</FONT></td>
</tr>
<tr>
<td valign="top">
<font sizE="2"><TT CLAsS="monofont">uppercase</Tt>
								</FOnT></TD>
<TD ValigN="top">
<FONt sizE="2">Uses uppercase letters</FONt></td>
</tR>
</COLgroup>
</table></p>

				<p><tt class="monofont">ios::showpos</tt> dictates that a positive sign for positive numeric values be written. If the flag is not set, only negative values are written with a sign, <TT CLASs="monofont">ios::uppercase</TT> dictates that letters in numeric values be written using uppercase letters. This flag applies to integers using hexadecimal format and to floating-point numbers using scientific notation. By default, letters are written as lowercase and no positive sign is written. For example, the statements</p>

				<PRe>
					
   std::cout &lt;&lt; 12345678.9 &lt;&lt; std::endl;

   std::cout.setf (std::ios::showpos | std::ios::uppercase);
   std::cout &lt;&lt; 12345678.9 &lt;&lt; std::endl;

				</PRE>

				<P>produce this output:</P>

				<Pre>
					
   1.23457e+07
   +1.23457E+07

				</prE>

				<P>Both flags can be set or cleared using the manipulators presented in <A href="0201379260_snode107.html#16">Table 13.18</a>.</P>

				<A NAme="16"></a><p><TABLe border="1" cellspacing="0" celLPADDInG="1" WiDTh="100%">
<CAPTIOn><h5>Table 13.18. Manipulators for Sign and Letters of Numeric Values</h5></cAPTIon><coLGROup alIGN="left" Span="2">
<tr>
<th valign="top">
<font size="2"><B>Manipulator</B>
								</FONT></tH>
<Th VAlIGN="top">
<FONt sizE="2"><B>Meaning</B>
								</Font></tH>
</TR>
<Tr>
<td vALIGn="top">
<font size="2"><tt class="monofont">showpos</tt>
								</fonT></TD>
<TD VaLIgN="top">
<FoNT SIZE="2">Forces to write a positive sign on positive numbers (sets the flag <tt clASS="monofont">ios::showpos</Tt>)
</fonT></TD>
</Tr>
<tr>
<tD VALign="top">
<font size="2"><tt class="monofont">noshowpos</tt>
								</fONT></TD>
<Td VAlIGn="top">
<FONT SIze="2">Forces not to write a positive sign (clears the flag <tt CLASs="monofont">ios::showpos</tt>)
</fONT></Td>
</tr>
<tR>
<TD Valign="top">
<font size="2"><tt class="monofont">uppercase</tT>
								</FONT></Td>
<TD vALiGN="top">
<FONT size="2">Forces uppercase letters (sets the flag <TT CLass="monofont">ios::upper case</tT>)
</FONt></td>
</tR>
<TR>
<Td valign="top">
<font size="2"><i><tt claSS="monofont">nouppercase</TT></I>
								</FoNT></tD>
<Td VALIGN="top">
<font SIZE="2">Forces lowercase letters (clears the flag <tt clASS="monofont">ios::uppercase</Tt>)
</fonT></TD>
</Tr>
</colgroup>
</table></p>

			
			<h4>13.7.5
Numeric Base</h4>
				<p>A group of three flags defines which base is used for I/O of integer values. The flags are defined in the class <tt cLASS="monofont">ios_base</TT> with the corresponding mask (<a href="0201379260_snode107.html#18">Table 13.19</A>).</p>

				<A NAME="18"></A><p><tabLE BOrder="1" CELLspacING="0" Cellpadding="1" width="100%">
<captioN><H5>Table 13.19. Flags Defining the Base of Integral Values</H5></CAPtIOn><COlGROUP Align="left" SPAN="3">
<tr>
<th VALIgn="top">
<foNT SIze="2"><b>Mask</b>
								</font></th>
<th valign="top">
<fonT SIZE="2"><B>Flag</b>
								</FOnT></Th>
<TH VALIgn="top">
<foNT SIze="2"><b>Meaning</b>
								</FONT></th>
</tr>
<TR>
<TD valign="top">
<font size="2"><tt class="monofont">basefield</TT>
								</FONT></tD>
<Td VAlIGN="top">
<FONt sizE="2"><TT Class="monofont">oct</TT>
								</FOnt></td>
<TD VAlign="top">
<font size="2">Writes and reads octal</font></td>
</tr>
<tR>
<TD VALiGN="top">
<fONt SIZE="2"> </FOnt></td>
<TD VAlign="top">
<FONT size="2"><TT CLass="monofont">dec</tt>
								</font></td>
<td valign="top">
<foNT SIZE="2">Writes and reads decimal (default)</fONt></TD>
</tR>
<TR>
<TD ValigN="top">
<FONt sizE="2"> </FONt></td>
<tD VALign="top">
<font size="2"><tt class="monofont">hex</tt>
								</fONT></TD>
<Td VAlIGn="top">
<FONT SIze="2">Writes and reads hexadecimal</foNT></TD>
</tr>
<tr>
<TD VAlign="top">
<FONT size="2"> </font></td>
<td valign="top">
<fonT SIZE="2">None</FoNT></tD>
<Td VALIGN="top">
<font SIZE="2">Writes decimal and reads according to the leading characters of the integral value</font></TD>
</TR>
</colgROUP>
</table></p>

				<p>A change in base applies to the processing of all integer numbers until the flags are reset. By default, decimal format is used. There is no support for binary notation. However, you can read and write integral values in binary by using class <tt class="monofont">bitset.</tt> See <a href="0201379260_snode87.html#1">Section 10.4.1</A>, for details.</P>

				<P>If none of the base flags is set, output uses a decimal base. If more than one flag is set, decimal is used as the base.</P>

				<P>The flags for the numeric base also affect input. If one of the flags for the numeric base is set, all numbers are read using this base. If no flag for the base is set when numbers are read the base is determined by the leading characters: A number starting with <Tt CLaSS="monofont">0x</tT> or <TT CLAss="monofont">0X</tt> is read as a hexadecimal number. A number starting with <TT CLass="monofont">0</tT> is read as an octal number. In all other cases, the number is read as a decimal value.</P>

				<P>There are basically two ways to switch these flags:</P>

				<ol tyPE="1" STart="restarts">
<li><p>Clear one flag and set another:</p>

						<pre>
							
      std::cout.unsetf (std::ios::dec);
      std::cout.setf (std::ios::hex);

						</pre>
</li>
<li><p>Set one flag and clear all other flags in the group automatically:</p>

						<prE>
      std::cout.setf (std::ios::hex, std::ios::basefield);

						</PRE>

					</LI>
</oL>

				<P>In addition, manipulators are defined that make the handling of these flags significantly simpler (<a href="0201379260_snode107.html#19">Table 13.20</A>).</P>

				<A NAme="19"></a><p><TABLe borDER="1" CellsPACIng="0" cellpadding="1" width="100%">
<capTION><H5>Table 13.20. Manipulators Defining the Base of Integral Values</H5></cAPtIOn><COLGROup alIGN="left" Span="2">
<tR>
<TH ValigN="top">
<FONt size="2"><b>Manipulator</b>
								</font></th>
<th valign="top">
<FONT SIzE="2"><B>Meaning</b>
								</FOnT></TH>
</TR>
<Tr>
<td vALIGn="top">
<fonT SIZe="2"><tt cLASS="monofont">oct</tt>
								</font></td>
<td valign="top">
<font sIZE="2">Writes and reads octal</FONt></TD>
</tR>
<Tr>
<TD VALIgn="top">
<foNT SIze="2"><tt CLASs="monofont">dec</tt>
								</fONT></Td>
<td valign="top">
<font size="2">Writes and reads hexadecimal</font></TD>
</TR>
<TR>
<tD VaLIgN="top">
<FONT Size="2"><tT CLAss="monofont">hex</tt>
								</FONT></td>
<td VALIgn="top">
<font size="2">Writes and reads decimal</font></td>
</tr>
</colGROUP>
</TaBLe></P>

				<P>For example, the following statements write <tT CLASS="monofont">x</tt> and <tt CLASs="monofont">y</tt> in hexadecimal, and <tT CLAss="monofont">z</tt> in decimal:</P>

				<PRE>
					
   int x, y, z;
   ...
   std::cout &lt;&lt; std::ios::hex &lt;&lt; x &lt;&lt; std::endl;
   std::cout &lt;&lt; y &lt;&lt; ' ' &lt;&lt; std::ios::dec &lt;&lt; z &lt;&lt; std::endl;

				</pre>

				<p>An additional flag, <tt class="monofont">showbase,</tt> lets you write numbers according to the usual C/C++ convention for indicating numeric bases of literal values (<a href="0201379260_snode107.html#20">Table 13.21</a>).</p>

				<a NAME="20"></A><P><tABlE BoRDER="1" CEllspACINg="0" celLPADding="1" WIDTh="100%">
<caption><h5>Table 13.21. Flags to Indicate the Numeric Base</h5></caption><colgROUP ALiGN="left" sPAn="2">
<TR>
<TH VAlign="top">
<FONT size="2"><B>Flag</B>
								</FOnt></th>
<TH VAlign="top">
<font size="2"><b>Meaning</b>
								</font></th>
</tR>
<TR>
<TD VaLIgN="top">
<FoNT SIZE="2"><tt clASS="monofont">showbase</Tt>
								</fonT></TD>
<Td valIGN="top">
<Font size="2">If set, indicates the numeric base</font></td>
</tr>
</colgroUP>
</TABLe></P>

				<P>If <tT ClASS="monofont">ios::showbase</TT> is set, octal numbers are preceded by a <Tt claSS="monofont">0</TT> and hexadecimal numbers are preceded by <tt clASS="monofont">0x</Tt> (or, if <tt cLASS="monofont">ios::uppercase</tt> is set, by <tt class="monofont">0X</tt>). For example, the statements</p>

				<pre>
					
   std::cout &lt;&lt; 127 &lt;&lt; ' ' &lt;&lt; 255 &lt;&lt; std::endl;
   
   std::cout &lt;&lt; std::hex &lt;&lt; 127 &lt;&lt; ' ' &lt;&lt; 255 &lt;&lt; std::endl;
   
   std::cout.setf(std::ios::showbase);
   std::cout &lt;&lt; 127 &lt;&lt; ' ' &lt;&lt; 255 &lt;&lt; std::endl;
   std::cout.setf(std::ios::uppercase);
   std::cout &lt;&lt; 127 &lt;&lt; ' ' &lt;&lt; 255 &lt;&lt; std::endl;

				</pre>

				<p>produce this output:</p>

				<pRE>
					
   127 255
   7f ff
   0x7f 0xff
   0X7F 0XFF

				</PRE>

				<P><tT ClASs="monofont">ios::showbase</TT> can also be manipulated using the manipulators presented in <A href="0201379260_snode107.html#21">Table 13.22</a>.</p>

				<a NAME="21"></a><p><taBLE BordeR="1" CELlspacing="0" cellpadding="1" wiDTH="100%">
<CAPtIOn><H5>Table 13.22. Manipulators to Indicate the Numeric Base</H5></cAPTION><colgROUP aligN="left" SPAn="2">
<tr>
<tH VALign="top">
<font size="2"><b>Manipulator</b>
								</font></th>
<th VALIGN="top">
<fONt SIzE="2"><B>Meaning</B>
								</FONt></th>
</tR>
<TR>
<Td valIGN="top">
<Font sIZE="2"><Tt class="monofont">showbase</tt>
								</font></td>
<td valigN="top">
<FONT SiZE="2">Indicates numeric base (sets the flag <tT ClASS="monofont">ios::showbase</TT>)
</Font></tD>
</TR>
<Tr>
<td vALIGn="top">
<fonT SIZe="2"><tt class="monofont">noshowbase</tt>
								</font></td>
<td valIGN="top">
<FONt SIzE="2">Does not indicate numeric base (clears the flag <Tt CLASS="monofont">ios::showbase</Tt>)
</fonT></TD>
</Tr>
</colGROUp>
</tabLE></P>

			
			<H4>13.7.6
Floating-Point Notation</h4>
				<p>Several flags and members control the output of floating-point values. The flags, presented in <a href="0201379260_snode107.html#23">Table 13.23</a>, define whether output is written using decimal or scientific notation. These flags are defined in the class <tt class="monofont">ios_base</tt> together with the corresponding mask. If <tt clASS="monofont">ios::fixed</TT> is set, floatingpoint values are printed using decimal notation. If <Tt CLaSS="monofont">ios::scientific</tT> is set scientific (that is, exponential) notation is used.</P>

				<A NAMe="23"></a><p><tABLE bordER="1" CEllspACINg="0" cellpadding="1" width="100%">
<captION><H5>Table 13.23. Flags for the Floating-Point Notation</H5></CaPTiON><cOLGROUp aliGN="left" SPan="3">
<tr>
<TH VAlign="top">
<FONT size="2"><b>Mask</b>
								</font></th>
<th valign="top">
<fONT SIZe="2"><B>Flag</B>
								</fONt></TH>
<TH VAlign="top">
<FONT size="2"><B>Meaning</B>
								</FOnt></th>
</TR>
<TR>
<td valign="top">
<font size="2"><tt claSS="monofont">floatfield</TT>
								</FOnT></Td>
<TD vALIGN="top">
<Font sIZE="2"><Tt claSS="monofont">fixed</TT>
								</font></TD>
<TD valign="top">
<font size="2">Uses decimal notation</font></td>
</tR>
<TR>
<TD VaLIgN="top">
<FoNT SIZE="2"> </font></TD>
<TD valiGN="top">
<FOnt siZE="2"><TT class="monofont">scientific</tt>
								</font></td>
<td valign="top">
<FONT SIzE="2">Uses scientific notation</FoNT></tD>
</TR>
<TR>
<Td valIGN="top">
<Font sIZE="2"> </Font></tD>
<TD Valign="top">
<font size="2">None</font></td>
<td VALIGN="top">
<fONt SIzE="2">Uses the "best" of these two notations (default)</FONT></Td>
</tr>
</cOLGRoup>
</tABLE></p>

				<p>To define the precision, the member function <tt CLASs="monofont">precision()</tt> is provided (see <a href="0201379260_snode107.html#24">Table 13.24</a>).</p>

				<a name="24"></a><p><tablE BORDEr="1" CElLSpACING="0" CellpADDIng="1" wiDTH="100%">
<CaptiON><H5>Table 13.24. Member Function for the Precision of Floating-Point Values</H5></caption><colgroup align="left" sPAN="2">
<TR>
<Th VAlIGn="top">
<FONT SIze="2"><b>Member Function</b>
								</FONT></th>
<th VALIgn="top">
<foNT SIze="2"><b>Meaning</b>
								</font></th>
</tr>
<tr>
<td valigN="top">
<FONT SiZE="2"><tT ClASS="monofont">precision()</TT>
								</Font></tD>
<TD ValigN="top">
<FONt sizE="2">Returns the actual precision of floating-point values</FONt></td>
</tr>
<tr>
<td valign="top">
<font siZE="2"><TT CLaSS="monofont">precision(val)</tT>
								</FoNT></TD>
<TD valiGN="top">
<FOnt siZE="2">Sets <I>val</I> as the new precision of floating-point values and returns the old
</font></TD>
</TR>
</colgroup>
</table></p>

				<p>If scientific notation is used, <tt clasS="monofont">precision()</TT> defines the number of decimal places in the fractional part. In all cases, the remainder is not cut off but rounded. Calling <TT ClASs="monofont">precision()</TT> without arguments returns the current precision. Calling it with an argument sets the precision to that value and returns the previous precision. The default precision is six decimal places.</p>

				<P>By default, neither <TT CLAss="monofont">ios::fixed</tt> nor <TT CLass="monofont">ios::scientific</tT> is set. In this case, the notation used depends on the value written. All meaningful but, at most, <TT Class="monofont">precision()</TT> decimal places are written as follows: A leading zero before the decimal point and/or all trailing zeros, and potentially even the decimal point, are removed. If <TT class="monofont">precision()</tt> places are sufficient, decimal notation is used; otherwise, scientific notation is used.</p>

				<p>Using the flag <tt class="monofont">showpoint,</tt> you can force the stream to write a decimal point and trailing zeros until <tt cLASS="monofont">precision()</TT> places are written (<a href="0201379260_snode107.html#25">Table 13.25</A>).</p>

				<A NAME="25"></A><p><tabLE BOrder="1" CELLspacING="0" Cellpadding="1" width="100%">
<captioN><H5>Table 13.25. Flags to Force Decimal Point</H5></CAPtIOn><COlGROUP Align="left" SPAN="2">
<tr>
<th VALIgn="top">
<foNT SIze="2"><b>Flag</b>
								</font></th>
<th valign="top">
<fonT SIZE="2"><B>Meaning</b>
								</FOnT></Th>
</TR>
<TR>
<TD valiGN="top">
<FOnt siZE="2"><TT clasS="monofont">showpoint</TT>
								</Font></td>
<td valign="top">
<font size="2">Always writes a decimal point</FONT></TD>
</tR>
</CoLGrOUP>
</TABle></p>

				<p><A href="0201379260_snode107.html#26">Table 13.26</a> shows the somewhat complicated dependencies between flags and precision, using two concrete values as an example.</p>

				<a NAME="26"></a><p><taBLE Border="1" cellspacing="0" cellpADDING="1" wIDtH="100%">
<CaPTION><H5>Table 13.26. Example of Floating-Point Formatting</h5></capTION><colgROUP aligN="left" SPAn="4">
<tr>
<th valign="top">
<font size="2"> </foNT></TH>
<TH vALiGN="top">
<fONT SIZe="2"><tt cLASS="monofont">precision()</tt>
								</foNT></TH>
<th vaLIGN="top">
<font size="2"><tt class="monofont">421.0</tt>
								</font></TH>
<TH VAlIGn="top">
<FOnT SIZE="2"><Tt claSS="monofont">0.0123456789</TT>
								</font></TH>
</TR>
<tr>
<td VALIgn="top">
<font size="2">Normal</font></td>
<td valIGN="top">
<FONt SIzE="2"><Tt CLASS="monofont">2</Tt>
								</fonT></TD>
<Td valIGN="top">
<Font sIZE="2"><Tt class="monofont">4.2e+02</tt>
								</font></td>
<td valigN="top">
<FONT SiZE="2"><tT ClASS="monofont">0.012</TT>
								</Font></tD>
</TR>
<Tr>
<td vALIGn="top">
<fonT SIZe="2"> </font></td>
<td valign="top">
<font siZE="2"><TT CLaSS="monofont">6</tT>
								</FoNT></TD>
<TD valiGN="top">
<FOnt siZE="2"><TT clasS="monofont">421</TT>
								</Font></td>
<td valign="top">
<font size="2"><TT CLASs="monofont">0.0123457</TT>
								</fONt></TD>
</TR>
<TR>
<td vaLIGN="top">
<font SIZE="2">With <tt clASS="monofont">showpoint</Tt>
								</font></td>
<td valign="top">
<font siZE="2"><TT CLaSS="monofont">2</tT>
								</FoNT></TD>
<TD valiGN="top">
<FOnt siZE="2"><TT clasS="monofont">4.2e+02</TT>
								</Font></td>
<td valign="top">
<font size="2"><TT CLASs="monofont">0.012</TT>
								</fONt></TD>
</TR>
<TR>
<td vaLIGN="top">
<font SIZE="2"> </font></TD>
<TD valign="top">
<font size="2"><tt class="monofont">6</TT>
								</FONT></tD>
<Td VAlIGN="top">
<FONt sizE="2"><TT Class="monofont">421.000</TT>
								</FOnt></td>
<TD VAlign="top">
<font size="2"><tt class="monofont">0.0123457</tt>
								</FONT></TD>
</tR>
<Tr>
<TD vALIGN="top">
<Font sIZE="2"><Tt claSS="monofont">fixed</TT>
								</font></TD>
<TD valign="top">
<font size="2"><tt class="monofont">2</TT>
								</FONT></tD>
<Td VAlIGN="top">
<FONt sizE="2"><TT Class="monofont">421.00</TT>
								</FOnt></td>
<TD VAlign="top">
<font size="2"><tt class="monofont">0.01</tt>
								</FONT></TD>
</tR>
<Tr>
<TD vALIGN="top">
<Font sIZE="2"> </Font></tD>
<TD ValigN="top">
<FONt size="2"><tt class="monofont">6</tt>
								</font></td>
<tD VALIGn="top">
<FOnT SiZE="2"><TT CLass="monofont">421.000000</tT>
								</FONt></td>
<tD VALign="top">
<fONT Size="2"><tt class="monofont">0.012346</tt>
								</font></td>
</tr>
<tR>
<TD VALiGN="top">
<fONt SIZE="2"><TT clasS="monofont">scientific</TT>
								</Font></tD>
<TD ValigN="top">
<FONt size="2"><tt class="monofont">2</tt>
								</font></td>
<tD VALIGn="top">
<FOnT SiZE="2"><TT CLass="monofont">4.21e+02</tT>
								</FONt></td>
<tD VALign="top">
<fONT Size="2"><tt class="monofont">1.23e-02</tt>
								</font></td>
</tr>
<tR>
<TD VALiGN="top">
<fONt SIZE="2"> </FOnt></td>
<TD VAlign="top">
<FONT size="2"><TT CLass="monofont">6</tt>
								</font></td>
<td valign="top">
<foNT SIZE="2"><tT ClASs="monofont">4.210000e+02</TT>
								</FONT></td>
<td VALIgn="top">
<foNT SIze="2"><tt CLASs="monofont">1.234568e-02</tt>
								</font></td>
</tr>
</colgroup>
</taBLE></P>

				<P>As for integral values, <Tt CLaSS="monofont">ios::showpos</tT> can be used to write a positive sign, <TT CLAss="monofont">ios::uppercase</tt> can be used to dictate whether the scientific notation should use an uppercase <TT CLass="monofont">E</tT> or a lowercase <TT Class="monofont">e.</TT></P>

				<P>The flag <tt class="monofont">ios::showpoint,</tt> the notation, and the precision can be configured using the manipulators presented in <a href="0201379260_snode107.html#27">Table 13.27</a>.</p>

				<p>For example, the statement</p>

				<pre>
					
   std::cout &lt;&lt; std::scientific &lt;&lt; std::showpoint
             &lt;&lt; std::setprecision(8)
             &lt;&lt; 0.123456789 &lt;&lt; std::endl;

				</PRE>

				<P>produces this output:</P>

				<PrE>
					
   1.23456789e-001

				</PrE>

				<A nAME="27"></A><P><Table BORDer="1" ceLLSPacinG="0" CELlpadding="1" width="100%">
<caption><h5>Table 13.27. Manipulators for Floating-Point Values</H5></CAPTIoN><CoLGrOUP ALIgn="left" spAN="2">
<TR>
<th vaLIGN="top">
<font SIZE="2"><b>Manipulator</b>
								</font></th>
<th valign="top">
<font sIZE="2"><B>Meaning</B>
								</FoNT></tH>
</Tr>
<TR>
<TD VAlign="top">
<FONT size="2"><TT CLass="monofont">showpoint</tT>
								</FONt></td>
<td valign="top">
<font size="2">Always writes a decimal point (sets the flag <tt CLASS="monofont">ios::showpoint</Tt>)
</FOnT></Td>
</TR>
<TR>
<TD valiGN="top">
<FOnt siZE="2"><TT clasS="monofont">noshowpoint</TT>
								</Font></td>
<td valign="top">
<font size="2">Does not require a decimal point (clears the flag <TT CLASs="monofont">showpoint</TT>)
</fONt></TD>
</TR>
<TR>
<td vaLIGN="top">
<font SIZE="2"><tt clASS="monofont">setprecision(val)</Tt>
								</font></td>
<td valign="top">
<font siZE="2">Sets <I>val</I> as the new value for the precision
</FOnT></Td>
</TR>
<tR>
<TD VALign="top">
<fONT Size="2"><tT CLAss="monofont">fixed</tt>
								</FONT></td>
<td valign="top">
<font size="2">Uses decimal notation</fonT></TD>
</TR>
<Tr>
<TD vALiGN="top">
<FONT size="2"><TT CLass="monofont">scientific</tT>
								</FONt></td>
<tD VALign="top">
<font size="2">Uses scientific notation</font></td>
</tr>
</coLGROUP>
</tABlE></P>

				<p><TT CLASs="monofont">setprecision()</tt> is a manipulator with an argument, so you must include the header file <tT CLAss="monofont">&lt;iomanip&gt;</tt> to use it.</P>

			
			<A NAme="28"></a><h4>13.7.7
General Formatting Definitions</H4>
				<P>Two more format flags complete the list of formatting flags: <TT class="monofont">skipws</tt> and <tt class="monofont">unitbuf</tt> (<a href="0201379260_snode107.html#29">Table 13.28</A>).</P>

				<A NAMe="29"></A><P><tABlE BORDEr="1" celLSPAcing="0" CELLpaddING="1" Width="100%">
<caption><h5>Table 13.28. Other Formatting Flags</h5></caption><cOLGROUp ALiGN="left" sPAN="2">
<TR>
<Th valIGN="top">
<Font sIZE="2"><B>Flag</b>
								</fonT></TH>
<Th valign="top">
<font size="2"><b>Meaning</b>
								</font></TH>
</TR>
<TR>
<tD VaLIgN="top">
<FONT Size="2"><tT CLAss="monofont">skipws</tt>
								</FONT></td>
<td VALIgn="top">
<font size="2">Skips leading whitespaces automatically when reading a value with operator <tt class="monofont">&gt;&gt;</tt>
								</foNT></TD>
</TR>
<tR>
<Td VAlIGN="top">
<FONt sizE="2"><TT Class="monofont">unitbuf</TT>
								</FOnt></td>
<TD VAlign="top">
<font size="2">Flushes the output buffer after each write operation</font></td>
</tr>
</cOLGROUp>
</TAbLE></p>

				<P><TT CLAss="monofont">ios::skipws</tt> is set by default, meaning that by default leading whitespaces are skipped by certain read operations. Normally, it is useful to have this flag set. For example, with it set, reading the separating spaces between numbers explicitly is not necessary. However, this implies reading space characters using operator <TT CLass="monofont">&gt;&gt;</tT> is not possible because leading whitespaces are always skipped.</P>

				<P><Tt claSS="monofont">ios::unitbuf</TT> controls the buffering of the output. With <tt class="monofont">ios::unitbuf</tt> set, output is basically unbuffered. The output buffer is flushed after each write operation. By default, this flag is not set. However, for the streams <tt class="monofont">cerr</tt> and <tt cLASS="monofont">wcerr</TT> this flag is set initially.</p>

				<P>Both flags can be manipulated using the manipulators presented in <A href="0201379260_snode108.html#1">Table 13.29</A>.</P>

			
		</FONT>
 
<table width="100%" border="0" cellspacing="0" cellpadding="0" bgcolor="#CCCCCC">
<td><font color="black" size=1>I l<font color="#FF0000">@</font>ve RuBoard</td>
<td valign="top" class="v2" align="right"><a href="0201379260_snode106.html"><img src="FILES/previous.gif" width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a> <a href="0201379260_snode108.html"><img src="FILES/next.gif" width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a></td></table>
</BODY></HTML>