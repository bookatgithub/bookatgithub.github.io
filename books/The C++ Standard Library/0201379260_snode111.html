<HTML><HEAD><META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=iso-8859-1">
<!--SafClassName="docSection1Title"--><!--SafTocEntry="13.11 Stream Classes for Strings"-->
<LINK REL="stylesheet" href="FILES/sbolM.css">
</HEAD>
<BODY link="#354278" vlink="#000066" alink="#000080" topmargin="0">
<table width="100%" border="0" cellspacing="0" cellpadding="0" bgcolor="#CCCCCC">
<td><font color="black" size=1>I l<font color="#FF0000">@</font>ve RuBoard</td>
<td valign="top" class="v2" align="right"><a href="0201379260_snode110.html"><img src="FILES/previous.gif" width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a> <a href="0201379260_snode112.html"><img src="FILES/next.gif" width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a></td></table>
<FONT><h3>13.11
Stream Classes for Strings</h3>
			<p>The mechanisms of stream classes can also be used to read from strings or to write to strings. String streams provide a buffer but don't have an I/O channel. This buffer/string can be manipulated with special functions. A major use of this is the processing of I/O independent of the actual I/O. For example, text for output can be formatted in a string and then sent to an output channel sometime later. Another use is reading input line-by-line and processing each line using string streams.</p>

			<P>The original stream classes for strings are replaced by a set of new ones in the C++ standard library. Formerly, the string stream classes used type <TT Class="monofont">char*</TT> to represent a string. Now, type <TT clasS="monofont">string</TT> (or in general <Tt class="monofont">basic_string&lt;&gt;</tt>) is used. The old string stream classes are also part of the C++ standard library, but they are deprecated. They are retained for backward compatibility, but they might be removed in future versions of the standard. Thus, they should not be used in new code and should be replaced in legacy code. Still, a brief description of these classes is found at the end of this section.</p>

			<h4>13.11.1
String Stream Classes</h4>
				<p>The following stream classes are defined for strings (they correspond to the stream classes for files):</p>

				<ul>
<li><p>The class <tt cLASS="monofont">basic_istringstream</TT> with the specializations <tT ClASs="monofont">istringstream</TT> and <TT CLass="monofont">wistringstream</tT> for reading from strings ("input string stream")</P>
</LI>
<li><p>The class <tT CLAss="monofont">basic_ostringstream</tt> with the specializations <TT CLass="monofont">ostringstream</tt> and <tt class="monofont">wostringstream</tt> for writing to strings ("output string stream")</p>
</li>
<li><p>The class <tT CLASS="monofont">basic_stringstream</tT> with the specializations <Tt CLaSS="monofont">stringstream</TT> and <TT clasS="monofont">wstringstream</TT> for reading from and writing to strings</P>
</li>
<li><P>The template class <TT Class="monofont">basic_stringbuf&lt;&gt;</TT> with the specializations <TT class="monofont">stringbuf</tt> and <tt class="monofont">wstringbuf</tt> is used by the other string stream classes to perform the actual reading and writing of characters.</p>

					</li>
</ul>
				<P>These classes have a similar relationship to the stream base classes, as do the file stream classes. The class hierarchy is depicted in <A href="0201379260_snode111.html#2">Figure 13.3</a>.</P>

				<CeNTeR>
					<H5>
<A NAMe="2"></a>Figure 13.3. Class Hierarchy of the String Stream Classes</h5><iMG BOrder="0" WIDTh="500" heiGHT="432" src="FILES/13fig03.gif" alt="graphics/13fig03.gif"></center>

				<p>The classes are declared in the header file <tt class="monofont">&lt;sstream&gt;</tt> like this:</P>

				<PRE>
					
   namespace std {
       template &lt;class charT,
                 class traits = char_traits&lt;charT&gt;,
                 class Allocator = allocator&lt;charT&gt; &gt;
         class basic_istringstream;
       typedef basic_istringstream&lt;char&gt;    istringstream;
       typedef basic_istringstream&lt;wchar_t&gt; wistringstream;

       template &lt;class charT,
                 class traits = char_traits&lt;charT&gt;,
                 class Allocator = allocator&lt;charT&gt; &gt;
                 class basic_ostringstream;
               typedef basic_ostringstream&lt;char&gt;    ostringstream;
               typedef basic_ostringstream&lt;wchar_t&gt; wostringstream;

               template &lt;class charT,
                         class traits = char_traits&lt;charT&gt;,
                         class Allocator = allocator&lt;charT&gt; &gt;
                 class basic_stringstream;
               typedef basic_stringstream&lt;char&gt;    stringstream;
               typedef basic_stringstream&lt;wchar_t&gt; wstringstream;

               template &lt;class charT,
                         class traits = char_traits&lt;charT&gt;,
                         class Allocator = allocator&lt;charT&gt; &gt;
                 class basic_stringbuf;
               typedef basic_stringbuf&lt;char&gt;    stringbuf;
               typedef basic_stringbuf&lt;wchar_t&gt; wstringbuf;
   }

				</PRe>

				<P>The major function in the interface of the string stream classes is the member function <Tt CLaSS="monofont">str().</TT> This function is used to manipulate the buffer of the string stream classes (<A href="0201379260_snode111.html#3">Table 13.39</a>).</P>

				<A NAme="3"></a><p><TABLe borDER="1" Cellspacing="0" cellpadding="1" WIDTH="100%">
<CaPTiON><h5>Table 13.39. Fundamental Operations for String Streams</H5></CAPTIon><coLGROup alIGN="left" Span="2">
<tR>
<TH Valign="top">
<font size="2"><b>Member Function</b>
								</font></th>
<TH VALIgN="top">
<FoNT sIZE="2"><B>Meaning</B>
								</Font></tH>
</TR>
<Tr>
<td vALIGn="top">
<fonT SIZe="2"><tt class="monofont">str()</tt>
								</font></td>
<td valIGN="top">
<FONt SIzE="2">Returns the buffer as a string</FoNT></TD>
</TR>
<tr>
<td VALIgn="top">
<foNT SIze="2"><tt CLASs="monofont">str</tt><i>(string)</i>
								</font></td>
<td valign="top">
<foNT SIZE="2">Sets the contents of the buffer to <i>string</I>
								</FoNT></tD>
</TR>
</COLgrouP>
</TABle></p>

				<p>The following program demonstrates the use of string streams:</P>

				<PRE>
					
   <i>// io/sstr1.cpp</i>

   #include &lt;iostream&gt;
   #include &lt;sstream&gt;
   #include &lt;bitset&gt;
   using namespace std;

   int main()
   {
       ostringstream os;

       <i>// decimal and hexadecimal value</i>
       os &lt;&lt; "dec: " &lt;&lt; 15 &lt;&lt; hex &lt;&lt; " hex: " &lt;&lt; 15 &lt;&lt; endl;
       cout &lt;&lt; os.str() &lt;&lt; endl;

       <I>// append floating value and bitset</I>
       bitset&lt;15&gt; b(5789);
       os &lt;&lt; "float: " &lt;&lt; 4.67 &lt;&lt; " bitset: " &lt;&lt; b &lt;&lt; endl;

       <I>//overwrite with octal value</I>
       os.seekp(0);
       os &lt;&lt; "oct: " &lt;&lt; oct &lt;&lt; 15;
       cout &lt;&lt; os.str() &lt;&lt; endl;
   }

				</pre>

				<p>The output of this program is as follows:</p>

				<pre>
					
   dec: 15 hex: f

   oct: 17 hex: f
   float: 4.67 bitset: 001011010011101

				</pre>

				<p>First a decimal and a hexadecimal value are written to <tt class="monofont">os.</tt> Next a floating-point value and a bitset (written in binary) are appended. Using <TT CLASs="monofont">seekp(),</TT> the write position is moved to the beginning of the stream. So, the following call of operator <tT ClASS="monofont">&lt;&lt;</TT> writes at the beginning of the string, thus overwriting the beginning of the existing string stream. However, the characters that are not overwritten remain valid. If you want to remove the current contents from the stream, you can use the function <Tt claSS="monofont">str()</TT> to assign new contents to the buffer:</p>

				<pre>
					
   strm.str(" ");

				</PRE>

				<P>The first lines written to <tt clASS="monofont">os</Tt> are each terminated with <tt class="monofont">endl.</tt> This means that the string ends with a newline. Because the string is printed followed by <tt class="monofont">endl,</tt> two adjacent newlines are written. This explains the empty lines in the output.</p>

				<p>A typical programming error when dealing with string streams is to forget to extract the string with the function <TT CLASs="monofont">str(),</TT> and instead to write to the stream directly. This is, from a compiler's point of view, a possible and reasonable thing to do in that there is a conversion to <tT ClASS="monofont">void*.</TT> As a result, the state of the stream is written in the form of an address (see page 596).</P>

				<p>A typical use for writing to an output string stream is to define output operators for user-defined types (see <a href="0201379260_snode112.html#1">Section 13.12.1</A>).</P>

				<p>Input string streams are used mainly for formatted reading from existing strings. For example, it is often easier to read data line-by-line and then analyze each line individually. The following lines read the integer <tt cLASS="monofont">x</tt> with the value <tt CLASs="monofont">3</tt> and the floating-point <tt class="monofont">f</tt> with the value <tt class="monofont">0.7</tt> from the string <TT CLASs="monofont">s:</TT></p>

				<PRe>
					
   int x;
   float f;
   std::string s = "3.7";

   std::istringstream is(s);
   is &gt;&gt; x &gt;&gt; f;

				</PRE>

				<P>A string stream can be created with the flags for the file open modes (see <A href="0201379260_snode109.html#3">Section 13.9.1</a>,) and/or an existing string. With the flag <TT CLass="monofont">ios::app</tT> or <TT Class="monofont">ios::ate,</TT> the characters written to a string stream can be appended to an existing string:</P>

				<Pre>
					
   std::string s;
   ...
   std::ostringstream os (s, ios::out|ios::app);
   os &lt;&lt; 77 &lt;&lt; std::hex &lt;&lt; 77;

				</pre>

				<p>However, this means that the string returned from <tt class="monofont">str()</tt> is a copy of the string <tt clasS="monofont">s,</TT> with a decimal and a hexadecimal version of <TT ClASs="monofont">77</TT> appended. The string s itself is not modified.</p>

			
			<H4>13.11.2
<TT CLAss="monofont">char*</tt> Stream Classes</H4>
				<P>The <TT clasS="monofont">char*</TT> stream classes are retained only for backward compatibility. Their interface is error prone and they are rarely used correctly. However, they are still in heavy use and thus are described briefly here. Note that the standard version described here has slightly modified the old interface.</P>

				<p>In this subsection, the term <i>character sequence</i> will be used instead of <i>string.</I> This is because the character sequence maintained by the <TT Class="monofont">char*</tt> stream classes is not always terminated with the string termination character (and thus it is not really a string).</p>

				<p>The <tt class="monofont">char*</tt> stream classes are defined only for the character type <tt clASS="monofont">char.</TT> They include</P>

				<uL>
<Li><P>The class <Tt CLASS="monofont">istrstream</Tt> for reading from character sequences (input string stream)</p>
</li>
<LI><P>The class <Tt claSS="monofont">ostrstream</TT> for writing to character sequences (output string stream)</p>
</li>
<lI><P>The class <TT class="monofont">strstream</tt> for reading from and writing to character sequences</p>
</li>
<li><p>The class <tt class="monofont">strstreambuf</tT> used as a stream buffer for <TT CLAsS="monofont">char*</Tt> streams</P>

					</Li>
</UL>
				<P>The <TT Class="monofont">char*</TT> stream classes are defined in the header file <TT clasS="monofont">&lt;strstream&gt;.</TT></P>

				<p>An <tt cLASS="monofont">istrstream</tt> can be initialized with a character sequence (of type <tt class="monofont">char*</tt>) that is either terminated with the string termination character <tt class="monofont">0</tt> or for which the number of characters is passed as the argument. A typical use is the reading and processing of whole lines:</p>

				<PRE>
					
    char buffer [1000] ;     <I>// buffer for at most 999 characters</I>

    <I>// read line</i>
    std::cin.get(buffer,sizeof(buffer));

    <I>// read/process line as stream</I>
    std::istrstream input(buffer);
    ...
    input &gt;&gt; x;

				</pRE>

				<p>A <TT CLASs="monofont">char*</tt> stream for writing can either maintain a character sequence that grows as needed or it can be initialized with a buffer of fixed size. Using the flag <tT CLAss="monofont">ios::app</tt> or <TT CLass="monofont">ios:ate,</tT> you can append the characters written to a character sequence that is already stored in the buffer.</P>

				<P>Care must be taken when using <Tt class="monofont">char*</tt> stream as a string. In contrast to string streams, <tt class="monofont">char*</tt> streams are not always responsible for the memory used to store the character sequence.</p>

				<p>With the member function <tt CLASS="monofont">str(),</Tt> the character sequence is made available to the caller together with the responsibility for the corresponding memory. Unless the stream is initialized with a buffer of fixed size (for which the stream is never responsible), the following three rules have to be obeyed:</P>

				<Ol TYpE="1" START="restarts">
<li><p>Because ownership of the memory is transferred to the caller, unless the stream was initialized with a buffer of fixed size, the character sequence has to be released. However, there is no guarantee how the memory was allocated,<fONT Size="1"><sUP><A Href="#FOOTNOTE-11">[11]</a></SUP></Font>
 thus it is not always safe to release it using <tt class="monofont">delete[].</tt> Your best bet is to return the memory to the stream by calling the member function <tt class="monofont">freeze()</tt> with the argument <TT CLASs="monofont">false</TT> (the following paragraphs present an example).</p>
<BLoCKQUOTe><fonT SIZe="1">
<p clASS="footnote">
<Sup><a nAME="FOOTNOTE-11">[11]</A></sup>
There is actually a constructor that takes two function pointers as an argument: a function to allocate memory and a function to release memory.</p>
</font></blockquote>

							</li>
<lI><P>With the call to <TT CLaSS="monofont">str(),</tT> the stream is no longer allowed to modify the character sequence. It calls the member function <Tt CLASS="monofont">freeze()</Tt> implicitly, which freezes the character sequence. The reason for this is to avoid complications if the allocated buffer is not sufficiently large and new memory has to be allocated.</p>
</li>
<LI><P>The member function <Tt claSS="monofont">str()</TT> does <i>not</i> append a string termination character (<tt CLASs="monofont">'\0'</tt>). This character has to be appended explicitly to the stream to terminate the character sequence. This can be done using the ends manipulator. Some implementations append a string termination character automatically, but this behavior is not portable.</p>

					</li>
</ol>

				<p>The following example demonstrates the use of a <tt class="monofont">char*</tt> stream:</p>

				<prE>
					
   float x;
   ...
   <I>/* create and fill char* stream</I>
   <I>/* - don't forget ends or '\0' !!!</I>
    <I>*/</i>
   std::ostrstream buffer;     <I>// dynamic stream buffer</I>
   buffer &lt;&lt; "float x: " &lt;&lt; x &lt;&lt; std::ends;

   <i>// pass resulting C-string to</I> foo() <I>and return memory to buffer</i>
   char* s = buffer.str();
   foo(s);
   buffer.freeze(false);

				</PRE>

				<P>A frozen <TT clasS="monofont">char*</TT> stream can be restored to its normal state for additional manipulation. To do so, the member function <Tt claSS="monofont">freeze()</TT> has to be called with the argument <tt clASS="monofont">false.</Tt> With this operation, ownership of the character sequence is returned to the stream object. This is the only safe way to release the memory for the character sequence. The next example demonstrates this:</p>

				<pre>
					
    float x;
    ...
    std::ostrstream buffer;       <i>// dynamic char* stream</i>

    <i>// fill char* stream</i>
    buffer &lt;&lt; "float x: " &lt;&lt; x &lt;&lt; std::ends;

    <i>/* pass resulting C-string to foo()</i>
     <i>* - freezes the char* stream</i>
     <i>*/</i>
    foo(buffer.str());

    <i>// unfreeze the char* stream</i>
    buffer.freeze(false);

    <i>// seek writing position to the beginning</i>
    buffer.seekp (0, ios::beg);

    <i>// refill char* stream</i>
    buffer &lt;&lt; "once more float x: " &lt;&lt; x &lt;&lt; std::ends;

    <I>/* pass resulting C-string to foo() again</I>
     <I>* - freezes the char* stream</I>
     <I>*/</I>
    foo(buffer.str());

    <i>// return memory to buffer</I>
    buffer.freeze(false);

				</PrE>

				<P>The problems related to freezing the stream are removed from the string stream classes. This is mainly because the strings are copied and because the string class takes care of the used memory.</p>

			
		</FONT>
 
<table width="100%" border="0" cellspacing="0" cellpadding="0" bgcolor="#CCCCCC">
<td><font color="black" size=1>I l<font color="#FF0000">@</font>ve RuBoard</td>
<td valign="top" class="v2" align="right"><a href="0201379260_snode110.html"><img src="FILES/previous.gif" width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a> <a href="0201379260_snode112.html"><img src="FILES/next.gif" width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a></td></table>
</BODY></HTML>