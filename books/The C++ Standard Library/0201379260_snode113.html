<HTML><HEAD><META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=iso-8859-1">
<!--SafClassName="docSection1Title"--><!--SafTocEntry="13.13 The Stream Buffer Classes"-->
<LINK REL="stylesheet" href="FILES/sbolM.css">
</HEAD>
<BODY link="#354278" vlink="#000066" alink="#000080" topmargin="0">
<table width="100%" border="0" cellspacing="0" cellpadding="0" bgcolor="#CCCCCC">
<td><font color="black" size=1>I l<font color="#FF0000">@</font>ve RuBoard</td>
<td valign="top" class="v2" align="right"><a href="0201379260_snode112.html"><img src="FILES/previous.gif" width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a> <a href="0201379260_snode114.html"><img src="FILES/next.gif" width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a></td></table>
<FONT><h3>13.13
The Stream Buffer Classes</h3>
			<p>As mentioned in <a href="0201379260_snode102.html#1">Section 13.2.1</a>, the actual reading and writing is not done by the streams directly, but is delegated to stream buffers. This section describes how these classes operate. The discussion not only gives a deeper understanding of what is going on when I/O streams are used, but also provides the basis to define new I/O channels. Before going into the details of stream buffer operation, the public interface is presented for those only interested in using stream buffers.</p>

			<a nAME="1"></A><h4>13.13.1
User's View of Stream Buffers</h4>
				<p>To the user of a stream buffer the class <tT CLAss="monofont">basic_streambuf</tt> is not much more than something that characters can be sent to or extracted from. <a href="0201379260_snode113.html#2">Table 13.41</a> lists the public function for writing characters.</p>

				<a name="2"></a><p><tabLE BORDeR="1" CeLLsPACING="0" cellPADDing="1" wIDTH="100%">
<captION><H5>Table 13.41. Public Members for Writing Characters</h5></caption><colgroup align="left" SPAN="2">
<TR>
<tH VaLIgN="top">
<FONT Size="2"><b>Member Function</B>
								</FONt></th>
<tH VALign="top">
<fONT Size="2"><b>Meaning</b>
								</font></th>
</tr>
<tr>
<td valiGN="top">
<FONT sIZe="2"><TT cLASS="monofont">sputc</TT><i>(c)</i>
								</foNT></TD>
<td vaLIGN="top">
<font SIZE="2">Sends the character <i>c</i> to the stream buffer
</font></td>
</tr>
<tr>
<td valign="top">
<fONT SIZe="2"><TT cLAsS="monofont">sputn</TT><I>(s, n)</I>
								</Font></tD>
<TD ValigN="top">
<FONt sizE="2">Sends <I>n</I> character from the sequence <I>s</i> to the stream buffer
</font></td>
</tr>
</colgroup>
</tablE></P>

				<P>The function <TT ClASs="monofont">sputc()</TT> returns <tT CLASS="monofont">traits_type::eof()</tt> in case of an error, where <tt CLASs="monofont">traits_type</tt> is a type definition in the class <tT CLAss="monofont">basic_streambuf.</tt> The function <TT CLass="monofont">sputn()</tt> writes the number of characters specified by the second argument unless the stream buffer cannot consume them. It does not care about string termination characters. This function returns the number of characters written.</p>

				<p>The interface to reading characters from a stream buffer is a little bit more complex (<a href="0201379260_snode113.html#3">Table 13.42</a>). This is because for input it is necessary to have a look at a character without consuming it. Also, it is desirable that characters can be put back into the stream buffer when parsing. Thus, the stream buffer classes provide corresponding functions.</p>

				<a name="3"></a><p><TABLE BoRDeR="1" CeLLSPACing="0" cELLPaddiNG="1" WIdth="100%">
<cAPTIon><h5>Table 13.42. Public Members for Reading Characters</h5></caption><colgroup alIGN="left" SPAn="2">
<TR>
<tH VaLIGN="top">
<FOnt siZE="2"><B>Member Function</B>
								</font></TH>
<TH valiGN="top">
<FOnt size="2"><b>Meaning</b>
								</font></th>
</tr>
<tr>
<td vALIGN="top">
<FoNT sIZe="2"><TT CLASs="monofont">in_avail()</tt>
								</fONT></Td>
<td vALIGn="top">
<fonT SIZe="2">Returns a lower bound on the characters available</font></td>
</tr>
<tr>
<td valign="top">
<foNT SIZE="2"><tT ClASs="monofont">sgetc()</TT>
								</FONT></td>
<td VALIgn="top">
<foNT SIze="2">Returns the current character without consuming it</foNT></TD>
</tr>
<tr>
<td valign="top">
<font size="2"><tT CLASS="monofont">sbumpc()</tT>
								</FoNT></tD>
<TD VALign="top">
<fONT Size="2">Returns the current character and consumes it</fONT></Td>
</tr>
<tR>
<TD Valign="top">
<font size="2"><tt class="monofont">snextc()</tT>
								</FONT></Td>
<TD vALiGN="top">
<FONT size="2">Consumes the current character and returns the next character</FONT></td>
</tr>
<TR>
<TD valiGN="top">
<FOnt size="2"><tt class="monofont">sgetn</tt><i>(b, n)</i>
								</font></TD>
<TD VAlIGn="top">
<FOnT SIZE="2">Reads <I>n</i> characters and stores them in the buffer <i>b</i>
								</fONT></Td>
</tr>
<tR>
<TD ValigN="top">
<FONt size="2"><tt class="monofont">sputbackc</tt><i>(c)</i>
								</font></tD>
<TD VALiGN="top">
<fONt SIZE="2">Returns the character <I>c</I> to the stream buffer
</font></TD>
</TR>
<tr>
<td VALIgn="top">
<foNT SIze="2"><tt class="monofont">sungetc()</tt>
								</font></td>
<td vaLIGN="top">
<FOnT SiZE="2">Steps one step back to the previous character</fONT></TD>
</Tr>
</colGROUp>
</tabLE></P>

				<P>The function <tt clASS="monofont">in_avail()</Tt> can be used to determine how many characters are at least available. This can be used, for example, to make sure that reading does not block when reading from the keyboard. However, there can be more characters available.</p>

				<p>Until the stream buffer has reached the end of the stream, there is a current character. The function <tt class="monofont">sgetc()</tt> is used to get the current character without moving on to the next character. The function <tt class="monofont">sbumpc()</tt> reads the current character and moves on to next character, making this the new current character. The last function reading a single character, <TT CLASs="monofont">snextc()</TT> makes the next character the current one and then reads this character. All three functions return <tT ClASS="monofont">traits_type::eof()</TT> to indicate failure. The function <Tt claSS="monofont">sgetn()</TT> reads a sequence of characters into a buffer. The maximum number of characters to be read is passed as an argument. The function returns the number of characters read.</p>

				<p>The two functions <tt CLASs="monofont">sputbackc()</tt> and <tT CLAss="monofont">sungetc()</tt> are used to move one step back, making the previous character the current one. The function <tt class="monofont">sputbackc()</tt> can be used to replace the previous character by some other character. These two functions should only be used with care. Often it is only possible to put back just one character.</p>

				<p>Finally, there are functions to access the imbued locale object, to change the position, and to influence buffering. <a href="0201379260_snode113.html#4">Table 13.43</a> lists these functions.</P>

				<A NAME="4"></a><P><TaBLe BORDER="1" cellSPACing="0" cELLPaddiNG="1" WIdth="100%">
<caption><h5>Table 13.43. Miscellaneous Public Stream Buffer Functions</h5></caption><coLGROUP aLIgN="left" SpAN="2">
<TR>
<TD valiGN="top">
<FOnt siZE="2"><B>Member Function</B>
								</font></TD>
<TD valign="top">
<font size="2"><b>Meaning</b>
								</font></tD>
</TR>
<TR>
<Td VAlIGn="top">
<FONT SIze="2"><tt CLASs="monofont">pubimbue</tt>(<i>loc</I>)
</FONt></td>
<tD VALign="top">
<font size="2">Imbues the stream buffer with the locale <i>loc</i>
								</font></td>
</tr>
<TR>
<TD VAlIGn="top">
<FOnT SIZE="2"><Tt claSS="monofont">getloc()</TT>
								</font></TD>
<TD valiGN="top">
<FOnt size="2">Returns the current locale</font></td>
</tr>
<tr>
<td valIGN="top">
<FONt SIzE="2"><Tt CLASS="monofont">Pubseekpos</Tt>(<i>pos</i>
								</fONT></Td>
<td vALIGn="top">
<fonT SIZe="2">Repositions the current position to an absolute position</font></td>
</tr>
<tr>
<td valign="top">
<foNT SIZE="2"><tT ClASs="monofont">pubseekpos</TT>(<I>pos, which</I>)
</FOnt></td>
<TD VAlign="top">
<FONT size="2">Same with specifying the I/O direction</FONT></td>
</tr>
<tr>
<td valign="top">
<font sizE="2"><TT CLAsS="monofont">pubseekoff</Tt>(<I>offset, rpos</I>)
</fONT></TD>
<Td valIGN="top">
<Font sIZE="2">Repositions the current position relative to another position</Font></tD>
</TR>
<Tr>
<td valign="top">
<font size="2"><tt clASS="monofont">pubseekoff</TT>(<I>offset, rpos, which</i>)
</FOnT></Td>
<TD VALIgn="top">
<foNT SIze="2">Same with specifying the I/O direction</foNT></TD>
</tr>
<tr>
<TD VAlign="top">
<font size="2"><tt class="monofont">pubsetbuf</tt>(<I>b, n</I>)
</FONT></tD>
<Td VAlIGN="top">
<FONt sizE="2">Influences buffering</FONt></td>
</tR>
</COLgrouP>
</TABle></p>

				<p><tt class="monofont">pubimbue()</tt> and <tt class="monofont">getloc()</tT> are used for internationalization (see page 625). <TT CLAsS="monofont">pubimbue()</Tt> installs a new locale object in the stream buffer returning the previously installed locale object. <TT cLASS="monofont">getloc()</TT> returns the currently installed locale object.</p>

				<p>The function <tt CLASs="monofont">pubsetbuf()</tt> is intended to provide some control over the buffering strategy of stream buffers. However, whether it is honored depends on the concrete stream buffer class. For example, it makes no sense to use <tT CLAss="monofont">pubsetbuf()</tt> for string stream buffers. Even for file stream buffers the use of this function is only portable if it is called before the first I/O operation is performed and if it is called as <TT CLass="monofont">pubsetbuf(0,0)</tt> (that is, no buffer is to be used). This function returns 0 on failure and the stream buffer otherwise.</p>

				<p>The functions <tt class="monofont">pubseekoff()</tt> and <tt claSS="monofont">pubseekpos()</TT> are used to manipulate the current position used for reading and/or writing. Which position is manipulated depends on the last argument, which is of type <TT cLAsS="monofont">ios_base::openmode</Tt> and which defaults to <TT CLASs="monofont">ios_base::in|ios_base::out</tt> if it is not specified. If <tT CLAss="monofont">ios_base::in</tt> is set, the read position is modified. Correspondingly, the write position is modified if <TT CLass="monofont">ios_base::out</tT> is set. The function <TT Class="monofont">pubseekpos()</tt> moves the stream to an absolute position specified as the first argument whereas the function <tt class="monofont">pubseekoff()</tt> moves the stream relative to some other position. The offset is specified as the first argument. The position used as starting point is specified as the second argument and can be either <tt clasS="monofont">ios_base::cur, ios_base::beg,</TT> or <TT ClASs="monofont">ios_base::end</TT> (see page 635 for details). Both functions return the position to which the stream was positioned or an invalid stream position. The invalid stream position can be detected by comparing the result with the object <tT CLASS="monofont">pos_type(off_type(-1)</tt>) (<tt CLASs="monofont">pos_type and off_type</tt> are types for handling stream positions; see page 634). The current position of a stream can be obtained using <tT CLAss="monofont">pubseekoff():</tt></P>

				<PRE>
					
   sbuf.pubseekoff(0, std::ios::cur)

				</pre>

			
			<a name="5"></a><h4>13.13.2
Stream Buffer Iterators</h4>
				<p>An alternative way to use a member function for unformatted I/O is to use the stream buffer iterator classes. These classes provide iterators that conform to input iterator or output iterator requirements and read or write individual characters from stream buffers. This fits character-level I/O into the algorithm library of the C++ standard library.</p>

				<p>The template classes <tt class="monofont">istreambuf_iterator</TT> and <TT CLaSS="monofont">ostreambuf_iterator</tT> are used to read or to write individual characters from or to objects of type <Tt CLASS="monofont">basic_streambuf.</Tt> The classes are defined in the header <tt cLASS="monofont">&lt;iterator&gt;</tt> like this:</p>

				<pRE>
					
   namespace std {
       template &lt;class charT,
                 class traits = char_traits&lt;charT&gt; &gt;
       istreambuf_iterator;
       template &lt;class charT,
                 class traits = char_traits&lt;charT&gt; &gt;
       ostreambuf_iterator;
   }

				</PRe>

				<p>These iterators are special forms of stream iterators, which are described in <a href="0201379260_snode62.html#16">Section 7.4.3</A>. The only difference is that their elements are characters.</p>

				<h5>Output Stream Buffer Iterators</h5>
					<p>Here is how a string can be written to a stream buffer using an <tt class="monofont">ostreambuf_iterator:</tt></p>

					<pre>
						
   <i>// create iterator for buffer of output stream cout</i>
   std::ostreambuf_iterator&lt;char&gt; bufWriter(std::cout);

   std::string hello("hello, world\n");
   std::copy(hello.begin(), hello.end(),  <i>// source: string</i>
             bufWriter);                  <I>// destination: output buffer of cout</I>

					</PRE>

					<P>The first line of this example constructs an output iterator of type <tT ClASs="monofont">ostreambuf_iterator</TT> from the object <TT CLass="monofont">cout.</tT> Instead of passing the output stream you could also pass a pointer to the stream buffer directly. The remainder constructs a <TT Class="monofont">string</TT> object and copies the characters in this object to the constructed output iterator.</P>

					<P><a href="0201379260_snode113.html#7">Table 13.44</A> lists all operations of output stream buffer iterators. The implementation is similar to ostream iterators (see page 278). In addition, you can initialize the iterator with a buffer and you can call <TT class="monofont">failed()</tt> to query whether the iterator is able to write. If any prior writing of a character failed, <tt class="monofont">failed()</tt> yields true. In this case, any writing with operator <tt claSS="monofont">=</TT> has no effect.</P>

					<A nAMe="7"></A><P><tABLE BOrder="1" CELLspacING="0" CellpADDIng="1" width="100%">
<caption><h5>Table 13.44. Operations of Output Stream Buffer Iterators</h5></captiON><COLGrOUp ALiGN="left" SPAN="2">
<tr>
<th VALIgn="top">
<foNT SIze="2"><b>Expression</b>
									</FONT></th>
<th valign="top">
<font size="2"><b>Effect</b>
									</fONT></TH>
</Tr>
<TR>
<tD VaLIGN="top">
<FOnt siZE="2"><TT clasS="monofont">ostreambuf_iterator</TT><I>&lt;char&gt;(ostream)</i>
									</fonT></TD>
<Td valign="top">
<font size="2">Creates an output stream buffer iterator for <i>ostream</i>
									</font></TD>
</TR>
<TR>
<tD VaLIgN="top">
<FONT Size="2"><tT CLAss="monofont">ostreambuf_iterator</tt><I>&lt;char&gt;</I>(<I>buffer_ptr</I>)
</font></TD>
<TD valign="top">
<font size="2">Creates an output stream buffer iterator for the buffer to which <i>buffer_ptr</i> refers
</font></tD>
</TR>
<TR>
<Td VAlIGn="top">
<FONT SIze="2"><i>*iter</i>
									</FONT></td>
<td VALIgn="top">
<foNT SIze="2">No-op (returns <i>iter</i>)
</font></td>
</tr>
<tr>
<td valigN="top">
<FONT SiZE="2"><i>iter = c</I>
									</FoNT></TD>
<TD valiGN="top">
<FOnt siZE="2">Writes character <I>c</I> to the buffer by calling sputc(<i>c</i>) for it
</foNT></TD>
</tr>
<tr>
<td valign="top">
<font size="2"><i>++iter</I>
									</FONT></Td>
<TD vALiGN="top">
<FONT size="2">No-op (returns <I>iter</I>)
</FOnt></td>
</TR>
<TR>
<td vaLIGN="top">
<font size="2"><i>iter++</i>
									</font></td>
<td valIGN="top">
<FONt SIzE="2">No-op (returns <I>iter</i>)
</FONT></TD>
</tr>
<tr>
<TD VAlign="top">
<FONT size="2"><TT CLass="monofont">failed()</tt>
									</font></td>
<td valign="top">
<foNT SIZE="2">Returns whether the output stream iterator is not able to write anymore</fONt></TD>
</tR>
</COLGRoup>
</tABLE></p>

				
				<h5>Input Stream Buffer Iterators</h5>
					<p><A href="0201379260_snode113.html#9">Table 13.45</a> lists all operations of input stream buffer iterators. The implementation is similar to istream iterators (see page 280). In addition, you can initialize the iterator with a buffer, and a member function, <tt CLASs="monofont">equal(),</tt> is provided, which returns whether two input stream buffer iterators are equal. Two input stream buffer iterators are equal when they are both end-of-stream iterators or when neither is an end-of-stream iterator.</p>

					<p>What is somewhat obscure is what it means for two objects of type <tt class="monofont">istreambuf_iterator</tt> to be equivalent: Two <tt class="monofont">istreambuf_iterator</TT> objects are equivalent if both iterators are end-of-stream iterators or if neither of them is an end-of-stream iterator (whether the output buffer is the same doesn't matter). One possibility to get an end-of-stream iterator is to construct an iterator with the default constructor. In addition, an <TT CLaSS="monofont">istreambuf_iterator</tT> becomes an end-of-stream iterator when an attempt is made to advance the iterator past the end of the stream (in other words, if <Tt CLASS="monofont">sbumpc()</Tt> returns <tt cLASS="monofont">traits_type::eof().</tt> This behavior has two major implications:</p>

					<a NAME="9"></a><p><taBLE Border="1" cellspacing="0" cellpADDING="1" wIDtH="100%">
<CaPTION><H5>Table 13.45. Operations of Input Stream Buffer Iterators</h5></capTION><colgROUP aligN="left" SPAn="2">
<tr>
<th valign="top">
<font size="2">
										<p><b>Expression</B></P>

									</FONT></tH>
<Th VAlIGN="top">
<FONt sizE="2">
										<P><B>Effect</B></p>

									</fonT></TH>
</Tr>
<tr>
<tD VALign="top">
<font size="2">
										<p><tt class="monofont">istreambuf _iterator</tt><I>&lt;char&gt;()</I></P>

									</FONt></TD>
<tD VaLIGN="top">
<FOnt siZE="2">
										<P>Creates an end-of-stream iterator</P>

									</font></TD>
</TR>
<tr>
<td VALIgn="top">
<font size="2">
										<p><tt class="monofont">istreambuf_iterator</tt><i>&lt;char&gt;(istream)</I></P>

									</FONT></tD>
<Td VAlIGN="top">
<FONt sizE="2">
										<P>Creates an input stream buffer iterator for <I>istream</I> and might read the first character using <tt clASS="monofont">sgetc()</Tt></p>

									</foNT></TD>
</tr>
<tr>
<td valign="top">
<font size="2">
										<p><TT CLASs="monofont">istreambuf_iterator</TT><i>&lt;char&gt;</I>(<I>buffer_ptr</i>)</P>

									</FONT></Td>
<td vALIGn="top">
<fonT SIZe="2">
										<p>Creates an input stream buffer iterator for the buffer to which <i>buffer_ptr</i> refers and might read the first character using <TT CLass="monofont">sgetc()</tt></p>

									</font></td>
</tr>
<tr>
<td valIGN="top">
<FONt SIzE="2">
										<P><i>*iter</I></P>

									</FONT></td>
<td VALIgn="top">
<foNT SIze="2">
										<p>Returns the actual character, read with <tT CLAss="monofont">sgetc()</tt> before (reads the first character if not done by the constructor)</p>

									</font></td>
</tr>
<tr>
<td valiGN="top">
<FONT sIZe="2">
										<P><I>++iter</i></P>

									</FONT></Td>
<td vALIGn="top">
<fonT SIZe="2">
										<p>Reads the next character with <tt CLASs="monofont">sbumpc()</tt> and returns its position</p>

									</font></td>
</tr>
<tr>
<td valigN="top">
<FONT SiZE="2">
										<p><I>iter++</I></p>

									</FONT></TD>
<td vaLIGN="top">
<font SIZE="2">
										<p>Reads the next character with <tt cLASS="monofont">sbumpc()</tt> but returns an iterator for the previous character</p>

									</font></td>
</tr>
<tr>
<td valign="top">
<FONT SIzE="2">
										<P><i>iter1.</I><Tt CLASS="monofont">equal</Tt> (<i>iter2</i>)</p>

									</FONT></td>
<td VALIgn="top">
<foNT SIze="2">
										<p>Returns whether both iterators are equal</p>

									</font></td>
</tr>
<tr>
<td valigN="top">
<FONT SiZE="2">
										<p><I>iter1== iter2</I></p>

									</FONT></TD>
<td vaLIGN="top">
<font SIZE="2">
										<p>Tests <i>iter1</i> and <i>iter2</I> for equality</P>

									</FOnt></td>
</tr>
<tr>
<td valign="top">
<font sIZE="2">
										<P><I>iter1</I> !<i> = iter2</I></P>

									</fONt></TD>
<TD VAlign="top">
<FONT size="2">
										<P>Tests <I>iter1</I> and <I>iter2</i> for inequality</p>

									</foNT></TD>
</tr>
</colgroup>
</table></p>

					<ol typE="1" START="restarts">
<lI><P>A range from the current position in a stream to the end of the stream is defined by the two iterators <tT ClASS="monofont">istreambuf_iterator&lt;charT,traits&gt;</TT> (<I>stream</i>) (for the current position) and <tt cLASS="monofont">istreambuf_iterator&lt;charT,traits&gt;()</tt> (for the end of the stream), where <i>stream</i> is of type <TT CLass="monofont">basic_istream&lt;charT,traits&gt;</tT> or <TT Class="monofont">basic_streambuf&lt;charT,traits&gt;.</tt></p>
</li>
<li><p>It is not possible to create subranges using <tt class="monofont">istreambuf_iterators.</tt></P>

						</LI>
</OL>

				
				<H5>Example Use of Stream Buffer Iterators</h5>
					<P>The following example is the classic filter framework that simply writes all read characters with stream buffer iterators. It is a modified version of the example on page 611:</P>

					<pRE>
						
   <i>// io/charcat2.cpp</I>

   #include &lt;iostream&gt;
   #include &lt;iterator&gt;
   using namespace std;

   int main()
   {
       <I>// input stream buffer iterator for cin</I>
       istreambuf_iterator&lt;char&gt; inpos(cin);

       <I>// end-of-stream iterator</I>
       istreambuf_iterator&lt;char&gt; endpos;

       <I>// output stream buffer iterator for cout</i>
       ostreambuf_iterator&lt;char&gt; outpos(cout);

       <i>// while input iterator is valid</i>
       while (inpos != endpos) {
           *outpos = *inpos;    <i>// assign its value to the output iterator</I>
           ++inpos;
           ++outpos;
       }
   }

					</PRE>

				
			
			<a namE="11"></A><H4>13.13.3
User-Defined Stream Buffers</H4>
				<p>Stream buffers are buffers for I/O. Their interface is defined by class <tt cLASS="monofont">basic_streambuf&lt;&gt;.</tt> For the character types <tt class="monofont">char</tt> and <tt class="monofont">wchar_t,</tt> the specializations <tT CLASS="monofont">streambuf</tT> and <Tt CLaSS="monofont">wstreambuf,</TT> respectively, are predefined. These classes are used as base classes when implementing the communication over special I/O channels. However, doing this requires an understanding of the stream buffer's operation.</P>

				<P>The central interface to the buffers is formed by three pointers for each of the two buffers. The pointers returned from the functions <tt clASS="monofont">eback(), gptr(),</Tt> and <tt cLASS="monofont">egptr()</tt> form the interface to the read buffer. The pointers returned from the functions <tt CLASs="monofont">pbase(), pptr(),</tt> and <tt class="monofont">epptr()</tt> form the interface to the write buffer. These pointers are manipulated by the read and write operations, which may result in corresponding reactions in the corresponding read or write channel. The exact operation is examined separately for reading and writing.</p>

				<h5>User-Defined Output Buffers</h5>
					<p>A buffer used to write characters is maintained with three pointers that can be accessed by the three functions <tt claSS="monofont">pbase(), pptr(),</TT> and <TT cLAsS="monofont">epptr()</Tt> (<A href="0201379260_snode113.html#13">Figure 13.4</A>). Here is what these pointers represent:</p>

					<cenTER>
						<H5>
<a namE="13"></A>Figure 13.4. The Interface to the Output Buffer</H5><Img boRDER="0" width="500" height="137" src="FILES/13fig04.gif" alt="graphics/13fig04.gif"></centER>

					<OL TYpE="1" StARt="restarts">
<LI><P><TT Class="monofont">pbase()</TT>("put base") is the beginning of the output buffer.</P>
</Li>
<li><p><TT CLass="monofont">pptr()</tT>("put pointer") is the current write position.</P>
</LI>
<li><p><tt class="monofont">epptr()</tt>("end put pointer") is the end of the output buffer. This means that <tt class="monofont">epptr()</tt> points to one past the last character that can be buffered.</P>

						</LI>
</OL>

					<P>The characters in the range from <tT ClASs="monofont">pbase()</TT> to <TT CLass="monofont">pptr()</tT> (not including the character pointed to by <TT Class="monofont">pptr()</TT>) are already written but not yet transported (flushed) to the corresponding output channel.</P>

					<P>A character is written using the member function <tt clASS="monofont">sputc().</Tt> This character is copied to the current write position if there is a spare write position. Then the pointer to the current write position is incremented. If the buffer is full <tt class="monofont">(pptr() == epptr()</tt>), the contents of the output buffer are sent to the corresponding output channel. This is done by calling the virtual function <tt class="monofont">overflow().</tt> This function is effectively responsible for the actual sending of the characters to some "external representation" (which may actually be internal, as in the case of string streams). The implementation of <tt CLASS="monofont">overflow()</Tt> in the base class <TT cLAsS="monofont">basic_streambuf</TT> only returns end-of-file, which indicates that no more characters could be written.</P>

					<P>The member function <Tt claSS="monofont">sputn()</TT> can be used to write multiple characters at once. This function delegates the work to the virtual function <tt clASS="monofont">xsputn(),</Tt> which can be implemented for more efficient writing of multiple characters. The implementation of <tt cLASS="monofont">xsputn()</tt> in class <tt class="monofont">basic_streambuf</tt> basically calls <tt class="monofont">sputc()</tt> for each character. Thus, overriding <tT CLASS="monofont">xsputn()</tT> is not necessary. However, often, writing multiple characters can be implemented more efficiently than writing characters one at a time. Thus, this function can be used to optimize the processing of character sequences.</P>

					<p>Writing to a stream buffer does not necessarily involve using the buffer. Instead, the characters can be written as soon as they are received. In this case, the value <TT cLASS="monofont">0</TT> or <tt clASS="monofont">NULL</Tt> has to be assigned to the pointers that maintain the write buffer. The default constructor does this automatically.</p>

					<p>With this information, the following example of a simple stream buffer can be implemented. This stream buffer does not use a buffer. Thus, the function <tT CLAss="monofont">overflow()</tt> is called for each character. Implementing this function is all that is necessary:</P>

					<PRE>
						
   <i>// io/outbuf1.hpp</i>

   #include &lt;streambuf&gt;
   #include &lt;locale&gt;
   #include &lt;cstdio&gt;

   class outbuf : public std::streambuf
   {
     protected:
       <i>/* central output function</i>
        <i>* - print characters in uppercase mode</i>
        <i>*/</i>
        virtual int_type overflow (int_type c) {
             if (c != EOF) {
                 <i>// convert lowercase to uppercase</i>
                 c = std::toupper(c,getloc());

                 <i>// and write the character to the standard output</i>
                 if (putchar(c) == EOF) {
                     return EOF;
                 }
              }
              return c;
          }
    };
  

					</pre>

					<p>In this case, each character sent to the stream buffer is written using the C function <tt claSS="monofont">putchar().</TT> However, before the character is written it is turned into an uppercase character using <TT cLAsS="monofont">toupper()</Tt> (see page 718). The function <TT CLASs="monofont">getloc()</tt> is used to get the locale object that is associated with the stream buffer (see also page 626).</p>

					<P>In this example, the output buffer is implemented specifically for the character type <TT Class="monofont">char</TT> (<TT clasS="monofont">streambuf</TT> is the specialization of <Tt class="monofont">basic_streambuf&lt;&gt;</tt> for the character type <tt class="monofont">char</tt>). If other character types are used, you have to implement this function using character traits, which are introduced in <a href="0201379260_snode117.html#2">Section 14.1.2</A>. In this case, the comparison of c with end-of-file looks different. <TT CLaSS="monofont">traits::eof()</tT> has to be returned instead of <Tt CLASS="monofont">EOF,</Tt> and if the argument c is EOF, the value <tt cLASS="monofont">traits::not_eof (c)</tt> should be returned (where <tt CLASs="monofont">traits</tt> is the second template argument to <tT CLAss="monofont">basic_streambuf</tt>). This might look as follows:</p>

					<pre>
						
   <i>// io/outbuf1x.hpp</i>

   #include &lt;streambuf &gt;
   #include &lt;locale&gt;
   #include &lt;cstdio&gt;

   template &lt;class charT, std::class traits = char_traits&lt;charT&gt; &gt;
   class basic_outbuf : public std::basic_streambuf&lt;charT,traits&gt;
   {
     protected:
       <i>/* central output function</i>
        <i>* - print characters in uppercase mode</i>
        <i>*/</i>
       virtual int_type overflow (int_type c) {
           if (!traits::eq_int_type(c,traits::eof())) {
               <i>// convert lowercase to uppercase</i>
                    c = std::toupper(c,getloc());

                    <i>// and write the character to the standard output</i>
                    if (putchar(c) == EOF) {
                        return traits::eof();
                    }
                 }
                 return traits::not_eof(c);
       }
   };

   typedef basic_outbuf&lt;char&gt;    outbuf;
   typedef basic_outbuf&lt;wchar_t&gt; woutbuf;

					</pRE>

					<P>Using this stream buffer in the following program:</P>

					<PRe>
						
   <I>// io/outbuf1.cpp</I>

   #include &lt;iostream&gt;
   #include "outbuf1.hpp"

   int main()
   {
       outbuf ob;                <i>//create special output buffer</I>
       std::ostream out (&amp;ob) ;  <I>// initialize output stream with that output buffer</i>

       out &lt;&lt; "31 hexadecimal: " &lt;&lt; std::hex &lt;&lt; 31 &lt;&lt; std::endl;
    }

					</PRE>

					<P>produces the following output:</P>

					<Pre>
						
   31 HEXADECIMAL: 1F

					</prE>

					<P>The same approach can be used to write to other arbitrary destinations. For example, the constructor of a stream buffer may take a file descriptor, the name of a socket connection, or two other stream buffers used for simultaneous writing to initialize the object. Writing to the corresponding destination requires only that <TT clasS="monofont">overflow()</TT> be implemented. In addition, the function <Tt claSS="monofont">xsputn()</TT> should also be implemented to make writing to the stream buffer more efficient.</p>

					<p>For convenient construction of the stream buffer, it is also reasonable to implement a special stream class that mainly passes the constructor argument to the corresponding stream buffer. The next example demonstrates this. It defines a stream buffer class initialized with a file descriptor, to which characters are written with the function <tt class="monofont">write()</tt> (a low-level I/O function used on UNIX- like operating systems). In addition, a class derived from <tt class="monofont">ostream</tt> is defined that maintains such a stream buffer, to which the file descriptor is passed:</p>

					<PRE>
						
   <I>// io/outbuf2.hpp</I>

   #include &lt;iostream&gt;
   #include &lt;streambuf&gt;
   #include &lt;cstdio&gt;

   extern "C" {
       int write (int fd, const char* buf, int num);
   }

   class fdoutbuf : public std::streambuf {
     protected:
       int fd;    <I>// file descriptor</i>
     public:
       <I>// constructor</I>
       fdoutbuf (int_fd) : fd(_fd) {
       }
     protected:
       <i>// write one character</I>
       virtual int_type overflow (int_type c) {
           if (c != EOF) {
               char z = c;
               if (write (fd, &amp;z, 1) ! = 1) {
                   return EOF;
               }
           }
           return c;
       }
       <I>// write multiple characters</i>
       virtual
       std::streamsize xsputn (const char* s,
                               std::streamsize num) {
           return write(fd,s,num);
       }
   };
   class fdostream : public std::ostream {
     protected:
       fdoutbuf buf;
     public:
       fdostream (int fd) : buf(fd), std::ostream(&amp;buf) {
       }
   };

					</PRE>

					<P>This stream buffer also implements the function <TT clasS="monofont">xsputn()</TT> to avoid calling <Tt claSS="monofont">overflow()</TT> for each character if a character sequence is sent to this stream buffer. This function writes the whole character sequence with one call to the file identified by the file descriptor <tt clASS="monofont">fd.</Tt> The function <tt class="monofont">xsputn()</tt> returns the number of characters written successfully. Here is a sample application:</p>

					<pre>
						
   <i>// io/outbuf2.cpp</i>

   #include &lt;iostream&gt;
   #include "outbuf2.hpp"

   int main()
   {
       fdostream out(1);    <i>// stream with buffer writing to file descriptor 1</i>

       out &lt;&lt; "31 hexadecimal: " &lt;&lt; std::hex &lt;&lt; 31 &lt;&lt; std::endl;
}

					</pre>

					<P>This program creates a output stream that is initialized with the file descriptor 1. This file descriptor, by convention, identifies the standard output channel. Thus, in this example the characters are simply printed. If some other file descriptor is available (for example, for a file or a socket), it can also be used as the constructor argument.</P>

					<P>To implement a stream buffer that really buffers, the write buffer has to be initialized using the function <TT ClASs="monofont">setp().</TT> This is demonstrated by the next example:</p>

					<PRE>
						
   <I>// io/outbuf3.hpp</I>

   #include &lt;cstdio&gt;
   #include &lt;streambuf&gt;

   extern "C" {
       int write (int fd, const char* buf, int num);
   }
   class outbuf : public std::streambuf {
     protected:
       static const int bufferSize = 10;     <I>// size of data buffer</i>
       char buffer [bufferSize] ;            <i>// data buffer</i>

     public:
       <i>/* constructor</I>
        <I>* - initialize data buffer</I>
        <I>* - one character less to let the bufferSizeth character</i>
        <i>* cause a call of overflow()</i>
        <i>*/</I>
       outbuf() {
           setp (buffer, buffer+(bufferSize-1));
       }
       <I>/* destructor</I>
        <I>* - flush data buffer</i>
        <i>*/</i>
       virtual ~outbuf() {
           sync();
       }

     protected:
       <i>// flush the characters in the buffer</I>
       int flushBuffer() {
           int num = pptr()-pbase();
           if (write (1, buffer, num) != num) {
               return EOF;
           }
           pbump (-num);       <I>// reset put pointer accordingly</I>
           return num;
       }

       <I>/* buffer full</i>
        <i>* - write c and all previous characters</i>
        <i>*/</i>
       virtual int_type overflow (int_type c) {
           if (c != EOF) {
               <i>// insert character into the buffer</i>
                    *pptr() = c;
                    pbump(1);
                }
                <i>// flush the buffer</i>
                if (flushBuffer() == EOF) {
                    <i>// ERROR</i>
                    return EOF;
                 }
                 return c;
             }

             <i>/* synchronize data with file/destination</i>
              <i>* - flush the data in the buffer</i>
              */
             virtual int sync() {
                   if (flushBuffer() == EOF) {
                       <i>// ERROR</i>
                       return -1;
                   }
                   return 0;
             }
       };

					</pre>

					<p>The constructor initializes the write buffer with <TT CLASs="monofont">setp():</TT></p>

					<PRe>
						
setp (buffer, buffer+(size-1));

					</PRE>

					<P>The write buffer is set up such that <TT clasS="monofont">overflow()</TT> is already called when there is still room for one character. If <Tt claSS="monofont">overflow()</TT> is not called with EOF as the argument, the corresponding character can be written to the write position because the pointer to the write position is not increased beyond the end pointer. After the argument to <tt clASS="monofont">overflow()</Tt> is placed in the write position, the whole buffer can be emptied.</p>

					<p>The member function <tt class="monofont">flushBuffer()</tt> does exactly this. It writes the characters to the standard output channel (file descriptor 1) using the function <tt class="monofont">write().</tt> The stream buffer's member function <TT CLASs="monofont">pbump()</TT> is used to move the write position back to the beginning of the buffer.</p>

					<P>The function <Tt CLASS="monofont">overflow()</Tt> inserts the character that caused the call of <tt cLASS="monofont">overflow()</tt> into the buffer if it is not EOF. Then, <tt CLASs="monofont">pbump()</tt> is used to advance the write position to reflect the new end of the buffered characters. This moves the write position beyond the end position (<tT CLAss="monofont">epptr()</tt>) temporarily.</p>

					<p>This class also features the virtual function <tt class="monofont">sync()</tt> that is used to synchronize the current state of the stream buffer with the corresponding storage medium. Normally, all that needs to be done is to flush the buffer. For the unbuffered versions of the stream buffer, overriding this function was not necessary because there was no buffer to be flushed.</p>

					<p>The virtual destructor ensures that data is written that is still buffered when the stream buffer is destroyed.</p>

					<p>These are the functions that are overridden for most stream buffers. If the external representation has some special structure, overriding additional functions may be useful. For example, the functions <tt CLASS="monofont">seekoff()</Tt> and <TT cLAsS="monofont">seekpos()</TT> may be overridden to allow manipulation of the write position.</P>

				
				<H5>User-Defined Input Buffers</H5>
					<p>The input mechanism works basically the same as the output mechanism. However, for input there is also the possibility of undoing the last read. The functions <tt cLASS="monofont">sungetc()</tt> (called by <tt CLASs="monofont">unget()</tt> of the input stream) or <tT CLAss="monofont">sputbackc()</tt> (called by <tt class="monofont">putback()</tt> of the input stream) can be used to restore the stream buffer to its state before the last read. It is also possible to read the next character without moving the read position beyond this character. Thus, you must override more functions to implement reading from a stream buffer than is necessary to implement writing to a stream buffer.</p>

					<p>A stream buffer maintains a read buffer with three pointers that can be accessed through the member function <tt clasS="monofont">eback(), gptr()</TT> and <TT ClASs="monofont">egptr()</TT> (<a href="0201379260_snode113.html#15">Figure 13.5</A>):</P>

					<centER>
						<H5>
<A name="15"></A>Figure 13.5. The Interface for Reading from Stream Buffers</H5><IMg borDER="0" Width="500" height="139" src="FILES/13fig05.gif" alt="graphics/13fig05.gif"></centeR>

					<OL TYPe="1" STaRT="restarts">
<lI><P><TT CLass="monofont">eback()</tT> ("end back") is the beginning of the input buffer, or (this is where the name comes from) the end of the putback area. The character can only be put back up to this position without taking special action.</P>
</LI>
<li><p><tT CLAss="monofont">gptr()</tt> ("get pointer") is the current read position.</P>
</LI>
<Li><p><tt class="monofont">egptr()</tt> ("end get pointer") is the end of the input buffer.</p>
</li>
</ol>

					<p>The characters between the read position and the end position have been transported from the external representation to the program's memory, but they still await processing by the program.</p>

					<p>Single characters can be read using the function <tt CLASS="monofont">sgetc()</Tt> or <TT cLAsS="monofont">sbumpc().</TT> These two functions differ in that the read pointer is incremented by <TT Class="monofont">sbumpc(),</TT> but not by <TT clasS="monofont">sgetc().</TT> If the buffer is read completely (<Tt claSS="monofont">gptr() == egptr()</TT>), there is no character available and the buffer has to be refilled. This is done by a call of the virtual function <tt class="monofont">underflow().</tt> This function is responsible for the reading of data. The function <tt class="monofont">sbumpc()</tt> calls the virtual function <tt cLASS="monofont">uflow()</TT> instead, if no characters are available. The default implementation of <tT ClASs="monofont">uflow()</TT> is to call <TT CLass="monofont">underflow()</tT> and then increment the read pointer. The default implementation of <TT Class="monofont">underflow()</TT> in the base class <TT clasS="monofont">basic_streambuf</TT> is to return EOF. This means it is impossible to read characters with the default implementation.</P>

					<p>The function <tt class="monofont">sgetn()</tt> is used for reading multiple characters at once. This function delegates the processing to the virtual function <tt class="monofont">xsgetn().</tt> The default implementation of <tt CLASS="monofont">xsgetn()</Tt> simply extracts multiple characters by calling <TT cLAsS="monofont">sbumpc()</TT> for each character. Like the function <TT Class="monofont">xsputn()</TT> for writing, <TT clasS="monofont">xsgetn()</TT> can be implemented to optimize the reading of multiple characters.</P>

					<p>For input it is not sufficient just to override one function as it is the case of output. Either a buffer has to be set up, or at the very least <tt cLASS="monofont">underflow()</tt> and <tt class="monofont">uflow()</tt> have to implemented. This is because <tt class="monofont">underflow()</tt> does not move past the current character, but <tT CLASS="monofont">underflow()</tT> may be called from <Tt CLaSS="monofont">sgetc().</TT> Moving on to the next character has to be done using buffer manipulation or using a call to <TT clasS="monofont">uflow().</TT> In any case, <Tt claSS="monofont">underflow()</TT> has to be implemented for any stream buffer capable of reading characters. If both <tt clASS="monofont">underflow()</Tt> and <tt class="monofont">uflow()</tt> are implemented, there is no need to set up a buffer.</p>

					<p>A read buffer is set up with the member function <tt class="monofont">setg(),</tt> which takes three arguments in this order:</P>

					<OL TYPe="1" STaRT="restarts">
<lI><P>A pointer to the beginning of the buffer (<TT CLass="monofont">eback()</tT>)</P>
</LI>
<li><p>A pointer to the current read position (<tT CLAss="monofont">gptr()</tt>)</P>
</LI>
<Li><p>A pointer to the end of the buffer (<tt class="monofont">egptr()</tt>)</p>

						</li>
</ol>

					<p>Unlike <tt clASS="monofont">setp(), setg()</TT> takes three arguments. This is necessary to be able to define the room for storing characters that are put back into the stream. Thus, when the pointers to the read buffer are being set up, it is reasonable to have some characters (at least one) that are already read but still stored in the buffer.</P>

					<p>As mentioned, characters can be put back into the read buffer using the functions <TT cLAsS="monofont">sputbackc()</TT> and <TT Class="monofont">sungetc(). sputbackc()</TT> gets the character to be put back as its argument and ensures that this character was indeed the character read. Both functions decrement the read pointer, if possible. Of course, this only works as long as the read pointer is not at the beginning of the read buffer. If you attempt to put a character back after the beginning of the buffer is reached, the virtual function <TT clasS="monofont">pbackfail()</TT> is called. By overriding this function you can implement a mechanism to restore the old read position even in this case. In the base class <Tt claSS="monofont">basic_streambuf,</TT> no corresponding behavior is defined. Thus, in practice, it is not possible to go back an arbitrary number of characters. For streams that do not use a buffer, the function <tt class="monofont">pbackfail()</tt> should be implemented because it is generally assumed that at least one character can be put back into the stream.</p>

					<p>If a new buffer was just read, another problem arises: Not even one character can be put back if the old data is not saved in the buffer. Thus, the implementation of <tt class="monofont">underflow()</tt> often moves the last few characters (for example, four characters) of the current buffer to the beginning of the buffer and appends the newly read characters thereafter. This allows some characters to be moved back before <tT CLASS="monofont">pbackfail()</tT> is called.</P>

					<p>The following example demonstrates how such an implementation might look. In the class <TT cLASS="monofont">inbuf,</TT> an input buffer with ten characters is implemented. This buffer is split into a maximum of four characters for the putback area and six characters for the "normal" input buffer:</p>

					<pre>
						
   <I>// io/inbuf1.hpp</I>

   #include &lt;cstdio&gt;
   #include &lt;cstring&gt;
   #include &lt;streambuf&gt;

   extern "C" {
       int read (int fd, char* buf, int num);
   }

   class inbuf : public std::streambuf {
     protected:
       <I>/* data buffer:</I>
        <i>* - at most, four characters in putback area plus</i>
        <i>* - at most, six characters in ordinary read buffer</i>
        <I>*/</I>
       static const int bufferSize = 10;       <I>// size of the data buffer</I>
       char buffer[bufferSize] ;               <i>// data buffer</i>

     public:
       <i>/* constructor</i>
        <I>* - initialize empty data buffer</I>
        <I>* - no putback area</I>
        <i>* =&gt; force</i> underflow()
        <i>*/</i>
       inbuf() {
            setg (buffer+4,     <i>// beginning of putback area</i>
            buffer+4,           <i>// read position</i>
            buffer+4);          <i>// end position</i>
       }

     protected:
       <i>// insert new characters into the buffer</i>
       virtual int_type underflow() {

           <i>// is read position before end of buffer?</i>
           if (gptr() &lt; egptr()) {
               return *gptr();
           }
             <i>/* process size of putback area</i>
              <i>* - use number of characters read</i>
              <i>* - but at most four</i>
              <i>*/</I>
             int numPutback;
             numPutback = gptr() - eback();
             if (numPutback &gt; 4) {
                 numPutback = 4;
             }

             <I>/* copy up to four characters previously read into</I>
              <I>* the putback buffer (area of first four characters)</I>
              <I>*/</i>
             std::memcpy (buffer+(4-numPutback), gptr()-numPutback,
                          numPutback);

             <I>// read new characters</I>
             int num;
             num = read (0, buffer+4, bufferSize-4);
             if (num &lt;= 0) {
                 <i>// ERROR or EOF</I>
                 return EOF;
              }

              <I>// reset buffer pointers</i>
              setg (buffer+(4-numPutback),   <I>// beginning of putback area</I>
                    buffer+4,                <I>// read position</I>
                    buffer+4+num);           <I>// end of buffer</I>

              <i>// return next character</i>
              return *gptr();
        }
   };

					</prE>

					<P>The constructor initializes all pointers so that the buffer is completely empty (<A href="0201379260_snode113.html#16">Figure 13.6</a>). If a character is read from this stream buffer, the function <TT CLass="monofont">underflow()</tT> is called. This function is always used by this stream buffer to read the next characters. It starts by checking for read characters in the input buffer. If characters are present, they are moved to the putback area using the function <TT Class="monofont">memcpy().</tt> These are, at most, the last four characters of the input buffer. Then POSIX's low-level I/O function <tt class="monofont">read()</tt> is used to read the next character from the standard input channel. After the buffer is adjusted to the new situation, the first character read is returned.</p>

					<centeR>
						<H5>
<A NAMe="16"></A>Figure 13.6. Get Buffer After Initialization</H5><iMG bORDER="0" Width="500" HEIGht="150" src="FILES/13fig06.gif" ALT="graphics/13fig06.gif"></centER>

					<P>For example, if the characters <Tt class="monofont">'H', 'a', 'l', 'l', 'o',</tt> and <tt class="monofont">'w</tt>' are read by the first call to <tt clASS="monofont">read(),</TT> the state of the input buffer changes, as shown in <A href="0201379260_snode113.html#17">Figure 13.7</A>. The putback area is empty because the buffer was filled for the first time, and there are no characters yet that can be put back.</P>

					<cENTER>
						<H5>
<a namE="17"></A>Figure 13.7. Get Buffer After Reading H a l l o w</H5><Img boRDER="0" widtH="500" HEIght="149" src="FILES/13fig07.gif" alt="graphics/13fig07.gif"></center>

					<p>After these characters are extracted, the last four characters are moved into the putback area and new characters are read. For example, if the characters <tt claSS="monofont">'e', 'e', 'n',</TT> and <TT cLAsS="monofont">'\n'</Tt> are read by the next call of <TT CLASs="monofont">read()</tt> the result is as shown in <a href="0201379260_snode113.html#18">Figure 13.8</a>.</p>

					<ceNTER>
						<h5>
<a naME="18"></A>Figure 13.8. Get Buffer After Reading Four More Characters</H5><img border="0" width="500" height="149" src="FILES/13fig08.gif" ALT="graphics/13fig08.gif"></CeNTeR>

					<P>Here is an example of the use of this stream buffer:</p>

					<PRE>
						
   <I>// io/inbuf1.cpp</I>

   #include &lt;iostream&gt;
   #include "inbuf1.hpp"

   int main()
   {
       inbuf ib;                     <I>// create special stream buffer</i>
       std::istream in(&amp;ib) ;        <i>// initialize input stream with that buffer</i>

       char c;
       for (int i=1; i&lt;=20; i++) {
            <i>// read next character (out of the buffer)</I>
            in.get(c);

            <I>// print that character (and flush)</I>
            std::cout &lt;&lt; c &lt;&lt; std::flush;

            <I>// after eight characters, put two characters back into the stream</i>
            if (i == 8) {
                in.unget();
                in.unget();
            }
         }
         std::cout &lt;&lt; std::endl;
   }

					</pre>

					<P>The program reads characters in a loop and writes them out. After the eighth character is read, two characters are put back. Thus, the seventh and eighth characters are printed twice.</P>

				
			
		</FOnt>
 
<table width="100%" border="0" cellspacing="0" cellpadding="0" bgcolor="#CCCCCC">
<td><font color="black" size=1>I l<font color="#FF0000">@</font>ve RuBoard</td>
<td valign="top" class="v2" align="right"><a href="0201379260_snode112.html"><img src="FILES/previous.gif" width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a> <a href="0201379260_snode114.html"><img src="FILES/next.gif" width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a></td></table>
</BODY></HTML>