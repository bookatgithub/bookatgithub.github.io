<HTML><HEAD><META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=iso-8859-1">
<!--SafClassName="docSection1Title"--><!--SafTocEntry="14.2 The Concept of Locales"-->
<LINK REL="stylesheet" href="FILES/sbolM.css">
</HEAD>
<BODY link="#354278" vlink="#000066" alink="#000080" topmargin="0">
<table width="100%" border="0" cellspacing="0" cellpadding="0" bgcolor="#CCCCCC">
<td><font color="black" size=1>I l<font color="#FF0000">@</font>ve RuBoard</td>
<td valign="top" class="v2" align="right"><a href="0201379260_snode117.html"><img src="FILES/previous.gif" width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a> <a href="0201379260_snode119.html"><img src="FILES/next.gif" width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a></td></table>
<FONT><h3>14.2
The Concept of Locales</h3>
			<p>A common approach to internationalization is to use environments, called <i>locales,</I> to encapsulate national or cultural conventions. The C community uses this approach. Thus, in the context of internationalization, a locale is a collection of parameters and functions used to support national or cultural conventions. According to X/Open conventions,<FONt sizE="1"><SUP><a hreF="#FOOTNOTE-3">[3]</A></SUp></font>
 the environment variable <tt class="monofont">LANG</tt> is used to define the locale to be used. Depending on this locale, different formats for floating-point numbers, dates, monetary values, and so on are used.</p>
<blockqUOTE><FOnT SiZE="1">
<p CLASS="footnote">
<Sup><a nAME="FOOTNOTE-3">[3]</A></sup>
POSIX and X/Open are standards for operating system interfaces.</p>
</FONT></blocKQUOte>

				
			<p>The format of the string defining a locale is normally this:</p>

			<pre>
				
    <i>language</i> [<i>_area</i> [<i>.code</i>]]

			</pre>

			<p><i>language</i> represents the language, such as English or German, <i>area</i> is the area, country, or culture where this language is used. It is used, for example, to support different national conventions even if the same language is used in different nations. <I>code</I> defines the character encoding to be used. This is mainly important in Asia, where different character encodings are used to represent the same character set.</P>

			<P><A href="0201379260_snode118.html#2">Table 14.2</a> presents a selection of typical language strings. However, note that these strings are <I>not</I> yet standardized. For example, sometimes the first character of <i>language</I> is capitalized. Some implementations deviate from the format mentioned previously and, for example, use <TT CLAss="monofont">english</tt> to select an English locale. All in all, the locales that are supported by a system are implementation specific.</P>

			<P>For programs, it is normally no problem that these names are not standardized! This is because the locale information is provided by the user in some form. It is common that programs simply read environment variables or some similar database to determine which locales to use. Thus, the burden of finding the correct locale names is put on the users. Only if the program always uses a special locale does the name need to be hard coded in the program. Normally, for this case, the C locale is sufficient, and is guaranteed to be supported by all implementations and to have the name C.</P>

			<P>The next section presents the use of different locales in C++ programs. In particular, it introduces <i>facets</i> of locales that are used to deal with specific formatting details.</p>

			<p>C also provides an approach to handle the problem of character sets with more than 256 characters. This approach is to use the character type <TT CLass="monofont">wchar_t,</tT> a type definition for one of the integral types with language support for wide-character constants and wide-character string literals. However, apart from this, only functions to convert between wide characters and narrow characters are supported. This approach was also incorporated into C++ with the character type <TT Class="monofont">wchar_t,</tt> which is, unlike the C approach, a distinct type in C++. However, C++ provides more library support than C, because basically everything available for char is also available for <tt class="monofont">wchar_t,</tt> and any other type may be used as a character type.</p>

			<a name="2"></A><P><TABLe BOrDEr="1" CELLSPacinG="0" CELlpadDING="1" widtH="100%">
<CAPtion><h5>Table 14.2. Selection of Locale Names</h5></caption><colgroup ALIGN="left" SpAN="2">
<tR>
<Th VALIGN="top">
<font SIZE="2"><b>Locale</b>
							</foNT></TH>
<th vaLIGN="top">
<font size="2"><b>Meaning</b>
							</font></th>
</tr>
<tr>
<tD VALIGn="top">
<FOnT SiZE="2"><TT CLass="monofont">c</tT>
							</FONt></td>
<tD VALign="top">
<fONT Size="2">Default: ANSI-C conventions (English, 7 bit)</font></td>
</tr>
<tr>
<td valign="top">
<FONT SIzE="2"><Tt CLaSS="monofont">de_DE</TT>
							</FOnt></td>
<TD VAlign="top">
<FONT size="2">German in Germany</FONT></td>
</tr>
<tr>
<td valign="top">
<font sizE="2"><TT CLAsS="monofont">de_DE. 88591</Tt>
							</FOnT></TD>
<TD ValigN="top">
<FONt sizE="2">German in Germany with ISO Latin-1 encoding</FONt></td>
</tR>
<TR>
<Td valign="top">
<font size="2"><tt clasS="monofont">de_AT</TT>
							</FONt></TD>
<tD VaLIGN="top">
<FOnt siZE="2">German in Austria</FOnt></td>
</TR>
<TR>
<td vaLIGN="top">
<font size="2"><tt class="monofont">de_CH</tt>
							</font></TD>
<TD VAlIGn="top">
<FOnT SIZE="2">German in Switzerland</Font></tD>
</TR>
<Tr>
<td vALIGn="top">
<fonT SIZe="2"><tt class="monofont">en_US</tt>
							</font></td>
<td valIGN="top">
<FONt SIzE="2">English in the United States</FoNT></TD>
</TR>
<tr>
<td VALIgn="top">
<foNT SIze="2"><tt CLASs="monofont">en_GB</tt>
							</font></td>
<td valign="top">
<font SIZE="2">English in Great Britain</FOnT></Td>
</TR>
<tR>
<TD VALign="top">
<fONT Size="2"><tT CLAss="monofont">en_AU</tt>
							</FONT></td>
<td valign="top">
<font size="2">English in Australia</fonT></TD>
</TR>
<Tr>
<TD vALiGN="top">
<FONT size="2"><TT CLass="monofont">en_CA</tT>
							</FONt></td>
<tD VALign="top">
<font size="2">English in Canada</font></td>
</tr>
<tr>
<TD VALIgN="top">
<FoNT sIZE="2"><TT Class="monofont">fr_FR</TT>
							</FOnt></td>
<TD VAlign="top">
<FONT size="2">French in France</font></td>
</tr>
<tr>
<td valigN="top">
<FONT SiZE="2"><tT ClASS="monofont">fr_CH</TT>
							</Font></tD>
<TD ValigN="top">
<FONt sizE="2">French in Switzerland</FONt></td>
</tr>
<tr>
<td valign="top">
<font siZE="2"><TT CLaSS="monofont">fr_CA</tT>
							</FoNT></TD>
<TD valiGN="top">
<FOnt siZE="2">French in Canada</FOnt></td>
</TR>
<TR>
<td valign="top">
<font size="2"><tt claSS="monofont">ja_JP. jis</TT>
							</FOnT></Td>
<TD vALIGN="top">
<Font sIZE="2">Japanese in Japan with <I>Japanese Industrial Standard (JIT)</i> encoding
</fonT></TD>
</Tr>
<tr>
<tD VALign="top">
<font size="2"><tt class="monofont">ja_JP. sjis</tt>
							</fONT></TD>
<Td VAlIGn="top">
<FONT SIze="2">Japanese in Japan with <i>Shift JIS</i> encoding
</FONT></td>
</tr>
<TR>
<TD valiGN="top">
<FOnt size="2"><tt class="monofont">ja_JP.ujis</tt>
							</font></td>
<TD VALIgN="top">
<FoNT sIZE="2">Japanese in Japan with <I>UNIXized JIS</I> encoding
</Font></tD>
</TR>
<Tr>
<td vALIGn="top">
<fonT SIZe="2"><tt class="monofont">ja_JP.EUC</tt>
							</font></td>
<td valIGN="top">
<FONt SIzE="2">Japanese in Japan with <I>Extended UNIX Code</i> encoding
</FONT></TD>
</tr>
<tr>
<TD VAlign="top">
<FONT size="2"><TT CLass="monofont">ko_KR</tt>
							</font></td>
<td valign="top">
<foNT SIZE="2">Korean in Korea</fONt></TD>
</tR>
<TR>
<TD ValigN="top">
<FONt sizE="2"><TT Class="monofont">zh_CN</TT>
							</FOnt></td>
<td valign="top">
<font size="2">Chinese in China</fONT></TD>
</Tr>
<TR>
<tD VaLIGN="top">
<FOnt siZE="2"><TT clasS="monofont">zh_TW</TT>
							</Font></tD>
<TD Valign="top">
<font size="2">Chinese in Taiwan</font></td>
</tr>
<TR>
<TD VAlIGn="top">
<FOnT SIZE="2"><Tt claSS="monofont">lt_LN.bit7</TT>
							</font></TD>
<TD valiGN="top">
<FOnt size="2">ISO Latin, 7 bit</font></td>
</tr>
<tr>
<td valIGN="top">
<FONt SIzE="2"><Tt CLASS="monofont">lt_LN.bit8</Tt>
							</fonT></TD>
<Td valIGN="top">
<Font sIZE="2">ISO Latin, 8 bit</Font></td>
</tr>
<tr>
<td valign="top">
<font SIZE="2"><TT cLAsS="monofont">POSIX</Tt>
							</FONT></TD>
<td vaLIGN="top">
<font SIZE="2">POSIX conventions (English, 7 bit)</font></TD>
</TR>
</colgroup>
</table></p>

			<a name="3"></a><h4>14.2.1
Using Locales</H4>
				<P>Using translations of textual messages is normally not sufficient for true internationalization. For example, different conventions for numeric, monetary, or date formatting also have to be used. In addition, functions manipulating letters should depend on character encoding to ensure the correct handling of all characters that are letters in a given language.</P>

				<P>According to the POSIX and X/Open standards, it is already possible in C programs to set a locale. This is done using the function <TT cLAsS="monofont">setlocale().</Tt> Changing the locale influences the results of character classification and manipulation functions, such as <TT CLASs="monofont">isupper()</tt> and <tT CLAss="monofont">toupper(),</tt> and the I/O functions, such as <TT CLass="monofont">printf().</tT></P>

				<P>However, the C approach has several limitations. Because the locale is a global property, using more than one locale at the same time (for example, when reading floating-point numbers in English and writing them in German) is either not possible or is possible only with a relatively large effort. Also, locales cannot be extended. They provide only the facilities the implementation chooses to provide. If something the C locales do not provide must also be adapted to national conventions, a different mechanism has to be used to do this. Finally, it is not possible to define new locales to support special cultural conventions.</P>

				<p>The C++ standard library addresses all of these problems with an object-oriented approach. First, the details of a <tt class="monofont">locale</tt> are encapsulated in an object of type locale. Doing this immediately provides the possibility of using multiple locales at the same time. Operations that depend on locales are configured to use a corresponding locale object. For example, a locale object can be installed for each I/O stream, which is then used by the different member functions to adapt to the corresponding conventions. This is demonstrated by the following example:</p>

				<pre>
					
   <i>// i18n/loc1.cpp</i>

   #include &lt;iostream&gt;
   #include &lt;locale&gt;
   using namespace std;

   int main()
   {
       <i>// use classic C locale to read data from standard input</i>
       cin.imbue(locale::classic());

       <i>// use a German locale to write data to standard ouput</i>
       cout.imbue(locale("de_DE"));

       <i>// read and output floating-point values in a loop</I>

       double value;
       while (cin &gt;&gt; value) {
           cout &lt;&lt; value &lt;&lt; endl;
       }
   }

				</PRE>

				<P>The statement</P>

				<pRE>
					
    cin.imbue(locale::classic());

				</pRE>

				<p>assigns the "classic" C locale to the standard input channel. For the classic C locale, formatting of numbers and dates, character classification, and so on is handled as it is in original C without any locales. The expression</P>

				<PRE>
					
    std::locale::classic()

				</PRe>

				<p>obtains a corresponding object of class <tt CLASs="monofont">locale.</tt> Using the expression</p>

				<PRE>
					
    std::locale("C")

				</Pre>

				<p>instead would yield the same result. This last expression constructs a <tT CLAss="monofont">locale</tt> object from a given name. The name <tt class="monofont">"C"</tt> is a special name, and actually is the only one a C++ implementation is required to support. There is no requirement to support any other locale, although it is assumed that C++ implementations also support other locales.</p>

				<p>Correspondingly, the statement</p>

				<pre>
					
    cout.imbue (locale("de_DE"));

				</prE>

				<P>assigns the locale <TT CLaSS="monofont">de_DE</tT> to the standard output channel. This is, of course, successful only if the system supports this locale. If the name used to construct a locale object is unknown to the implementation, an exception of type <Tt CLASS="monofont">runtime_error</Tt> is thrown.</p>

				<p>If everything was successful, input is read according to the classic C conventions and output is written according to the German conventions. The loop thus reads floating-point values in the normal English format, for example</p>

				<PRE>
					
   47.11

				</Pre>

				<p>and prints them using the German format, for example</p>

				<PRE>
					
   47,11

				</Pre>

				<p>Yes, the Germans really use a comma as a "decimal point".</p>

				<P>Normally, a program does not predefine a specific locale except when writing and reading data in a fixed format. Instead, the locale is determined using the environment variable <TT Class="monofont">LANG.</tt> Another possibility is to read the name of the locale to be used. The following program demonstrates this:</p>

				<pre>
					
    
   <i>// i18n/loc2.cpp</i>

   #include &lt;iostream&gt;
   #include &lt;locale&gt;
   #include &lt;string&gt;
   #include &lt;cstdlib&gt;
   using namespace std;

   int main()
   {
       <i>//create the default locale from the user's environment</i>
       locale langLocale("');


       <i>//and assign it to the standard ouput channel</i>
       cout.imbue(langLocale);


       <i>//process the name of the locale</i>
       bool isGerman;
       if (langLocale.name() == "0de_DE" ||
           langLocale.name() == "de" ||
           langLocale.name() == "german") {
             isGerman = true;
       }
       else {
             isGerman = false;
       }


       <i>//read locale for the input</i>
       if (isGerman) {
           cout &lt;&lt; "Sprachumgebung fuer Eingaben: ";
       }
       else {
           cout &lt;&lt; "Locale for input: ";
       }
       string s;
       cin &gt;&gt; s;
       if (!cin) {
           if (isGerman) {
               cerr &lt;&lt; "FEHLER beim Einlesen der Sprachumgebung"
                    &lt;&lt; endl;
           }
           else {
               cerr &lt;&lt; "ERROR while reading the locale" &lt;&lt; endl;
           }
           return EXIT.FAILURE;
       }
       locale cinLocale(s.c_str());


       <i>//and assign it to the standard input channel</I>
       cin.imbue(cinLocale);

       <I>//read and output floating-point values in a loop</I>
       double value;
       while (cin &gt;&gt; value) {
           cout &lt;&lt; value &lt;&lt; endl;
       }
    }

				</PRE>

				<p>In this example, the following statement creates an object of the class <TT cLAsS="monofont">locale:</TT></P>

				<PRe>
					
    locale langLocale("");

				</pre>

				<P>Passing an empty string as the name of the locale has a special meaning: The default locale from the user's environment is used (this is often determined by the environment variable <TT Class="monofont">LANG</TT>). This locale is assigned to the standard input stream with the statement</P>

				<Pre>
					
    cout.imbue(langLocale);

				</prE>

				<P>The expression</P>

				<Pre>
					
    langLocale.name()

				</pre>

				<p>is used to retrieve the name of the default locale, which is returned as an object of <tt class="monofont">type string</tt> (see <a href="0201379260_cnode88.html">Chapter 11</a>).</P>

				<P>The following statements construct a locale from a name read from standard input:</P>

				<PRE>
					
   string s;
   cin &gt;&gt; s;
   ...
   locale cinLocale(s.c_str());

				</pRE>

				<p>To do this, a word is read from the standard input and used as the constructor's argument. If the read fails, the <TT cLASS="monofont">ios_base:: failbit</TT> is set in the input stream, which is checked and handled in this program:</p>

				<pre>
					
   if (!cin) {
       if (isGerman) {
           cerr &lt;&lt; "FEHLER beim Einlesen der Sprachumgebung"
                &lt;&lt; endl;
       }
       else {
           cerr &lt;&lt; "ERROR while reading the locale" &lt;&lt; endl;
       }
       return EXIT_FAILURE;
   }

				</PRE>

				<P>Again, if the string is not a valid value for the construction of a locale, a <tt clASS="monofont">runtime_error</Tt> exception is thrown.</p>

				<p>If a program wants to honor local conventions, it should use corresponding locale objects. The static member function <tT CLAss="monofont">global()</tt> of the class <tt class="monofont">locale</tt> can be used to install a global locale object. This object is used as the default value for functions that take an optional locale object as an argument. If the locale object set with the <tt class="monofont">global()</tT> function has a name, it is also arranged that the C functions dealing with locales react correspondingly. If the locale set has no name, the consequences for the C functions depend on the implementation.</P>

				<P>Here is an example of how to set the global locale object depending on the environment in which the program is running:</P>

				<PRe>
					
    / <I>* create a locale object depending on the program's environment and</I>
     <i>* set it as the global object</I>
     <I>*/</i>
    std::locale::global(std::locale(""));

				</PRE>

				<P>Among other things, this arranges for the corresponding registration for the C functions to be executed. That is, the C functions are influenced as if the following call was made:</P>

				<Pre>
					
    std::setlocale(LC_ALL,"")

				</prE>

				<P>However, setting the global locale does not replace locales already stored in objects. It only modifies the locale object copied when a locale is created with a default constructor. For example, the stream objects store locale objects that are not replaced by a call to <TT clasS="monofont">locale::global().</TT> If you want an existing stream to use a specific locale, you have to tell the stream to use this locale using the <Tt claSS="monofont">imbue()</TT> function.</p>

				<p>The global locale is used if a locale object is created with the default constructor. In this case, the new locale behaves as if it is a copy of the global locale at the time it was constructed. The following three lines install the default locale for the standard streams:</p>

				<pre>
					
    <i>// register global locale object for streams</i>
    std::cin.imbue(std::locale());
    std::cout.imbue(std::locale());
    std::cerr.imbue(std::locale());

				</pre>

				<p>When using locales in C++, it is important to remember that the C++ locale mechanism is only loosely coupled to the C locale mechanism. There is only one relation to the C locale mechanism: The global C locale is modified if a named C++ locale object is set as the global locale. In general, you should not assume that the C and the C++ functions operate on the same locales.</p>

			
			<a name="4"></a><h4>14.2.2
Locale Facets</h4>
				<P>The actual dependencies on national conventions are separated into several aspects that are handled by corresponding objects. An object dealing with a specific aspect of internationalization is called a <I>facet.</I> A locale object is used as a container of different facets. To access an aspect of a locale, the type of the corresponding facet is used as the index. The type of the facet is passed explicitly as a template argument to the template function <TT ClASs="monofont">use_facet(),</TT> accessing the desired facet. For example, the expression</p>

				<PRE>
					
    std::use_facet&lt;std::numpunct&lt;char&gt; &gt;(loc)

				</PRE>

				<p>accesses the facet type <tt cLASS="monofont">numpunct</tt> for the character type <tt CLASs="monofont">char</tt> of the locale object <tT CLAss="monofont">loc.</tt> Each facet type is defined by a class that defines certain services. For example, the facet type <tt class="monofont">numpunct</tt> provides services used in conjunction with the formatting of numeric and Boolean values. For example, the following expression returns the string used to represent <tt class="monofont">true</tT> in the locale <TT CLAsS="monofont">loc.</Tt></P>

				<PrE>
					
    std::use_facet&lt;std::numpunct&lt;char&gt; &gt;(loc).truename()

				</PRE>

				<P><A href="0201379260_snode118.html#5">Table 14.3</A> provides an overview over the facets predefined by the C++ standard library. Each facet is associated with a category. These categories are used by some of the constructors of locales to create new locales as the combination of other locales.</P>

				<A Name="5"></a><P><TABle boRDER="1" cellspacing="0" cellpaddinG="1" WIDTH="100%">
<cAPtIOn><H5>Table 14.3. Facet Types Predefined by the C++ Standard Library</H5></CAPTion><cOLGRoup aLIGN="left" span="3">
<TR>
<TH valign="top">
<font size="2"><b>Category</b>
								</font></tH>
<TH VALiGN="top">
<fONt SIZE="2"><B>Facet Type</B>
								</font></TH>
<TH valiGN="top">
<FOnt siZE="2"><B>Used for</B>
								</font></th>
</tr>
<tr>
<td valign="top">
<fonT SIZE="2"><Tt CLaSS="monofont">numeric</tT>
								</FONT></Td>
<td vALIGn="top">
<fonT SIZe="2"><tt cLASS="monofont">num_get&lt;&gt;()</tt>
								</font></td>
<td valign="top">
<font sIZE="2">Numeric input</FONt></TD>
</tR>
<Tr>
<TD VALIgn="top">
<foNT SIze="2"> </foNT></TD>
<td vaLIGN="top">
<font size="2"><tt class="monofont">num_put&lt;&gt;()</tt>
								</font></TD>
<TD VAlIGn="top">
<FOnT SIZE="2">Numeric output</Font></tD>
</TR>
<Tr>
<td vALIGn="top">
<fonT SIZe="2"> </font></td>
<td valign="top">
<font siZE="2"><TT CLaSS="monofont">numpunct&lt;&gt;()</tT>
								</FoNT></TD>
<TD valiGN="top">
<FOnt siZE="2">Symbols used for numeric I/O</FOnt></td>
</TR>
<TR>
<td valign="top">
<font size="2"><tt claSS="monofont">time</TT>
								</FOnT></Td>
<TD vALIGN="top">
<Font sIZE="2"><Tt claSS="monofont">time_get&lt;&gt;()</TT>
								</font></TD>
<TD valign="top">
<font size="2">Time and date input</font></td>
</tR>
<TR>
<TD VaLIgN="top">
<FoNT SIZE="2"> </font></TD>
<TD valiGN="top">
<FOnt siZE="2"><TT class="monofont">time_put&lt;&gt;()</tt>
								</font></td>
<td valign="top">
<FONT SIzE="2">Time and date output</FoNT></tD>
</TR>
<TR>
<Td valIGN="top">
<Font sIZE="2"><Tt claSS="monofont">monetary</TT>
								</font></td>
<td valign="top">
<font sizE="2"><TT CLAsS="monofont">money_get&lt;&gt;()</Tt>
								</FOnT></TD>
<TD ValigN="top">
<FONt sizE="2">Monetary input</FONt></td>
</tR>
<TR>
<Td valign="top">
<font size="2"> </font></td>
<TD VALIgN="top">
<FoNT sIZE="2"><TT Class="monofont">money_put&lt;&gt;()</TT>
								</FOnt></td>
<TD VAlign="top">
<FONT size="2">Monetary output</font></td>
</tr>
<tr>
<td valigN="top">
<FONT SiZE="2"> </fONt></TD>
<TD VAlign="top">
<FONT size="2"><TT CLass="monofont">moneypunct &lt;&gt;()</tT>
								</FONt></td>
<td valign="top">
<font size="2">Symbols used for monetary I/O</foNT></TD>
</TR>
<tR>
<Td VAlIGN="top">
<FONt sizE="2"><TT Class="monofont">ctype</TT>
								</FOnt></td>
<TD VAlign="top">
<font size="2"><tt class="monofont">ctype&lt;&gt;()</tt>
								</FONT></TD>
<tD VaLIgN="top">
<FONT Size="2">Character information<tT CLAss="monofont">(toupper() , isupper())</tt>
								</FONT></td>
</tr>
<TR>
<TD valign="top">
<font size="2"> </font></td>
<tD VALIGn="top">
<FOnT SiZE="2"><TT CLass="monofont">codecvt&lt;&gt;()</tT>
								</FONt></td>
<tD VALign="top">
<fONT Size="2">Conversion between different character encodings</font></td>
</tr>
<tr>
<td valign="top">
<FONT SIzE="2"><Tt CLaSS="monofont">collate</TT>
								</FOnt></td>
<TD VAlign="top">
<FONT size="2"><TT CLass="monofont">collate&lt;&gt;()</tt>
								</font></td>
<td valign="top">
<foNT SIZE="2">String collation</fONt></TD>
</tR>
<TR>
<TD ValigN="top">
<FONt sizE="2"><TT Class="monofont">messages</TT>
								</FOnt></td>
<td valign="top">
<font size="2"><tT CLASS="monofont">messages&lt;&gt;</tT>
								</FoNT></tD>
<TD VALign="top">
<fONT Size="2">Message string retrieval</fONT></Td>
</tr>
</cOLGRoup>
</table></p>

				<p>It is possible to define your own versions of the facets to create specialized locales. The following examples demonstrates how this is done. It defines a facet using German representations of the Boolean values:</p>

				<pre>
					
    class germanBoolNames : public std::numpunct_byname&lt;char&gt; {
      public:
        germanBoolNames (const char *name)
          : std::numpunct_byname&lt;char&gt;(name) {
        }
      protected:
        virtual std::string do_truename() const {
            return "wahr";
        }
        virtual std::string do_falsename() const {
            return "falsch";
        }
    };

				</pre>

				<p>The class <tt cLASS="monofont">germanBoolNames</TT> derives from the class <tT ClASs="monofont">numpunct_byname,</TT> which is defined by the C++ standard library. This class defines punctuation properties depending on the locale used for numeric formatting. Deriving from <TT CLass="monofont">numpunct_byname</tT> instead of from <TT Class="monofont">numpunct</TT> lets you customize the members not overridden explicitly. The values returned from these members still depend on the name used as the argument to the constructor. If the class <TT clasS="monofont">numpunct</TT> had been used as the base class, the behavior of the other functions would be fixed. However, the class <Tt class="monofont">germanBoolNames</tt> overrides the two functions used to determine the textual representation of <tt class="monofont">true</tt> and <tt clASS="monofont">false.</TT></P>

				<p>To use this facet in a locale, you need to create a new locale using a special constructor of the class <TT cLAsS="monofont">locale.</TT> This constructor takes a locale object as its first argument and a pointer to a facet as its second argument. The created locale is identical to the first argument except for the facet that is passed as the second argument. This facet is installed in the newly create locale after the first argument is copied:</P>

				<PRe>
					
    std::locale loc (std::locale(""), new germanBoolNames(""));

				</pre>

				<P>The new expression creates a facet that is installed in the new locale. Thus, it is registered in <TT Class="monofont">loc</TT> to create a variation of <TT clasS="monofont">locale("").</TT> Since locales are immutable, you have to create a new locale object if you want to install a new facet to a locale. This locale object can be used like any other locale object. For example,</P>

				<pre>
					
    std::cout.imbue(loc);
    std::cout &lt;&lt; std::boolalpha &lt;&lt; true &lt;&lt; std::endl;

				</pre>

				<p>would have the following output:</p>

				<pre>
					
    wahr

				</pre>

				<p>You also can create a completely new facet. In this case, the function <tt clasS="monofont">has_facet()</TT> can be used to determine whether such a new facet is registered for a given locale object.</P>

			
		</FOnT>
 
<table width="100%" border="0" cellspacing="0" cellpadding="0" bgcolor="#CCCCCC">
<td><font color="black" size=1>I l<font color="#FF0000">@</font>ve RuBoard</td>
<td valign="top" class="v2" align="right"><a href="0201379260_snode117.html"><img src="FILES/previous.gif" width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a> <a href="0201379260_snode119.html"><img src="FILES/next.gif" width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a></td></table>
</BODY></HTML>