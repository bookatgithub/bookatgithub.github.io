<HTML><HEAD><META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=iso-8859-1">
<!--SafClassName="docSection1Title"--><!--SafTocEntry="14.4 Facets in Detail"-->
<LINK REL="stylesheet" href="FILES/sbolM.css">
</HEAD>
<BODY link="#354278" vlink="#000066" alink="#000080" topmargin="0">
<table width="100%" border="0" cellspacing="0" cellpadding="0" bgcolor="#CCCCCC">
<td><font color="black" size=1>I l<font color="#FF0000">@</font>ve RuBoard</td>
<td valign="top" class="v2" align="right"><a href="0201379260_snode119.html"><img src="FILES/previous.gif" width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a> <a href="0201379260_cnode121.html"><img src="FILES/next.gif" width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a></td></table>
<FONT><h3>14.4
Facets in Detail</h3>
			<p>The important aspect of locales are the contained facets. All locales are guaranteed to contain certain standard facets. The description of the individual facets in the following subsections provides which instantiations of the corresponding facet are guaranteed. In addition to these facets, an implementation of the C++ standard library may provide additional facets in the locales. What is important is that the user can also install her own facets or replace standard ones.</p>

			<P><A href="0201379260_snode118.html#4">Section 14.2.2</a>, discussed how to install a facet in a locale. For example, the class <tT CLAss="monofont">germanBoolNames</tt> was derived from the class <TT CLass="monofont">numpunct_byname&lt;char&gt;,</tt> one of the standard facets, and installed in a locale using the constructor, taking a locale and a facet as arguments. But what do you need to create your own facet? Every class F that conforms to the following two requirements can be used as a facet:</p>

			<ol type="1" start="restarts">
<li><p><tT CLASS="monofont">F</tT> derives publically from class <Tt CLaSS="monofont">locale::facet.</TT> This base class mainly defines some mechanism for reference counting that is used internally by the locale objects. It also declares the copy constructor and the assignment operator to be private, thereby making it infeasible to copy or to assign facets.</P>
</Li>
<li><p><TT CLass="monofont">F</tT> has a publically accessible static member named <TT Class="monofont">id</TT> of type <TT class="monofont">locale::id.</tt> This member is used to look up a facet in a locale using the facet's type. The whole issue of using a type as the index is to have a type-safe interface. Internally, a normal container with an integer as the index is used to maintain the facets.</p>

				</li>
</ol>

			<p>The standard facets conform not only to these requirements but also to some special implementation guidelines. Although conforming to these guidelines is not required, doing so is useful. The guidelines are as follows:</p>

			<ol type="1" sTART="restarts">
<LI><p>All member functions are declared to be <TT cLAsS="monofont">const.</TT> This is useful because <TT Class="monofont">use_facet()</TT> returns a reference to a <TT clasS="monofont">const</TT> facet. Member functions that are not declared to be <Tt claSS="monofont">const</TT> can't be invoked.</p>
</li>
<li><p>All public functions are nonvirtual and delegate each request to a protected virtual function. The protected function is named like the public one, with the addition of a leading <tt class="monofont">do_.</tt> For example, <tt clasS="monofont">numpunct::truename()</TT> calls <TT ClASs="monofont">numpunct::do_truename().</TT> This style is used to avoid hiding member functions when overriding only one of several virtual member functions that has the same name. For example, the class <tT CLASS="monofont">num_put</tt> has several functions named <tt CLASs="monofont">put().</tt> In addition, it gives the programmer of the base class the possibility of adding some extra code in the nonvirtual functions, which is executed even if the virtual function is overridden.</p>

				</LI>
</OL>

			<p>The following description of the standard facets concerns only the public functions. To modify the facet you have always to override the corresponding protected functions. If you define functions with the same interface as the public facet functions, they would only overload them because these functions are not virtual.</p>

			<p>For most standard facets, a <tT CLAss="monofont">"_byname"</tt> version is defined. This version derives from the standard facet and is used to create an instantiation for a corresponding locale name. For example, the class <tt class="monofont">numpunct_byname</tt> is used to create the <tt class="monofont">numpunct</tT> facet for a named locale. For example, a German <TT CLAsS="monofont">numpunct</Tt> facet can be created like this:</P>

			<PrE>
				
    std::numpunct_byname("de_DE")

			</PRE>

			<P>The <Tt claSS="monofont">_byname</TT> classes are used internally by the locale constructors that take a name as an argument. For each of the standard facets supporting a name, the corresponding <tt clASS="monofont">_byname</Tt> class is used to construct an instant of the facet.</p>

			<a nAME="1"></A><h4>14.4.1
Numeric Formatting</h4>
				<p>Numeric formatting converts between the internal representation of numbers and the corresponding textual representations. The iostream operators delegate the actual conversion to the facets of the <tt class="monofont">locale::numeric</tt> category. This category is formed by three facets:</p>

				<ol type="1" stART="restarts">
<LI><P><tT ClASs="monofont">numpunct,</TT> which handles punctuation symbols used for numeric formatting and parsing</P>
</LI>
<Li><p><tt CLASs="monofont">num_put,</tt> which handles numeric formatting</p>
</LI>
<LI><p><tt cLASS="monofont">num_get,</tt> which handles numeric parsing</p>

					</li>
</ol>

				<p>In short, the facet <tt class="monofont">num_put</tt> does the numeric formatting described for iostreams in <a href="0201379260_snode107.html">Section 13.7</A>, and <TT CLaSS="monofont">num_get</tT> parses the corresponding strings. Additional flexibility not directly accessible through the interface of the streams is provided by the <Tt CLASS="monofont">numpunct</Tt> facet.</p>

				<h5>Numeric Punctuation</h5>
					<P>The <TT Class="monofont">numpunct</TT> facet controls the symbol used as the decimal point, the insertion of optional thousands separators, and the strings used for the textual representation of Boolean values. <A href="0201379260_snode120.html#3">Table 14.7</a> lists the members of <TT CLass="monofont">numpunct.</tt></p>

					<a name="3"></a><p><table borDER="1" CELlSPaCInG="0" CELLPaddiNG="1" WIdth="100%">
<cAPTIon><h5>Table 14.7. Members of the <tT CLAss="monofont">numpunct</tt> Facet</h5></caption><colgroup aLIGN="left" SPaN="2">
<Tr>
<TH vALIGN="top">
<Font sIZE="2"><B>Expression</b>
									</fonT></TH>
<Th valIGN="top">
<Font size="2"><b>Meaning</b>
									</font></th>
</tr>
<tr>
<td VALIGN="top">
<fONt SIzE="2"><TT CLAss="monofont">np.decimal_point()</tt>
									</FONT></td>
<td VALIgn="top">
<foNT SIze="2">Returns the character used as the decimal point</font></td>
</tr>
<tr>
<td valign="top">
<fONT SIZe="2"><TT cLAsS="monofont">np.thousands_sep()</TT>
									</FONt></td>
<tD VALign="top">
<fONT Size="2">Returns the character used as the thousands separator</fONT></Td>
</tr>
<tr>
<td valign="top">
<font size="2"><TT CLASs="monofont">np.grouping()</TT>
									</fONt></TD>
<TD VAlign="top">
<FONT size="2">Returns a <TT CLass="monofont">string</tT> describing the positions of the thousands separators
</FONt></td>
</tr>
<tr>
<td valign="top">
<font siZE="2"><TT CLaSS="monofont">np.truename()</tT>
									</FoNT></TD>
<TD valiGN="top">
<FOnt siZE="2">Returns the textual representation of <TT clasS="monofont">true</TT>
									</Font></td>
</tr>
<tr>
<td valign="top">
<font SIZE="2"><TT cLAsS="monofont">np.falsename()</Tt>
									</FONT></TD>
<td vaLIGN="top">
<font SIZE="2">Returns the textual representation of <tt clASS="monofont">false</Tt>
									</font></td>
</tr>
</colgroup>
</tablE></P>

					<P><TT ClASs="monofont">numpunct</TT> takes a character type <tT CLASS="monofont">charT</tt> as the template argument. The characters returned from <tt CLASs="monofont">decimal_point()</tt> and <tT CLAss="monofont">thousand.sep()</tt> are of this type, and the functions <TT CLass="monofont">truename()</tt> and <tt class="monofont">falsename()</tt> return a <tt class="monofont">basic_string&lt;charT&gt;.</TT> The two instantiations <TT CLaSS="monofont">numpunct&lt;char&gt;</tT> and <Tt CLASS="monofont">numpunct&lt;wchar_t&gt;</Tt> are required.</p>

					<p>Because long numbers are hard to read without intervening characters, the standard facets for numeric formatting and numeric parsing support thousands separators. Often, the digits representing an integer are grouped into triples. For example, one million is written like this:</p>

					<PRE>
						
    1,000,000

					</Pre>

					<p>Unfortunately, it is not used everywhere exactly like that. For example, in German a period is used instead of a comma. Thus, a German would write one million like this:</p>

					<PRE>
						
    1.000.000

					</Pre>

					<p>This difference is covered by the <tT CLAss="monofont">thousands_sep()</tt> member. But this is not sufficient because in some countries digits are not put into triples. For example, in Nepal people would write</p>

					<pre>
						
    10.00.000

					</pre>

					<p>using even different numbers of digits in the groups. This is where the string returned from the function <tt class="monofont">grouping()</tt> comes in. The number stored at index <I>i</I> gives the number of digits in the <I>i</I>th group, where counting starts with zero for the rightmost group. If there are fewer characters in the string than groups, the size of the last specified group is repeated. To create unlimited groups, you can use the value <TT cLAsS="monofont">numeric_limits&lt;char&gt;: :max()</Tt> or, if there is no group at all, the empty string.<A href="0201379260_snode120.html#4">Table 14.8</A> lists some examples of the formatting of one million.</p>

					<a naME="4"></A><P><tablE BORder="1" cELLSpacing="0" cellpadding="1" widtH="100%">
<CAPTIoN><H5>Table 14.8. Examples of Numeric Punctuation of One Million</h5></CApTION><COlgroUP ALign="left" sPAN="2">
<Tr>
<th vALIGn="top">
<font size="2"><b>String</b>
									</font></th>
<th vaLIGN="top">
<FOnT SiZE="2"><b>Result</B>
									</FONT></Th>
</tr>
<tR>
<TD ValigN="top">
<FONt sizE="2"><TT Class="monofont">{ 0 } or "" (the default for grouping())</tt>
									</font></td>
<td valign="top">
<fONT SIZe="2"><TT cLAsS="monofont">1000000</TT>
									</FONt></td>
</tR>
<TR>
<Td valIGN="top">
<Font sIZE="2"><Tt class="monofont">{ 3, 0 } or "\3"</tt>
									</font></td>
<td valigN="top">
<FONT SiZE="2"><tT ClASS="monofont">1,000,000</TT>
									</Font></tD>
</TR>
<Tr>
<td vALIGn="top">
<fonT SIZe="2"><tt class="monofont">{ 3, 2, 3, 0 } or "\3\2\3"</tt>
									</font></td>
<td valIGN="top">
<FONt SIzE="2"><Tt CLASS="monofont">10,00,000</Tt>
									</fonT></TD>
</Tr>
<tr>
<tD VALign="top">
<fONT Size="2"><tt class="monofont">{ 2, CHAR_MAX, 0 }</tt>
									</font></td>
<td vALIGN="top">
<FoNT sIZe="2"><TT CLASs="monofont">10000,00</tt>
									</fONT></Td>
</tr>
</cOLGRoup>
</tABLE></p>

					<p>Note that normal digits are usually not very useful. For example, the string <tt class="monofont">"2"</tt> specifies groups of 50 digits for ASCII encoding because the character <tt class="monofont">'2'</tt> has the integer value <tT CLASS="monofont">50</tT> in the ASCII character set.</P>

				
				<h5>Numeric Formatting</H5>
					<P>The <tT CLASS="monofont">num_put</tt> facet is used for textual formatting of numbers. It is a template class that takes two template arguments: the type <tt CLASs="monofont">charT</tt> of the characters to be produced and the type <tT CLAss="monofont">OutIt</tt> of an output iterator to the location at which the produced characters are written. The output iterator defaults to <TT CLass="monofont">ostreambuf _iterator&lt;charT&gt;.</tt> The <tt class="monofont">num_put</tt> facet provides a set of functions, all called <tt class="monofont">put()</TT> and differing only in the last argument. You can use the facet as follows:</P>

					<PRE>
						
    std::locale      loc;
    OutIt            to = ...;
    std: : ios_base&amp; fmt = ...;
    charT            fill = ...;
    T                value = ...;


    <i>//get numeric output facet of the</I> loc <I>locale</i> 
    const std::num_put&lt;charT,OutIt&gt;&amp; np 
     = std::use_facet&lt;std::num_put&lt;charT,OutIt&gt;(loc);


    <I>//write value with numeric output facet</I>
    np.put(to, fmt, fill, value);

					</pRE>

					<P>These statements would produce a textual representation of the value <TT Class="monofont">value</TT> using characters of type <TT clasS="monofont">charT</TT> written to the output iterator <Tt claSS="monofont">to.</TT> The exact format is determined from the formatting flags stored in <tt class="monofont">fmt,</tt> where the character <tt class="monofont">fill</tt> is used as a fill character. The <tt cLASS="monofont">put()</TT> function returns an iterator pointing immediately after the last character written.</p>

					<P>The facet <Tt CLaSS="monofont">num_put</TT> provides member functions that take objects of types <TT clasS="monofont">bool, long, unsigned long, double, long double,</TT> and <Tt claSS="monofont">void*</TT> as the last argument. It does not provide member functions, for example, for <tt clASS="monofont">short</Tt> or <tt class="monofont">int.</tt> This is no problem because corresponding values of built-in types are promoted to supported types if necessary.</p>

					<p>The standard requires that the two instantiations <tt class="monofont">num_put&lt;char&gt;</tt> and <TT CLASs="monofont">num_put&lt;wchar_t&gt;</TT> are stored in each locale (both using the default for the second template argument). In addition, the C++ standard library supports all instantiations that take a character type as the first template argument and an output iterator type as the second. Of course, it is not required that all of these instantiations are stored in each locale because this would be an infinite amount of facets.</p>

				
				<H5>Numeric Parsing</H5>
					<p>The facet <TT CLASs="monofont">num_get</tt> is used to parse textual representations of numbers. Corresponding to the facet <tT CLAss="monofont">num_put,</tt> it is a template that takes two template arguments: the character type <TT CLass="monofont">charT</tT> and an input iterator type <TT Class="monofont">InIt,</tt> which defaults to <tt class="monofont">istreambuf _iterator&lt;charT&gt;.</tt> It provides a set of <tt clasS="monofont">get()</TT> functions that differ only in the last argument. You can use the facet as follows:</P>

					<PRe>
						
    std::locale      loc;
    InIt             from = ...;
    InIt             end = ...;
    std::ios_base&amp;   fmt = ...;
    std::ios_base::ios_state err;
    T             value;


    <I>//get numeric input facet of the</I> loc <i>locale</I>
    const std::num_get&lt;charT,InIt&gt;&amp; ng
    = std::use_facet&lt;std::num_get&lt;charT,InIt&gt;(loc);


    <I>// read value with numeric input facet</i>
    ng.get(from, end, fmt, err, value);

					</PRE>

					<P>These statements attempt to parse a numeric value corresponding to the type T from the sequence of characters between <TT clasS="monofont">from</TT> and <Tt claSS="monofont">end.</TT> The format of the expected numeric value is defined by the argument <tt clASS="monofont">fmt.</Tt> If the parsing fails, <tt class="monofont">err</tt> is modified to contain the value <tt class="monofont">ios_base: :failbit.</tt> Otherwise, <tt CLASS="monofont">ios_base: :goodbit</Tt> is stored in <TT cLAsS="monofont">err</TT> and the parsed value in <TT Class="monofont">value.</TT> The value of <TT clasS="monofont">value</TT> is modified only if the parsing is successful. <Tt claSS="monofont">get()</TT> returns the second parameter <tt class="monofont">(end)</tt> if the sequence was used completely. Otherwise, it returns an iterator pointing to the first character that could not be parsed as part of the numeric value.</p>

					<p>The facet <tt class="monofont">num_get</tt> supports functions to read objects of the types <tT CLASS="monofont">bool, long, unsigned short, unsigned int, unsigned long, float, double, long double, and void*.</tT> There are some types for which there is no corresponding function in the <Tt CLaSS="monofont">num_put</TT> facet; for example, <TT clasS="monofont">unsigned short.</TT> This is because writing a value of type <Tt claSS="monofont">unsigned short</TT> produces the same result as writing a value of type <tt clASS="monofont">unsigned short</Tt> promoted to an <tt class="monofont">unsigned long.</tt> However, reading a value as type <tt class="monofont">unsigned long</tt> and then converting it to <tt CLASS="monofont">unsigned short</Tt> may yield a different value than reading it as type <TT cLAsS="monofont">unsigned short</TT> directly.</P>

					<P>The standard requires that the two instantiations <Tt claSS="monofont">num_get&lt;char&gt;</TT> and <tt clASS="monofont">num_get&lt;wchar_t&gt;</Tt> be stored in each locale (both using the default for the second template argument). In addition, the C++ standard library supports all instantiations that take a character type as the first template argument and an input iterator type as the second. As with <tt cLASS="monofont">num_put,</tt> not all supported instantiations are required to be present in all locale objects.</p>

				
			
			<h4>14.4.2
Time and Date Formatting</h4>
				<p>The two facets <tt class="monofont">time_get</tt> and <tt clasS="monofont">time_put</TT> in the category <TT ClASs="monofont">time</TT> provide services for parsing and formatting times and dates. This is done by the member functions that operate on objects of type <tT CLASS="monofont">tm.</tt> This type is defined in the header tile <tt CLASs="monofont">&lt;ctime&gt;.</tt> The objects are not passed directly; rather, a pointer to them is used as the argument.</p>

				<P>Both facets in the <TT Class="monofont">time</TT> category depend heavily on the behavior of the function <TT class="monofont">strftime()</tt> (also defined in the header file <tt class="monofont">&lt;ctime&gt;</tt>). This function uses a string with conversion specifiers to produce a string from a <tt claSS="monofont">t</TT>m object. <A href="0201379260_snode120.html#9">Table 14.9</a> provides a brief summary of the conversion specifiers. The same conversion specifiers are also used by the <TT cLASS="monofont">time_put</TT> facet.</p>

				<p>Of course, the exact string produced by <tt CLASs="monofont">strftime()</tt> depends on the C locale in effect. The examples in the table are given for the <tT CLAss="monofont">"C"</tt> locale.</P>

				<H5>Time and Date Parsing</H5>
					<P>The facet <tt class="monofont">time_get</tt> is a template that takes a character type <tt class="monofont">charT</tt> and an input iterator type <tt cLASS="monofont">InIt</TT> as template arguments. The input iterator type defaults to <tT ClASs="monofont">istreambuf _iterator&lt;charT&gt;.</TT>
						<A href="0201379260_snode120.html#10">Table 14.10</a> lists the members defined for the <tt CLASs="monofont">time_get</tt> facet. All of these members, except <tT CLAss="monofont">date_order(),</tt> parse the string and store the results in the <TT CLass="monofont">tm</tt> object pointed to by the argument <tt class="monofont">t.</tt> If the string could not be parsed correctly, either an error is reported (for example, by modifying the argument <tt class="monofont">err</TT>) or an unspecified value is stored. This means that a time produced by a program can be parsed reliably but user input cannot. With the argument <TT CLaSS="monofont">fmt,</tT> other facets used during parsing are determined. Whether other flags from <Tt CLASS="monofont">fmt</Tt> have any influence on the parsing is not specified.</p>

					<p>All functions return an iterator that has the position immediately after the last character read. The parsing stops if parsing is complete or if an error occurs (for example, because a string could not be parsed as a date).</p>

					<P>A function reading the name of a weekday or a month reads both abbreviated names and full names. If the abbreviation is followed by a letter, which would be legal for a full name, the function attempts to read the full name. If this fails, the parsing fails, even though an abbreviated name was already parsed successfully.</P>

					<A Name="9"></a><P><TABle boRDER="1" cellspacing="0" cellpaddinG="1" WIDTH="100%">
<cAPtIOn><H5>Table 14.9. Conversion Specifiers for <TT CLAss="monofont">strftime()</tt></H5></CAPtion><COLGroup ALIGn="left" span="3">
<tr>
<th valign="top">
<font siZE="2"><B>Specifier</B>
									</FOnT></Th>
<TH vALIGN="top">
<Font sIZE="2"><B>Meaning</b>
									</fonT></TH>
<Th valIGN="top">
<Font size="2"><b>Example</b>
									</font></th>
</tr>
<tr>
<td VALIGN="top">
<fONt SIzE="2"><TT CLAss="monofont">%a</tt>
									</FONT></td>
<td VALIgn="top">
<foNT SIze="2">Abbreviated weekday</font></td>
<td valign="top">
<font sIZE="2"><TT ClASs="monofont">Mon</TT>
									</fONT></TD>
</Tr>
<tr>
<tD VALign="top">
<fONT Size="2"><tT CLAss="monofont">%A</tt>
									</font></td>
<td valign="top">
<fonT SIZE="2">Full weekday</FoNT></tD>
<Td VALIGN="top">
<font SIZE="2"><tt clASS="monofont">Monday</Tt>
									</fonT></TD>
</Tr>
<tr>
<td valign="top">
<font size="2"><tt CLASS="monofont">%b</Tt>
									</FOnT></Td>
<TD VALIgn="top">
<foNT SIze="2">Abbreviated month name</foNT></TD>
<td vaLIGN="top">
<font size="2"><tt class="monofont">Jul</tt>
									</font></TD>
</TR>
<TR>
<tD VaLIgN="top">
<FONT Size="2"><tT CLAss="monofont">%B</tt>
									</FONT></td>
<td VALIgn="top">
<font size="2">Full month name</font></td>
<td valIGN="top">
<FONt SIzE="2"><Tt CLASS="monofont">July</Tt>
									</fonT></TD>
</Tr>
<tr>
<tD VALign="top">
<fONT Size="2"><tt class="monofont">%c</tt>
									</font></td>
<td vALIGN="top">
<FoNT sIZe="2">Locale's preferred date and time representation</FONT></TD>
<td vaLIGN="top">
<font SIZE="2"><tt clASS="monofont">Jul 12 21:53:22 1998</Tt>
									</font></td>
</tr>
<tr>
<td valign="top">
<foNT SIZE="2"><tT ClASs="monofont">%d</TT>
									</FONT></td>
<td VALIgn="top">
<foNT SIze="2">Day of the month</foNT></TD>
<td valign="top">
<font size="2"><tt claSS="monofont">12</TT>
									</FOnT></Td>
</TR>
<tR>
<TD VALign="top">
<fONT Size="2"><tT CLAss="monofont">%H</tt>
									</FONT></td>
<td valign="top">
<font size="2">Hour of the day using a 24-hour clock</fonT></TD>
<TD VaLIgN="top">
<FoNT SIZE="2"><tt clASS="monofont">21</Tt>
									</fonT></TD>
</Tr>
<tr>
<tD VALign="top">
<font size="2"><tt class="monofont">%I</tt>
									</fONT></TD>
<Td VAlIGn="top">
<FONT SIze="2">Hour of the day using a 12-hour clock</foNT></TD>
<td vaLIGN="top">
<font SIZE="2"><tt class="monofont">9</tt>
									</font></td>
</tr>
<tr>
<td VALIGN="top">
<fONt SIzE="2"><TT CLAss="monofont">%j</tt>
									</FONT></td>
<td VALIgn="top">
<foNT SIze="2">Day of the year</font></td>
<td valign="top">
<font sIZE="2"><TT ClASs="monofont">193</TT>
									</fONT></TD>
</Tr>
<tr>
<tD VALign="top">
<fONT Size="2"><tT CLAss="monofont">%m</tt>
									</font></td>
<td valign="top">
<fonT SIZE="2">Month as decimal number</FoNT></tD>
<Td VALIGN="top">
<font SIZE="2"><tt clASS="monofont">7</Tt>
									</fonT></TD>
</Tr>
<tr>
<td valign="top">
<font size="2"><tt CLASS="monofont">%M</Tt>
									</FOnT></Td>
<TD VALIgn="top">
<foNT SIze="2">Minutes</foNT></TD>
<td vaLIGN="top">
<font size="2"><tt class="monofont">53</tt>
									</font></TD>
</TR>
<TR>
<tD VaLIgN="top">
<FONT Size="2"><tT CLAss="monofont">%P</tt>
									</FONT></td>
<td VALIgn="top">
<font size="2">Morning or evening <tt class="monofont">(am or pm)</tt>
									</foNT></TD>
<TD vALiGN="top">
<fONT SIZe="2"><tt cLASS="monofont">pm</tt>
									</foNT></TD>
</tr>
<tr>
<TD VAlign="top">
<font size="2"><tt class="monofont">%S</tt>
									</FONT></TD>
<tD VaLIgN="top">
<FONT Size="2">Seconds</fONT></Td>
<td vALIGn="top">
<fonT SIZe="2"><tt class="monofont">22</tt>
									</font></td>
</tr>
<tr>
<tD VALIGn="top">
<FOnT SiZE="2"><TT CLass="monofont">%U</tT>
									</FONt></td>
<tD VALign="top">
<fONT Size="2">Week number starting with the first Sunday</font></td>
<td valign="top">
<font SIZE="2"><TT cLAsS="monofont">28</Tt>
									</FONT></TD>
</tr>
<tr>
<TD VAlign="top">
<FONT size="2"><TT CLass="monofont">%W</tt>
									</font></td>
<td valign="top">
<foNT SIZE="2">Week number starting with the first Monday</fONt></TD>
<tD VALIGn="top">
<fonT SIZe="2"><tt cLASS="monofont">28</tt>
									</foNT></TD>
</tr>
<tr>
<td valign="top">
<font size="2"><tT CLASS="monofont">%w</tT>
									</FoNT></tD>
<TD VALign="top">
<fONT Size="2">Weekday as a number (Sunday == 0)</fONT></Td>
<td vALIGn="top">
<font size="2"><tt class="monofont">0</tt>
									</fonT></TD>
</TR>
<Tr>
<TD vALiGN="top">
<FONT size="2"><TT CLass="monofont">%x</tT>
									</FONt></td>
<tD VALign="top">
<font size="2">Locale's preferred date representation</font></td>
<td vaLIGN="top">
<FOnT SiZE="2"><tT CLASS="monofont">Jul 12 1998</tt>
									</foNT></TD>
</tr>
<tr>
<TD VAlign="top">
<FONT size="2"><tt class="monofont">%X</tt>
									</font></td>
<td VALIGN="top">
<fONt SIzE="2">Locale's preferred time representation</FONT></Td>
<td vALIGn="top">
<fonT SIZe="2"><tt cLASS="monofont">21:53:22</tt>
									</font></td>
</tr>
<tr>
<td valign="top">
<fONT SIZe="2"><TT cLAsS="monofont">%y</TT>
									</FONt></td>
<tD VALign="top">
<fONT Size="2">The year without the century</fONT></Td>
<td valign="top">
<font size="2"><tt clASS="monofont">98</TT>
									</FoNT></tD>
</Tr>
<TR>
<TD VAlign="top">
<FONT size="2"><TT CLass="monofont">%Y</tT>
									</FONt></td>
<td valign="top">
<font size="2">The year with the century</foNT></TD>
<TD vALiGN="top">
<fONT SIZe="2"><tt cLASS="monofont">1998</tt>
									</foNT></TD>
</tr>
<tr>
<TD VAlign="top">
<font size="2"><tt class="monofont">%Z</tt>
									</FONT></TD>
<tD VaLIgN="top">
<FONT Size="2">The time zone</fONT></Td>
<td vALIGn="top">
<fonT SIZe="2"><tt class="monofont">MEST</tt>
									</font></td>
</tr>
<tr>
<tD VALIGn="top">
<FOnT SiZE="2"><TT CLass="monofont">%%</tT>
									</FONt></td>
<tD VALign="top">
<fONT Size="2">The literal %</font></td>
<td valign="top">
<font SIZE="2"><TT cLAsS="monofont">7.</Tt>
									</FONT></TD>
</tr>
</coLGROup>
</taBLE></P>

					<p>Whether a function that is parsing a year allows two-digit years is unspecified. The year that is assumed for a two-digit year, if it is allowed, is also unspecified.</p>

					<p><tT CLAss="monofont">date_order()</tt> returns the order in which the day, month, and year appear in a date string. This is necessary for some dates because the order cannot be determined from the string representing a date. For example, the first day in February in the year 2003 may be printed either as <tt class="monofont">3/2/1</tt> or as <tt class="monofont">1/2/3.</tT> Class <TT CLAsS="monofont">time_base,</Tt> which is the base class of the facet <TT cLASS="monofont">time_get,</TT> defines an enumeration called <tt clASS="monofont">dateorder</Tt> for possible dale order values. <a href="0201379260_snode120.html#11">Table 14.11</A> lists these values.</P>

					<p>The standard requires that the two instantiations <tt cLASS="monofont">time_get&lt;char&gt;</tt> and <tt class="monofont">time_get&lt;wchar_t&gt;</tt> are stored in each locale. In addition, the C++ standard library supports all instantiations that take <tt class="monofont">char</tt> or <tT CLASS="monofont">wchar_t</tT> as the first template argument, and a corresponding input iterator as the second. All of these instantiations are not required to be stored in each locale object.</P>

					<a NAmE="10"></A><P><TABle boRDER="1" cellSPACing="0" cELLPadding="1" width="100%">
<caption><h5>Table 14.10. Members of the <tt CLASS="monofont">time_get</Tt> Facet</H5></CaPTiON><COLGroup ALIGn="left" spaN="2">
<TR>
<Th valIGN="top">
<Font size="2"><b>Expression</b>
									</font></th>
<th valiGN="top">
<FONT sIZe="2"><B>Meaning</B>
									</fONT></TH>
</Tr>
<tr>
<tD VALign="top">
<fONT Size="2"><tT CLAss="monofont">tg.get_time (from , to , fmt , err , t</tt> )
</font></td>
<td valign="top">
<fonT SIZE="2">Parses the string between <I>from</i> and <I>to</I> as the time produced by the X specifier for <tT ClASS="monofont">strftime()</TT>
									</Font></tD>
</TR>
<Tr>
<td vALIGn="top">
<fonT SIZe="2"><tt class="monofont">tg.get_date(from,to,fmt ,err,t</tt>)
</font></td>
<td valIGN="top">
<FONt SIzE="2">Parses the string between <I>from</i> and <I>to</I> as the date produced by the x specifier for <TT CLass="monofont">strftime()</tT>
									</FONt></td>
</tR>
<TR>
<Td valIGN="top">
<Font size="2"><tt class="monofont">tg.get_weekday (from, to , fmt , err , t</tt> )
</font></tD>
<TD VALiGN="top">
<fONt SIZE="2">Parses the string between <I>from</I> and <i>to</i> as the name of the weekday
</foNT></TD>
</tr>
<tr>
<TD VAlign="top">
<FONT size="2"><tt class="monofont">tg.get_monthname (from , to , fmt , err , t )</tt>
									</font></td>
<td VALIGN="top">
<fONt SIzE="2">Parses the string between <I>from</I> and <I>to</I> as the name of the month
</Font></tD>
</TR>
<Tr>
<td vALIGn="top">
<fonT SIZe="2"><tt class="monofont">tg.get_year (from, to , fmt , err , t</tt> )
</font></td>
<td valIGN="top">
<FONt SIzE="2">Parses the string between <I>from</i> and <I>to</I> as the year
</FONT></td>
</tr>
<TR>
<TD valiGN="top">
<FOnt siZE="2"><TT class="monofont">tg.date_order( )</tt>
									</font></td>
<td valign="top">
<FONT SIzE="2">Returns the date order used by the facet</FoNT></tD>
</TR>
</COLgrouP>
</TABle></p>

					<a NAME="11"></a><p><taBLE Border="1" cellspacing="0" cellpADDING="1" wIDtH="100%">
<CaPTION><H5>Table 14.11. Members of the Enumeration <tt clASS="monofont">dateorder</Tt></h5></caPTIOn><colGROUp align="left" span="2">
<tr>
<td valign="top">
<fONT SIZe="2"><B>Value</B>
									</fONt></TD>
<TD VAlign="top">
<FONT size="2"><B>Meaning</B>
									</FOnt></td>
</TR>
<TR>
<td valign="top">
<font size="2"><tt claSS="monofont">no_order</TT>
									</FOnT></Td>
<TD vALIGN="top">
<Font sIZE="2">No particular order (for example, a date may be in Julian format)</Font></tD>
</TR>
<Tr>
<td vALIGn="top">
<font size="2"><tt class="monofont">dmy</tt>
									</fonT></TD>
<TD VaLIgN="top">
<FoNT SIZE="2">The order is day, month, year</font></TD>
</TR>
<tr>
<td VALIgn="top">
<foNT SIze="2"><tt class="monofont">mdy</tt>
									</font></td>
<td vaLIGN="top">
<FOnT SiZE="2">The order is month, day, year</fONT></TD>
</Tr>
<tr>
<tD VALign="top">
<fONT Size="2"><tT CLAss="monofont">ymd</tt>
									</font></td>
<td valign="top">
<fonT SIZE="2">The order is year, month, day</FoNT></tD>
</Tr>
<TR>
<TD VAlign="top">
<FONT size="2"><TT CLass="monofont">ydm</tT>
									</FONt></td>
<td valign="top">
<font size="2">The order is year, day, month</foNT></TD>
</TR>
</cOLgROuP>
</TABLE></p>

				
				<h5>Time and Date Formatting</h5>
					<p>The facet <TT CLass="monofont">time_put</tT> is used for formatting times and dates. It is a template that takes as arguments a character type <TT Class="monofont">charT</TT> and an optional output iterator type <TT class="monofont">Out It.</tt> The latter defaults to type <tt class="monofont">ostreambuf_iterator</tt> (see page 665).</p>

					<p>The facet <tt cLASS="monofont">time_put</TT> defines two functions called <tT ClASs="monofont">put(),</TT> which are used to convert the date information stored in an object of type <TT CLass="monofont">tm</tT> into a sequence of characters written to an output iterator. <A href="0201379260_snode120.html#13">Table 14.12</a> lists the members of the facet <tT CLAss="monofont">time_put.</tt></P>

					<A NAme="13"></a><p><table border="1" cellspACING="0" CeLLpADdING="1" WIDth="100%">
<caPTIOn><h5>Table 14.12. Members of the <tt CLASs="monofont">time_put</tt> Facet</h5></CAPTion><colgroup align="left" span="2">
<tR>
<TH VALiGN="top">
<fONt SIZE="2"><B>Expression</B>
									</font></TH>
<TH valiGN="top">
<FOnt siZE="2"><B>Meaning</B>
									</font></th>
</tr>
<tr>
<td valign="top">
<fonT SIZE="2"><Tt CLaSS="monofont">tp.put (oit , fmt ,fill , t , cbeg , cend)</tT>
									</FONT></Td>
<td vALIGn="top">
<fonT SIZe="2">Converts according to the string [cbeg,cend)</fonT></TD>
</Tr>
<tr>
<td valign="top">
<font size="2"><tt CLASS="monofont">tp.put (oit , fmt , fill , t , cvt ,mod)</Tt>
									</FOnT></Td>
<TD VALIgn="top">
<foNT SIze="2">Converts using the conversion specifier cvt</foNT></TD>
</tr>
</coLGROup>
</table></p>

					<p>Both functions write their results to the output iterator <tt class="monofont">oit</tt> and return an iterator pointing immediately after the last character produced. The argument I is of type <tt cLASS="monofont">ios_base</TT> and is used to access other facets and potentially additional formatting information. The character <tT ClASs="monofont">fill</TT> is used when a space character is needed and for filling. The argument <TT CLass="monofont">t</tT> points to an object of type <TT Class="monofont">tm</TT> that is storing the date to be formatted.</P>

					<P>The version of <tt clASS="monofont">put()</Tt> that takes two characters as the last two arguments formats the date found in the tm object to which <tt class="monofont">t</tt> refers, interpreting the argument <tt class="monofont">cvt</tt> like a conversion specifier to <tt CLASS="monofont">strftime().</Tt> This <TT cLAsS="monofont">put()</TT> function does only one conversion; namely, the one specified by the <TT Class="monofont">cvt</TT> character. This function is called by the other <TT clasS="monofont">put()</TT> function for each conversion specifier found. For example, using <Tt claSS="monofont">'X'</TT> as the conversion specifier results in the time that is stored in <tt class="monofont">*t</tt> being written to the output iterator. The meaning of the argument <tt class="monofont">mod</tt> is not defined by the standard. It is intended to be used as a modifier to the conversion as found in several implementations of the <tt cLASS="monofont">strftime()</TT> function.</p>

					<P>The version of <Tt CLaSS="monofont">put()</TT> that takes a string defined by the range [<I>cbeg,cend</I>) to guide the conversion behaves very much like <tt clASS="monofont">strftime().</Tt> It scans the string and writes every character that is not part of a conversion specification to the output iterator <tt cLASS="monofont">oit.</tt> If it encounters a conversion specification introduced by the character <tt CLASs="monofont">%,</tt> it extracts an optional modifier and a conversion specifier. The function continues by calling the other version of <tt class="monofont">put(),</tt> using the conversion specifier and the modifier as the last two arguments. After processing a conversion specification, <tt class="monofont">put()</tt> continues to scan the string.</P>

					<P>Note that this facet is somewhat unusual because it provides a nonvirtual member function; namely, the function <TT CLaSS="monofont">put(),</tT> which uses a string as the conversion specification. This function cannot be overridden in classes derived from <Tt CLASS="monofont">time_put.</Tt> Only the other <tt cLASS="monofont">put()</tt> function can be overridden.</p>

					<p>The standard requires that the two instantiations <TT CLass="monofont">time_put&lt;char&gt;</tT> and <TT Class="monofont">time_put&lt;wchar_t&gt;</tt> are stored in each locale. In addition, the C++ standard library supports all instantiations that take <tt class="monofont">char</tt> or <tt clasS="monofont">wchar_t</TT> as the first template argument and a corresponding output iterator as the second. There is no guaranteed support for instantiations using a type other than char or <TT ClASs="monofont">wchar_t</TT> as the first template argument. Also, it is not guaranteed that any instantiations other than <tT CLASS="monofont">time_put&lt;char&gt;</tt> and <tt CLASs="monofont">time_put&lt;wchar_t&gt;</tt> be stored in locale objects by default.</p>

				
			
			<H4>14.4.3
Monetary Formatting</H4>
				<P>The category <Tt claSS="monofont">monetary</TT> consists of the facets <tt class="monofont">moneypunct, money_get,</tt> and <tt class="monofont">money_put.</tt> The facet <tt cLASS="monofont">moneypunct</TT> defines the format of monetary values. The other two use this information to format or to parse a monetary value.</p>

				<H5>Monetary Punctuation</H5>
					<p>Monetary values are printed differently depending on the context. The formats used in different cultural communities differ widely. Examples of the varying details are the placement of the currency symbol (if present at all), the notation for negative or positive values, the use of national or international currency symbols, and the use of thousands separators. To provide the necessary flexibility, the details of the format are factored into the facet <TT cLASS="monofont">moneypunct.</TT></p>

					<p>The facet <tt CLASs="monofont">moneypunct</tt> is a template that takes as arguments a character type <tT CLAss="monofont">charT</tt> and a Boolean value that defaults to <TT CLass="monofont">false.</tt> The Boolean value indicates whether local (<tt class="monofont">false</tt>) or international (<tt class="monofont">true</TT>) currency symbols are to be used. <A href="0201379260_snode120.html#16">Table 14.13</A> lists the members of the facet <Tt CLaSS="monofont">moneypunct.</TT></P>

					<A name="16"></A><P><TAble bORDEr="1" celLSPAcing="0" cellpadding="1" width="100%">
<cAPTION><h5>Table 14.13. Members of the <TT cLAsS="monofont">moneypunct</TT> Facet</H5></CAptioN><COLgrouP ALIgn="left" spAN="2">
<TR>
<th valign="top">
<font size="2"><b>Expression</b>
									</fonT></TH>
<TH VaLIgN="top">
<FoNT SIZE="2"><b>Meaning</b>
									</foNT></TH>
</tr>
<tr>
<TD VAlign="top">
<FONT size="2"><tt class="monofont">mp.decimal_point()</tt>
									</font></td>
<td VALIGN="top">
<fONt SIzE="2">Returns a character to be used as the decimal point</FONT></Td>
</tr>
<tR>
<TD ValigN="top">
<FONt sizE="2"><TT Class="monofont">mp.thousands _ sep()</tt>
									</font></td>
<td valign="top">
<fONT SIZe="2">Returns a character to be used as the thousands separator</FOnT></Td>
</TR>
<TR>
<TD valiGN="top">
<FOnt siZE="2"><TT clasS="monofont">mp.grouping()</TT>
									</Font></td>
<td valign="top">
<font size="2">Returns a string specifying the placement of the thousands separators</FONT></TD>
</tR>
<Tr>
<TD vALIGN="top">
<Font sIZE="2"><Tt claSS="monofont">mp.curr_symbol()</TT>
									</font></TD>
<TD valign="top">
<font size="2">Returns a string with the currency symbol</font></td>
</tR>
<TR>
<TD VaLIgN="top">
<FoNT SIZE="2"><tt clASS="monofont">mp.positive_sign()</Tt>
									</fonT></TD>
<Td valIGN="top">
<Font size="2">Returns a string with the positive sign</font></td>
</tr>
<tr>
<td vaLIGN="top">
<FOnT SiZE="2"><tT CLASS="monofont">mp.negative_sign()</tt>
									</foNT></TD>
<td vaLIGN="top">
<font SIZE="2">Returns a string with the negative sign</font></td>
</tr>
<tr>
<td valign="top">
<fonT SIZE="2"><Tt CLaSS="monofont">mp.frac_digits()</tT>
									</FONT></Td>
<td vALIGn="top">
<fonT SIZe="2">Returns the number of fractional digits</fonT></TD>
</Tr>
<tr>
<td valign="top">
<font size="2"><tt CLASS="monofont">mp.pos_format()</Tt>
									</FOnT></Td>
<TD VALIgn="top">
<foNT SIze="2">Returns the format to be used for non-negative values</foNT></TD>
</tr>
<tr>
<TD VAlign="top">
<font size="2"><tt class="monofont">mp.neg_format()</tt>
									</FONT></TD>
<tD VaLIgN="top">
<FONT Size="2">Returns the format to be used for negative values</fONT></Td>
</tr>
</cOLGRoup>
</tABLE></p>

					<p><tt class="monofont">moneypunct</tt> derives from the class <tt class="monofont">money_base.</tt> This base class defines an enumeration called <tT CLASS="monofont">part,</tT> which is used to form a <Tt CLaSS="monofont">pattern</TT> for monetary values. The class also defines a type called pattern (which is actually a type definition for <TT clasS="monofont">char [4]</TT>). This type is used to store four values of type <Tt claSS="monofont">part</TT> that form a pattern describing the layout of a monetary value. <a href="0201379260_snode120.html#17">Table 14.14</A> lists the five possible <TT class="monofont">parts</tt> that can be placed in a pattern.</p>

					<a name="17"></a><p><table bORDER="1" CeLLsPAcING="0" CELlpadDING="1" widtH="100%">
<CAPtion><H5>Table 14.14. Parts of Monetary Layout Patterns</H5></CAption><colgroup align="left" spaN="2">
<TR>
<TH VaLIgN="top">
<FoNT SIZE="2"><b>Value</b>
									</foNT></TH>
<th vaLIGN="top">
<font SIZE="2"><b>Meaning</b>
									</font></th>
</tr>
<tr>
<td valign="top">
<fONT SIZe="2"><TT cLAsS="monofont">none</TT>
									</FONt></td>
<tD VALign="top">
<fONT Size="2">At this position, spaces may appear but are not required</fONT></Td>
</tr>
<tr>
<td valign="top">
<font size="2"><TT CLASs="monofont">space</TT>
									</fONt></TD>
<TD VAlign="top">
<FONT size="2">At this position, at least one space is required</FONT></td>
</tr>
<TR>
<TD valign="top">
<font size="2"><tt class="monofont">sign</TT>
									</FONT></tD>
<Td VAlIGN="top">
<FONt sizE="2">At this position, a sign may appear</FONt></td>
</tR>
<TR>
<Td valIGN="top">
<Font size="2"><tt class="monofont">symbol</tt>
									</font></tD>
<TD VALiGN="top">
<fONt SIZE="2">At this position, the currency symbol may appear</FOnt></td>
</TR>
<TR>
<td vaLIGN="top">
<font SIZE="2"><tt class="monofont">value</tt>
									</font></td>
<td valiGN="top">
<FONT sIZe="2">At this position, the value appears</FOnT></TD>
</TR>
</ColgrOUP>
</Table></P>

					<P><TT clasS="monofont">moneypunct</TT> defines two functions that return patterns: the function <Tt class="monofont">neg_format()</tt> for negative values and the function <tt class="monofont">pos_format()</tt> for non-negative values. In a pattern, each of the parts sign, <tt clASS="monofont">symbol,</TT> and <Tt CLaSS="monofont">value</tT> is mandatory, and one of the parts <TT CLAss="monofont">none</tt> and <TT CLass="monofont">space</tT> has to appear. This does not mean, however, that there is really a sign or a currency symbol printed. What is printed at the positions indicated by the parts depends on the values returned from other members of the facet and on the formatting flags passed to the functions for formatting.</P>

					<P>Only the value always appears. Of course, it is placed at the position where the part value appears in the pattern. The value has exactly <Tt claSS="monofont">frac_digits()</TT> fractional digits, with <tt class="monofont">decimal_point()</tt> used as the decimal point (unless there are no fractional digits, in which case no decimal point is used).</p>

					<p>The value may be interspersed with thousands separators, unless the string that is returned from <tt class="monofont">grouping()</tt> is empty. The character used for the thousands separator is the one returned from <tT CLASS="monofont">thousands_sep().</tT> The rules for the placement of the thousands separators are identical to the rules for numeric formatting (see page 705). When monetary values are printed, thousands separators are always inserted according to the string returned from <Tt CLaSS="monofont">grouping().</TT> When monetary values are read, thousands separators are optional unless the grouping string is empty. The correct placement of thousands separators is checked after all other parsing is successful.</P>

					<P>The parts <tt clASS="monofont">space</Tt> and <tt cLASS="monofont">none</tt> control the placement of spaces. <tt CLASs="monofont">space</tt> is used at a position where at least one space is required. During formatting, if <tt class="monofont">ios_base: :internal</tt> is specified in the format flags, fill characters are inserted at the position of the <tt class="monofont">space</tt> or the <TT CLASs="monofont">none</TT> part. Of course, filling is done only if the minimum width specified is not used with other characters. The character used as the space character is passed as the argument to the functions for the formatting of monetary values. If the formatted value does not contain a space, <tT ClASS="monofont">none</TT> can be placed at the last position. space and <Tt claSS="monofont">none</TT> may not appear as the first part in a pattern, and <tt clASS="monofont">space</Tt> may not be the last part in a pattern.</p>

					<p>Signs for monetary values may consist of more than one character. For example, in certain contexts parentheses around a value are used to indicate negative values. At the position where the <tT CLAss="monofont">sign</tt> part appears in the pattern, the first character of the sign appears. All other characters of the sign appear at the end after all other components. If the string for a sign is empty, no character indicating the sign appears. The character that is to be used as a sign is determined with the function <tt class="monofont">positive_sign()</tt> for non-negative values and <tt class="monofont">negative_sign()</tT> for negative values.</P>

					<P>At the position of the <TT ClASs="monofont">symbol</TT> part, the currency symbol appears. The symbol is present only if the formatting flags used during formatting or parsing have the <tT CLASS="monofont">ios_base::showbase</tt> flag set. The string returned from the function <tt CLASs="monofont">curr_symbol()</tt> is used as the currency symbol. The currency symbol is a local symbol to be used to indicate the currency if the second template argument is <tT CLAss="monofont">false</tt> (the default). Otherwise, an international currency symbol is used.</P>

					<P><A href="0201379260_snode120.html#19">Table 14.15</a> illustrates all of this, using the value <tt class="monofont">$-1234.56</tt> as an example. Of course, this means that <tt class="monofont">frac_digits()</tT> returns <TT CLAsS="monofont">2.</Tt> In addition, a width of <TT cLASS="monofont">0</TT> is always used.</p>

					<p>The standard requires that the instantiations <tt CLASs="monofont">moneypunct&lt;char&gt;, moneypunct&lt;wchar_t&gt;, moneypunct&lt;char, true&gt;,</tt> and <tT CLAss="monofont">moneypunct&lt;wchar_t, true&gt;</tt> are stored in each locale. The C++ standard library does not support any other instantiation.</P>

				
				<H5>Monetary Formatting</H5>
					<P>The facet <tt class="monofont">money_put</tt> is used to format monetary values. It is a template that takes a character type <tt class="monofont">charT</tt> as the first template argument and an output iterator <tt cLASS="monofont">OutIt</TT> as the second. The output iterator defaults to <tT ClASs="monofont">ostreambuf _iterator&lt;charT&gt;.</TT> The two member functions <TT CLass="monofont">put()</tT> produce a sequence of characters corresponding to the format specified by a <TT Class="monofont">moneypunct</TT> facet. The value to be formatted is either passed as type long double or as type <TT clasS="monofont">basic_string&lt;charT&gt;.</TT> You can use the facet as follows:</P>

					<a name="19"></a><p><table border="1" celLSPACInG="0" CeLLpADDING="1" widtH="100%">
<CAPtion><H5>Table 14.15. Examples of Using the Monetary Pattern</H5></CAptioN><COLgroup align="left" span="3">
<tr>
<th valIGN="top">
<FONt SIzE="2"><B>Pattern</b>
									</FONT></TH>
<th vaLIGN="top">
<font SIZE="2"><b>Sign</b>
									</foNT></TH>
<th valign="top">
<font size="2"><b>Result</b>
									</fonT></TH>
</TR>
<Tr>
<TD vALiGN="top">
<FONT size="2"><TT CLass="monofont">symbol none sign value</tT>
									</FONt></td>
<tD VALign="top">
<font size="2"> </font></td>
<td vaLIGN="top">
<FOnT SiZE="2">$1234.56</fONT></TD>
</Tr>
<tr>
<tD VALign="top">
<fONT Size="2"><tT CLAss="monofont">symbol none sign value</tt>
									</font></td>
<td valign="top">
<fonT SIZE="2">-</FoNT></tD>
<Td VALIGN="top">
<font SIZE="2">$-1234.56</font></TD>
</TR>
<tr>
<td VALIgn="top">
<font size="2"><tt class="monofont">symbol space sign value</tt>
									</foNT></TD>
<TD vALiGN="top">
<fONT SIZe="2">-</fonT></TD>
<Td valIGN="top">
<Font sIZE="2">$ -1234.56</Font></td>
</tr>
<tr>
<td valign="top">
<font SIZE="2"><TT cLAsS="monofont">symbol space sign value</Tt>
									</FONT></TD>
<td vaLIGN="top">
<font SIZE="2">( )</font></TD>
<TD valign="top">
<font size="2">$ (1234.56)</font></td>
</tR>
<TR>
<TD VaLIgN="top">
<FoNT SIZE="2"><tt clASS="monofont">sign symbol space value</Tt>
									</fonT></TD>
<Td valIGN="top">
<Font size="2">( )</font></td>
<td valign="top">
<FONT SIzE="2">($ 1234.56)</FoNT></tD>
</TR>
<TR>
<Td valIGN="top">
<Font sIZE="2"><Tt claSS="monofont">sign value space symbol</TT>
									</font></td>
<td valign="top">
<font sizE="2">0</FONT></Td>
<TD vALiGN="top">
<FONT size="2">(1234.56 $)</FONT></td>
</tr>
<TR>
<TD valiGN="top">
<FOnt size="2"><tt class="monofont">symbol space value sign</tt>
									</font></td>
<TD VALIgN="top">
<FoNT sIZE="2">-</FONt></td>
<tD VALign="top">
<fONT Size="2">$ 1234.56-</fONT></Td>
</tr>
<tr>
<td valign="top">
<font size="2"><TT CLASs="monofont">sign value space symbol</TT>
									</fONt></TD>
<TD VAlign="top">
<FONT size="2">-</FONT></td>
<td VALIgn="top">
<font size="2">-1234.56 $</font></td>
</tr>
<tr>
<tD VALIGn="top">
<FOnT SiZE="2"><TT CLass="monofont">sign value space symbol</tT>
									</FONt></td>
<tD VALign="top">
<fONT Size="2">-</font></td>
<td valign="top">
<font SIZE="2">-1234.56 $</FOnT></Td>
</TR>
<tR>
<TD VALign="top">
<fONT Size="2"><tT CLAss="monofont">sign value space symbol</tt>
									</FONT></td>
<td valign="top">
<font size="2">-</fonT></TD>
<TD VaLIgN="top">
<FoNT SIZE="2">-1234.56$</font></TD>
</TR>
</colgROUP>
</tablE></P>

					<PRe>
						
    <i>//get monetary output facet of the</i> loc <i>locale</i>
    const std::money_put&lt;charT,OutIt&gt;&amp; mp
    = std::use_facet&lt;std::money_put&lt;charT,OutIt&gt; &gt;(loc);


    <i>// write value with monetary output facet</i>
    mp.put(out, intl, frat, fill, value);

					</pre>

					<p>The argument out is an output iterator of <tt class="monofont">type OutIt</tt> to which the formatted string is written. <tT CLASS="monofont">put()</tT> returns an object of this type pointing immediately after the last character produced. The argument <Tt CLaSS="monofont">intl</TT> indicates whether a local or an international currency symbol is to be used. <TT clasS="monofont">fmt</TT> is used to determine formatting flags, such as the width to be used and the <Tt claSS="monofont">moneypunct</TT> facet defining the format of the value to be printed. Where a space character has to appear, the character <tt clASS="monofont">fill</Tt> is inserted.</p>

					<p>The argument <tt class="monofont">value</tt> has type <tt class="monofont">long double</tt> or type <TT CLASs="monofont">basic_string&lt;charT&gt;.</TT> This is the value that is formatted. If the argument is a string, this string may consist only of decimal digits with an optional leading minus sign. If the first character of the string is a minus sign, the value is formatted as a negative value. After it is determined that the value is negative, the minus sign is discarded. The number of fractional digits in the string is determined from the member function <tT ClASS="monofont">frac_digits()</TT> of the <Tt claSS="monofont">moneypunct</TT> facet.</p>

					<p>The standard requires that the two instantiations <tt CLASs="monofont">money_put&lt;char&gt;</tt> and <tT CLAss="monofont">money_put&lt;wchar_t&gt;</tt> are stored in each locale. In addition, the C++ standard library supports all instantiations that take <tt class="monofont">char</tt> or <tt class="monofont">wchar_t</tT> as the first template argument and a corresponding output iterator as the second. All of these instantiations are not required to be stored in each locale object.</P>

				
				<H5>Monetary Parsing</H5>
					<P>The facet <Tt CLaSS="monofont">money_get</tT> is used for parsing of monetary values. It is a template class that takes a character type <TT CLAss="monofont">charT</tt> as the first template argument and an input iterator type <TT CLass="monofont">InIt</tT> as the second. The second template argument defaults to <TT Class="monofont">istreambuf _iterator&lt;charT&gt;.</TT> This class defines two member functions called <TT class="monofont">get()</tt> that try to parse a character and, if the parse is successful, store the result in a value of type <tt class="monofont">long double</tt> or of type <tt claSS="monofont">basic_string&lt;charT&gt;.</TT> You can use the facet as follows:</P>

					<PrE>
						
    <I>//get monetary input facet of the</i> loc <I>locale</I>
    const std::money_get&lt;charT,InIt&gt;&amp; mg 
     = std::use_facet&lt;std::money_get&lt;charT,InIt&gt; &gt;(loc);


    <i>//read value with monetary input facet</I>
    mg.get(ibeg, iend, intl, fmt, err, val);

					</PRE>

					<P>The character sequence to be parsed is defined by the sequence between <Tt claSS="monofont">ibeg</TT> and <tt clASS="monofont">iend.</Tt> The parsing stops as soon as either all elements of the used pattern are read or an error is encountered. If an error is encountered, the <tt cLASS="monofont">ios_base::failbit</tt> is set in <tt class="monofont">err</tt> and nothing is stored in <tt class="monofont">val.</tt> If parsing is successful, the result is stored in the value of types <tT CLASS="monofont">long double</tT> or <Tt CLaSS="monofont">basic_string</TT> that is passed by reference as argument <TT clasS="monofont">val.</TT></P>

					<p>The argument <tt cLASS="monofont">intl</tt> is a Boolean value that selects a local or an international currency string. The <tt CLASs="monofont">moneypunct</tt> facet defining the format of the value to be parsed is retrieved using the locale object imbued by the argument <tt class="monofont">fmt.</tt> For parsing a monetary value, the pattern returned from the member <tt class="monofont">neg_format()</tt> of the <TT CLASs="monofont">moneypunct</TT> facet is always used.</p>

					<P>At the position of <Tt CLASS="monofont">none</Tt> or <tt cLASS="monofont">space,</tt> the function that is parsing a monetary value consumes all available space, unless <tt CLASs="monofont">none</tt> is the last part in a pattern. Trailing spaces are not skipped. The <tT CLAss="monofont">get()</tt> functions return an iterator that points after the last character that was consumed.</p>

					<p>The standard requires that the two instantiations <tt class="monofont">money_get&lt;char&gt;</tt> and <tt clasS="monofont">money_get&lt;wchar_t&gt;</TT> be stored in each locale. In addition, the C++ standard library supports all instantiations that take <TT ClASs="monofont">char</TT> or <tT CLASS="monofont">wchar_t</tt> as the first template argument and a corresponding input iterator as the second. All of these instantiations are not required to be stored in each locale object.</p>

				
			
			<a NAME="21"></a><h4>14.4.4
Character Classification and Conversion</h4>
				<p>The C++ standard library defines two facets to deal with characters: <TT CLass="monofont">ctype</tT> and <TT Class="monofont">codecvt.</tt> Both belong to the category <tt class="monofont">locale:: ctype.</tt> The facet <tt clasS="monofont">ctype</TT> is used mainly for character classification. such as testing whether a character is a letter. It also provides methods for conversion between lowercase and uppercase letters and for conversion between <TT ClASs="monofont">char</TT> and the character type for which the facet is instantiated. The facet <tT CLASS="monofont">codecvt</tt> is used to convert characters between different encodings and is used mainly by <tt CLASs="monofont">basic_filebuf</tt> to convert between external and internal representations.</p>

				<H5>Character Classification</H5>
					<P>The facet <Tt claSS="monofont">ctype</TT> is a template class parameterized with a character type. Three kinds of functions are provided by the class <tt class="monofont">ctype&lt;charT&gt;:</tt></p>

					<ol type="1" start="restarts">
<LI><P>Functions to convert between <TT ClASs="monofont">char</TT> and <tT CLASS="monofont">charT</tt></p>
</lI>
<LI><P>Functions for character classification</p>
</li>
<lI><P>Functions for conversion between uppercase and lowercase letters</P>

						</Li>
</ol>

					<p><A href="0201379260_snode120.html#23">Table 14.16</a> lists the members defined for the facet <tt class="monofont">ctype.</tt></p>

					<a name="23"></a><p><taBLE BORdER="1" cELlSPACINg="0" celLPADding="1" WIDTh="100%">
<capTION><h5>Table 14.16. Services Defined by the <tt class="monofont">ctype&lt;charT&gt;</tt> Facet</h5></caption><colGROUP AlIGn="left" SPaN="2">
<TR>
<TH ValigN="top">
<FONt sizE="2"><B>Expression</B>
									</Font></tH>
<TH Valign="top">
<font size="2"><b>Effect</b>
									</font></th>
</TR>
<TR>
<TD vALiGN="top">
<fONT SIZe="2"><tt cLASS="monofont">ct.is</tt>(<i>m,c</i>)
</FONT></td>
<td VALIgn="top">
<font size="2">Tests whether the character <i>c</i> matches the mask <i>m</i>
									</font></td>
</tR>
<TR>
<TD VaLIgN="top">
<FoNT SIZE="2"><tt clASS="monofont">ct.is</Tt>(<i>beg ,end, vec</i>)
</fONT></Td>
<td vALIGn="top">
<font size="2">For each character in the range between <i>beg</i> and <i>end,</i> places a mask matched by the character in the corresponding location of <i>vec</i>
									</font></td>
</TR>
<TR>
<TD vALiGN="top">
<fONT SIZe="2"><tt cLASS="monofont">ct.scan_is</tt>(<i>m,beg,end</i>)
</FONT></td>
<td VALIgn="top">
<font size="2">Returns a pointer to the first character in the range between <i>beg</i> and <i>end</i> that matches the mask <i>m</i> or <i>end</i> if there is no such character
</fonT></TD>
</TR>
<Tr>
<TD vALiGN="top">
<FONT size="2"><TT CLass="monofont">ct.scan_not </tT>(<I>m , beg , end</I>)
</Font></tD>
<TD Valign="top">
<font size="2">Returns a pointer to the first character in the range between <i>beg</i> and <i>end</i> that does not match the mask <i>m</i> or <i>end</i> if all characters match the mask
</FONT></TD>
</tR>
<Tr>
<TD vALIGN="top">
<Font sIZE="2"><Tt claSS="monofont">ct.toupper</TT>(<i>c</i>)
</foNT></TD>
<td valign="top">
<font size="2">Returns an uppercase letter corresponding to <i>c</i> if there is such a letter; otherwise <i>c</i> is returned
</fONT></TD>
</Tr>
<TR>
<tD VaLIGN="top">
<FOnt siZE="2"><TT clasS="monofont">ct.toupper</TT>(<I>beg,end*</i>)
</fonT></TD>
<Td valign="top">
<font size="2">Converts each letter in the range between <i>beg</i> and <i>end</i> by replacing the letter with the result of <tt CLASS="monofont">toupper()</Tt>
									</FOnT></Td>
</TR>
<TR>
<TD valiGN="top">
<FOnt siZE="2"><TT clasS="monofont">ct.tolower</TT>(<I>c</i>)
</font></td>
<td valign="top">
<font siZE="2">Returns a lowercase letter corresponding to <I>c</I> if there is such a letter; otherwise <I>c</I> is returned
</fONt></TD>
</tR>
<TR>
<TD ValigN="top">
<FONt sizE="2"><TT Class="monofont">ct.tolower</TT>(<I>beg,end*</I>)
</font></td>
<td valign="top">
<font sizE="2">Converts each letter in the range between <I>beg</I> and <I>end</I> by replacing the letter with the result of <Tt CLaSS="monofont">tolower()</tT>
									</FONT></Td>
</tr>
<tR>
<TD ValigN="top">
<FONt sizE="2"><TT Class="monofont">ct.widen</tt>(<i>c</i>)
</font></td>
<td valigN="top">
<FONT SiZE="2">Returns the char converted to <tT ClASS="monofont">charT</TT>
									</Font></tD>
</TR>
<Tr>
<td vALIGn="top">
<fonT SIZe="2"><tt class="monofont">ct.widen</tt>(<i>beg, end, dest</i>)
</font></td>
<td vALIGN="top">
<FoNT sIZe="2">For each character in the range between <I>beg</I> and <I>end,</I> places the result of <TT clasS="monofont">widen()</TT> at the corresponding location in <I>dest</i>
									</fonT></TD>
</Tr>
<tr>
<tD VALign="top">
<font size="2"><tt class="monofont">ct.narrow </tt>(<i>c , default</I>)
</FONT></Td>
<TD vALiGN="top">
<FONT size="2">Returns the <TT CLass="monofont">charT</tT>
										<I>c</I> converted to <Tt claSS="monofont">char,</TT> or the <tt class="monofont">char</tt>
										<i>default</i> if there is no suitable character
</font></td>
</tr>
<tr>
<TD VALIgN="top">
<FoNT sIZE="2"><TT Class="monofont">ct.narrow </TT>(<I>beg, end, default, dest</I>)
</font></TD>
<TD valiGN="top">
<FOnt size="2">For each character in the range between <i>beg</i> and <i>end,</i>places the result of <tt class="monofont">narrow()</tt> at the corresponding location in <i>dest</i>
									</FONT></TD>
</tR>
</CoLGrOUP>
</TABle></p>

					<p>The function is(<I>beg,end, vec</I>) is used to store a set of masks in an array. For each of the characters in the range between <I>beg</I> and <i>end,</i> a mask with the attributes corresponding to the character is stored in the array pointed to by <i>vec.</i> This is useful to avoid virtual function calls for the classification of characters if there are lots of characters to be classified.</P>

					<P>The function <TT clasS="monofont">widen()</TT> can be used to convert a character of type <Tt class="monofont">char</tt> from the native character set to the corresponding character in the character set used by a locale. Thus, it makes sense to widen a character even if the result is also of type <tt class="monofont">char.</tt> For the opposite direction, the function <tt clASS="monofont">narrow()</TT> can be used to convert a character from the character set used by the locale to a corresponding <Tt CLaSS="monofont">char</tT> in the native character set, provided there is such a <TT CLAss="monofont">char.</tt> For example, the following code converts the decimal digits from <TT CLass="monofont">char</tT> to <TT Class="monofont">wchar_t:</TT></P>

					<Pre>
						
    std::locale loc;
    char narrow[] = "0123456789";
    wchar_t wide [10];


    std::use_facet&lt;std::ctype&lt;wchar_t&gt; &gt;(loc).widen(narrow, narrow+10,
                                                    wide);

					</pre>

					<p>Class <tt class="monofont">ctype</tt> derives from the class <tt clasS="monofont">ctype_base.</TT> This class is used only to define an enumeration called <TT ClASs="monofont">mask.</TT> This enumeration defines values that can be combined to form a bitmask used for testing character properties. The values defined in <tT CLASS="monofont">ctype_base</tt> are shown in <a href="0201379260_snode120.html#24">Table 14.17</A>. The functions for character classification all take a bitmask as an argument, which is formed by combinations of the values defined in <tt clASS="monofont">ctype_base.</Tt> To create bitmasks as needed, you can use the operators for bit manipulation (<tt cLASS="monofont">|, &amp;,^, and ~</tt>). A character matches this mask if it is any of the characters identified by the mask.</p>

					<a name="24"></a><p><table border="1" CELLSPaCInG="0" CeLLPADDing="1" wIDTH="100%">
<captION><H5>Table 14.17. Character Mask Values Used by <tt clASS="monofont">ctype</Tt></h5></caption><colgroup aligN="left" SPAN="2">
<Tr>
<TH vALiGN="top">
<FONT size="2"><B>Value</B>
									</FOnt></th>
<TH VAlign="top">
<FONT size="2"><b>Meaning</b>
									</font></th>
</tr>
<tr>
<td valIGN="top">
<FONt SIzE="2"><Tt CLASS="monofont">ctype_base::alnum</Tt>
									</fonT></TD>
<Td valIGN="top">
<Font sIZE="2">Tests for letters and digits (equivalent to <Tt class="monofont">alpha I digit</tt>)
</font></td>
</tr>
<tr>
<td vALIGN="top">
<FoNT sIZe="2"><TT CLASs="monofont">ctype_base:: alpha</tt>
									</fONT></Td>
<td vALIGn="top">
<fonT SIZe="2">Tests for letters</font></td>
</tr>
<tr>
<td valign="top">
<foNT SIZE="2"><tT ClASs="monofont">ctype_base::cntrl</TT>
									</FONT></td>
<td VALIgn="top">
<foNT SIze="2">Tests for control characters</foNT></TD>
</tr>
<tr>
<td valign="top">
<font size="2"><tT CLASS="monofont">ctype_base:: digit</tT>
									</FoNT></tD>
<TD VALign="top">
<fONT Size="2">Tests for decimal digits</fONT></Td>
</tr>
<tR>
<TD Valign="top">
<font size="2"><tt class="monofont">ctype_base:: graph</tT>
									</FONT></Td>
<TD vALiGN="top">
<FONT size="2">Tests for punctuation characters, letters, and digits (equivalent to <TT CLass="monofont">alnum | punct</tT>)
</FONt></td>
</tR>
<TR>
<Td valign="top">
<font size="2"><tt clasS="monofont">ctype_base :: lower</TT>
									</FONt></TD>
<tD VaLIGN="top">
<FOnt siZE="2">Tests for lowercase letters</FOnt></td>
</TR>
<TR>
<td vaLIGN="top">
<font size="2"><tt class="monofont">ctype_base:: print</tt>
									</font></TD>
<TD VAlIGn="top">
<FOnT SIZE="2">Tests for printable characters</Font></tD>
</TR>
<Tr>
<td vALIGn="top">
<fonT SIZe="2"><tt class="monofont">ctype_base::punct</tt>
									</font></td>
<td valIGN="top">
<FONt SIzE="2">Tests for punctuation characters</FoNT></TD>
</TR>
<tr>
<td VALIgn="top">
<foNT SIze="2"><tt CLASs="monofont">ctype_base :: space</tt>
									</font></td>
<td valign="top">
<font SIZE="2">Tests for space characters</FOnT></Td>
</TR>
<tR>
<TD VALign="top">
<fONT Size="2"><tT CLAss="monofont">ctype_base:: upper</tt>
									</FONT></td>
<td valign="top">
<font size="2">Tests for uppercase letters</fonT></TD>
</TR>
<Tr>
<TD vALiGN="top">
<FONT size="2"><TT CLass="monofont">ctype_base::xdigit</tT>
									</FONt></td>
<tD VALign="top">
<font size="2">Tests for hexadecimal digits</font></td>
</tr>
</coLGROUP>
</tABlE></P>

				
				<h5>Specialization of <TT CLASs="monofont">ctype&lt;&gt;</tt> for Type <tT CLAss="monofont">char</tt></H5>
					<P>For better performance of the character classification functions, the facet <TT clasS="monofont">ctype</TT> is specialized for the character type <Tt class="monofont">char.</tt> This specialization does not delegate the functions dealing with character classification (<tt class="monofont">is(), scan_is(),</tt> and <tt clASS="monofont">scan_not()</TT>) to corresponding virtual functions. Instead, these functions are implemented inline using a table lookup. For this case additional members are provided (<A href="0201379260_snode120.html#26">Table 14.18</A>).</P>

					<a NAME="26"></A><P><tablE BORder="1" cELLSpaciNG="0" CEllpadding="1" width="100%">
<caption><H5>Table 14.18. Additional Members of <TT CLAsS="monofont">ctype&lt;char&gt;</Tt></H5></CaPTION><ColgrOUP Align="left" SPAN="2">
<tr>
<th VALIgn="top">
<font size="2"><b>Expression</b>
									</font></th>
<th vALIGN="top">
<FoNT sIZe="2"><B>Effect</B>
									</FONT></th>
</tr>
<TR>
<TD valiGN="top">
<FOnt siZE="2"><TT class="monofont">ctype&lt;char&gt;::table_size</tt>
									</font></td>
<td valign="top">
<FONT SIzE="2">Returns the size of the table (<Tt CLaSS="monofont">&gt;=256</TT>)
</FOnt></td>
</TR>
<TR>
<td vaLIGN="top">
<font SIZE="2"><tt class="monofont">ctype&lt;char&gt;:: classic_table()</tt>
									</font></td>
<td valiGN="top">
<FONT sIZe="2">Returns the table for the "classic" C locale</FOnT></TD>
</TR>
<Tr>
<td vALIGn="top">
<fonT SIZe="2"><tt cLASS="monofont">ctype&lt;char&gt; (</tt><i>table,del</i><tt class="monofont">=false)</tt>
									</font></td>
<td VALIGN="top">
<fONt SIzE="2">Creates the facet with table <I>table</I>
									</FONt></td>
</tR>
<TR>
<Td valIGN="top">
<Font sIZE="2"><Tt class="monofont">ct. table()</tt>
									</font></td>
<td valigN="top">
<FONT SiZE="2">Returns the actual table of facet <tT ClASS="monofont">ct</TT>
									</Font></tD>
</TR>
</ColgrOUP>
</Table></P>

					<P>Manipulating the behavior of these functions for specific locales is done with a corresponding table of masks that is passed as a constructor argument:</P>

					<Pre>
						
    <i>// create and initialize the table</i>
    std::ctype_base::mask mytable[std::ctype&lt;char&gt;::table_size] = {
         ...
    };


    <i>// use the table for the</i>  ctype&lt;char&gt;<i>facet</i> ct
                 std::ctype&lt;char&gt; ct(mytable, false);

					</pre>

					<p>This code constructs a <tt class="monofont">ctype&lt;char&gt;</tt> facet that uses the table <TT CLASs="monofont">mytable</TT> to determine the character class of a character. More precisely, the character class of the character c is determined by</p>

					<PRe>
						
    mytable[static_cast&lt;unsigned char&gt;(c)]

					</PRE>

					<P>The static member <TT clasS="monofont">table_size</TT> is a constant defined by the library implementation and gives the size of the lookup table. This size is at least 256 characters. The second optional argument to the constructor of <Tt claSS="monofont">ctype&lt;char&gt;</TT> indicates whether the table should be deleted if the facet is destroyed. If it is <tt clASS="monofont">true,</Tt> the table passed to the constructor is released by using <tt class="monofont">delete []</tt> when the facet is no longer needed.</p>

					<p>The member function <tt class="monofont">table()</tt> is a protected member function that returns the table that is passed as the first argument to the constructor. The static protected member function <TT CLASs="monofont">classic_table()</TT> returns the table that is used for character classification in the classic <tT ClASS="monofont">C</TT> locale.</P>

				
				<h5>Global Convenience Functions for Character Classification</h5>
					<p>Convenient use of the <tT CLAss="monofont">ctype</tt> facets is provided by predefined global functions. <A href="0201379260_snode120.html#28">Table 14.19</a> lists all of the global functions.</p>

					<a NAME="28"></a><p><table border="1" cellspacING="0" CELlPAdDInG="1" WIDTH="100%">
<captION><H5>Table 14.19. Global Convenience Functions for Character Classification</h5></capTION><colgROUP align="left" span="2">
<tr>
<th valign="top">
<foNT SIZE="2"><b>Function</B>
									</FoNT></tH>
<TH VALign="top">
<fONT Size="2"><b>Effect</B>
									</FONt></th>
</tR>
<TR>
<Td valign="top">
<font size="2"><tt clasS="monofont">isalnum</TT>(<I>c, loc</I>)
</FoNT></tD>
<Td VALIGN="top">
<font SIZE="2">Returns whether <i>c</i> is a letter or a digit (equivalent to <tt CLASs="monofont">isalpha()&amp;&amp;isdigit()</tt>)
</fONT></Td>
</tr>
<tr>
<td valign="top">
<font size="2"><TT CLASs="monofont">isalpha</TT>(<i>c, loc</I>)
</FoNT></TD>
<TD valiGN="top">
<FOnt siZE="2">Returns whether <I>c</I> is a letter
</font></TD>
</TR>
<tr>
<td valign="top">
<font size="2"><tt cLASS="monofont">iscntrl</TT>(<i>c, loc</I>)
</FoNT></tD>
<TD VALign="top">
<fONT Size="2">Returns whether <i>c</I> is a control character
</FONt></td>
</tR>
<TR>
<Td valign="top">
<font size="2"><tt clasS="monofont">isdigit</TT><I>(c, loc)</I>
									</FoNT></tD>
<Td VALIGN="top">
<font SIZE="2">Returns whether <i>c</i> is a digit
</foNT></TD>
</tr>
<tr>
<TD VAlign="top">
<font size="2"><tt class="monofont">isgraph</tt>(<I>c, loc</I>)
</FONT></tD>
<Td VAlIGN="top">
<FONt sizE="2">Returns whether <I>c</I> is a printable, nonspace character (equivalent to <Tt claSS="monofont">isalnum()&amp;&amp;ispunct())</TT>
									</font></TD>
</TR>
<tr>
<td valign="top">
<font size="2"><tt cLASS="monofont">islower</TT>(<i>c, loc</I>)
</FoNT></tD>
<TD VALign="top">
<fONT Size="2">Returns whether <i>c</I> is a lowercase letter
</FONt></td>
</tR>
<TR>
<Td valign="top">
<font size="2"><tt clasS="monofont">isprint</TT> (<I>c, loc</I>)
</FoNT></tD>
<Td VALIGN="top">
<font SIZE="2">Returns whether <i>c</i> is a printable character (including whitespaces)
</foNT></TD>
</tr>
<tr>
<TD VAlign="top">
<font size="2"><tt class="monofont">ispunct</tt>(<I>c, loc</I>)
</FONT></tD>
<Td VAlIGN="top">
<FONt sizE="2">Returns whether <I>c</I> is a punctuation character (that is, it is printable, but it is not a space, digit, or letter)
</Font></tD>
</TR>
<Tr>
<td vALIGn="top">
<font size="2"><tt class="monofont">isspace</tt>(<i>c, loc</i>)
</fONT></TD>
<Td VAlIGn="top">
<FONT SIze="2">Returns whether <i>c</i> is a space character
</FONT></td>
</tr>
<TR>
<TD valiGN="top">
<FOnt size="2"><tt class="monofont">isupper</tt>(<i>c, loc</i>)
</font></TD>
<TD VAlIGn="top">
<FOnT SIZE="2">Returns whether <I>c</i> is an uppercase letter
</fonT></TD>
</Tr>
<tr>
<tD VALign="top">
<fONT Size="2"><tt class="monofont">isxdigit</tt>(<i>c, loc</i>)
</font></td>
<tD VALIGn="top">
<FOnT SiZE="2">Returns whether <I>c</I> is a hexadecimal digit
</FOnt></td>
</TR>
<TR>
<td vaLIGN="top">
<font SIZE="2"><tt class="monofont">tolower</tt>(<i>c, loc</i>)
</font></td>
<td vaLIGN="top">
<FOnT SiZE="2">Converts <i>c</I> from an uppercase letter to a lowercase letter
</FONT></Td>
</tr>
<tR>
<TD ValigN="top">
<FONt sizE="2"><TT Class="monofont">toupper</tt>(<i>c, loc</i>)
</font></td>
<td valigN="top">
<FONT SiZE="2">Converts <i>c</I> from a lowercase letter to an uppercase letter
</FoNT></TD>
</TR>
</colgROUP>
</tablE></P>

					<P>For example, the following expression determines whether the character c is a lowercase letter in the locale <Tt claSS="monofont">loc:</TT></p>

					<pre>
						
    std::islower(c,loc)

					</pre>

					<p>It returns a corresponding value of type <tt class="monofont">bool.</tt></p>

					<p>The following expression returns the character <tt CLASS="monofont">c</Tt> converted to an uppercase letter, if <TT cLAsS="monofont">c</TT> is a lowercase letter in the locale <TT Class="monofont">loc:</TT></P>

					<Pre>
						
    std::toupper(c,loc)

					</prE>

					<P>If <TT clasS="monofont">c</TT> is not a lowercase letter, the first argument is returned unmodified.</P>

					<p>The expression</p>

					<pre>
						
    std::islower(c,loc)

					</pre>

					<p>is equivalent to the following expression:</p>

					<pre>
						
    std::use_facet&lt;std::ctype&lt;char&gt; &gt;(loc).is(std::ctype_base::lower,c)

					</pre>

					<p>This expression calls the member function <tt clASS="monofont">is()</TT> of the facet <Tt CLaSS="monofont">ctype&lt;char&gt;. is()</tT> determines whether the character <TT CLAss="monofont">c</tt> fulfills any of the character properties that are passed as the bitmask in the first argument. The values for the bitmask are defined in the class <TT CLass="monofont">ctype_base.</tT> See page 502 and page 669 for examples of the use of these convenience functions.</P>

					<P>The global convenience functions for character classification correspond to C functions that have the same name but only the first argument. They are defined in <Tt claSS="monofont">&lt;cctype&gt;</TT> and <tt class="monofont">&lt;ctype.h&gt;,</tt> and always use the current global C locale.<font size="1"><sup><a HREF="#FOOTNOTE-4">[4]</A></SuP></FoNT>
 Their use is even more convenient:</p>
<BLOCKQuote><FONT size="1">
<P CLAss="footnote">
<suP><A NAme="FOOTNOTE-4">[4]</a></sup>
This locale is only identical to the global C++ locale if the last call to locale:: global() was with a named locale and if there was no call to <tt class="monofont">setlocale()</tt> since then. Otherwise, the locale used by the C functions is different from the global C++ locale.</p>
</font></bLOCKQUoTE>

						
					<pRE>
						
    if (std::isdigit(c)) 
        ...
    {

					</pRE>

					<P>However, by using them you can't use different locales in the same program. Also, you can't use a user-defined ctype facet using the C function. See page 497 for an example that demonstrates how to use these C functions to convert all characters of a string to uppercase letters.</P>

					<P>It is important to note that the C++ convenience functions should not be used in code sections where performance is crucial. It is much faster to obtain the corresponding facet from the locale and use the functions on this object directly. If a lot of characters are to be classified according to the same locale, this can be improved even more, at least for <Tt claSS="monofont">non-char</TT> characters. The function <tt clASS="monofont">is</Tt>(<i>beg,end,vec</i>) can be used to determine the masks for typical characters: This function determines for each character in the range [<i>beg,end</I>)<TT Class="monofont">a</tt>mask that describes the properties of the character. The resulting mask is stored in <i>vec</i> at the position corresponding to the character's position. This vector can then be used for fast lookup of the characters.</p>

				
				<h5>Character Encoding Conversion</h5>
					<p>The facet <tt class="monofont">codecvt</tt> is used to convert between internal and external character encoding. For example, it can be used to convert between Unicode and EUC (Extended UNIX Code), provided the implementation of the C++ standard library supports a corresponding facet.</P>

					<P>This facet is used by the class <TT CLaSS="monofont">basic_filebuf</tT> to convert between the internal representation and the representation stored in a file. The class <Tt CLASS="monofont">basic_filebuf &lt;charT,traits&gt;</Tt> (see page 627) uses the instantiation <tt cLASS="monofont">codecvt&lt;charT,char.typename traits::state_type&gt;</tt> to do so. The facet used is taken from the locale stored with <tt CLASs="monofont">basic_filebuf.</tt> This is the major application of the <tT CLAss="monofont">codecvt</tt> facet. Only rarely is it necessary to use this facet directly.</p>

					<p>In <a href="0201379260_snode117.html">Section 14.1</a>, some basics of character encodings are introduced. To understanding <tt class="monofont">codecvt,</tt> you need to know that there are two approaches for the encoding of characters: One is character encodings that use a fixed number of bytes for each character (wide-character representation), and the other is character encodings that use a varying number of bytes per character (multibyte representation).</P>

					<P>It is also necessary to know that multibyte representations use so-called <I>shift states</I> for space efficient representation of characters. The correct interpretation of a byte is possible only with the correct shift state at this position. This in turn can be determined only by walking through the whole sequence of multibyte characters (see <A href="0201379260_snode117.html">Section 14.1</a>, for more details).</P>

					<P>The <tT CLASS="monofont">codecvt&lt;&gt;</tt> facet takes three template arguments:</p>

					<oL TYPe="1" staRT="restarts">
<LI><p>The character type <tt cLASS="monofont">internT</tt> used for an internal representation</p>
</li>
<li><p>The type <tt class="monofont">externT</tt> used to represent an external representation</p>
</li>
<lI><P>The type <TT CLaSS="monofont">stateT</tT> used to represent an intermediate state during the conversion</P>

						</lI>
</OL>

					<P>The intermediate state may consist of incomplete wide characters or the current shift state. The C++ standard makes no restriction about what is stored in the objects representing the state.</P>

					<P>The internal representation always uses a representation with a fixed number of bytes per character. Mainly the two types <tt clASS="monofont">char</Tt> and <tt cLASS="monofont">wchar_t</tt> are intended to be used within a program. The external representation may be a representation that uses a fixed size or a multibyte representation. When a multibyte representation is used, the second template argument is the type used to represent the basic units of the multibyte encoding. Each multibyte character is stored in one or more objects of this type. Normally, the type <tt CLASs="monofont">char</tt> is used for this.</p>

					<p>The third argument is the type used to represent the current state of the conversion. It is necessary, for example, if one of the character encodings is a multibyte encoding. In this case, the processing of a multibyte character might be terminated because the source buffer is drained or the destination buffer is full while one character is being processed. If this happens, the current state of the conversion is stored in an object of this type.</p>

					<p>Similar to the other facets, the standard requires support for only a very few conversions. Only the following two instantiations are supported by the C++ standard library:</p>

					<ol type="1" start="restarts">
<li><P><TT CLAsS="monofont">codecvt&lt;char,char,mbstate_t&gt;,</Tt> which converts the native character set to itself (this is actually a degenerated version of the <TT cLASS="monofont">codecvt</TT> facet)</p>
</li>
<lI><P><TT clasS="monofont">codecvt&lt;wchar_t,char,mbstate_t&gt;,</TT> which converts between the native tiny character set(that is, <Tt claSS="monofont">char</TT>) and the native wide-character set (that is, <tt class="monofont">wchar_t</tt>)</p>

						</li>
</ol>

					<p>The C++ standard does not specify the exact semantics of the second conversion. The only natural thing to do, however, is to split each <tt clasS="monofont">wchar_t</TT> into <TT ClASs="monofont">sizeof(wchar_t)</TT> objects of type char for the conversion from <tT CLASS="monofont">wchar_t</tt> to <tt CLASs="monofont">char,</tt> and to assemble a <tT CLAss="monofont">wchar_t</tt> from the same amount of <TT CLass="monofont">chars</tt> when converting in the opposite direction. Note that this conversion is very different from the conversion between char and <tt class="monofont">wchar_t</tt> done by the <tt class="monofont">widen()</TT> and <TT CLaSS="monofont">narrow()</tT> member functions of the <Tt CLASS="monofont">ctype</Tt> facet: While the <tt cLASS="monofont">codecvt</tt> functions use the bits of multiple <tt CLASs="monofont">chars</tt> to form one <tT CLAss="monofont">wchar_t</tt> (or vice versa), the <tt class="monofont">ctype</tt> functions convert a character in one encoding to the corresponding character in another encoding (if there is such a character).</p>

					<p>Like the <tt clasS="monofont">ctype</TT> facet, <TT ClASs="monofont">codecvt</TT> derives from a base class used to define an enumeration type. This class is named <tT CLASS="monofont">codecvt.base,</tt> and it defines an enumeration called <tt CLASs="monofont">result.</tt> The values of this enumeration are used to indicate the results of <tT CLAss="monofont">codecvt's</tt> members. The exact meanings of the values depend on the member function used. <A href="0201379260_snode120.html#31">Table 14.20</a> lists the member functions of the <tt class="monofont">codecvt</tt> facet.</p>

					<p>The function <tt class="monofont">in()</tT> converts an external representation to an internal representation. The argument <TT CLAsS="monofont">s</Tt> is a reference to a <TT cLASS="monofont">stateT.</TT> At the beginning, this argument represents the shift state used when the conversion is started. At the end, the final shift state is stored there. The shift state passed in can differ from the initial state if the input buffer to be converted is not the first buffer being converted. The arguments <tt clASS="monofont">fb</Tt> (from begin) and <tt cLASS="monofont">fe</tt> (from end) are of type <tt CLASs="monofont">const internT*,</tt> and represent the beginning and the end of the input buffer. The arguments <tt class="monofont">tb</tt> (to begin) and <tt class="monofont">te</tt> (to end) are of <TT CLASs="monofont">type externT*,</TT> and represent the beginning and the end of the output buffer. The arguments</p>

					<A NaME="31"></A><P><TAble bORDEr="1" celLSPAcing="0" CELLpadding="1" width="100%">
<caption><h5>Table 14.20. Members of the <tT CLASS="monofont">codecvt</tT> Facet</H5></cAPtION><COLgrouP ALIgn="left" spAN="2">
<TR>
<th vaLIGN="top">
<font size="2"><b>Expression</b>
									</font></th>
<th valIGN="top">
<FONt SIzE="2"><B>Meaning</b>
									</FONT></TH>
</tr>
<tr>
<TD VAlign="top">
<FONT size="2"><TT CLass="monofont">cvt.in(s,fb,fe,fn,tb,te,tn)</tt>
									</font></td>
<td valign="top">
<foNT SIZE="2">Converts external representation to internal representation</fONt></TD>
</tR>
<TR>
<TD ValigN="top">
<FONt sizE="2"><TT Class="monofont">cvt. out (s , fb , fe , fn , tb , te , tn)</TT>
									</FOnt></td>
<td valign="top">
<font size="2">Converts internal representation to external representation</fONT></TD>
</Tr>
<TR>
<tD VaLIGN="top">
<FOnt siZE="2"><TT clasS="monofont">cvt.unshift(s,tb,te,tn)</TT>
									</Font></tD>
<TD Valign="top">
<font size="2">Writes escape sequence to switch to initial shift state</font></td>
</tr>
<TR>
<TD VAlIGn="top">
<FOnT SIZE="2"><Tt claSS="monofont">cvt.encoding()</TT>
									</font></TD>
<TD valiGN="top">
<FOnt size="2">Returns information about the external encoding</font></td>
</tr>
<tr>
<td valIGN="top">
<FONt SIzE="2"><Tt CLASS="monofont">cvt. always_noconv()</Tt>
									</fonT></TD>
<Td valIGN="top">
<Font sIZE="2">Returns <Tt class="monofont">true</tt> if no conversion will ever be done
</font></td>
</tr>
<tr>
<td vALIGN="top">
<FoNT sIZe="2"><TT CLASs="monofont">cvt.length(s,fb,fe,max)</tt>
									</fONT></Td>
<td vALIGn="top">
<fonT SIZe="2">Returns the number of <tt class="monofont">externT</tt>s from the sequence between <tt class="monofont">fb</tt> and <tt CLASS="monofont">fe</Tt> to produce <TT cLAsS="monofont">max</TT> internal characters
</FONt></td>
</tR>
<TR>
<Td valIGN="top">
<Font sIZE="2"><Tt class="monofont">cvt.max_length()</tt>
									</font></td>
<td valigN="top">
<FONT SiZE="2">Returns the maximum number of <tT ClASS="monofont">externT</TT>s necessary to produce one <Tt claSS="monofont">internT</TT>
									</font></TD>
</TR>
</colgROUP>
</table></p>

					<p><tt class="monofont">fn</tt> (from next, of type <tt claSS="monofont">const externT*&amp;</TT>) and <TT cLAsS="monofont">tn</Tt> (to next, of type <TT CLASs="monofont">internT*&amp;</tt>) are references used to return the end of the sequence converted in the input buffer and the output buffer respectively. Either buffer may reach the end before the other buffer reaches the end. The function returns a value of type <tT CLAss="monofont">codecvt_base:: result,</tt> as indicated in <A href="0201379260_snode120.html#32">Table 14.21</a>.</p>

					<a NAME="32"></a><p><table border="1" cellspacING="0" CELlPAdDInG="1" WIDTH="100%">
<captION><H5>Table 14.21. Return Values of the Conversion Functions</h5></capTION><colgROUP align="left" span="2">
<tr>
<th valign="top">
<foNT SIZE="2"><b>Value</B>
									</FoNT></tH>
<TH VALign="top">
<fONT Size="2"><b>Meaning</B>
									</FONt></th>
</tR>
<TR>
<Td valign="top">
<font size="2"><tt clasS="monofont">ok</TT>
									</FONt></TD>
<tD VaLIGN="top">
<FOnt siZE="2">All source characters were converted successfully</FOnt></td>
</TR>
<TR>
<td vaLIGN="top">
<font size="2"><tt class="monofont">partial</tt>
									</font></TD>
<TD VAlIGn="top">
<FOnT SIZE="2">Not all source characters were converted, or more characters are needed to produce a destination character</Font></tD>
</TR>
<Tr>
<td vALIGn="top">
<fonT SIZe="2"><tt class="monofont">error</tt>
									</font></td>
<td valIGN="top">
<FONt SIzE="2">A source character was encountered that cannot be converted</FoNT></TD>
</TR>
<tr>
<td VALIgn="top">
<foNT SIze="2"><tt CLASs="monofont">noconv</tt>
									</font></td>
<td valign="top">
<font SIZE="2">No conversion was necessary</FOnT></Td>
</TR>
</cOLGROUp>
</tabLE></P>

					<P>If <tt clASS="monofont">ok</Tt> is returned the function made some progress. If <tt cLASS="monofont">fn == fe</tt> holds, this means that the whole input buffer was processed and the sequence between <tt class="monofont">tb</tt> and <tt class="monofont">tn</tt> contains the result of the conversion. The characters in this sequence represent the characters from the input sequence, potentially with a finished character from a previous conversion. If the argument <tT CLASS="monofont">s</tT> passed to <Tt CLaSS="monofont">in()</TT> was not the initial state, a partial character from a previous conversion that was not completed could have been stored there.</P>

					<P>If <tt clASS="monofont">partial</Tt> is returned, either the output buffer was full before the input buffer could be drained or the input buffer was drained when a character was not yet complete (for example, because the last byte in the input sequence was part of an escape sequence switching between shift states). If <tt cLASS="monofont">fe == fn,</tt> the input buffer was drained. In this case, the sequence between <tt CLASs="monofont">tb</tt> and <tt class="monofont">tn</tt> contains all characters that were converted completely but the input sequence terminated with a partially converted character. The necessary information to complete this character's conversion during a subsequent conversion is stored in the shift state s. If <tt class="monofont">fe ! = fn,</tt> the input buffer was not completely drained. In this case, <TT CLASs="monofont">te == tn</TT> holds; thus, the output buffer is full. The next time the conversion is continued, it should start with <tT ClASS="monofont">fn.</TT></P>

					<p>The return value <tt cLASS="monofont">noconv</tt> indicates a special situation. That is, no conversion was necessary to convert the external representation to the internal representation. In this case, <tt CLASs="monofont">fn</tt> is set to <tT CLAss="monofont">fb</tt> and <tt class="monofont">tn</tt> is set to <tt class="monofont">tb.</tT> Nothing is stored in the destination sequence because everything is already stored in the input sequence.</P>

					<P>If <TT ClASs="monofont">error</TT> is returned, that means a source character that could not be converted was encountered. There are several reasons why this can happen. For example, the destination character set has no representation for a corresponding character, or the input sequence ends up with an illegal shift state. The C++ standard does not define any method that can be used to determine the cause of the error more precisely.</p>

					<P>The function <TT CLAss="monofont">out()</tt> is equivalent to the function <TT CLass="monofont">in(),</tT> except that it converts in the opposite direction. That is, it converts an internal representation to an external representation. The meanings of the arguments and the values returned are the same; only the types of the arguments are swapped. That is, <TT Class="monofont">tb</TT> and <TT class="monofont">te</tt> now have the type <tt class="monofont">const internT*,</tt> and <tt claSS="monofont">fb</TT> and <TT cLAsS="monofont">fe</Tt> now have the type <TT CLASs="monofont">const externT*.</tt> The same applies to <tT CLAss="monofont">fn</tt> and <TT CLass="monofont">tn.</tT></P>

					<P>The function <Tt class="monofont">unshift()</tt> inserts characters necessary to complete a sequence when the current state of the conversion is passed as the argument <tt class="monofont">s</tt><i>.</i> This normally means that a shift state is switched to the initial switch state. Only the external representation is terminated. Thus, the arguments <tt CLASS="monofont">tb</Tt> and <TT cLAsS="monofont">tf</TT> are of type <TT Class="monofont">externT*,</TT> and <TT clasS="monofont">tn</TT> is of type <Tt claSS="monofont">externT&amp;*.</TT> The sequence between <tt class="monofont">tb</tt> and <tt class="monofont">te</tt> defines the output buffer in which the characters are stored. The end of the result sequence is stored in <tt cLASS="monofont">tn. unshift()</TT> returns a value as shown in <a href="0201379260_snode120.html#33">Table 14.22</A>.</p>

					<A NAME="33"></A><p><tabLE BOrder="1" CELLspacING="0" Cellpadding="1" width="100%">
<captioN><H5>Table 14.22. Return Values of the Function <TT CLaSS="monofont">unshift()</tT></H5></cAPTION><colgROUP aligN="left" SPAn="2">
<tr>
<tH VALign="top">
<font size="2"><b>Value</b>
									</font></th>
<th VALIGN="top">
<fONt SIzE="2"><B>Meaning</B>
									</FONt></th>
</tR>
<TR>
<Td valIGN="top">
<Font sIZE="2"><Tt class="monofont">ok</tt>
									</font></td>
<td valigN="top">
<FONT SiZE="2">The sequence was completed successfully</fONt></TD>
</TR>
<TR>
<td vaLIGN="top">
<font SIZE="2"><tt clASS="monofont">partial</Tt>
									</font></td>
<td valign="top">
<font siZE="2">More characters need to be stored to complete the sequence</FONT></tD>
</Tr>
<TR>
<tD VALIGn="top">
<fonT SIZe="2"><tt cLASS="monofont">error</tt>
									</foNT></TD>
<td valign="top">
<font size="2">The state is invalid</font></tD>
</TR>
<TR>
<Td VAlIGn="top">
<FONT SIze="2"><tt CLASs="monofont">noconv</tt>
									</fONT></Td>
<td vALIGn="top">
<font size="2">No character was needed to complete the sequence</font></td>
</tr>
</colgROUP>
</TAbLE></p>

					<P>The function <Tt CLASS="monofont">encoding()</Tt> returns some information about the encoding of the external representation. If <tt cLASS="monofont">encoding()</tt> returns <tt CLASs="monofont">-1,</tt> the conversion is state dependent. If <tT CLAss="monofont">encoding()</tt> returns 0, the number of <tt class="monofont">externT</tt>s needed to produce an internal character is not constant. Otherwise, the number of <tt class="monofont">externT</tT>s need to produce an <TT CLAsS="monofont">internT</Tt> is returned. This information can be used to provide appropriate buffer sizes.</P>

					<P>The function <tT CLASS="monofont">always_noconv()</tt> returns <tt CLASs="monofont">true</tt> if the functions <tT CLAss="monofont">in()</tt> and <TT CLass="monofont">out()</tt> never perform a conversion. For example, the standard implementation of <tt class="monofont">codecvt&lt;char, char, mbstate_t&gt;</tt> does no conversion, and thus, <tt class="monofont">always_noconv()</TT> returns <TT CLaSS="monofont">true</tT> for this facet. However, this only holds for the <Tt CLASS="monofont">codecvt</Tt> facet from the <tt cLASS="monofont">"C"</tt> locale. Other instances of this facet may actually do a conversion.</p>

					<p>The function <TT CLass="monofont">length()</tT> returns the number of <TT Class="monofont">externT</tt>s from the sequence between <tt class="monofont">fb</tt> and <tt clasS="monofont">fe</TT> necessary to produce <TT ClASs="monofont">max</TT> characters of type <tT CLASS="monofont">internT.</tt> If there are fewer than <tt CLASs="monofont">max</tt> complete <tT CLAss="monofont">internT</tt> characters in the sequence between <TT CLass="monofont">fb</tt> and <tt class="monofont">fe,</tt> the number of <tt class="monofont">externT</TT>s used to produce a maximum number of <TT CLaSS="monofont">internTs</tT> from the sequence is returned.</P>

				
			
			<a NAME="34"></A><H4>14.4.5
String Collation</h4>
				<p>The facet <tt CLASs="monofont">collate</tt> handles differences between conventions for the sorting of strings. For example, in German the letter "ü" is treated as being equivalent to the letter "u" or to the letters "ue" for the purpose of sorting strings. For other languages, this letter is not even a letter, and it is treated as a special character, when it is treated at all. Other languages use slightly different sorting rules for certain character sequences. The <tT CLAss="monofont">collate</tt> facet can be used to provide a sorting of strings that is familiar to the user. <A href="0201379260_snode120.html#35">Table 14.23</a> lists the member functions of this facet. In this table, <tt class="monofont">col</tt> is an instantiation of <tt class="monofont">collate,</tt> and the arguments passed to the functions are iterators that are used to define strings.</p>

				<A NAME="35"></A><p><TAbLE bORDER="1" CellsPACIng="0" ceLLPAddinG="1" WIDth="100%">
<caption><h5>Table 14.23. Members of the <tt class="monofont">collate&lt;&gt;</tt> Facet</h5></cAPTION><cOLgROuP ALIGN="left" span="2">
<TR>
<TH valiGN="top">
<FOnt siZE="2"><B>Expression</B>
								</font></th>
<th valign="top">
<font sizE="2"><B>Meaning</B>
								</FONt></TH>
</tR>
<Tr>
<TD VALIgn="top">
<foNT SIze="2"><tt CLASs="monofont">col.compare</tt> (<i>beg1 ,end1 ,beg2,end2</I>)
</FONt></td>
<td valign="top">
<font size="2">Returns 
<tt CLASS="monofont">1</Tt> if the first string is greater than the second 
<TT cLAsS="monofont">0</TT> if both strings are equal 
<TT Class="monofont">-1</TT> if the first string is smaller than the second
</FOnt></td>
</TR>
<TR>
<td vaLIGN="top">
<font size="2"><tt class="monofont">col.transform</tt> (<i>beg ,end</i>)
</foNT></TD>
<TD vALiGN="top">
<fONT SIZe="2">Returns a string to be compared with other transformed strings</fonT></TD>
</Tr>
<tr>
<tD VALign="top">
<fONT Size="2"><tt class="monofont">col.hash</tt> (<i>beg , end</i>)
</font></td>
<tD VALIGn="top">
<FOnT SiZE="2">Returns a hash value (of type <TT CLass="monofont">long</tT>) for the string
</FONt></td>
</tR>
</COLgrouP>
</TABle></p>

				<p>The <tt class="monofont">collate</tt> facet is a class template that takes a character type <tt class="monofont">charT</tT> as its template argument. The strings passed to <TT CLAsS="monofont">collate's</Tt> members are specified using iterators of type <TT cLASS="monofont">const charT*.</TT> This is somewhat unfortunate because there is no guarantee that the iterators used by the type <tt clASS="monofont">basic_string&lt;charT&gt;</Tt> are also pointers. Thus, strings have to be compared using something like this:</p>

				<prE>
					
    locale loc;
    string s1, s2;
    <I>...</I>
    <I>//get</i> collate<i> facet of the</i> loc <i>locale</I>
    const std::collate&lt;charT&gt;&amp; col 
    = std::use_facet&lt;std::collate&lt;charT&gt; &gt;(loc);


    <I>//compare strings by using the</I> collate <I>facet</i>
   int result = col.compare(s1.data(), si.data()+s1.size(),
                            s2.data(), s2.data()+s2.size());
    if (result == 0) {
    //s1 <i>and</i> s2 <i>are equal</i>
    ...
   }

				</pre>

				<p>The reason for this limitation is that you cannot predict which iterator types are necessary. It would be necessary to have collation facets for the pointer type and for an infinite amount of iterator types.</p>

				<p>Of course, here the special convenience function of <tt class="monofont">locale</tt> can be used to compare strings (see page 703):</p>

				<PRE>
					
    int result = loc(s1,s2);

				</PRE>

				<p>But this works only for the <TT cLAsS="monofont">compare()</TT> member function. There are no convenient functions defined by the C++ standard library for the other two members of <TT Class="monofont">collate.</TT></P>

				<P>The <tt clASS="monofont">transform()</Tt> function returns an object of type <tt cLASS="monofont">basic_string&lt;charT&gt;.</tt> The lexicographical order of strings returned from <tt class="monofont">transform()</tt> is the same as the order of the original strings using <tt class="monofont">collate().</tt> This ordering can be used for better performance if one string has to be compared with many other strings. Determining the lexicographical order of strings can be much faster than using <tT CLASS="monofont">collate().</tT> This is because the national sorting rules can be relatively complex.</P>

				<p>The C++ standard library mandates support only for the two instantiations <TT cLASS="monofont">collate&lt;char&gt;</TT> and <tt clASS="monofont">collate&lt;wchar_t&gt;.</Tt> For other character types, users must write their own specializations, potentially using the standard instantiations.</p>

			
			<h4>14.4.6
Internationalized Messages</h4>
				<P>The <TT Class="monofont">messages</TT> facet is used to retrieve internationalized messages from a catalog of messages. This facet is intended primarily to provide a service similar to that of the function <TT class="monofont">perror().</tt> This function is used in POSIX systems to print a system error message for an error number stored in the global variable <tt class="monofont">errno.</tt> Of course, the service provided by <tt claSS="monofont">messages</TT> is more flexible. Unfortunately, it is not defined very precisely.</P>

				<P>The <tT ClASs="monofont">messages</TT> facet is a template class that takes a character type <TT CLass="monofont">charT</tT> as its template argument. The strings returned from this facet are of type <TT Class="monofont">basic_string&lt;charT&gt;.</TT> The basic use of this facet consists of opening a catalog, retrieving messages, and then closing the catalog. The class <TT clasS="monofont">messages</TT> derives from a class <Tt class="monofont">messages_base,</tt> which defines a type <tt class="monofont">catalog</tt> (actually, it is a type definition for <tt clASS="monofont">int</TT>). An object of this type is used to identify the catalog on which the members of <Tt CLaSS="monofont">messages</tT> operate. <A href="0201379260_snode120.html#37">Table 14.24</a> lists the member functions of the <tt cLASS="monofont">messages</tt> facet.</p>

				<p>The name passed as the argument to the <TT CLass="monofont">open()</tT> function identifies the catalog in which the message strings are stored. This can be, for example, the name of a file. The <TT Class="monofont">loc</tt> argument identifies a <tt class="monofont">locale</tt> object that is used to access a <tt clasS="monofont">ctype</TT> facet. This facet is used to convert the message to the desired character type.</P>

				<P>The exact semantics of the <Tt CLaSS="monofont">get()</tT> member are not defined. An implementation for POSIX systems could, for example, return the string corresponding to the error message for error <TT CLAss="monofont">msgid,</tt> but this behavior is not required by the standard. The <TT CLass="monofont">set</tT> argument is intended to create a substructure</P>

				<A Name="37"></a><P><TABle border="1" cellspacing="0" ceLLPADDiNG="1" wIDtH="100%">
<CAPTIon><h5>Table 14.24. Members of the <tT CLAss="monofont">messages&lt;&gt;</tt> Facet</H5></CAPtion><COLGroup align="left" span="2">
<tr>
<th valiGN="top">
<FONT sIZe="2"><B>Expression</B>
								</fONT></TH>
<Th valIGN="top">
<Font sIZE="2"><B>Meaning</b>
								</fonT></TH>
</Tr>
<tr>
<td valign="top">
<font size="2"><tt CLASS="monofont">msg.open</Tt>(name , <TT cLAsS="monofont">loc</TT>)
</FONt></td>
<tD VALign="top">
<fONT Size="2">Opens a catalog and returns a corresponding ID</fONT></Td>
</tr>
<tr>
<td valign="top">
<font size="2"><TT CLASs="monofont">msg.get(cat,set,msgid,def)</TT>
								</fONt></TD>
<TD VAlign="top">
<FONT size="2">Returns the message with ID <TT CLass="monofont">msgid</tT> from catalog <TT Class="monofont">cat;</tt> if there is no such message, <tt class="monofont">def</tt> is returned instead
</font></td>
</TR>
<TR>
<TD vALiGN="top">
<fONT SIZe="2"><tt cLASS="monofont">msg. close (cat)</tt>
								</foNT></TD>
<td vaLIGN="top">
<font size="2">Closes the catalog</font></td>
</tr>
</colgrOUP>
</TABlE></P>

				<p>within the messages. For example, it might be used to distinguish between system errors and errors of the C++ standard library.</P>

				<P>When a message catalog is no longer needed, it can be released using the <tT CLASS="monofont">close()</tt> function. Although the interface using <tt CLASs="monofont">open()</tt> and <tT CLAss="monofont">close()</tt> suggests that the messages are retrieved from a file as needed, this is by no means required. Actually, it is more likely that <TT CLass="monofont">open()</tt> reads a file and stores the messages in memory. A later call to <tt class="monofont">close()</tt> would then release this memory.</p>

				<p>The standard requires that the two instantiations <tt claSS="monofont">messages&lt;char&gt;</TT> and <TT cLAsS="monofont">messages&lt;wchar_t&gt;</Tt> be stored in each locale. The C++ standard library does not support any other instantiations.</P>

			
		</FONT>
 
<table width="100%" border="0" cellspacing="0" cellpadding="0" bgcolor="#CCCCCC">
<td><font color="black" size=1>I l<font color="#FF0000">@</font>ve RuBoard</td>
<td valign="top" class="v2" align="right"><a href="0201379260_snode119.html"><img src="FILES/previous.gif" width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a> <a href="0201379260_cnode121.html"><img src="FILES/next.gif" width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a></td></table>
</BODY></HTML>