<HTML><HEAD><META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=iso-8859-1">
<!--SafClassName="docSection1Title"--><!--SafTocEntry="4.2 Class 'auto_ptr'"-->
<LINK REL="stylesheet" href="FILES/sbolM.css">
</HEAD>
<BODY link="#354278" vlink="#000066" alink="#000080" topmargin="0">
<table width="100%" border="0" cellspacing="0" cellpadding="0" bgcolor="#CCCCCC">
<td><font color="black" size=1>I l<font color="#FF0000">@</font>ve RuBoard</td>
<td valign="top" class="v2" align="right"><a href="0201379260_snode26.html"><img src="FILES/previous.gif" width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a> <a href="0201379260_snode28.html"><img src="FILES/next.gif" width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a></td></table>
<FONT><h3>4.2
Class <tt cLASS="monofont">auto_ptr</tt></h3>
			<p>This section covers the <TT CLass="monofont">auto_ptr</tT> type. The <TT Class="monofont">auto_ptr</tt> type is provided by the C++ standard library as a kind of a smart pointer that helps to avoid resource leaks when exceptions are thrown. Note that I wrote "a kind of a smart pointer." There are several useful smart pointer types. This class is smart with respect to only one certain kind of problem. For other kinds of problems, type <tt class="monofont">auto_ptr</tt> does not help. So, be careful and read the following subsections.</p>

			<h4>4.2.1
Motivation of Class <tt clASS="monofont">auto_ptr</TT></H4>
				<p>Functions often operate in the following way<FOnT SiZE="1"><SUP><A href="#FOOTNOTE-4">[4]</A></SUP></font>
:</P>
<BLOckquOTE><Font size="1">
<p class="footnote">
<sup><a name="FOOTNOTE-4">[4]</A></SUP>
This motivation of class <TT cLAsS="monofont">auto_ptr</Tt> is based, with permission, partly on Scott Meyers' book <I>More Effective C++.</I> The general technique was originally presented by Bjarne Stroustrup as the "resource allocation is initialization" in his books <I>The C++ Programming Language,</I> 2nd edition and <I>The Design and Evolution of C++.</I>
							<tt clASS="monofont">auto_ptr</Tt> was added to the standard specifically to support this technique.</p>
</foNT></BLockqUOTE>

				<ol type="1" start="restarts">
<li><p>Acquire some resources.</p>
</li>
<li><p>Perform some operations.</p>
</LI>
<LI><P>Free the acquired resources.</P>

					</lI>
</Ol>

				<P>If the resources acquired on entry are bound to local objects, they get freed automatically on function exit because the destructors of those local objects are called. But if resources are acquired explicitly and are not bound to any object, they must be freed explicitly. Resources are typically managed explicitly when pointers are used.</P>

				<p>A typical examples of using pointers in this way is the use of <TT CLASs="monofont">new</tt> and <tT CLAss="monofont">delete</tt> to create and destroy an object:</P>

				<PRE>
					
    void f()
    {
        ClassA* ptr = new ClassA;     <i>//create an object explicitly</i>
        ...                            <i>//perform some operations</i>
        delete ptr;                    <I>//clean up (destroy the object explicitly)</I>
    }

				</PRe>

				<p>This function is a source of trouble. One obvious problem is that the deletion of the object might be forgotten (especially if you have <tt class="monofont">return</tt> statements inside the function). There also is a not-so-obvious danger that an exception might occur. Such an exception would exit the function immediately without calling the <tt class="monofont">delete</tt> statement at the end of the function. The result would be a memory leak or, more generally, a resource leak. Avoiding such a resource leak usually requires that a function catches all exceptions. For example:</p>

				<PRE>
					
   void f()
   {
       ClassA* ptr = new ClassA;     <I>//create an object explicitly</I>


       try {
          ...                        <I>//perform some operations</i>
       }
       catch (...) {                  <I>//for any exception</I>
           delete ptr;                <i>//-clean up</I>
           throw;                     <I>//-rethrow the exception</i>
       }


       delete ptr;                    <I>//clean up on normal end</I>
   }

				</PRE>

				<P>To handle the deletion of this object properly in the event of an exception, the code gets more complicated and redundant. If a second object is handled in this way, or if more than one <tt clASS="monofont">catch</Tt> clause is used, the problem gets worse. This is bad programming style and should be avoided because it is complex and error prone.</p>

				<p>A kind of smart pointer can help here. The smart pointer can free the data to which it points whenever the pointer itself gets destroyed. Furthermore, because the pointer is a local variable, it gets destroyed automatically when the function is exited regardless of whether the exit is normal or is due to an exception. The class <tT CLAss="monofont">auto_ptr</tt> was designed to be such a kind of smart pointer.</P>

				<P>An <TT class="monofont">auto_ptr</tt> is a pointer that serves as <i>owner</i> of the object to which it refers (if any). As a result, an object gets destroyed automatically when its <tt class="monofont">auto_ptr</tt> gets destroyed. A requirement of an <tt cLASS="monofont">auto_ptr</TT> is that its object has only one owner.</p>

				<P>Here is the previous example rewritten to use an <Tt CLaSS="monofont">auto_ptr:</TT></P>

				<Pre>
					
    <i>//header file for</i> auto_ptr
    #include &lt;memory&gt;


    void f()
    {
        <I>//create and initialize an</I> auto_ptr
        std::auto_ptr&lt;ClassA&gt; ptr(new ClassA);


        ...                           <I>//perform some operations</I>
    }

				</pre>

				<p>The <TT CLass="monofont">delete</tT> statement and the <TT Class="monofont">catch</tt> clause are no longer necessary. An <tt class="monofont">auto_ptr</tt> has much the same interface as an ordinary pointer; that is, operator <tt clasS="monofont">*</TT> dereferences the object to which it points, whereas operator <TT ClASs="monofont">-&gt;</TT> provides access to a member if the object is a class or a structure. However, any pointer arithmetic (such as <tT CLASS="monofont">++</tt>) is not defined (this might be an advantage, because pointer arithmetic is a source of trouble).</p>

				<p>Note that class <TT CLass="monofont">auto_ptr&lt;&gt;</tT> does not allow you to initialize an object with an ordinary pointer by using the assignment syntax. Thus, you must initialize the <TT Class="monofont">auto_ptr</TT> directly by using its value<FOnt size="1"><sup><a href="#FOOTNOTE-5">[5]</a></sup></fonT>
:</P>
<BLOCkQUoTE><fONT SIZe="1">
<p clASS="footnote">
<Sup><a nAME="FOOTNOTE-5">[5]</A></sup>
There is a minor difference between</p>
</FONT></blockquote>

						<pre>
							
    X x;
    Y y(x);   <i>//explicit conversion</i>
</pre>

						<bloCKQUOTe><FOnT SiZE="1">
<P CLAss="footnote">
and</p>
</fONT></BlockQUOTe>

						<pre>
							
    X x;
    Y y = x;   <I>//implicit conversion</I>

						</PRe>

						<blockquote><font size="1">
<p cLASS="footnote">
The former creates a new object of type <TT cLAsS="monofont">Y</Tt> by using an explicit conversion from type <TT CLASs="monofont">X,</tt> whereas the latter creates a new object of type <tT CLAss="monofont">Y</tt> by using an implicit conversion.</P>
</FONt></bloCKQUote>

				<pre>
					
   std::auto_ptr&lt;ClassA&gt; ptr1(new ClassA);     <i>//OK</i>
   std::auto_ptr&lt;ClassA&gt; ptr2 = new ClassA;    <i>//ERROR</i>

				</pre>

			
			<a name="4"></a><h4>4.2.2
Transfer of Ownership by <tT CLASS="monofont">auto_ptr</tT></H4>
				<p>An <TT cLASS="monofont">auto_ptr</TT> provides the semantics of strict ownership. This means that because an <tt clASS="monofont">auto_ptr</Tt> deletes the object to which it points, the object should not be "owned" by any other objects. Two or more <tt cLASS="monofont">auto_ptr</tt>s must not own the same object at the same time. Unfortunately, it might happen that two <tt CLASs="monofont">auto_ptr</tt>s own the same object (for example, if you initialize two <tt class="monofont">auto_ptr</tt>s with the same object). Making sure this doesn't happen is up to the programmer.</p>

				<p>This leads to the question of how the copy constructor and the assignment operator of <tt class="monofont">auto_ptr</TT>s operate. The usual behavior of these operations would be to copy the data of one <TT CLaSS="monofont">auto_ptr</tT> to the other. However, this behavior would result in the situation, in which two <Tt CLASS="monofont">auto_ptr</Tt>s own the same object. The solution is simple, but it has important consequences: The copy constructor and assignment operator of <tt cLASS="monofont">auto_ptr</tt>s "transfer ownership" of the objects to which they refer.</p>

				<p>Consider, for example, the following use of the copy constructor:</P>

				<PRE>
					
    <i>//initialize an</i> auto_ptr <i>with a new object</i>
    std::auto_ptr&lt;ClassA&gt; ptr1(new ClassA);


    <I>//copy the</I> auto_ptr
    <I>//- transfers ownership from</I> ptr1 <i>to</i> ptr2
    std::auto_ptr&lt;ClassA&gt; ptr2(ptr1);

				</pre>

				<p>After the first statement, <tt class="monofont">ptr1</tt> owns the object that was created with the <tt clasS="monofont">new</TT> operator. The second statement transfers ownership from <TT ClASs="monofont">ptr1</TT> to <tT CLASS="monofont">ptr2.</tt> So after the second statement, <tt CLASs="monofont">ptr2</tt> owns the object created with <tT CLAss="monofont">new,</tt> and <TT CLass="monofont">ptr1</tt> no longer owns the object. The object created by <tt class="monofont">new ClassA</tt> gets deleted exactly once — when <tt class="monofont">ptr2</TT> gets destroyed.</P>

				<P>The assignment operator behaves similarly:</P>

				<PrE>
					
    <I>//initialize an</i> auto_ptr <I>with a new object</I>
    std::auto_ptr&lt;ClassA&gt; ptr1(new ClassA);
    std::auto_ptr&lt;ClassA&gt; ptr2;  <i>//create another</I> auto_ptr


    ptr2 = ptr1;                 <I>//assign the</I> auto_ptr
                                 <I>//- transfers ownership from</I> ptr1 <I>to</i> ptr2

				</pre>

				<P>Here, the assignment transfers ownership from <TT Class="monofont">ptr1</TT> to <TT clasS="monofont">ptr2.</TT> As a result, <Tt class="monofont">ptr2</tt> owns the object that was previously owned by <tt class="monofont">ptr1.</tt></p>

				<p>If <tt CLASS="monofont">ptr2</Tt> owned an object before an assignment, <TT cLAsS="monofont">delete</TT> is called for that object:</P>

				<PRe>
					
    <i>//initialize an</i> auto_ptr <i>with a new object</I>
    std::auto_ptr&lt;ClassA&gt; ptr1(new ClassA);
    <I>//initialize another</I> auto_ptr <I>with a new object</i>
    std::auto_ptr&lt;ClassA&gt; ptr2(new ClassA);


    ptr2 = ptr1;                  <i>//assign the</i> auto_ptr
                                  <i>//- delete object owned by</I> ptr2
                                  <I>//- transfers ownership from</I> ptr1 <I>to</i> ptr2

				</pre>

				<P>Note that a transfer of ownership means that the value is <I>not</I> simply copied. In all cases of ownership transfer, the previous owner (<Tt class="monofont">ptr1</tt> in the previous examples) loses its ownership. As a consequence the previous owner has the null pointer as its value after the transfer. This is a significant violation of the general behavior of initializations and assignments in programming languages. Here, the copy constructor <i>modifies</i> the object that is used to initialize the new object, and the assignment operator <i>modifies</i> the right-hand side of the assignment. It is up to the programmer to ensure that an <tt class="monofont">auto_ptr</tt> that lost ownership and got the null pointer as value is no longer dereferenced.</P>

				<P>To assign a new value to an <TT CLaSS="monofont">auto_ptr,</tT> this new value must be an <Tt CLASS="monofont">auto_ptr.</Tt> You can't assign an ordinary pointer:</p>

				<prE>
					
    std::auto_ptr&lt;ClassA&gt; ptr;                         <I>//create an</I> auto_ptr


    ptr = new ClassA;                                  <I>//ERROR</i> 
    ptr = std::auto_ptr&lt;ClassA&gt;(new ClassA);           <i>//OK, delete old object</i>
                                                       <i>//    and own new</I>

				</PRE>

				<h5>Source and Sink</h5>
					<p>The transfer of ownership implies a special use for <tT CLAss="monofont">auto_ptr</tt>s; that is, functions can use them to transfer ownership to other functions. This can occur in two different ways:</p>

					<ol type="1" start="restarts">
<li><p>A function can behave as a <i>sink</i> of data. This happens if an <TT CLASs="monofont">auto_ptr</TT> is passed as an argument to the function by value. In this case, the parameter of the called function gets ownership of the <tT ClASS="monofont">auto_ptr.</TT> Thus, if the function does not transfer it again, the object gets deleted on function exit:</P>

							<pre>
								
   void sink(std::auto_ptr&lt;ClassA&gt;);       <i>//</I>sink() <I>gets ownership</I>
							</Pre>

						</li>
<LI><P>A function can behave as a <I>source</i> of data. When an <tt cLASS="monofont">auto_ptr</tt> is returned, ownership of the returned value gets transferred to the calling function. The following example shows this technique:</p>

							<pre>
								
   std::auto_ptr&lt;ClassA&gt; f()
   {
       std:: auto_ptr&lt;ClassA&gt; ptr(new ClassA); <i>//</i>ptr <i>owns the new object</i>
       ...
       return ptr;         <i>//transfer ownership to calling function</i>
   }


   void g()
   {
       std::auto_ptr&lt;ClassA&gt; p;


       for (int i=0; i&lt;10; ++i) {
           p = f();        <i>//p gets ownership of the returned object</i>
                           <i>//(previously returned object of</i> f() <i>gets deleted)</i>
           ...
       }
   }                       <i>//last-owned object of</i> p<i> gets deleted</I>

							</PRE>

							<P>Each time <Tt CLaSS="monofont">f()</tT> is called, it creates an object with <TT CLAss="monofont">new</tt> and returns the object, along with its ownership, to the caller. The assignment of the return value to <TT CLass="monofont">p</tT> transfers ownership to <TT Class="monofont">p.</TT> In the second and additional passes through the loop, the assignment to <TT class="monofont">p</tt> deletes the object that <tt class="monofont">p</tt> owned previously. Leaving <tt claSS="monofont">g(),</TT> and thus destroying <TT cLAsS="monofont">p,</Tt> results in the destruction of the last object owned by <TT CLASs="monofont">p.</tt> In any case, no resource leak is possible. Even if an exception is thrown, any <tT CLAss="monofont">auto_ptr</tt> that owns data ensures that this data is deleted.</P>

						</LI>
</Ol>

				
				<h5>Caveat</h5>
					<p>The semantics of <TT CLass="monofont">auto_ptr</tt> always include ownership, so don't use <tt class="monofont">auto_ptr</tt>s in a parameter list or as a return value if you don't mean to transfer ownership. Consider, for example, the following naive implementation of a function that prints the object to which an <tt class="monofont">auto_ptr</TT> refers. Using it would be a disaster.</P>

					<PRE>
						
   <i>//this is a</I> <B><i>bad example</I></B>
   template &lt;class T&gt;
   void bad_print(std::auto_ptr&lt;T&gt; p)    <i>//</I>p <I>gets ownership of passed argument</I>
   {
      <I>//does</I> p <I>own an object ?</i>
      if (p.get() == NULL) {
             std::cout &lt;&lt; "NULL";
      }
      else {
          std::cout &lt;&lt; *p;
      }
   }            <i>//Oops, exiting deletes the object to which</i> p <i>refers</I>

					</PRE>

					<p>Whenever an <tt cLASS="monofont">auto_ptr</tt> is passed to this implementation of <tt CLASs="monofont">bad_print(),</tt> the objects it owns (if any) are deleted. This is because the ownership of the <tt class="monofont">auto_ptr</tt> that is passed as an argument is passed to the parameter <tt class="monofont">p,</tt> and <TT CLASs="monofont">p</TT> deletes the object it owns on function exit. This is probably not the programmer's intention and would result in fatal runtime errors:</p>

					<PRe>
						
   std::auto_ptr&lt;int&gt; p(new int);
   *p = 42;         <I>//change value to which</I> p <I>refers</I>
   bad_print (p);   <I>//Oops, deletes the memory to which</I> p <i>refers</i>
   *p = 18;         <i>//RUNTIME ERROR</i>

					</PRE>

					<P>You might think about passing <tt clASS="monofont">auto_ptr</Tt>s by reference instead. However, passing <tt cLASS="monofont">auto_ptr</tt>s by reference confuses the concept of ownership. A function that gets an <tt class="monofont">auto_ptr</tt> by reference might or might not transfer ownership. Allowing an <tt class="monofont">auto_ptr</tt> to pass by reference is very bad design and you should always avoid it.</p>

					<P>According to the concept of <TT CLAsS="monofont">auto_ptr</Tt>s, it is possible to transfer ownership into a function by using a constant reference. This is very dangerous because people usually expect that an object won't get modified when you pass it as a constant reference. Fortunately, there was a late design decision that made <TT cLASS="monofont">auto_ptr</TT>s less dangerous. By some tricky implementation techniques, transfer of ownership is not possible with constant references. In fact, you can't change the ownership of any constant <tt clASS="monofont">auto_ptr:</Tt></p>

					<prE>
						
   const std::auto_ptr&lt;int&gt; p(new int);
   *p = 42;         <I>//change value to which</I> p <I>refers</i>
   bad_print(p);    <i>//COMPILE-TIME ERROR</i>
   *p = 18;         <i>//OK</I>

					</PRE>

					<p>This solution makes <tt class="monofont">auto_ptr</tt>s safer than they were before. Many interfaces use constant references to get values that they copy internally. In fact, all container classes (see <a href="0201379260_cnode46.html">Chapter 6</a> or <a href="0201379260_cnode82.html">Chapter 10</A> for examples) of the C++ standard library behave this way, which might look like the following:</P>

					<PRE>
						
   template &lt;class T&gt;
   void container::insert (const T&amp; value)
   {
         ...
         X = value;   <I>//assign or copy value internally</i>
         ...
   }

					</PRe>

					<P>If such an assignment was possible for <Tt CLASS="monofont">auto_ptr</Tt>s, the assignment would transfer ownership into the container. However, because of the actual design of <tt cLASS="monofont">auto_ptr</tt>s, this call results in an error at compile time:</p>

					<pRE>
						
   <I>container</I>&lt;std::auto_ptr&lt;int&gt; &gt; c;
   const std::auto_ptr&lt;int&gt; p(new int);
   ...
   c.insert(p);     <i>//ERROR</i>
   ...

					</prE>

					<P>All in all, constant <TT class="monofont">auto_ptr</tt>s reduce the danger of an unintended transfer of ownership. Whenever an object is passed via an <tt class="monofont">auto_ptr,</tt> you can use a constant <tt claSS="monofont">auto_ptr</TT> to signal the end of the chain.</P>

					<P>The <tT ClASs="monofont">const</TT> does not mean that you can't change the value of the object the <TT CLass="monofont">auto_ptr</tT> owns (if any). You can't change the <I>ownership</I> of a constant <Tt claSS="monofont">auto_ptr;</TT> however, you can change the <i>value</i> of the object to which it refers. For example:</p>

					<pRE>
						
    std::auto_ptr&lt;int&gt; f()
    {
       const std::auto_ptr&lt;int&gt; p(new int);   <I>//no ownership transfer possible</I>
       std::auto_ptr&lt;int&gt; q(new int);         <i>//ownership transfer possible</i>


       *p = 42;          <i>//OK, change value to which</i> p <i>refers</i>
       bad.print(p);     <i>//COMPILE-TIME ERROR</i>
       *p = *q;          <i>//OK, change value to which</i> p <i>refers</i>
       p = q;            <i>//COMPILE-TIME ERROR</i>
       return p;         <i>//COMPILE-TIME ERROR</i>
    }

					</pre>

					<p>Whenever the <tT CLASS="monofont">const auto_ptr</tT> is passed or returned as an argument, any attempt to assign a new object results in a compile-time error. With respect to the <Tt CLaSS="monofont">const</TT>ness, a <TT clasS="monofont">const auto_ptr</TT> behaves like a constant pointer <Tt claSS="monofont">(T* const p)</TT> and not like a pointer that refers to a constant <tt clASS="monofont">(const T* p);</Tt> although the syntax looks the other way around.</p>

				
			
			<h4>4.2.3
<tt class="monofont">auto_ptr</tt>s as Members</h4>
				<p>By using <tt class="monofont">auto_ptr</TT>s within a class you can also avoid resource leaks. If you use an <TT CLaSS="monofont">auto_ptr</tT> instead of an ordinary pointer, you no longer need a destructor because the object gets deleted with the deletion of the member. In addition, an <Tt CLASS="monofont">auto_ptr</Tt> helps to avoid resource leaks that are caused by exceptions that are thrown during the initialization of an object. Note that destructors are called only if any construction is completed. So, if an exception occurs inside a constructor, destructors are only called for objects that have been fully constructed. This might result in a resource leak if, for example, the first <tt cLASS="monofont">new</tt> was successful but the second was not. For example:</p>

				<pRE>
					
   class ClassB {
     private:
       ClassA* ptr1;                 <I>//pointer members</I>
       ClassA* ptr2;
     public:
       <i>//constructor that initializes the pointers</i>
       <i>//- will cause resource leak if second</i> new <I>throws</I>
       ClassB (ClassA val1, ClassA val2)
        : ptr1(new ClassA(val1)), ptr2(new ClassA(val2)) {
       }


       <I>//copy constructor</I>
       <i>//- might cause resource leak if second new throws</i>
       ClassB (const ClassB&amp; x)
        : ptr1(new ClassA(*x.ptr1)), ptr2(new ClassA(*x.ptr2)) {
       }


       <i>//assignment operator</i>
       const ClassB&amp; operator= (const ClassB&amp; x) {
          *ptr1 = *x.ptr1;
          *ptr2 = *x.ptr2;
          return *this;
       }


       ~ClassB () {
           delete ptr1;
           delete ptr2;
       }
       ...
   };

				</pre>

				<p>To avoid such a possible resource leak, you can simply use <tt class="monofont">auto_ptr</tt>s:</p>

				<pre>
					
   class ClassB {
     private:
       const std::auto_ptr&lt;ClassA&gt; ptr1;         <I>//</I>auto_ptr <I>members</I>
       const std::auto_ptr&lt;ClassA&gt; ptr2;
     public:
       <I>//constructor that initializes the</I> auto_ptr<i>s</I>
       <I>//- no resource leak possible</i>
       ClassB (ClassA val1, ClassA val2)
        : ptr1 (new ClassA(val1)), ptr2(new ClassA(val2)) {
       }


       <I>//copy constructor</I>
       <i>//- no resource leak possible</I>
       ClassB (const ClassB&amp; x)
        : ptr1(new ClassA(*x.ptr1), ptr2(new ClassA(*x.ptr2)) {
       }


       <I>//assignment operator</I>
       const ClassB&amp; operator= (const ClassB&amp; x) {
          *ptr1 = *x.ptr1;
          *ptr2 = *x.ptr2;
          return *this;
       }


       <I>//no destructor necessary</I>
       <I>//(default destructor lets</i> ptr1 <i>and</i> ptr2 <i>delete their objects)</I>
       ...
   };

				</PRE>

				<p>Note, however, that although you can skip the destructor, you still have to program the copy constructor and the assignment operator. By default, both would try to transfer ownership, which is probably not the intention. In addition, and as mentioned on page 42, to avoid an unintended transfer of ownership you should also use constant <tt cLASS="monofont">auto_ptr</tt>s here if the <tt CLASs="monofont">auto_ptr</tt> should refer to the same object throughout its lifetime.</p>

			
			<h4>4.2.4
Misusing <tt class="monofont">auto_ptr</tt>s</h4>
				<p><tt claSS="monofont">auto_ptr</TT>s satisfy a certain need; namely, to avoid resource leaks when exception handling is used. Unfortunately, the exact behavior of <TT cLAsS="monofont">auto_ptr</Tt>s changed in the past and no other kind of smart pointers are provided in the C++ standard library, so people tend to misuse <TT CLASs="monofont">auto_ptr</tt>s. Here are some hints to help you use them correctly:</p>

				<OL TYpe="1" stART="restarts">
<Li><p><b><tT CLAss="monofont">auto_ptr</tt></b><b>s cannot share ownership.</b></p>

						<p>An <tt class="monofont">auto_ptr</tt> must <i>not</i> refer to an object that is owned by another <tT CLASS="monofont">auto_ptr</tT> (or other object). Otherwise, if the first pointer deletes the object, the other pointer suddenly refers to a destroyed object, and any further read or write access may result in disaster.</P>
</lI>
<Li><P><B><TT CLass="monofont">auto_ptr</tT></B><B>s are not provided for arrays.</B></p>

						<p>An <tt CLASs="monofont">auto_ptr</tt> is <i>not</I> allowed to refer to arrays. This is because an <TT Class="monofont">auto_ptr</tt> calls <tt class="monofont">delete</tt> instead of <tt clasS="monofont">delete []</TT> for the object it owns. Note that there is no equivalent class in the C++ standard library that has the <TT ClASs="monofont">auto_ptr</TT> semantics for arrays. Instead, the library provides several container classes to handle collections of data (see <a href="0201379260_cnode32.html">Chapter 5</A>).</P>
</li>
<li><P><B><TT clasS="monofont">auto_ptr</TT></B><b>s are not "universal smart pointers."</b></p>

						<p>An <TT CLass="monofont">auto_ptr</tt> is <i>not</i> designed to solve other problems for which smart pointers might be useful. In particular, they are not pointers for reference counting. (Pointers for reference counting ensure that an object gets deleted only if the last of several smart pointers that refer to that object gets destroyed.)</p>
</li>
<li><p><b><tt class="monofont">auto_ptr</TT></B><B>s don't meet the requirements for container elements.</B></P>

						<p>An <TT cLAsS="monofont">auto_ptr</TT> does <I>not</I> meet one of the most fundamental requirements for elements of standard containers. That is, after a copy or an assignment of an <Tt claSS="monofont">auto_ptr,</TT> source and sink are not equivalent. In fact, when an <tt clASS="monofont">auto_ptr</Tt> is assigned or copied, the source <tt cLASS="monofont">auto_ptr</tt> gets modified because it transfers its value rather than copying it. So you should not use an <tt class="monofont">auto_ptr</tt> as an element of a standard container. Fortunately, the design of the language and library prevents this misuse from compiling in a standard-conforming environment.</p>

					</li>
</ol>

				<p>Unfortunately, sometimes the misuse of an <tt clASS="monofont">auto_ptr</TT> works. Regarding this, using nonconstant <Tt CLaSS="monofont">auto_ptr</tT>s is no safer than using ordinary pointers. You might call it luck if the misuse doesn't result in a crash, but in fact you are unlucky because you don't realize that you made a mistake.</P>

				<P>See <A href="0201379260_snode43.html#3">Section 5.10.2</a>, for a discussion and <a href="0201379260_snode55.html">Section 6.8</a>, for an implementation of a smart pointer for reference counting. This pointer is useful when sharing elements in different containers.</p>

			
			<h4>4.2.5
<tT CLAss="monofont">auto_ptr</tt> Examples</H4>
				<P>The first example shows how <TT class="monofont">auto_ptr</tt>s behave regarding the transfer of ownership:</p>

				<pre>
					
   <i>//util/autoptr1.cpp</i>

   #include &lt;iostream&gt;
   #include &lt;memory&gt;
   using namespace std;


   <i>/* define output operator for</i> auto_ptr
    <i>* - print object value or NULL</i>
    <i>*/</i>
   template &lt;class T&gt;
   ostream&amp; operator&lt;&lt; (ostream&amp; strm, const auto_ptr&lt;T&gt;&amp; p)
   {
       <i>//does</i> p <I>own an object ?</I>
       if (p.get() == NULL) {
           strm &lt;&lt; "NULL";        <I>//NO: print NULL</I>
        }
        else {
           strm &lt;&lt; *p;           <I>//YES: print the object</I>
        }
        return strm;
   }


   int main()
   {
       auto_ptr&lt;int&gt; p(new int(42));
       auto_ptr&lt;int&gt; q;


       cout &lt;&lt; "after initialization:" &lt;&lt; endl;
       cout &lt;&lt; " p: " &lt;&lt; p &lt;&lt; endl;
       cout &lt;&lt; " q: " &lt;&lt; q &lt;&lt; endl;


       q = p;
       cout &lt;&lt; "after assigning auto pointers:" &lt;&lt; endl;
       cout &lt;&lt; " p: " &lt;&lt; p &lt;&lt; endl;
       cout &lt;&lt; " q: " &lt;&lt; q &lt;&lt; endl;


       *q += 13;                   <i>//change value of the object</I> q <I>owns</i>
       p = q;
       cout &lt;&lt; "after change and reassignment:" &lt;&lt; endl;
       cout &lt;&lt; " p: " &lt;&lt; p &lt;&lt; endl;
       cout &lt;&lt; " q: " &lt;&lt; q &lt;&lt; endl;
   }

				</PRe>

				<P>The output of the program is as follows:</P>

				<PRE>
					
   after initialization:
    p: 42
    q: NULL
   after assigning auto pointers:
    p: NULL
    q: 42
   after change and reassignment:
    p: 55
    q: NULL

				</Pre>

				<p>Note that the second parameter of the output operator function is a constant reference. So it uses <tT CLAss="monofont">auto.ptr</tt>s without any transfer of ownership.</P>

				<P>As mentioned on page 40, bear in mind that you can't initialize an <TT clasS="monofont">auto_ptr</TT> by using the assignment syntax or assign an ordinary pointer:</P>

				<pre>
					
    std::auto_ptr&lt;int&gt; p(new int(42));     <i>//OK</i>
    std::auto_ptr&lt;int&gt; p = new int(42);    <i>//ERROR</i>


    p = std::auto_ptr&lt;int&gt;(new int(42));   <i>//OK</i>
    p = new int(42);                       <i>//ERROR</i>

				</pre>

				<p>This is because the constructor to create an <tt clasS="monofont">auto_ptr</TT> from an ordinary pointer is declared as <TT ClASs="monofont">explicit</TT> (see <a href="0201379260_snode14.html#15">Section 2.2.6</A>, for an introduction of <Tt claSS="monofont">explicit</TT>).</p>

				<p>The following example shows how constant <tt CLASs="monofont">auto_ptr</tt>s behave:</p>

				<PRE>
					
   <I>//util/autoptr2.cpp</i>

   #include &lt;iostream&gt;
   #include &lt;memory&gt;
   using namespace std;


   <i>/* define output operator for</i> auto_ptr
    <i>* - print object value or NULL</i>
    <i>*/</i>
   template &lt;class T&gt;
   ostream&amp; operator&lt;&lt; (ostream&amp; strm, const auto_ptr&lt;T&gt;&amp; p)
   {
       <i>//does</i> p <i>own an object ?</i>
       if (p.get() == NULL) {
           strm &lt;&lt; "NULL";       <i>//NO: print NULL</i>
       }
       else {
           strm &lt;&lt; *p;           <i>//YES: print the object</i>
       }
       return strm;
   }


   int main()
   {
       const auto_ptr&lt;int&gt; p(new int(42));
       const auto_ptr&lt;int&gt; q(new int(0));
       const auto_ptr&lt;int&gt; r;
       cout &lt;&lt; "after initialization:" &lt;&lt; endl;
       cout &lt;&lt; " p: " &lt;&lt; p &lt;&lt; endl;
       cout &lt;&lt; " q: " &lt;&lt; q &lt;&lt; endl;
       cout &lt;&lt; " r: " &lt;&lt; r &lt;&lt; endl;


       *q = *p;
   //  *r = *p;    <i>//ERROR: undefined behavior</i>
       *p = -77;
       cout &lt;&lt; "after assigning values:" &lt;&lt; endl;
       cout &lt;&lt; " p: " &lt;&lt; p &lt;&lt; endl;
       cout &lt;&lt; " q: " &lt;&lt; q &lt;&lt; endl;
       cout &lt;&lt; " r: " &lt;&lt; r &lt;&lt; endl;


   //  q = p;      <i>//ERROR at compile time</i>
   //  r = p;      <i>//ERROR at compile time</i>
   }

				</PRE>

				<P>Here, the output of the program is as follows:</P>

				<PrE>
					
   after initialization:
    p: 42
    q: 0
    r: NULL
   after assigning values:
    p: -77
    q: 42
    r: NULL

				</PrE>

				<P>This example defines an output operator for <tT CLASS="monofont">auto_ptr</tt>s. To do this, it passes an <tt CLASs="monofont">auto_ptr</tt> as a constant reference. According to the discussion on page 43, you should usually not pass an <tT CLAss="monofont">auto_ptr</tt> in any form. This function is an exception to this rule.</P>

				<P>Note that the assignment</P>

				<Pre>
					
   *r = *p;

				</pre>

				<p>is an error. It dereferences an <tt class="monofont">auto_ptr</tt> that refers to no object. According to the standard, this results in undefined behavior; for example, a crash. As you can see, you can manipulate the objects to which constant <tt clasS="monofont">auto_ptr</TT>s refer, but you can't change which objects they own. Even if <TT ClASs="monofont">r</TT> was nonconstant, the last statement would not be possible because it would change the constant <tT CLASS="monofont">p.</tt></p>

			
			<h4>4.2.6
Class <TT CLass="monofont">auto_ptr</tT> in Detail</H4>
				<P>Class <Tt claSS="monofont">auto_ptr</TT> is declared in <tt class="monofont">&lt;memory&gt;:</tt></p>

				<pre>
					
   #include &lt;memory&gt;

				</pre>

				<p>It provides <tt clASS="monofont">auto_ptr</TT> as a template class for any types in namespace <Tt CLaSS="monofont">std.</tT> The following is the exact declaration of the class <TT CLAss="monofont">auto_ptr:</tt><FONT size="1"><SUP><A href="#FOOTNOTE-6">[6]</A></SUP></font>
</p>
<blockquote><font siZE="1">
<P CLAsS="footnote">
<SuP><A nAME="FOOTNOTE-6">[6]</A></SUp>
This is a slightly improved version that fixes some minor problems of the version in the C++ standard (<tt cLASS="monofont">auto_ptr_ref</tt> is global now and there is an assignment operator from <tt CLASs="monofont">auto_ptr_ref</tt> to <tT CLAss="monofont">auto_ptr;</tt> see page 55).</p>
</font></blockquote>

					
				<prE>
					
   namespace std {
       <I>//auxiliary type to enable copies and assignments</I>
       template &lt;class Y&gt; struct auto_ptr_ref {};


       template&lt;class T&gt;
       class auto_ptr {
         public:
           <I>//type names for the value</I>
           typedef T element_type;


           <I>//constructor</i>
           explicit auto_ptr(T* ptr = 0) throw();


           <I>//copy constructors (with implicit conversion)</I>
           <i>//- note: nonconstant parameter</I>
           auto_ptr(auto_ptr&amp;) throw();
           template&lt;class U&gt; auto_ptr(auto_ptr&lt;U&gt;&amp;) throw();


           <I>//assignments (with implicit conversion)</i>
           <I>//- note: nonconstant parameter</I>
           auto_ptr&amp; operator= (auto_ptr&amp;) throw();
           template&lt;class U&gt;
               auto_ptr&amp; operator= (auto_ptr&lt;U&gt;&amp;) throw();


           <I>//destructor</I> 
           ~auto_ptr() throw();


           <I>//value access</I>
           T* get() const throw();
           T&amp; operator*() const throw();
           T* operator-&gt;() const throw();


           <i>//release ownership</i>
           T* release() throw();


           <i>//reset value</i>
           void reset(T* ptr = 0) throw();


         <I>//special conversions to enable copies and assignments</I>
         public:
           auto_ptr(auto_ptr_ref&lt;T&gt;) throw();
           auto_ptr&amp; operator= (auto_ptr_ref&lt;T&gt; rhs) throw();
           template&lt;class U&gt; operator auto_ptr_ref&lt;U&gt;() throw();
           template&lt;class U&gt; operator auto_ptr&lt;U&gt;() throw();
      };
   }

				</PRe>

				<p>The individual members are described in detail in the following sections, in which <i>auto_ptr</i> is an abbreviation for <TT CLass="monofont">auto_ptr&lt;T&gt;.</tT> A complete sample implementation of class <TT Class="monofont">auto_ptr</tt> is located on page 56.</p>

				<h5>Type Definitions</h5>
					<p><i>auto_ptr::</i>
						<b>element_type</b></p>

					<ul>
<li><p>The type of the object that the <tT CLASS="monofont">auto_ptr</tT> owns.</P>

						</lI>
</Ul>
				
				<H5>Constructors, Assignments, and Destructors</H5>
					<P><I>auto_ptr::</I><B>auto_ptr</b>
						<tt cLASS="monofont">() throw()</tt></p>

					<uL>
<LI><P>The default constructor.</p>
</li>
<lI><P>Creates an <TT class="monofont">auto_ptr</tt> that does not own an object.</p>
</li>
<li><p>Initializes the value of the <tt class="monofont">auto_ptr</tT> with zero.</P>

						</LI>
</UL>
					<p><TT cLAsS="monofont">explicit</TT>
						<I>auto_ptr::</I><B>auto_ptr</b>
						<tt cLASS="monofont">(T*</tt>
						<i>ptr</i><TT CLass="monofont">) throw()</tT></P>

					<UL>
<li><p>Creates an <tt class="monofont">auto_ptr</tt> that owns and points to the object to which <tt class="monofont">ptr</tt> refers.</P>
</LI>
<LI><P>After the call, <tT ClASs="monofont">*this</TT> is the owner of the object to which <I>ptr</I> refers. There must be no other owner.</P>
</Li>
<li><p>If <I>ptr</I> is not the null pointer, it must be a value returned by <TT clasS="monofont">new</TT> because the destructor of the <Tt claSS="monofont">auto_ptr</TT> calls <tt class="monofont">delete</tt> automatically for the object it owns.</p>
</li>
<li><p>It is not correct to pass the return value of a new array that was created by <tt clasS="monofont">new[].</TT> (For arrays, the STL container classes, which are introduced in <A href="0201379260_snode35.html">Section 5.2</A>, should be used.)</p>

						</LI>
</uL>
					<P><I>auto_ptr::</I><B>auto_ptr</B>
						<tt clASS="monofont">(auto_ptr&amp;</Tt>
						<i>ap</i><tT CLAss="monofont">) throw()</tt></P>

					<P><TT class="monofont">template&lt;class U&gt;</tt>
						<i>auto_ptr::</i><b>auto_ptr</b>
						<tt class="monofont">(auto_ptr&lt;U&gt;&amp;</tt>
						<i>ap</I><TT CLAsS="monofont">) throw()</Tt></P>

					<Ul>
<LI><P>The copy constructor (for nonconstant values).</P>
</LI>
<li><p>Creates an <tT CLAss="monofont">auto_ptr</tt> that adopts the ownership of the object <I>ap</I> owned on entry. The ownership of an object to which <I>ap</I> referred on entry (if any) is transferred to <tt clASS="monofont">*this.</Tt></p>
</li>
<li><p>After the operation, <i>ap</i> no longer owns an object. Its value becomes the null pointer. Thus, in contrast to the usual implementation of a copy constructor, the source object gets modified.</p>
</li>
<li><p>Note that this function is overloaded with a member template (see page 11 for an introduction to member templates). This enables automatic type conversions from the type of <i>ap</i> to the type of the created <tt clASS="monofont">auto_ptr;</TT> for example, to convert an <Tt CLaSS="monofont">auto_ptr</tT> to an object of a derived class into an <TT CLAss="monofont">auto_ptr</tt> to an object of a base class.</P>
</LI>
<Li><p>See <a href="0201379260_snode27.html#4">Section 4.2.2</A>, for a discussion of the transfer of ownership.</p>

						</li>
</uL>
					<P><I>auto_ptr&amp; auto_ptr::</I><b>operator =</b>
						<tt class="monofont">(auto_ptr&amp;</tt>
						<i>ap</i><tt class="monofont">) throw()</tT></P>

					<P><TT ClASs="monofont">template&lt;class U&gt;</TT>
						<i>auto_ptr&amp; auto_ptr::</I><B>operator =</B>
						<TT Class="monofont">(auto_ptr&lt;U&gt;&amp;</TT>
						<I>ap</I><tt clASS="monofont">) throw()</Tt></p>

					<ul>
<LI><P>The assignment operator (for nonconstant values).</P>
</li>
<li><p>Deletes the object it owns on entry (if any) and adopts the ownership of the object that <i>ap</i> owned on entry. Thus, the ownership of an object to which <i>ap</i> referred on entry (if any) is transferred to <tt class="monofont">*this.</tt></p>
</li>
<LI><P>After the operation, <I>ap</I> no longer owns an object. Its value becomes the null pointer. Thus, in contrast to the usual implementation of an assignment operator, the source object gets modified.</P>
</lI>
<Li><P>The object to which the <Tt CLASS="monofont">auto_ptr</Tt> on the left-hand side of the assignment (<tt cLASS="monofont">*this</tt>) refers is deleted by calling <tt CLASs="monofont">delete</tt> for it.</p>
</LI>
<LI><p>Note that this function is overloaded with a member template (see page 11 for an introduction to member templates). This enables automatic type conversions from the type of <i>ap</i> to the type of <tt class="monofont">*this;</tt> for example, to convert an <tt class="monofont">auto_ptr</tt> to an object of a derived class into an <TT CLASs="monofont">auto_ptr</TT> to an object of a base class.</p>
</LI>
<lI><P>See <A href="0201379260_snode27.html#4">Section 4.2.2</a>, for a discussion about the transfer of ownership.</p>

						</lI>
</UL>
					<P><i>auto_ptr::</i><b>~auto_ptr</b>
						<TT CLass="monofont">() throw()</tT></P>

					<UL>
<li><p>The destructor.</p>
</li>
<li><p>If the <tt class="monofont">auto_ptr</tt> owns an object on entry, it calls <tt cLASS="monofont">delete</TT> for it.</p>

						</LI>
</uL>
				
				<H5>Value Access</h5>
					<P><TT CLAss="monofont">T*</tt>
						<I>auto_ptr::</I><B>get</B>
						<tt clASS="monofont">() const throw()</Tt></p>

					<ul>
<LI><P>Returns the address of the object that the <Tt class="monofont">auto_ptr</tt> owns (if any).</p>
</li>
<li><p>Returns the null pointer if the <tt class="monofont">auto_ptr</TT> does not own an object.</P>
</LI>
<Li><P>This call does not change the ownership. Thus, on exit the <Tt CLaSS="monofont">auto_ptr</TT> still owns the object that it owned on entry (if any).</P>

						</Li>
</ul>
					<p><TT CLass="monofont">T&amp;</tT>
						<I>auto_ptr::</I><B>operator</b> * <tt cLASS="monofont">() const throw()</tt></p>

					<ul>
<li><p>The dereferencing operator.</p>
</li>
<li><p>Returns the object that the <tt class="monofont">auto_ptr</TT> owns.</P>
</LI>
<Li><P>If the <Tt CLaSS="monofont">auto_ptr</TT> does not own an object, the call results in undefined behavior (which may result in a crash).</P>

						</Li>
</ul>
					<p><TT CLass="monofont">T*</tT>
						<I>auto_ptr::</I><B>operator-&gt;</b>
						<tt cLASS="monofont">() const throw()</tt></p>

					<ul>
<li><p>The operator for member access.</p>
</li>
<li><p>Returns a member of the object that the <tt class="monofont">auto_ptr</TT> owns.</P>
</LI>
<Li><P>If the <Tt CLaSS="monofont">auto_ptr</TT> does not own an object, the call results in undefined behavior (which may result in a crash).</P>

						</Li>
</ul>
				
				<h5>Value Manipulation</H5>
					<P><TT clasS="monofont">T*</TT>
						<I>auto_ptr::</i><b>release</b>
						<tT CLAss="monofont">() throw()</tt></p>

					<ul>
<li><p>Releases the ownership of the object that the <tt class="monofont">auto_ptr</tt> owns.</p>
</lI>
<LI><P>Returns the address of the object that the <TT cLAsS="monofont">auto_ptr</Tt> owned on entry (if any).</P>
</LI>
<LI><P>Returns the null pointer if the <tt clASS="monofont">auto_ptr</Tt> does not own an object on entry.</p>

						</li>
</UL>
					<P><Tt claSS="monofont">void</TT>
						<i>auto_ptr::</i><b>reset</b>
						<tt class="monofont">(T*</tt><i> ptr</i>
						<tt clasS="monofont">= 0)</TT>
						<TT ClASs="monofont">throw()</TT></p>

					<UL>
<LI><P>Reinitializes the <Tt claSS="monofont">auto_ptr</TT> with<i> ptr.</i></p>
</lI>
<LI><P><tt clASS="monofont">delete</Tt>s the object that the <tt class="monofont">auto_ptr</tt> owns on entry (if any).</p>
</li>
<li><p>After the call, <tt claSS="monofont">*this</TT> is the owner of the object to which <I>ptr</I> refers. There should be no other owner.</p>
</LI>
<lI><P>If <i>ptr</I> is not the null pointer it should be a value returned by <TT CLAss="monofont">new</tt> because the destructor of the <TT CLass="monofont">auto_ptr</tT> automatically calls <TT Class="monofont">delete</TT> for the object it owns.</P>
</Li>
<li><p>Note that it is not correct to pass the return value of a new array that was creates by <tt class="monofont">new [].</tt> (For arrays, the STL container classes, which are introduced in <a href="0201379260_snode35.html">Section 5.2</a>, should be used.)</p>

						</lI>
</UL>
				
				<H5>Conversions</H5>
					<P>The rest of the class <tT ClASs="monofont">auto.ptr</TT> (auxiliary type <TT CLass="monofont">auto_ptr_ref</tT> and functions using it) consists of rather tricky conversions that enable you to use copy and assignment operations for nonconstant <TT Class="monofont">auto_ptr</TT>s but not for constant <TT clasS="monofont">auto_ptr</TT>s (see page 44 for details). The following is a quick explanation.<Font size="1"><sup><a href="#FOOTNOTE-7">[7]</a></sup></foNT>
 We have the following two requirements:</P>
<BLOcKQuOTe><FONT SIze="1">
<p cLASS="footnote">
<sup><a NAME="FOOTNOTE-7">[7]</a></sup>
Thanks to Bill Gibbons for pointing this out.</P>
</FONt></blockquote>

						
					<ol type="1" starT="restarts">
<LI><P>It should be possible to pass <TT cLAsS="monofont">auto_ptr</Tt>s to and from functions as rvalues.<FONT SIze="1"><suP><A HRef="#FOOTNOTE-8">[8]</a></sUP></FOnt>
 Because <tt CLASs="monofont">auto_ptr</tt> is a class, this must be done using a constructor.</p>
<blockquote><font sizE="1">
<P CLASs="footnote">
<SUp><A NaME="FOOTNOTE-8">[8]</A></SUP>
The names <i>rvalue</i> and <i>lvalue</i> come originally from the assignment expression <I>expr1 = expr2,</I> in which the left operand <I>expr1</I> must be a (modifiable) 1value. However, an 1value is perhaps better considered as representing an object <i>l</i>ocator <i>value.</i> Thus, it is an expression that designates an object by name or address (pointer or reference). Lvalues need not be modifiable. For example, the name of a constant object is a nonmodifiable 1value. All expressions that are not 1values are rvalues. In particular, temporary objects created explicitly (<TT CLass="monofont">T()</tT>) or as the result of a function call are rvalues.</P>
</FOnt></blockquote>

								</li>
<li><p>When an <tt clASS="monofont">auto_ptr</TT> is copied, it is important that the source pointer gives up ownership. This requires that the copy modifies the source <Tt CLaSS="monofont">auto_ptr.</tT></P>

						</LI>
</OL>

					<p>An ordinary copy constructor can copy an rvalue, but to do so it must declare its parameter as a reference to a <tt cLASS="monofont">const</tt> object. To use an ordinary constructor to copy an <tt CLASs="monofont">auto_ptr</tt> we would have to declare the data member containing the real pointer <tT CLAss="monofont">mutable</tt> so that it could be modified in the copy constructor. But this would allow you to write code that copies <tt class="monofont">auto_ptr</tt> objects that were actually declared <tt class="monofont">const,</tT> transferring their ownership in contradiction to their constant status.</P>

					<P>The alternative is to find a mechanism to enable an rvalue to be converted to an lvalue. A simple operator conversion function to reference type does not work because an operator conversion function is never called to convert an object to its own type (remember that the reference attribute is not part of the type). Thus, the <TT ClASs="monofont">auto_ptr_ref</TT> class was introduced to provide this convert-to-lvalue mechanism. The mechanism relies on a slight difference between the overloading and template argument deduction rules. This difference is too subtle to be of use as a general programming tool, but it is sufficient to enable the <tT CLASS="monofont">auto_ptr</tt> class to work correctly.</p>

					<p>Don't be surprised if your compiler doesn't support the distinction between nonconstant and constant <TT CLass="monofont">auto_ptr</tT>s yet. And be aware that if your compiler does not yet implement this distinction, your <TT Class="monofont">auto_ptr</TT> interface is more dangerous. In this case, it is rather easy to transfer ownership by accident.</P>

				
				<H5>Sample Implementation of Class <tt class="monofont">auto_ptr</tt></h5>
					<p>The following code contains a sample implementation of a standard-conforming <tt class="monofont">auto_ptr</tt> class<fONT SIZe="1"><SUp><A HrEF="#FOOTNOTE-9">[9]</A></SUP></font>
:</P>
<BLOckquOTE><Font sIZE="1">
<P class="footnote">
<sup><a name="FOOTNOTE-9">[9]</a></sup>
Thanks to Greg Colvin for this implementation of <tt clASS="monofont">auto.ptr.</TT> Note that it does not conform exactly to the standard. It turned out that the specification in the standard is still not correct regarding the special conversions encountered using <Tt CLaSS="monofont">auto_ptr_ref.</tT> The version presented in this book, hopefully, fixes all the problems. However, at the writing of this book, there was still ongoing discussion.</P>
</FONT></blocKQUOte>

						
					<prE>
						
   <I>// util/autoptr.hpp</I>

   <I>/* class</i> auto_ptr
    <i>*- improved standard conforming implementation
    */</i>
   namespace std {
       <i>//auxiliary type to enable copies and assignments (now global)</I>
       template&lt;class Y&gt; 
       struct auto_ptr_ref {
           Y* yp; 
           auto_ptr_ref (Y* rhs)
            : yp(rhs) {
           }
       };


       template&lt;class T&gt;
       class auto_ptr {
         private:
           T* ap;    <I>//refers to the actual owned object (if any)</I>
         public:
           typedef T element_type;


           <I>//constructor</i>
           explicit auto_ptr (T* ptr = 0) throw()
            : ap(ptr) {
           }


           <i>//copy constructors (with implicit conversion)</i>
           <i>//- note: nonconstant parameter</i>
           auto_ptr (auto_ptr&amp; rhs) throw()
            : ap (rhs. release()) {
           }
           template&lt;class Y&gt;
           auto_ptr (auto_ptr&lt;Y&gt;&amp; rhs) throw()
            : ap(rhs.release()) { 
           }


           <i>//assignments (with implicit conversion)</i>
           <i>//- note: nonconstant parameter</i>
           auto_ptr&amp; operator= (auto_ptr&amp; rhs) throw() {
               reset(rhs.release());
               return *this; 
           }
           template&lt;class Y&gt;
           auto_ptr&amp; operator= (auto_ptr&lt;Y&gt;&amp; rhs) throw() {
               reset(rhs.release());
               return *this; 
           }


           <i>//destructor</i>
            ~auto_ptr() throw() {
                delete ap; 
           }


           <i>//value access</i>
           T* get() const throw() {
               return ap; 
           } 
           T&amp; operator*() const throw() {
               return *ap; 
           }
           T* operator-&gt;() const throw() {
               return ap; 
           }


           <i>//release ownership</i>
           T* release() throw() {
               T* tmp(ap);
               ap = 0;
               return tmp;
           }


           <i>//reset value</i>
           void reset (T* ptr=0) throw(){
               if (ap != ptr) { 
                   delete ap; 
                   ap = ptr; 
               }
           }


           <i>/* special conversions with auxiliary type to enable copies and assignments</i>
            <i>*/</i>
           auto_ptr(auto_ptr_ref&lt;T&gt; rhs) throw()
            : ap(rhs.yp) {
           }
           auto_ptr&amp; operator= (auto_ptr_ref&lt;T&gt; rhs) throw() { <I>//new</I> 
                reset(r.yp);
                return *this;
           }
           template&lt;class Y&gt; 
           operator auto_ptr_ref&lt;Y&gt;() throw() {
               return auto_ptr_ref&lt;Y&gt;(release()); 
           }
           template&lt;class Y&gt; 
           operator auto_ptr&lt;Y&gt;() throw() {
               return auto_ptr&lt;Y&gt;(release()); 
           }
       };
   }

					</PRE>

				
			
		</FoNT>
 
<table width="100%" border="0" cellspacing="0" cellpadding="0" bgcolor="#CCCCCC">
<td><font color="black" size=1>I l<font color="#FF0000">@</font>ve RuBoard</td>
<td valign="top" class="v2" align="right"><a href="0201379260_snode26.html"><img src="FILES/previous.gif" width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a> <a href="0201379260_snode28.html"><img src="FILES/next.gif" width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a></td></table>
</BODY></HTML>