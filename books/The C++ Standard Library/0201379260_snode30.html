<HTML><HEAD><META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=iso-8859-1">
<!--SafClassName="docSection1Title"--><!--SafTocEntry="4.5 Supplementary Comparison Operators"-->
<LINK REL="stylesheet" href="FILES/sbolM.css">
</HEAD>
<BODY link="#354278" vlink="#000066" alink="#000080" topmargin="0">
<table width="100%" border="0" cellspacing="0" cellpadding="0" bgcolor="#CCCCCC">
<td><font color="black" size=1>I l<font color="#FF0000">@</font>ve RuBoard</td>
<td valign="top" class="v2" align="right"><a href="0201379260_snode29.html"><img src="FILES/previous.gif" width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a> <a href="0201379260_snode31.html"><img src="FILES/next.gif" width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a></td></table>
<FONT><h3>4.5
Supplementary Comparison Operators</h3>
			<p>Four template functions define the comparison operators <tT CLAss="monofont">! =, &gt;, &lt;=,</tt> and <TT CLass="monofont">&gt;=</tT> by calling the operators <TT Class="monofont">==</tt> and <tt class="monofont">&lt;.</tt> These functions are defined in <tt clasS="monofont">&lt;utility&gt;</TT> as follows:</P>

			<PRe>
				
   namespace std {
       namespace rel_ops {
           template &lt;class T&gt;
           inline bool operator!= (const T&amp; x, const T&amp; y) {
               return !(x == y);

      bool operator== (const X&amp; x) const;
      bool operator&lt; (const X&amp; x) const;
      ...
   };


   void foo()
   {
       using namespace std::rel_ops;     <I>//make</I> !=, &gt;, <i>etc., available</I>
       X x1, x2;
      ...


      if (x1 != x2) {
          ...
      }
      ...


      if (x1 &gt; x2) {
          ...
      }
      ...
   }

			</PrE>

			<P>Note that these operators are defined in a subnamespace of <TT CLass="monofont">std,</tT> called <TT Class="monofont">rel_ops.</TT> The reason that they are in a separate namespace is so that users who define their own relational operators in the global namespace won't clash even if they made all identifiers of namespace <TT clasS="monofont">std</TT> global by using a general using directive:</P>

			<pre>
				
   using namespace std;               <i>//operators are not in global scope</i>

			</pre>

			<p>On the other hand, users who want to get their hands on them explicitly can implement the following without having to rely on lookup rules to find them implicitly:</p>

			<pre>
				
   using namespace std::rel_ops ;     <i>//operators are in global scope</i>

			</pre>

			<p>Some implementations define the previous templates by using two different argument types:</p>

			<pRE>
				
   namespace std {
       template &lt;class T1, class T2&gt;
       inline bool operator!=(const T1&amp; x, const T2&amp; y) {
           return !(x == y); 
       }
       ...
   }

			</PRE>

			<P>The advantage of such an implementation is that the types of the operands may differ (provided the types are comparable). But, note that this kind of implementation is not provided by the C++ standard library. Thus, taking advantage of it makes code nonportable.</p>

		</FOnT>
 
<table width="100%" border="0" cellspacing="0" cellpadding="0" bgcolor="#CCCCCC">
<td><font color="black" size=1>I l<font color="#FF0000">@</font>ve RuBoard</td>
<td valign="top" class="v2" align="right"><a href="0201379260_snode29.html"><img src="FILES/previous.gif" width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a> <a href="0201379260_snode31.html"><img src="FILES/next.gif" width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a></td></table>
</BODY></HTML>