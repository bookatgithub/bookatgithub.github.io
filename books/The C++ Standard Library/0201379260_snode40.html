<HTML><HEAD><META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=iso-8859-1">
<!--SafClassName="docSection1Title"--><!--SafTocEntry="5.7 User-Defined Generic Functions"-->
<LINK REL="stylesheet" href="FILES/sbolM.css">
</HEAD>
<BODY link="#354278" vlink="#000066" alink="#000080" topmargin="0">
<table width="100%" border="0" cellspacing="0" cellpadding="0" bgcolor="#CCCCCC">
<td><font color="black" size=1>I l<font color="#FF0000">@</font>ve RuBoard</td>
<td valign="top" class="v2" align="right"><a href="0201379260_snode39.html"><img src="FILES/previous.gif" width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a> <a href="0201379260_snode41.html"><img src="FILES/next.gif" width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a></td></table>
<FONT><h3>5.7
User-Defined Generic Functions</h3>
			<p>The STL is an extensible framework. This means you can write your own functions and algorithms to process elements of collections. Of course, these operations may also be generic. However, to declare a valid iterator in these operations, you must use the type of the container, which is different for each container type. To facilitate the writing of generic functions, each container type provides some internal type definitions. Consider the following example:</p>

			<PRE>
				
   <I>// stl/print.hpp</i>

   #include &lt;iostream&gt;

   /* PRINT_ELEMENTS()
    <i>* - prints optional C-string</i> optcstr <i>followed by</I>
    <I>* - all elements of the collection</I> coll
    <I>* - separated by spaces</i>
    <i>*/</i>
   template &lt;class T&gt;
   inline void PRINT_ELEMENTS (const T&amp; coll, const char* optcstr="")
   {
       typename T::const_iterator pos;

       std::cout &lt;&lt; optcstr;
       for (pos=coll.begin(); pos!=coll.end(); ++pos) {
           std::cout &lt;&lt; *pos &lt;&lt; ' ';
       }
       std::cout &lt;&lt; std::endl;
   }

			</pRE>

			<P>This example defines a generic function that prints an optional string followed by all elements of the passed container. In the declaration</P>

			<pre>
				
   typename T::const_iterator pos;

			</pre>

			<p><tt class="monofont">pos</tt> is declared as having the iterator type of the passed container type, <tt claSS="monofont">typename</TT> is necessary to specify that <TT cLAsS="monofont">const_iterator</Tt> is a type and not a value of type <TT CLASs="monofont">T</tt> (see the introduction of <tT CLAss="monofont">typename</tt> on page 11).</P>

			<P>In addition to <TT clasS="monofont">iterator</TT> and <Tt class="monofont">const_iterator,</tt> containers provide other types to facilitate the writing of generic functions. For example, they provide the type of the elements to enable the handling of temporary copies of elements. See <a href="0201379260_snode63.html#1">Section 7.5.1</a>, for details.</p>

			<p>The optional second argument of <tt claSS="monofont">PRINT_ELEMENTS</TT> is a string that is used as a prefix before all elements are written. Thus, by using <TT cLAsS="monofont">PRINT_ELEMENTS()</Tt> you could comment or introduce the output like this:</P>

			<PRE>
				
   PRINT_ELEMENTS (coll, "all elements: ");

			</PRe>

			<p>I introduced this function here because I use it often in the rest of the book to print all elements of containers by using a simple call.</p>

		</fONT>
 
<table width="100%" border="0" cellspacing="0" cellpadding="0" bgcolor="#CCCCCC">
<td><font color="black" size=1>I l<font color="#FF0000">@</font>ve RuBoard</td>
<td valign="top" class="v2" align="right"><a href="0201379260_snode39.html"><img src="FILES/previous.gif" width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a> <a href="0201379260_snode41.html"><img src="FILES/next.gif" width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a></td></table>
</BODY></HTML>