<HTML><HEAD><META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=iso-8859-1">
<!--SafClassName="docSection1Title"--><!--SafTocEntry="6.2 Vectors"-->
<LINK REL="stylesheet" href="FILES/sbolM.css">
</HEAD>
<BODY link="#354278" vlink="#000066" alink="#000080" topmargin="0">
<table width="100%" border="0" cellspacing="0" cellpadding="0" bgcolor="#CCCCCC">
<td><font color="black" size=1>I l<font color="#FF0000">@</font>ve RuBoard</td>
<td valign="top" class="v2" align="right"><a href="0201379260_snode48.html"><img src="FILES/previous.gif" width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a> <a href="0201379260_snode50.html"><img src="FILES/next.gif" width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a></td></table>
<FONT><h3>6.2
Vectors</h3>
			<p>A vector models a dynamic array. Thus, it is an abstraction that manages its elements with a dynamic array (<a href="0201379260_snode49.html#1">Figure 6.1</a>). However, note that the standard does not specify that the implementation use a dynamic array. Rather, it follows from the constraints and specification of the complexity of its operation.</p>

			<ceNTER>
				<h5>
<a naME="1"></A>Figure 6.1. Structure of a Vector</H5><img border="0" width="500" height="75" src="FILES/06fig01.gif" ALT="graphics/06fig01.gif"></CeNTeR>

			<P>To use a vector, you must include the header file <tT CLASS="monofont">&lt;vector&gt;</tt><foNT SIze="1"><suP><A HRef="#FOOTNOTE-4">[4]</a></sUP></FOnt>
:</p>
<blockquote><font size="1">
<P CLASS="footnote">
<sUP><a NAmE="FOOTNOTE-4">[4]</A></SUP>
In the original STL, the header file for vectors was <Tt claSS="monofont">&lt;vector.h&gt;.</TT></p>
</fonT></BLOckquOTE>

			<Pre>
				
   #include &lt;vector&gt;

			</pre>

			<p>There, the type is defined as a template class inside namespace <tt class="monofont">std:</tt></p>

			<pre>
				
   namespace std {
       template &lt;class T,
                 class Allocator = allocator&lt;T&gt; &gt;
       class vector;
   }

			</prE>

			<P>The elements of a vector may have any type <TT CLaSS="monofont">T</tT> that is assignable and copyable. The optional second template parameter defines the memory model (see <A href="0201379260_cnode121.html">Chapter 15</A>). The default memory model is the model <TT clasS="monofont">allocator,</TT> which is provided by the C++ standard library.<Font sIZE="1"><Sup><a hREF="#FOOTNOTE-5">[5]</A></sup></font>
</p>
<blockquote><fonT SIZE="1">
<P cLAsS="footnote">
<SuP><A NAME="FOOTNOTE-5">[5]</a></sup>
In systems without support for default template parameters, the second argument is typically missing.</P>
</FONt></bloCKQUote>

			<a NAME="4"></a><h4>6.2.1
Abilities of Vectors</h4>
				<p>Vectors copy their elements into their internal dynamic array. The elements always have a certain order. Thus, vectors are a kind of <i>ordered collection.</i> Vectors provide <i>random access.</i> Thus, you can access every element directly in constant time, provided you know its position. The iterators are random access iterators, so you can use any algorithm of the STL.</p>

				<p>Vectors provide good performance if you append or delete elements at the end. If you insert or delete in the middle or at the beginning, performance gets worse. This is because every element behind has to be moved to another position. In fact, the assignment operator would be called for every following element.</p>

				<h5>Size and Capacity</h5>
					<p>Part of the way in which vectors give good performance is by allocating more memory than they need to contain all their elements. To use vectors effectively and correctly you should understand how size and capacity cooperate in a vector.</p>

					<p>Vectors provide the usual size operations <tt claSS="monofont">size(), empty(),</TT> and <TT cLAsS="monofont">max_size()</Tt> (see <A href="0201379260_snode48.html#2">Section 6.1.2</A>). An additional "size" operation is the <tt clASS="monofont">capacity()</Tt> function. <tt cLASS="monofont">capacity()</tt> returns the number of characters a vector could contain in its actual memory. If you exceed the <tt CLASs="monofont">capacity(),</tt> the vector has to reallocate its internal memory.</p>

					<p>The capacity of a vector is important for two reasons:</p>

					<ol type="1" start="restarts">
<li><p>Reallocation invalidates all references, pointers, and iterators for elements of the vector.</p>
</LI>
<LI><P>Reallocation takes time.</P>

						</lI>
</Ol>

					<P>Thus, if a program manages pointers, references, or iterators into a vector, or if speed is a goal, it is important to take the capacity into account.</P>

					<p>To avoid reallocation, you can use <TT CLASs="monofont">reserve()</tt> to ensure a certain capacity before you really need it. In this way, you can ensure that references remain valid as long as the capacity is not exceeded:</p>

					<PRE>
						
    std::vector&lt;int&gt; v;       <I>// create an empty vector</i>
    v.reserve (80);           <i>// reserve memory for</i> 80 <i>elements</I>

					</PRE>

					<p>Another way to avoid reallocation is to initialize a vector with enough elements by passing additional arguments to the constructor. For example, if you pass a numeric value as parameter, it is taken as the starting size of the vector:</p>

					<prE>
						
    std::vector&lt;T&gt; v(5);       <I>// creates a vector and initializes it with five values</I>
                               <I>// (calls five times the default constructor of type</i> T<i>)</i>

					</pre>

					<p>Of course, the type of the elements must provide a default constructor for this ability. But note that for complex types, even if a default constructor is provided, the initialization takes time. If the only reason for initialization is to reserve memory, you should use <tt class="monofont">reserve().</tt></p>

					<p>The concept of capacity for vectors is similar to that for strings (see <a href="0201379260_snode91.html#15">Section 11.2.5</A>), with one big difference: Unlike strings, it is not possible to call <TT ClASs="monofont">reserve()</TT> for vectors to shrink the capacity. Calling <tT CLASS="monofont">reserve()</tt> with an argument that is less than the current capacity is a no-op. Furthermore, how to reach an optimal performance regarding speed and memory usage is implementation defined. Thus, implementations might increase capacity in larger steps. In fact, to avoid internal fragmentation, many implementations allocate a whole block of memory (such as 2K) the first time you insert anything if you don't call <tt CLASs="monofont">reserve()</tt> first yourself. This can waste Jots of memory if you have many vectors with only a few small elements.</p>

					<P>Because the capacity of vectors never shrinks, it is guaranteed that references, pointers, and iterators remain valid even when elements are deleted or changed, provided they refer to a position before the manipulated elements. However, insertions may invalidate references, pointers, and iterators.</P>

					<P>There is a way to shrink the capacity indirectly: Swapping the contents with another vector swaps the capacity. The following function shrinks the capacity while preserving the elements:</P>

					<pre>
						
    template &lt;class T&gt;
    void shrinkCapacity(std::vector&lt;T&gt;&amp; v)
    {
         std::vector&lt;T&gt; tmp(v);    <i>// copy elements into a new vector</I>
         v.swap(tmp);              <I>// swap internal vector data</I>
    }

					</Pre>

					<p>You can even shrink the capacity without calling this function by calling the following statement<font size="1"><sup><a href="#FOOTNOTE-6">[6]</a></sUP></FONT>
:</p>
<BLoCKqUOTE><FOnt siZE="1">
<P Class="footnote">
<SUP><A name="FOOTNOTE-6">[6]</A></SUP>
You (or your compiler) might consider this statement as being incorrect because it calls a nonconstant member function for a temporary value. However, standard C++ allows you to call a nonconstant member function for temporary values.</p>
</font></blockquote>

					<pre>
						
   <i>//shrink capacity of vector</i> v <i>for type</I> T
   std::vector&lt;T&gt;(v).swap(v);

					</PRE>

					<P>However, note that after <Tt CLaSS="monofont">swap(),</tT> all references, pointers, and iterators swap their containers. They still refer to the elements to which they referred on entry. Thus, <TT CLAss="monofont">shrinkCapacity()</tt> invalidates all references, pointers, and iterators.</P>

				
			
			<A NAme="7"></a><h4>6.2.2
Vector Operations</H4>
				<H5>Create, Copy, and Destroy Operations</H5>
					<P><a href="0201379260_snode49.html#9">Table 6.2</A> lists the constructors and destructors for vectors. You can create vectors with and without elements for initialization. If you pass only the size, the elements are created with their default constructor. Note that an explicit call of the default constructor also initializes fundamental types such as <TT class="monofont">int</tt> with zero (this language feature is covered on page 14). See <a href="0201379260_snode48.html#2">Section 6.1.2</a>, for some remarks about possible initialization sources.</p>

					<a name="9"></a><p><TABLE BoRDeR="1" CeLLSPACing="0" cELLPaddiNG="1" WIdth="100%">
<cAPTIon><h5>Table 6.2. Constructors and Destructors of Vectors</h5></caption><colgroup alIGN="left" SPAn="2">
<TR vALiGN="top">
<TH>
<FOnt siZE="2"><B>Operation</B>
									</font></TH>
<TH>
<font SIZE="2"><b>Effect</b>
									</font></th>
</tr>
<tr valign="top">
<td>
<fONT SIZe="2"><TT cLAsS="monofont">vector&lt;Elem&gt; c</TT>
									</FONt></td>
<tD>
<FONt sizE="2">Creates an empty vector without any elements</FONt></td>
</tR>
<TR Valign="top">
<td>
<font size="2"><tt clasS="monofont">vector&lt;Elem&gt; c1(c2)</TT>
									</FONt></TD>
<tD>
<FoNT SIZE="2">Creates a copy of another vector of the same type (all elements are copied)</font></TD>
</TR>
<tr vaLIGN="top">
<td>
<foNT SIze="2"><tt class="monofont">vector&lt;Elem&gt; c(n)</tt>
									</font></td>
<td>
<foNT SIZE="2">Creates a vector with <tT ClASs="monofont">n</TT> elements that are created by the default constructor
</FONT></td>
</tr>
<TR VAlign="top">
<TD>
<FOnt siZE="2"><TT class="monofont">vector&lt;Elem&gt; c(n,elem)</tt>
									</font></td>
<td>
<font siZE="2">Creates a vector initialized with <TT CLaSS="monofont">n</tT> copies of element <Tt CLASS="monofont">elem</Tt>
									</fonT></TD>
</Tr>
<tr vALIGn="top">
<td>
<fONT Size="2"><tt class="monofont">vector&lt;Elem&gt; c(beg,end)</tt>
									</font></td>
<td>
<fONT SIZe="2">Creates a vector initialized with the elements of the range <TT cLAsS="monofont">[beg,end</TT>)
</FONt></td>
</tR>
<TR ValigN="top">
<TD>
<Font sIZE="2"><Tt class="monofont">c.<sup>~</sup>vector&lt;Elem&gt;()</tt>
									</font></td>
<tD>
<FONT SiZE="2">Destroys all elements and frees the memory</fONt></TD>
</TR>
</COlgroUP>
</TAble></p>

				
				<H5>Nonmodifying Operations</H5>
					<P><A href="0201379260_snode49.html#12">Table 6.3</A> lists all nonmodifying operations of vectors.<FONt size="1"><sup><a href="#FOOTNOTE-7">[7]</a></sup></font>
 See additional remarks in <A href="0201379260_snode48.html#2">Section 6.1.2</A>, and <a href="0201379260_snode49.html#4">Section 6.2.1</A>.</p>
<BLOCKQuote><FONT size="1">
<P CLAss="footnote">
<suP><A NAme="FOOTNOTE-7">[7]</a></sup>
<tt class="monofont">reserve()</tt> manipulates the vector because it invalidates references, pointers, and iterators to elements. However, it is mentioned here because it does not manipulate the logical contents of the container.</p>
</font></bLOCKQUoTE>

					<a NAmE="12"></A><P><TABle boRDER="1" cellSPACing="0" cELLPadding="1" width="100%">
<caption><h5>Table 6.3. Nonmodifying Operations of Vectors</h5></cAPTION><cOLgROuP ALIGN="left" span="2">
<TR VAlign="top">
<TH>
<FOnt siZE="2"><B>Operation</B>
									</font></th>
<th>
<font size="2"><b>Effect</b>
									</fonT></TH>
</TR>
<Tr VAlIGn="top">
<TD>
<FONT size="2"><TT CLass="monofont">c.size()</tT>
									</FONt></td>
<tD>
<FONt size="2">Returns the actual number of elements</font></td>
</tr>
<tr valign="top">
<TD>
<FONT sIZe="2"><TT cLASS="monofont">c.empty()</TT>
									</font></TD>
<TD>
<font SIZE="2">Returns whether the container is <tt clASS="monofont">empty</Tt> (equivalent to <tt class="monofont">size()==0,</tt> but might be faster)
</font></td>
</tr>
<tr vALIGN="top">
<Td>
<FOnT SiZE="2"><TT CLass="monofont">c.max_size()</tT>
									</FONt></td>
<tD>
<FONt sizE="2">Returns the maximum number of elements possible</FONt></td>
</tr>
<tr valign="top">
<td>
<font siZE="2"><TT CLaSS="monofont">capacity()</tT>
									</FoNT></TD>
<TD>
<font SIZE="2">Returns the maximum possible number of elements without reallocation</font></TD>
</TR>
<tr vaLIGN="top">
<td>
<font size="2"><tt class="monofont">reserve()</tt>
									</foNT></TD>
<TD>
<fONt SIzE="2">Enlarges capacity, if not enough yet<SUP><A Href="#FOOTNOTE-7">[7]</a></SUP>
									</Font></tD>
</TR>
<Tr valIGN="top">
<Td>
<font size="2"><tt class="monofont">c1 == c2</tt>
									</fonT></TD>
<TD>
<FoNT sIZe="2">Returns whether <TT CLASs="monofont">c1</tt> is equal to <tT CLAss="monofont">c2</tt>
									</FONT></td>
</tr>
<TR VAlign="top">
<td>
<font size="2"><tt class="monofont">c1 != c2</TT>
									</FONT></tD>
<Td>
<FOnT SIZE="2">Returns whether <Tt claSS="monofont">c1</TT> is not equal to <tt clASS="monofont">c2</Tt> (equivalent to <tt cLASS="monofont">!</tt>
										<tt class="monofont">(</tt><tt class="monofont">c1==c2)</tt>)
</fONT></TD>
</Tr>
<TR vALiGN="top">
<TD>
<FOnt siZE="2"><TT clasS="monofont">c1 &lt; c2</TT>
									</Font></tD>
<TD>
<Font size="2">Returns whether <tt class="monofont">c1</tt> is less than <tt claSS="monofont">c2</TT>
									</FOnT></Td>
</TR>
<tR VALIGn="top">
<td>
<fONT Size="2"><tT CLAss="monofont">c1 &gt; c2</tt>
									</FONT></td>
<td>
<font size="2">Returns whether <tt class="monofont">c1</tt> is greater than <TT CLASs="monofont">c2</TT> (equivalent to <tT ClASS="monofont">c2&lt;c1</TT>)
</Font></tD>
</TR>
<Tr valIGN="top">
<Td>
<fonT SIZe="2"><tt class="monofont">c1 &lt;= c2</tt>
									</font></td>
<td>
<fonT SIZE="2">Returns whether <Tt CLaSS="monofont">c1</tT> is less than or equal to <TT CLAss="monofont">c2</tt> (equivalent to <TT CLass="monofont">!</tT>
										<TT Class="monofont">(</TT><TT class="monofont">c2&lt;c1)</tt>)
</font></td>
</tr>
<tr valiGN="top">
<TD>
<FOnT SiZE="2"><tT CLASS="monofont">c1 &gt;= c2</tt>
									</foNT></TD>
<td>
<foNT SIze="2">Returns whether <tt CLASs="monofont">c1</tt> is greater than or equal to <tt class="monofont">c2</tt> (equivalent to <tt class="monofont">! (</tt><TT CLASs="monofont">c1&lt;c2)</TT>)
</fONt></TD>
</TR>
</COlgroUP>
</TAble></p>

				
				<H5>Assignments</H5>
					<A Name="14"></a><P><TABle border="1" cellspacing="0" ceLLPADDiNG="1" wIDtH="100%">
<CAPTIon><h5>Table 6.4. Assignment Operations of Vectors</h5></CAPTion><cOLGRoup aLIGN="left" span="2">
<tr valign="top">
<th>
<font sizE="2"><B>Operation</B>
									</FONt></TH>
<tH>
<FoNT SIZE="2"><b>Effect</b>
									</foNT></TH>
</tr>
<tr VALIgn="top">
<td>
<FONT size="2"><tt class="monofont">c1 = c2</tt>
									</font></td>
<td>
<FONT SIzE="2">Assigns all elements of <Tt CLaSS="monofont">c2</TT> to <TT clasS="monofont">c1</TT>
									</Font></tD>
</TR>
<Tr valIGN="top">
<Td>
<font size="2"><tt class="monofont">c.assign(n,elem)</tt>
									</fonT></TD>
<TD>
<FoNT sIZe="2">Assigns <TT CLASs="monofont">n</tt> copies of element <tT CLAss="monofont">elem</tt>
									</FONT></td>
</tr>
<TR VAlign="top">
<td>
<font size="2"><tt class="monofont">c.assign(beg,end)</TT>
									</FONT></tD>
<Td>
<FOnT SIZE="2">Assigns the elements of the range <Tt claSS="monofont">[beg,end)</TT>
									</font></TD>
</TR>
<tr vaLIGN="top">
<td>
<font size="2"><tt class="monofont">c1.swap(c2)</tt>
									</foNT></TD>
<TD>
<fONt SIzE="2">Swaps the data of <TT CLAss="monofont">c1</tt> and <TT CLass="monofont">c2</tT>
									</FONt></td>
</tR>
<TR Valign="top">
<td>
<font size="2"><tt clasS="monofont">swap(c1,c2)</TT>
									</FONt></TD>
<tD>
<FoNT SIZE="2">Same (as global function)</font></TD>
</TR>
</colgROUP>
</tablE></P>

					<P><A href="0201379260_snode49.html#14">Table 6.4</a> lists the ways to assign new elements while removing all ordinary elements. The set of <tt class="monofont">assign()</tt> functions matches the set of constructors. You can use different sources for assignments (containers, arrays, standard input) similar to those described for constructors on page 144. All assignment operations call the default constructor, copy constructor, assignment operator, and/or destructor of the element type, depending on how the number of elements changes. For example:</p>

					<pre>
						
    std::list&lt;Elem&gt; l;
    std::vector&lt;Elem&gt; coll;
    ...
    <i>//make</i> coll <i>be a copy of the contents of</I> l
    coll.assign(l.begin(),l.end());

					</PRE>

				
				<H5>Element Access</H5>
					<p><A href="0201379260_snode49.html#16">Table 6.5</a> shows all vector operations for direct element access. As usual in C and C++, the first element has index <TT CLASs="monofont">0</tt> and the last element has index <tT CLAss="monofont">size()-1.</tt> Thus, the <I>n</I>th element has index <I>n</I>-1. For nonconstant vectors, these operations return a reference to the element. Thus you could modify an element by using one of these operations (provided it is not forbidden for other reasons).</p>

					<a naME="16"></A><P><table border="1" cellspacinG="0" CELLPaDDiNG="1" wIDTH="100%">
<CAptioN><H5>Table 6.5. Direct Element Access of Vectors</H5></CaptiON><COlgroUP ALign="left" span="2">
<tr valign="top">
<th>
<font SIZE="2"><B>Operation</B>
									</fONt></TH>
<tH>
<FONT Size="2"><b>Effect</B>
									</FONt></th>
</tR>
<TR ValigN="top">
<TD>
<Font size="2"><tt class="monofont">c.at(idx)</tt>
									</font></tD>
<TD>
<FONt SIzE="2">Returns the element with index <Tt CLASS="monofont">idx</Tt> (throws range error exception if <tt cLASS="monofont">idx</tt> is out of range)
</foNT></TD>
</tr>
<tr VALIgn="top">
<td>
<font size="2"><tt class="monofont">c[idx]</tt>
									</FONT></TD>
<tD>
<FoNT sIZE="2">Returns the element with index <TT Class="monofont">idx</TT> (<I>no</I> range checking)
</font></TD>
</TR>
<tr vaLIGN="top">
<td>
<font size="2"><tt class="monofont">c.front()</tt>
									</foNT></TD>
<TD>
<fONt SIzE="2">Returns the first element (<I>no</I> check whether a first element exists)
</FONt></td>
</tR>
<TR ValigN="top">
<TD>
<Font sIZE="2"><Tt class="monofont">c.back()</tt>
									</font></td>
<td>
<font sIZE="2">Returns the last element (<I>no</I> check whether a last element exists)
</FoNT></tD>
</Tr>
</COLGROup>
</taBLE></P>

					<p>The most important issue for the caller is whether these operations perform range checking. Only <tt cLASS="monofont">at()</tt> performs range checking. If the index is out of range, it throws an <tt CLASs="monofont">out_of_range</tt> exception (see <a href="0201379260_snode20.html">Section 3.3</a>). All other functions do <i>not</i> check. A range error results in undefined behavior. Calling operator <tt class="monofont">[],</tt>
						<tT CLASS="monofont">front(),</tT> and <Tt CLaSS="monofont">back()</TT> for an empty container always results in undefined behavior:</P>

					<Pre>
						
   std::vector&lt;Elem&gt; coll;          <i>// empty!</i>

   coll [5] = elem;                 <I>// RUNTIME ERROR</I> ? <I>undefined behavior</I>
   std::cout &lt;&lt; coll. front ();     <i>// RUNTIME ERROR</i> ? <i>undefined behavior</i>

					</PRE>

					<P>So, you must ensure that the index for operator <tt clASS="monofont">[]</Tt> is valid and the container is not empty when either <tt class="monofont">front()</tt> or <tt class="monofont">back()</tt> is called:</p>

					<pRE>
						
    std::vector&lt;Elem&gt; coll;         <I>// empty!</I>

    if (coll.size() &gt; 5) {
        coll [5] = elem;            <I>// OK</I>
    }
    if (!coll.empty()) {
        cout &lt;&lt; coll.front();       <i>// OK</I>
    }
    coll.at(5) = elem;              <I>// throws</i> out_of_range <I>exception</I>

					</pRE>

				
				<H5>Iterator Functions</H5>
					<P>Vectors provide the usual operators to get iterators (<A href="0201379260_snode49.html#18">Table 6.6</A>). Vector iterators are random access iterators (see <A href="0201379260_snode60.html">Section 7.2</a>, for a discussion of iterator categories). Thus, in principle you could use all algorithms of the STL.</p>

					<A NAMe="18"></a><p><tABLE border="1" cellspacing="0" cellPADDINg="1" WIdTH="100%">
<cAPTION><h5>Table 6.6. Iterator Operations of Vectors</h5></caPTIOn><colGROUp aliGN="left" SPan="2">
<tr valign="top">
<th>
<font size="2"><b>Operation</B>
									</FONT></Th>
<TH>
<fONt SIZE="2"><B>Effect</B>
									</font></TH>
</TR>
<tr vaLIGN="top">
<td>
<foNT SIze="2"><tt class="monofont">c.begin()</tt>
									</font></td>
<td>
<foNT SIZE="2">Returns a random access iterator for the first element</fONt></TD>
</tR>
<TR VALign="top">
<tD>
<FONt sizE="2"><TT Class="monofont">c.end()</TT>
									</FOnt></td>
<td>
<font size="2">Returns a random access iterator for the position after the last element</font></td>
</tR>
<TR VALiGN="top">
<tD>
<FoNT SIZE="2"><tt clASS="monofont">c.rbegin()</Tt>
									</fonT></TD>
<Td>
<fonT SIZe="2">Returns a reverse iterator for the first element of a reverse iteration</font></td>
</tr>
<tr valign="top">
<td>
<foNT SIZE="2"><tT ClASs="monofont">c.rend()</TT>
									</FONT></td>
<td>
<FONT size="2">Returns a reverse iterator for the position after the last element of a reverse iteration</FONT></td>
</tr>
</COLGroup>
</table></p>

					<p>The exact type of these iterators is implementation defined. However, for vectors they are often ordinary pointers. An ordinary pointer is a random access iterator, and because the internal structure of a vector is usually an array, it has the correct behavior. However, you can't count on it. For example, if a safe version of the STL that checks range errors and other potential problems is used, the iterator type is usually an auxiliary class. See <a href="0201379260_snode60.html#14">Section 7.2.6</a>, for a look at the nasty difference between iterators implemented as pointers and iterators implemented as classes.</p>

					<p>Iterators remain valid until an element with a smaller index gets inserted or removed, or reallocation occurs and capacity changes (see <a href="0201379260_snode49.html#4">Section 6.2.1</A>).</P>

				
				<H5>Inserting and Removing Elements</h5>
					<P><A href="0201379260_snode49.html#20">Table 6.7</A> shows the operations provided for vectors to insert or to remove elements. As usual by using the STL, you must ensure that the arguments are valid. Iterators must refer to valid positions, the beginning of a range must have a position that is not behind the end, and you must not try to remove an element from an empty container.</P>

					<P>Regarding performance, you should consider that inserting and removing happens faster when</P>

					<UL>
<li><p>Elements are inserted or removed at the end</p>
</LI>
<LI><p>The capacity is large enough on entry</p>
</li>
<LI><P>Multiple elements are inserted by a single call rather than by multiple calls</P>

						</li>
</ul>
					<P>Inserting or removing elements invalidates references, pointers, and iterators that refer to the following elements. If an insertion causes reallocation, it invalidates all references, iterators, and pointers.</P>

					<A Name="20"></a><p><table border="1" cellsPACING="0" cELlPAdDING="1" WIdth="100%">
<cAPTIon><h5>Table 6.7. Insert and Remove Operations of Vectors</h5></CAPTion><cOLGRoup align="left" span="2">
<tr valign="top">
<tH>
<FONT SiZE="2"><b>Operation</B>
									</FoNT></TH>
<TH>
<font SIZE="2"><b>Effect</b>
									</foNT></TH>
</tr>
<tr VALIgn="top">
<td>
<font size="2"><tt class="monofont">c.insert(pos,elem)</tt>
									</FONT></TD>
<tD>
<FoNT sIZE="2">Inserts at iterator position <TT Class="monofont">pos</TT> a copy of <TT clasS="monofont">elem</TT> and returns the position of the new element
</Font></tD>
</TR>
<Tr valign="top">
<td>
<font size="2"><tt clASS="monofont">c.insert(pos,n,elem)</TT>
									</FoNT></tD>
<Td>
<FONT SIze="2">Inserts at iterator position <tt CLASs="monofont">pos</tt>
										<tT CLAss="monofont">n</tt> copies of <TT CLass="monofont">elem</tt> (returns nothing)
</font></td>
</tr>
<tr valign="top">
<TD>
<FONT sIZe="2"><TT cLASS="monofont">c.insert(pos,beg,end)</TT>
									</font></TD>
<TD>
<font SIZE="2">Inserts at iterator position <tt clASS="monofont">pos</Tt> a copy of all elements of the range <tt class="monofont">[beg,end</tt>) (returns nothing)
</font></td>
</tr>
<tr vALIGN="top">
<Td>
<FOnT SiZE="2"><TT CLass="monofont">c.push_back(elem)</tT>
									</FONt></td>
<tD>
<FONt sizE="2">Appends a copy of <TT Class="monofont">elem</tt> at the end
</font></td>
</tr>
<tr valigN="top">
<TD>
<FONt SIzE="2"><Tt CLASS="monofont">c.pop_back()</Tt>
									</fonT></TD>
<Td>
<fonT SIZe="2">Removes the last element (does not return it)</fonT></TD>
</Tr>
<tr valign="top">
<td>
<font size="2"><tt CLASS="monofont">c.erase(pos)</Tt>
									</FOnT></Td>
<TD>
<FONT size="2">Removes the element at iterator position <TT CLass="monofont">pos</tT> and returns the position of the next element
</FONt></td>
</tR>
<TR Valign="top">
<td>
<font size="2"><tt clasS="monofont">c.erase(beg,end)</TT>
									</FONt></TD>
<tD>
<FoNT SIZE="2">Removes all elements of the range <tt clASS="monofont">[beg,end</Tt>) and returns the position of the next element
</fonT></TD>
</Tr>
<tr vALIGn="top">
<td>
<font size="2"><tt class="monofont">c.resize(num)</tt>
									</fONT></TD>
<Td>
<FOnT SiZE="2">Changes the number of elements to num (if <TT CLass="monofont">size()</tT> grows, new elements are created by their default constructor)
</FONt></td>
</tR>
<TR ValigN="top">
<TD>
<Font size="2"><tt class="monofont">c.resize(num,elem)</tt>
									</font></tD>
<TD>
<FONt SIzE="2">Changes the number of elements to num (if <Tt CLASS="monofont">size()</Tt> grows, new elements are copies of <tt cLASS="monofont">elem</tt>)
</foNT></TD>
</tr>
<tr VALIgn="top">
<td>
<font size="2"><tt class="monofont">c.clear()</tt>
									</FONT></TD>
<tD>
<FoNT sIZE="2">Removes all elements (makes the container empty)</FONt></td>
</tR>
</COLgrouP>
</TABle></p>

					<p>Vectors provide no operation to remove elements directly that have a certain value. You must use an algorithm to do this. For example, the following statement removes all elements that have the value <TT CLass="monofont">val:</tt></p>

					<pre>
						
   std::vector&lt;Elem&gt; coll;
   ...
   <i>//remove all elements with value</i> val
   coll.erase(remove(coll.begin(),coll.end(),
                     val),
              coll.end());

					</pre>

					<p>This statement is explained in <a href="0201379260_snode39.html#1">Section 5.6.1</a>.</P>

					<P>To remove only the first element that has a certain value, you must use the following statements:</P>

					<PRE>
						
   std::vector&lt;Elem&gt; coll;
   ...
   <i>//remove first element with value</I> val
   std::vector&lt;Elem&gt;::iterator pos;
   pos = find(coll.begin(),coll.end(),
              val);
   if (pos != coll.end()) {
       coll.erase(pos);
   }

					</PrE>

				
			
			<A nAME="21"></A><H4>6.2.3
Using Vectors as Ordinary Arrays</H4>
				<p>The C++ standard library does not state clearly whether the elements of a vector are required to be in contiguous memory. However, it is the intention that this is guaranteed and it will be fixed due to a defect report. Thus, you can expect that for any valid index <tt cLASS="monofont">i</tt> in vector <tt CLASs="monofont">v,</tt> the following yields <tT CLAss="monofont">true:</tt></p>

				<pre>
					
   &amp;v[i] == &amp;v[0] + i

				</pre>

				<p>This guarantee has some important consequences. It simply means that you can use a vector in all cases in which you could use a dynamic array. For example, you can use a vector to hold data of ordinary C-strings of type <tt class="monofont">char*</tt> or <TT CLASs="monofont">const char*:</TT></p>

				<PRe>
					
   std::vector&lt;char&gt; v;            <I>// create vector as dynamic array of</I> char<I>s</I>

   v.resize(41);                   <I>// make room for 41 characters (including '</I>\0<i>'</i><i>)</i>
   strcpy(&amp;v[0], "hello, world");  <I>// copy a C-string into the vector</I>
   printf("%s\n", &amp;v[0]);          <I>// print contents of the vector as C-string</I>

				</pre>

				<p>Of course, you have to be careful when you use a vector in this way (like you always have to be careful when using dynamic arrays). For example, you have to ensure that the size of the vector is big enough to copy some data into it and that you have an <TT CLass="monofont">'\0'</tT> element at the end if you use the contents as a C-string. However, this example shows that whenever you need an array of type <TT Class="monofont">T</tt> for any reason (such as for an existing C library) you can use a <tt class="monofont">vector&lt;T&gt;</tt> and pass the address of the first element.</p>

				<p>Note that you must not pass an iterator as the address of the first element. Iterators of vectors have an implementation-specific type, which may be totally different from an ordinary pointer:</p>

				<pre>
					
   printf("%s\n", v.begin());        <I>// ERROR</I> <I>(might work, but not portable)</I>
   printf("%s\n", &amp;v[0]);            <I>// OK</I>

				</pRE>

			
			<h4>6.2.4
Exception Handling</H4>
				<P>Vectors provide only minimal support for logical error checking. The only member function for which the standard requires that it may throw an exception is <tT CLASS="monofont">at(),</tt> which is the safe version of the subscript operator (see page 152). In addition, the standard requires that only the usual standard exceptions may occur, such as <tt CLASs="monofont">bad_alloc</tt> for a lack of memory or exceptions of user-defined operations.</p>

				<P>If functions called by a vector (functions for the element type or functions that are user supplied) throw exceptions, the C++ standard library guarantees the following:</P>

				<OL type="1" STARt="restarts">
<li><p>If an element gets inserted with <tt class="monofont">push_back()</tt> and an exception occurs, this function has no effect.</p>
</li>
<li><p><tt CLASS="monofont">insert()</Tt> either succeeds or has no effect if the copy operations (copy constructor and assignment operator) of the elements do not throw.</P>
</Li>
<LI><p><TT CLASs="monofont">pop_back()</tt> does not throw any exceptions.</p>
</LI>
<LI><p><tt cLASS="monofont">erase()</tt> and <tt CLASs="monofont">clear</tt> do not throw if the copy operations (copy constructor and assignment operator) of the elements do not throw.</p>
</li>
<li><p><tt class="monofont">swap()</tt> does not throw.</p>
</li>
<LI><P>If elements are used that never throw exceptions on copy operations (copy constructor and assignment operator), every operation is either successful or has no effect. Such elements might be "plain old data" (POD). POD describes types that use no special C++ feature. For example, every ordinary C structure is POD.</P>

					</LI>
</oL>

				<P>All these guarantees are based on the requirements that destructors don't throw. See <a href="0201379260_snode44.html#3">Section 5.11.2</A>, for a general discussion of exceptions handling in the STL and <A href="0201379260_snode57.html#20">Section 6.10.10</a>, for a list of all container operations that give special guarantees in face of exceptions.</p>

			
			<h4>6.2.5
Examples of Using Vectors</H4>
				<P>The following example shows a simple usage of vectors:</P>

				<Pre>
					
   <i>// cont/vector1.cpp</i>

   #include &lt;iostream&gt;
   #include &lt;vector&gt;
   #include &lt;string&gt;
   #include &lt;algorithm&gt;
   using namespace std;

   int main()
   {

       <I>//create empty vector for strings</I>
       vector&lt;string&gt; sentence;

       <I>//reserve memory for five elements to avoid reallocation</I>
       sentence.reserve(5);

       <i>//append some elements</i>
       sentence.push_back("Hello,");
       sentence.push_back("how");
       sentence.push_back("are");
       sentence.push_back("you");
       sentence.push_back("?");

       <i>//print elements separated with spaces</i>
       copy (sentence.begin(), sentence.end(),
             ostream_iterator&lt;string&gt;(cout," "));
       cout &lt;&lt; endl;

       <I>//print ''technical data''</I>
       cout &lt;&lt; " max_size(): " &lt;&lt; sentence.max_size() &lt;&lt; endl;
       cout &lt;&lt; " size():     " &lt;&lt; sentence.size()     &lt;&lt; endl;
       cout &lt;&lt; " capacity(): " &lt;&lt; sentence.capacity() &lt;&lt; endl;

       <I>//swap second and fourth element</I>
       swap (sentence[1], sentence [3]);

       <i>//insert element</i> "always" <i>before element</i> "?"
       sentence.insert (find(sentence.begin(),sentence.end(),"?"),
                        "always");

       <i>//assign</i> "!" <i>to the last element</i>
       sentence.back() = "!";

       <i>//print elements separated with spaces</i>
       copy (sentence.begin(), sentence.end(),
             ostream_iterator&lt;string&gt;(cout," "));
       cout &lt;&lt; endl;

       <i>//print "technical data" again</i>
       cout &lt;&lt; " max_size(): " &lt;&lt; sentence.max_size() &lt;&lt; endl;
       cout &lt;&lt; " size():     " &lt;&lt; sentence.size()     &lt;&lt; endl;
       cout &lt;&lt; " capacity(): " &lt;&lt; sentence.capacity() &lt;&lt; endl;

   }

				</pre>

				<p>The output of the program might look like this:</p>

				<pre>
					
   Hello, how are you ?
     max_size(): 268435455
     size():     5
     capacity(): 5
   Hello, you are how always !
     max_size(): 268435455
     size():     6
     capacity(): 10

				</pRE>

				<P>Note my use of the word "might." The values of <TT ClASs="monofont">max_size()</TT> and <tT CLASS="monofont">capacity()</tt> are implementation defined. Here, for example, you can see that the implementation doubles the capacity if the capacity no longer fits.</p>

			
			<a NAME="24"></a><h4>6.2.6
Class <tt CLASs="monofont">vector&lt;bool&gt;</tt></h4>
				<P>For Boolean elements of a vector, the C++ standard library provides a specialization of <TT Class="monofont">vector.</tt> The goal is to have a version that is optimized to use less size than a usual implementation of <tt class="monofont">vector</tt> for type <tt clasS="monofont">bool.</TT> Such a usual implementation would reserve at least 1 byte for each element. The <TT ClASs="monofont">vector&lt;bool&gt;</TT> specialization usually uses internally only 1 bit for an element, so it is typically eight times smaller. Note that such an optimization also has a snag: In C++, the smallest addressable value must have a size of at least 1 byte. Thus, such a specialization of a vector needs special handling for references and iterators.</p>

				<P>As a result, a <TT CLAss="monofont">vector&lt;bool&gt;</tt> does not meet all requirements of other vectors (for example, a <TT CLass="monofont">vector&lt;bool&gt;::</tT>reference is not a true lvalue and <TT Class="monofont">vector&lt;bool&gt;::iterator</TT> is not a random access iterator). Therefore, template code might work for vectors of any type except <TT class="monofont">bool.</tt> In addition, <tt class="monofont">vector&lt;bool&gt;</tt> might perform slower than normal implementations because element operations have to be transformed into bit operations. However, how <tt claSS="monofont">vector&lt;bool&gt;</TT> is implemented is implementation specific. Thus, the performance (speed and memory) might differ.</P>

				<P>Note that class <tT ClASs="monofont">vector&lt;bool&gt;</TT> is more than a specialization of <TT CLass="monofont">vector&lt;&gt;</tT> for <TT Class="monofont">bool.</TT> It also provides some special bit operations. You can handle bits or flags in a more convenient way.</P>

				<P><tt clASS="monofont">vector&lt;bool&gt;</Tt> has a dynamic size, so you can consider it a bitfield with dynamic size. Thus, you can add and remove bits. If you need a bitfield with static size, you should use <tt class="monofont">bitset</tt> rather than a <tt class="monofont">vector&lt;bool&gt;.</tt> Class <tt CLASS="monofont">bitset</Tt> is covered in <A href="0201379260_snode87.html">Section 10.4</a>.</P>

				<A NAME="25"></a><p><taBLE BordeR="1" CELlspaCING="0" cellpadding="1" width="100%">
<captiON><H5>Table 6.8. Special Operations of <TT ClASs="monofont">vector&lt;bool&gt;</TT></h5></CAPTIOn><colGROUp aliGN="left" SPan="2">
<tr VALIgn="top">
<th>
<font size="2"><b>Operation</b>
								</font></th>
<tH>
<FONT SiZE="2"><b>Effect</B>
								</FoNT></TH>
</TR>
<tr vaLIGN="top">
<td>
<foNT SIze="2"><tt CLASs="monofont">c.flip()</tt>
								</font></td>
<td>
<font size="2">Negates all Boolean elements (complement of all bits)</foNT></TD>
</TR>
<tR VaLIgN="top">
<TD>
<FONt sizE="2"><TT Class="monofont">m[idx].flip()</TT>
								</FOnt></td>
<TD>
<FOnt size="2">Negates the Boolean element with index <tt class="monofont">idx</tt> (complement of a single bit)
</font></td>
</TR>
<TR VAlIGn="top">
<TD>
<fONT SIZe="2"><tt cLASS="monofont">m[idx] =</tt>
									<i>val</i>
								</FONT></td>
<td>
<FONT size="2">Assigns <i>val</i> to the Boolean element with index <tt class="monofont">idx</tt> (assignment to a single bit)
</font></td>
</TR>
<TR VAlIGn="top">
<TD>
<fONT SIZe="2"><tt cLASS="monofont">m[idx1] = m[idx2]</tt>
								</foNT></TD>
<td>
<foNT SIze="2">Assigns the value of the element with index <tt class="monofont">idx2</tt> to the element with index <tt class="monofont">idx1</tt>
								</fONT></TD>
</Tr>
</COlGRoUP>
</TABLe></p>

				<p>The additional operations of <tT CLAss="monofont">vector&lt;bool&gt;</tt> are shown in <A href="0201379260_snode49.html#25">Table 6.8</a>. The operation <tt CLASs="monofont">flip(),</tt> which processes the complement, can be called for all bits and a single bit of the vector. Note that you can call <tt class="monofont">flip()</tt> for a single Boolean element. This is surprising, because you might expect that the subscript operator returns <tt class="monofont">bool</tt> and that calling <TT CLASs="monofont">flip()</TT> for such a fundamental type is not possible. Here the class <tT ClASS="monofont">vector&lt;bool&gt;</TT> uses a common trick, called a <I>proxy</i><fonT SIZe="1"><sup><A HREf="#FOOTNOTE-8">[8]</a></suP></FONt>
: For <tt class="monofont">vector&lt;bool&gt;,</tt> the return type of the subscript operator (and other operators that return an element) is an auxiliary class. If you need the return value to be <tt class="monofont">bool,</tt> an automatic type conversion is used. For other operations, the member functions are provided. The relevant part of the declaration of <tt CLASS="monofont">vector&lt;bool&gt;</Tt> looks like this:</P>
<BlOCkQUOTE><Font sIZE="1">
<P clasS="footnote">
<SUP><a namE="FOOTNOTE-8">[8]</A></SUp>
A proxy allows you to keep control where usually no control is provided. This is often used to get more security. In this case, it maintains control to allow certain operations, although the return value in principle behaves as <tt class="monofont">bool.</tt></p>
</font></blockqUOTE>

				<PRe>
					
   namespace std {
       class vector&lt;bool&gt; {
         public:
           <I>//auxiliary type for subscript operator</I>
           class reference {
             ...
             public:
               <i>//automatic type conversion to</I> bool
               operator bool() const;

               <I>//assignments</i>
               reference&amp; operator= (const bool);
               reference&amp; operator= (const reference&amp;);

               <I>//bit complement</I>
               void flip();
           }
           ...

           <I>//operations for element access</I>
           <I>//-return type is</I> reference <i>instead of</i> bool
           reference operator[](size_type n);
           reference at(size_type n);
           reference front();
           reference back();
           ...
       };
   }

				</prE>

				<P>As you can see, all member functions for element access return type <TT clasS="monofont">reference.</TT> Thus, you could also use the following statement:</P>

				<pre>
					
   c.front().flip();     <i>// negate first Boolean element</I>
   c.at(5) = c.back();   <I>// assign last element to element with index</I> 5

				</Pre>

				<p>As usual, to avoid undefined behavior, the caller must ensure that the first, last, and sixth elements exist.</p>

				<p>The internal type <tt class="monofont">reference</tt> is only used for nonconstant containers of type <tt class="monofont">vector&lt;bool&gt;.</TT> The constant member functions for element access return ordinary values of type <TT CLaSS="monofont">bool.</tT></P>

			
		</fONT>
 
<table width="100%" border="0" cellspacing="0" cellpadding="0" bgcolor="#CCCCCC">
<td><font color="black" size=1>I l<font color="#FF0000">@</font>ve RuBoard</td>
<td valign="top" class="v2" align="right"><a href="0201379260_snode48.html"><img src="FILES/previous.gif" width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a> <a href="0201379260_snode50.html"><img src="FILES/next.gif" width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a></td></table>
</BODY></HTML>