<HTML><HEAD><META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=iso-8859-1">
<!--SafClassName="docSection1Title"--><!--SafTocEntry="6.5 Sets and Multisets"-->
<LINK REL="stylesheet" href="FILES/sbolM.css">
</HEAD>
<BODY link="#354278" vlink="#000066" alink="#000080" topmargin="0">
<table width="100%" border="0" cellspacing="0" cellpadding="0" bgcolor="#CCCCCC">
<td><font color="black" size=1>I l<font color="#FF0000">@</font>ve RuBoard</td>
<td valign="top" class="v2" align="right"><a href="0201379260_snode51.html"><img src="FILES/previous.gif" width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a> <a href="0201379260_snode53.html"><img src="FILES/next.gif" width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a></td></table>
<FONT><h3>6.5
Sets and Multisets</h3>
			<p>Set and multiset containers sort their elements automatically according to a certain sorting criterion. The difference between the two is that multisets allow duplicates, whereas sets do not (see <a href="0201379260_snode52.html#1">Figure 6.6</a> and the earlier discussion on this topic in <a href="0201379260_cnode32.html">Chapter 5</A>).</P>

			<centER>
				<H5>
<A name="1"></a>Figure 6.6. Sets and Multisets</h5><img border="0" width="500" hEIGHT="181" src="FILES/06fig06.gif" AlT="graphics/06fig06.gif"></CeNTER>

			<P>To use a set or multiset, you must include the header file <Tt claSS="monofont">&lt;set&gt;</TT><font SIZE="1"><sup><a HREF="#FOOTNOTE-14">[14]</a></sup></font>
:</p>
<blockquote><foNT SIZE="1">
<p CLaSS="footnote">
<sUP><A NAMe="FOOTNOTE-14">[14]</a></suP>
In the original STL, the header file for sets was <TT Class="monofont">&lt;set.h&gt;,</TT> and for multisets it was <TT clasS="monofont">&lt;multiset.h&gt;.</TT></P>
</font></blockquote>

			<pre>
				
   #include &lt;set&gt;

			</pre>

			<p>There, the type is defined as a template class inside namespace <TT CLASs="monofont">std:</TT></p>

			<PRe>
				
   namespace std {
       template &lt;class T,
                 class Compare = less&lt;T&gt;,
                 class Allocator = allocator&lt;T&gt; &gt;
       class set;

       template &lt;class T,
                 class Compare = less&lt;T&gt;,
                 class Allocator = allocator&lt;T&gt; &gt;
       class multiset;
   }

			</PRE>

			<P>The elements of a set or multiset may have any type <TT clasS="monofont">T</TT> that is assignable, copyable, and comparable according to the sorting criterion. The optional second template argument defines the sorting criterion. If a special sorting criterion is not passed, the default criterion <Tt claSS="monofont">less</TT> is used. The function object <tt clASS="monofont">less</Tt> sorts the elements by comparing them with operator <tt class="monofont">&lt;</tt> (see page 305 for details about <tt class="monofont">less</tt>).<foNT SIZE="1"><sUP><a HReF="#FOOTNOTE-15">[15]</A></SUP></Font>
 The optional third template parameter defines the memory model (see <a href="0201379260_cnode121.html">Chapter 15</a>). The default memory model is the model <tt cLASS="monofont">allocator,</tt> which is provided by the C++ standard library.<foNT SIze="1"><sup><a href="#FOOTNOTE-16">[16]</a></sup></font>
</p>
<blOCKQUOtE><FoNT sIZE="1">
<P CLass="footnote">
<sUP><A Name="FOOTNOTE-15">[15]</a></SUP>
In systems without support for default template parameters, the second argument typically is mandatory.</P>
</font></BLOCkquote>
<blockquote><font sIZE="1">
<P CLaSS="footnote">
<sUP><a NAME="FOOTNOTE-16">[16]</A></Sup>
In systems without support for default template parameters, the third argument typically is missing.</p>
</fONT></BlockQUOTe>

			<p>The sorting criterion must define "strict weak ordering." Strict weak ordering is defined by the following three properties:</p>

			<oL TYPe="1" start="restarts">
<li><p>It has to be <b>antisymmetric.</b></p>

					<p>This means for operator <tt class="monofont">&lt;:</tT> If <TT CLAsS="monofont">x &lt; y</Tt> is true, then <TT cLASS="monofont">y &lt; x</TT> is false.</p>

					<p>This means for a predicate <tt CLASs="monofont">op():</tt> If <tT CLAss="monofont">op(x,y)</tt> is true, then <TT CLass="monofont">op(y,x)</tt> is false.</p>
</li>
<li><p>It has to be <b>transitive.</b></p>

					<p>This means for operator <tt clasS="monofont">&lt;:</TT> If <TT ClASs="monofont">x &lt; y</TT> is true and <tT CLASS="monofont">y &lt; z</tt> is true, then <tt CLASs="monofont">x &lt; z</tt> is true.</p>

					<P>This means for a predicate <TT Class="monofont">op():</TT> If <TT class="monofont">op(x,y)</tt> is true and <tt class="monofont">op (y,z</tt><tt claSS="monofont">)</TT> is true, then <TT cLAsS="monofont">op(x,z</Tt>) is true.</P>
</LI>
<LI><P>It has to be <b>irreflexive.</b></p>

					<p>This means for operator <TT CLass="monofont">&lt;:x &lt; x</tT> is always false.</P>

					<P>This means for a predicate <Tt claSS="monofont">op(): op(x,x)</TT> is always false.</p>

				</li>
</ol>

			<p>Based on these properties the sorting criterion is also used to check equality. That is, two elements are equal if neither is less than the other (or if both <tt class="monofont">op(x,y)</tt> and <tt clasS="monofont">op(y,x)</TT> are false).</P>

			<H4>6.5.1
Abilities of Sets and Multisets</H4>
				<p>Like all standardized associative container classes, sets and multisets are usually implemented as balanced binary trees (<A href="0201379260_snode52.html#7">Figure 6.7</a>). The standard does not specify this, but it follows from the complexity of set and multiset operations.<FONT SIze="1"><suP><A HRef="#FOOTNOTE-17">[17]</a></sUP></FOnt>
</p>
<bLOCKquote><font size="1">
<p class="footnote">
<suP><A NAME="FOOTNOTE-17">[17]</a></SUp>
In fact, sets and multisets are typically implemented as "red-black trees." Red-black trees are good for both changing the number of elements and searching for elements. They guarantee at most two internal relinks on insertions and that the longest path is at least twice as long as the shortest path to an element.</P>
</FoNT></BLOCkquoTE>

				<CEnter>
					<H5>
<A NAme="7"></a>Figure 6.7. Internal Structure of Sets and Multisets</h5><IMG Border="0" width="500" height="340" src="FILES/06fig07.gif" alT="graphics/06fig07.gif"></CENTEr>

				<P>The major advantage of automatic sorting is that a binary tree performs well when elements with a certain value are searched. In fact, search functions have logarithmic complexity. For example, to search for an element in a set or multiset of 1,000 elements, a tree search (which is performed by the member function) needs, on average, one fiftieth of the comparisons of a linear search (which is performed by the algorithm). See <A href="0201379260_snode15.html">Section 2.3</A>, for more details about complexity.</P>

				<P>However, automatic sorting also imposes an important constraint on sets and multisets: You may <I>not</I> change the value of an element directly because this might compromise the correct order. Therefore, to modify the value of an element, you must remove the element that has the old value and insert a new element that has the new value. The interface reflects this behavior:</P>

				<ul>
<li><P>Sets and multisets don't provide operations for direct element access.</P>
</LI>
<li><p>Indirect access via iterators has the constraint that, from the iterator's point of view, the element value is constant.</p>

					</LI>
</UL>
			
			<a namE="8"></A><H4>6.5.2
Set and Multiset Operations</H4>
				<h5>Create, Copy, and Destroy Operations</h5>
					<p><a href="0201379260_snode52.html#10">Table 6.20</a> lists the constructors and destructors of sets and multisets.</p>

					<p><table bordeR="1" CELLSpACiNG="0" cELLPADding="1" WIDTh="100%">
<colGROUp aliGN="left" SPan="2">
<tr valign="top">
<td>
<font size="2"><b>Operation</B>
									</FONT></Td>
<TD>
<fONt SIZE="2"><B>Effect</B>
									</font></TD>
</TR>
<tr vaLIGN="top">
<td>
<foNT SIze="2"><i>set</i>
										<tt class="monofont">c</tt>
									</font></td>
<td>
<FONT SIzE="2">Creates an empty set/multiset without any elements</FoNT></tD>
</TR>
<TR ValigN="top">
<TD>
<Font sIZE="2"><I>set</i>
										<tt cLASS="monofont">c(op)</tt>
									</font></td>
<td>
<font size="2">Creates an empty set/multiset that uses <tt cLASS="monofont">op</TT> as the sorting criterion
</fONt></TD>
</tR>
<TR VALign="top">
<tD>
<FONt sizE="2"><I>set</I>
										<Tt claSS="monofont">c1(c2)</TT>
									</font></td>
<td>
<font size="2">Creates a copy of another set/multiset of the same type (all elements are copied)</font></tD>
</TR>
<TR VaLIgN="top">
<Td>
<FONT SIze="2"><i>set</i>
										<TT CLass="monofont">c(beg,end)</tT>
									</FONt></td>
<tD>
<FONt size="2">Creates a set/multiset initialized by the elements of the range <tt class="monofont">[beg,end)</tt>
									</font></td>
</tR>
<TR VALiGN="top">
<tD>
<FoNT SIZE="2"><i>set</i>
										<tt CLASs="monofont">c(beg,end, op)</tt>
									</fONT></Td>
<td>
<fONT Size="2">Creates a set/multiset with the sorting criterion op initialized by the elements of the range <tt class="monofont">[beg,end)</tt>
									</font></td>
</tr>
<tR VALIGn="top">
<TD>
<fONt SIZE="2"><TT clasS="monofont">c.<SUP>~</sup></tT><I>set</I>()
</Font></tD>
<TD>
<Font size="2">Destroys all elements and frees the memory</font></td>
</tr>
</colgroUP>
</TABLe></P>

					<P>Here, <b>set</B> may be one of the following:</P>

					<a NAME="10"></A><P><tablE BORder="1" cELLSpaciNG="0" CEllpadding="1" width="100%">
<caption><H5>Table 6.20. Constructors and Destructors of Sets and Multisets</H5></CAPTiON><cOLgROUP ALign="left" sPAN="2">
<Tr valIGN="top">
<Td>
<fonT SIZe="2"><b>set</b>
									</font></td>
<td>
<font size="2"><b><i>Effect</I></B>
									</FONT></tD>
</Tr>
<TR vALIGN="top">
<Td>
<fonT SIZe="2"><tt cLASS="monofont">set&lt;Elem&gt;</tt>
									</foNT></TD>
<td>
<font size="2">A set that sorts with <tt class="monofont">less&lt;&gt;</tt> (operator <tt CLASS="monofont">&lt;</Tt>)
</FOnT></Td>
</TR>
<TR VAlign="top">
<TD>
<FOnt siZE="2"><TT clasS="monofont">set&lt;Elem,0p&gt;</TT>
									</Font></td>
<td>
<font size="2">A set that sorts with <tt clasS="monofont">0p</TT>
									</FONt></TD>
</tR>
<Tr VALIGN="top">
<td>
<foNT SIze="2"><tt CLASs="monofont">multiset&lt;Elem&gt;</tt>
									</fONT></Td>
<td>
<font size="2">A multiset that sorts with <tt class="monofont">less&lt;&gt;</tt> (operator <tT CLASS="monofont">&lt;</tT>)
</FoNT></tD>
</TR>
<TR ValigN="top">
<TD>
<Font sIZE="2"><Tt claSS="monofont">multiset&lt;Elem,0p&gt;</TT>
									</font></td>
<td>
<font size="2">A multiset that sorts with <tt claSS="monofont">0p</TT>
									</FOnT></Td>
</TR>
</cOLGROUp>
</tabLE></P>

					<P>You can define the sorting criterion in two ways:</p>

					<ol tYPE="1" Start="restarts">
<LI><P><B>As a template parameter.</b></p>

							<p>For example<font size="1"><sup><a href="#FOOTNOTE-18">[18]</a></sUP></FONT>
:</p>
<BLoCKqUOTE><FOnt siZE="1">
<P Class="footnote">
<SUP><A name="FOOTNOTE-18">[18]</A></SUP>
Note that you have to put a space between the two <tt class="monofont">"&gt;"</tt> characters. <tt class="monofont">"&gt;&gt;"</tt> would be parsed as shift operator, which would result in a syntax error.</p>
</foNT></BLOCkQUoTE>

							<pRE>
								
      std::set&lt;int,std::greater&lt;int&gt; &gt; coll;

							</PRE>
<P>In this case, the sorting criterion is part of the type. Thus, the type system ensures that only containers with the same sorting criterion can be combined. This is the usual way to specify the sorting criterion. To be more precise, the second parameter is the <i>type</i> of the sorting criterion. The concrete sorting criterion is the function object that gets created with the container. To do this, the constructor of the container calls the default constructor of the type of the sorting criterion. See page 294 for an example that uses a user-defined sorting criterion.</p>
</lI>
<LI><P><b>As a constructor parameter.</b></p>

							<p>In this case, you might have a type for several sorting criteria, and the initial value or state of the sorting criteria might differ. This is useful when processing the sorting criterion at runtime and when sorting criteria are needed that are different but of the same data type. See page 191 for a complete example.</P>

						</LI>
</Ol>

					<p>If no special sorting criterion is passed, the default sorting criterion, function object <tt CLASs="monofont">less&lt;&gt;,</tt> is used, which sorts the elements by using operator <tt class="monofont">&lt;.</tt><font size="1"><sUP><A HREf="#FOOTNOTE-19">[19]</A></SuP></FoNT>
</P>
<BLOckquOTE><Font sIZE="1">
<P clasS="footnote">
<SUP><a name="FOOTNOTE-19">[19]</a></sup>
In systems without support for default template parameters, you typically must always pass the sorting criterion as follows:</p>
</font></blockquOTE>

							<PRE>
								
     set&lt;int,less&lt;int&gt; &gt; coll;

							</pRE>

					<p>Note that the sorting criterion is also used to check for equality of the elements. Thus, when the default sorting criterion is used, the check for equality of two elements looks like this:</P>

					<PrE>
						
   if (! (elem1&lt;elem2 || elem2&lt;elem1))

					</PRE>

					<P>This has three advantages:</P>

					<ol tyPE="1" STart="restarts">
<lI><P>You need to pass only one argument as the sorting criterion.</P>
</Li>
<li><p>You don't have to provide operator <TT CLass="monofont">==</tt> for the element type.</p>
</li>
<li><p>You can have contrary definitions for equality (it doesn't matter if operator <tt class="monofont">==</tt> behaves differently than in the expression). However, this might be a source of confusion.</p>

						</LI>
</OL>

					<P>However, checking for equality in this way takes a bit more time. This is because two comparisons might be necessary to evaluate the previous expression. Note that if the result of the first comparison yields <Tt CLaSS="monofont">true,</tT> the second comparison is not evaluated.</P>

					<P>By now the type name of the container might be a bit complicated and boring, so it is probably a good idea to use a type definition. This definition could be used as a shortcut wherever the container type is needed (this also applies to iterator definitions):</P>

					<PRe>
						
   typedef std::set&lt;int,std::greater&lt;int&gt; &gt; IntSet;
   ...
   IntSet coll;
   IntSet::iterator pos;
</pre>

					<P>The constructor for the beginning and the end of a range could be used to initialize the container with elements from containers that have other types, from arrays, or from the standard input. See <A href="0201379260_snode48.html#2">Section 6.1.2</a>, for details.</p>

				
				<H5>Nonmodifying Operations</H5>
					<P>Sets and multisets provide the usual nonmodifying operations to query the size and to make comparisons (<A href="0201379260_snode52.html#14">Table 6.21</A>).</P>

					<A Name="14"></a><p><table border="1" cellsPACING="0" cELlPAdDING="1" WIdth="100%">
<cAPTIon><h5>Table 6.21. Nonmodifying Operations of Sets and Multisets</h5></CAPTion><cOLGRoup align="left" span="2">
<tr valign="top">
<tD>
<FONT SiZE="2"><b>Operation</B>
									</FoNT></TD>
<TD>
<font SIZE="2"><b>Effect</b>
									</foNT></TD>
</tr>
<tr VALIgn="top">
<td>
<font size="2"><tt class="monofont">c.size()</tt>
									</FONT></TD>
<tD>
<FoNT sIZE="2">Returns the actual number of elements</FONt></td>
</tR>
<TR ValigN="top">
<TD>
<Font sIZE="2"><Tt class="monofont">c.empty ()</tt>
									</font></td>
<td>
<font sIZE="2">Returns whether the container is empty (equivalent to <TT ClASs="monofont">size()==0,</TT> but might be faster)
</fONT></TD>
</Tr>
<tr vALIGn="top">
<td>
<fONT Size="2"><tT CLAss="monofont">c.max_size()</tt>
									</font></td>
<td>
<font size="2">Returns the maximum number of elements possible</fONT></TD>
</Tr>
<TR vALiGN="top">
<TD>
<FOnt siZE="2"><TT clasS="monofont">c1 == c2</TT>
									</Font></tD>
<TD>
<Font size="2">Returns whether <tt class="monofont">c1</tt> is equal to <tt claSS="monofont">c2</TT>
									</FOnT></Td>
</TR>
<tR VALIGn="top">
<td>
<fONT Size="2"><tT CLAss="monofont">c1 != c2</tt>
									</FONT></td>
<td>
<font size="2">Returns whether <tt class="monofont">c1</tt> is not equal to <TT CLASs="monofont">c2</TT> (equivalent to <tT ClASS="monofont">!</TT>
										<Tt claSS="monofont">(c1==c2)</TT> )
</font></TD>
</TR>
<tr vaLIGN="top">
<td>
<font size="2"><tt class="monofont">c1 &lt; c2</tt>
									</foNT></TD>
<TD>
<fONt SIzE="2">Returns whether <TT CLAss="monofont">c1</tt> is less than <TT CLass="monofont">c2</tT>
									</FONt></td>
</tR>
<TR Valign="top">
<td>
<font size="2"><tt clasS="monofont">c1 &gt; c2</TT>
									</FONt></TD>
<tD>
<FoNT SIZE="2">Returns whether <tt clASS="monofont">c1</Tt> is greater than <tt cLASS="monofont">c2</tt> (equivalent to <tt CLASs="monofont">c2&lt;c1</tt>)
</font></td>
</tr>
<tr valign="top">
<td>
<FONT SIzE="2"><Tt CLaSS="monofont">c1 &lt;= c2</TT>
									</FOnt></td>
<TD>
<FOnt siZE="2">Returns whether <TT clasS="monofont">c1</TT> is less than or equal to <Tt class="monofont">c2</tt> (equivalent to <tt class="monofont">!</tt>
										<tt clASS="monofont">(c2&lt;c1)</TT> )
</FoNT></tD>
</Tr>
<TR VALIgn="top">
<td>
<FONT size="2"><TT CLass="monofont">c1 &gt;= c2</tT>
									</FONt></td>
<td>
<font size="2">Returns whether <tt class="monofont">c1</tT> is greater than or equal to <TT CLAsS="monofont">c2</Tt> (equivalent to <TT cLASS="monofont">!(c1&lt;c2)</TT>)
</font></TD>
</TR>
</colgROUP>
</tablE></P>

					<P>Comparisons are provided only for containers of the same type. Thus, the elements <I>and</i> the sorting criterion must have the same types; otherwise, a type error occurs at compile time. For example:</p>

					<pre>
						
   std::set&lt;float&gt; c1;      <i>// sorting criterion:</i> std::less&lt;&gt;
   std::set&lt;float,std::greater&lt;float&gt; &gt; c2;
   ...
   if (c1 == c2) {          <i>// ERROR: different types</i>
      ...
   }

					</pre>

					<p>The check whether a container is less than another container is done by a lexicographical comparison (see page 360). To compare containers of different types (different sorting criteria), you must use the comparing algorithms in <a href="0201379260_snode75.html#11">Section 9.5.4</a>.</p>

				
				<h5>Special Search Operations</H5>
					<P>Sets and multisets are optimized for fast searching of elements, so they provide special search functions (<A href="0201379260_snode52.html#16">Table 6.22</A>). These functions are special versions of general algorithms that have the same name. You should always prefer the optimized versions for sets and multisets to achieve logarithmic complexity instead of the linear complexity of the general algorithms. For example, a search of a collection of 1,000 elements requires on average only 10 comparisons instead of 500 (see <A href="0201379260_snode15.html">Section 2.3</A>,).</P>

					<A NAMe="16"></a><p><tABLE bordER="1" CEllspACINg="0" cellpadding="1" width="100%">
<captION><H5>Table 6.22. Special Search Operations of Sets and Multisets</H5></CaPTiON><cOLGROUp aliGN="left" SPan="2">
<tr VALIgn="top">
<td>
<FONT size="2"><b>Operation</b>
									</font></td>
<td>
<font sizE="2"><B>Effect</B>
									</FONt></TD>
</tR>
<Tr VALIGN="top">
<td>
<foNT SIze="2"><tt CLASs="monofont">count (elem)</tt>
									</fONT></Td>
<td>
<font size="2">Returns the number of elements with value <tt class="monofont">elem</tt>
									</fONT></TD>
</Tr>
<TR vALiGN="top">
<TD>
<FOnt siZE="2"><TT clasS="monofont">find(elem)</TT>
									</Font></tD>
<TD>
<Font size="2">Returns the position of the first element with value <tt class="monofont">elem</tt> or <tt claSS="monofont">end()</TT>
									</FOnT></Td>
</TR>
<tR VALIGn="top">
<td>
<fONT Size="2"><tT CLAss="monofont">lower _bound( elem)</tt>
									</FONT></td>
<td>
<font size="2">Returns the first position, where <tt class="monofont">elem</tt> would get inserted (the first element <TT CLASs="monofont">&gt;=</TT>
										<tT ClASS="monofont">elem)</TT>
									</Font></tD>
</TR>
<Tr valIGN="top">
<Td>
<fonT SIZe="2"><tt class="monofont">upper _bound (elem)</tt>
									</font></td>
<td>
<fonT SIZE="2">Returns the last position, where <Tt CLaSS="monofont">elem</tT> would get <TT CLAss="monofont">inserted</tt> (the first element <TT CLass="monofont">&gt;</tT>
										<TT Class="monofont">elem)</TT>
									</FOnt></td>
</tr>
<tr valign="top">
<td>
<font sIZE="2"><TT ClASs="monofont">equal_range (elem)</TT>
									</fONT></TD>
<Td>
<fonT SIZe="2">Returns the first and last position, where <tt cLASS="monofont">elem</tt> would get inserted (the range of elements <tt CLASs="monofont">==</tt>
										<tt class="monofont">elem)</tt>
									</font></td>
</tr>
</cOLGROUp>
</TAbLE></p>

					<P>The <TT CLAss="monofont">find()</tt> member function searches the first element that has the value that was passed as the argument and returns its iterator position. If no such element is found, <TT CLass="monofont">find()</tT> returns <TT Class="monofont">end()</TT> of the container.</P>

					<P><tt class="monofont">lower_bound()</tt> and <tt class="monofont">upper_bound()</tt> return the first and last position respectively, at which an element with the passed value would be inserted. In other words, <tt cLASS="monofont">lower_bound()</TT> returns the position of the first element that has the same or a greater value than the argument, whereas <tT ClASs="monofont">upper_bound()</TT> returns the position of the first element with a greater value. <TT CLass="monofont">equal_range()</tT> returns both return values of <TT Class="monofont">lower_bound()</TT> and <TT clasS="monofont">upper_bound()</TT> as a <Tt class="monofont">pair</tt> (type <tt class="monofont">pair</tt> is introduced in <a href="0201379260_snode24.html">Section 4.1</A>). Thus, it returns the range of elements that have the same value as the argument. If <TT CLaSS="monofont">lower_bound()</tT> or the first value of <Tt CLASS="monofont">equal_range()</Tt> is equal to <tt cLASS="monofont">upper_bound()</tt> or the second value of <tt CLASs="monofont">equal_range(),</tt> then no elements with the same value exist in <tT CLAss="monofont">the set</tt> or multiset. Naturally, in a set the range of elements that have the same values could contain at most one element.</p>

					<p>The following example shows how to use <tt class="monofont">lower_bound(), upper_bound(),</tt> and <tt clasS="monofont">equal_range():</TT></P>

					<PRe>
						
    <I>// cont/set2.cpp</I>

    #include &lt;iostream&gt;
    #include &lt;set&gt;
    using namespace std;
    int main ()
    {

        set&lt;int&gt; c;

        c.insert(1);
        c.insert(2);
        c.insert(4);
        c.insert(5);
        c.insert(6);

        cout &lt;&lt; "lower_bound(3): " &lt;&lt; *c.lower_bound(3) &lt;&lt; endl;
        cout &lt;&lt; "upper_bound(3): " &lt;&lt; *c.upper_bound(3) &lt;&lt; endl;
        cout &lt;&lt; "equal_range(3): " &lt;&lt; *c.equal_range(3).first &lt;&lt; " "
                                   &lt;&lt; *c.equal_range(3).second &lt;&lt; endl;
        cout &lt;&lt; endl;
        cout &lt;&lt; "lower_bound(5): " &lt;&lt; *c.lower_bound(5) &lt;&lt; endl;
        cout &lt;&lt; "upper_bound(5): " &lt;&lt; *c.upper_bound(5) &lt;&lt; endl;
        cout &lt;&lt; "equal_range(5): " &lt;&lt; *c.equal_range(5).first &lt;&lt; " "
                                   &lt;&lt; *c.equal_range(5).second &lt;&lt; endl;
    }

					</pRE>

					<p>The output of the program is as follows:</P>

					<PRE>
						
    lower_bound(3): 4
    upper_bound(3): 4
    equal_range(3): 4 4

    lower_bound(5): 5
    upper_bound(5): 6
    equal_range(5): 5 6

					</PRe>

					<p>If you use a multiset instead of a set, the program has the same output.</p>

				
				<h5>Assignments</H5>
					<P>Sets and multisets provide only the fundamental assignment operations that all containers provide (<A href="0201379260_snode52.html#18">Table 6.23</a>). See page 147 for more details.</P>

					<P>For these operations both containers must have the same type. In particular, the type of the comparison criteria must be the same, although the comparison criteria themselves may be different. See page 191 for an example of different sorting criteria that have the same type. If the criteria are different, they will also get assigned or swapped.</P>

					<A name="18"></A><P><TAble border="1" cellspacing="0" cELLPADdINg="1" WIdTH="100%">
<CAPTion><h5>Table 6.23. Assignment Operations of Sets and Multisets</H5></CAPtion><COLGroup ALIGn="left" span="2">
<tr valign="top">
<td>
<font siZE="2"><B>Operation</B>
									</FOnT></Td>
<TD>
<fONT SIZe="2"><b>Effect</b>
									</fONT></Td>
</tr>
<tR VALign="top">
<tD>
<FONt size="2"><tt class="monofont">c1 = c2</tt>
									</font></td>
<tD>
<FONT SiZE="2">Assigns all elements of <tT ClASS="monofont">c2</TT> to <Tt claSS="monofont">c1</TT>
									</font></TD>
</TR>
<tr vaLIGN="top">
<td>
<font size="2"><tt class="monofont">c1.swap(c2)</tt>
									</foNT></TD>
<TD>
<fONt SIzE="2">Swaps the data of <TT CLAss="monofont">c1</tt> and <TT CLass="monofont">c2</tT>
									</FONt></td>
</tR>
<TR Valign="top">
<td>
<font size="2"><tt clasS="monofont">swap(c1,c2)</TT>
									</FONt></TD>
<tD>
<FoNT SIZE="2">Same (as global function)</font></TD>
</TR>
</colgROUP>
</tablE></P>

				
				<H5>Iterator Functions</H5>
					<p>Sets and multisets do not provide direct element access, so you have to use iterators. Sets and multisets provide the usual member functions for iterators (<a href="0201379260_snode52.html#20">Table 6.24</a>).</p>

					<a name="20"></a><p><table bORDER="1" CeLLsPAcING="0" CELlpadDING="1" widtH="100%">
<CAPtion><H5>Table 6.24. Iterator Operations of Sets and Multisets</H5></CAption><colgroup align="left" spaN="2">
<TR VALiGN="top">
<tD>
<FoNT SIZE="2"><b>Operation</b>
									</foNT></TD>
<td>
<foNT SIze="2"><b>Effect</b>
									</FONT></td>
</tr>
<tr valign="top">
<td>
<font sizE="2"><TT CLAsS="monofont">c.begin()</Tt>
									</FOnT></TD>
<TD>
<Font sIZE="2">Returns a bidirectional iterator for the first element (elements are considered <Tt claSS="monofont">const</TT>)
</font></TD>
</TR>
<tr valign="top">
<td>
<font size="2"><tt cLASS="monofont">c.end()</TT>
									</fONt></TD>
<tD>
<FONT Size="2">Returns a bidirectional iterator for the position after the last element (elements are considered <tT CLAss="monofont">const</tt>)
</FONT></td>
</tr>
<TR VAlign="top">
<td>
<font size="2"><tt class="monofont">c.rbegin()</TT>
									</FONT></tD>
<Td>
<FOnT SIZE="2">Returns a reverse iterator for the first element of a reverse iteration</Font></tD>
</TR>
<Tr valIGN="top">
<Td>
<fonT SIZe="2"><tt class="monofont">c.rend()</tt>
									</font></td>
<td>
<fonT SIZE="2">Returns a reverse iterator for the position after the last element of a reverse iteration</FoNT></tD>
</Tr>
</COLGROup>
</taBLE></P>

					<p>As with all associative container classes, the iterators are bidirectional iterators (see <a href="0201379260_snode60.html#9">Section 7.2.4</A>). Thus, you can't use them in algorithms that are provided only for random access iterators (such as algorithms for sorting or random shuffling).</P>

					<p>More important is the constraint that, from an iterator's point of view, all elements are considered constant. This is necessary to ensure that you can't compromise the order of the elements by changing their values. However, as a result you can't call any modifying algorithm on the elements of a set or multiset. For example, you can't call the <tt cLASS="monofont">remove()</tt> algorithm to remove elements because it "removes" by overwriting "removed" elements the with following arguments (see <a href="0201379260_snode39.html#4">Section 5.6.2</a>, for a detailed discussion of this problem). To remove elements in sets and multisets, you can use only member functions provided by the container.</p>

				
				<h5>Inserting and Removing Elements</h5>
					<p><a href="0201379260_snode52.html#22">Table 6.25</a> shows the operations provided for sets and multisets to insert and remove elements.</p>

					<p>As usual by using the STL, you must ensure that the arguments are valid. Iterators must refer to valid positions, the beginning of a range must have a position that is not behind the end, and you must not try to remove an element from an empty container.</p>

					<P>Inserting and removing happens faster if, when working with multiple elements, you use a single call for all elements rather than multiple calls.</P>

					<A NAMe="22"></A><P><tABlE BORDEr="1" celLSPAcing="0" CELLpaddING="1" Width="100%">
<caption><h5>Table 6.25. Insert and Remove Operations of Sets and Multisets</h5></caption><cOLGROUp ALiGN="left" sPAN="2">
<TR ValigN="top">
<TD>
<Font sIZE="2"><B>Operation</b>
									</fonT></TD>
<Td>
<font size="2"><b>Effect</b>
									</font></td>
</tr>
<tr VALIGN="top">
<tD>
<FoNT sIZE="2"><TT Class="monofont">c. insert(elem)</TT>
									</FOnt></td>
<TD>
<FOnt siZE="2">Inserts a copy of <TT class="monofont">elem</tt> and returns the position of the new element and, for sets, whether it succeeded
</font></td>
</tr>
<tr valiGN="top">
<TD>
<FOnT SiZE="2"><tT CLASS="monofont">c. insert(pos, elem)</tt>
									</foNT></TD>
<td>
<foNT SIze="2">Inserts a copy of <tt CLASs="monofont">elem</tt> and returns the position of the new element (<tt class="monofont">pos</tt> is used as a hint pointing to where the insert should start the search)
</font></td>
</tr>
<tR VALIGn="top">
<TD>
<fONt SIZE="2"><TT clasS="monofont">c. insert (beg,end)</TT>
									</Font></tD>
<TD>
<Font sIZE="2">Inserts a copy of all elements of the range <Tt class="monofont">[beg,end)</tt> (returns nothing)
</font></td>
</tr>
<tr valIGN="top">
<TD>
<FoNT sIZe="2"><TT CLASs="monofont">c. erase(elem)</tt>
									</fONT></Td>
<td>
<fONT Size="2">Removes all elements with value <tT CLAss="monofont">elem</tt> and returns the number of removed elements
</font></td>
</tr>
<tr valign="top">
<tD>
<FONT SiZE="2"><tT ClASS="monofont">c. erase(pos)</TT>
									</Font></tD>
<TD>
<Font sIZE="2">Removes the element at iterator position <Tt claSS="monofont">pos</TT> (returns nothing)
</font></td>
</tr>
<tr valign="top">
<td>
<fonT SIZE="2"><Tt CLaSS="monofont">c. erase(beg,end)</tT>
									</FONT></Td>
<td>
<fONT Size="2">Removes all elements of the range <tT CLAss="monofont">[beg,end)</tt> (returns nothing)
</FONT></td>
</tr>
<tr valign="top">
<td>
<font sizE="2"><TT CLAsS="monofont">c. clear()</Tt>
									</FOnT></TD>
<TD>
<Font sIZE="2">Removes all elements (makes the container empty)</Font></tD>
</TR>
</ColgrOUP>
</Table></p>

					<p>Note that the return types of the insert functions differ as follows:</p>

					<ul>
<li><p><b>Sets</b> provide the following interface:</p>

							<pre>
								
   pair&lt;iterator,bool&gt; insert(const value_type&amp; elem);
   iterator            insert(iterator pos_hint,
                              const value_type&amp; elem);

							</pre>

						</LI>
<LI><P><B>Multisets</b> provide the following interface:</P>

							<PrE>
								
   iterator            insert(const value_type&amp; elem);
   iterator            insert(iterator pos_hint,
                              const value_type&amp; elem);

							</PrE>

						</LI>
</UL>
					<P>The difference in return types results because multisets allows duplicates, whereas sets do not. Thus, the insertion of an element might fail for a set if it already contains an element with the same value. Therefore, the return type of a set returns two values by using a <tt clASS="monofont">pair</Tt> structure (<tt cLASS="monofont">pair</tt> is discussed in <a href="0201379260_snode24.html">Section 4.1</A>,):</p>

					<ol type="1" start="restarts">
<li><p>The member <tt clasS="monofont">second</TT> of the <TT ClASs="monofont">pair</TT> structure returns whether the insertion was successful.</p>
</LI>
<LI><P>The member <Tt claSS="monofont">first</TT> of the <tt clASS="monofont">pair</Tt> structure returns the position of the newly inserted element or the position of the still existing element.</p>

						</li>
</OL>

					<P>In all other cases, the functions return the position of the new element (or of the existing element if the set contains an element with the same value already).</P>

					<p>The following example shows how to use this interface to insert a new element into a set. It tries to insert the element with value 3.3 into the set <tt class="monofont">c:</tt></p>

					<pre>
						
    std::set&lt;double&gt; c;
       
    if (c.insert(3.3).second) {
        std::cout &lt;&lt; "3.3 inserted" &lt;&lt; std::endl;
    }
    else {
        std::cout &lt;&lt; "3.3 already exists" &lt;&lt; std::endl;
    }

					</pre>

					<p>If you also want to process the new or old positions, the code gets more complicated:</p>

					<prE>
						
    <I>//define variable for return value of</I> insert()
    std::pair&lt;std::set&lt;float&gt;::iterator,bool&gt; status;

    <I>//insert value and assign return value</I>
    status = c.insert(value);

    <I>//process return value</i>
    if (status.second) {
        std::cout &lt;&lt; value &lt;&lt; " inserted as element "
    }
    else {
        std::cout &lt;&lt; value &lt;&lt; " already exists as element "
    }
    std::cout &lt;&lt; std::distance(c.begin().status.first) + 1
              &lt;&lt; std::endl;

					</PRe>

					<P>The output of two calls of this sequence might be as follows:</P>

					<pRE>
						
   8.9 inserted as element 4
   7.7 already exists as element 3

					</PRE>

					<P>Note that the return types of the insert functions with an additional position parameter don't differ. These functions return a single iterator for both sets and multisets. However, these functions have the same effect as the functions without the position parameter. They differ only in their performance. You can pass an iterator position, but this position is processed as a hint to optimize performance. In fact, if the element gets inserted right after the position that is passed as the first argument, the time complexity changes from logarithmic to amortized constant (complexity is discussed in <a href="0201379260_snode15.html">Section 2.3</A>,). The fact that the return type for the insert functions with the additional position hint doesn't have the same difference as the insert functions without the position hint ensures that you have one insert function that has the same interface for all container types. In fact, this interface is used by general inserters. See <A href="0201379260_snode62.html#6">Section 7.4.2</a>, especially page 275, for details about inserters. To remove an element that has a certain value, you simply call <TT CLass="monofont">erase():</tT></P>

					<PRe>
						
   std::set&lt;Elem&gt; coll;
   ...
   <i>//remove all elements with passed value</i>
   coll.erase(value);

					</pre>

					<p>Unlike with lists, the <tt class="monofont">erase()</tt> member function does not have the name <tt claSS="monofont">remove()</TT> (see page 170 for a discussion of <TT cLAsS="monofont">remove()</Tt>). It behaves differently because it returns the number of removed elements. When called for sets, it returns only <TT CLASs="monofont">0</tt> or <tT CLAss="monofont">1.</tt></P>

					<P>If a multiset contains duplicates, you can't use <TT clasS="monofont">erase()</TT> to remove only the first element of these duplicates. Instead, you can code as follows:</P>

					<pre>
						
   std::multiset&lt;Elem&gt; coll;
   ...<i></i>
   <i>//remove first element with passed value</i>
   std::multiset&lt;Elem&gt;::iterator pos;
   pos = coll.find (elem);
   if (pos != coll.end()) {
       coll.erase(pos);
   }

					</pre>

					<p>You should use the member function <tt class="monofont">find()</tt> instead of the <tT CLASS="monofont">find()</tT> algorithm here because it is faster (see the example on page 154).</P>

					<p>Note that there is another inconsistency in return types here. That is, the return types of the <TT cLASS="monofont">erase()</TT> functions differ between sequence and associative containers as follows:</p>

					<ol tYPE="1" Start="restarts">
<LI><P><B>Sequence containers</b> provide the following <tt cLASS="monofont">erase()</tt> member functions:</p>

							<pre>
								
      iterator erase(iterator pos);
      iterator erase(iterator beg, iterator end);

							</pre>
</li>
<li><p><b>Associative containers</b> provide the following <tt claSS="monofont">erase()</TT> member functions:</P>

							<PrE>
								
      void     erase(iterator pos);
      void     erase(iterator beg, iterator end);

							</PrE>
</Li>
</OL>

					<P>The reason for this difference is performance. It might cost time to find and return the successor in an associative container because the container is implemented as a binary tree. However, as a result, to write generic code for all containers you must ignore the return value.</P>

				
			
			<H4>6.5.3
Exception Handling</H4>
				<p>Sets and multisets are node-based containers, so any failure to construct a node simply leaves the container as it was. Furthermore, because destructors in general don't throw, removing a node can't fail.</p>

				<p>However, for multiple-element insert operations, the need to keep elements sorted makes full recovery from throws impractical. Thus, all single-element insert operations support commit-or-rollback behavior. That is, they either succeed or they have no effect. In addition, it is guaranteed that all multiple-element delete operations always succeed. If copying/assigning the comparison criterion may throw, <tT CLAss="monofont">swap()</tt> may throw.</P>

				<P>See <A href="0201379260_snode44.html#3">Section 5.11.2</a>, for a general discussion of exceptions handling in the STL and <A href="0201379260_snode57.html#20">Section 6.10.10</a>, for a list of all container operations that give special guarantees in face of exceptions.</p>

			
			<h4>6.5.4
Examples of Using Sets and Multisets</h4>
				<p>The following program demonstrates some abilities of sets<font size="1"><sup><a hreF="#FOOTNOTE-20">[20]</A></SUP></FoNT>
:</p>
<BLoCKQUOTe><fonT SIZe="1">
<p clASS="footnote">
<Sup><a nAME="FOOTNOTE-20">[20]</A></sup>
The definition of <tt class="monofont">distance()</tt> has changed, so in older STL versions you must include the file <tt class="monofont">distance.hpp,</tt> which is mentioned on page 263.</P>
</FONT></BlOCkQUoTE>

				<PRE>
					
    <I>// cont/set1.cpp</i>

    #include &lt;iostream&gt;
    #include &lt;set&gt;
    using namespace std;

    int main()
    {

       /*<i>type of the collection:</i>
        *-<i>no duplicates</I>
        *-<I>elements are integral values</I>
        *-<I>descending order</i>
        */
       typedef set&lt;int,greater&lt;int&gt; &gt; IntSet;

       IntSet coll1;         <i>// empty set container</i>

       <i>//insert elements in random order</I>
       coll1.insert(4);
       coll1.insert(3);
       coll1.insert(5);
       coll1.insert(1);
       coll1.insert(6);
       coll1.insert(2);
       coll1.insert(5);

       <I>//iterate over all elements and print them</I>
       IntSet::iterator pos;
       for (pos = coll1.begin(); pos != coll1.end(); ++pos) {
           cout &lt;&lt; *pos &lt;&lt; ' ';
       }
       cout &lt;&lt; endl;

       <I>//insert</i> 4 <i>again and process return value</i>
       pair&lt;IntSet::iterator,bool&gt; status = coll1.insert(4);
       if (status.second) {
           cout &lt;&lt; "4 inserted as element "
                &lt;&lt; distance (coll1.begin(),status. first) + 1
                &lt;&lt; endl;
       }
       else {
           cout &lt;&lt; "4 already exists" &lt;&lt; endl;
       }

       <i>//assign elements to another set with ascending order</I>
       set&lt;int&gt; coll2(coll1.begin(),
                      coll1.end());

       <I>//print all elements of the copy</I>
       copy (coll2.begin(), coll2.end(),
             ostream_iterator&lt;int&gt;(cout," "));
       cout &lt;&lt; endl;

       <I>//remove all elements up to element with value</i> 3
       coll2.erase (coll2.begin(), coll2.find(3));

       <i>//remove all elements with value</i> 5
       int num;
       num = coll2.erase (5);
       cout &lt;&lt; num &lt;&lt; " element(s) removed" &lt;&lt; endl;

       <i>//print all elements</i>
       copy (coll2.begin(), coll2.end(),
             ostream_iterator&lt;int&gt;(cout," "));
       cout &lt;&lt; endl;
    }

				</pre>

				<p>At first, the type definition</p>

				<pre>
					
    typedef set&lt;int,greater&lt;int&gt; &gt; IntSet;

				</pre>

				<p>defines a short type name for a set of <tt clASS="monofont">int</TT>s with descending order. After an empty set is created, several elements are inserted by using <Tt CLaSS="monofont">insert ():</tT></P>

				<PRE>
					
   IntSet coll1;

   coll1.insert(4);
   ...

				</Pre>

				<p>Note that the element with value <tT CLAss="monofont">5</tt> is inserted twice. However, the second insertion is ignored because sets do not allow duplicates.</P>

				<P>After printing all elements, the program tries again to insert the element <TT clasS="monofont">4.</TT> This time it processes the return values of <Tt class="monofont">insert()</tt> as discussed on page 183.</p>

				<p>The statement</p>

				<pre>
					
   set&lt;int&gt; coll2(coll1.begin(), coll1. end());

				</pre>

				<p>creates a new set of <tt cLASS="monofont">int</TT>s with ascending order and initializes it with the elements of the old set.<fONt SIzE="1"><SUP><A Href="#FOOTNOTE-21">[21]</a></SUP></Font>
</p>
<BLOCkquoTE><FOnt size="1">
<p class="footnote">
<sup><a name="FOOTNOTE-21">[21]</a></SUP>
This statement requires several new language features; namely, member templates and default template arguments. If your system does not provide them, you must program as follows:</P>
</FOnT></BlOCkQUOTE>

						<Pre>
							
   set&lt;int,less&lt;int&gt; &gt; coll2;
   copy (coll1.begin(), coll1. end(),
         inserter(coll2,coll2.begin()));


						</prE>

					
				<P>Both containers have different sorting criteria, so their types differ and you can't assign or compare them directly. However, you can use algorithms, which in general are able to handle different container types as long as the element types are equal or convertible.</P>

				<P>The statement</p>

				<pre>
					
   coll2.erase (coll2.begin(), coll2.find(3));

				</PRE>

				<P>removes all elements up to the element with value <tt clASS="monofont">3.</Tt> Note that the element with value <tt class="monofont">3</tt> is the end of the range, so that it is not removed.</p>

				<p>Lastly, all elements with value <tt class="monofont">5</tt> are removed:</P>

				<PRE>
					
   int num;
   num = coll2.erase (5);
   cout &lt;&lt; num &lt;&lt; " element(s) removed" &lt;&lt; endl;

				</PRe>

				<P>The output of the whole program is as follows:</P>

				<pRE>
					
   6 5 4 3 2 1
   4 already exists
   1 2 3 4 5 6
   1 element(s) removed
   3 4 6

				</pRE>

				<P>For multisets, the same program looks a bit differently and produces different results:</P>

				<PRe>
					
   <i>// cont/mset1.cpp</i>

   #include &lt;iostream&gt;
   #include &lt;set&gt;
   using namespace std;

   int main()
   {

       /*<i>type of the collection:</I>
        *-<I>duplicates allowed</I>
        *-<I>elements are integral values</i>
        *-<i>descending order</i>
        */
       typedef multiset&lt;int,greater&lt;int&gt; &gt; IntSet;

       IntSet coll1,        <i>// empty multiset container</I>

       <I>//insert elements in random order</I>
       coll1.insert(4);
       coll1.insert(3);
       coll1.insert(5);
       coll1.insert(l);
       coll1.insert(6);
       coll1.insert(2);
       coll1.insert(5);

       <I>//iterate over all elements and print them</i>
       IntSet::iterator pos;
       for (pos = coll1.begin(); pos != coll1.end(); ++pos) {
           cout &lt;&lt; *pos &lt;&lt; ' ';
       }
       cout &lt;&lt; endl;

       <i>//insert</i> 4 <i>again and process return value</I>
       IntSet::iterator ipos = coll1.insert(4);
       cout &lt;&lt; "4 inserted as element "
            &lt;&lt; distance (coll1.begin(),ipos) + 1
            &lt;&lt; endl;

       <I>//assign elements to another multiset with ascending order</I>
       multiset&lt;int&gt; coll2(coll1.begin(),
                              coll1.end());

       <I>//print all elements of the copy</i>
       copy (coll2.begin(), coll2.end(),
             ostream_iterator&lt;int&gt;(cout," "));
       cout &lt;&lt; endl;

       <i>//remove all elements up to element with value</i> 3
       coll2.erase (coll2.begin(), coll2.find(3));

       <i>//remove all elements with value</i> 5
       int num;
       num = coll2.erase (5);
       cout &lt;&lt; num &lt;&lt; " element(s) removed" &lt;&lt; endl;

       <i>//print all elements</i>
       copy (coll2.begin(), coll2.end(),
             ostream_iterator&lt;int&gt;(cout," "));
       cout &lt;&lt; endl;
   }

				</pre>

				<p>In all cases type <tt class="monofont">set</tt> was changed to <tT CLASS="monofont">multiset.</tT> In addition, the processing of the return value of <Tt CLaSS="monofont">insert()</TT> looks different:</P>

				<Pre>
					
   IntSet::iterator ipos = coll1.insert(4);
   cout &lt;&lt; "4 inserted as element "
        &lt;&lt; distance (coll1.begin(),ipos) + 1
        &lt;&lt; endl;

				</prE>

				<P>Because multisets may contain duplicates, the insertion can fail only if an exception gets thrown. Thus, the return type is only the iterator position of the new element.</P>

				<P>The output of the program changed as follows:</p>

				<pre>
					
   6 5 5 4 3 2 1
   4 inserted as element 5
   1 2 3 4 4 5 5 6
   2 element(s) removed
   3 4 4 6

				</PRE>

			
			<H4>6.5.5
Example of Specifying the Sorting Criterion at Runtime</h4>
				<p>Normally you define the sorting criterion as part of the type, either by passing it as a second template argument or by using the default sorting criterion <tt CLASs="monofont">less&lt;&gt;.</tt> However, sometimes you must process the sorting criterion at runtime, or you may need different sorting criteria with the same data type. In this case, you need a special type for the sorting criterion — one that lets you pass your sorting details at runtime. The following example program demonstrates how to do this:</p>

				<pre>
					
   <i>// cont/setcmp.cpp</i>

   #include &lt;iostream&gt;
   #include &lt;set&gt;
   #include "print.hpp"
   using namespace std;

   <i>//type for sorting criterion</i>
   template &lt;class T&gt;
   class RuntimeCmp {
     public:
       enum cmp_mode {normal, reverse};
     private:
       cmp_mode mode;
     public:
       <i>//constructor for sorting criterion</i>
       <i>//-default criterion uses value</i> normal
       RuntimeCmp (cmp_mode m=normal) : mode(m) {
       }
       <i>//comparision of elements</i>
       bool operator() (const T&amp; t1, const T&amp; t2) const {
           return mode == normal ? t1 &lt; t2 : t2 &lt; t1;
       }
       <i>//comparision of sorting criteria</i>
       bool operator== (const RuntimeCmp&amp; rc) {
           return mode == rc.mode;
       }
   };

   <i>//type of a set that uses this sorting criterion</i>
   typedef set&lt;int,RuntimeCmp&lt;int&gt; &gt; IntSet;

   <I>//forward declaration</I>
   void fill (IntSet&amp; set);
 
   int main()
   {
       <I>//create, fill, and print set with normal element order</I>
       <I>//-uses default sorting criterion</I>
       IntSet coll1;
       fill(coll1);
       PRINT_ELEMENTS (coll1, "coll1: ");

       <i>//create sorting criterion with reverse element order</I>
       RuntimeCmp&lt;int&gt; reverse_order(RuntimeCmp&lt;int&gt;::reverse);

       <I>//create, fill, and print set with reverse element order</i>
       IntSet coll2(reverse_order);
       fill(coll2);
       PRINT_ELEMENTS (coll2, "coll2: ");
 
       <I>//assign elements AND sorting criterion</I>
       coll1 = coll2;
       coll1.insert(3);
       PRINT_ELEMENTS (coll1, "coll1: ");

       <i>//just to make sure...</I>
       if (coll1.value_comp() == coll2.value_comp()) {
          cout &lt;&lt; "coll1 and coll2 have same sorting criterion"
               &lt;&lt; endl;
       }
       else {
           cout &lt;&lt; "coll1 and coll2 have different sorting criterion"
                &lt;&lt; endl;
       }
   }

   void fill (IntSet&amp; set)
   {
       <I>//fill insert elements in random order</I>
       set.insert(4);
       set.insert(7);
       set.insert(5);
       set.insert(1);
       set.insert(6);
       set.insert(2);
       set.insert(5);
   }

				</PRE>

				<p>In this program, <tt cLASS="monofont">RuntimeCmp&lt;&gt;</tt> is a simple template that provides the general ability to specify, at runtime, the sorting criterion for any type. Its default constructor sorts in ascending order using the default value <tt CLASs="monofont">normal.</tt> It also is possible to pass <tT CLAss="monofont">RuntimeCmp&lt;&gt;::reverse</tt> to sort in descending order.</p>

				<p>The output of the program is as follows:</p>

				<pre>
					
   coll1: 1 2 4 5 6 7
   coll2: 7 6 5 4 2 1
   coll1: 7 6 5 4 3 2 1
   coll1 and coll2 have same sorting criterion

				</pre>

				<p>Note that <tt class="monofont">coll1</TT> and <TT CLaSS="monofont">coll2</tT> have the same type, which is used in <Tt CLASS="monofont">fill(),</Tt> for example. Note also that the assignment operator assigns the elements <i>and</i> the sorting criterion (otherwise an assignment would be an easy way to compromise the sorting criterion).</p>

			
		</FONT>
 
<table width="100%" border="0" cellspacing="0" cellpadding="0" bgcolor="#CCCCCC">
<td><font color="black" size=1>I l<font color="#FF0000">@</font>ve RuBoard</td>
<td valign="top" class="v2" align="right"><a href="0201379260_snode51.html"><img src="FILES/previous.gif" width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a> <a href="0201379260_snode53.html"><img src="FILES/next.gif" width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a></td></table>
</BODY></HTML>