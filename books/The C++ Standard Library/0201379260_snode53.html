<HTML><HEAD><META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=iso-8859-1">
<!--SafClassName="docSection1Title"--><!--SafTocEntry="6.6 Maps and Multimaps"-->
<LINK REL="stylesheet" href="FILES/sbolM.css">
</HEAD>
<BODY link="#354278" vlink="#000066" alink="#000080" topmargin="0">
<table width="100%" border="0" cellspacing="0" cellpadding="0" bgcolor="#CCCCCC">
<td><font color="black" size=1>I l<font color="#FF0000">@</font>ve RuBoard</td>
<td valign="top" class="v2" align="right"><a href="0201379260_snode52.html"><img src="FILES/previous.gif" width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a> <a href="0201379260_snode54.html"><img src="FILES/next.gif" width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a></td></table>
<FONT><h3>6.6
Maps and Multimaps</h3>
			<p>Map and multimap containers are containers that manage key/value pairs as elements. They sort their elements automatically according to a certain sorting criterion that is used for the actual key. The difference between the two is that multimaps allow duplicates, whereas maps do not (<a href="0201379260_snode53.html#1">Figure 6.8</a>).</p>

			<ceNTER>
				<h5>
<a naME="1"></A>Figure 6.8. Maps and Multimaps</H5><img border="0" width="500" height="180" src="FILES/06fig08.gif" ALT="graphics/06fig08.gif"></CeNTeR>

			<P>To use a map or multimap, you must include the header file <tT CLASS="monofont">&lt;map&gt;</tt><foNT SIze="1"><suP><A HRef="#FOOTNOTE-22">[22]</a></sUP></FOnt>
:</p>
<blockquote><font size="1">
<P CLASS="footnote">
<sUP><a NAmE="FOOTNOTE-22">[22]</A></SUP>
In the original STL, the header file for maps was <Tt claSS="monofont">&lt;map.h&gt;,</TT> and for multimaps it was <tt clASS="monofont">&lt;multimap.h&gt;.</Tt></p>
</foNT></BLockquote>

			<pre>
				
   #include &lt;map&gt;

			</pre>

			<p>There, the type is defined as a class template inside namespace <tt clasS="monofont">std:</TT></P>

			<PRe>
				
   namespace std {
       template &lt;class Key, class T,
                 class Compare = less&lt;Key&gt;,
                 class Allocator = allocator&lt;pair&lt;const Key,T&gt; &gt; &gt;
       class map;

       template &lt;class Key, class T,
                 class Compare = less&lt;Key&gt;,
                 class Allocator = allocator&lt;pair&lt;const Key,T&gt; &gt; &gt;
       class multimap;
   }

			</PRe>

			<P>The first template argument is the type of the element's key, and the second template argument is the type of the element's value. The elements of a map or multimap may have any types <Tt CLASS="monofont">Key</Tt> and <tt cLASS="monofont">T</tt> that meet the following two requirements:</p>

			<oL TYPe="1" staRT="restarts">
<LI><p>The key/value pair must be assignable and copyable.</p>
</li>
<li><p>The key must be comparable with the sorting criterion.</p>

				</li>
</ol>

			<p>The optional third template argument defines the sorting criterion. Like sets, this sorting criterion must define a "strict weak ordering" (see page 176). The elements are sorted according to their keys, thus the value doesn't matter for the order of the elements. The sorting criterion is also used to check equality; that is, two elements are equal if neither key is less than the other. If a special sorting criterion is not passed, the default criterion <tt class="monofont">less</tT> is used. The function object <TT CLAsS="monofont">less</Tt> sorts the elements by comparing them with operator <TT cLASS="monofont">&lt;</TT> (see page 305 for details about <tt clASS="monofont">less</Tt>).<fonT SIZe="1"><sup><A HREf="#FOOTNOTE-23">[23]</a></sup></font>
</p>
<blockquote><fONT SIZe="1">
<P ClASs="footnote">
<SUP><A NAme="FOOTNOTE-23">[23]</a></sUP>
In systems without support for default template parameters, the third argument typically is mandatory.</P>
</Font></bLOCKquotE>

			<P>The optional fourth template parameter defines the memory model (see <A href="0201379260_cnode121.html">Chapter 15</a>). The default memory model is the model <tt class="monofont">allocator,</tt> which is provided by the C++ standard library.<font size="1"><SUP><A HReF="#FOOTNOTE-24">[24]</A></sUP></fONT>
</P>
<BLockqUOTE><font SIZE="1">
<p claSS="footnote">
<SUp><a name="FOOTNOTE-24">[24]</a></sup>
In systems without support for default template parameters, the fourth argument typically is missing.</p>
</font></blockqUOTE>

			<H4>6.6.1
Abilities of Maps and Multimaps</H4>
				<p>Like all standardized associative container classes, maps and multimaps are usually implemented as balanced binary trees (<A href="0201379260_snode53.html#6">Figure 6.9</a>). The standard does not specify this but it follows from the complexity of the map and multimap operations. In fact, sets, multisets, maps, and multimaps typically use the same internal data type. So, you could consider sets and multisets as special maps and multimaps, respectively, for which the value and the key of the elements are the same objects. Thus, maps and multimaps have all the abilities and operations of sets and multisets. Some minor differences exist, however. First, their elements are key/value pairs. In addition, maps can be used as associative arrays.</P>

				<CENTEr>
					<h5>
<a nAME="6"></A>Figure 6.9. Internal Structure of Maps and Multimaps</h5><img BORDer="0" wiDTH="500" Height="339" src="FILES/06fig09.gif" alt="graphics/06fig09.gif"></center>

				<p>Maps and multimaps sort their elements automatically according to the element's keys. Thus they have good performance when searching for elements that have a certain key. Searching for elements that have a certain value promotes bad performance. Automatic sorting imposes an important constraint on maps and multimaps: You may <i>not</i> change the key of an element directly because this might compromise the correct order. To modify the key of an element, you must remove the element that has the old key and insert a new element that has the new key and the old value (see page 201 for details). As a consequence, from the iterator's point of view, the element's key is constant. However, a direct modification of the value of the element is still possible (provided the type of the value is not constant).</p>

			
			<H4>6.6.2
Map and Multimap Operations</H4>
				<H5>Create, Copy, and Destroy Operations</H5>
					<P><A href="0201379260_snode53.html#9">Table 6.26</A> lists the constructors and destructors of maps and multimaps.</P>

					<a NAME="9"></A><P><tablE BORder="1" cELLSpaciNG="0" CEllpadding="1" width="100%">
<caption><H5>Table 6.26. Constructors and Destructors of Maps and Multimaps</H5></CAPTiON><cOLgROUP ALign="left" sPAN="2">
<Tr valIGN="top">
<Td>
<fonT SIZe="2"><b>Operation</b>
									</font></td>
<td>
<font size="2"><b>Effect</b>
									</FONT></TD>
</tR>
<Tr VAlIGN="top">
<TD>
<Font sIZE="2"><B><i>map</i></b>
										<tT CLAss="monofont">c</tt>
									</FONT></td>
<td>
<font size="2">Creates an empty map/multimap without any elements</font></td>
</tr>
<tR VALIGn="top">
<TD>
<fONt SIZE="2"><B><I>map</i></b>
										<tt CLASs="monofont">c(op)</tt>
									</fONT></Td>
<td>
<fONT Size="2">Creates an empty map/multimap that uses <tt class="monofont">op</tt> as the sorting criterion
</font></td>
</tr>
<tR VALIGn="top">
<TD>
<fONt SIZE="2"><B><I>map</i></b>
										<tt CLASs="monofont">c1(c2)</tt>
									</fONT></Td>
<td>
<fONT Size="2">Creates a copy of another map/multimap of the same type (all elements are copied)</font></td>
</tr>
<tr valign="top">
<td>
<FONT SIzE="2"><B><i>map</I></B>
										<tT CLASS="monofont">c(beg,end)</tt>
									</foNT></TD>
<td>
<foNT SIze="2">Creates a map/multimap initialized by the elements of the range <tt CLASs="monofont">[beg,end)</tt>
									</font></td>
</tr>
<tr valign="top">
<td>
<FONT SIzE="2"><B><i>map</I></B>
										<tT CLASS="monofont">c(beg,end,op)</tt>
									</foNT></TD>
<td>
<foNT SIze="2">Creates a map/multimap with the sorting criterion <tt CLASs="monofont">op</tt> initialized by the elements of the range <tt class="monofont">[beg,end)</tt>
									</font></td>
</tr>
<tR VALIGn="top">
<TD>
<fONt SIZE="2"><TT clasS="monofont">c.</TT>
										<Sup>~</suP><B><I>map</I></b>
										<i>()</i>
									</fONT></Td>
<td>
<font size="2">Destroys all elements and frees the memory</font></td>
</tr>
</coLGROUP>
</tABlE></P>

					<p>Here, <B>map</B> may be one of the following:</P>

					<P><TAble bORDEr="1" celLSPAcing="0" CELLpadding="1" width="100%">
<colgroup aLIGN="left" SPaN="2">
<Tr VAlIGN="top">
<TD>
<Font sIZE="2"><B>Map</b>
									</fonT></TD>
<Td>
<fonT SIZe="2"><b>Effect</b>
									</font></td>
</tr>
<tr valign="top">
<td>
<FONT SIzE="2"><Tt CLaSS="monofont">map&lt;Key,Elem&gt;</TT>
									</FOnt></td>
<TD>
<FOnt siZE="2">A map that sorts keys with <TT clasS="monofont">less&lt;&gt;</TT> (operator <Tt class="monofont">&lt;</tt>)
</font></td>
</tr>
<tr valIGN="top">
<TD>
<FoNT sIZe="2"><TT CLASs="monofont">map&lt;Key,Elem,Op&gt;</tt>
									</fONT></Td>
<td>
<fONT Size="2">A map that sorts keys with <tT CLAss="monofont">Op</tt>
									</font></td>
</tr>
<tr valign="top">
<tD>
<FONT SiZE="2"><tT ClASS="monofont">multimap&lt;Key,Elem&gt;</TT>
									</Font></tD>
<TD>
<Font sIZE="2">A multimap that sorts keys with <Tt claSS="monofont">less&lt;&gt;</TT> (operator <tt class="monofont">&lt;</tt>)
</font></td>
</tr>
<tr vaLIGN="top">
<TD>
<fONt SIzE="2"><TT CLAss="monofont">multimap&lt;Key,Elem,Op&gt;</tt>
									</FONT></td>
<td>
<FONT size="2">A multimap that sorts keys with <TT CLass="monofont">Op</tt>
									</font></td>
</tr>
</colgroup>
</TABLE></P>

					<p>You can define the sorting criterion in two ways:</P>

					<Ol TYpE="1" START="restarts">
<li><p><b>As a template parameter.</B></P>

							<P>For example<Font sIZE="1"><Sup><a hREF="#FOOTNOTE-25">[25]</A></sup></font>
:</p>
<blockquote><fonT SIZE="1">
<P cLAsS="footnote">
<SuP><A NAME="FOOTNOTE-25">[25]</a></sup>
Note that you have to put a space between the two <TT CLass="monofont">"&gt;"</tT> characters. <TT Class="monofont">"&gt;&gt;"</TT> would be parsed as shift operator, which would result in a syntax error.</P>
</Font></blockquote>

							<pre>
								
std::map&lt;float,std::string,std::greater&lt;float&gt; &gt; coll;
							</pre>
<p>In this case, the sorting criterion is part of the type. Thus, the type system ensures that only containers with the same sorting criterion can be combined. This is the usual way to specify the sorting criterion. To be more precise, the third parameter is the <i>type</I> of the sorting criterion. The concrete sorting criterion is the function object that gets created with the container. To do this, the constructor of the container calls the default constructor of the type of the sorting criterion. See page 294 for an example that uses a user-defined sorting criterion.</P>
</LI>
<LI><p><B>As <I>a</i> constructor parameter.</B></P>

							<p>In this case you might have a type for several sorting criteria, and the initial value or state of the sorting criteria might differ. This is useful when processing the sorting criterion at runtime, or when sorting criteria are needed that are different but of the same data type. A typical example is specifying the sorting criterion for string keys at runtime. See page 213 for a complete example.</P>

						</LI>
</OL>

					<P>If no special sorting criterion is passed, the default sorting criterion, function object <tt clASS="monofont">less&lt;&gt;,</Tt> is used. which sorts the elements by using operator <tt cLASS="monofont">&lt;.</tt><foNT SIze="1"><sup><a href="#FOOTNOTE-26">[26]</a></sup></font>
</p>
<blOCKQUOtE><FoNT sIZE="1">
<P CLass="footnote">
<sUP><A Name="FOOTNOTE-26">[26]</a></SUP>
In systems without support for default template parameters, you typically must always pass the sorting criterion as follows:</P>
</font></BLOCkquote>

							<pre>
								
   map&lt;float,string,less&lt;float&gt; &gt; coll;

							</pre>

						
					<p>You should make a type definition to avoid the boring repetition of the type whenever it is used:</p>

					<pre>
						
   typedef std::map&lt;std::string,float,std::greater&lt;string&gt; &gt;
           StringFloatMap;
   ...
   StringFloatMap coll;

					</pre>

					<p>The constructor for the beginning and the end of a range could be used to initialize the container with elements from containers that have other types, from arrays, or from the standard input. See <A href="0201379260_snode48.html#2">Section 6.1.2</A>, for details. However, the elements are key/value pairs, so you must ensure that the elements from the source range have or are convertible into type <tT ClASs="monofont">pair</TT><I>&lt;key,value&gt;.</I></P>

				
				<H5>Nonmodifying and Special Search Operations</h5>
					<p>Maps and multimaps provide the usual nonmodifying operations — those that query size aspects and make comparisons (<a href="0201379260_snode53.html#13">Table 6.27</A>).</p>

					<a naME="13"></A><P><tablE BORder="1" cellspacing="0" cellpadDING="1" WIdTH="100%">
<cAPtION><H5>Table 6.27. Nonmodifying Operations of Maps and Multimaps</H5></CaptiON><COlgroUP ALign="left" sPAN="2">
<Tr valign="top">
<td>
<font size="2"><b>Operation</b>
									</foNT></TD>
<TD>
<fONt SIzE="2"><B>Effect</B>
									</FONt></td>
</tR>
<TR ValigN="top">
<TD>
<Font sIZE="2"><Tt class="monofont">c.size()</tt>
									</font></td>
<td>
<font sIZE="2">Returns the actual number of elements</FONt></TD>
</tR>
<Tr VALIGN="top">
<td>
<foNT SIze="2"><tt CLASs="monofont">c.empty()</tt>
									</fONT></Td>
<td>
<font size="2">Returns whether the container is empty (equivalent to <tt class="monofont">size()==0,</tt> but might be faster)
</fONT></TD>
</Tr>
<TR vALiGN="top">
<TD>
<FOnt siZE="2"><TT clasS="monofont">c.max_size()</TT>
									</Font></tD>
<TD>
<Font size="2">Returns the maximum number of elements possible</font></td>
</tr>
<tr valiGN="top">
<TD>
<FOnT SiZE="2"><tT CLASS="monofont">c1 == c2</tt>
									</foNT></TD>
<td>
<foNT SIze="2">Returns whether <tt CLASs="monofont">c1</tt> is equal to <tt class="monofont">c2</tt>
									</font></td>
</tr>
<tR VALIGn="top">
<TD>
<fONt SIZE="2"><TT clasS="monofont">c1 != c2</TT>
									</Font></tD>
<TD>
<Font sIZE="2">Returns whether <Tt class="monofont">c1</tt> is not equal to <tt class="monofont">c2</tt> (equivalent to <tt clASS="monofont">!</TT><Tt CLaSS="monofont">(c1==c2)</tT>)
</FONT></Td>
</tr>
<tR VALign="top">
<tD>
<FONt sizE="2"><TT Class="monofont">c1 &lt; c2</tt>
									</font></td>
<td>
<font sizE="2">Returns whether <TT CLAsS="monofont">c1</Tt> is less than <TT cLASS="monofont">c2</TT>
									</font></TD>
</TR>
<tr vaLIGN="top">
<td>
<foNT SIze="2"><tt class="monofont">c1 &gt; c2</tt>
									</font></td>
<td>
<foNT SIZE="2">Returns whether <tT ClASs="monofont">c1</TT> is greater than <TT CLass="monofont">c2 c2&lt;c1)</tT>
									</FONt></td>
</tR>
<TR ValigN="top">
<TD>
<Font size="2"><tt class="monofont">c1 &lt;= c2</tt>
									</font></tD>
<TD>
<FONt SIzE="2">Returns whether <Tt CLASS="monofont">c1</Tt> is less than or equal to <tt cLASS="monofont">c2</tt> (equivalent to <tt CLASs="monofont">!</tt><tT CLAss="monofont">(c2&lt;c1)</tt>)
</font></td>
</tr>
<tr valign="top">
<tD>
<FONT SiZE="2"><tT ClASS="monofont">c1 &gt;= c2</TT>
									</Font></tD>
<TD>
<Font sIZE="2">Returns whether <Tt claSS="monofont">c1</TT> is greater than or equal to <tt class="monofont">c2</tt> (equivalent to <tt class="monofont">!</tt><tt cLASS="monofont">(c1&lt;c2)</TT>)
</fONt></TD>
</tR>
</COLGRoup>
</tABLE></p>

					<p>Comparisons are provided only for containers of the same type. Thus, the key, the value, and the sorting criterion must be of the same type. Otherwise, a type error occurs at compile time. For example:</p>

					<pRE>
						
   std::map&lt;float,std::string&gt; c1;     <I>// sorting criterion:</I> less&lt;&gt;
   std::map&lt;float,std::string,std::greater&lt;float&gt; &gt; c2;
   ...
   if (c1 == c2) {                     <i>// ERROR: different types</i>
       ...
   }

					</prE>

					<P>To check whether a container is less than another container is done by a lexicographical comparison (see page 360). To compare containers of different types (different sorting criterion), you must use the comparing algorithms of <A href="0201379260_snode75.html#11">Section 9.5.4</a>.</p>

				
				<h5>Special Search Operations</h5>
					<p>Like sets and multisets, maps and multimaps provide special search member functions that perform better because of their internal tree structure (<a href="0201379260_snode53.html#15">Table 6.28</a>).</p>

					<p>The <tt claSS="monofont">find()</TT> member function searches for the first element that has the appropriate key and returns its iterator position. If no such element is found, <TT cLAsS="monofont">find()</Tt> returns <TT CLASs="monofont">end()</tt> of the container. You can't use the <tT CLAss="monofont">find()</tt> member function to search for an element that has a certain value. Instead, you have to use a general algorithm such as the <TT CLass="monofont">find_if()</tT> algorithm, or program an explicit loop. Here is an example of a simple loop that does something with each element that has a certain value:</P>

					<PRe>
						
   std::multimap&lt;std::string,float&gt; coll;
   ...
   <i>//do something with all elements having a certain value</i>
   std::multimap&lt;std::string,float&gt;::iterator pos;
   for (pos = coll.begin(); pos != coll.end(); ++pos) {
      if (pos-&gt;second == value) {
          do_something();
      }
   }

					</pre>

					<a name="15"></a><p><table borDER="1" CELlSPaCInG="0" CELLPaddiNG="1" WIdth="100%">
<cAPTIon><h5>Table 6.28. Special Search Operations of Maps and Multimaps</h5></CAPTion><colgroup align="left" span="2">
<tR VALIGn="top">
<TD>
<fONt SIZE="2"><B>Operation</B>
									</font></TD>
<TD>
<font SIZE="2"><b>Effect</b>
									</foNT></TD>
</tr>
<tr valign="top">
<td>
<font size="2"><tT CLASS="monofont">count(key)</tT>
									</FoNT></tD>
<TD>
<FONt sizE="2">Returns the number of elements with key <TT Class="monofont">key</TT>
									</FOnt></td>
</TR>
<TR valign="top">
<td>
<font size="2"><tt claSS="monofont">find(key)</TT>
									</FOnT></Td>
<TD>
<fONT SIZe="2">Returns the position of the first element with key <tt cLASS="monofont">key</tt> or <tt CLASs="monofont">end()</tt>
									</fONT></Td>
</tr>
<tr valign="top">
<td>
<font size="2"><TT CLASs="monofont">lower_bound(key)</TT>
									</fONt></TD>
<TD>
<FOnt siZE="2">Returns the first position where an element with key <TT clasS="monofont">key</TT> would get inserted (the first element with key &gt;<Tt claSS="monofont">= key</TT>)
</font></td>
</tr>
<tr valign="top">
<td>
<fonT SIZE="2"><Tt CLaSS="monofont">upper_bound(key)</tT>
									</FONT></Td>
<td>
<fONT Size="2">Returns the last position where an element with key <tT CLAss="monofont">key</tt> would get inserted (the first element with key <TT CLass="monofont">&gt; key</tt>)
</font></td>
</tr>
<tr valign="top">
<TD>
<FONT sIZe="2"><TT cLASS="monofont">equal_range(key)</TT>
									</font></TD>
<TD>
<font SIZE="2">Returns the first and last positions where elements with key <tt clASS="monofont">key</Tt> would get inserted (the range of elements with key <tt class="monofont">== key</tt>)
</font></td>
</tr>
</colGROUP>
</TaBLe></P>

					<P>Be careful when you want to use such a loop to remove elements. It might happen that you saw off the branch on which you are sitting. See page 204 for details about this issue.</p>

					<P>Using the <TT CLAss="monofont">find_if()</tt> algorithm to search for an element that has a certain value is even more complicated than writing a loop because you have to provide a function object that compares the value of an element with a certain value. See page 211 for an example.</P>

					<P>The <TT clasS="monofont">lower_bound(), upper_bound(),</TT> and <Tt claSS="monofont">equal_range()</TT> functions behave as they do for sets (see page 180), except that the elements are key/value pairs.</p>

				
				<h5>Assignments</h5>
					<p>Maps and multimaps provide only the fundamental assignment operations that all containers provide (<a href="0201379260_snode53.html#17">Table 6.29</a>). See page 147 for more details.</p>

					<a name="17"></a><p><tabLE BORDeR="1" CeLLsPACING="0" cellPADDing="1" wIDTH="100%">
<captION><H5>Table 6.29. Assignment Operations of Maps and Multimaps</h5></caption><colgroup align="left" SPAN="2">
<TR vALiGN="top">
<tD>
<FONT Size="2"><b>Operation</B>
									</FONt></td>
<tD>
<FONt sizE="2"><B>Effect</B>
									</Font></td>
</tr>
<tr valign="top">
<td>
<font SIZE="2"><TT cLAsS="monofont">c1 = c2</Tt>
									</FONT></TD>
<td>
<foNT SIze="2">Assigns all elements of <tt CLASs="monofont">c2 c1</tt>
									</fONT></Td>
</tr>
<tr valign="top">
<td>
<font size="2"><TT CLASs="monofont">c1.swap(c2)</TT>
									</fONt></TD>
<TD>
<FOnt siZE="2">Swaps the data of <TT clasS="monofont">c1</TT> and <Tt claSS="monofont">c2</TT>
									</font></td>
</tr>
<tr valign="top">
<td>
<fonT SIZE="2"><Tt CLaSS="monofont">swap(c1,c2)</tT>
									</FONT></Td>
<td>
<fONT Size="2">Same (as global function)</fONT></Td>
</tr>
</cOLGRoup>
</table></p>

					<p>For these operations both containers must have the same type. In particular, the type of the comparison criteria must be the same, although the comparison criteria themselves may be different. See page 213 for an example of different sorting criteria that have the same type. If the criteria are different, they also get assigned or swapped.</p>

				
				<h5>Iterator Functions and Element Access</h5>
					<p>Maps and multimaps do not provide direct element access, so the usual way to access elements is via iterators. An exception to that rule is that maps provide the subscript operator to access elements directly. This is covered in <a href="0201379260_snode53.html#24">Section 6.6.3</a>. <a href="0201379260_snode53.html#19">Table 6.30</A> lists the usual member functions for iterators that maps and multimaps provide.</P>

					<a NAmE="19"></A><p><TABLE BordeR="1" CELlspaCING="0" cellPADDing="1" width="100%">
<caption><h5>Table 6.30. Iterator Operations of Maps and Multimaps</h5></captION><COLgROuP AlIGN="left" SPAn="2">
<tr vALIGn="top">
<td>
<fONT Size="2"><b>Operation</B>
									</FONt></td>
<td>
<font size="2"><b>Effect</b>
									</font></td>
</TR>
<TR VAlIGn="top">
<TD>
<fONT SIZe="2"><tt cLASS="monofont">c.begin()</tt>
									</foNT></TD>
<td>
<foNT SIze="2">Returns a bidirectional iterator for the first element (keys are considered <tt class="monofont">const</tt>)
</font></td>
</tr>
<tr VALIGN="top">
<tD>
<FoNT sIZE="2"><TT Class="monofont">c.end()</TT>
									</FOnt></td>
<TD>
<FOnt siZE="2">Returns a bidirectional iterator for the position after the last element (keys are considered <TT class="monofont">const</tt>)
</font></td>
</tr>
<tr valiGN="top">
<TD>
<FOnT SiZE="2"><tT CLASS="monofont">c.rbegin()</tt>
									</foNT></TD>
<td>
<foNT SIze="2">Returns a reverse iterator for the first element of a reverse iteration</foNT></TD>
</tr>
<tr valign="top">
<td>
<font size="2"><tT CLASS="monofont">c.rend()</tT>
									</FoNT></tD>
<TD>
<FONt sizE="2">Returns a reverse iterator for the position after the last element of a reverse iteration</FONt></td>
</tR>
</COLgrouP>
</TABle></p>

					<p>As for all associative container classes, the iterators are bidirectional (see <a href="0201379260_snode60.html#9">Section 7.2.4</a>, ). Thus, you can't use them in algorithms that are provided only for random access iterators (such as algorithms for sorting or random shuffling).</p>

					<p>More important is the constraint that the key of all elements inside a map and a multimap is considered to be constant. Thus, the type of the elements is <tt class="monofont">pair&lt;const Key, T&gt;.</tt> This is also necessary to ensure that you can't compromise the order of the elements by changing their keys. However, you can't call any modifying algorithm if the destination is a map or multimap. For example, you can't call the <TT CLASs="monofont">remove()</TT> algorithm to remove elements because it "removes" only by overwriting "removed" elements with the following arguments (see <a href="0201379260_snode39.html#4">Section 5.6.2</A>, for a detailed discussion of this problem). To remove elements in maps and multimaps, you can use only member functions provided by the container.</P>

					<P>The following is an example of the use of iterators:</P>

					<Pre>
						
   std::map&lt;std::string,float&gt; coll;
   ...
   std::map&lt;std::string,float&gt;::iterator pos;
   for (pos = coll.begin(); pos != coll.end(); ++pos) {
       std::cout &lt;&lt; "key: " &lt;&lt; pos-&gt;first &lt;&lt; "\t"
                 &lt;&lt; "value: " &lt;&lt; pos-&gt;second &lt;&lt; std::endl;
   }

					</prE>

					<P>Here, the iterator <TT clasS="monofont">pos</TT> iterates through the sequence of <Tt claSS="monofont">string/float</TT> pairs. The expression</p>

					<pre>
						
   pos-&gt;first

					</pre>

					<p>yields the key of the actual element, whereas the expression</p>

					<pre>
						
   pos-&gt;second

					</pre>

					<p>yields the value of the actual element.<font sIZE="1"><SUP><a HReF="#FOOTNOTE-27">[27]</A></sUP></FONT>
</p>
<bloCKQUote><fONT Size="1">
<p CLASs="footnote">
<sup><a name="FOOTNOTE-27">[27]</a></sup>
<tt class="monofont">pos-&gt;first</tT> is a shortcut for <TT CLAsS="monofont">(*pos).first.</Tt> Some old libraries might only provide the latter.</P>
</FoNT></BLOCkquoTE>

					<P>Trying to change the value of the key results in an error:</P>

					<pre>
						
   pos-&gt;first = "hello";   <i>// ERROR at compile time</I>

					</PRE>

					<p>However, changing the value of the element is no problem (as long as the type of the value is not constant):</p>

					<prE>
						
   pos-&gt;second = 13.5;     <I>// OK</I>

					</Pre>

					<p>To change the key of an element, you have only one choice: You must replace the old element with a new element that has the same value. Here is a generic function that does this:</p>

					<pre>
						
   <i>// cont/newkey.hpp</i>

   namespace MyLib {
       template &lt;class Cont&gt;
       inline
       bool replace_key (Cont&amp; c,
                         const typename Cont::key_type&amp; old_key,
                         const typename Cont::key_type&amp; new_key)
       {
           typename Cont::iterator pos;
           pos = c.find(old_key);
           if (pos != c.end()) {
               <i>//insert new element with value of old element</i>
               c.insert(typename Cont::value_type(new_key,
                                                  pos-&gt;second));
               <i>//remove old element</i>
               c.erase(pos);
               return true;
           }
           else {
               <i>//key not found</i>
               return false;
           }
       }
   }

					</pre>

					<p>The <tt CLASS="monofont">insert()</Tt> and <TT cLAsS="monofont">erase()</TT> member functions are discussed in the next subsection.</P>

					<P>To use this generic function you simply must pass the container the old key and the new key. For example:</P>

					<pre>
						
   std::map&lt;std::string,float&gt; coll;
   ...
   MyLib::replace_key(coll,"old key","new key");

					</pRE>

					<P>It works the same way for multimaps.</P>

					<p>Note that maps provide a more convenient way to modify the key of an element. Instead of calling <tt cLASS="monofont">replace_key(),</tt> you can simply write the following:</p>

					<pRE>
						
   <I>//insert new element with value of old element</I>
   coll["new_key"] = coll["old_key"];
   <i>//remove old element</i>
   coll.erase("old_key");

					</pre>

					<p>See <a href="0201379260_snode53.html#24">Section 6.6.3</a>, for details about the use of the subscript operator with maps.</p>

					
						<h5>Inserting and Removing Elements</h5>
						<p><a href="0201379260_snode53.html#22">Table 6.31</A> shows the operations provided for maps and multimaps to insert and remove elements.</P>

						<A NAMe="22"></A><P><tABlE BORDEr="1" celLSPAcing="0" CELLpaddING="1" Width="100%">
<caption><h5>Table 6.31. Insert and Remove Operations of Maps and Multimaps</h5></caption><cOLGROUp SPaN="2">
<Tr>
<TD>
<FONT size="2"><B>Operation</B>
										</FOnt></td>
<TD>
<FOnt siZE="2"><B>Effect</B>
										</font></td>
</tr>
<tr>
<td>
<font size="2"><tT CLASS="monofont">c.insert(elem)</tT></FoNT></tD>
<TD>
<FONt sizE="2">Inserts a copy of <TT Class="monofont">elem</TT> and returns the position of the new element and, for maps, whether it succeeded</FOnt></td>
</TR>
<TR>
<td>
<font size="2"><tt class="monofont">c.insert(pos,elem)</tt></foNT></TD>
<TD>
<fONt SIzE="2">Inserts a copy of elem and returns the position of the new element (<TT CLAss="monofont">pos</tt> is used as a hint pointing to where the insert should start the search)</FONT></td>
</tr>
<TR>
<TD>
<font SIZE="2"><tt class="monofont">c.insert(beg,end)</tt></font></td>
<td>
<font SIZE="2">Inserts a copy of all elements of the range [<TT cLAsS="monofont">beg,end</Tt>)(returns nothing)</FONT></TD>
</tr>
<tr>
<TD>
<FOnt siZE="2"><TT clasS="monofont">c.erase(elem)</TT></Font></td>
<td>
<font size="2">Removes all elements with value <tt clasS="monofont">elem</TT> and returns the number of removed elements</FONt></TD>
</tR>
<Tr>
<TD>
<FONT size="2"><TT CLass="monofont">c.erase(pos)</tT></FONt></td>
<tD>
<FONt size="2">Removes the element at iterator position <tt class="monofont">pos</tt> (returns nothing)</font></td>
</tR>
<TR>
<TD>
<FoNT sIZe="2"><TT CLASs="monofont">c.erase(beg,end)</tt></fONT></Td>
<td>
<fONT Size="2">Removes all elements of the range [<tT CLAss="monofont">beg,end</tt>)(returns nothing)</font></td>
</tr>
<tr>
<td>
<font sIZE="2"><TT ClASs="monofont">c.clear()</TT></fONT></TD>
<Td>
<fonT SIZe="2">Removes all elements (makes the container empty)</fonT></TD>
</Tr>
</colGROUp>
</table></p>

						<p>The remarks on page 182 regarding sets and multisets apply here. In particular, the return types of these operations have the same differences as they do for sets and multisets. However, note that the elements here are key/value pairs. So, the use is getting a bit more complicated.</p>

						<p>To insert a key/value pair, you must keep in mind that inside maps and multimaps the key is considered to be constant. You either must provide the correct type or you need to provide implicit or explicit type conversions. There are three different ways to pass a value into a map:</p>

						<ol type="1" starT="restarts">
<LI><P><B>Use</B>
									<b><TT cLAsS="monofont">value_type</TT></B></P>

								<P>To avoid implicit type conversion, you could pass the correct type explicitly by using <tt clASS="monofont">value_type,</Tt> which is provided as a type definition by the container type. For example:</p>

								<prE>
   std::map&lt;std::string,float&gt; coll;
   ...
   coll.insert(std::map&lt;std::string,float&gt;::value_type("otto",
                                                       22.3));

								</PRE>
</li>
<li><P><B>Use</B>
									<B><tt class="monofont">pair&lt;&gt;</tt></b></p>

								<p>Another way is to use <tt class="monofont">pair&lt;&gt;</tt> directly. For example:</P>

								<PRE>
   std::map&lt;std::string,float&gt; coll;
   ...
   <I>//use implicit conversion:</I>
   coll.insert(std::pair&lt;std::string,float&gt;("otto",22.3));
   <i>//use no implicit conversion:</I>
   coll.insert(std::pair&lt;const std::string,float&gt;("otto",22.3));

								</PrE>
<P>In the first <tT CLASS="monofont">insert()</tt> statement the type is not quite right, so it is converted into the real element type. For this to happen, the <tt CLASs="monofont">insert()</tt> member function is defined as a member template.<fONT Size="1"><sUP><A Href="#FOOTNOTE-28">[28]</a></sup></font>
</p>
<blockquotE><FONT SiZE="1">
<p CLaSS="footnote">
<SUP><A name="FOOTNOTE-28">[28]</A></SUP>
If your system does not provide member templates, you must pass an element with the correct type. This usually requires that you make the type conversions explicit.</p>
</fonT></BLOckquOTE>
</Li>
<li><p><b>Use</b>
									<b><tt class="monofont">make_pair()</tt></b></p>

								<p>Probably the most convenient way is to use the <tt CLASS="monofont">make_pair()</Tt> function (see page 36). This function produces a pair object that contains the two values passed as arguments:</P>

								<PrE>
   std::map&lt;std::string,float&gt; coll;
   ...
   coll.insert(std::make_pair("otto",22.3));

								</PrE>
<P>Again, the necessary type conversions are performed by the <TT CLass="monofont">insert()</tT> member template.</P>

							</LI>
</ol>

						<p>Here is a simple example of the insertion of an element into a map that also checks whether the insertion was successful:</p>

						<PRE>
							
   std::map&lt;std::string,float&gt; coll;
   ...
   if (coll.insert(std::make_pair("otto",22.3)).second) {
       std::cout &lt;&lt; "OK, could insert otto/22.3" &lt;&lt; std::endl;
   }
   else {
       std::cout &lt;&lt; "Oops, could not insert otto/22.3 "
                 &lt;&lt; "(key otto already exists)" &lt;&lt; std::endl;
   }

						</Pre>

						<p>See page 182 for a discussion regarding the return values of the <tT CLAss="monofont">insert()</tt> functions and more examples that also apply to maps. Note, again, that maps provide a more convenient way to insert (and set) elements with the subscript operator. This is discussed in <a href="0201379260_snode53.html#24">Section 6.6.3</a>.</p>

						<p>To remove an element that has a certain value, you simply call <tt class="monofont">erase():</tt></P>

						<PRE>
							
   std::map&lt;std::string,float&gt; coll;
   ...
   <I>//remove all elements with the passed key</I>
   coll.erase(key);

						</pRE>

						<p>This version of <TT cLASS="monofont">erase()</TT> returns the number of removed elements. When called for maps, the return value of <tt clASS="monofont">erase()</Tt> can only be <tt cLASS="monofont">0</tt> or <tt CLASs="monofont">1.</tt></p>

						<p>If a multimap contains duplicates, you can't use <tt class="monofont">erase()</tt> to remove only the first element of these duplicates. Instead, you could code as follows:</p>

						<pre>
							
   typedef multimap&lt;string.float&gt; StringFloatMMap;
   StringFloatMMap coll;
   ...
   <i>//remove first element with passed key</i>
   StringFloatMMap::iterator pos;
   pos = coll.find(key);
   if (pos != coll.end()) {
       coll.erase(pos);
   }

						</pRE>

						<P>You should use the member function <TT ClASs="monofont">find()</TT> instead of the <tT CLASS="monofont">find()</tt> algorithm here because it is faster (see an example with the <tt CLASs="monofont">find()</tt> algorithm on page 154). However, you can't use the <tT CLAss="monofont">find()</tt> member functions to remove elements that have a certain value (instead of a certain key). See page 198 for a detailed discussion of this topic.</P>

						<P>When removing elements, be careful not to saw off the branch on which you are sitting. There is a big danger that will you remove an element to which your iterator is referring. For example:</P>

						<Pre>
							
   typedef std::map&lt;std::string,float&gt; StringFloatMap;
   StringFloatMap coll;
   StringFloatMap::iterator pos;
   ...
   for (pos = coll.begin(); pos != coll.end(); ++pos) {
        if (pos-&gt;second == value) {
            coll. erase (pos);                   <i>// RUNTIME ERROR !!!</i>
        }
   }

						</pre>

						<p>Calling <tt class="monofont">erase()</tt> for the element to which you are referring with <tt clASS="monofont">pos</TT> invalidates <Tt CLaSS="monofont">pos</tT> as an iterator of <TT CLAss="monofont">coll.</tt> Thus, if you use <TT CLass="monofont">pos</tT> after removing its element without any reinitialization, then all bets are off. In fact, calling <TT Class="monofont">++pos</TT> results in undefined behavior.</P>

						<P>A solution would be easy if <tt class="monofont">erase()</tt> always returned the value of the following element:</p>

						<pre>
							
   typedef std::map&lt;std::string,float&gt; StringFloatMap;
   StringFloatMap coll;
   StringFloatMap::iterator pos;
   ...
   for (pos = coll.begin(); pos != coll.end(); ) {
       if (pos-&gt;second == value) {
           pos = coll.erase(pos);  <i>// would be fine, but COMPILE TIME ERROR</i>
       }
       else {
           ++pos;
       }
   }

						</pre>

						<p>It was a design decision not to provide this trait, because if not needed, it costs unnecessary time. I don't agree with this decision however, because code is getting more error prone and complicated (and may cost even more in terms of time).</p>

						<p>Here is an example of the correct way to remove elements to which an iterator refers:</P>

						<PRE>
							
   typedef std::map&lt;std::string,float&gt; StringFloatMap;
   StringFloatMap coll;
   StringFloatMap::iterator pos, tmp_pos;
   ...
   <I>//remove all elements having a certain value</I>
   for (pos = c.begin(); pos != c.end(); ) {
       if (pos-&gt;second == value) {
           c.erase(pos++);
       }
       else {
           ++pos;
       }
   }

						</pRE>

						<p>Note that <TT cLASS="monofont">pos++</TT> increments <tt clASS="monofont">pos</Tt> so that it refers to the next element but yields a copy of its original value. Thus, <tt cLASS="monofont">pos</tt> doesn't refer to the element that is removed when <tt CLASs="monofont">erase()</tt> is called.</p>

					
				
			
			<a name="24"></a><h4>6.6.3
Using Maps as Associative Arrays</h4>
				<p>Associative containers don't typically provide abilities for direct element access. Instead, you must use iterators. For maps, however, there is an exception to this rule. Nonconstant maps provide a subscript operator for direct element access (<a href="0201379260_snode53.html#25">Table 6.32</a>). However, the index of the subscript operator is not the integral position of the element. Instead, it is the key that is used to identify the element. This means that the index may have any type rather than only an integral type. Such an interface is the interface of a so-called <i>associative array.</i></P>

				<A NAME="25"></a><P><TaBLe BORDER="1" cellSPACing="0" cELLPaddiNG="1" WIdth="100%">
<caption><h5>Table 6.32. Direct Element Access of Maps with Operator [ ]</h5></caption><coLGROUP aLIgN="left" SpAN="2">
<TR VAlign="top">
<TD>
<FOnt siZE="2"><B>Operation</B>
								</font></TD>
<TD>
<font size="2"><b>Effect</b>
								</font></td>
</tr>
<tr vALIGN="top">
<Td>
<FOnT SiZE="2"><TT CLass="monofont">m[key]</tT>
								</FONt></td>
<tD>
<FONt sizE="2">Returns a reference to the value of the element with key <TT Class="monofont">key</tt> Inserts an element with <tt class="monofont">key</tt> if it does not yet exist
</font></td>
</TR>
</COLGrOUp>
</TAbLE></P>

				<P>The type of the index is not the only difference from ordinary arrays. In addition, you can't have a wrong index. If you use a key as the index, for which no element yet exists, a new element gets inserted into the map automatically. The value of the new element is initialized by the default constructor of its type. Thus, to use this feature you can't use a value type that has no default constructor. Note that the fundamental data types provide a default constructor that initializes their values to zero (see page 14).</P>

				<P>This behavior of an associative array has both advantages and disadvantages:</p>

				<ul>
<lI><P>The advantage is that you can insert new elements into a map with a more convenient interface.</P>

						<P>For example:</p>

						<pre>
   std::map&lt;std::string,float&gt; coll;     <I>// empty collection</I>
   /*<I>insert</I> "otto"/7.7 <i>as key/value pair</i>
    *-<i>first it inserts</i> "otto"/float()
    *-<I>then it assigns</I> 7.7
    */
   coll["otto"] = 7.7;

						</PRe>
<p>The statement</p>

						<pre>
   coll["otto"] = 7.7;

						</pre>

						<p>is processed here as follows:</p>

						<ol type="1" starT="restarts">
<LI><P>Process <TT cLAsS="monofont">coll["otto"]</Tt> expression:</P>

								<UL>
<LI><P>If an element with key <tt clASS="monofont">"otto"</Tt> exists, the expression returns the value of the element by reference.</p>

									</li>
<LI><P>If, as in this example, no element with key <Tt claSS="monofont">"otto"</TT> exists, the expression inserts a new element automatically with <tt class="monofont">"otto"</tt> as key and the value of the default constructor of the value type as the element value. It then returns a reference to that new value of the new element.</p>

									</li>
</ul>
							</li>
<li><p>Assign value <tt CLASS="monofont">7.7:</Tt></P>

								<Ul>
<LI><p>The second part of the statement assigns <TT CLASs="monofont">7.7</tt> to the value of the new or existing element.</p>

									</LI>
</UL>
							</li>
</ol>

						<P>The map then contains an element with key <TT Class="monofont">"otto"</TT> and value <TT class="monofont">7.7.</tt></p>

					</li>
<li><p>The disadvantage is that you might insert new elements by accident or mistake. For example, the following statement does something you probably hadn't intended or expected:</p>

						<pre>
   std::cout &lt;&lt; coll ["ottto"];
						</pre>
<p>It inserts a new element with key <TT CLASs="monofont">"ottto"</TT> and prints its value, which is <tT ClASS="monofont">0</TT> by default. However, it should have generated an error message telling you that you wrote <Tt claSS="monofont">"otto"</TT> incorrectly.</p>

						<p>Note, too, that this way of inserting elements is slower than the usual way for maps, which is described on page 202. This is because the new value is first initialized by the default value of its type, which is then overwritten by the correct value.</p>

					</lI>
</UL>
			
			<H4>6.6.4
Exception Handling</h4>
				<p>Maps and multimaps provide the same behavior as sets and multisets with respect to exception safety. This behavior is mentioned on page 185.</p>

			
			<h4>6.6.5
Examples of Using Maps and Multimaps</H4>
				<H5>Using a Map as an Associative Array</H5>
					<P>The following example shows the use of a map as an associative array. The map is used as a stock chart. The elements of the map are pairs in which the key is the name of the stock and the value is its price:</p>

					<pre>
						
   <i>// cont/mapl.cpp</i>

   #include &lt;iostream&gt;
   #include &lt;map&gt;
   #include &lt;string&gt;
   using namespace std;

   int main()
   {
       /*<i>create map/associative array</i>
        *-<i>keys are</i> string<i>s</i>
        *-<i>values are</i> float<i>s</i>
        */
       typedef map&lt;string,float&gt; StringFloatMap;

       StringFloatMap stocks;      <i>// create empty container</i>

       <i>//insert some elements</i>
       stocks["BASF"] = 369.50;
       stocks["VW"] = 413.50;
       stocks["Daimler"] = 819.00;
       stocks["BMW"] = 834.00;
       stocks["Siemens"] = 842.20;

       <i>//print all elements</I>
       StringFloatMap::iterator pos;
       for (pos = stocks.begin(); pos != stocks.end(); ++pos) {
           cout &lt;&lt; "stock: " &lt;&lt; pos-&gt;first &lt;&lt; "\t"
                &lt;&lt; "price: " &lt;&lt; pos-&gt;second &lt;&lt; endl;
       }
       cout &lt;&lt; endl;

       <I>//boom (all prices doubled)</I>
       for (pos = stocks.begin(); pos != stocks.end(); ++pos) {
           pos-&gt;second *= 2;
       }

       <I>//print all elements</I>
       for (pos = stocks.begin(); pos != stocks.end(); ++pos) {
           cout &lt;&lt; "stock: " &lt;&lt; pos-&gt;first &lt;&lt; "\t"
                &lt;&lt; "price: " &lt;&lt; pos-&gt;second &lt;&lt; endl;
       }
       cout &lt;&lt; endl;

       /*<I>rename key from</i> "VW" <I>to</I> "Volkswagen"
        *-<i>only provided by exchanging element</I>
        */
       stocks["Volkswagen"] = stocks["VW"];
       stocks.erase("VW");

       <I>//print all elements</i>
       for (pos = stocks.begin(); pos != stocks.end(); ++pos) {
           cout &lt;&lt; "stock: " &lt;&lt; pos-&gt;first &lt;&lt; "\t"
                &lt;&lt; "price: " &lt;&lt; pos-&gt;second &lt;&lt; endl;
       }
   }

					</PRE>

					<P>The program has the following output:</P>

					<Pre>
						
   stock: BASF price: 369.5
   stock: BMW price: 834
   stock: Daimler price: 819
   stock: Siemens price: 842.2
   stock: VW price: 413.5

   stock: BASF price: 739
   stock: BMW price: 1668
   stock: Daimler price: 1638
   stock: Siemens price: 1684.4
   stock: VW price: 827

   stock: BASF price: 739
   stock: BMW price: 1668
   stock: Daimler price: 1638
   stock: Siemens price: 1684.4
   stock: Volkswagen price: 827

					</prE>

				
				<H5>Using a Multimap as a Dictionary</H5>
					<P>The following example shows how to use a multimap as a dictionary:</p>

					<pre>
						
   <I>// cont/mmap1.cpp</I>

   #include &lt;iostream&gt;
   #include &lt;map&gt;
   #include &lt;string&gt;
   #include &lt;iomanip&gt;
   using namespace std;

   int main()
   {
       <I>//define multimap type as</I> string/string <i>dictionary</i>
       typedef multimap&lt;string,string&gt; StrStrMMap;

       <i>//create empty dictionary</i>
       StrStrMMap dict;

       <I>//insert some elements in random order</I>
       dict.insert(make_pair("day","Tag"));
       dict.insert(make_pair("strange","fremd"));
       dict.insert(make_pair("car","Auto"));
       dict.insert(make_pair("smart","elegant"));
       dict.insert(make_pair("trait","Merkmal"));
       dict.insert(make_pair("strange","seltsam"));
       dict.insert(make_pair("smart","raffiniert"));
       dict.insert(make_pair("smart","klug"));
       dict.insert(make_pair("clever","raffiniert"));

       <I>//print all elements</I>
       StrStrMMap::iterator pos;
       cout.setf (ios::left, ios::adjustfield);
       cout &lt;&lt; ' ' &lt;&lt; setw(10) &lt;&lt; "english "
            &lt;&lt; "german " &lt;&lt; endl; 
       cout &lt;&lt; setfil('-') &lt;&lt; setw(20) &lt;&lt; ""
            &lt;&lt; setfil(' ') &lt;&lt; endl;
       for (pos = dict.begin(); pos != dict.end(); ++pos) {
           cout &lt;&lt; ' ' &lt;&lt; setw(10) &lt;&lt; pos&gt;first.c_str()
                &lt;&lt; pos-&gt;second &lt;&lt; endl;
       }
       cout &lt;&lt; endl;

       <i>//print all values for key</i> "smart"
       string word("smart");
       cout &lt;&lt; word &lt;&lt; ": " &lt;&lt; endl;

       for (pos = dict.lower_bound(word);
            pos != dict.upper_bound(word); ++pos) {
               cout &lt;&lt; " " &lt;&lt; pos-&gt;second &lt;&lt; endl;
       }

       <i>//print all keys for value</i> "raffiniert"
       word = ("raffiniert");
       cout &lt;&lt; word &lt;&lt; ": " &lt;&lt; endl;
       for (pos = dict.begin(); pos != dict.end(); ++pos) {
           if (pos-&gt;second == word) {
               cout &lt;&lt; " " &lt;&lt; pos-&gt;first &lt;&lt; endl;
           }
       }
   }

					</pre>

					<p>The program has the following output:</p>

					<pre>
						
    english   german
   --------------------
    car       Auto
    clever    raffiniert
    day       Tag
    smart     elegant
    smart     raffiniert
    smart     klug
    strange   fremd
    strange   seltsam
    trait     Merkmal

   smart:
       elegant
       raffiniert
       klug
   raffiniert:
       clever
       smart

					</pre>

				
				<h5>Find Elements with Certain Values</h5>
					<p>The following example shows how to use the global <tt cLASS="monofont">find_if()</TT> algorithm to find an element with a certain value:</p>

					<PRe>
						
   <I>// cont/mapfind.cpp</I>

   #include &lt;iostream&gt;
   #include &lt;algorithm&gt;
   #include &lt;map&gt;
   using namespace std;

   /*<i>function object to check the value of a map element</I>
    */
   template &lt;class K, class V&gt;
   class value_equals {
     private:
       V value;
     public:
       <I>//constructor (initialize value to compare with)</I>
       value_equals (const V&amp; v)
        : value(v) {
       }
       <I>//comparison</I>
       bool operator() (pair&lt;const K, V&gt; elem) {
           return elem.second == value;
       }
   };

   int main()
   {
       typedef map&lt;float,float&gt; FloatFloatMap;
       FloatFloatMap coll;
       FloatFloatMap::iterator pos;

       <I>//fill container</i>
       coll[1]=7;
       coll[2]=4;
       coll[3]=2;
       coll[4]=3;
       coll[5]=6;
       coll[6]=1;
       coll[7]=3;

       <i>//search an element with key</i> 3.0
       pos = coll.find (3.0);                     <i>// logarithmic complexity</I>
       if (pos != coll.end()) {
           cout &lt;&lt; pos-&gt;first &lt;&lt; ": "
                &lt;&lt; pos-&gt;second &lt;&lt; endl;
       }

       <I>//search an element with value</I> 3.0
       pos = find_if (coll.begin(),coll.end(),    <I>// linear complexity</i>
                      value_equals&lt;float,float&gt;(3.0));
       if (pos != coll.end()) {
           cout &lt;&lt; pos-&gt;first &lt;&lt; ": "
                &lt;&lt; pos-&gt;second &lt;&lt; endl;
       }
   }

					</pre>

					<P>The output of the program is as follows:</P>

					<PRe>
						
   3: 2
   4: 3

					</pre>

				
			
			<H4>6.6.6
Example with Maps, Strings, and Sorting Criterion at Runtime</H4>
				<P>Here is another example. It is for advanced programmers rather than STL beginners. You can take it as an example of both the power and the snags of the STL. In particular, this example demonstrates the following techniques:</P>

				<ul>
<li><p>How to use maps</p>
</li>
<li><p>How to write and use function objects</p>
</li>
<li><p>How to define a sorting criterion at runtime</p>
</li>
<lI><P>How to compare strings in a case-insensitive way</P>

						<PRE>
   <i>// cont/mapcmp.cpp</I>

   #include &lt;iostream&gt;
   #include &lt;iomanip&gt;
   #include &lt;map&gt;
   #include &lt;string&gt;
   #include &lt;algorithm&gt;
   using namespace std;

   /*<I>function object to compare strings</i>
    *-<I>allows you to set the comparison criterion at runtime</I>
    *-<i>allows you to compare case insensitive</I>
    */
   class RuntimeStringCmp {
     public:
       <I>//constants for the comparison criterion</I>
       enum cmp_mode {normal, nocase};
     private:
       <I>//actual comparison mode</I>
       const cmp_mode mode;

       <I>//auxiliary function to compare case insensitive</i>
       static bool nocase_compare (char c1, char c2)
       {
           return toupper(c1) &lt; toupper(c2);
       }

     public:
       <i>//constructor: initializes the comparison criterion</i>
       RuntimeStringCmp (cmp_mode m=normal) : mode(m) {
       }

       <i>//the comparison</I>
       bool operator() (const string&amp; s1, const string&amp; s2) const {
           if (mode == normal) {
               return s1&lt;s2;
           }
           else {
               return lexicographical_compare (s1.begin(), s1.end(),
                                               s2.begin(), s2.end(),
                                               nocase_compare);
           }
       }
   };

   /*<I>container type:</I>
    *-<I>map with</i>
    *   -string <i>keys</i>
    *   -string <i>values</I>
    *   -<I>the special comparison object type</I>
    */
   typedef map&lt;string,string,RuntimeStringCmp&gt; StringStringMap;

   <I>//function that fills and prints such containers</i>
   void fillAndPrint(StringStringMap&amp; coll);

   int main()
   {
       <i>//create a container with the default comparison criterion</i>
       StringStringMap coll1;
       fillAndPrint(coll1);

       <i>//create an object for case-insensitive comparisons</I>
       RuntimeStringCmp ignorecase (RuntimeStringCmp::nocase);

       <I>//create a container with the case-insensitive comparisons criterion</I>
       StringStringMap coll2 (ignorecase);
       fillAndPrint (coll2);
   }

   void fillAndPrint (StringStringMap&amp; coll)
   {
       <I>//fill insert elements in random order</i>
       coll["Deutschland"] = "Germany";
       coll["deutsch"] = "German";
       coll["Haken"] = "snag";
       coll["arbeiten"] = "work";
       coll["Hund"] = "dog";
       coll["gehen"] = "go";
       coll["Unternehmen"] = "enterprise";
       coll["unternehmen"] = "undertake";
       coll["gehen"] = "walk";
       coll["Bestatter"] = "undertaker";

       <i>//print elements</i>
       StringStringMap::iterator pos;
       cout.setf(ios::left, ios::adjustfield);
       for (pos=coll.begin(); pos!=coll.end(); ++pos) {
           cout &lt;&lt; setw(15) &lt;&lt; pos-&gt;first.c_str() &lt;&lt; " "
                &lt;&lt; pos-&gt;second &lt;&lt; endl;
       }
       cout &lt;&lt; endl;
   }
						</pre>
</li>
</ul>
				<p><tt class="monofont">main()</tt> creates two containers and calls <tT CLASS="monofont">fillAndPrint()</tT> for them. <Tt CLaSS="monofont">fillAndPrint()</TT> fills the containers with the same elements and prints the contents of them. However, the containers have two different sorting criteria:</P>

				<Ol typE="1" STArt="restarts">
<li><P><TT Class="monofont">coll1</TT> uses the default function object of type <TT class="monofont">RuntimeStringCmp,</tt> which compares the elements by using operator <tt class="monofont">&lt;.</tt></p>
</li>
<li><P><TT CLAsS="monofont">coll2</Tt> uses a function object of type <TT cLASS="monofont">RuntimeStringCmp</TT> that is initialized by value <tt clASS="monofont">nocase</Tt> of class <tt cLASS="monofont">RuntimeStringCmp. nocase</tt> forces this function object to sort strings in a case-insensitive way.</p>

					</lI>
</OL>

				<P>The program has the following output:</p>

				<pre>
					
   Bestatter        undertaker
   Deutschland      Germany
   Haken            snag
   Hund             dog
   Unternehmen      enterprise
   arbeiten         work
   deutsch          German
   gehen            walk
   unternehmen      undertake

   arbeiten         work
   Bestatter        undertaker
   deutsch          German
   Deutschland      Germany
   gehen            walk
   Haken            snag
   Hund             dog
   Unternehmen      undertake

				</pre>

				<p>The first block of the output prints the contents of the first container that compares with operator <tt class="monofont">&lt;.</tt> The output starts with all uppercase keys followed by all lowercase keys.</p>

				<p>The second block prints all case-insensitive items, so the order changed. But note, the second block has one item less. This is because the uppercase word <tt CLASS="monofont">"Unternehmen"</Tt> is, from a case-insensitive point of view, equal to the lowercase word <TT cLAsS="monofont">"unternehmen,"</TT><FONt sizE="1"><SUP><a hreF="#FOOTNOTE-29">[29]</A></SUp></fonT>
 and we use a map that does not allow duplicates according to its comparison criterion. Unfortunately the result is a mess because the German key that is the translation for "enterprise" got the value "undertake." So probably a multimap should be used here. This makes sense because a multimap is the typical container for dictionaries.</P>
<BLockquote><font size="1">
<p clasS="footnote">
<SUP><A NaME="FOOTNOTE-29">[29]</a></SUp>
In German all nouns are written with an initial capital letter whereas all verbs are written in lowercase letters.</P>
</FONT></BlockQUOTe>

			
		</fonT>
 
<table width="100%" border="0" cellspacing="0" cellpadding="0" bgcolor="#CCCCCC">
<td><font color="black" size=1>I l<font color="#FF0000">@</font>ve RuBoard</td>
<td valign="top" class="v2" align="right"><a href="0201379260_snode52.html"><img src="FILES/previous.gif" width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a> <a href="0201379260_snode54.html"><img src="FILES/next.gif" width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a></td></table>
</BODY></HTML>