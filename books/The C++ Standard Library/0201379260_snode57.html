<HTML><HEAD><META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=iso-8859-1">
<!--SafClassName="docSection1Title"--><!--SafTocEntry="6.10 Container Types and Members in Detail"-->
<LINK REL="stylesheet" href="FILES/sbolM.css">
</HEAD>
<BODY link="#354278" vlink="#000066" alink="#000080" topmargin="0">
<table width="100%" border="0" cellspacing="0" cellpadding="0" bgcolor="#CCCCCC">
<td><font color="black" size=1>I l<font color="#FF0000">@</font>ve RuBoard</td>
<td valign="top" class="v2" align="right"><a href="0201379260_snode56.html"><img src="FILES/previous.gif" width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a> <a href="0201379260_cnode58.html"><img src="FILES/next.gif" width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a></td></table>
<FONT><h3>6.10
Container Types and Members in Detail</h3>
			<p>This section discusses the different STL containers and presents all of the operations that STL containers provide. The types and members are grouped by functionality. For each type and operation this section describes the signature, the behavior, and the container types that provide it. Possible containers are vector, deques, lists, sets, multisets, maps, multimaps, and strings. In the following subsections, <i>container</I> means the container type that provides the member.</P>

			<H4>6.10.1
Type Definitions</H4>
				<p><i>container::</i><b>value_type</B></P>

				<UL>
<li><p>The type of elements.</p>
</LI>
<LI><p>For sets and multisets, it is constant.</p>
</li>
<li><p>For maps and multimaps, it is <tt class="monofont">pair &lt;const</tt>
							<i>key-type, value-type&gt;</i></p>
</li>
<LI><P>Provided by vectors, deques, lists, sets, multisets, maps, multimaps, and strings.</P>

					</LI>
</uL>
				<P><i>container::</I><B>reference</b></P>

				<UL>
<LI><P>The type of element references.</p>
</li>
<lI><P>Typically: <I>container::</I><tt clASS="monofont">value_type&amp;.</Tt></p>
</li>
<LI><P>For <Tt class="monofont">vector&lt;bool&gt;,</tt> it is an auxiliary class (see page 158).</p>
</li>
<li><p>Provided by vectors, deques, lists, sets, multisets, maps, multimaps, and strings.</p>

					</li>
</ul>
				<p><i>container::</I><B>const_reference</B></P>

				<UL>
<lI><P>The type of constant element references.</p>
</LI>
<lI><P>Typically: <TT CLass="monofont">const</tT>
							<I>container::</I><Tt claSS="monofont">value_type&amp;.</TT></p>
</li>
<lI><P>For <TT class="monofont">vector&lt;bool&gt;,</tt> it is <tt class="monofont">bool.</tt></p>
</li>
<li><P>Provided by vectors, deques, lists, sets, multisets, maps, multimaps, and strings.</P>

					</LI>
</UL>
				<p><I>container::</I><b>iterator</B></P>

				<uL>
<LI><P>The type of iterators.</P>
</Li>
<li><p>Provided by vectors, deques, lists, sets, multisets, maps, multimaps, and strings.</P>

					</LI>
</Ul>
				<p><i>container::</i><B>const_iterator</B></P>

				<Ul>
<li><p>The type of constant iterators.</P>
</LI>
<Li><p>Provided by vectors, deques, lists, sets, multisets, maps, multimaps, and strings.</p>

					</li>
</ul>
				<p><i>container::</i><b>reverse_iterator</b></p>

				<ul>
<li><p>The type of reverse iterators.</p>
</li>
<LI><P>Provided by vectors, deques, lists, sets, multisets, maps, and multimaps.</P>

					</LI>
</uL>
				<P><i>container::</I><B>const_reverse_iterator</b></P>

				<UL>
<LI><P>The type of constant reverse iterators.</p>
</li>
<lI><P>Provided by vectors, deques, lists, sets, multisets, maps, multimaps, and strings.</P>

					</Li>
</ul>
				<p><I>container::</I><B>size_type</B></p>

				<ul>
<lI><P>The unsigned integral type for size values.</P>
</Li>
<li><p>Provided by vectors, deques, lists, sets, multisets, maps, multimaps, and strings.</p>

					</li>
</ul>
				<p><i>container::</i><b>difference_type</b></p>

				<ul>
<li><p>The signed integral type for difference values.</p>
</LI>
<LI><P>Provided by vectors, deques, lists, sets, multisets, maps, multimaps, and strings.</P>

					</lI>
</Ul>
				<P><I>container::</i><B>key_type</B></P>

				<UL>
<Li><p>The type of the key of the elements for associative containers.</p>
</lI>
<LI><P>For sets and multisets, it is equivalent to <tt clASS="monofont">value_type.</Tt></p>
</li>
<LI><P>Provided by sets, multisets, maps, and multimaps.</P>

					</li>
</ul>
				<p><i>container::</i><b>mapped_type</b></p>

				<ul>
<li><p>The type of the value of the elements of associative containers.</p>
</li>
<li><p>Provided by maps and multimaps.</P>

					</LI>
</UL>
				<P><i>container::</I><B>key_compare</b></P>

				<Ul>
<LI><P>The type of the comparison criterion of associative containers.</P>
</LI>
<li><p>Provided by sets, multisets, maps, and multimaps.</p>

					</LI>
</UL>
				<p><i>container::</i><b>value_compare</B></P>

				<UL>
<li><p>The type of the comparison criterion for the whole element type.</p>
</LI>
<LI><p>For sets and multisets, it is equivalent to <tt class="monofont">key_compare.</tt></p>
</li>
<li><p>For maps and multimaps, it is an auxiliary class for a comparison criterion that compares only the key part of two elements.</p>
</li>
<li><P>Provided by sets, multisets, maps, and multimaps.</P>

					</LI>
</UL>
				<p><I>container::</I><b>allocator_type</B></P>

				<uL>
<LI><P>The type of the allocator.</P>
</Li>
<li><p>Provided by vectors, deques, lists, sets, multisets, maps, multimaps, and strings.</P>

					</LI>
</Ul>
			
			<h4>6.10.2
Create, Copy, and Destroy Operations</h4>
				<p>Containers provide the following constructors and destructors. Also, most constructors allow you to pass an allocator as an additional argument (see <A href="0201379260_snode57.html#17">Section 6.10.9</a>).</p>

				<p><I>container::container ()</I></P>

				<Ul>
<li><p>The default constructor.</p>
</li>
<li><p>Creates a new empty container.</p>
</li>
<li><p>Provided by vectors, deques, lists, sets, multisets, maps, multimaps, and strings.</p>

					</li>
</ul>
				<P><TT CLAsS="monofont">explicit</Tt>
					<I>container::container</I> (<tT CLASS="monofont">const CompFunc&amp;</tt>
					<i>op</i>)</P>

				<UL>
<Li><p>Creates a new empty container with <i>op</i> used as the sorting criterion (see page 191 and page 213 for examples).</P>
</LI>
<Li><p>The sorting criterion must define a "strict weak ordering" (see page 176).</p>
</lI>
<LI><P>Provided by sets, multisets, maps, and multimaps.</p>

					</li>
</ul>
				<p><tt class="monofont">explicit</tt>
					<i>container::</i><i>container</i> (<tt CLASS="monofont">const</Tt>
					<I>container&amp;, c</I>)</p>

				<UL>
<lI><P>The copy constructor.</P>
</LI>
<Li><p>Creates a new container as a copy of the existing container <i>c.</i></P>
</LI>
<Li><p>Calls the copy constructor for every element in <i>c.</i></P>
</LI>
<Li><p>Provided by vectors, deques, lists, sets, multisets, maps, multimaps, and strings.</p>

					</lI>
</UL>
				<P><tt class="monofont">explicit</tt>
					<i>container::container</i> (<tt class="monofont">size_type</tt>
					<i>num</I>)</P>

				<UL>
<LI><p>Creates a container with <I>num</I> elements.</p>
</LI>
<lI><P>The elements are created with their default constructor.</P>
</LI>
<Li><p>Provided by vectors, deques, and lists.</p>

					</lI>
</UL>
				<P><i>container::</i><i>container</i> (<TT CLass="monofont">size_type</tT>
					<I>num,</I>
					<Tt class="monofont">const T&amp;</tt>
					<i>value</i>)</p>

				<ul>
<li><p>Creates a container with <i>num</i> elements.</p>
</li>
<LI><P>The elements are created as copies of <I>value.</I></P>
</lI>
<Li><P><Tt CLASS="monofont">T</Tt> is the type of the container elements.</p>
</li>
<LI><P>For strings, <I>value</i> is not passed by reference.</p>
</li>
<LI><P>Provided by vectors, deques, lists, and strings.</P>

					</li>
</ul>
				<P><I>container::</I><I>container</i> (<tt class="monofont">InputIterator</tt>
					<i>beg,</i>
					<tt class="monofont">InputIterator</tt>
					<I>end</I>)</P>

				<UL>
<Li><P>Creates a container that is initialized by all elements of the range <I>[beg,end).</i></P>
</Li>
<LI><P>This function is a member template (see page 11). Thus, the elements of the source range may have any type that is convertible to the element type of the container.</P>
</LI>
<li><p>Provided by vectors, deques, lists, sets, multisets, maps, multimaps, and strings.</p>

					</LI>
</UL>
				<p><i>container::</i><i>container</I> (<TT Class="monofont">InputIterator</TT>
					<I>beg,</I>
					<tt class="monofont">InputIterator</tt>
					<i>end,</i>
					<tt class="monofont">const CompFunc&amp;</tt>
					<i>op</I>)</P>

				<UL>
<LI><p>Creates a container that has the sorting criterion <I>op</I> and is initialized by all elements of the range <i>[beg,end).</I></P>
</lI>
<LI><P>This function is a member template (see page 11). Thus, the elements of the source range may have any type that is convertible to the element type of the container.</P>
</Li>
<li><p>The sorting criterion must define a "strict weak ordering" (see page 176).</P>
</LI>
<Li><p>Provided by sets, multisets, maps, and multimaps.</p>

					</lI>
</UL>
				<P><i>container::</i><i><sUP>~</SUp>container</i>
					<tt class="monofont">()</tt></p>

				<ul>
<li><p>The destructor.</p>
</li>
<lI><P>Removes all elements and frees the memory.</P>
</LI>
<Li><P>Calls the destructor for every element.</P>
</lI>
<Li><P>Provided by vectors, deques, lists, sets, multisets, maps, multimaps, and strings.</P>

					</LI>
</UL>
			
			<h4>6.10.3
Nonmodifying Operations</h4>
				<h5>Size Operations</h5>
					<P><TT Class="monofont">size_type</TT>
						<I>container::</I><b>size</b>
						<tt CLASs="monofont">() const</tt></p>

					<ul>
<li><p>Returns the actual number of elements.</p>
</li>
<li><p>To check whether the container is empty (contains no elements), you should use <tt clasS="monofont">empty()</TT> because it may be faster.</P>
</LI>
<lI><P>Provided by vectors, deques, lists, sets, multisets, maps, multimaps, and strings.</p>

						</LI>
</uL>
					<P><TT CLass="monofont">bool</tT>
						<I>container::</I><B>empty</b>
						<tt cLASS="monofont">() const</tt></p>

					<uL>
<LI><P>Returns whether the container is empty (contains no elements).</p>
</li>
<li><p>It is equivalent to <i>container::</i>
								<tt class="monofont">size()==0,</tt> but it may be faster (especially for lists).</p>
</li>
<lI><P>Provided by vectors, deques, lists, sets, multisets, maps, multimaps, and strings.</P>

						</LI>
</Ul>
					<P><Tt CLaSS="monofont">size_type</TT>
						<I>container::</I><b>max_size</b>
						<tt CLASs="monofont">() const</tt></p>

					<UL>
<LI><p>Returns the maximum number of elements a container may contain.</p>
</li>
<LI><P>This is a technical value that may depend on the memory model of the container. In particular, because vectors usually use one memory segment, this value may be less than for other containers.</P>
</li>
<li><p>Provided by vectors, deques, lists, sets, multisets, maps, multimaps, and strings.</p>

						</li>
</ul>
				
				<h5>Capacity Operations</h5>
					<p><tt class="monofont">size_type</tT>
						<I>container::</I><B>capacity</B>
						<Tt CLaSS="monofont">() const</tT></P>

					<UL>
<LI><p>Returns the number of elements the container may contain without reallocation.</p>
</li>
<LI><P>Provided by vectors and strings.</P>

						</li>
</ul>
					<P><TT Class="monofont">void</TT>
						<I>container::</I><b><i>reserve</i></b> (<tt class="monofont">size_type</tt>
						<i>num</i>)</p>

					<ul>
<li><p>Reserves internal memory for at least <I>num</I> elements.</P>
</LI>
<Li><P>If <I>num</i> is less than the actual capacity, this call has no effect on vectors and is a nonbinding shrink request for strings.</P>
</Li>
<LI><P>To shrink the capacity of vectors, see the example on page 149.</P>
</LI>
<li><p>Each reallocation invalidates all references, pointers, and iterators, and takes some time. Thus <tT CLAss="monofont">reserve()</tt> can increase speed and keep references, pointers, and iterators valid (see page 149 for details).</P>
</LI>
<Li><p>Provided by vectors and strings.</p>

						</lI>
</UL>
				
				<H5>Comparison Operations</h5>
					<p><tt class="monofont">bool</tt>
						<b><i>comparison</i></b> (<tt clasS="monofont">const</TT>
						<I>container&amp; c1,</I>
						<Tt CLaSS="monofont">const</tT>
						<I>container</I>&amp;<I>,</I> c2)</P>

					<ul>
<li><P>Returns the result of the comparison of two containers of same type.</P>
</LI>
<li><p><b><I>comparison</I></B> might be any of the following:</P>

							<pre>
   operator ==
   operator !=
   operator &lt;
   operator &gt;
   operator &lt;=
   operator &gt;=

							</pRE>
</LI>
<li><p>Two containers are equal if they have the same number of elements and contain the same elements in the same order (all comparisons of two corresponding elements have to yield <tt class="monofont">true</tt>).</p>
</li>
<li><p>To check whether a container is less than another container, the containers are compared lexicographically. See the description of the <tt cLASS="monofont">lexicographical_compare()</TT> algorithm on page 360 for a description of lexicographical comparison.</p>
</LI>
<lI><P>Provided by vectors, deques, lists, sets, multisets, maps, multimaps, and strings.</p>

						</LI>
</UL>
				
				<H5>Special Nonmodifying Operations for Associative Containers</H5>
					<p>The member functions mentioned here are special implementations of corresponding STL algorithms that are discussed in <a href="0201379260_snode75.html">Section 9.5</A> and <A href="0201379260_snode78.html">Section 9.9</A>. They provide better performance because they rely on the fact that the elements of associative containers are sorted. In fact, they provide logarithmic complexity instead of linear complexity. For example, to search for one of 1,000 elements, no more than ten comparisons on average are needed (see <A href="0201379260_snode15.html">Section 2.3</a>).</p>

					<P><TT Class="monofont">size_type</tt>
						<i>container::</i><b>count</b> (<tt class="monofont">const T&amp;</tt>
						<i>value</i>) <TT CLASs="monofont">const</TT></p>

					<UL>
<lI><P>Returns the number of elements that are equal to <I>value.</I></P>
</Li>
<li><p>This is the special version of the <TT CLass="monofont">count()</tT> algorithm discussed on page 338.</P>
</LI>
<li><p><tT CLAss="monofont">T</tt> is the type of the sorted value:</p>

							<ul>
<li><p>For sets and multisets, it is the type of the elements.</p>
</li>
<li><p>For maps and multimaps, it is the type of the keys.</p>
</li>
</ul>
						</LI>
<LI><P>Complexity: linear.</P>
</lI>
<Li><P>Provided by sets, multisets, maps, and multimaps.</P>

						</lI>
</UL>
					<P><TT clasS="monofont">iterator</TT>
						<I>container::</i><b>find</b> (<tT CLAss="monofont">const T&amp;</tt>
						<I>value</I>)</P>

					<P><tt class="monofont">const_iterator</tt>
						<i>container::</i><b>find</b> (<tt class="monofont">const T&amp;</tT>
						<I>value</I>) <TT ClASs="monofont">const</TT></p>

					<UL>
<LI><P>Both return the position of the first element that has a value equal to <I>value.</i></p>
</li>
<LI><P>They return <Tt claSS="monofont">end()</TT> if no element is found.</p>
</li>
<lI><P>These are the special versions of the <TT class="monofont">find()</tt> algorithm discussed on page 341.</p>
</li>
<li><p><tt class="monofont">T</tT> is the type of the sorted value:</P>

							<UL>
<LI><p>For sets and multisets, it is the type of the elements.</P>
</Li>
<LI><p>For maps and multimaps, it is the type of the keys.</P>
</LI>
</UL>
						</Li>
<li><p>Complexity: logarithmic.</P>
</LI>
<Li><p>Provided by sets, multisets, maps, and multimaps.</p>

						</lI>
</UL>
					<P><tt clASS="monofont">iterator</Tt>
						<i>container::</i><b>lower_bound</b> (<tt class="monofont">const T&amp;</tt>
						<i>value</i>)</p>

					<p><tt cLASS="monofont">const_iterator</TT>
						<i>container::</I><B>lower_bound</b> (<TT cLASS="monofont">const T&amp;</TT>
						<i>value</i>) <tt CLASs="monofont">const</tt></p>

					<UL>
<LI><p>Both return the first position where a copy of <i>value</i> would get inserted according to the sorting criterion.</p>
</LI>
<LI><p>They return <tt class="monofont">end()</tt> if no such element is found.</p>
</li>
<li><p>The return value is the position of the first element that has a value less than or equal to <i>value</i> (which might be <tt cLASS="monofont">end()</TT>).</p>
</LI>
<lI><P>These are the special versions of the <tT CLASS="monofont">lower_bound()</tt> algorithm discussed on page 413.</p>
</lI>
<LI><P><tt clASS="monofont">T</Tt> is the type of the sorted value:</p>

							<ul>
<LI><P>For sets and multisets, it is the type of the elements.</P>
</li>
<li><p>For maps and multimaps, it is the type of the keys.</p>
</li>
</ul>
						</li>
<li><p>Complexity: logarithmic.</p>
</li>
<li><p>Provided by sets, multisets, maps, and multimaps.</P>

						</LI>
</UL>
					<P><tT ClASs="monofont">iterator</TT>
						<I>container::</I><B>upper_bound</B> (<tt clASS="monofont">const T&amp;</Tt>
						<i>value</i>)</p>

					<P><TT Class="monofont">const_iterator</TT>
						<I>container::</I><b>upper_bound</b> (<tt class="monofont">const T&amp;</tt>
						<i>value</i>) <tt class="monofont">const</tT></P>

					<UL>
<LI><p>Both return the last position where a copy of <I>value</I> would get inserted according to the sorting criterion.</p>
</LI>
<lI><P>They return <TT CLass="monofont">end()</tT> if no such element is found.</P>
</LI>
<li><p>The return value is the position of the first element that has a value greater than <i>value</I> (which might be <TT Class="monofont">end()</TT>).</P>
</Li>
<li><p>These are the special versions of the <tt class="monofont">upper_bound()</tt> algorithm discussed on page 413.</p>
</li>
<li><p><tt CLASS="monofont">T</Tt> is the type of the sorted value:</P>

							<Ul>
<LI><p>For sets and multisets, it is the type of the elements.</P>
</LI>
<LI><P>For maps and multimaps, it is the type of the keys.</p>
</li>
</uL>
						</LI>
<Li><p>Complexity: logarithmic.</p>
</lI>
<LI><P>Provided by sets, multisets, maps, and multimaps.</p>

						</li>
</uL>
					<P><TT class="monofont">pair&lt;iterator,iterator&gt;</tt>
						<i>container::</i><b>equal_range</b> (<tt class="monofont">const T&amp;</tt>
						<i>value</I>)</P>

					<P><TT ClASs="monofont">pair&lt;const_iterator,const_iterator&gt;</TT>
						<i>container::</I><B>equal_range</B> (<TT Class="monofont">const T&amp;</TT>
						<I>value</I>) <tt clASS="monofont">const</Tt></p>

					<ul>
<LI><P>Both return a pair with the first and last positions where a copy of <I>value</i> would get inserted according to the sorting criterion.</p>
</li>
<li><p>The return value is the range of elements equal to <i>value.</i></p>
</li>
<li><p>They are equivalent to:</p>

							<pre>
   make_pair (lower_bound(<i>value</i>),upper_bound(<I>value</I>))
							</PRE>
</Li>
<LI><p>These are the special versions of the <TT cLASS="monofont">equal_range()</TT> algorithm discussed on page 415.</p>
</li>
<lI><P><TT clasS="monofont">T</TT> is the type of the sorted value:</P>

							<ul>
<li><P>For sets and multisets, it is the type of the elements.</P>
</LI>
<li><p>For maps and multimaps, it is the type of the keys.</p>
</li>
</ul>
						</li>
<li><p>Complexity: logarithmic.</p>
</li>
<li><p>Provided by sets, multisets, maps, and multimaps.</p>

						</lI>
</UL>
					<P><TT cLAsS="monofont">key_compare</Tt>
						<I>container::</I><B>key_comp</B>
						<TT clasS="monofont">()</TT></P>

					<ul>
<li><P>Returns the comparison criterion.</P>
</LI>
<li><p>Provided by sets, multisets, maps, and multimaps.</p>

						</LI>
</UL>
					<p><tt class="monofont">value_compare</tt>
						<i>container::</i><b>value_comp</b>
						<tt class="monofont">()</TT></P>

					<UL>
<Li><P>Returns the object that is used as the comparison criterion.</P>
</lI>
<Li><P>For sets and multisets, it is equivalent to <TT CLAss="monofont">key_comp ().</tt></P>
</LI>
<Li><p>For maps and multimaps, it is an auxiliary class for a comparison criterion that compares only the key part of two elements.</p>
</lI>
<LI><P>Provided by sets, multisets, maps, and multimaps.</p>

						</li>
</uL>
				
			
			<H4>6.10.4
Assignments</H4>
				<P><i>container&amp; container::</i><b>operator=</b> (<tt class="monofont">const</tt>
					<i>container&amp; c</i>)</p>

				<ul>
<li><p>Assigns all elements of <I>c;</I> that is, it replaces all existing elements with copies of the elements of <I>c.</I></P>
</Li>
<LI><p>The operator may call the assignment operator for elements that have been overwritten, the copy constructor for appended elements, and the destructor of the element type for removed elements.</P>
</Li>
<LI><P>Provided by vectors, deques, lists, sets, multisets, maps, multimaps, and strings.</P>

					</LI>
</ul>
				<p><tT CLAss="monofont">void</tt>
					<I>container::</I><B>assign</B> (<tt clASS="monofont">size_type</Tt>
					<i>num,</i>
					<tt class="monofont">const T&amp; value</tt>)</p>

				<ul>
<li><p>Assigns <i>num</i> occurrences of <i>value;</I> that is, it replaces all existing elements by <I>num</I> copies of <I>value.</I></P>
</lI>
<Li><P><Tt CLASS="monofont">T</Tt> has to be the element type.</p>
</li>
<LI><P>Provided by vectors, deques, lists, and strings.</P>

					</li>
</ul>
				<P><TT Class="monofont">void</TT>
					<I>container::</I><b>assign</b> (<tt class="monofont">InputIterator</tt>
					<i>beg,</i>
					<tt class="monofont">Inputlterator</tT>
					<I>end</I>)</P>

				<UL>
<lI><P>Assigns all elements of the range <i>[beg,end);</I> that is, it replaces all existing elements with copies of the elements of <I>[beg,end).</i></P>
</LI>
<LI><P>This function is a member template (see page 11). Thus, the elements of the source range may have any type that is convertible to the element type of the container.</p>
</li>
<lI><P>Provided by vectors, deques, lists, and strings.</P>

					</Li>
</ul>
				<p><TT CLass="monofont">void</tT>
					<I>container::</I><B>swap</b> (<i>container&amp; c</i>)</p>

				<ul>
<li><p>Swaps the contents with <i>c.</i></p>
</li>
<li><p>Both containers swap</p>

						<ul>
<lI><P>their elements and</P>
</LI>
<Li><P>their sorting criterion if any.</P>
</lI>
</Ul>
					</LI>
<LI><P>This function has a constant complexity. You should always prefer it over an assignment when you no longer need the assigned object (see <A href="0201379260_snode48.html#2">Section 6.1.2</A>).</P>
</LI>
<li><p>For associative containers, the function may only throw if copying or assigning the comparison criterion may throw. For all other containers, the function does not throw.</p>
</LI>
<LI><p>Provided by vectors, deques, lists, sets, multisets, maps, multimaps, and strings.</p>

					</li>
</UL>
				<P><Tt class="monofont">void</tt>
					<b>swap</b> (<i>container&amp; c1, container&amp;, c2</i>)</p>

				<ul>
<li><p>It is equivalent to <i>c1.</i>
							<tT CLASS="monofont">swap</tT><I>(c2)</i> (see the previous description).</P>
</Li>
<LI><P>For associative containers, the function may only throw if copying or assigning the comparison criterion may throw. For all other containers, the function does not throw.</P>
</LI>
<li><p>Provided by vectors, deques, lists, sets, multisets, maps, multimaps, and strings.</p>

					</LI>
</UL>
			
			<h4>6.10.5
Direct Element Access</h4>
				<p><tT CLAss="monofont">reference</tt>
					<I>container::</I><B>at</B> (<tt class="monofont">size_type</tt>
					<i>idx</i>)</p>

				<p><tt class="monofont">const_reference</tT>
					<I>container::</I><B>at</B> (<Tt CLaSS="monofont">size_type</tT>
					<I>idx</I>) <TT Class="monofont">const</TT></P>

				<Ul>
<li><p>Both return the element with the index <I>idx</I> (the first element has index <TT clasS="monofont">0</TT>).</P>
</li>
<li><p>Passing an invalid index (less than <tt class="monofont">0</tt> or equal to <tt class="monofont">size()</TT> or greater than <TT CLaSS="monofont">size()</tT>) throws an <Tt CLASS="monofont">out_of _range</Tt> exception.</p>
</li>
<LI><P>Note that the returned reference may get invalidated due to later modifications or reallocations.</P>
</li>
<li><P>If you are sure that the index is valid, you can use operator <TT Class="monofont">[ ],</TT> which is faster.</P>
</Li>
<li><p>Provided by vectors, deques, and strings.</p>

					</li>
</ul>
				<p><tt class="monofont">reference</tt>
					<i>container::</i><B>operator [ ]</B> (<TT CLaSS="monofont">size_type</tT>
					<I>idx</i>)</P>

				<P><TT CLass="monofont">const_reference</tT>
					<I>container::</I><B>operator [ ]</b> (<tt cLASS="monofont">size_type</tt>
					<i>idx</i>) <TT CLass="monofont">const</tt></p>

				<ul>
<li><p>Both return the element with the index <i>idx</i> (the first element has index <tt class="monofont">0</tT>).</P>
</LI>
<LI><p>Passing an invalid index (less than <TT cLAsS="monofont">0</TT> or equal to <TT Class="monofont">size()</TT> or greater than <TT clasS="monofont">size()</TT>) results in undefined behavior. Thus, the caller must ensure that the index is valid; otherwise, <Tt claSS="monofont">at()</TT> should be used.</p>
</li>
<li><p>The reference returned for the nonconstant string may get invalidated due to string modifications or reallocations (see page 487 for details).</p>
</li>
<li><p>Provided by vectors, deques, and strings.</p>

					</li>
</ul>
				<p><tt cLASS="monofont">T&amp;</TT>
					<i>map::</I><B>operator []</b> (<TT cLASS="monofont">const key_type&amp;</TT>
					<i>key</i>)</p>

				<uL>
<LI>
						<P>Operator <tt clASS="monofont">[ ]</Tt> for associative arrays.</p>
</li>
<LI>
						<P>Returns the corresponding value to <I>key</i> in a map.</p>
</li>
<li>
						<p>Note: If no element with a key equal to <i>key</i> exists, this operation <i>creates</i> a new element automatically with a value that is initialized by the default constructor of the value type. Thus, you can't have an invalid index (only wrong behavior). For example:</p>

						<pre>
							
     map&lt;int,string&gt; coll;
     coll [77] = "hello";  <i>// insert key</i> 77 <i>with value</i> "hello"
     cout &lt;&lt; coll [42];    <i>// Oops, inserts key</i> 42 <I>with value</I> "" <I>and prints the value</I>

						</PRe>
<P>See <A href="0201379260_snode53.html#24">Section 6.6.3</A>, for details.</P>
</LI>
<LI>
						<p><tt cLASS="monofont">T</tt> is the type of the element value.</p>
</lI>
<LI>
						<P>It is equivalent to:</p>

						<pre>
							
     (*((insert(make_pair(x,T()))).first)).second

						</PRE>
</Li>
<li>
						<p>Provided by maps.</p>
</li>
</ul>
				<p><tt class="monofont">reference</tt>
					<i>container::</i><B>front</B>
					<TT CLaSS="monofont">()</tT></P>

				<p><TT CLASs="monofont">const_reference</tt>
					<i>container::</I><B>front</B>
					<Tt claSS="monofont">() const</TT></p>

				<ul>
<lI><P>Both return the first element (the element with index <TT class="monofont">0</tt>).</p>
</li>
<li><p>The caller must ensure that the container contains an element (<tt class="monofont">size ()&gt;0</tT>); otherwise, the behavior is undefined.</P>
</LI>
<LI><p>Provided by vectors, deques, and lists.</P>

					</Li>
</UL>
				<p><TT CLASs="monofont">reference</tt>
					<i>container::</I><B>back</B>
					<Tt claSS="monofont">()</TT></p>

				<p><tt CLASs="monofont">const_reference</tt>
					<i>container::</i><b>back</b>
					<tt class="monofont">() const</tt></p>

				<ul>
<li><P>Both return the last element (the element with index <TT CLAsS="monofont">size()-l</Tt>).</P>
</Li>
<LI><P>The caller must ensure that the container contains an element (<TT Class="monofont">size()&gt;0</TT>); otherwise, the behavior is undefined.</P>
</Li>
<li><p>Provided by vectors, deques, and lists.</P>

					</LI>
</Ul>
			
			<h4>6.10.6
Operations to Generate Iterators</h4>
				<p>The following member functions return iterators to iterate over the elements of the containers. <A href="0201379260_snode57.html#11">Table 6.34</a> lists the iterator category (see <a href="0201379260_snode60.html">Section 7.2</a>,) according to the different container types.</p>

				<a name="11"></a><p><table BORDER="1" cELlSPaCING="0" CEllpaDDINg="1" widTH="100%">
<CAptioN><H5>Table 6.34. Iterator Categories According to Container Types</H5></Caption><colgroup align="left" spAN="2">
<TR VAlIGn="top">
<TH>
<fONT SIZe="2"><b>Container</b>
								</fONT></Th>
<th>
<fONT Size="2"><b>Iterator Category</B>
								</FONt></th>
</tr>
<tr valign="top">
<td>
<font siZE="2">Vector</FONT></tD>
<Td>
<FOnT SIZE="2">Random access</Font></tD>
</TR>
<Tr valIGN="top">
<Td>
<fonT SIZe="2">Deque</font></td>
<td>
<font size="2">Random access</font></TD>
</TR>
<TR vALiGN="top">
<tD>
<FONT Size="2">List</fONT></Td>
<td>
<fONT Size="2">Bidirectional</fONT></Td>
</tr>
<tr valign="top">
<td>
<font size="2">Set</FONT></TD>
<tD>
<FoNT sIZE="2">Bidirectional, element is constant</FONt></td>
</tR>
<TR ValigN="top">
<TD>
<Font sIZE="2">Multiset</Font></td>
<td>
<font size="2">Bidirectional, element is constant</font></td>
</TR>
<TR VAlIGn="top">
<TD>
<fONT SIZe="2">Map</fonT></TD>
<Td>
<fonT SIZe="2">Bidirectional, key is constant</fonT></TD>
</Tr>
<tr valign="top">
<td>
<font size="2">Multimap</foNT></TD>
<TD>
<fONt SIzE="2">Bidirectional, key is constant</FONT></Td>
</tr>
<tR VALign="top">
<tD>
<FONt sizE="2">String</FONt></td>
<td>
<font size="2">Random access</font></td>
</tr>
</COLGROuP>
</TaBLe></P>

				<P><TT CLass="monofont">iterator</tT>
					<I>container::</I><B>begin</b>
					<tt cLASS="monofont">()</tt></p>

				<p><TT CLass="monofont">const_iterator</tt>
					<i>container::</i>
					<b>begin</b>
					<tt class="monofont">() const</tt></p>

				<ul>
<LI><P>Both return an iterator for the beginning of the container (the position of the first element).</P>
</LI>
<lI><P>If the container is empty, the calls are equivalent to <i>container::</I><Tt CLASS="monofont">end().</Tt></p>
</li>
<LI><P>Provided by vectors, deques, lists, sets, multisets, maps, multimaps, and strings.</P>

					</li>
</ul>
				<P><TT Class="monofont">iterator</TT>
					<I>container::</I><b>end</b>
					<tt class="monofont">()</tt></p>

				<p><tt class="monofont">const_iterator</tT>
					<I>container::</I><B>end</B>
					<Tt CLaSS="monofont">() const</tT></P>

				<UL>
<LI><p>Both return an iterator for the end of the container (the position after the last element).</p>
</li>
<LI><P>If the container is empty, the calls are equivalent to <I>container:</i>
							<b>: begin().</b></p>
</LI>
<LI><p>Provided by vectors, deques, lists, sets, multisets, maps, multimaps, and strings.</p>

					</li>
</UL>
				<P><Tt class="monofont">reverse_iterator</tt>
					<i>container::</i><b>rbegin</b>
					<tt class="monofont">()</tt></P>

				<P><TT CLaSS="monofont">const_reverse_iterator</tT>
					<I>container::</i><B>rbegin</B>
					<TT CLass="monofont">() const</tT></P>

				<UL>
<li><p>Both return a reverse iterator for the beginning of a reverse iteration over the elements of the container (the position of the last element).</p>
</LI>
<LI><p>If the container is empty, the calls are equivalent to <i>container::</i>
							<tT CLAss="monofont">rend().</tt></p>
</li>
<li><p>For details about reverse iterators, see <a href="0201379260_snode62.html#1">Section 7.4.1</a>.</p>
</li>
<li><P>Provided by vectors, deques, lists, sets, multisets, maps, multimaps, and strings.</P>

					</LI>
</UL>
				<p><TT cLAsS="monofont">reverse_iterator</TT>
					<I>container::</I><B>rend</b> ()</p>

				<p><tT CLAss="monofont">const_reverse_iterator</tt>
					<I>container::</I><B>rend</B> () <tt clASS="monofont">const</Tt></p>

				<ul>
<li><p>Both return a reverse iterator for the end of a reverse iteration over the elements of the container (the position before the first element).</p>
</li>
<li><p>If the container is empty, the calls are equivalent to <i>container::</i>
							<tt clasS="monofont">rbegin().</TT></P>
</LI>
<lI><P>For details about reverse iterators, see <a href="0201379260_snode62.html#1">Section 7.4.1</A>.</P>
</LI>
<Li><p>Provided by vectors, deques, lists, sets, multisets, maps, multimaps, and strings.</p>

					</lI>
</UL>
			
			<H4>6.10.7
Inserting and Removing Elements</h4>
				<p><tt CLASs="monofont">iterator</tt>
					<i>container::</I><B>insert</B> (<Tt class="monofont">const T&amp;</tt>
					<i>value</i>)</p>

				<p><tt class="monofont">pair&lt;iterator,bool&gt;</tt>
					<I>container::</I><B>insert</B> (<TT cLAsS="monofont">const T&amp;</Tt>
					<I>value</I>)</P>

				<UL>
<Li><p>Both insert a copy of <i>value</i> into an associative container.</P>
</LI>
<Li><p>Containers that allow duplicates (multisets and multimaps) have the first signature. They return the position of the new element.</p>
</lI>
<LI><P>Containers that do not allow duplicates (sets and maps) have the second signature. If they can't insert the value because an element with an equal value or key exists, they return the position of the existing element and <tt clASS="monofont">false.</Tt> If they can insert the value, they return the position of the new element and <tt class="monofont">true.</tt></p>
</li>
<li><p><tt claSS="monofont">T</TT> is the type of the container elements. Thus, for maps and multimaps it is a key/value pair.</P>
</Li>
<LI><p>The functions either succeed or have no effect.</P>
</Li>
<LI><P>Provided by sets, multisets, maps, and multimaps.</P>

					</LI>
</ul>
				<p><tT CLAss="monofont">iterator</tt>
					<I>container::</I><B>insert</B> (<tt clASS="monofont">iterator</Tt>
					<i>pos,</i>
					<tt class="monofont">const T&amp;</tt>
					<i>value</i>)</p>

				<ul>
<li><p>Inserts a copy of <i>value</I> at the position of iterator <I>pos.</I></P>
</LI>
<lI><P>Returns the position of the new element.</p>
</LI>
<lI><P>For associative containers (sets, multisets, maps, and multimaps), the position is only used as hint, pointing to where the insert should start to search. If <I>value</I> is inserted right behind <I>pos</I> the function has amortized constant complexity; otherwise, it has logarithmic complexity.</p>
</li>
<lI><P>If the container is a set or a map that already contains an element equal to (the key of) <I>value,</I> then the call has no effect and the return value is the position of the existing element.</p>
</li>
<lI><P>For vectors and deques, this operation might invalidate iterators and references to other elements.</P>
</Li>
<li><p><TT CLass="monofont">T</tt> is the type of the container elements. Thus, for maps and multimaps it is a key/value pair.</p>
</li>
<li><p>For strings, <i>value</i> is not passed by reference.</p>
</li>
<li><p>For vectors and deques, if the copy operations (copy constructor and assignment operator) of the elements don't throw, the function either succeeds or has no effect. For all other standard containers, the function either succeeds or has no effect.</p>
</lI>
<LI><P>Provided by vectors, deques, lists, sets, multisets, maps, multimaps, and strings.</P>

					</Li>
</UL>
				<p><TT cLASS="monofont">void</TT>
					<i>container::</i><b>insert</b> (<TT CLass="monofont">iterator</tT>
					<I>pos,</I>
					<Tt claSS="monofont">size_type</TT>
					<i>num,</i>
					<tt class="monofont">const T&amp;</tt>
					<i>value</i>)</p>

				<ul>
<li><p>Inserts <i>num</i> copies of <I>value</I> at the position of iterator <I>pos.</I></P>
</Li>
<LI><p>For vectors and deques, this operation might invalidate iterators and references to other elements.</P>
</Li>
<LI><P><TT Class="monofont">T</TT> is the type of the container elements. Thus, for maps and multimaps it is a key/value pair.</P>
</Li>
<li><p>For strings, <I>value</I> is not passed by reference.</P>
</Li>
<li><p>For vectors and deques, if the copy operations (copy constructor and assignment operator) of the elements don't throw, the function either succeeds or has no effect. For lists, the function either succeeds or has no effect.</P>
</LI>
<Li><p>Provided by vectors, deques, lists, and strings.</p>

					</li>
</ul>
				<p><tt class="monofont">void</tt>
					<i>container::</i><b>insert</b> (<TT CLASs="monofont">InputIterator</TT>
					<i>beg,</I>
					<Tt CLASS="monofont">InputIterator</Tt>
					<i>end</i>)</p>

				<UL>
<LI><p>Inserts copies of all elements of the range <i>[beg,end)</i> into the associative container.</p>
</LI>
<LI><p>This function is a member template (see page 11). Thus, the elements of the source range may have any type that is convertible to the element type of the container.</p>
</li>
<LI><P>Provided by sets, multisets, maps, and multimaps.</P>

					</li>
</ul>
				<p><tt class="monofont">void</tt>
					<i>container::</i><b>insert</b> (<tt cLASS="monofont">iterator</TT>
					<i>pos,</I>
					<Tt CLaSS="monofont">InputIterator</TT>
					<I>beg,</I>
					<tt clASS="monofont">InputIterator</Tt>
					<i>end</i>)</p>

				<UL>
<LI><p>Inserts copies of all elements of the range <i>[beg,end)</i> at the position of iterator <i>pos.</I></P>
</LI>
<li><p>This function is a member template (see page 11). Thus, the elements of the source range may have any type that is convertible to the element type of the container.</p>
</li>
<li><p>For vectors and deques, this operation might invalidate iterators and references to other elements.</p>
</li>
<li><p>For lists, the function either succeeds or has no effect.</p>
</li>
<li><p>Provided by vectors, deques, lists, and strings.</P>

					</LI>
</UL>
				<P><tT ClASs="monofont">void</TT>
					<I>container::</I><B>push_front</B> (<tt clASS="monofont">const T&amp;</Tt>
					<i>value</i>)</p>

				<UL>
<LI><p>Inserts a copy of <i>value</i> as the new first element.</p>
</LI>
<LI><p><tt class="monofont">T</tt> is the type of the container elements.</p>
</li>
<li><p>It is equivalent to <tt claSS="monofont">insert(begin(),</TT>
							<I>value</I>)<i>.</I></P>
</lI>
<Li><P>For deques, this operation invalidates iterators to other elements. References to other elements stay valid.</P>
</LI>
<LI><p>This function either succeeds or has no effect.</p>
</li>
<LI><P>Provided by deques and lists.</P>

					</li>
</ul>
				<P><TT Class="monofont">void</TT>
					<I>container::</I><b>push_back</b> (<tt class="monofont">const T&amp;</tt>
					<i>value</i>)</p>

				<ul>
<li><p>Appends a copy of <i>value</i> as the new last element.</P>
</LI>
<LI><P><tT ClASs="monofont">T</TT> is the type of the container elements.</P>
</LI>
<Li><p>It is equivalent to <tt CLASs="monofont">insert(end()</tt>
							<i>,value</I>)<I>.</I></P>
</li>
<li><P>For vectors, this operation invalidates iterators and references to other elements when reallocation takes place.</P>
</LI>
<li><p>For deques, this operation invalidates iterators to other elements. References to other elements stay valid.</p>
</li>
<li><p>This function either succeeds or has no effect.</p>
</li>
<li><p>Provided by vectors, deques, lists, and strings.</p>

					</li>
</ul>
				<p><TT CLASs="monofont">void</TT>
					<i>list::</I><B>remove</b> (<TT CLASs="monofont">const T&amp;</tt>
					<i>value</I>)</P>

				<P><Tt claSS="monofont">void</TT>
					<i>list::</i><b>remove_if</b> (<TT CLass="monofont">UnaryPredicate</tt>
					<i>op</i>)</p>

				<ul>
<li><p><tt class="monofont">remove()</tT> removes all elements with value <TT CLAsS="monofont">value.</Tt></P>
</Li>
<LI><P><TT Class="monofont">remove_if()</TT> removes all elements for which the unary predicate</P>

						<Pre>
							
   <i>op(elem)</i>
						</PRE>
<P>yields <tt clASS="monofont">true.</Tt></p>
</li>
<li><p>Note that <i>op</i> should not change its state during a function call. See <a href="0201379260_snode66.html#6">Section 8.1.4</a>, for details.</p>
</li>
<li><p>Both call the destructors of the removed elements.</P>
</LI>
<LI><P>The order of the remaining arguments remains stable.</p>
</LI>
<lI><P>This is the special version of the <tT CLASS="monofont">remove()</tt> algorithm, which is discussed on page 378, for lists.</p>
</lI>
<LI><P><tt clASS="monofont">T</Tt> is the type of the container elements.</p>
</li>
<LI><P>For further details and examples, see page 170.</P>
</li>
<li><p>The functions may only throw if the comparison of the elements may throw.</p>
</li>
<li><p>Provided by lists.</p>

					</li>
</ul>
				<p><tt clASS="monofont">size_type</TT>
					<I>container::</i><B><I>erase</i></B> (<Tt CLASS="monofont">const T&amp;</Tt>
					<i>value</i>)</p>

				<UL>
<LI><p>Removes all elements equal to <i>value</i> from an associative container.</p>
</LI>
<LI><p>Returns the number of removed elements.</p>
</li>
<LI><P>Calls the destructors of the removed elements.</P>
</li>
<li><p><tt class="monofont">T</tt> is the type of the sorted value:</p>

						<ul>
<li><p>For sets and multisets, it is the type of the elements.</p>
</LI>
<LI><P>For maps and multimaps, it is the type of the keys.</P>
</lI>
</Ul>
					</LI>
<lI><P>The function does not throw.</P>
</LI>
<Li><p>Provided by sets, multisets, maps, and multimaps.</p>

					</lI>
</UL>
				<P><tt clASS="monofont">void</Tt>
					<i>container::</i><b>erase</B> (<TT Class="monofont">iterator</tt>
					<i>pos</i>)</p>

				<p><tt class="monofont">iterator</tt>
					<i>container::</i><B>erase</B> (<TT CLaSS="monofont">iterator</tT>
					<I>pos</i>)</P>

				<UL>
<LI><P>Both remove the element at the position of iterator <i>pos.</i></p>
</lI>
<LI><P>Sequence containers (vectors, deques, lists, and strings) have the second signature. They return the position of the following element (or <tt clASS="monofont">end()</Tt>).</p>
</li>
<LI><P>Associative containers (sets, multisets, maps, and multimaps) have the first signature. They return nothing.</P>
</li>
<li><p>Both call the destructors of the removed elements.</p>
</li>
<li><p>Note that the caller must ensure that the iterator <i>pos</i> is valid. For example:</p>

						<pre>
     coll. erase (coll. end());  <i>// ERROR</i> ? <i>undefined behavior</i>
						</PRE>
</LI>
<Li><P>For vectors and deques, this operation might invalidate iterators and references to other elements.</P>
</lI>
<Li><P>For vectors and deques, the function may only throw if the copy constructor or assignment operator of the elements may throw. For all other containers, the function does not throw.</P>
</LI>
<LI><p>Provided by vectors, deques, lists, sets, multisets, maps, multimaps, and strings.</p>

					</li>
</UL>
				<P><Tt claSS="monofont">void</TT>
					<i>container::</i><b>erase</b> (<TT CLass="monofont">iterator</tt>
					<i>beg,</i>
					<tt class="monofont">iterator</tt>
					<i>end</i>)</p>

				<p><tT CLASS="monofont">iterator</tT>
					<I>container::</i><B>erase</B> (<tT CLASS="monofont">iterator</tt>
					<i>beg,</i>
					<TT CLass="monofont">iterator</tT>
					<I>end</I>)</P>

				<ul>
<li><P>Both remove the elements of the range <I>[beg,end).</I></P>
</li>
<li><p>Sequence containers (vectors, deques, lists, and strings) have the second signature. They return the position of the element that was behind the last removed element on entry (or <tt class="monofont">end()</tt>).</p>
</li>
<li><p>Associative containers (sets, multisets, maps, and multimaps) have the first signature. They return nothing.</p>
</LI>
<LI><P>As always for ranges, all elements including <I>beg</i> but excluding <I>end</I> are removed.</p>
</LI>
<lI><P>Both call the destructors of the removed elements.</P>
</LI>
<Li><p>Note that the caller must ensure that <i>beg</i> and <I>end</I> define a valid range that is part of the container.</P>
</Li>
<li><p>For vectors and deques, this operation might invalidate iterators and references to other elements.</P>
</LI>
<Li><p>For vectors and deques, the function may only throw if the copy constructor or the assignment operator of the elements may throw. For all other containers, the function does not throw.</p>
</lI>
<LI><P>Provided by vectors, deques, lists, sets, multisets, maps, multimaps, and strings.</p>

					</li>
</ul>
				<p><tt class="monofont">void</tt>
					<i>container::</i><b>pop_front</b>
					<tt CLASS="monofont">()</Tt></P>

				<Ul>
<LI><p>Removes the first element of the container.</P>
</LI>
<LI><P>It is equivalent to <i>container.</i>
							<tt CLASs="monofont">erase</tt> (<i>container.</I><TT Class="monofont">begin()</TT>).</P>
</Li>
<li><p>Note: If the container is empty, the behavior is undefined. Thus, the caller must ensure that the container contains at least one element (<tt class="monofont">size () &gt;0</tt>).</p>
</li>
<li><p>The function does not throw.</p>
</lI>
<LI><P>Provided by deques and lists.</P>

					</Li>
</UL>
				<p><TT cLASS="monofont">void</TT>
					<i>container::</i><b>pop_back</b>
					<TT CLass="monofont">()</tT></P>

				<UL>
<li><p>Removes the last element of the container.</p>
</LI>
<LI><p>It is equivalent to <i>container.</i><tt class="monofont">erase</tt>(--<i>container.</i><tt class="monofont">end()</TT>), provided this expression is valid, which might not be the case for vectors (see page 258).</P>
</LI>
<Li><P>Note: If the container is empty, the behavior is undefined. Thus, the caller must ensure that the container contains at least one element <Tt CLaSS="monofont">(size()&gt;0</TT>).</P>
</Li>
<li><p>The function does not throw.</P>
</LI>
<Li><p>Provided by vectors, deques, and lists.</p>

					</lI>
</UL>
				<P><tt clASS="monofont">void</Tt>
					<i>container::</i><b>resize</b> (<tt class="monofont">size_type</tt>
					<i>num</i>)</p>

				<p><tt cLASS="monofont">void</TT>
					<i>container::</I><B>resize</b> (<TT cLASS="monofont">size_type</TT>
					<i>num,</i>
					<tt CLASs="monofont">T</tt>
					<i>value</I>)</P>

				<UL>
<li><p>Both change the number of elements to <i>num.</I></P>
</LI>
<li><p>If <tt class="monofont">size()</tt> is <i>num</i> on entry, they have no effect.</p>
</li>
<li><p>If <i>num</I> is greater than <TT CLAsS="monofont">size()</Tt> on entry, additional elements are created and appended to the end of the container. The first form creates the new elements by calling their default constructor; the second form creates the new elements as copies of <I>value.</I></p>
</LI>
<LI><P>If <I>num</i> is less than <tt cLASS="monofont">size()</tt> on entry, elements are removed at the end to get the new size. In this case, they call the destructor of the removed elements.</p>
</lI>
<LI><P>For vectors and deques, these functions might invalidate iterators and references to other elements.</p>
</li>
<lI><P>For vectors and deques, these functions either succeed or have no effect, provided the copy constructor or the assignment operator of the elements don't throw. For lists, the functions either succeed or have no effect.</P>
</Li>
<li><p>Provided by vectors, deques, lists, and strings.</p>

					</li>
</ul>
				<p><tt class="monofont">void</tt>
					<i>container::</i><B>clear</B>
					<TT CLaSS="monofont">()</tT></P>

				<uL>
<LI><P>Removes all elements (makes the container empty).</P>
</Li>
<li><p>Calls the destructors of the removed elements.</P>
</LI>
<Li><p>Invalidates all iterators and references to the container.</p>
</lI>
<LI><P>For vectors and deques, the function may only throw if the copy constructor or the assignment operator of the elements may throw. For all other containers, the function does not throw.</p>
</li>
<lI><P>Provided by vectors, deques, lists, sets, multisets, maps, multimaps, and strings.</P>

					</Li>
</ul>
			
			<a name="13"></a><h4>6.10.8
Special Member Functions for Lists</h4>
				<p><tt class="monofont">void</tt>
					<I>list::</I>
					<B>unique</B>
					<TT cLAsS="monofont">()</Tt></P>

				<P><TT CLass="monofont">void</tT>
					<I>list::</I><B>unique</b> (<tt cLASS="monofont">BinaryPredicate</tt>
					<i>op</i>)</P>

				<UL>
<Li><p>Both remove subsequent duplicates of list elements so that each element contains a different value than the following element.</p>
</li>
<li><p>The first form removes all elements for which the previous values are equal.</p>
</li>
<li><p>The second form removes all elements that follow an element e and for which the binary predicate</p>

						<pre>
							
   <i>op(elem,e)</i>
						</pRE>
<P>yields <TT ClASs="monofont">true.</TT><fONT SIZe="1"><sup><A HREf="#FOOTNOTE-34">[34]</a></suP></FONt>
 In other words, the predicate is not used to compare an element with its predecessor; the element is compared with the previous element that was not removed.</p>
<blOCKQuote><font size="1">
<p class="footnote">
<sup><A NAME="FOOTNOTE-34">[34]</A></sUP>
The second version of <tT ClASS="monofont">unique()</TT> is available only in systems that support member templates (see page 11).</P>
</font></BLOCkquoTE>
</LI>
<li><p>Note that <i>op</I> should not change its state during a function call. See <A href="0201379260_snode66.html#6">Section 8.1.4</a>, for details.</p>
</li>
<li><p>Both call the destructors of the removed elements.</p>
</li>
<li><p>These are the special versions of the <tt clasS="monofont">unique()</TT> algorithms, which are discussed on page 381, for lists.</P>
</LI>
<lI><P>The functions do not throw if the comparisons of the elements do not throw.</p>

					</LI>
</uL>
				<P><TT CLass="monofont">void</tT>
					<I>list::</I><B>splice</b> (<tt cLASS="monofont">iterator</tt>
					<i>pos, list</i>&amp; <I>source</I>)</P>

				<Ul>
<li><p>Moves all elements of <i>source</i> into <tt class="monofont">*this</tt> and inserts them at the position of iterator <i>pos.</i></p>
</li>
<lI><P><I>source</I> is empty after the call.</P>
</Li>
<LI><p>If <I>source</I> and <tT CLASS="monofont">*this</tt> are identical, the behavior is undefined. Thus, the caller must ensure that <i>source</i> is a different list. To move elements inside the same list you must use the following form of <TT CLass="monofont">splice().</tT></P>
</LI>
<li><p>The caller must ensure that <i>pos</I> is a valid position of <TT Class="monofont">*this;</tt> otherwise, the behavior is undefined.</p>
</li>
<li><p>This function does not throw.</p>

					</li>
</ul>
				<p><tt cLASS="monofont">void</TT>
					<i>list::</I><B>splice</b> (<TT cLASS="monofont">iterator</TT>
					<i>pos, list&amp; source,</i>
					<tt CLASs="monofont">iterator</tt>
					<i>sourcePos</I>)</P>

				<UL>
<li><p>Moves the element at the position <i>sourcePos</I> of the list <I>source</I> into <Tt class="monofont">*this</tt> and inserts it at the position of iterator <i>pos.</i></p>
</li>
<li><p><i>source</i> and <tt cLASS="monofont">*this</TT> may be identical. In this case, the element is moved inside the list.</p>
</LI>
<lI><P>If <i>source</I> is a different list, it contains one element less after the operation.</P>
</LI>
<LI><p>The caller must ensure that <i>pos</i> is a valid position of <tT CLAss="monofont">*this,</tt>
							<I>sourcePos</I> is a valid iterator of <I>source,</I> and <i>sourcePos</i> is not <i>source.</i>
							<TT CLass="monofont">end();</tt> otherwise, the behavior is undefined.</p>
</li>
<li><p>This function does not throw.</p>

					</li>
</ul>
				<p><tt clASS="monofont">void</TT>
					<I>list::</i><B>splice</B> (<tT ClASS="monofont">iterator</TT>
					<I>pos, list&amp; source,</i>
					<tt cLASS="monofont">iterator</tt>
					<i>sourceBeg,</i>
					<TT CLass="monofont">iterator</tT>
					<I>sourceEnd</I>)</P>

				<ul>
<li><p>Moves the elements of the range <i>[sourceBeg,sourceEnd)</i> of the list <i>source</i> to <tt class="monofont">*this</tt> and inserts it at the position of iterator <i>pos.</i></p>
</LI>
<LI><P><I>source</i> and <TT cLAsS="monofont">*this</TT> may be identical. In this case, <I>pos</I> must not be part of the moved range, and the elements are moved inside the list.</P>
</li>
<li><P>If <I>source</I> is a different list, it contains less elements after the operation.</P>
</li>
<li><P>The caller must ensure that <I>pos</I> is a valid position of <Tt claSS="monofont">*this,</TT> and that <i>sourceBeg</i> and <i>sourceEnd</i> define a valid range that is part of <i>source;</i> otherwise, the behavior is undefined.</p>
</li>
<li><p>This function does not throw.</p>

					</li>
</ul>
				<p><tt cLASS="monofont">void</TT>
					<i>list::</I><B>sort</b>
					<TT cLASS="monofont">()</TT></p>

				<p><tt CLASs="monofont">void</tt>
					<i>list::</I><B>sort</B> (<Tt claSS="monofont">CompFunc</TT>
					<i>op</i>)</p>

				<ul>
<li><p>Both sort the elements in the list.</p>
</li>
<li><p>The first form sorts all elements in the list with operator <tt class="monofont">&lt;.</TT></P>
</LI>
<Li><P>The second form sorts all elements in the list by calling <I>op</i> to compare two elements<FOnT SIZE="1"><Sup><a hREF="#FOOTNOTE-35">[35]</A></sup></fONT>
:</P>
<blocKQUOte><font size="1">
<p class="footnote">
<sup><a nAME="FOOTNOTE-35">[35]</A></SUp>
The second form of <TT cLAsS="monofont">sort()</TT> is available only in systems that support member templates (see page 11).</P>
</FOnt></blOCKQuote>

						<PRE>
							
<I>op(elem1,elem2)</i>

						</pre>

					</LI>
<LI><p>The order of elements that have an equal value remains stable (unless an exception is thrown).</p>
</li>
<li><p>These are the special versions of the <tt class="monofont">sort()</tt> and <tt claSS="monofont">stable_sort()</TT> algorithms, which are discussed on page 397.</P>

					</Li>
</UL>
				<p><TT cLASS="monofont">void</TT>
					<i>list::</i><b>merge</b> (<I>list&amp; source</I>)</P>

				<P><tt clASS="monofont">void</Tt>
					<i>list::</i><b>merge</B> (<I>list&amp; source,</I>
					<Tt class="monofont">CompFunc</tt>
					<i>op</i>)</p>

				<ul>
<li><p>Both merge all elements of the list <i>source</i> into <tt cLASS="monofont">*this.</TT></p>
</LI>
<lI><P><i>source</I> is empty after the call.</P>
</LI>
<LI><p>If <tt cLASS="monofont">*this</tt> and <i>source</i> are sorted on entry according to the sorting criterion <TT CLass="monofont">&lt;</tT> or <I>op,</I> the resulting list is also sorted. Strictly speaking, the standard requires that both lists be sorted on entry. In practice, however, merging is also possible for unsorted lists. However, you should check this before you rely on it.</P>
</li>
<li><p>The first form uses operator <tt class="monofont">&lt;</tt> as the sorting criterion.</p>
</li>
<li><p>The second form uses <i>op</I> as the optional sorting criterion and is used to compare two elements<FONT SiZE="1"><sUP><a HREF="#FOOTNOTE-36">[36]</A></Sup></foNT>
:</P>
<BlockQUOTe><fonT SIZe="1">
<p class="footnote">
<sup><a name="FOOTNOTE-36">[36]</a></sup>
The second form of <tt CLASS="monofont">merge()</Tt> is available only in systems that support member templates (see page 11).</P>
</FoNT></bLOCKQUote>

						<pRE>
							
<I>op (elem, sourceElem)</I>

						</pre>
</lI>
<LI><P>This is the special version of the <tt clASS="monofont">merge()</Tt> algorithm, which is discussed on page 416.</p>
</li>
<li><p>If the comparisons of the elements do not throw, the functions either succeed or have no effect.</p>

					</li>
</ul>
				<p><tt class="monofont">void</tT>
					<I>list::</I><B>reverse</B>
					<Tt CLaSS="monofont">()</tT></P>

				<UL>
<LI><p>Reverses the order of the elements in a list.</p>
</li>
<LI><P>This is the special version of the <Tt claSS="monofont">reverse()</TT> algorithm, which is discussed on page 386.</p>
</li>
<lI><P>This function does not throw.</P>

					</Li>
</ul>
			
			<a name="17"></a><h4>6.10.9
Allocator Support</h4>
				<p>All STL containers can be used with a special memory model that is defined by an allocator object (see <a href="0201379260_cnode121.html">Chapter 15</a> for details). This subsection describes the members for allocator support.</p>

				<p>Standard containers require that all instances of an allocator type are interchangeable. Thus, storage allocated from one container can be deallocated via another that has the same type. Therefore, it is no problem when elements (and their storage) are moved between containers of the same type.</p>

				<H5>Fundamental Allocator Members</H5>
					<P><I>container::</I><B>allocator_type</b></P>

					<Ul>
<LI><p>The type of the allocator.</P>
</LI>
<LI><P>Provided by vectors, deques, lists, sets, multisets, maps, multimaps, and strings.</p>

						</li>
</uL>
					<P><TT clasS="monofont">allocator_type</TT>
						<I>container::</i><b>get_allocator</b>
						<tT CLAss="monofont">() const</tt></p>

					<ul>
<li><p>Returns the memory model of the container.</p>
</li>
<li><p>Provided by vectors, deques, lists, sets, multisets, maps, multimaps, and strings.</p>

						</li>
</ul>
				
				<H5>Constructors with Optional Allocator Parameters</H5>
					<P><TT ClASs="monofont">explicit</TT>
						<i>container container</I> (<TT CLAss="monofont">const Allocator&amp;</tt>
						<I>alloc</I>)</P>

					<Ul>
<li><p>Creates a new empty container that uses the memory model <I>alloc.</I></P>
</Li>
<li><p>Provided by vectors, deques, lists, sets, multisets, maps, multimaps, and strings.</P>

						</LI>
</Ul>
					<p><i>container::</i><i>container</i> (<tt class="monofont">const CompFunc&amp;</tt>
						<i>op,</i>
						<tt clASS="monofont">const Allocator&amp;</TT>
						<I>alloc</i>)</P>

					<Ul>
<LI><p>Creates a new empty container with <I>op</I> used as the sorting criterion that uses the memory model <I>alloc.</I></P>
</Li>
<li><p>The sorting criterion must define a "strict weak ordering" (see page 176).</P>
</LI>
<Li><p>Provided by sets, multisets, maps, and multimaps.</p>

						</lI>
</UL>
					<P><i>container::</i><i>container</i> (<TT CLass="monofont">size.type</tt>
						<i>num,</i>
						<tt class="monofont">const T&amp;</tt>
						<i>value,</i>
						<tt cLASS="monofont">const Allocator&amp;</TT>
						<i>alloc</I>)</P>

					<uL>
<Li><P>Creates a container with <I>num</I> elements that uses the memory model <I>alloc.</I></P>
</li>
<li><P>The elements are created as copies of <I>value.</I></P>
</li>
<li><P><TT Class="monofont">T</TT> is the type of the container elements. Note that for strings, <I>value</I> is passed by value.</p>
</li>
<li><p>Provided by vectors, deques, lists, and strings.</p>

						</li>
</ul>
					<p><i>container::</i><i>container</i> (<tt claSS="monofont">InputIterator</TT>
						<I>beg,</I>
						<tT ClASs="monofont">InputIterator</TT>
						<I>end,</I>
						<TT clasS="monofont">const Allocator&amp;</TT>
						<I>alloc</i>)</p>

					<ul>
<LI><P>Creates a container that is initialized by all elements of the range <I>[beg,end)</i> and uses the memory model <i>alloc.</i></p>
</LI>
<LI><p>This function is a member template (see page 11). Thus, the elements of the source range may have any type that is convertible to the element type of the container.</p>
</li>
<li><p>Provided by vectors, deques, lists, sets, multisets, maps, multimaps, and strings.</p>

						</li>
</ul>
					<p><i>container::</i><i>container</i> (<tt clASS="monofont">InputIterator</TT>
						<I>beg,</i>
						<TT cLAsS="monofont">InputIterator</TT>
						<I>end,</I>
						<Tt claSS="monofont">const CompFunc&amp;</TT>
						<i>op,</i>
						<tt CLASs="monofont">const Allocator&amp;</tt>
						<i>alloc</I>)</P>

					<UL>
<li><p>Creates a container that has the sorting criterion <i>op,</i> is initialized by all elements of the range <i>[beg,end),</i> and uses the memory model <i>alloc.</i></p>
</li>
<li><p>This function is a member template (see page 11). Thus, the elements of the source range may have any type that is convertible to the element type of the container.</p>
</li>
<li><p>The sorting criterion must define a "strict weak ordering" (see page 176).</P>
</LI>
<LI><P>Provided by sets, multisets, maps, and multimaps.</p>

						</LI>
</uL>
				
			
			<A nAME="20"></A><H4>6.10.10
Overview of Exception Handling in STL Containers</H4>
				<p>As mentioned in <a href="0201379260_snode44.html#3">Section 5.11.2</A>, containers provide different guarantees in the face of exceptions. In general, the C++ standard library will not leak resources or violate container invariants in the face of exceptions. However, some operations give stronger guarantees (provided the arguments meet some requirements): They may guarantee commit-or-rollback behavior, or they may even guarantee that they will never throw at all. Table 6.35 lists all operations that give these stronger guarantees.<Font sIZE="1"><Sup><a hREF="#FOOTNOTE-37">[37]</A></sup></font>
</p>
<blockquote><fonT SIZE="1">
<P cLAsS="footnote">
<SuP><A NAME="FOOTNOTE-37">[37]</a></sup>
Many thanks to Greg Colvin and Dave Abrahams for providing this table.</P>
</FONt></bloCKQUote>

				<p>For vectors, deques, and lists, you also have guarantees for <TT CLass="monofont">resize().</tt> It is defined as having the effect of either calling <tt class="monofont">erase()</tt> or calling <tt class="monofont">insert()</TT> or doing nothing:</P>

				<PRE>
					
    void <i>container::</I>resize (size_type num, T value = T())
    {
        if (num &gt; size()) {
            insert (end(), num-size(), value);
        }
        else if (num &lt; size()) {
            erase (begin()+num, end());
        }
    }

				</PrE>

				<P>Thus, its guarantees are a combination of the guarantees of <tT CLASS="monofont">erase()</tt> and <tt CLASs="monofont">insert()</tt> (see page 244).</p>

				<P><TABle boRDER="1" cellspacing="0" cellpaddinG="1" WIDTH="100%">
<cAPtIOn><H5>Table 6.35. Container operations with Special Guarantees in Face of Exceptions</H5></CAPTion><cOLGRoup aLIGN="left" span="3">
<TR VAlign="top">
<th>
<font size="2"><b>Operation</b>
								</font></tH>
<TH>
<FONt SIzE="2"><B>Page</b>
								</FONT></TH>
<th>
<foNT SIze="2"><b>Guarantee</b>
								</FONT></th>
</tr>
<TR VAlign="top">
<td>
<font size="2"><tt class="monofont">vector::push_back()</TT>
								</FONT></tD>
<Td>
<FOnT SIZE="2">241</Font></tD>
<TD>
<Font sIZE="2">Either succeeds or has no effect</Font></tD>
</TR>
<Tr valign="top">
<td>
<font size="2"><tt clASS="monofont">vector::insert()</TT>
								</FoNT></tD>
<Td>
<FONT SIze="2">240</foNT></TD>
<td>
<foNT SIze="2">Either succeeds or has no effect if copying/assigning elements doesn't throw</foNT></TD>
</tr>
<tr valign="top">
<td>
<font size="2"><tT CLASS="monofont">vector::pop_back()</tT>
								</FoNT></tD>
<TD>
<FONt sizE="2">243</FONt></td>
<tD>
<FONt sizE="2">Doesn't throw</FONt></td>
</tr>
<tr valign="top">
<td>
<font siZE="2"><TT CLaSS="monofont">vector::erase()</tT>
								</FoNT></TD>
<TD>
<font SIZE="2">242</font></TD>
<TD>
<font SIZE="2">Doesn't throw if copying/assigning elements doesn't throw</font></td>
</tr>
<tr valign="top">
<td>
<fonT SIZE="2"><Tt CLaSS="monofont">vector::clear()</tT>
								</FONT></Td>
<td>
<fONT Size="2">244</fONT></Td>
<td>
<fONT Size="2">Doesn't throw if copying/assigning elements doesn't throw</font></td>
</tr>
<tr valign="top">
<td>
<FONT SIzE="2"><Tt CLaSS="monofont">vector::swap()</TT>
								</FOnt></td>
<TD>
<FOnt siZE="2">237</FOnt></td>
<TD>
<FOnt size="2">Doesn't throw</font></td>
</tr>
<tr valigN="top">
<TD>
<FONt SIzE="2"><Tt CLASS="monofont">deque::push_back()</Tt>
								</fonT></TD>
<Td>
<fonT SIZe="2">241</fonT></TD>
<Td>
<font size="2">Either succeeds or has no effect</font></td>
</tr>
<tr vaLIGN="top">
<TD>
<fONt SIzE="2"><TT CLAss="monofont">deque::push_front()</tt>
								</FONT></td>
<td>
<FONT size="2">241</FONT></td>
<td>
<font size="2">Either succeeds or has no effect</font></td>
</tr>
<tR VALIGn="top">
<TD>
<fONt SIZE="2"><TT clasS="monofont">deque::insert()</TT>
								</Font></tD>
<TD>
<Font sIZE="2">240</Font></td>
<td>
<font size="2">Either succeeds or has no effect if copying/assigning elements doesn't throw</font></td>
</TR>
<TR VAlIGn="top">
<TD>
<fONT SIZe="2"><tt cLASS="monofont">deque::pop_back()</tt>
								</foNT></TD>
<td>
<foNT SIze="2">243</font></td>
<td>
<font size="2">Doesn't throw</fonT></TD>
</TR>
<Tr VAlIGn="top">
<TD>
<FONT size="2"><TT CLass="monofont">deque::pop_front()</tT>
								</FONt></td>
<tD>
<FONt size="2">243</font></td>
<td>
<font size="2">Doesn't throw</FONT></TD>
</tR>
<Tr VAlIGN="top">
<TD>
<Font sIZE="2"><Tt claSS="monofont">deque::erase()</TT>
								</font></TD>
<TD>
<font size="2">242</font></td>
<td>
<font sIZE="2">Doesn't throw if copying/assigning elements doesn't throw</FONt></TD>
</tR>
<Tr VALIGN="top">
<td>
<foNT SIze="2"><tt CLASs="monofont">deque::clear()</tt>
								</fONT></Td>
<td>
<font size="2">244</font></td>
<td>
<foNT SIZE="2">Doesn't throw if copying/assigning elements doesn't throw</fONt></TD>
</tR>
<TR VALign="top">
<tD>
<FONt sizE="2"><TT Class="monofont">deque::swap()</TT>
								</FOnt></td>
<td>
<font size="2">237</font></td>
<tD>
<FONT SiZE="2">Doesn't throw</fONt></TD>
</TR>
<TR valiGN="top">
<TD>
<font SIZE="2"><tt clASS="monofont">list::push_back()</Tt>
								</font></td>
<td>
<font size="2">241</font></TD>
<TD>
<FOnT SiZE="2">Either succeeds or has no effect</fONT></TD>
</Tr>
<tr vALIGn="top">
<td>
<fONT Size="2"><tT CLAss="monofont">list::push_front()</tt>
								</font></td>
<td>
<font size="2">241</fONT></TD>
<Td>
<FOnT SiZE="2">Either succeeds or has no effect</FONT></td>
</tr>
<TR VAlign="top">
<TD>
<FOnt siZE="2"><TT class="monofont">list::insert()</tt>
								</font></td>
<td>
<font siZE="2">240</FONT></tD>
<Td>
<FOnT SIZE="2">Either succeeds or has no effect</Font></tD>
</TR>
<Tr valIGN="top">
<Td>
<fonT SIZe="2"><tt class="monofont">list::pop_back()</tt>
								</font></td>
<td>
<fonT SIZE="2">243</FoNT></tD>
<Td>
<FONT SIze="2">Doesn't throw</foNT></TD>
</tr>
<tr VALIgn="top">
<td>
<FONT size="2"><tt class="monofont">list::pop_front()</tt>
								</font></td>
<td>
<FONT SIzE="2">243</FoNT></tD>
<TD>
<FONt sizE="2">Doesn't throw</FONt></td>
</tR>
<TR ValigN="top">
<TD>
<Font size="2"><tt class="monofont">list::erase()</tt>
								</font></tD>
<TD>
<FONt SIzE="2">242</FoNT></TD>
<TD>
<font SIZE="2">Doesn't throw</font></TD>
</TR>
<tr vaLIGN="top">
<td>
<font size="2"><tt class="monofont">list:: clear()</tt>
								</foNT></TD>
<TD>
<fONt SIzE="2">244</FONT></Td>
<td>
<fONT Size="2">Doesn't throw</fONT></Td>
</tr>
<tR VALign="top">
<td>
<font size="2"><tt class="monofont">list:: remove()</tT>
								</FONT></Td>
<TD>
<fONt SIZE="2">242</FOnt></td>
<TD>
<FOnt siZE="2">Doesn't throw if comparing the elements doesn't throw</FOnt></td>
</TR>
<TR valign="top">
<td>
<font size="2"><tt claSS="monofont">list::remove_if()</TT>
								</FOnT></Td>
<TD>
<fONT SIZe="2">242</fonT></TD>
<Td>
<fonT SIZe="2">Doesn't throw if the predicate doesn't throw</fonT></TD>
</Tr>
<tr valign="top">
<td>
<font size="2"><tt CLASS="monofont">list::unique()</Tt>
								</FOnT></Td>
<TD>
<FONT size="2">244</FONT></td>
<td>
<FONT size="2">Doesn't throw if comparing the elements doesn't throw</FONT></td>
</tr>
<tr valign="top">
<td>
<font sizE="2"><TT CLAsS="monofont">list::splice()</Tt>
								</FOnT></TD>
<TD>
<Font sIZE="2">245</Font></tD>
<TD>
<Font sIZE="2">Doesn't throw</Font></td>
</tr>
<tr valign="top">
<td>
<font SIZE="2"><TT cLAsS="monofont">list::merge()</Tt>
								</FONT></TD>
<td>
<foNT SIze="2">246</foNT></TD>
<td>
<foNT SIze="2">Either succeeds or has no effect if comparing the elements doesn't throw</font></td>
</tr>
<tr valign="top">
<td>
<fONT SIZe="2"><TT cLAsS="monofont">list::reverse()</TT>
								</FONt></td>
<tD>
<FONt sizE="2">246</FONt></td>
<tD>
<FONt size="2">Doesn't throw</font></td>
</tr>
<tr valign="top">
<TD>
<FONT sIZe="2"><TT cLASS="monofont">list::swap()</TT>
								</font></TD>
<TD>
<font SIZE="2">237</font></TD>
<TD>
<font size="2">Doesn't throw</font></td>
</tr>
<tr valIGN="top">
<TD>
<FoNT sIZe="2"><TT CLASs="monofont">[multi]set::insert()</tt>
								</fONT></Td>
<td>
<fONT Size="2">240</fONT></Td>
<td>
<font size="2">For single elements either succeeds or has no effect</font></td>
</tr>
<tr VALIGN="top">
<tD>
<FoNT sIZE="2"><TT Class="monofont">[multi]set::erase()</TT>
								</FOnt></td>
<TD>
<FOnt siZE="2">242</FOnt></td>
<td>
<font size="2">Doesn't throw</font></td>
</tR>
<TR VALiGN="top">
<tD>
<FoNT SIZE="2"><tt clASS="monofont">[multi]set::clear()</Tt>
								</fonT></TD>
<Td>
<fonT SIZe="2">244</font></td>
<td>
<font size="2">Doesn't throw</font></TD>
</TR>
<TR vALiGN="top">
<tD>
<FONT Size="2"><tT CLAss="monofont">[multi]set::swap()</tt>
								</FONT></td>
<td>
<FONT size="2">237</font></td>
<td>
<font size="2">Doesn't throw if copying/assigning the comparison criterion doesn't throw</fONT></TD>
</Tr>
<TR vALiGN="top">
<TD>
<FOnt siZE="2"><TT clasS="monofont">[multi]map::insert()</TT>
								</Font></tD>
<TD>
<Font size="2">240</font></td>
<td>
<font siZE="2">For single elements either succeeds or has no effect</FONT></tD>
</Tr>
<TR vALIGN="top">
<Td>
<fonT SIZe="2"><tt cLASS="monofont">[multi]map::erase()</tt>
								</foNT></TD>
<td>
<font size="2">242</font></td>
<td>
<fonT SIZE="2">Doesn't throw</FoNT></tD>
</Tr>
<TR VALIgn="top">
<td>
<FONT size="2"><TT CLass="monofont">[multi]map::clear()</tT>
								</FONt></td>
<td>
<font size="2">244</font></td>
<td>
<FONT SIzE="2">Doesn't throw</FoNT></tD>
</TR>
<TR ValigN="top">
<TD>
<Font sIZE="2"><Tt claSS="monofont">[multi]map::swap()</TT>
								</font></td>
<td>
<font size="2">237</font></tD>
<TD>
<FONt SIzE="2">Doesn't throw if copying/assigning the comparison criterion doesn't throw</FoNT></TD>
</TR>
</colgROUP>
</tablE></P>

			
		</FOnt>
 
<table width="100%" border="0" cellspacing="0" cellpadding="0" bgcolor="#CCCCCC">
<td><font color="black" size=1>I l<font color="#FF0000">@</font>ve RuBoard</td>
<td valign="top" class="v2" align="right"><a href="0201379260_snode56.html"><img src="FILES/previous.gif" width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a> <a href="0201379260_cnode58.html"><img src="FILES/next.gif" width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a></td></table>
</BODY></HTML>