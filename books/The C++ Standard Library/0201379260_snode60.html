<HTML><HEAD><META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=iso-8859-1">
<!--SafClassName="docSection1Title"--><!--SafTocEntry="7.2 Iterator Categories"-->
<LINK REL="stylesheet" href="FILES/sbolM.css">
</HEAD>
<BODY link="#354278" vlink="#000066" alink="#000080" topmargin="0">
<table width="100%" border="0" cellspacing="0" cellpadding="0" bgcolor="#CCCCCC">
<td><font color="black" size=1>I l<font color="#FF0000">@</font>ve RuBoard</td>
<td valign="top" class="v2" align="right"><a href="0201379260_snode59.html"><img src="FILES/previous.gif" width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a> <a href="0201379260_snode61.html"><img src="FILES/next.gif" width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a></td></table>
<FONT><h3>7.2
Iterator Categories</h3>
			<p>Iterators are objects that can iterate over elements of a sequence. They do this via a common interface that is adapted from ordinary pointers (see the introduction in <a href="0201379260_snode36.html">Section 5.3</a>). Iterators follow the concept of pure abstraction: Anything that <i>behaves</i> like an iterator <i>is</I> an iterator. However, iterators have different abilities. These abilities are important because some algorithms require special iterator abilities. For example, sorting algorithms require iterators that can perform random access because otherwise the runtime would be poor. For this reasen, iterators have different categories (<A href="0201379260_snode60.html#1">Figure 7.1</a>). The abilities of these categories are listed in <a href="0201379260_snode60.html#2">Table 7.1</a>, and discussed in the following subsections.</p>

			<center>
				<h5>
<a name="1"></a>Figure 7.1. Iterator Categories</h5><img boRDER="0" WIdTH="500" hEIgHT="332" src="FILES/07fig01.gif" Alt="graphics/07fig01.gif"></ceNTER>

			<a namE="2"></A><P><Table BORDer="1" cellspacing="0" cellpaddING="1" WIDtH="100%">
<CaPTiON><H5>Table 7.1. Abilities of Iterator Categories</H5></CAptioN><COLgrouP ALIgn="left" spAN="3">
<TR>
<th valign="top">
<font size="2"><b>Iterator Category</b>
							</fonT></TH>
<TH VaLIgN="top">
<FoNT SIZE="2"><b>Ability</b>
							</foNT></TH>
<th vaLIGN="top">
<font SIZE="2"><b>Providers</b>
							</font></th>
</tr>
<tr>
<td valign="top">
<fONT SIZe="2">Input iterator</FOnT></Td>
<TD VALIgn="top">
<foNT SIze="2">Reads forward</foNT></TD>
<td vaLIGN="top">
<font size="2">istream</font></td>
</tr>
<tr>
<td vALIGN="top">
<FoNT sIZe="2">Output iterator</FONT></TD>
<td vaLIGN="top">
<font SIZE="2">Writes forward</font></TD>
<TD valign="top">
<font size="2">ostream, inserter</font></td>
</tR>
<TR>
<TD VaLIgN="top">
<FoNT SIZE="2">Forward iterator</font></TD>
<TD valiGN="top">
<FOnt siZE="2">Reads and writes forward</FOnt></td>
<td valign="top">
<font size="2"> </fONT></TD>
</Tr>
<TR>
<tD VaLIGN="top">
<FOnt siZE="2">Bidirectional iterator</FOnt></td>
<TD VAlign="top">
<FONT size="2">Reads and writes forward and backward</font></td>
<td valign="top">
<fonT SIZE="2">list, set, multiset, map, multimap</FoNT></tD>
</Tr>
<TR>
<TD VAlign="top">
<FONT size="2">Random access iterator</FONT></td>
<td VALIgn="top">
<font size="2">Reads and writes with random access</font></td>
<td valIGN="top">
<FONt SIzE="2">vector, deque string, array</FoNT></TD>
</TR>
</colgROUP>
</tablE></P>

			<A Name="3"></a><H4>7.2.1
Input Iterators</H4>
				<P>Input iterators can only step forward element-by-element with read access. Thus, they return values elementwise. <A href="0201379260_snode60.html#4">Table 7.2</a> lists the operations of input iterators.</p>

				<p>Note that input iterators can read elements only once. Thus, if you copy an input iterator and let the original and the copy read forward, they might iterate over different values.</p>

				<p>Almost all iterators have the abilities of input iterators. However, usually they can have more. A typical example of a pure input iterator is an iterator that reads from the standard input (typically the keyboard). The same value can't be read twice. After a word is read from an input stream (out of the input buffer), the next read access returns another word.</p>

				<p>Two input iterators are equal if they occupy the same position. However, as stated previously, this does not mean that they return the same value on element access.</p>

				<a name="4"></a><p><taBLE BORdER="1" cELlSPACINg="0" celLPADding="1" WIDTh="100%">
<capTION><h5>Table 7.2. Operations of Input Iterators</h5></caption><colgroup aligN="left" SPAN="2">
<Tr>
<TH vALiGN="top">
<FONT size="2"><B>Expression</B>
								</FOnt></th>
<TH VAlign="top">
<FONT size="2"><b>Effect</b>
								</font></th>
</tr>
<tr>
<td valIGN="top">
<FONt SIzE="2"><I>*iter</i>
								</FONT></TD>
<td vaLIGN="top">
<font SIZE="2">Provides read access to the actual element</font></TD>
</TR>
<tr>
<td valign="top">
<font size="2"><i>iter -&gt;member</i>
								</fONT></TD>
<Td VAlIGn="top">
<FONT SIze="2">Provides read access to a member (if any) of the actual element</foNT></TD>
</tr>
<tr>
<TD VAlign="top">
<FONT size="2"><i>++iter</i>
								</font></td>
<td valign="top">
<fONT SIZe="2">Steps forward (returns new position)</FOnT></Td>
</TR>
<TR>
<TD valiGN="top">
<FOnt siZE="2"><I>iter++</I>
								</font></TD>
<TD valign="top">
<font size="2">Steps forward (returns old position)</font></td>
</tR>
<TR>
<TD VaLIgN="top">
<FoNT SIZE="2"><i>Iter1 == iter2</i>
								</foNT></TD>
<td vaLIGN="top">
<font SIZE="2">Returns whether two iterators are equal</font></td>
</tr>
<tr>
<td valign="top">
<fonT SIZE="2"><I>Iter1 != iter2</i>
								</FOnT></Td>
<TD VALIgn="top">
<foNT SIze="2">Returns whether two iterators are not equal</foNT></TD>
</tr>
<tr>
<TD VAlign="top">
<font size="2"><i>TYPE(iter)</i>
								</font></td>
<tD VALIGn="top">
<FOnT SiZE="2">Copies iterator (copy constructor)</FONT></td>
</tr>
</COLGroup>
</TABLe></p>

				<p>You should always prefer the preincrement operator over the postincrement operator because it might perform better. This is because the preincrement operator does not have to return an old value that must be stored in a temporary object. So, for any iterator <tT CLAss="monofont">pos</tt> (and any abstract data type), you should prefer</p>

				<pre>
					
   ++pos       <i>//OK and fast</i>

				</pre>

				<p>rather than</p>

				<pre>
					
   pos++       <i>//OK, but not so fast</i>

				</pRE>

				<P>The same applies to decrement operators, as long as they are defined (they aren't for input iterators).</P>

			
			<A NaME="5"></a><H4>7.2.2
Output Iterators</H4>
				<p>Output iterators are the counterparts of input iterators. They can only step forward with write access. Thus, you can assign new values only element-by-element. You can't use an output iterator to iterate twice over the same range. The goal is to write a value into a "black hole" (whatever that means). So, if you write something for the second time at the same position into the same black hole, it is not guaranteed that you will overwrite a previous value. <A href="0201379260_snode60.html#6">Table 7.3</A> lists the valid operations for output iterators. The only valid use of operator <tt clASS="monofont">*</Tt> is on the left side of an assignment statement.</p>

				<a nAME="6"></A><p><tabLE BOrder="1" cellspacing="0" cellpaDDING="1" WiDTh="100%">
<CApTION><H5>Table 7.3. Operations of Output Iterators</H5></captION><ColgrOUP Align="left" SPAN="2">
<tr>
<th valign="top">
<font size="2"><b>Expression</b>
								</fONT></TH>
<Th VAlIGn="top">
<FONT SIze="2"><b>Effect</b>
								</FONT></th>
</tr>
<TR>
<TD valiGN="top">
<FOnt size="2"><i>*iter = value</i>
								</font></td>
<td valigN="top">
<FONT SiZE="2">Writes <i>value</I> to where the iterator refers
</FoNT></TD>
</TR>
<tr>
<td VALIgn="top">
<foNT SIze="2"><i>++iter</i>
								</FONT></td>
<td valign="top">
<font size="2">Steps forward (returns new position)</fonT></TD>
</TR>
<Tr>
<TD vALiGN="top">
<FONT size="2"><I>iter++</I>
								</FOnt></td>
<TD VAlign="top">
<FONT size="2">Steps forward (returns old position)</font></td>
</tr>
<tr>
<td valigN="top">
<FONT SiZE="2"><i>TYPE (iter)</I>
								</FoNT></TD>
<TD valiGN="top">
<FOnt siZE="2">Copies iterator (copy constructor)</FOnt></td>
</TR>
</COlgroup>
</table></p>

				<p>Note that no comparison operations are required for output iterators. You can't check whether an output iterator is valid or whether a "writing" was successful. The only thing you can do is to write, and write, and write values.</p>

				<p>Usually iterators can read and write values. So, as for input iterators, almost all iterators also have the abilities of output iterators. A typical example of a pure output iterator is an iterator that writes to the standard output (for example, to the screen or a printer). If you use two output iterators to write to the screen, the second word follows the first rather than overwriting it. Another typical example of output iterators are inserters. Inserters are iterators that insert values into containers. If you assign a value, you insert it. If you then write a second value, you don't overwrite the first value; you just also insert it. Inserters are discussed in <a href="0201379260_snode62.html#6">Section 7.4.2</a>.</P>

			
			<H4>7.2.3
Forward Iterators</H4>
				<P>Forward iterators are combinations of input and output iterators. They have all the abilities of input iterators and most of those of output iterators. <A href="0201379260_snode60.html#8">Table 7.4</a> summarizes the operations of forward iterators.</P>

				<A nAME="8"></A><P><Table BORDer="1" ceLLSPacinG="0" CELlpadding="1" width="100%">
<caption><h5>Table 7.4. Operations of Forward Iterators</H5></CAPTIoN><CoLGrOUP ALIgn="left" spAN="2">
<TR>
<th vaLIGN="top">
<font SIZE="2"><b>Expression</b>
								</font></th>
<th valign="top">
<font sIZE="2"><B>Effect</B>
								</FoNT></tH>
</Tr>
<TR>
<TD VAlign="top">
<FONT size="2"><I>*iter</I>
								</FOnt></td>
<TD VAlign="top">
<font size="2">Provides access to the actual element</font></td>
</tr>
<tR>
<TD VALiGN="top">
<fONt SIZE="2"><I>iter-&gt;</I>
									<i>member</i>
								</foNT></TD>
<td vaLIGN="top">
<font SIZE="2">Provides access to a member of the actual element</font></td>
</tr>
<tr>
<td valign="top">
<fonT SIZE="2"><I>++iter</i>
								</FOnT></Td>
<TD VALIgn="top">
<foNT SIze="2">Steps forward (returns new position)</foNT></TD>
</tr>
<tr>
<TD VAlign="top">
<font size="2"><i>iter++</i>
								</font></td>
<tD VALIGn="top">
<FOnT SiZE="2">Steps forward (returns old position)</FONT></td>
</tr>
<TR>
<TD valiGN="top">
<FOnt siZE="2"><I>iter1 ==</I>
									<i>iter2</i>
								</font></td>
<td valign="top">
<font sIZE="2">Returns whether two iterators are equal</FONt></TD>
</tR>
<Tr>
<TD VALIgn="top">
<foNT SIze="2"><i>iter1 !</i><I>= iter2</I>
								</FOnt></td>
<TD VAlign="top">
<font size="2">Returns whether two iterators are not equal</font></td>
</tr>
<tR>
<TD VALiGN="top">
<fONt SIZE="2"><I>TYPE()</I>
								</font></TD>
<TD valiGN="top">
<FOnt siZE="2">Creates iterator (default constructor)</FOnt></td>
</tr>
<tr>
<td valign="top">
<font sIZE="2"><I>TYPE</I><I>(iter)</i>
								</FOnT></Td>
<TD VALIgn="top">
<foNT SIze="2">Copies iterator (copy constructor)</foNT></TD>
</tr>
<tr>
<TD VAlign="top">
<font size="2"><i>iter1 = iter2</i>
								</font></td>
<tD VALIGn="top">
<FOnT SiZE="2">Assigns an iterator</FONT></td>
</tr>
</COLGroup>
</TABLe></p>

				<p>Unlike input iterators and output iterators, forward iterators can refer to the same element in the same collection and process the same element more than once.</p>

				<P>You might wonder why a forward iterator does not have all of the abilities of an output iterator. One restriction applies that prohibits valid code for output iterators from being valid for forward iterators:</P>

				<UL>
<li><p>For <b>output iterators,</b> writing data without checking for the end of a sequence is correct. In fact, you can't compare an output iterator with an end iterator because output iterators do not have to provide a comparison operation. Thus, the following loop is correct for output iterator <tt class="monofont">pos:</tt></p>

						<pre>
							
   <i>//OK for output iterators</i>
   <i>//ERROR for forward iterators</I>
   while (true) {
       *pos = foo();
        ++pos;
   }
						</PRE>
</LI>
<lI><P>For <b>forward iterators,</B> you must <I>ensure</i> that it is correct to dereference (access the data) before you do this. Thus, the previous loop is not correct for forward iterators. This is because it would result in dereferencing the <TT CLASs="monofont">end()</tt> of a collection, which results in undefined behavior. For forward iterators, the loop must be changed in the following manner:</p>

						<PRE>
							
   <I>//OK for forward iterators</i>
   <i>//IMPOSSIBLE for output iterators</i>
   while (pos != coll.end()) {
       *pos = foo();
       ++pos;
   }

						</pRE>

					</LI>
</ul>
				<p>This loop does not compile for output iterators because operator <tT CLAss="monofont">! =</tt> is not defined for them.</p>

			
			<a name="9"></a><h4>7.2.4
Bidirectional Iterators</h4>
				<p>Bidirectional iterators are forward iterators that provide the additional ability to iterate backward over the elements. Thus, they provide the decrement operator to step backward (<a href="0201379260_snode60.html#10">Table 7.5</a>).</p>

				<A NAME="10"></A><p><TAbLE bORDER="1" CellsPACIng="0" ceLLPAddinG="1" WIDth="100%">
<caption><h5>Table 7.5. Additional Operations of Bidirectional Iterators</h5></caption><colGROUP AlIGn="left" SPaN="2">
<TR>
<TH ValigN="top">
<FONt sizE="2"><B>Expression</B>
								</Font></tH>
<TH Valign="top">
<font size="2"><b>Effect</b>
								</font></th>
</TR>
<TR>
<TD vALiGN="top">
<fONT SIZe="2"><i>-- iter</i>
								</fONT></Td>
<td vALIGn="top">
<fonT SIZe="2">Steps backward (returns new position)</font></td>
</tr>
<tr>
<td valign="top">
<foNT SIZE="2"><i>iter--</I>
								</FoNT></tD>
<TD VALign="top">
<fONT Size="2">Steps backward (returns old position)</fONT></Td>
</tr>
</cOLGRoup>
</table></p>

			
			<a name="11"></a><h4>7.2.5
Random Access Iterators</h4>
				<p>Random access iterators are bidirectional iterators that can perform random access. Thus, they provide operators for "iterator arithmetic" (in accordance with the "pointer arithmetic" of ordinary pointers). That is, they can add and subtract offsets, process differences, and compare iterators with relational operators such as <tt cLASS="monofont">&lt;</TT> and <tT ClASs="monofont">&gt;.</TT>
					<A href="0201379260_snode60.html#12">Table 7.6</a> lists the additional operations of random access iterators.</p>

				<p>Random access iterators are provided by the following objects and types:</P>

				<UL>
<Li><p>Containers with random access (<tt CLASs="monofont">vector, deque</tt>)</p>
</LI>
<LI><p>Strings (<tt class="monofont">string, wstring</tt>)</p>
</li>
<li><p>Ordinary arrays (pointers)</p>

					</li>
</ul>
				<A NAME="12"></A><p><TAbLE bORDER="1" CellsPACIng="0" ceLLPAddinG="1" WIDth="100%">
<caption><h5>Table 7.6. Additional Operations of Random Access Iterators</h5></caption><colGROUP AlIGn="left" SPaN="2">
<TR>
<TH ValigN="top">
<FONt sizE="2"><B>Expression</B>
								</Font></tH>
<TH Valign="top">
<font size="2"><b>Effect</b>
								</font></th>
</TR>
<TR>
<TD vALiGN="top">
<fONT SIZe="2"><i>iter[n]</i>
								</fONT></Td>
<td vALIGn="top">
<fonT SIZe="2">Provides access to the element that has index <i>n</i>
								</font></td>
</tr>
<tr>
<td valign="top">
<FONT SIzE="2"><I>iter+=n</i>
								</FOnT></TD>
<TD ValigN="top">
<FONt sizE="2">Steps <I>n</I> elements forward (or backward, if <I>n</i> is negative)
</fonT></TD>
</Tr>
<tr>
<td valign="top">
<font size="2"><i>iter-=n</i>
								</FONT></TD>
<tD VaLIgN="top">
<FONT Size="2">Steps <i>n</I> elements backward (or forward, if <I>n</I> is negative)
</Font></tD>
</TR>
<Tr>
<td vALIGn="top">
<font size="2"><i>iter+n</i>
								</font></td>
<td vaLIGN="top">
<FOnT SiZE="2">Returns the iterator of the <i>n</I>th next element
</FONT></Td>
</tr>
<tR>
<TD ValigN="top">
<FONt sizE="2"><I>n+iter</I>
								</Font></td>
<td valign="top">
<font size="2">Returns the iterator of the <I>n</I>th next element
</FONT></tD>
</Tr>
<TR>
<tD VALIGn="top">
<fonT SIZe="2"><i>iter-n</i>
								</fONT></Td>
<td vALIGn="top">
<font size="2">Returns the iterator of the <i>n</i>th previous element
</font></td>
</tr>
<tr>
<TD VALIgN="top">
<FoNT sIZE="2"><I>iter1-iter2</I>
								</Font></tD>
<TD ValigN="top">
<FONt sizE="2">Returns the distance between <I>iter1</I> and <I>iter2</i>
								</font></td>
</tr>
<tr>
<td valign="top">
<foNT SIZE="2"><i>iter1&lt;iter2</I>
								</FoNT></tD>
<TD VALign="top">
<fONT Size="2">Returns whether <i>iter1</I> is before <I>iter2</I>
								</Font></tD>
</TR>
<Tr>
<td valign="top">
<font size="2"><i>iter1&gt;iter2</i>
								</foNT></TD>
<TD vALiGN="top">
<fONT SIZe="2">Returns whether <i>iter1</i> is after <i>iter2</I>
								</FONt></td>
</tR>
<TR>
<Td valIGN="top">
<Font size="2"><i>iter1&lt;=iter2</i>
								</font></td>
<td valiGN="top">
<FONT sIZe="2">Returns whether <I>iter1</I> is not after <i>iter2</I>
								</FONT></Td>
</tr>
<tR>
<TD ValigN="top">
<FONt sizE="2"><I>iter1&gt;=iter2</I>
								</Font></td>
<td valign="top">
<font size="2">Returns whether <I>iter1</I> is not before <I>iter2</I>
								</FOnT></Td>
</TR>
</cOLGROUp>
</tabLE></P>

				<P>The following program demonstrates the special abilities of random access iterators:</p>

				<pre>
					
   <I>// iter/itercat.cpp</I>

   #include &lt;vector&gt;
   #include &lt;iostream&gt;
   using namespace std;


   int main()
   {
      vector&lt;int&gt; coll;


      <I>//insert elements from</I> -3 <i>to</i> 9
      for (int i=-3; i&lt;=9; ++i) {
          coll.push_back (i);
      }


      <i>/* print number of elements by processing the distance between beginning and end</i>
       <I>* - NOTE: uses operator -for iterators</I>
       <I>*/</I>
      cout &lt;&lt; "number/distance: " &lt;&lt; coll.end()-coll.begin() &lt;&lt; endl;


      <i>/* print all elements</i>
       <i>* - NOTE: uses operator &lt; instead of operator</i> ! =
       <i>*/</i>
      vector&lt;int&gt;::iterator pos;
       for (pos=coll.begin(); pos&lt;coll.end(); ++pos) {
           cout &lt;&lt; *pos &lt;&lt; ' '; 
       }
       cout &lt;&lt; endl;


       <i>/* print all elements</i>
        <i>* - NOTE: uses operator</i> [ ] <i>instead of operator</i> *
        <i>*/</i>
       for (int i=0; i&lt;coll.size(); ++i) {
           cout &lt;&lt; coll.begin() [i] &lt;&lt; ' ';
       }
       cout &lt;&lt; endl;


       <i>/* print every second element</i>
        <i>* - NOTE: uses operator +=</i>
        <i>*/</i>
       for (pos = coll.begin(); pos &lt; coll.end()-1; pos += 2) {
           cout &lt;&lt; *pos &lt;&lt; ' ';
       }
       cout &lt;&lt; endl;
   }

				</pRE>

				<P>The output of the program is as follows:</P>

				<PRe>
					
   number/distance: 13
   -3 -2 -1 0 1 2 3 4 5 6 7 8 9
   -3 -2 -1 0 1 2 3 4 5 6 7 8 9
   -3 -1 1 3 5 7

				</PRe>

				<P>This example won't work with lists, sets, and maps because all operations that are marked with <I>NOTE:</i> are provided only for random access iterators. In particular, keep in mind that you can use operator <TT CLASs="monofont">&lt;</tt> as an end criterion in loops for random access iterators only.</p>

				<P>Note that in the last loop the expression</P>

				<PRe>
					
   pos &lt; coll.end()-1

				</pre>

				<P>requires that <TT Class="monofont">coll</TT> contains at least one element. If the collection was empty, <TT class="monofont">coll.end()</tt>
					<tt class="monofont">-1</tt> would be the position before <tt claSS="monofont">coll.begin().</TT> The comparison might still work; but, strictly speaking, moving an iterator to before the beginning results in undefined behavior. Similarly, the expression <TT cLAsS="monofont">pos += 2</Tt> might result in undefined behavior if it moves the iterator beyond the <TT CLASs="monofont">end()</tt> of the collection. Therefore, changing the final loop to the following is very dangerous because it results in undefined behavior if the collection contains an even number of elements (<a href="0201379260_snode60.html#13">Figure 7.2</a>):</p>

				<ceNTER>
					<h5>
<a naME="13"></A>Figure 7.2. Incrementing Iterators by More than One Element</H5><img border="0" width="500" height="193" src="FILES/07fig02.gif" ALT="graphics/07fig02.gif"></CeNTeR>

				<PrE>
					
   for (pos = coll.begin(); pos &lt; coll.end(); pos += 2) {
       cout &lt;&lt; *pos &lt;&lt; ' ';
   }

				</PRE>

			
			<A Name="14"></a><H4>7.2.6
The Increment and Decrement Problem of Vector Iterators</H4>
				<P>The use of the increment and decrement operators of iterators includes a strange problem. In general, you can increment and decrement temporary iterators. However, for vectors and strings, you typically can't. Consider the following vector example:</P>

				<pre>
					
   std::vector&lt;int&gt; coll;
   ...
   <i>//sort, starting with the second element</I>
   <I>// - NONPORTABLE version</I> 
   if (coll.size() &gt; 1) {
       coll.sort (++coll.begin(), coll.end());
   }

				</Pre>

				<p>Typically, the compilation of <tT CLAss="monofont">sort()</tt> fails. However, if you use, for example, a deque rather than a vector, it will compile. It might compile even with vectors, depending on the implementation of class <tt class="monofont">vector.</tt></p>

				<p>The reason for this strange problem lies in the fact that vector iterators are typically implemented as ordinary pointers. And for all fundamental data types, such as pointers, you are not allowed to modify temporary values. For structures and classes, however, it is allowed. Thus, if the iterator is implemented as an ordinary pointer, the compilation fails; if implemented as a class, it succeeds. It always works with deques, lists, sets, and maps because you can't implement iterators as ordinary pointers for them. But for vectors, whether it works depends on the implementation. Usually, ordinary pointers are used. But if, for example, you use a "safe version" of the STL, the iterators are implemented as classes. To make your code portable you should not code as the previous example, using vectors. Instead, you should use an auxiliary object:</p>

				<pre>
					
   std::vector&lt;int&gt; coll;
   ...
   <i>//sort, starting with the second element</i>
   <I>// - PORTABLE version</I>
   if (coll.size() &gt; 1) {
       std::vector&lt;int&gt;::iterator beg = coll.begin();
       coll.sort (++beg, coll.end()); 
   }

				</PRE>

				<P>The problem is not as bad as it sounds. You can't get unexpected behavior because it is detected at compile time. But it is tricky enough to spend time solving it. This problem also applies to strings. String iterators are usually also implemented as ordinary character pointers, although this is not required.</p>

			
		</FOnT>
 
<table width="100%" border="0" cellspacing="0" cellpadding="0" bgcolor="#CCCCCC">
<td><font color="black" size=1>I l<font color="#FF0000">@</font>ve RuBoard</td>
<td valign="top" class="v2" align="right"><a href="0201379260_snode59.html"><img src="FILES/previous.gif" width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a> <a href="0201379260_snode61.html"><img src="FILES/next.gif" width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a></td></table>
</BODY></HTML>