<HTML><HEAD><META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=iso-8859-1">
<!--SafClassName="docSection1Title"--><!--SafTocEntry="7.4 Iterator Adapters"-->
<LINK REL="stylesheet" href="FILES/sbolM.css">
</HEAD>
<BODY link="#354278" vlink="#000066" alink="#000080" topmargin="0">
<table width="100%" border="0" cellspacing="0" cellpadding="0" bgcolor="#CCCCCC">
<td><font color="black" size=1>I l<font color="#FF0000">@</font>ve RuBoard</td>
<td valign="top" class="v2" align="right"><a href="0201379260_snode61.html"><img src="FILES/previous.gif" width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a> <a href="0201379260_snode63.html"><img src="FILES/next.gif" width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a></td></table>
<FONT><h3>7.4
Iterator Adapters</h3>
			<p>This section covers iterator adapters. These special iterators allow algorithms to operate in reverse, in insert mode, and with streams.</p>

			<A NAMe="1"></a><h4>7.4.1
Reverse Iterators</h4>
				<P><I>Reverse iterators</I> are adapters that redefine increment and decrement operators so that they behave in reverse. Thus, if you use these iterators instead of ordinary iterators, algorithms process elements in reverse order. All standard container classes provide the ability to use reverse iterators to iterate over their elements. Consider the following example:</P>

				<pre>
					
   <i>// iter/reviter1.cpp</I>

   #include &lt;iostream&gt; 
   #include &lt;list&gt;
   #include &lt;algorithm&gt;
   using namespace std;


   void print (int elem) 
   {
       cout &lt;&lt; elem &lt;&lt; ' ';
   }


   int main()
   {
       list&lt;int&gt; coll;


       <I>//insert elements from</I> 1 <I>to</i> 9
       for (int i=1; i&lt;=9; ++i) {
            coll.push_back(i);
       }


       <i>//print all elements in normal order</i>
       for_each (coll.begin(), coll.end(),      <i>//range</i>
                 print);                        <i>//operation</i>
       cout &lt;&lt; endl;


       <i>//print all elements in reverse order</i>
       for_each (coll.rbegin(), coll.rend(),    <i>//range</i>
                 print);                        <i>//operations</i>
       cout &lt;&lt; endl; 
   }

				</pre>

				<p>The <tt clASS="monofont">rbegin()</TT> and <Tt CLaSS="monofont">rend()</tT> member functions return a reverse iterator. According to <TT CLAss="monofont">begin()</tt> and <TT CLass="monofont">end(),</tT> these iterators define the elements to process as a half-open range. However, they operate in a reverse direction:</P>

				<UL>
<li><p><b><TT CLass="monofont">rbegin()</tt></b> returns the position of the first element of a reverse iteration. Thus, it returns the position of the last element.</p>
</li>
<li><p><b><tt class="monofont">rend()</tT></B> returns the position after the last element of a reverse iteration. Thus, it returns the position <I>before</I> the first element.</P>

					</Li>
</UL>
				<h5>Iterators and Reverse Iterators</H5>
					<P>You can convert normal iterators to reverse iterators. Naturally, the iterators must be bidirectional iterators, but note that the logical position of an iterator is moved during the conversion. Consider the following program:</p>

					<PRE>
						
   <I>// iter/reviter2.cpp</I>

   #include &lt;iostream&gt;
   #include &lt;vector&gt;
   #include &lt;algorithm&gt;
   using namespace std;


   int main() 
   {
       vector&lt;int&gt; coll;


       <I>//insert elements from</i> 1 <i>to</i> 9
       for (int i=1; i&lt;=9; ++i) {
            coll.push_back(i);
       }


       <i>//find position of element with value</I> 5
       vector&lt;int&gt;::iterator pos;
       pos = find (coll.begin(), coll.end(),
                   5);


       <I>//print value to which iterator</I> pos <I>refers</i>
       cout &lt;&lt; "pos: " &lt;&lt; *pos &lt;&lt; endl;


       <i>//convert iterator to reverse iterator</i> rpos
       vector&lt;int&gt;::reverse_iterator rpos(pos);


       <i>//print value to which reverse iterator</I> rpos <I>refers</I>
       cout &lt;&lt; "rpos: " &lt;&lt; *rpos &lt;&lt;endl;
   }

					</Pre>

					<p>This program has the following output:</p>

					<PRE>
						
   pos:  5
   rpos: 4

					</Pre>

					<p>Thus, if you print the value of an iterator and convert the iterator into a reverse iterator, the value has changed. This is not a bug; it's a feature! This behavior is a consequence of the fact that ranges are half-open. To specify all elements of a container, you must use the position after the last argument. However, for a reverse iterator this is the position before the first element. Unfortunately, such a position may not exist. Containers are not required to guarantee that the position before their first element is valid. Consider that ordinary strings and arrays might also be containers, and the language does not guarantee that arrays don't start at address zero.</p>

					<p>As a result, the designers of reverse iterators use a trick: They "physically" reverse the "half-open principle." Physically, in a range defined by reverse iterators, the beginning is <i>not</i> included, whereas the end <i>is.</i> However, logically, they behave as usual. Thus, there is a distinction between the physical position that defines to which element the iterator refers and the logical position that defines to which value the iterator refers (<a href="0201379260_snode62.html#3">Figure 7.3</a>). The question is, what happens on a conversion from an iterator to a reverse iterator? Does the iterator keep its logical position (the value) or its physical position (the element)? As the previous example shows, the latter is the case. Thus the value is moved to the previous element (<a href="0201379260_snode62.html#4">Figure 7.4</a>).</P>

					<CENTEr>
						<H5>
<A nAMe="3"></A>Figure 7.3. Position and value of Reverse Iterators</H5><IMG BordeR="0" WIDth="500" heIGHT="152" src="FILES/07fig03.gif" aLT="graphics/07fig03.gif"></CEnter>

					<center>
						<h5>
<a name="4"></a>Figure 7.4. Conversion Between Iterator <tt clASS="monofont">pos</TT> and Reverse Iterator <Tt CLaSS="monofont">rpos</tT></H5><IMG BordeR="0" WIDth="499" heIGHT="251" src="FILES/07fig04.gif" aLT="graphics/07fig04.gif"></CEnter>

					<p>You can't understand this decision? Well, it has its advantages: You have nothing to do when you convert a range that is specified by two iterators rather than a single iterator. All elements stay valid. Consider the following example:</p>

					<pre>
						
   <i>// iter/reviter3.cpp</i>

   #include &lt;iostream&gt;
   #include &lt;deque&gt;
   #include &lt;algorithm&gt;
   using namespace std;


   void print (int elem)
   {
        cout &lt;&lt; elem &lt;&lt; ' ';
   }


   int main()
   {
       deque&lt;int&gt; coll;


       <i>//insert elements from</i> 1 <i>to</i> 9
       for (int i=1; i&lt;=9; ++i) {
           coll.push_back(i);
       }


       <i>//find position of element with value</i> 2
       deque&lt;int&gt;::iterator pos1;
       pos1 = find (coll.begin(), coll.end(),    <i>//range</i>
                    2);                          <i>//value</i>


       <I>//find position of element with value</I> 7
       deque&lt;int&gt;::iterator pos2;
       pos2 = find (coll.begin(), coll.end(),    <I>//range</I>
                    7);                          <I>//value</I>


       <i>//print all elements in range</I> [pos1,pos2)
       for_each (pos1, pos2,               <I>//range</i>
                 print);                   <I>//operation</I>
       cout &lt;&lt; endl;


       <i>//convert iterators to reverse iterators</I>
       deque&lt;int&gt;::reverse_iterator rpos1(pos1);
       deque&lt;int&gt;::reverse_iterator rpos2(pos2);


      <I>//print all elements in range</I> [pos1,pos2) <I>in reverse order</I>
      for.each (rpos2, rpos1,             <I>//range</i>
                print);                   <i>//operation</i>
      cout &lt;&lt; endl; 
   }

					</pRE>

					<P>The iterators <Tt claSS="monofont">pos1</TT> and <tt clASS="monofont">pos2</Tt> specify the half-open range, including the element with value <tt class="monofont">2</tt> but excluding the element with value <tt class="monofont">7.</tt> When the iterators describing that range are converted to reverse iterators, the range stays valid and can be processed in reverse order. Thus, the output of the program is as follows:</p>

					<pRE>
						
   2 3 4 5 6
   6 5 4 3 2

					</PRE>

					<P>Thus, <tT ClASs="monofont">rbegin()</TT> is simply:</P>

					<PRE>
						
<i>   container:</i>:reverse_iterator(end())

					</prE>

					<P>and <TT clasS="monofont">rend()</TT> is simply:</P>

					<pre>
						
<i>   container:</I>:reverse_iterator(begin())

					</PRE>

					<p>Of course, constant iterators are converted into type <tt class="monofont">const_reverse_iterator.</tt></p>

				
				<h5>Converting Reverse Iterators Back Using <tt class="monofont">base()</tt></H5>
					<P>You can convert reverse iterators back to normal iterators. To do this, reverse iterators provide the <TT CLaSS="monofont">base()</tT> member function:</P>

					<pRE>
						
   namespace std {
       template &lt;class Iterator&gt;
       class reverse_iterator ... {
           ...
           Iterator base() const;
           ...
       };
   }

					</PRE>

					<P>Here is an example of the use of <tt clASS="monofont">base():</Tt></p>

					<prE>
						
   <I>// iter/reviter4.cpp</I>

   #include &lt;iostream&gt;
   #include &lt;list&gt;
   #include &lt;algorithm&gt;
   using namespace std;


   int main()
   {
       list&lt;int&gt; coll;


       <I>//insert elements from</i> 1 <i>to</i> 9 
       for (int i=1; i&lt;=9; ++i) {
            coll.push_back(i);
       }


       <i>//find position of element with value</I> 5
       list&lt;int&gt;::iterator pos;
       pos = find (coll.begin(), coll.end(),    <I>//range</I>
                   5);                          <I>//value</i>


       <i>//print value of the element</i>
       cout &lt;&lt; "pos: " &lt;&lt; *pos &lt;&lt; endl;


       <i>//convert iterator to reverse iterator</i>
       list&lt;int&gt;::reverse_iterator rpos(pos);


       <i>//print value of the element to which the reverse iterator refers</i>
       cout &lt;&lt; "rpos: " &lt;&lt; *rpos &lt;&lt; endl;


       <i>//convert reverse iterator back to normal iterator</i>
       list&lt;int&gt;::iterator rrpos;
       rrpos = rpos.base();


       <i>//print value of the element to which the normal iterator refers</i>
       cout &lt;&lt; "rrpos: " &lt;&lt; *rrpos &lt;&lt; endl;
   }

					</pre>

					<p>The program has the following output:</p>

					<pre>
						
   pos:     5
   rpos:    4
   rrpos:   5

					</prE>

					<P>Thus, the conversion with <TT CLaSS="monofont">base()</tT></P>

					<pRE>
						
   *rpos.base()

					</PRE>

					<P>is equivalent to the conversion in a reverse iterator. That is, the physical position (the element of the iterator) is retained, but the logical position (the value of the element) is moved. You can find another example of the use of <tt clASS="monofont">base()</Tt> on page 353.</p>

				
			
			<a nAME="6"></A><h4>7.4.2
Insert Iterators</h4>
				<p>Insert iterators, also called <i>inserters,</I> are iterator adapters that transform an assignment of a new value into an insertion of that new value. By using insert iterators, algorithms can insert rather than overwrite. All insert iterators are in the output iterator category. Thus, they provide only the ability to assign new values (see <A href="0201379260_snode60.html#5">Section 7.2.2</a>).</p>

				<h5>Functionality of Insert Iterators</h5>
					<p>Usually an algorithm assigns values to a destination iterator. For example, consider the <tt class="monofont">copy()</tt> algorithm (described on page 363):</p>

					<pre>
						
   namespace std {
       template &lt;class InputIterator, class OutputIterator&gt;
       OutputIterator copy (InputIterator from_pos,    <i>//beginning of source</I>
                            InputIterator from_end,    <I>//end of source</I>
                            OutputIterator to_pos)     <I>//beginning of dest.</I>
       {
           while (from_pos != from_end) {
               *to_pos = *from_pos;    <I>//copy values</i>
               ++from_pos;             <I>//increment iterators</I>
               ++to_pos;
           }
           return to_pos; 
       }
   }

					</pRE>

					<p>The loop runs until the actual position of the source iterator has reached the end. Inside the loop, the source iterator, <TT CLASs="monofont">from_pos,</tt> is assigned to the destination iterator, <tT CLAss="monofont">to_pos,</tt> and both iterators get incremented. The interesting part is the assignment of the new value:</P>

					<PRE>
						
   *to_pos = <i>value</i>

					</prE>

					<P>An insert iterator transforms such an assignment into an insertion. However, there actually are two operations involved: First, operator * returns the actual element of the iterator, and second, operator <TT class="monofont">=</tt> assigns the new value. Implementations of insert iterators usually use the following two-step trick:</p>

					
						<p><b>Step 1.</b>

							Operator <tt class="monofont">*</tt> is implemented as a no-op that simply returns <tT CLASS="monofont">*this.</tT> Thus, for insert iterators, <Tt CLaSS="monofont">*pos</TT> is equivalent to <TT clasS="monofont">pos.</TT>
						</P>
						<p><b>Step 2.</b>

							The assignment operator is implemented so that it gets transferred into an insertion. In fact, the insert iterator calls the <tT CLAss="monofont">push_back(), push_front(),</tt> or <TT CLass="monofont">insert()</tt> member function of the container.
						</p>
					
					<p>Thus, for insert iterators, you could write <tt class="monofont">pos=</tt><i>value</i> instead of <tt cLASS="monofont">*pos=</TT><i>value</I> to insert a new value. However, I'm talking about implementation details of input iterators. The correct expression to assign a new value is <Tt CLaSS="monofont">*pos=</TT><I>value.</I></p>

					<p>Similarly, the increment operator is implemented as a no-op that simply returns <tt CLASs="monofont">*this.</tt> Thus,</p>

					<P>you can't modify the position of an insert iterator. <A href="0201379260_snode62.html#8">Table 7.7</a> lists all operations of insert iterators.</p>

					<A NAMe="8"></a><p><table border="1" cellspaCING="0" CElLPaDDiNG="1" WIDTh="100%">
<capTION><h5>Table 7.7. Operations of Insert Iterators</h5></caPTIOn><colGROUp align="left" span="2">
<tr>
<td valign="top">
<fONT SIZe="2"><B>Expression</B>
									</fONt></TD>
<TD VAlign="top">
<FONT size="2"><B>Effect</B>
									</FOnt></td>
</TR>
<TR>
<td valign="top">
<font size="2"><i>*iter</i>
									</fonT></TD>
<TD VaLIgN="top">
<FoNT SIZE="2">No-op (returns <i>iter</i>)
</foNT></TD>
</tr>
<tr>
<TD VAlign="top">
<FONT size="2"><i>iter = value</i>
									</font></td>
<td valign="top">
<fONT SIZe="2">Inserts <I>value</I>
									</fONt></TD>
</TR>
<TR>
<td vaLIGN="top">
<font SIZE="2"><i>++iter</i>
									</foNT></TD>
<td valign="top">
<font size="2">No-op (returns <i>iter</i>)
</fonT></TD>
</TR>
<Tr>
<TD vALiGN="top">
<FONT size="2"><I> iter++</I>
									</FOnt></td>
<TD VAlign="top">
<FONT size="2">No-op (returns <i>iter</i>)
</font></td>
</tr>
</colgrouP>
</TABLE></p>

				
				<H5>Kinds of Insert Iterators</H5>
					<p>The C++ standard library provides three kinds of insert iterators: back inserters, front inserters, and general inserters. They differ in their handling of the position at which to insert a value. In fact, each uses a different member function, which it calls for the container to which it belongs. Thus, an insert iterator must be always initialized with its container.</P>

					<P>Each kind of insert iterator has a convenience function for its creation and initialization. <a href="0201379260_snode62.html#10">Table 7.8</A> lists the different kinds of insert iterators and their abilities.</P>

					<a namE="10"></A><P><Table BORDer="1" ceLLSPacing="0" cellpadding="1" width="100%">
<CAPTIOn><H5>Table 7.8. Kinds of Insert Iterators</H5></cAPtION><COLgrouP ALIgn="left" spAN="4">
<TR>
<th vaLIGN="top">
<font size="2"><b>Name</b>
									</font></th>
<th valIGN="top">
<FONt SIzE="2"><B>Class</b>
									</FONT></TH>
<th vaLIGN="top">
<font SIZE="2"><b>Called Function</b>
									</foNT></TH>
<th valign="top">
<font size="2"><b>Creation</b>
									</fonT></TH>
</TR>
<Tr>
<TD vALiGN="top">
<FONT size="2">Back inserter</FONT></td>
<td VALIgn="top">
<foNT SIze="2"><tt class="monofont">back_insert_iterator</tt>
									</font></td>
<td vaLIGN="top">
<FOnT SiZE="2"><tT CLASS="monofont">push_back</tt>
										<i>(value)</i>
									</FONT></td>
<td VALIgn="top">
<foNT SIze="2"><tt class="monofont">back_inserter</tt>
										<i>(cont)</i>
									</font></td>
</tr>
<TR>
<TD VAlIGn="top">
<FOnT SIZE="2">Front inserter</Font></tD>
<TD ValigN="top">
<FONt sizE="2"><TT Class="monofont">front_insert_iterator</tt>
									</font></td>
<td valign="top">
<fONT SIZe="2"><TT cLAsS="monofont">push_front</TT>
										<I>(value)</I>
									</Font></tD>
<TD ValigN="top">
<FONt sizE="2"><TT Class="monofont">front_inserter</tt>
										<i>(cont)</i>
									</font></td>
</tr>
<tr>
<td vALIGN="top">
<FoNT sIZe="2">General inserter</FONT></TD>
<td vaLIGN="top">
<font SIZE="2"><tt clASS="monofont">insert_iterator</Tt>
									</font></td>
<td valign="top">
<font siZE="2"><TT CLaSS="monofont">insert</tT><I> (pos, value)</i>
									</FONT></TD>
<td vaLIGN="top">
<font SIZE="2"><tt clASS="monofont">inserter</Tt><i> (cont, pos)</i>
									</font></td>
</tr>
</colgroup>
</taBLE></P>

					<P>Of course, the container must provide the member function that the insert iterator calls; otherwise, that kind of insert iterator can't be used. For this reason, back inserters are available only for vectors, deques, lists, and strings; front inserters are available only for deques and lists. The following subsections describe the insert iterators in detail.</P>

				
				<h5>Back Inserters</H5>
					<P>A <i>back inserter</I> (or <I>back insert iterator)</i> appends a value at the end of a container by calling the <TT CLASs="monofont">push_back()</tt> member function (see page 241 for details about <tT CLAss="monofont">push_back()</tt>). <TT CLass="monofont">push_back()</tT> is available only for vectors, deques, lists, and strings, so these are the only containers in the C++ standard library for which back inserters are usable.</P>

					<P>A back inserter must be initialized with its container at creation time. The <Tt class="monofont">back_inserter()</tt> function provides a convenient way of doing this. The following example demonstrates the use of back inserters:</p>

					<pre>
						
   <i>// iter/backins.cpp</i>

   #include &lt;iostream&gt;
   #include &lt;vector&gt;
   #include &lt;algorithm&gt;
   #include "print.hpp"
   using namespace std;


   int main() 
   {
       vector&lt;int&gt; coll;


       <i>//create, back inserter for</i> coll
       <i>// - inconvenient way</i>
       back_insert_iterator&lt;vector&lt;int&gt; &gt; iter(coll);


       <i>//insert elements with the usual iterator interface</i>
       *iter = 1;
       iter++;
       *iter = 2;
       iter++;
       *iter = 3;


       PRINT_ELEMENTS(coll);


       <i>//create back inserter and insert elements</I>
       <I>// - convenient way</I>
       back_inserter(coll) = 44;
       back_inserter(coll) = 55;


       PRINT_ELEMENTS(coll);


       <I>//use back inserter to append all elements again</I> 
       copy (coll .begin(), coll.end(),                     <I>//source</i>
             back_inserter(coll));                          <I>//destination</I>
       PRINT_ELEMENTS(coll); 
   }

					</pRE>

					<p>The output of the program is as follows:</P>

					<PRE>
						
   1 2 3
   1 2 3 44 55
   1 2 3 44 55 1 2 3 44 55

					</PRe>

					<p>Note that you must not forget to reserve enough space before calling <tt CLASs="monofont">copy()</tt>. This is because the back inserter inserts elements, which might invalidate all other iterators referring to the same vector.Thus, the algorithm invalidates the passed source iterators while running, if not enough space is reserved.</p>

					<P>Strings also provide an STL container interface, including <TT Class="monofont">push_back().</TT> Therefore, you could use back inserters to append characters in a string. See page 502 for an example.</P>

				
				<H5>Front Inserters</h5>
					<p>A <i>front inserter</i> (or <i>front insert iterator</i>) inserts a value at the beginning of a container by calling the <tt class="monofont">push_front()</tt> member function (see page 241 for details about <tt clasS="monofont">push_front()</TT>). <TT ClASs="monofont">push_front()</TT> is available only for deques and lists, so these are the only containers in the C++ standard library for which front inserters are usable.</p>

					<P>A front inserter must be initialized with its container at creation time. The <TT CLAss="monofont">front_inserter()</tt> function provides a convenient way of doing this. The following example demonstrates the use of front inserters:</P>

					<PRE>
						
   <i>// iter/frontins.cpp</i>

   #include &lt;iostream&gt;
   #include &lt;list&gt;
   #include &lt;algorithm&gt;
   #include "print.hpp"
   using namespace std;


   int main()
   {
       list&lt;int&gt; coll;


       <i>//create front inserter for</i> coll
       <I>// - inconvenient way</I>
       front_insert_iterator&lt;list&lt;int&gt; &gt; iter(coll);


       <I>//insert elements with the usual iterator interface</I>
       *iter = 1;
       iter++;
       *iter = 2;
       iter++;
       *iter = 3;


       PRINT_ELEMENTS(coll);


       <i>//create front inserter and insert elements</i>
       <i>// - convenient way</i>
       front_inserter(coll) = 44;
       front_inserter(coll) = 55;


       PRINT_ELEMENTS(coll);


       <I>//use front inserter to insert all elements again</I>
       copy (coll.begin(), coll.end(),                  <I>//source</I>
             front_inserter(coll));                     <i>//destination</i>

       PRINT_ELEMENTS(coll); 
   }

					</pre>

					<p>The output of the program is as follows:</p>

					<pre>
						
   3 2 1
   55 44 3 2 1
   1 2 3 44 55 55 44 3 2 1

					</pre>

					<p>Note that the front inserter inserts multiple elements in reverse order. This happens because it always inserts the next element in front of the previous one.</p>

				
				<h5>General Inserters</h5>
					<p>A <i>general inserter</i> (or <i>general insert iterator</I>)<FONT SiZE="1"><sUP><a HREF="#FOOTNOTE-2">[2]</A></Sup></foNT>
 is initialized with two values: the container and the position that is used for the insertions. Using both, it calls the <TT clasS="monofont">insert()</TT> member function with the specified position as argument. The <Tt claSS="monofont">inserter()</TT> function provides a convenient way of creating and initializing a general inserter.</p>
<blockquote><font size="1">
<p cLASS="footnote">
<SUp><A NaME="FOOTNOTE-2">[2]</a></SUP>
A general inserter is often simply called <I>insert iterator</I> or <I>inserter.</i> This means that the words <i>insert iterator</i> and <i>inserter</I> have different meanings: They are a general term for all kinds of insert iterators. They are also used as names for a special insert iterator that inserts at a specified position rather than in the front or in the back. To avoid this ambiguity, I use the term <I>general inserter</I> in this book.</P>
</font></BLOCkquoTE>

					<P>A general inserter is available for all standard containers because all containers provide the needed <Tt class="monofont">insert()</tt> member function. However, for associative containers (set and maps) the position is used only as a hint because the value of the element defines the correct position. See the description of <tt class="monofont">insert()</tt> on page 240 for details.</p>

					<p>After an insertion, the general inserter gets the position of the new inserted element. In particular, the following statements are called:</p>

					<pRE>
						
      <I>pos = container.</I> insert <I>(pos, value);</I>
      <i>++pos;</I>

					</PrE>

					<P>The assignment of the return value of <tT CLASS="monofont">insert()</tt> ensures that the iterator's position is always valid. Without the assignment of the new position for deques, vectors, and strings, the general inserter would invalidate itself. This is because each insertion does, or at least might, invalidate all iterators that refer to the container.</p>

					<p>The following example demonstrates the use of general inserters:</P>

					<PRE>
						
   <i>// iter/inserter.cpp</i>

   #include &lt;iostream&gt;
   #include &lt;set&gt;
   #include &lt;list&gt;
   #include &lt;algorithm&gt;
   #include "print.hpp"
   using namespace std;


   int main() 
   {
       set&lt;int&gt; coll;


       <i>//create insert iterator for</i> coll
       <I>// - inconvenient way</I>
       insert_iterator&lt;set&lt;int&gt; &gt; iter(coll,coll.begin());


       <I>//insert elements with the usual iterator interface</I>
       *iter = 1;
       iter++;
       *iter = 2;
       iter++;
       *iter = 3;


       PRINT.ELEMENTS(coll,"set: ");


       <i>//create inserter and insert elements</i>
       <i>// - convenient way</i>
       inserter(coll,coll.end()) = 44;
       inserter(coll,coll.end()) = 55;


       PRINT_ELEMENTS(coll,"set: ");


       <I>//use inserter to insert all elements into a list</I>
       list&lt;int&gt; coll2;
       copy (coll.begin(), coll.end(),                             <I>//source</I>
             inserter(coll2,coll2.begin()));                       <i>//destination</i>


       PRINT_ELEMENTS(coll2,"list: ");


       <i>//use inserter to reinsert all elements into the list before the second element</i>
       copy (coll.begin(), coll.end(),                             <i>//source</i>
             inserter(coll2,++coll2.begin()));                     <i>//destination</i>


       PRINT_ELEMENTS(coll2,"list: "); 
   }

					</pre>

					<p>The output of the program is as follows:</p>

					<pre>
						
   set:  1 2 3
   set:  1 2 3 44 55
   list: 1 2 3 44 55
   list: 1 1 2 3 44 55 2 3 44 55

					</pre>

					<p>The calls of <tT CLASS="monofont">copy()</tT> demonstrate that the general inserter maintains the order of the elements. The second call of <Tt CLaSS="monofont">copy()</TT> uses a certain position inside the range that is passed as argument.</P>

				
				<H5>A User-Defined Inserter for Associative Containers</h5>
					<p>As mentioned previously, for associative containers the position argument of general inserters is only used as a hint. This hint might help to improve speed, however it also might cause bad performance. For example, if the inserted elements are in reverse order, the hint may slow down programs a bit. This is because the search for the correct insertion point always starts at a wrong position. Thus, a bad hint might even be worse than no hint. This is a good example of a useful supplementation of the C++ standard library. See <a href="0201379260_snode63.html#5">Section 7.5.2</A>, for such an extension.</p>

				
			
			<a naME="16"></A><H4>7.4.3
Stream Iterators</h4>
				<p>A <i>stream iterator</i> is an iterator adapter that allows you to use a stream as source or destination of algorithms. In particular, an streams iterator can be used to read elements from an input stream and an ostream iterator can be used to write values to an output stream.</P>

				<P>A special form of a stream iterator is a <I>stream buffer iterator,</I> which can be used to read from or write to a stream buffer directly. Stream buffer iterators are discussed in <a href="0201379260_snode113.html#1">Section 13.13.2</a>.</p>

				<h5>Ostream Iterators</h5>
					<p><i>Ostream iterators</i> write assigned values to an output stream. By using ostream iterators, algorithms can write directly to streams. The implementation of an ostream iterator uses the same concept as the implementation of insert iterators (see page 271). The only difference is that they transform the assignment of a new value into an output operation by using operator <tt class="monofont">&gt;&gt;.</tt> Thus, algorithms can write directly to streams using the usual iterator interface. <A href="0201379260_snode62.html#18">Table 7.9</A> lists the operations of ostream iterators.</p>

					<A NaME="18"></a><P><TABLE bordER="1" CEllspACINg="0" celLPADding="1" width="100%">
<caption><h5>Table 7.9. Operations of ostream Iterators</h5></capTION><COlGRoUP aLIGN="left" SPan="2">
<tr>
<TH VAlign="top">
<FONT size="2"><B>Expression</B>
									</FOnt></th>
<th valign="top">
<font size="2"><b>Effect</B>
									</FONT></Th>
</TR>
<tR>
<Td VALIGN="top">
<font SIZE="2"><tt clASS="monofont">Ostream_iterator</Tt>&lt;<i>T</i>&gt; (<i>ostream</I>)
</FONt></td>
<td valign="top">
<font size="2">Creates an ostream iterator for <i>ostream</i>
									</FONT></TD>
</tR>
<Tr>
<TD vALIGN="top">
<Font sIZE="2"><Tt claSS="monofont">ostream_iterator</TT>&lt;<i>T</i>&gt; (<i>ostream,delim</i>)
</FONT></td>
<td valign="top">
<font size="2">Creates an ostream iterator for <i>ostream</i> with the string <i>delim</I> as the delimiter between the values (note that <I>delim</I> has type <TT ClASs="monofont">const char*</TT>)
</fONT></TD>
</Tr>
<tr>
<tD VALign="top">
<fONT Size="2"><i>*iter</I>
									</FONt></td>
<td valign="top">
<font size="2">No-op (returns <i>iter</i>)
</FONT></TD>
</tR>
<Tr>
<TD vALIGN="top">
<Font sIZE="2"><I>iter = value</i>
									</fonT></TD>
<Td valIGN="top">
<Font size="2">Writes <i>value</i> to <i>ostream: ostream&lt;&lt;value</i> (followed by <i>delim</i> if set)
</font></td>
</tr>
<TR>
<TD VAlIGn="top">
<FOnT SIZE="2"><I>++iter</i>
									</fonT></TD>
<Td valIGN="top">
<Font sIZE="2">No-op (returns <I>iter</i>)
</font></td>
</tr>
<tr>
<td valign="top">
<foNT SIZE="2"><i>iter++</I>
									</FoNT></tD>
<TD VALign="top">
<fONT Size="2">No-op (returns <i>iter)</I>
									</FONt></td>
</tR>
</COLgroup>
</table></p>

					<p>At creation time of the ostream iterator you must pass the output stream on which the values are written. An optional string can be passed, which is written as a separator between single values. Without the delimiter, the elements directly follow each other.</p>

					<p>Ostream iterators are defined for a certain element type T:</p>

					<pre>
						
   namespace std {
       template &lt;class T,
                 class charT = char,
                 class traits = char_traits&lt;charT&gt; &gt;
       class ostream_iterator; 
   }

					</pre>

					<P>The optional second and third template arguments specify the type of stream that is used (see <A href="0201379260_snode102.html#1">Section 13.2.1</a>, for their meaning).<FOnT SiZE="1"><SUP><A href="#FOOTNOTE-3">[3]</A></SUP></font>
</P>
<BLOckquOTE><Font size="1">
<p class="footnote">
<sup><a name="FOOTNOTE-3">[3]</A></SUP>
In older systems, the optional template arguments for the stream type are missing.</P>
</FoNT></bLOcKQUOTE>

						
					<p>The following example demonstrates the use of ostream iterators:</p>

					<prE>
						
   <I>// iter/ostriter.cpp</I>

   #include &lt;iostream&gt;
   #include &lt;vector&gt;
   #include &lt;algorithm&gt;
   using namespace std;


   int main()
   {
       <I>//create ostream iterator for stream</i> cout
       <i>// - values are separated by a newline character</i>
       ostream_iterator&lt;int&gt; intWriter(cout,"\n");


       <i>//write elements with the usual iterator interface</I>
       *intWriter = 42;
       intWriter++;
       *intWriter = 77;
       intWriter++;
       *intWriter = -5;


       <I>//create collection with elements from</I> 1 <I>to</i> 9
       vector&lt;int&gt; coll;
       for (int i=1; i&lt;=9; ++i) {
           coll.push_back(i); 
       }


       <i>//write all elements without any delimiter</i> 
       copy (coll.begin(), coll.end(),
             ostream_iterator&lt;int&gt;(cout));
       cout &lt;&lt; endl;


       <i>//write all elements with " &lt;</I> " <I>as delimiter</I>
       copy (coll.gin(), coll.end(),
             ostream_iterator&lt;int&gt;(cout," &lt; "));
       cout &lt;&lt; endl;
   }

					</Pre>

					<p>The output of the program is as follows:</p>

					<pre>
						
   42
   77
   -5
   123456789
   1 &lt; 2 &lt; 3 &lt; 4 &lt; 5 &lt; 6 &lt; 7 &lt; 8 &lt; 9 &lt;

					</pre>

					<p>Note that the delimiter has type <tt class="monofont">const char*.</tt> Thus, if you pass an object of type <tT CLASS="monofont">string</tT> you must call its member function <Tt CLaSS="monofont">c_str()</TT> (see <A href="0201379260_snode92.html#9">Section 11.3.6</a>) to get the correct type. For example:</P>

					<PRE>
						
   string delim;
   ...
   ostream_iterator&lt;int&gt;(cout,delim.c_str());

					</pre>

				
				<h5>Istream Iterators</H5>
					<P><I>Istream iterators</I> are the counterparts of ostream iterators. An istream iterator reads elements from an input stream. By using istream iterators, algorithms can read from streams directly. However, istream iterators are a bit more complicated than ostream iterators (as usual, reading is more complicated than writing).</p>

					<p>At creation time the istream iterator is initialized by the input stream from which it reads. Then, by using the usual interface of input iterators (see <a href="0201379260_snode60.html#3">Section 7.2.1</A>), it reads element-by-element using operator <tt class="monofont">&gt;&gt;.</tt> However, reading might fail (due to end-of-file or an error), and source ranges of algorithms need an "end position." To handle both problems, you can use an <i>end-of-stream iterator.</i> An end-of-stream iterator is created with the default constructor for istream iterators. If a read fails, every istream iterator becomes an end-of-stream iterator. Thus, after any read access, you should compare an istream iterator with an end-of-stream iterator to check whether the iterator has a valid value. <a href="0201379260_snode62.html#21">Table 7.10</a> lists all operations of istream iterators.</p>

					<p>Note that the constructor of an istream iterator opens the stream and usually reads the first element. It has to read the first value because otherwise it could not return the first element when operator <tt CLASS="monofont">*</Tt> is called after the initialization. However, implementations may defer the first read until the first call of operator <TT cLAsS="monofont">*.</TT> So, you should not define an istream iterator before you really need it.</P>

					<P>Istream iterators are defined for a certain element type <Tt claSS="monofont">T:</TT></p>

					<pre>
						
   namespace std {
       template &lt;class T,
                 class charT = char,
                 class traits = char_traits&lt;charT&gt;,
                 class Distance = ptrdiff_t&gt;
       class istream_iterator; 
   }

					</PRE>

					<A name="21"></A><P><TAble border="1" cellspacing="0" cELLPADdINg="1" WIdTH="100%">
<CAPTion><h5>Table 7.10. Operations of istream Iterators</H5></CAPtion><COLGroup ALIGn="left" span="2">
<tr>
<th valign="top">
<font siZE="2"><B>Expression</B>
									</FOnT></Th>
<TH vALIGN="top">
<Font sIZE="2"><B>Effect</b>
									</fonT></TH>
</Tr>
<tr>
<tH VALign="top">
<font size="2"><tt class="monofont">istream_iterator</tt>&lt;<i>T</I>&gt;()
</FONT></Th>
<TH vALiGN="top">
<FONT size="2">Creates an end-of-stream iterator</FONT></th>
</tr>
<TR>
<TD valiGN="top">
<FOnt size="2"><tt class="monofont">istream_iterator</tt>&lt;<i>T</i>&gt; (<i>istream</i>)
</foNT></TD>
<TD vALiGN="top">
<fONT SIZe="2">Creates an istream iterator for <i>istream</i> (and might read the first value)
</fONT></Td>
</tr>
<tR>
<TD ValigN="top">
<FONt size="2"><i>*iter</i>
									</font></td>
<td valign="top">
<FONT SIzE="2">Returns the actual value, read before (reads first value if not done by the constructor)</FoNT></tD>
</TR>
<TR>
<Td valIGN="top">
<Font sIZE="2"><I>iter-&gt;member</i>
									</fonT></TD>
<Td valign="top">
<font size="2">Returns a member (if any) of the actual value, read before</font></td>
</TR>
<TR>
<TD vALiGN="top">
<fONT SIZe="2"><i>++iter</i>
									</fONT></Td>
<td vALIGn="top">
<fonT SIZe="2">Reads next value and returns its position</font></td>
</tr>
<tr>
<td valign="top">
<foNT SIZE="2"><i>iter++</I>
									</FoNT></tD>
<TD VALign="top">
<fONT Size="2">Reads next value but returns an iterator for the previous value</fONT></Td>
</tr>
<tR>
<TD Valign="top">
<font size="2"><i>Iter1==iter2</i>
									</font></td>
<TD VALIgN="top">
<FoNT sIZE="2">Tests <I>iter1</I> and <I>iter2</i> for equality
</fonT></TD>
</Tr>
<tr>
<tD VALign="top">
<fONT Size="2"><i>Iter1!= iter2</i>
									</font></td>
<td valign="top">
<foNT SIZE="2">Tests <i>iter1</I> and <I>iter2</i> for inequality
</FOnT></TD>
</TR>
</ColgrOUP>
</Table></P>

					<P>The optional second and third template arguments specify the type of stream that is used (see <A href="0201379260_snode102.html#1">Section 13.2.1</a>, for their meaning). The optional fourth template argument specifies the difference type for the iterators.<FONT size="1"><sup><a href="#FOOTNOTE-4">[4]</a></sup></font>
</p>
<BLOCKQuOTe><FOnT SIZE="1">
<P clasS="footnote">
<SUP><a namE="FOOTNOTE-4">[4]</A></SUp>
In older systems without default template parameters, the optional fourth template argument is required as the second argument, and the arguments for the stream type are missing.</p>
</foNT></BLockquote>

						
					<p>Two istream iterators are equal if</p>

					<ul>
<li><p>both are end-of-stream iterators and thus can no longer read, or</p>
</li>
<li><p>both can read and use the same stream.</P>

						</LI>
</UL>
					<P>The following example demonstrates the operations provided for istream iterators:</p>

					<PRe>
						
   <I>// iter/istriter.cpp</I>

   #include &lt;iostream&gt; 
   #include &lt;iterator&gt;
   using namespace std;


   int main() 
   {
       <i>//create istream iterator that reads integers from</I> cin
       istream_iterator&lt;int&gt; intReader(cin);


       <I>//create end-of-stream iterator</I>
       istream_iterator&lt;int&gt; intReaderEOF;


       <I>/* while able to read tokens with istream iterator</I>
        <I>* - write them twice</i>
        <i>*/</i>
       while (intReader != intReaderEOF) {
           cout &lt;&lt; "once:       " &lt;&lt; *intReader &lt;&lt; endl;
           cout &lt;&lt; "once again: " &lt;&lt; *intReader &lt;&lt; endl;
           ++intReader;
       }
   }

					</pRE>

					<P>If you start the program with the following input:</P>

					<pre>
						
   1 2 3 f 4

					</pRE>

					<P>the output of the program is as follows:</P>

					<pre>
						
   once:       1
   once again: 1
   once:       2
   once again: 2
   once:       3
   once again: 3

					</pRE>

					<P>As you can see, the input of character <Tt class="monofont">f</tt> ends the program. Due to a format error, the stream is no longer in a good state. Therefore, the istream iterator <tt class="monofont">intReader</tt> is equal to the end-of-stream iterator <tt clASS="monofont">intReaderEOF.</TT> So, the condition of the loop yields <Tt CLaSS="monofont">false,</tT></P>

				
				<H5>Another Example of Stream Iterators</H5>
					<P>Here is an example that uses both kinds of stream iterators as well as the <Tt claSS="monofont">advance()</TT> iterator function:</p>

					<pre>
						
   <I>// iter/advance2.cpp</I>

   #include &lt;iostream&gt;
   #include &lt;string&gt;
   #include &lt;algorithm&gt;
   using namespace std;


   int main() 
   {
       istream_iterator&lt;string&gt; cinPos(cin);
       ostream_iterator&lt;string&gt; coutPos(cout," ");


       <I>/* while input is not at the end of the file</I>
        <i>* - write every third string</i>
        <i>*/</i>
       while (cinPos != istream_iterator&lt;string&gt;()) {
           <I>//ignore the following two strings</I> 
           advance (cinPos, 2);


           <I>//read and write the third string</I>
           if (cinPos != istream_iterator&lt;string&gt;()) {
               *coutPos++ = *cinPos++;
           }
       }
       cout &lt;&lt; endl;
   }

					</pre>

					<p>The <tt class="monofont">advance()</tt> iterator function is provided to advance the iterator to another position (see <a href="0201379260_snode61.html#1">Section 7.3.1</a>). Used with istream iterators, it skips input tokens. For example, if you have the following input<foNT SIZE="1"><sUP><a HReF="#FOOTNOTE-5">[5]</A></SUP></Font>
:</p>
<BLOCkquoTE><FOnt siZE="1">
<P Class="footnote">
<sup><a name="FOOTNOTE-5">[5]</a></sup>
Thanks to Andrew Koenig for the nice input of this example.</p>
</font></BLOCKQuOTe>

						
					<PRe>
						
   No one objects if you are doing
   a good programming job for
   someone who you respect.

					</PRE>

					<P>the output is as follows:</P>

					<Pre>
						
   objects are good for you

					</prE>

					<P>Don't forget to check whether the istream iterator is still valid after calling <TT clasS="monofont">advance()</TT> and before accessing its value with <Tt claSS="monofont">*cinPos.</TT> Calling operator <tt class="monofont">*</tt> for an end-of-stream iterator results in undefined behavior.</p>

					<p>See pages 107, 366, and 385 for other examples that demonstrate how algorithms use stream iterators to read from and write to streams.</p>

				
			
		</font>
 
<table width="100%" border="0" cellspacing="0" cellpadding="0" bgcolor="#CCCCCC">
<td><font color="black" size=1>I l<font color="#FF0000">@</font>ve RuBoard</td>
<td valign="top" class="v2" align="right"><a href="0201379260_snode61.html"><img src="FILES/previous.gif" width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a> <a href="0201379260_snode63.html"><img src="FILES/next.gif" width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a></td></table>
</BODY></HTML>