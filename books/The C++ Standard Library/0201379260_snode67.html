<HTML><HEAD><META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=iso-8859-1">
<!--SafClassName="docSection1Title"--><!--SafTocEntry="8.2 Predefined Function Objects"-->
<LINK REL="stylesheet" href="FILES/sbolM.css">
</HEAD>
<BODY link="#354278" vlink="#000066" alink="#000080" topmargin="0">
<table width="100%" border="0" cellspacing="0" cellpadding="0" bgcolor="#CCCCCC">
<td><font color="black" size=1>I l<font color="#FF0000">@</font>ve RuBoard</td>
<td valign="top" class="v2" align="right"><a href="0201379260_snode66.html"><img src="FILES/previous.gif" width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a> <a href="0201379260_snode68.html"><img src="FILES/next.gif" width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a></td></table>
<FONT><h3>8.2
Predefined Function Objects</h3>
			<p>As mentioned in <a href="0201379260_snode42.html#3">Section 5.9.2</a>, the C++ standard library provides many predefined function objects. <a href="0201379260_snode67.html#2">Table 8.1</A> lists all predefined function objects.<Font sIZE="1"><Sup><a href="#FOOTNOTE-4">[4]</a></sup></font>
</p>
<blockQUOTE><FoNT sIZe="1">
<P CLASS="footnote">
<sup><a NAME="FOOTNOTE-4">[4]</a></sup>
In earlier versions of the STL, the function object for multiplication had the name <TT CLass="monofont">times.</tT> This was changed due to a name clash with a function of the operating system standards (X/Open, POSIX) and because <TT Class="monofont">multiplies</tt> was clearer.</p>
</font></blockquote>

				
			<A NAME="2"></A><p><TAbLE bORDER="1" CellsPACIng="0" ceLLPAddinG="1" WIDth="100%">
<caption><h5>Table 8.1. Predefined Function Objects</h5></caption><colGROUP AlIGn="left" SPaN="2">
<TR>
<TH ValigN="top">
<FONt sizE="2"><B>Expression</B>
							</Font></tH>
<TH Valign="top">
<font size="2"><b>Effect</b>
							</font></th>
</TR>
<TR>
<TD vALiGN="top">
<fONT SIZe="2"><tt cLASS="monofont">negate&lt;</tt><i>type</i><TT CLass="monofont">&gt;()</tT>
							</FONt></td>
<td valign="top">
<font size="2">-<i> param</i>
							</FONT></TD>
</tR>
<Tr>
<TD vALIGN="top">
<Font sIZE="2"><Tt claSS="monofont">plus&lt;</TT><i>type</i><tt CLASs="monofont">&gt;()</tt>
							</font></td>
<td valign="top">
<font SIZE="2"><I>param1</I>
								<tT ClASs="monofont">+</TT>
								<I>param2</I>
							</FOnt></td>
</TR>
<TR>
<td vaLIGN="top">
<font SIZE="2"><tt class="monofont">minus&lt;</tt><i>type</i><tt class="monofont">&gt;()</tt>
							</fONT></TD>
<Td VAlIGn="top">
<FONT SIze="2"><i>param 1</i> - <I>param2</I>
							</FOnt></td>
</TR>
<TR>
<td vaLIGN="top">
<font size="2"><tt class="monofont">multiplies&lt;</tt><i>type</i><tt CLASS="monofont">&gt;()</Tt><SUp><A HrEF="#FOOTNOTE-4">[4]</A></SUP>
							</font></TD>
<TD valiGN="top">
<FOnt siZE="2"><I>param1</I>
								<tt class="monofont">*</tt><i> param2</i>
							</font></td>
</tr>
<tr>
<TD VALIgN="top">
<FoNT sIZE="2"><TT Class="monofont">divides&lt;</TT><I>type</I><tt clASS="monofont">&gt;()</Tt>
							</fonT></TD>
<Td valign="top">
<font size="2"><i>param1</i>
								<tt clASS="monofont">/</TT><I> param2</i>
							</FOnT></Td>
</TR>
<TR>
<TD valiGN="top">
<FOnt siZE="2"><TT clasS="monofont">modulus &lt;</TT><I>type</i><tt class="monofont">&gt;()</tt>
							</font></td>
<td valIGN="top">
<FONt SIzE="2"><I>param1</i>
								<TT CLASs="monofont">%</tt><i> param2</I>
							</FONt></td>
</tR>
<TR>
<Td valIGN="top">
<Font size="2"><tt class="monofont">equal_to&lt;</tt><i>type</i><tt cLASS="monofont">&gt;()</TT>
							</fONt></TD>
<tD VALIGn="top">
<fonT SIZe="2"><i>param1</i>
								<tT CLAss="monofont">==</tt><I> param2</I>
							</FOnt></td>
</tr>
<tr>
<td valign="top">
<font sIZE="2"><TT ClASs="monofont">not_equal_to&lt;</TT><i>type</I><TT CLAss="monofont">&gt;()</tt>
							</FONT></td>
<td VALIgn="top">
<foNT SIze="2"><i>param1</i>
								<tt class="monofont">! =</tt><i> param2</i>
							</font></td>
</TR>
<TR>
<TD vALiGN="top">
<fONT SIZe="2"><tt cLASS="monofont">less&lt;</tt><i>type</i><TT CLass="monofont">&gt;()</tT>
							</FONt></td>
<td valign="top">
<font size="2"><i>param1</i>
								<TT CLASs="monofont">&lt;</TT><i> param2</I>
							</FoNT></TD>
</TR>
<tr>
<td VALIgn="top">
<foNT SIze="2"><tt CLASs="monofont">greater&lt;</tt><i>type</i><tt class="monofont">&gt;()</tt>
							</font></td>
<tD VALIGn="top">
<FOnT SiZE="2"><I>param1</I>
								<TT clasS="monofont">&gt;</TT><I> param2</i>
							</fonT></TD>
</Tr>
<tr>
<tD VALign="top">
<font size="2"><tt class="monofont">less_equal&lt;</tt><i>type</I><TT CLAsS="monofont">&gt;()</Tt>
							</FOnT></TD>
<TD ValigN="top">
<FONt sizE="2"><I>param1</I>
								<Tt claSS="monofont">&lt;=</TT><i> param2</i>
							</font></td>
</tr>
<tr>
<td valign="top">
<fONT SIZe="2"><TT cLAsS="monofont">greater_equal&lt;</TT><I>type</I><Tt claSS="monofont">&gt;()</TT>
							</font></TD>
<TD valiGN="top">
<FOnt size="2"><i>param1</i>
								<tt class="monofont">&gt;=</tt><i> param2</i>
							</foNT></TD>
</TR>
<tR>
<Td VAlIGN="top">
<FONt sizE="2"><TT Class="monofont">logical_not&lt;</TT><I>type</I><tt clASS="monofont">&gt;()</Tt>
							</font></td>
<td valign="top">
<font siZE="2"><TT CLaSS="monofont">!</tT><I> param</i>
							</FONT></TD>
</tr>
<tr>
<TD VAlign="top">
<FONT size="2"><TT CLass="monofont">logical_and&lt;</tt><i>type</i><tt class="monofont">&gt;()</tt>
							</font></tD>
<TD VALiGN="top">
<fONt SIZE="2"><I>param1</I>
								<tt clASS="monofont">&amp;&amp;</Tt><i> param2</i>
							</fONT></Td>
</tr>
<tR>
<TD Valign="top">
<font size="2"><tt class="monofont">logical_or&lt;</tT><I>type</I><TT ClASs="monofont">&gt; ()</TT>
							</fONT></TD>
<Td valIGN="top">
<Font sIZE="2"><I>param1</i>
								<tt cLASS="monofont">| |</tt><i> param2</i>
							</font></td>
</tr>
</colgroup>
</tABLE></P>

			<P><tT ClASs="monofont">less&lt;&gt;</TT> is the default criterion whenever objects are sorted or compared, so it is used often. Default sorting operations always produce an ascending order (<I>element</I>
				<TT clasS="monofont">&lt;</TT>
				<I>nextElement</i>)<i>.</i> To use these function objects, you must include the header file <tT CLAss="monofont">&lt;functional&gt;</tt><FONT size="1"><sup><a href="#FOOTNOTE-5">[5]</a></sup></font>
:</p>
<BLOCKQuOTe><FOnT SIZE="1">
<P clasS="footnote">
<SUP><a namE="FOOTNOTE-5">[5]</A></SUp>
In the original STL, the header file for function objects was called <tt cLASS="monofont">&lt;function.h&gt;.</tt></p>
</font></blockquote>

				
			<pre>
				
   #include &lt;functional&gt;

			</pRE>

			<P>To compare internationalized strings, the C++ standard library provides another function object that can be used as a sorting criterion for strings. See page 703 for details.</P>

			<H4>8.2.1
Function Adapters</H4>
				<p>A function adapter is a function object that enables the combining of function objects with each other, with certain values, or with special functions. Function adapters are also declared in <TT cLAsS="monofont">&lt;functional&gt;.</TT> For example, in the following statement:</P>

				<PRe>
					
    find_if (coll.begin(),coll.end(),        <i>//range</i>
             bind2nd (greater&lt;int&gt;(),42))    <i>//criterion</I>

				</PRE>

				<p>the expression</p>

				<prE>
					
    bind2nd(greater&lt;int&gt;(),42)

				</PRE>

				<p>produces a combined function object that checks whether an <tt cLASS="monofont">int</tt> value is greater than <tt class="monofont">42.</tt> In fact, <tt class="monofont">bind2nd</tt> transforms a binary function object, such as <tT CLASS="monofont">greater&lt;&gt;,</tT> into a unary function object. It always uses its second parameter as the second argument of the binary function object that is passed as the first parameter. Thus, in this example it always calls <Tt CLaSS="monofont">greater&lt;&gt;</TT> with <TT clasS="monofont">42</TT> as the second argument. <A href="0201379260_snode42.html#3">Section 5.9.2</A>, offers some other examples of the use of function adapters.</P>

				<P><A href="0201379260_snode67.html#5">Table 8.2</A> lists the predefined function adapter classes provided by the C++ standard library.</P>

				<A Name="5"></a><p><table border="1" cellsPACING="0" cELlPAdDING="1" WIdth="100%">
<cAPTIon><h5>Table 8.2. Predefined Function Adapters</h5></CAPTion><cOLGRoup align="left" span="2">
<tr>
<th valigN="top">
<FONT SiZE="2"><b>Expression</B>
								</FoNT></TH>
<TH valiGN="top">
<FOnt siZE="2"><B>Effect</B>
								</font></TH>
</TR>
<tr>
<td valign="top">
<font size="2"><tt cLASS="monofont">bind1st</TT>
									<i>(op,value)</I>
								</FoNT></tD>
<TD VALign="top">
<fONT Size="2"><i>op(value,param)</I>
								</FONt></td>
</tR>
<TR>
<Td valign="top">
<font size="2"><tt clasS="monofont">bind2nd</TT>
									<I>(op, value)</I>
								</FoNT></tD>
<Td VALIGN="top">
<font SIZE="2"><i>op(param,value)</i>
								</foNT></TD>
</tr>
<tr>
<TD VAlign="top">
<font size="2"><tt class="monofont">not 1</tt><I>(op)</I>
								</FONT></tD>
<Td VAlIGN="top">
<FONt sizE="2"><I>!op(param)</I>
								</Font></tD>
</TR>
<Tr>
<td vALIGn="top">
<font size="2"><tt class="monofont">not2</tt><i>(op)</i>
								</fONT></TD>
<Td VAlIGn="top">
<FONT SIze="2"><i>!op(param1 ,param2)</i>
								</FONT></td>
</tr>
</COLGroup>
</TABLe></p>

				<p>Function adapters are function objects themselves, so you can combine function adapters and function objects to form more powerful (and more complicated) expressions. For example, the following statement returns the first even element of a collection:</p>

				<pre>
					
    pos = find_if (coll.begin() , coll.end(),                <i>//range</i>
                   not1 (bind2nd(modulus&lt;int&gt;(),2)));        <i>//criterion</i>

				</pre>

				<p>In this statement, the expression</p>

				<pre>
					
    bind2nd(modulus&lt;int&gt;(),2)

				</prE>

				<P>returns <TT CLaSS="monofont">1</tT> for all odd values. So this expression as a criterion finds the first element that has an odd value because <Tt CLASS="monofont">1</Tt> is equivalent to <tt cLASS="monofont">true not1()</tt> negates the result, so the whole statement searches for the first element that has an even value.</p>

				<p>By using function adapters you can combine different function objects to form very powerful expressions. This kind of programming is called <I>functional composition.</I> However, the C++ standard library lacks some function adapters that are necessary and useful for functional composition. For example, some function adapters are missing that allow you to combine two predicates with "and" or "or" (such as, "greater than 4 <I>and</I> less than 7"). If you extend the standard function adapters by some composing function adapters you get a lot more power. See <a href="0201379260_snode68.html">Section 8.3</A>, for a description of such extensions.</P>

			
			<A name="6"></a><h4>8.2.2
Function Adapters for Member Functions</h4>
				<p>The C++ standard library provides some additional function adapters that enable you to call a member function for each element of a collection (<a href="0201379260_snode67.html#7">Table 8.3</a>).</p>

				<a name="7"></a><P><TABLE bORdER="1" cELLSPAcing="0" CELLpaddING="1" Width="100%">
<CAPTion><h5>Table 8.3. Function Adapters for Member Functions</h5></caption><colgroup aLIGN="left" SPaN="2">
<Tr>
<TH vALIGN="top">
<Font sIZE="2"><B>Expression</b>
								</fonT></TH>
<Th valIGN="top">
<Font size="2"><b>Effect</b>
								</font></th>
</tr>
<tr>
<td VALIGN="top">
<fONt SIzE="2"><TT CLAss="monofont">mem_fun_ref</tt>
									<I>(op)</I>
								</FOnt></td>
<TD VAlign="top">
<FONT size="2">Calls<i> op</i>() as a constant member function for an object
</font></td>
</tr>
<tr>
<td valIGN="top">
<FONt SIzE="2"><Tt CLASS="monofont">mem_fun</Tt>
									<i>(op)</i>
								</fONT></Td>
<td vALIGn="top">
<fonT SIZe="2">Calls<i> op</i>() as a constant member function for an object
</font></td>
</tr>
</colgroup>
</taBLE></P>

				<P>For example, in the following code <Tt CLaSS="monofont">mem_fun_ref</tT> is used to call a member function for objects of a vector:</P>

				<PRE>
					
   <I>// fo/memfunla.cpp</i>

   class Person {
     private:
       std::string name;
     public:
       ...
       void print() const {
           std::cout &lt;&lt; name &lt;&lt; std::endl;
       }
       void printWithPrefix (std::string prefix) const {
           std::cout &lt;&lt; prefix &lt;&lt; name &lt;&lt; std::endl;
       }
   };


   void foo (const std::vector&lt;Person&gt;&amp; coll)
   {
       using std::for_each;
       using std::bind2nd;
       using std::mem_fun_ref;


        <i>//call member function</i> print() <i>for each element</I>
        for_each (coll.begin(), coll.end(),
                  mem_fun_ref(&amp;Person::print));


        <I>//call member function</I> printWithPrefix() <I>for each element</i>
        <i>//</i>-"person: " <i>is passed as an argument to the member function</I>
        for_each (coll.begin(), coll.end(),
                  bind2nd (mem_fun_ref (&amp;Person::printWithPrefix),
                           "person: "));
    }

				</PRE>

				<p>In <tt cLASS="monofont">foo(),</tt> two different member functions of class <tt class="monofont">Person</tt> are called for each element in the vector <tt class="monofont">coll:</tt> (1)<tT CLASS="monofont">Person::print(),</tT> which has no parameter, and (2)<Tt CLaSS="monofont">Person::printWithPrefix(),</TT> which has an additional parameter. To call the <TT clasS="monofont">Person::print()</TT> member function, the function object</P>

				<pre>
					
   mem_fun_ref (&amp;Person::print)

				</pRE>

				<P>is passed to the <Tt claSS="monofont">for_each()</TT> algorithm:</p>

				<pre>
					
   for_each (coll.begin(), coll.end(),
             mem_fun_ref(&amp;Person::print));

				</pre>

				<p>The <tt class="monofont">mem_fun_ref</tt> adapter transforms the function call for the element into a call of the passed member function.</p>

				<p>The adapter is necessary because you can't pass a member function directly to an algorithm. Doing so would cause a compile-time error:</p>

				<pRE>
					
   for_each (coll.begin(), coll.end (),
             &amp;Person:: print);   <I>//ERROR: can't call operator</I>()
                                 <I>//       for a member function pointer</I>

				</pRE>

				<p>The problem is that <TT cLASS="monofont">for_each()</TT> would call operator<tt clASS="monofont">()</Tt> for the pointer passed as the third argument instead of calling the member function to which it points. The <tt cLASS="monofont">mem_fun_ref</tt> adapter solves this problem by transforming the call of operator<tt CLASs="monofont">().</tt></p>

				<p>By using <tt class="monofont">bind2nd</tt> it is also possible to pass one argument to the called member function, as the second call of <tt class="monofont">for_each()</TT> shows<FONT sIZe="1"><SUp><A HREF="#FOOTNOTE-6">[6]</A></sup></fONT>
:</P>
<blocKQUOte><foNT SIze="1">
<p class="footnote">
<sup><a name="FOOTNOTE-6">[6]</a></sup>
In older versions of the STL and the C++ standard library, the member function adapters for one argument were called <tT CLASS="monofont">mem_fun1</tT> and <Tt CLaSS="monofont">mem_fun1_ref</TT> instead of <TT clasS="monofont">mem_fun</TT> and <Tt claSS="monofont">mem_fun_ref.</TT></p>
</fonT></BLOckquote>

					
				<pre>
					
    for_each (coll.begin(), coll.end(),
              bind2nd(mem_fun_ref (&amp;Person::printWithPrefix),
                      "person: "));

				</pre>

				<p>You might wonder why the adapter is called <tt class="monofont">mem_fun_ref</TT> instead of simply <TT CLaSS="monofont">mem_fun.</tT> The reason is historical: Another version of member function adapters was introduced first and got the name <Tt CLASS="monofont">mem_fun.</Tt> Those <tt cLASS="monofont">mem_fun</tt> adapters are for sequences that contain <i>pointers</i> to elements. Probably <TT CLass="monofont">mem_fun_ptr</tT> would have been a less confusing name for them. So, if you have a sequence of pointers to objects, you can also call member functions for them. For example:</P>

				<PRe>
					
   <i>// fo/memfun1b.cpp</i>

   void ptrfoo (const std::vector&lt;Person*&gt;&amp; coll)
                                      //^^^<i> pointer!</i>
   {
       using std::for_each;
       using std::bind2nd;
       using std::mem_fun;


       <i>//call member function</i> print() <i>for each referred object</i>
       for_each (coll.begin() , coll.end(),
                 mem_fun(&amp;Person::print));


       <i>//call member function</i> printWithPrefix()<i>for each referred object</i>
       <i>//-</i>"person: " <i>is passed as an argument to the member function</i>
       for_each (coll.begin() , coll.end(),
                 bind2nd(mem_fun(&amp;Person::printWithPrefix),
                         "person: "));
   }

				</pre>

				<p>Both <TT CLASs="monofont">mem_fun_ref</TT> and <tT ClASS="monofont">mem_fun</TT> can call member functions with zero or one argument. However, you can't call member functions with two or more arguments in this way. This is because for the implementation of these adapters you need auxiliary function objects that are provided for each kind of member function. For example, the auxiliary classes for <Tt claSS="monofont">mem_fun</TT> and <tt clASS="monofont">mem_fun_ref</Tt> are <tt cLASS="monofont">mem_fun_t, mem_fun_ref_t, const_mem_fun_t, const_mem_fun_ref_t, mem_fun1_t, mem_fun1_ref_t, const_mem_fun1_t,</tt> and <tt class="monofont">const_mem_fun1_ref_t.</tt></p>

				<p>Note that the member functions called by <tt class="monofont">mem_fun_ref</tT> and <TT CLAsS="monofont">mem_fun</Tt> must be <I>constant</I> member functions. Unfortunately, the C++ standard library does not provide function adapters for nonconstant member functions (I discovered this while writing this book). It seems to have been simply an oversight because nobody knew that this was not possible, and it is possible to solve this problem without much effort. Hopefully, implementations (and the standard) will fix this problem in the future.</p>

			
			<H4>8.2.3
Function Adapters for Ordinary Functions</H4>
				<P>Another function adapter enables ordinary functions to be used from other function adapters: <TT Class="monofont">ptr_fun</TT> (<A href="0201379260_snode67.html#10">Table 8.4</a>).</P>

				<P>For example, suppose you have a global function such as the following that checks something for each parameter:</P>

				<Pre>
					
    bool check(int elem);

				</prE>

				<A NAme="10"></a><p><table border="1" cellspACING="0" CeLLpADdING="1" WIDth="100%">
<caPTIOn><h5>Table 8.4. Functions Adapters for Ordinary Functions</h5></cAPTIon><coLGROup align="left" span="2">
<tr>
<th valign="top">
<FONT SIzE="2"><B>Expression</b>
								</FOnT></TH>
<TH ValigN="top">
<FONt sizE="2"><B>Effect</B>
								</Font></tH>
</TR>
<Tr>
<td valign="top">
<font size="2"><tt clASS="monofont">ptr_fun</TT><I>(op)</i>
								</FOnT></Td>
<TD VALIgn="top">
<foNT SIze="2"><i>*op(param)</i>
								</FONT></td>
</tr>
<TR>
<TD valign="top">
<font size="2"> </font></td>
<tD VALIGn="top">
<FOnT SiZE="2"><I>*op(param1 ,param2)</I>
								</FOnt></td>
</TR>
</COlgroUP>
</TAble></p>

				<P>If you want to find the first element for which the check does not succeed you could call the following statement:</P>

				<PRe>
					
    pos = find_if (coll.begin(), coll.end(),          <i>//range</i>
                   not1(ptr_fun(check)));             <i>//search criterion</i>

				</pre>

				<p>You could not use <tt class="monofont">not1(check)</tt> because <tt cLASS="monofont">not1()</TT> uses special type members that function objects provide. See <a href="0201379260_snode67.html#11">Section 8.2.4</A> for more details.</p>

				<P>The second form is used when you have a global function for two parameters and, for example, you want to use it as a unary function:</P>

				<PRE>
					
   <I>//find first string that is not empty</i>
   pos = find_if (coll.begin(), coll.end(),           <i>//range</i>
                  bind2nd(ptr_fun(strcmp),""));       <i>//search criterion</I>

				</PRE>

				<p>Here, the <tt cLASS="monofont">strcmp()</tt> C function is used to compare each element with the empty C-string. <tt CLASs="monofont">strcmp()</tt> returns <tt class="monofont">0,</tt> which is equivalent to <tt class="monofont">false,</tt> when both strings match. So, this call of <TT CLASs="monofont">find_if()</TT> returns the position of the first element that is not the empty string. See another example of the use of <tT ClASS="monofont">ptr_fun</TT> on page 319.</P>

			
			<a namE="11"></A><H4>8.2.4
User-Defined Function Objects for Function Adapters</H4>
				<p>You can write your own function objects, but to use them in combination with function adapters they must meet certain requirements: They must provide type members for the type of their arguments and the result. The C++ standard library provides structures to make this more convenient:</p>

				<prE>
					
   template &lt;class Arg, class Result&gt;
   struct unary_function {
       typedef Arg argument_type;
       typedef Result result_type;
   };


   template &lt;class Argl, class Arg2, class Result&gt;
   struct binary_function {
       typedef Argl first_argument_type;
       typedef Arg2 second_argument_type;
       typedef Result result_type;
   };

				</PRE>

				<p>Thus, by deriving your function object from one of these types you meet the requirements easily so that your function object becomes "adapter-able."</p>

				<p>The following example shows a complete definition for a function object that processes the first argument raised to the power of the second argument:</p>

				<PRE>
					
   <I>// fo/fopow.hpp</i>

   #include &lt;functional&gt;
   #include &lt;cmath&gt;


   template &lt;class T1, class T2&gt;
   struct fopow : public std::binary_function&lt;T1, T2, T1&gt;
   {
       T1 operator() (T1 base, T2 exp) const {
           return std::pow(base,exp);
       }
   };

				</pre>

				<p>Here, the first argument and the return value have the same type, <tt class="monofont">T1,</tt> and the exponent may have a different type <tt class="monofont">T2.</TT> These types are passed to <TT CLaSS="monofont">binary_function</tT> to make the required type definitions. However, instead of passing them to <Tt CLASS="monofont">binary_function</Tt> you could make the type definition directly. As usual in the STL, the concept of function adapters is pure abstraction: Anything that <i>behaves</i> like a function object for function adapters <i>is</I> a function object for function adapters.</P>

				<P>The following program shows how to use the user-defined function object <Tt claSS="monofont">fopow.</TT> In particular, it uses <tt clASS="monofont">fopow</Tt> with the <tt class="monofont">bind1st</tt> and <tt class="monofont">bind2nd</tt> function adapters:</p>

				<pRE>
					
     <I>// fo/fopow1. cpp</I>

     #include &lt;iostream&gt;
     #include &lt;vector&gt;
     #include &lt;algorithm&gt;
     using namespace std;


     <I>//include self-defined</I> fopow&lt;&gt;
     #include "fopow.hpp"


     int main()
     {
         vector&lt;int&gt; coll;


         <i>//insert elements from</I> 1 <I>to</i> 9
       for (int i=1; i&lt;=9; ++i) {
             coll.push_back(i);
        }


        <I>//print</I> 3 <i>raised to the power of all elements</I>
        transform (coll.begin(), coll.end(),            <I>//source</I>
                   ostream_iterator&lt;int&gt;(cout," "),     <I>//destination</I>
                   bind1st(fopow&lt;float ,int&gt;() ,3));    <I>//operation</i>
        cout &lt;&lt; endl;


        <i>//print all elements raised to the power of</i> 3
        transform (coll.begin(), coll.end(),            <i>//source</I>
                   ostream_iterator&lt;int&gt; (cout," "),    <I>//destination</I>
                   bind2nd(fopow&lt;float,int&gt;(),3)) ;     <I>//operation</i>
        cout &lt;&lt; endl;
 }

				</pre>

				<P>The program has the following output:</P>

				<PRe>
					
   3 9 27 81 243 729 2187 6561 19683
   1 8 27 64 125 216 343 512 729

				</pre>

				<P>Note that <TT Class="monofont">fopow</tt> is realized for types <tt class="monofont">float</tt> and <tt clasS="monofont">int.</TT> If you use <TT ClASs="monofont">int</TT> for both base and exponent, you'd call <tT CLASS="monofont">pow()</tt> with two arguments of type <tt CLASs="monofont">int,</tt> but this isn't portable because according to the standard <tT CLAss="monofont">pow()</tt> is overloaded for more than one but not all fundamental types:</P>

				<PRE>
					
    transform (coll.begin(), coll.end(),
               ostream_iterator&lt;int&gt;(cout," "),
               bind1st(fopow&lt;int,int&gt;() ,3));      <i>//ERROR:ambiguous</i>

				</pre>

				<p>See page 581 for details about this problem</p>

			
		</font>
 
<table width="100%" border="0" cellspacing="0" cellpadding="0" bgcolor="#CCCCCC">
<td><font color="black" size=1>I l<font color="#FF0000">@</font>ve RuBoard</td>
<td valign="top" class="v2" align="right"><a href="0201379260_snode66.html"><img src="FILES/previous.gif" width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a> <a href="0201379260_snode68.html"><img src="FILES/next.gif" width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a></td></table>
</BODY></HTML>