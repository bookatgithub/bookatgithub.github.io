<HTML><HEAD><META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=iso-8859-1">
<!--SafClassName="docSection1Title"--><!--SafTocEntry="8.3 Supplementary Composing Function Objects"-->
<LINK REL="stylesheet" href="FILES/sbolM.css">
</HEAD>
<BODY link="#354278" vlink="#000066" alink="#000080" topmargin="0">
<table width="100%" border="0" cellspacing="0" cellpadding="0" bgcolor="#CCCCCC">
<td><font color="black" size=1>I l<font color="#FF0000">@</font>ve RuBoard</td>
<td valign="top" class="v2" align="right"><a href="0201379260_snode67.html"><img src="FILES/previous.gif" width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a> <a href="0201379260_cnode69.html"><img src="FILES/next.gif" width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a></td></table>
<FONT><h3>8.3
Supplementary Composing Function Objects</h3>
			<p>The ability to compose function objects is important for building software components from other components. It enables you to construct very complicated function objects from simple ones. So in general it should be possible to define almost every functional behavior as a combination of function objects. However, the C++ standard library does not provide enough adapters to support this. For example, it is not possible to combine the result of two unary operations to formulate a criterion such as "this <i>and</I> that."</P>

			<P>In principal, the following compose adapters are useful:</P>

			<ul>
<li><P><B><TT clasS="monofont">f (g(</TT></B>
						<i>elem</i><b><tt class="monofont">))</tt></b></p>

					<p>This is the general form of a unary compose function. It allows nested calls of unary predicates such that the result of calling predicate <tt clasS="monofont">g()</TT> for <I>elem</I> is used as input for predicate <Tt CLaSS="monofont">f().</tT> The whole expression operates as a unary predicate.</P>
</LI>
<LI><p><b><tt CLASs="monofont">f (g(</tt></b>
						<I>elem1,elem2</I><B><Tt claSS="monofont">))</TT></b></p>

					<p>This is a form in which two elements, <i>elem1</i> and <i>elem2,</i> are passed as arguments to a binary predicate <tt class="monofont">g().</tt> Again the result is used as input for the unary predicate <tt claSS="monofont">f().</TT> The whole expression operates as a binary predicate.</P>
</Li>
<LI><p><B><Tt CLASS="monofont">f (g(</Tt></b>
						<i>elem</i><B><TT Class="monofont">),h(</TT></B><I>elem</i><b><tt CLASs="monofont">))</tt></b></p>

					<p>This is a form in which <i>elem</i> is passed as an argument to two different unary predicates <tt class="monofont">g()</tt> and <tt clASS="monofont">h(),</TT> and the result of both is processed by the binary predicate <Tt CLaSS="monofont">f().</tT> In a way, this form "injects" a single argument into a composed function. The whole expression operates as a unary predicate.</P>
</LI>
<LI><p><b><tt CLASs="monofont">f (g(</tt></b><I>elem1</I><B><Tt claSS="monofont">) ,h(</TT></b><i>elem2</i><b><tt class="monofont">))</tt></b></p>

					<p>This is a form in which two elements, <i>elem1</i> and <i>elem2,</i> are passed as an argument to two different unary predicates <tT CLASS="monofont">g()</tT> and <Tt CLaSS="monofont">h(),</TT> and the result of both is processed by the binary predicate <TT clasS="monofont">f().</TT> In a way, this form "distributes" a composed function over two arguments. The whole expression operates as a binary predicate.</P>

				</li>
</ul>
			<P>Unfortunately, these compose adapters were not standardized, so we don't have standard names for them. SGI's implementation of the STL has names for two of them, however the community is currently looking for general names for all these adapters. See <A href="0201379260_snode68.html#1">Table 8.5</a> for some possible names and the names I chose to use in this book.</p>

			<A NAMe="1"></a><p><table border="1" cellspaCING="0" CElLPaDDiNG="1" WIDTh="100%">
<capTION><h5>Table 8.5. Possible Names of Compose Function Object Adapters</h5></caPTIOn><colGROUp align="left" span="3">
<tr>
<th valign="top">
<fONT SIZe="2"><B>Functionality</B>
							</fONt></TH>
<TH VAlign="top">
<FONT size="2"><B>This Book</B>
							</FOnt></th>
<TH VAlign="top">
<font size="2"><b>SGI STL</b>
							</font></th>
</tR>
<TR>
<TD VaLIgN="top">
<FoNT SIZE="2"><tt clASS="monofont">f (g</Tt><i>(elem))</i>
							</fONT></Td>
<td vALIGn="top">
<font size="2"><tt class="monofont">compose_f_gx</tt>
							</fonT></TD>
<TD VaLIgN="top">
<FoNT SIZE="2"><tt clASS="monofont">compose1</Tt>
							</fonT></TD>
</Tr>
<tr>
<tD VALign="top">
<font size="2"><tt class="monofont">f (g</tt><i>(elem1,elem2))</I>
							</FONT></Td>
<TD vALiGN="top">
<FONT size="2"><TT CLass="monofont">compose_f_gxy</tT>
							</FONt></td>
<tD VALign="top">
<font size="2"> </font></td>
</tr>
<tr>
<TD VALIgN="top">
<FoNT sIZE="2"><TT Class="monofont">f (g</TT><I>(elem),</I><tt clASS="monofont">h</Tt><i>(elem))</i>
							</fONT></Td>
<td valign="top">
<font size="2"><tt clASS="monofont">compose_f_gx_hx</TT>
							</FoNT></tD>
<Td VALIGN="top">
<font SIZE="2"><tt clASS="monofont">compose2</Tt>
							</fonT></TD>
</Tr>
<tr>
<td valign="top">
<font size="2"><tt CLASS="monofont">f (g</Tt><I>(elem1),</I><tT ClASS="monofont">h</TT><I>(elem2))</i>
							</fonT></TD>
<Td valIGN="top">
<Font sIZE="2"><Tt class="monofont">compose_f_gx_hy</tt>
							</font></td>
<td valigN="top">
<FONT SiZE="2"> </fONt></TD>
</TR>
</COlgroUP>
</TAble></p>

			<P>Look at the Boost repository for C++ libraries at <A TArget="_blank" HREF="http://www.boost.org/default.htm">http://www.boost.org/</a> for the names that should be used in the future and for a complete implementation of all of them. In the next few subsections I discuss three of them — those that I need most often.</p>

			<a name="2"></a><h4>8.3.1
Unary Compose Function Object Adapters</h4>
				<p>This subsection describes the most fundamental compose function object adapters. They are also part of SGI's STL implementation.</p>

				<h5>Nested Computations by Using <tt class="monofont">compose_f_gx</tT></H5>
					<P>The simplest and most fundamental compose function adapter uses the result of a unary operation as input to another unary operation. Thus, it is simply a nested call of two unary function objects. You need this function adapter to formulate something like "add 10 and multiply by 4."</P>

					<P>I use the name <Tt CLaSS="monofont">compose_f_gx</tT> for this function object adapter. SGI's implementation of the STL uses the name <TT CLAss="monofont">compose1.</tt> You can implement <TT CLass="monofont">compose_f_gx</tT> as follows:</P>

					<PRe>
						
   <i>// fo/compose11.hpp</i>

   #include &lt;functional&gt;


   <i>/* class for the compose_f_gx adapter</I>
    <I>*/</I>
   template &lt;class 0P1, class 0P2&gt;
   class compose_f_gx_t
    : public std::unary_function&lt;typename 0P2::argument_type,
                                 typename 0P1::result_type&gt;
   {
     private:
       0P1 op1;     <I>//process:</i> op1(op2(x))
       0P2 op2;
     public:
       <i>//constructor</i>
       compose_f_gx_t(const 0P1&amp; o1, const 0P2&amp; o2)
        : 0p1(o1), op2(o2) {
       }


       <i>//function call</i>
       typename 0P1::result_type
       operator() (const typename 0P2::argument_type&amp; x) const {
           return op1 (op2(x));
       }
   };


   <i>/*convenience functions for the compose _f_gx adapter</i>
    <i>*/</i>
   template &lt;class 0P1, class 0P2&gt;
   inline compose_f_gx_t&lt;0Pl,0P2&gt;
   compose_f_gx (const 0P1&amp; o1, const OP2&amp; o2) {
       return compose_f_gx_t&lt;0Pl,OP2&gt;(ol,o2);
   }

					</pre>

					<p>Here is a complete example that demonstrates the use of <tt class="monofont">compose_f_gx:</tT></P>

					<PRE>
						
   <I>// fo/compose1. cpp</i>

   #include &lt;iostream&gt;
   #include &lt;vector&gt;
   #include &lt;algorithm&gt;
   #include &lt;functional&gt;
   #include "print.hpp"
   #include "composell.hpp"
   using namespace std;


   int main()
   {
       vector&lt;int&gt; coll;


       <I>//insert elements from</I> 1<i> to</I> 9
       for (int i=1; i&lt;=9; ++i) {
           coll.push_back(i);
       }
       PRINT_ELEMENTS(coll);


       <I>//for each element add</i> 10 <I>and multiply by</I> 5
       transform (coll.begin(),coll.end(),
                  ostream_iterator&lt;int&gt;(cout," "),
                  compose_f_gx (bind2nd (multiplies&lt;int&gt;(),5),
                                bind2nd (plus&lt;int&gt;(),10)));
       cout &lt;&lt; endl;
   }

					</PRE>

					<P>Note that the second operation passed to <tt clASS="monofont">compose_f_gx</Tt> is performed first. Thus,</p>

					<prE>
						
   compose_f_gx(bind2nd(multiplies&lt;int&gt;(),5),
                bind2nd (plus&lt;int&gt;(),10))

					</PRE>

					<p>yields a unary function object that first adds ten and then multiplies the result by five. The program has the following output:</p>

					<prE>
						
   1 2 3 4 5 6 7 8 9
   55 60 65 70 75 80 85 90 95

					</PRE>

				
				<h5>Combining Two Criteria by Using <tt class="monofont">compose_f_gx_hx</tt></h5>
					<p>Probably the most important supplementary function adapter is one that allows you to combine two criteria logically to formulate a single criterion. You need this function adapter' to formulate something like "greater than 4 <i>and</i> less than 7."</p>

					<p>I use the name <tt claSS="monofont">compose_f_gx_hx</TT> for this function object adapter. In SGI's implementation of the STL it is called <TT cLAsS="monofont">compose2.</Tt> You can implement <TT CLASs="monofont">compose_f_gx_hx</tt> as follows:</p>

					<PRE>
						
   <I>// fo/compose21.hpp</i>

   #include &lt;functional&gt;


   <i>/*class for the compose_f_gx_hx adapter</i>
    <i>*/</I>
   template &lt;class 0P1, class 0P2, class 0P3&gt;
   class compose_f_gx_hx_t
    : public std::unary_function&lt;typename 0P2::argument_type,
                                 typename 0P1::result_type&gt;
   {
     private:
       0P1 op1;     <I>//process:</I> op1 (op2(x), op3(x))
       0P2 op2;
       0P3 op3;
     public:
       <I>//constructor</i>
       compose_f_gx_hx_t (const 0P1&amp; o1, const 0P2&amp; o2, const 0P3&amp; o3)
        : op1(o1), op2(o2), op3(o3) {
       }


       <i>//function call</i>
       typename 0P1::result_type
       operator()(const typename 0P2::argument_type&amp; x) const {
           return op1(op2(x),op3(x));
       }
   };


   <i>/*convenience functions for the compose f_gx_hx adapter</I>
    <I>*/</I>
   template &lt;class 0P1, class 0P2, class 0P3&gt;
   inline compose_f_gx_hx_t&lt;0Pl,0P2,0P3&gt;
   compose_f_gx_hx (const 0P1&amp; o1, const 0P2&amp; o2, const 0P3&amp; o3) {
       return compose_f_gx_hx_t&lt;0Pl,0P2,0P3&gt;(ol,o2,o3);
   }

					</Pre>

					<p><tt class="monofont">compose_f _gx_hx</tt> uses the first operation to combine the results of two unary operations for the same object. Thus, the expression</p>

					<pre>
						
   compose_f_gx_hx(opl,op2,op3)

					</pre>

					<p>results in the unary predicate that calls for each value <tT CLASS="monofont">x:</tT></P>

					<pRE>
						
   op1(op2(x),op3(x))

					</pRE>

					<P>Here is a complete example that demonstrates the use of <TT Class="monofont">compose_f _gx_hx:</TT></P>

					<Pre>
						
   <i>// fo/compose2.cpp</i>

   #include &lt;iostream&gt;
   #include &lt;vector&gt;
   #include &lt;algorithm&gt;
   #include &lt;functional&gt;
   #include "print.hpp"
   #include "compose21.hpp"
   using namespace std;


   int main()
   {
       vector&lt;int&gt; coll;


       <I>//insert elements from</I> 1 <I>to</I> 9
       for (jnt i=1; i&lt;=9; ++i) {
           coll.push_back(i);
       }
       PRINT_ELEMENTS(coll);


       <i>//remove all elements that are greater than four and less than seven</i>
       <i>// - retain new end</i>
       vector&lt;int&gt;::iterator pos;
       pos = remove_if (coll.begin(),coll.end(),
                           compose_f_gx_hx(logical_and&lt;bool&gt;(),
                                           bind2nd(greater&lt;int&gt;(),4),
                                           bind2nd(less&lt;int&gt;(),7)));


       <I>//remove "removed" elements in</I> coll
       coll.erase(pos,coll.end());


       PRINT_ELEMENTS(coll);
   }

					</PRe>

					<p>The expression</p>

					<pre>
						
   compose_f_gx_hx(logical_and&lt;bool&gt;(),
                   bind2nd(greater&lt;int&gt;(),4),
                   bind2nd(less&lt;int&gt;(),7))

					</pre>

					<p>yields a unary predicate that returns whether a value is greater than four and less than seven. The program has the following output:</p>

					<pre>
						
   1 2 3 4 5 6 7 8 9
   1 2 3 4 7 8 9

					</pre>

				
			
			<h4>8.3.2
Binary Compose Function Object Adapters</h4>
				<p>One of the binary compose function object adapters processes the result of two unary operations that use different elements as parameters. I use the name <tT CLASS="monofont">compose_f_gx_hy</tT> for this function object adapter. Here is a possible implementation:</P>

				<pRE>
					
   <i>// fo/compose22.hpp</I>

   #include &lt;functional&gt;


   <I>/*class for the compose_ f_gx_hy adapter</I>
    <I>*/</I>
   template &lt;class 0P1, class 0P2, class 0P3&gt;
   class compose_f_gx_hy_t
    : public std::binary_function&lt;typename 0P2::argument_type,
                                 typename 0P3::argument_type,
                                 typename 0P1::result_type&gt;
   {
     private:
       0P1 op1; <I>//process:</i> op1 (op2(x) ,op3(y))
       0P2 op2;
       0P3 op3;
     public:
       <i>//constructor</i>
       compose_f_gx_hy_t (const 0P1&amp; o1, const 0P2&amp; o2, const 0P3&amp; o3)
        : op1(o1), op2(o2), op3(o3) {
       }


       <i>//function call</I>
       typename 0P1::result_type
       operator()(const typename 0P2::argument_type&amp; x,
                const typename 0P3::argument_type&amp; y) const {
         return op1(op2(x),op3(y));
       }
   };


   <I>/*convenience function for the compose _f_gx_hy adapter</I>
    <I>*/</i>
   template &lt;class 0P1, class OP2, class 0P3&gt;
   inline compose.f_gx_hy_t&lt;0Pl,0P2,0P3&gt;
   compose_f_gx_hy (const 0P1&amp; o1, const 0P2&amp; o2, const 0P3&amp; o3) {
       return compose_f_gx_hy_t&lt;0Pl,0P2,0P3&gt;(ol,o2,o3);
   }

				</pre>

				<P>The following example shows the use of <TT Class="monofont">compose_f _gx_hy.</TT> It searches for a substring in a string in a case-insensitive way:</P>

				<Pre>
					
   <i>// fo/compose3.cpp</i>

   #include &lt;iostream&gt;
   #include &lt;algorithm&gt;
   #include &lt;functional&gt;
   #include &lt;string&gt;
   #include "compose22.hpp"
   using namespace std;


   int main()
   {
       string s("Internationalization");
       string sub("Nation");


       <i>//search substring case insensitive</i>
       string::iterator pos;
       pos = search (s .begin(), s. end(),         <i>//string to search in</i>
                     sub.begin() ,sub.end() ,      <i>//substring to search</i>
                     compose_f _gx_hy(equal_to&lt;int&gt;(), <i>//compar. criterion</i>
                                      ptr_fun(toupper),
                                      ptr_fun(toupper)));


       if (pos != s.end()) {
           cout &lt;&lt; "\"" &lt;&lt; sub &lt;&lt; "\" is part of \"" &lt;&lt; s &lt;&lt; "\""
                &lt;&lt; end1;
       }
   }

				</pre>

				<p>The program has the following output:</p>

				<pre>
					
   "Nation" is part of "Internationalization"

				</pRE>

				<P>On page 499 you will find an example program that searches a substring in a case-insensitive way without using <TT ClASs="monofont">compose_f _gx_hy.</TT></p>

			
		</FONT>
 
<table width="100%" border="0" cellspacing="0" cellpadding="0" bgcolor="#CCCCCC">
<td><font color="black" size=1>I l<font color="#FF0000">@</font>ve RuBoard</td>
<td valign="top" class="v2" align="right"><a href="0201379260_snode67.html"><img src="FILES/previous.gif" width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a> <a href="0201379260_cnode69.html"><img src="FILES/next.gif" width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a></td></table>
</BODY></HTML>