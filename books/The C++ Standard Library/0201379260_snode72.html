<HTML><HEAD><META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=iso-8859-1">
<!--SafClassName="docSection1Title"--><!--SafTocEntry="9.2 Algorithm Overview"-->
<LINK REL="stylesheet" href="FILES/sbolM.css">
</HEAD>
<BODY link="#354278" vlink="#000066" alink="#000080" topmargin="0">
<table width="100%" border="0" cellspacing="0" cellpadding="0" bgcolor="#CCCCCC">
<td><font color="black" size=1>I l<font color="#FF0000">@</font>ve RuBoard</td>
<td valign="top" class="v2" align="right"><a href="0201379260_snode71.html"><img src="FILES/previous.gif" width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a> <a href="0201379260_snode73.html"><img src="FILES/next.gif" width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a></td></table>
<FONT><h3>9.2
Algorithm Overview</h3>
			<p>This section presents an overview of all of the C++ standard library algorithms. From it you can get an idea of their abilities and be better able to find the best algorithm to solve a certain problem.</p>

			<H4>9.2.1
A Brief Introduction</H4>
				<P>Algorithms were introduced in <A href="0201379260_cnode32.html">Chapter 5</A> along with the STL. In particular, <A href="0201379260_snode37.html">Section 5.4</a>, and <a href="0201379260_snode39.html">Section 5.6</a>, discuss the role of algorithms and some important constraints regarding their use. All STL algorithms process one or more iterator ranges. The first range is usually specified by its beginning and its end. For additional ranges, in most cases you need to pass only the beginning because the end follows from the number of elements of the first range. The caller must ensure that the ranges are valid. That is, the beginning must refer to a previous or the same element of the same container as the end. Additional ranges must have enough elements.</p>

				<p>Algorithms work in overwrite mode rather than in insert mode. Thus, the caller must ensure that destination ranges have enough elements. You can use special insert iterators (see <a href="0201379260_snode62.html#6">Section 7.4.2</a>) to switch from overwrite to insert mode.</p>

				<p>To increase their flexibility and power, several algorithms allow the user to pass user-defined operations, which they call internally. These operations might be ordinary functions or function objects. If these functions return a Boolean value they are called <i>predicates.</i> You can use predicates for the following tasks:</p>

				<ul>
<li><p>You can pass a function or function objects that specify a unary predicate as the search criterion for a search algorithm. The unary predicate is used to check whether an element fits the criterion. For example, you could search the first element that is less than 50.</p>
</lI>
<LI><P>You can pass a function or function objects that specify a binary predicate as the sorting criterion for a sort algorithm. The binary predicate is used to compare two elements. For example, you could pass a criterion that lets objects that represent a person sort according to their last name (see page 294 for an example).</P>
</Li>
<LI><p>You can pass a unary predicate as the criterion that specifies for which elements an operation should apply. For example, you could specify that only elements with an odd value should be removed.</P>
</Li>
<LI><P>You can specify the numeric operation of numeric algorithms. For example, you could use <TT Class="monofont">accumulate(),</TT> which normally processes the sum of elements, to process the product of all elements.</P>

					</Li>
</ul>
				<p>Note that predicates should not modify their state due to a function call (see <A href="0201379260_snode66.html#6">Section 8.1.4</a>).</p>

				<p>See <A href="0201379260_snode41.html">Section 5.8</a>, <a href="0201379260_snode42.html">Section 5.9</a>, and <a href="0201379260_cnode64.html">Chapter 8</a> for examples and details about functions and function objects that are used as algorithm parameters.</p>

			
			<a name="2"></a><H4>9.2.2
C1assification of Algorithms</H4>
				<P>Different algorithms meet different needs. Thus, they can be c1assified by their main purposes. For example, some algorithms operate as read only, some modify elements, and some change the order of elements. This subsection gives you a brief idea of the functionality of each algorithm and in which aspect it differs from similar algorithms.</P>

				<P>The name of an algorithm gives you a first impression of its purpose. The designers of the STL introduced two special suffixes:</P>

				<oL TyPE="1" sTART="restarts">
<LI><p><b>The <tt CLASs="monofont">_if</tt> suffix </b></P>
<P>The <TT clasS="monofont">_if</TT> suffix is used when you can call two forms of an algorithm that have the same number of parameters either by passing a value or by passing a function or function object. In this case, the version without the suffix is used for values, and the version with the <Tt class="monofont">_if</tt> suffix is used for functions and function objects. For example, <tt class="monofont">find()</tt> searches for an element that has a certain value, whereas <tt clASS="monofont">find_if()</TT> searches for an element that meets the criterion passed as a function or function object. </P>
<p>However, not all algorithms that have a parameter for functions and function objects have the <TT cLAsS="monofont">_if</TT> suffix. When the function or function object version of an algorithm has an additional argument, it has the same name. For example, <TT Class="monofont">min_element()</TT> called with two arguments returns the minimum element in the range according to a comparison with operator <TT clasS="monofont">&lt;.</TT> If you pass a third element, it is used as comparison criterion.</P>
</li>
<li><P><B>The <TT class="monofont">_copy</tt> suffix </b></p>
<p>The <tt class="monofont">_copy</tt> suffix is used as an indication that elements are not only manipulated but also copied into a destination range. For example, <tt CLASS="monofont">reverse()</Tt> reverses the order of elements inside a range, whereas <TT cLAsS="monofont">reverse_copy()</TT> copies the elements into another range in reverse order.</P>

					</LI>
</ol>

				<p>The following subsections and sections describe the algorithms according to the following c1assification:</p>

				<UL>
<LI><p>Nonmodifying algorithms</p>
</li>
<LI><P>Modifying algorithms</P>
</li>
<li><P>Removing algorithms</P>
</LI>
<li><p>Mutating algorithms</p>
</li>
<li><p>Sorting algorithms</p>
</li>
<li><p>Sorted range algorithms</p>
</li>
<li><p>Numeric algorithms</P>

					</LI>
</UL>
				<P>If algorithms belong to more than one category I describe them in the category that I consider to be the most important.</p>

				<H5>Nonmodifying Algorithms</H5>
					<p>Nonmodifying algorithms neither change the order nor the value of the elements they process. They operate with input and forward iterators; therefore, you can call them for all standard containers. <A href="0201379260_snode72.html#4">Table 9.1</A> lists the nonmodifying algorithms of the C++ standard library. See page 330 for nonmodifying algorithms that are provided especially for sorted input ranges.</P>

					<A Name="4"></a><P><TABle boRDER="1" cellSPACing="0" cellpadding="1" width="100%">
<caPTION><H5>Table 9.1. Nonmodifying Algorithms</h5></CApTIoN><COLGRoup aLIGN="left" span="3">
<TR VAlign="top">
<TH>
<FOnt size="2"><b>Name</b>
									</font></th>
<th>
<font sIZE="2"><B>Effect</B>
									</FoNT></tH>
<Th>
<FONT SIze="2"><b>Page</b>
									</FONT></th>
</tr>
<TR VAlign="top">
<TD>
<FOnt size="2"><tt class="monofont">for_each()</tt>
									</font></td>
<TD>
<FONT sIZe="2">Performs an operation for each element</FOnT></TD>
<TD>
<Font sIZE="2">334</Font></tD>
</TR>
<Tr valIGN="top">
<Td>
<font size="2"><tt class="monofont">count()</tt>
									</fonT></TD>
<TD>
<FoNT sIZe="2">Returns the number of elements</FONT></TD>
<td>
<foNT SIze="2">338</foNT></TD>
</tr>
<tr VALIgn="top">
<td>
<font size="2"><tt class="monofont">count()_if()</tt>
									</FONT></TD>
<tD>
<FoNT sIZE="2">Returns the number of elements that match a criterion</FONt></td>
<tD>
<FONt sizE="2">338</FONt></td>
</tR>
<TR Valign="top">
<td>
<font size="2"><tt clasS="monofont">min_element()</TT>
									</FONt></TD>
<tD>
<FoNT SIZE="2">Returns the element with the smallest value</font></TD>
<TD>
<font SIZE="2">340</font></TD>
</TR>
<tr valign="top">
<td>
<font size="2"><tt cLASS="monofont">max_element()</TT>
									</fONt></TD>
<tD>
<FONT Size="2">Returns the element with the largest value</fONT></Td>
<td>
<fONT Size="2">340</fONT></Td>
</tr>
<tr valign="top">
<td>
<font size="2"><TT CLASs="monofont">find()</TT>
									</fONt></TD>
<TD>
<FOnt siZE="2">Searches for the first element with the passed value</FOnt></td>
<TD>
<FOnt siZE="2">341</FOnt></td>
</tr>
<tr valign="top">
<td>
<font sIZE="2"><TT ClASs="monofont">find_if()</TT>
									</fONT></TD>
<Td>
<fonT SIZe="2">Searches for the first element that matches a criterion</fonT></TD>
<Td>
<fonT SIZe="2">341</font></td>
</tr>
<tr valign="top">
<td>
<foNT SIZE="2"><tT ClASs="monofont">search_n()</TT>
									</FONT></td>
<td>
<FONT size="2">Searches for the first <I>n</I> consecutive elements with certain properties
</FOnt></td>
<TD>
<FOnt size="2">344</font></td>
</tr>
<tr valigN="top">
<TD>
<FONt SIzE="2"><Tt CLASS="monofont">search()</Tt>
									</fonT></TD>
<Td>
<fonT SIZe="2">Searches for the first occurrence of a subrange</fonT></TD>
<Td>
<font size="2">347</font></td>
</tr>
<tr vaLIGN="top">
<TD>
<fONt SIzE="2"><TT CLAss="monofont">find_end()</tt>
									</FONT></td>
<td>
<FONT size="2">Searches for the last occurrence of a subrange</FONT></td>
<td>
<font size="2">350</font></td>
</tr>
<tR VALIGn="top">
<TD>
<fONt SIZE="2"><TT clasS="monofont">find_first_of()</TT>
									</Font></tD>
<TD>
<Font sIZE="2">Searches the first of several possible elements</Font></td>
<td>
<font size="2">352</font></td>
</TR>
<TR VAlIGn="top">
<TD>
<fONT SIZe="2"><tt cLASS="monofont">adjacent_find()</tt>
									</foNT></TD>
<td>
<foNT SIze="2">Searches for two adjacent elements that are equal(by some criterion)</font></td>
<td>
<font size="2">354</fonT></TD>
</TR>
<Tr VAlIGn="top">
<TD>
<FONT size="2"><TT CLass="monofont">equal()</tT>
									</FONt></td>
<tD>
<FONt size="2">Returns whether two ranges are equal</font></td>
<td>
<font size="2">356</FONT></TD>
</tR>
<Tr VAlIGN="top">
<TD>
<Font sIZE="2"><Tt claSS="monofont">mismatch()</TT>
									</font></TD>
<TD>
<font size="2">Returns the first elements of two sequences that differ</font></td>
<td>
<font sIZE="2">358</FONt></TD>
</tR>
<Tr VALIGN="top">
<td>
<foNT SIze="2"><tt CLASs="monofont">lexicographical_compare()</tt>
									</fONT></Td>
<td>
<font size="2">Returns whether a range is lexicographically less than another range</font></td>
<td>
<foNT SIZE="2">360</fONt></TD>
</tR>
</COLGRoup>
</tABLE></p>

					<p>One of the most important algorithms is <tt CLASs="monofont">for_each(). for_each()</tt> calls an operation provided by the caller for each element. That operation is usually used to process each element of the range individually. For example, you can pass <tT CLAss="monofont">for_each()</tt> a function that prints each element. However, <tt class="monofont">for_each()</tt> can also call a modifying operation for the elements. So <tt class="monofont">for_each()</tT> can be used as both a nonmodifying and a modifying algorithm. However, you should avoid using <TT CLAsS="monofont">for_each()</Tt> when possible, and use other algorithms to meet your needs because the other algorithms are implemented specifically for that purpose.</P>

					<P>Several of the nonmodifying algorithms perform searching. Unfortunately, the naming scheme of searching algorithms is a mess. In addition, the naming schemes of searching algorithms and searching string functions differ (<a href="0201379260_snode72.html#5">Table 9.2</A>). As is often the case, there are historical reasons for this. First, the STL and string c1asses were designed independently. Second, the <Tt claSS="monofont">find_end(), find_first_of(),</TT> and <tt clASS="monofont">search_n()</Tt> algorithms were not part of the original STL. So, for example, by accident the name <tt cLASS="monofont">find_end()</tt> instead of <tt class="monofont">search_end()</tt> was chosen (it is easy to forget aspects of the whole picture, such as consistency, when you are caught up in the details). Also by accident, a form of <tt class="monofont">search_n()</tt> breaks the general concept of the original STL. See page 346 for a description of this problem.</p>

					<A NAME="5"></A><p><TAbLE bORDER="1" CellsPACIng="0" ceLLPAddinG="1" WIDth="100%">
<caption><h5>Table 9.2. Comparison of Searching String Operations and Algorithms</h5></caption><colGROUP AlIGn="left" SPaN="3">
<TR VALign="top">
<tH>
<FONt sizE="2"><B>Search for</B>
									</Font></tH>
<TH>
<Font size="2"><b>String Function</b>
									</font></th>
<th>
<font SIZE="2"><B>STL Algorithm</B>
									</fONt></TH>
</tR>
<TR VALign="top">
<tD>
<FONt sizE="2">First occurrence of one element</FONt></td>
<tD>
<FONt size="2"><tt class="monofont">find()</tt>
									</font></td>
<tD>
<FONT SiZE="2"><tT ClASS="monofont">find()</TT>
									</Font></tD>
</TR>
<Tr valIGN="top">
<Td>
<fonT SIZe="2">Last occurrence of one element</font></td>
<td>
<font size="2"><tt clASS="monofont">rfind()</TT>
									</FoNT></tD>
<Td>
<FONT SIze="2"><tt CLASs="monofont">find()</tt> with reverse iterators
</fONT></Td>
</tr>
<tR VALign="top">
<td>
<font size="2">First occurrence of a subrange</font></td>
<td>
<FONT SIzE="2"><Tt CLaSS="monofont">find()</TT>
									</FOnt></td>
<TD>
<FOnt siZE="2"><TT clasS="monofont">search()</TT>
									</Font></td>
</tr>
<tr valign="top">
<td>
<font SIZE="2">Last occurrence of a subrange</FOnT></Td>
<TD>
<fONT SIZe="2"><tt cLASS="monofont">rfind()</tt>
									</foNT></TD>
<td>
<foNT SIze="2"><tt class="monofont">find_end()</tt>
									</font></td>
</tr>
<tr VALIGN="top">
<tD>
<FoNT sIZE="2">First occurrence of several elements</FONt></td>
<tD>
<FONt sizE="2"><TT Class="monofont">find_first_of()</TT>
									</FOnt></td>
<td>
<font size="2"><tt class="monofont">find_first_of()</TT>
									</FONT></tD>
</Tr>
<TR vALIGN="top">
<Td>
<fonT SIZe="2">Last occurrence of several elements</fonT></TD>
<Td>
<fonT SIZe="2"><tt class="monofont">find_last_of()</tt>
									</font></td>
<td>
<fonT SIZE="2"><Tt CLaSS="monofont">find_ first_of()</tT> with reverse iterators
</FONT></Td>
</tr>
<tR VALign="top">
<tD>
<FONt sizE="2">First occurrence of <I>n</I> consecutive Elements
</Font></td>
<td>
<font size="2"> </font></td>
<TD>
<FONT sIZe="2"><TT cLASS="monofont">search_n()</TT>
									</font></TD>
</TR>
</colgROUP>
</tablE></P>

				
				<H5>Modifying Algorithms</H5>
					<p>Modifying algorithms change the value of elements. They might modify the elements of a range directly or modify them while they are being copied into another range. If elements are copied into a destination range, the source range is not changed. <a href="0201379260_snode72.html#7">Table 9.3</a> lists the modifying algorithms of the C++ standard library.</p>

					<p>The fundamental modifying algorithms are <tt class="monofont">for_each()</tt> (again) and <tt cLASS="monofont">transform().</TT> You can use both to modify elements of a sequence. However, their behavior differs as follows:</p>

					<UL>
<lI><P><b><TT CLASs="monofont">for_each()</tt></b> accepts an operation that modifies its argument. Thus, the argument has to be passed by reference. For example:</P>

							<PRE>
								
   void square (int&amp; elem)      <i>// call-by-reference</i>
   {

       elem = elem * elem;      <i>// assign processed value directly</i>
   }
   ...
   for_each(coll.begin(),coll.end(),         <I>// range</I>
            square) ;                        <I>// opertion</I>
							</pre>

						</lI>
<LI><P><tt class="monofont">transform()</tt> uses an operation that returns the modified argument. The trick is that it can be used to assign the result to the original element. For example:</p>

							<pre>
								
   int square (int elem)         <i>// call-by-value</i>
   {

       return elem * elem;       <i>// return processed value</i>
   }
   ...
   transform (coll.begin(), coll.end(),        <i>// source range</i>
              coll.begin(),                    <i>// destination range</i>
              square);                         <I>// operation</I>
							</PRE>

						</Li>
</UL>
					<a NAmE="7"></A><P><TABle boRDER="1" cellSPACing="0" cELLPadding="1" width="100%">
<caption><h5>Table 9.3. Modifying Algorithms</h5></cAPTION><cOLgROuP ALIGN="left" span="3">
<TR VAlign="top">
<TH>
<FOnt siZE="2"><B>Name</B>
									</font></th>
<th>
<font size="2"><b>Effect</b>
									</fonT></TH>
<TH>
<FoNT sIZe="2"><B>Page</B>
									</FONT></th>
</tr>
<TR VAlign="top">
<TD>
<FOnt siZE="2"><TT class="monofont">for_each()</tt>
									</font></td>
<td>
<font siZE="2">Performs an operation for each element</FONT></tD>
<Td>
<FOnT SIZE="2">334</Font></tD>
</TR>
<Tr valIGN="top">
<Td>
<fonT SIZe="2"><tt class="monofont">copy()</tt>
									</font></td>
<td>
<fonT SIZE="2">Copies a range starting with the first element</FoNT></tD>
<Td>
<FONT SIze="2">363</foNT></TD>
</tr>
<tr VALIgn="top">
<td>
<FONT size="2"><tt class="monofont">copy _backward()</tt>
									</font></td>
<td>
<FONT SIzE="2">Copies a range starting with the last element</FoNT></tD>
<TD>
<FONt sizE="2">363</FONt></td>
</tR>
<TR ValigN="top">
<TD>
<Font size="2"><tt class="monofont">transform()</tt>
									</font></tD>
<TD>
<FONt SIzE="2">Modifies (and copies) elements; combines elements of two ranges</FoNT></TD>
<TD>
<font SIZE="2">367</font></TD>
</TR>
<tr vaLIGN="top">
<td>
<font size="2"><tt class="monofont">merge()</tt>
									</foNT></TD>
<TD>
<fONt SIzE="2">Merges two ranges</FONT></Td>
<td>
<fONT Size="2">416</fONT></Td>
</tr>
<tR VALign="top">
<td>
<font size="2"><tt class="monofont">swap_ranges()</tT>
									</FONT></Td>
<TD>
<fONt SIZE="2">Swaps elements of two ranges</FOnt></td>
<TD>
<FOnt siZE="2">370</FOnt></td>
</TR>
<TR valign="top">
<td>
<font size="2"><tt claSS="monofont">fill()</TT>
									</FOnT></Td>
<TD>
<fONT SIZe="2">Replaces each element with a given value</fonT></TD>
<Td>
<fonT SIZe="2">372</fonT></TD>
</Tr>
<tr valign="top">
<td>
<font size="2"><tt CLASS="monofont">fill_n()</Tt>
									</FOnT></Td>
<TD>
<FONT size="2">Replaces <I>n</I> elements with a given value
</FOnt></td>
<TD>
<FOnt siZE="2">372</FOnt></td>
</tr>
<tr valign="top">
<td>
<font sIZE="2"><TT ClASs="monofont">generate()</TT>
									</fONT></TD>
<Td>
<fonT SIZe="2">Replaces each element with the result of an operation</fonT></TD>
<Td>
<fonT SIZe="2">373</font></td>
</tr>
<tr valign="top">
<td>
<foNT SIZE="2"><tT ClASs="monofont">generate_n()</TT>
									</FONT></td>
<td>
<FONT size="2">Replaces <I>n</I> elements with the result of an operation
</FOnt></td>
<TD>
<FOnt size="2">373</font></td>
</tr>
<tr valigN="top">
<TD>
<FONt SIzE="2"><Tt CLASS="monofont">replace()</Tt>
									</fonT></TD>
<Td>
<fonT SIZe="2">Replaces elements that have a special value with another value</fonT></TD>
<Td>
<font size="2">375</font></td>
</tr>
<tr vaLIGN="top">
<TD>
<fONt SIzE="2"><TT CLAss="monofont">replace()_if()</tt>
									</FONT></td>
<td>
<FONT size="2">Replaces elements that match a criterion with another value</FONT></td>
<td>
<font size="2">375</font></td>
</tr>
<tR VALIGn="top">
<TD>
<fONt SIZE="2"><TT clasS="monofont">replace_copy()</TT>
									</Font></tD>
<TD>
<Font sIZE="2">Replaces elements that have a special value while copying the whole range</Font></td>
<td>
<font size="2">376</font></td>
</TR>
<TR VAlIGn="top">
<TD>
<fONT SIZe="2"><tt cLASS="monofont">replace_copy_if()</tt>
									</foNT></TD>
<td>
<foNT SIze="2">Replaces elements that match a criterion while copying the whole range</font></td>
<td>
<font size="2">376</fonT></TD>
</TR>
</CoLGrOUp>
</TABLE></P>

					<p>The approach of <tt cLASS="monofont">transform()</tt> is a bit slower because it returns and assigns the result instead of modifying the element directly. However, it is more flexible because it can also be used to modify elements while they are being copied into a different destination sequence, <tt CLASs="monofont">transform()</tt> also has another version, one that can process and combine elements of two source ranges.</p>

					<P>Strictly speaking, <TT Class="monofont">merge()</tt> does not necessarily have to be part of the list of modifying algorithms. This is because it requires that its input ranges must be sorted. So it should be part of the algorithms for sorted ranges (see page 330). However, in practice, <tt class="monofont">merge()</tt> also merges the elements of unsorted ranges. Of course, then the result is unsorted. Nevertheless, to be safe you should call <tt clasS="monofont">merge()</TT> only for sorted ranges.</P>

					<P>Note that elements of associative algorithms are constant to ensure that you can't compromise the sorted order of the elements due to an element modification. Therefore, you can't use associative containers as a destination for modifying algorithms.</P>

					<p>In addition to these modifying algorithms, the C++ standard library provides modifying algorithms for sorted ranges. See page 330 for details.</P>

				
				<H5>Removing Algorithms</h5>
					<P>Removing algorithms are a special form of modifying algorithms. They can remove the elements either in a single range or while they are being copied into another range. As with modifying algorithms, you can't use an associative container as a destination because the elements of the associative container are considered to be constant. <A href="0201379260_snode72.html#9">Table 9.4</A> lists the removing algorithms of the C++ standard library.</P>

					<A name="9"></A><P><TAble bORDEr="1" celLSPAcing="0" cellpadding="1" width="100%">
<cAPTION><h5>Table 9.4. Removing Algorithms</H5></CaPTiON><COLGroup ALIGn="left" spaN="3">
<TR ValigN="top">
<TH>
<Font size="2"><b>Name</b>
									</font></th>
<th>
<font SIZE="2"><B>Effect</B>
									</fONt></TH>
<tH>
<FONT Size="2"><b>Page</B>
									</FONt></th>
</tR>
<TR ValigN="top">
<TD>
<Font size="2"><tt class="monofont">remove()</tt>
									</font></tD>
<TD>
<FONt SIzE="2">Removes elements with a given value</FoNT></TD>
<TD>
<font SIZE="2">378</font></TD>
</TR>
<tr vaLIGN="top">
<td>
<font size="2"><tt class="monofont">remove_if()</tt>
									</foNT></TD>
<TD>
<fONt SIzE="2">Removes elements that match a given criterion</FONT></Td>
<td>
<fONT Size="2">378</fONT></Td>
</tr>
<tR VALign="top">
<td>
<font size="2"><tt class="monofont">remove_copy()</tT>
									</FONT></Td>
<TD>
<fONt SIZE="2">Copies elements that do not match a given value</FOnt></td>
<TD>
<FOnt siZE="2">380</FOnt></td>
</TR>
<TR valign="top">
<td>
<font size="2"><tt claSS="monofont">remove_copy()_if()</TT>
									</FOnT></Td>
<TD>
<fONT SIZe="2">Copies elements that do not match a given criterion</fonT></TD>
<Td>
<fonT SIZe="2">380</fonT></TD>
</Tr>
<tr valign="top">
<td>
<font size="2"><tt CLASS="monofont">unique()</Tt>
									</FOnT></Td>
<TD>
<FONT size="2">Removes adjacent duplicates (elements that are equal to their predecessor)</FONT></td>
<td>
<FONT size="2">381</FONT></td>
</tr>
<tr valign="top">
<td>
<font sizE="2"><TT CLAsS="monofont">unique_copy()</Tt>
									</FOnT></TD>
<TD>
<Font sIZE="2">Copies elements while removing adjacent duplicates</Font></tD>
<TD>
<Font sIZE="2">384</Font></td>
</tr>
</colgroup>
</table></p>

					<P>Note that removing algorithms remove elements logically only by overwriting them with the following elements that were not removed. Thus, they do not change the number of elements in the ranges on which they operate. Instead, they return the position of the new "end" of the range. It's up to the caller to use that new end, such as to remove the elements physically. See <A href="0201379260_snode39.html#1">Section 5.6.1</a>, for a detailed discussion of this behavior.</P>

				
				<H5>Mutating Algorithms</h5>
					<P>Mutating algorithms are algorithms that change the order of elements (and not their values) by assigning and swapping their values. <A href="0201379260_snode72.html#11">Table 9.5</A> lists the mutating algorithms of the C++ standard library. As with modifying algorithms, you can't use an associative container as a destination because the elements of the associative container are considered to be constant.</P>

					<A name="11"></A><P><TAble bORDEr="1" celLSPAcing="0" cellpadding="1" width="100%">
<cAPTION><h5>Table 9.5. Mutating Algorithms</H5></CaPTiON><COLGroup ALIGn="left" spaN="3">
<TR ValigN="top">
<TH>
<Font size="2"><b>Name</b>
									</font></th>
<th>
<font SIZE="2"><B>Effect</B>
									</fONt></TH>
<tH>
<FONT Size="2"><b>Page</B>
									</FONt></th>
</tR>
<TR ValigN="top">
<TD>
<Font size="2"><tt class="monofont">reverse()</tt>
									</font></tD>
<TD>
<FONt SIzE="2">Reverses the order of the elements</FoNT></TD>
<TD>
<font SIZE="2">386</font></TD>
</TR>
<tr vaLIGN="top">
<td>
<font size="2"><tt class="monofont">reverse_copy()</tt>
									</foNT></TD>
<TD>
<fONt SIzE="2">Copies the elements while reversing their order</FONT></Td>
<td>
<fONT Size="2">386</fONT></Td>
</tr>
<tR VALign="top">
<td>
<font size="2"><tt class="monofont">rotate()</tT>
									</FONT></Td>
<TD>
<fONt SIZE="2">Rotates the order of the elements</FOnt></td>
<TD>
<FOnt siZE="2">388</FOnt></td>
</TR>
<TR valign="top">
<td>
<font size="2"><tt claSS="monofont">rotate_copy()</TT>
									</FOnT></Td>
<TD>
<fONT SIZe="2">Copies the elements while rotating their order</fonT></TD>
<Td>
<fonT SIZe="2">389</fonT></TD>
</Tr>
<tr valign="top">
<td>
<font size="2"><tt CLASS="monofont">next_permutation()</Tt>
									</FOnT></Td>
<TD>
<FONT size="2">Permutates the order of the elements</FONT></td>
<td>
<FONT size="2">391</FONT></td>
</tr>
<tr valign="top">
<td>
<font sizE="2"><TT CLAsS="monofont">prev_permutation()</Tt>
									</FOnT></TD>
<TD>
<Font sIZE="2">Permutates the order of the elements</Font></tD>
<TD>
<Font sIZE="2">391</Font></td>
</tr>
<tr valign="top">
<td>
<font SIZE="2"><TT cLAsS="monofont">random_shuffle()</Tt>
									</FONT></TD>
<td>
<foNT SIze="2">Brings the elements into a random order</foNT></TD>
<td>
<foNT SIze="2">393</font></td>
</tr>
<tr valign="top">
<td>
<fONT SIZe="2"><TT cLAsS="monofont">partition()</TT>
									</FONt></td>
<tD>
<FONt sizE="2">Changes the order of the elements so that elements that match a criterion are at the front</FONt></td>
<tD>
<FONt size="2">395</font></td>
</tr>
<tr valign="top">
<TD>
<FONT sIZe="2"><TT cLASS="monofont">stable_partition()</TT>
									</font></TD>
<TD>
<font SIZE="2">Same as <tt clASS="monofont">partition()</Tt> but preserves the relative order of matching and nonmatching elements
</font></td>
<td>
<font size="2">395</font></TD>
</TR>
</COlGRoUP>
</tABLE></P>

				
				<H5>Sorting Algorithms</h5>
					<p>Sorting algorithms are a special kind of mutating algorithm because they also change the order of the elements. However, sorting is more complicated and therefore usually takes more time than simple mutating operations. In fact, these algorithms usually have worse than linear complexity <foNT SIze="1"><suP><A HRef="#FOOTNOTE-3">[3]</a></sUP></FOnt>
<sup>
						</sup>and require random access iterators (for the destination). <a href="0201379260_snode72.html#14">Table 9.6</a> lists the sorting algorithms.</p>
<blockqUOTE><FOnT SiZE="1">
<p CLASS="footnote">
<Sup><a nAME="FOOTNOTE-3">[3]</A></sup>
See <a href="0201379260_snode15.html">Section 2.3</a>, for an introduction to and a discussion of complexity.</p>
</foNT></BLockquote>

						
					<a name="14"></a><p><table bORDER="1" CeLLsPAcING="0" CELlpadDING="1" widtH="100%">
<CAPtion><H5>Table 9.6. Sorting Algorithms</H5></CAption><colgroup align="left" spaN="3">
<TR VALiGN="top">
<tH>
<FoNT SIZE="2"><b>Name</b>
									</foNT></TH>
<th>
<foNT SIze="2"><b>Effect</b>
									</FONT></th>
<th>
<font size="2"><b>Page</b>
									</font></th>
</tR>
<TR VALiGN="top">
<tD>
<FoNT SIZE="2"><tt clASS="monofont">sort()</Tt>
									</fonT></TD>
<Td>
<fonT SIZe="2">Sorts all elements</font></td>
<td>
<font size="2">397</font></TD>
</TR>
<TR vALiGN="top">
<tD>
<FONT Size="2"><tT CLAss="monofont">stable_sort()</tt>
									</FONT></td>
<td>
<FONT size="2">Sorts while preserving order of equal elements</font></td>
<td>
<font size="2">397</fONT></TD>
</Tr>
<TR vALiGN="top">
<TD>
<FOnt siZE="2"><TT clasS="monofont">partial_sort()</TT>
									</Font></tD>
<TD>
<Font size="2">Sorts until the first <i>n</i> elements are correct
</font></td>
<td>
<font SIZE="2">400</FOnT></Td>
</TR>
<tR VALIGn="top">
<td>
<fONT Size="2"><tT CLAss="monofont">partial_sort_copy()</tt>
									</FONT></td>
<td>
<font size="2">Copies elements in sorted order</font></td>
<td>
<fONT SIZe="2">402</FOnT></Td>
</TR>
<TR VAlign="top">
<TD>
<FOnt siZE="2"><TT clasS="monofont">nth_element()</TT>
									</Font></td>
<td>
<font size="2">Sorts according to the <i>n</i>th position
</font></TD>
<TD>
<FOnT SiZE="2">404</fONT></TD>
</Tr>
<tr vALIGn="top">
<td>
<fONT Size="2"><tT CLAss="monofont">partition()</tt>
									</font></td>
<td>
<font size="2">Changes the order of the elements so that elements that match a criterion are at the front</fONT></TD>
<Td>
<FOnT SiZE="2">395</FONT></td>
</tr>
<TR VAlign="top">
<TD>
<FOnt siZE="2"><TT class="monofont">stable_partition()</tt>
									</font></td>
<td>
<font siZE="2">Same as <TT CLaSS="monofont">partition()</tT> but preserves the relative order of matching and nonmatching elements
</FoNT></TD>
<TD>
<font SIZE="2">395</font></TD>
</TR>
<tr vaLIGN="top">
<td>
<font size="2"><tt class="monofont">make_heap()</tt>
									</foNT></TD>
<TD>
<fONt SIzE="2">Converts a range into a heap</FONT></Td>
<td>
<fONT Size="2">406</fONT></Td>
</tr>
<tR VALign="top">
<td>
<font size="2"><tt class="monofont">push_heap()</tT>
									</FONT></Td>
<TD>
<fONt SIZE="2">Adds an element to a heap</FOnt></td>
<TD>
<FOnt siZE="2">406</FOnt></td>
</TR>
<TR valign="top">
<td>
<font size="2"><tt claSS="monofont">pop_heap()</TT>
									</FOnT></Td>
<TD>
<fONT SIZe="2">Removes an element from a heap</fonT></TD>
<Td>
<fonT SIZe="2">407</fonT></TD>
</Tr>
<tr valign="top">
<td>
<font size="2"><tt CLASS="monofont">sort_heap()</Tt>
									</FOnT></Td>
<TD>
<FONT size="2">Sorts the heap (it is no longer a heap after the call)</FONT></td>
<td>
<FONT size="2">407</FONT></td>
</tr>
</colgroup>
</table></p>

					<p>Time often is critical for sorting algorithms. Therefore, the C++ standard library provides more than one sorting algorithm. The algorithms use different ways of sorting, and some algorithms don't sort all elements. For example, <tt CLASS="monofont">nth_element()</Tt> stops when the <I>n</I>th element of the sequence is correct according to the sorting criterion. For the other elements it guarantees only that the previous elements have a lesser or equal value and that the following elements have a greater or equal value. To sort all elements of a sequence, you should consider the following algorithms:</p>

					<UL>
<lI><P><B><TT Class="monofont">sort()</TT></B> is based historically on <I>quicksort.</i> Thus, it guarantees a good runtime <i>(n * log(n)</i> complexity) on average but may have a very bad runtime (quadratic complexity) in the worst case:</p>

							<PRE>
								
    <I>/*sort all elements</i>
     <i>*-best n*log(n) complexity on average</i>
     <i>*-n*n complexity in worst case</I>
     <I>*/</I>
    sort (coll.begin(), coll.end());

							</Pre>

							<p>So if avoiding the worst-case behavior is important, you should use another algorithm, such as <tt class="monofont">partial_sort()</tt> or <tt class="monofont">stable_sort(),</tt> which are discussed next.</P>
</LI>
<LI><P><b><TT cLAsS="monofont">partial_sort()</TT></B> is based historically on <I>heapsort.</I> Thus, it guarantees <i><tt cLASS="monofont">n*log(n)</tt></i> complexity in any case. However, in most circumstances, heapsort is slower than quicksort by a factor of two to five. So, provided <tT CLAss="monofont">sort()</tt> is implemented as quicksort and <TT CLass="monofont">partial_sort()</tt> is implemented as heapsort, <tt class="monofont">partial_sort()</tt> has the better complexity, but <tt class="monofont">sort()</TT> has the better runtime in most cases. The advantage of <TT CLaSS="monofont">partial_sort()</tT> is that it guarantees <I>n * log(n)</i> complexity in any case, so it never becomes quadratic complexity. </P>
<P><TT CLass="monofont">partial_sort()</tT> also has the special ability to stop sorting when only the first <I>n</I> elements need to be sorted. To sort all the elements you have to pass the end of the sequence as second and last argument:</P>

							<pre>
								
   <i>/*sort all elements</I>
    <I>*-always n*log(n) complexity</I>
    <I>*-but usually twice as long as</i> sort()
    <i>*/</i>
   partial_sort (coll.begin(), coll.end(), coll.end());</pRE>
</LI>
<li><p><b><tt class="monofont">stable_sort()</tt></b> is also based historically on heapsort. It sorts all the elements:</p>

							<pre>
								
   <i>/*sort all elements</i>
    <i>*-n*log(n) or n*log(n)*log(n) complexity</I>
    <I>*/</I>
   stable_sort (coll.begin(), coll.end());

							</PRE>

							<p>However, it needs enough additional memory to have <I>n * log(n)</I> complexity. Otherwise, it has <i>n * log(n) * log(n)</I> complexity. The advantage of <Tt CLASS="monofont">stable_sort()</Tt> is that it preserves the order of equal elements.</p>

						</li>
</UL>
					<P>Now you have a brief idea of which sorting algorithm might best meet your needs. But the story doesn't end here. The standard guarantees complexity, but not how it is implemented. This is an advantage in that an implementation could benefit from algorithm innovations and use a better way of sorting without breaking the standard. For example, the <Tt claSS="monofont">sort()</TT> algorithm in the SGI implementation of the STL is implemented by using <i>introsort.</i> Introsort is a new algorithm that, by default, operates like quicksort, but switches to heapsort when it is going to have quadratic complexity. The disadvantage of the fact that the standard does not guarantee exact complexity is that an implementation could use a standard-conforming but very bad algorithm. For example, using heapsort to implement <tt CLASs="monofont">sort()</tt> would be standard conforming. Of course, you simply could test which algorithm fits best, but be aware that measurements might not be portable.</p>

					<p>There are even more algorithms to sort elements. For example, the heap algorithms are provided to call the functions that implement a heap directly (a heap is a binary tree, which is used internally by heapsort). The heap algorithms are provided and used as the base for efficient implementations of priority queues (see <a href="0201379260_snode86.html">Section 10.3</a>). You can use them to sort all elements of a collection by calling them as follows:</p>

					<pre>
						
   <i>/*sort all elements</i>
    <i>*-n+n*log(n) complexity</i>
    <i>*/</i>
   make_heap (coll.begin(), coll.end());
   sort_heap (coll.begin(), coll.end());

					</PRE>

					<P>See <A href="0201379260_snode79.html#4">Section 9.9.4</a>, for details about heaps and heap algorithms.</P>

					<P>The <tT CLASS="monofont">nth_element()</tt> algorithms are provided if you need only the <i>n</i>th sorted element or the set of the <I>n</I> highest or <I>n</I> lowest elements (not sorted). Thus, <tt clASS="monofont">nth_element()</Tt> is a way to split elements into two subsets according to a sorting criterion. However, you could also use <tt cLASS="monofont">partition()</tt> or <tt class="monofont">stable_partition()</tt> to do this. The difference is as follows:</p>

					<ul>
<li><p>For<b>
									<tt cLASS="monofont">nth_element()</TT></b> you pass the number of elements you want to have in the first part (and therefore also in the second part). For example:</P>

							<PrE>
								
   <I>// move the four lowest elements to the front</i>
   nth_element (coll.begin(),               <I>// beginning of range</I>
                coll.begin()+3,             <I>// position between first and second part</I>
                coll.end()) ;               <I>// end of range</I>

							</pre>

							<p>However, after the call you don't know the exact criterion that is the difference between the first and the second parts. Both parts may, in fact, have elements with the same value as the <I>n</I>th element.</P>
</Li>
<li><p>For <B><TT Class="monofont">partition()</TT></B> you pass the exact sorting criterion that serves as the difference between the first and the second parts:</P>

							<pre>
								
     <i>// move all elements less than seven to the front</i>
     vector&lt;int&gt;::iterator pos;
     pos = partition (coll1.begin(), coll1.end(),       <i>// range</i>
                      bind2nd(less&lt;int&gt;(),7));          <i>// criterion</i>

							</pre>

							<p>Here, after the call, you don't know how many elements are owned by the first and the second parts. The return value pos refers to the first element of the second part that contains all elements that don't match the criterion, if any.</p>
</li>
<li><p><b><tT CLASS="monofont">stable_partition()</tT></B> behaves similarly to <tT ClASS="monofont">partition(),</TT> with an additional ability. It guarantees that the order of the elements in both parts remains stable according to their relative positions to the other elements in the same part.</P>

						</li>
</ul>
					<P>You can always pass the sorting criterion to all sorting algorithms as an optional argument. The default sorting argument is the function object <TT Class="monofont">less&lt;&gt;,</TT> so that elements are sorted in ascending order of their values.</P>

					<P>As with modifying algorithms, you can't use an associative container as a destination because the elements of the associative containers are considered to be constant.</p>

					<p>Lists do not provide random access iterators, so you can't call sorting algorithms for them either. However, lists provide a member function <tt CLASs="monofont">sort()</tt> to sort their elements; see page 245.</p>

				
				<h5>Sorted Range Algorithms</h5>
					<p>Sorted range algorithms require that the ranges on which they operate are sorted according to their sorting criterion. <a href="0201379260_snode72.html#16">Table 9.7</a> lists all algorithms of the C++ standard library that are especially written for sorted ranges. Like associative containers, these algorithms have the advantage of a better complexity.</p>

					<a name="16"></a><p><TABLE BoRDeR="1" CeLLSPACing="0" cELLPaddiNG="1" WIdth="100%">
<cAPTIon><h5>Table 9.7. Algorithms for Sorted Ranges</h5></caption><colgroup alIGN="left" SPAn="3">
<TR vALiGN="top">
<TH>
<FOnt siZE="2"><B>Name</B>
									</font></TH>
<TH>
<font SIZE="2"><b>Effect</b>
									</font></th>
<th>
<font size="2"><b>Page</b>
									</fONT></TH>
</Tr>
<TR vALiGN="top">
<TD>
<FOnt siZE="2"><TT clasS="monofont">binary_search()</TT>
									</Font></tD>
<TD>
<Font size="2">Returns whether the range contains an element</font></td>
<td>
<font siZE="2">410</FONT></tD>
</Tr>
<TR vALIGN="top">
<Td>
<fonT SIZe="2"><tt cLASS="monofont">includes()</tt>
									</foNT></TD>
<td>
<font size="2">Returns whether each element of a range is also an element of another range</font></td>
<td>
<fonT SIZE="2">411</FoNT></tD>
</Tr>
<TR VALIgn="top">
<td>
<FONT size="2"><TT CLass="monofont">lower_bound()</tT>
									</FONt></td>
<td>
<font size="2">Finds the first element greater than or equal to a given value</font></td>
<td>
<FONT SIzE="2">413</FoNT></tD>
</TR>
<TR ValigN="top">
<TD>
<Font sIZE="2"><Tt claSS="monofont">upper _bound()</TT>
									</font></td>
<td>
<font size="2">Finds the first element greater than a given value</font></tD>
<TD>
<FONt SIzE="2">413</FoNT></TD>
</TR>
<tr vaLIGN="top">
<td>
<foNT SIze="2"><tt CLASs="monofont">equal_range()</tt>
									</font></td>
<td>
<font size="2">Returns the range of elements equal to a given value</foNT></TD>
<TD>
<fONt SIzE="2">415</FONT></Td>
</tr>
<tR VALign="top">
<tD>
<FONt sizE="2"><TT Class="monofont">merge()</tt>
									</font></td>
<td>
<font sizE="2">Merges the elements of two ranges</FONT></Td>
<TD>
<fONt SIZE="2">416</FOnt></td>
</TR>
<TR valiGN="top">
<TD>
<font SIZE="2"><tt class="monofont">set_union()</tt>
									</font></td>
<td>
<font SIZE="2">Processes the sorted union of two ranges</FOnT></Td>
<TD>
<fONT SIZe="2">418</fonT></TD>
</Tr>
<tr vALIGn="top">
<td>
<fONT Size="2"><tt class="monofont">set.intersection()</tt>
									</font></td>
<td>
<fONT SIZe="2">Processes the sorted intersection of two ranges</FOnT></Td>
<TD>
<FONT size="2">419</FONT></td>
</tr>
<TR VAlign="top">
<TD>
<FOnt size="2"><tt class="monofont">set_difference()</tt>
									</font></td>
<TD>
<FONT sIZe="2">Processes a sorted range that contains all elements of a range that are not part of another</FOnT></TD>
<TD>
<Font sIZE="2">420</Font></tD>
</TR>
<Tr valIGN="top">
<Td>
<font size="2"><tt class="monofont">set_symmetric_difference()</tt>
									</fonT></TD>
<TD>
<FoNT sIZe="2">Processes a sorted range that contains all elements that are in exactly one of two ranges</FONT></TD>
<td>
<foNT SIze="2">421</foNT></TD>
</tr>
<tr VALIgn="top">
<td>
<font size="2"><tt class="monofont">inplace_merge()</tt>
									</FONT></TD>
<tD>
<FoNT sIZE="2">Merges two consecutive sorted ranges</FONt></td>
<tD>
<FONt sizE="2">423</FONt></td>
</tR>
</COLgroup>
</table></p>

					<p>The first five sorted range algorithms in <a href="0201379260_snode72.html#16">Table 9.7</a> are nonmodifying because they search only according to their purpose. The other algorithms combine two sorted input ranges and write the result to a destination range. In general, the result of these algorithms is also sorted.</p>

				
				<h5>Numeric Algorithms</h5>
					<P>These algorithms combine numeric elements in different ways. <A href="0201379260_snode72.html#18">Table 9.8</a> lists the numeric algorithms of the C++ standard library. If you understand the names, you get an idea of the purpose of the algorithms. However, these algorithms are more flexible and more powerful than they may seem at first. For example, by default, <TT cLAsS="monofont">accumulate()</TT> processes the sum of all elements. When you use strings as elements, you concatenate them using this algorithm. When you switch from operator <TT Class="monofont">+</TT> to operator <TT clasS="monofont">*,</TT> you get the product of all elements. As another example, you should know that <Tt claSS="monofont">adjacent_difference()</TT> and <tt class="monofont">partial_sum()</tt> transfer a range of absolute values into a range of relative values and vice versa.</p>

					<p><tt class="monofont">accumulate()</tt> and <tT CLASS="monofont">inner_product()</tT> process and return a single value without modifying the ranges. The other algorithms write the results to a destination range that has the same number of elements as the source range.</P>

					<a NAmE="18"></A><P><TABle boRDER="1" cellSPACing="0" cELLPadding="1" width="100%">
<caption><h5>Table 9.8. Numeric Algorithms</h5></cAPTION><cOLgROuP ALIGN="left" span="3">
<TR VAlign="top">
<TH>
<FOnt siZE="2"><B>Name</B>
									</font></th>
<th>
<font size="2"><b>Effect</b>
									</fonT></TH>
<TH>
<FoNT sIZe="2"><B>Page</B>
									</FONT></th>
</tr>
<TR VAlign="top">
<TD>
<FOnt siZE="2"><TT class="monofont">accumulate()</tt>
									</font></td>
<td>
<font siZE="2">Combines all element values (processes sum, product, and so forth)</FONT></tD>
<Td>
<FOnT SIZE="2">425</Font></tD>
</TR>
<Tr valIGN="top">
<Td>
<fonT SIZe="2"><tt class="monofont">inner_product()</tt>
									</font></td>
<td>
<fonT SIZE="2">Combines all elements of two ranges</FoNT></tD>
<Td>
<FONT SIze="2">427</foNT></TD>
</tr>
<tr VALIgn="top">
<td>
<FONT size="2"><tt class="monofont">adjacent_difference()</tt>
									</font></td>
<td>
<FONT SIzE="2">Combines each element with its predecessor</FoNT></tD>
<TD>
<FONt sizE="2">431</FONt></td>
</tR>
<TR ValigN="top">
<TD>
<Font size="2"><tt class="monofont">partial_sum()</tt>
									</font></tD>
<TD>
<FONt SIzE="2">Combines each element with all of its predecessors</FoNT></TD>
<TD>
<font SIZE="2">429</font></TD>
</TR>
</colgROUP>
</table></p>

				
			
		</font>
 
<table width="100%" border="0" cellspacing="0" cellpadding="0" bgcolor="#CCCCCC">
<td><font color="black" size=1>I l<font color="#FF0000">@</font>ve RuBoard</td>
<td valign="top" class="v2" align="right"><a href="0201379260_snode71.html"><img src="FILES/previous.gif" width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a> <a href="0201379260_snode73.html"><img src="FILES/next.gif" width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a></td></table>
</BODY></HTML>