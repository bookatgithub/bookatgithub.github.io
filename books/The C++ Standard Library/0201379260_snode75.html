<HTML><HEAD><META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=iso-8859-1">
<!--SafClassName="docSection1Title"--><!--SafTocEntry="9.5 Nonmodifying Algorithms"-->
<LINK REL="stylesheet" href="FILES/sbolM.css">
</HEAD>
<BODY link="#354278" vlink="#000066" alink="#000080" topmargin="0">
<table width="100%" border="0" cellspacing="0" cellpadding="0" bgcolor="#CCCCCC">
<td><font color="black" size=1>I l<font color="#FF0000">@</font>ve RuBoard</td>
<td valign="top" class="v2" align="right"><a href="0201379260_snode74.html"><img src="FILES/previous.gif" width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a> <a href="0201379260_snode76.html"><img src="FILES/next.gif" width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a></td></table>
<FONT><h3>9.5
Nonmodifying Algorithms</h3>
			<p>The algorithms presented in this section enable you to access elements without modifying their values or changing their order.</p>

			<H4>9.5.1
Counting Elements</H4>
				<P><I>difference _type</i></p>

				<p><b>count</B>
					<TT Class="monofont">(</TT><TT class="monofont">InputIterator</tt>
					<i>beg,</i>
					<tt class="monofont">InputIterator</tt>
					<i>end,</i>
					<tT CLASS="monofont">const</tT>
					<Tt CLaSS="monofont">T&amp;</TT>
					<I>value</I><tt clASS="monofont">)</Tt></p>

				<p><i>difference _type</I></P>

				<P><B>count_if</b>
					<tt cLASS="monofont">(</tt><tt class="monofont">InputIterator</tt>
					<i>beg,</i>
					<tt class="monofont">InputIterator</tT>
					<I>end,</I>
					<TT ClASs="monofont">UnaryPredicate</TT>
					<i>op</I><TT CLAss="monofont">)</tt></P>

				<UL>
<Li><p>The first form counts the elements in the range [<i>beg,end</i>) that are equal to value <I>value.</I></P>
</Li>
<li><p>The second form counts the elements in the range [<I>beg,end</I>) for which the unary predicate</P>

						<Blockquote>
<p><p><i>op (elem)</i></p>
</p>
</blockqUOTE>
						<P>yields <Tt CLaSS="monofont">true.</tT></P>
</LI>
<LI><p>The type of the return value, <i>difference_type,</i> is the difference type of the iterator:</p>

						<PRE>
							
    typename iterator_traits&lt;lnputIterator&gt;::difference_type

						</Pre>

						<p>(<a href="0201379260_snode63.html">Section 7.5</a>, introduces iterator traits.)<fonT SIZe="1"><sup><a href="#FOOTNOTE-4">[4]</a></sup></font>
</p>
<bloCKQUOTe><FOnT SiZE="1">
<P CLAss="footnote">
<suP><A NAme="FOOTNOTE-4">[4]</a></sUP>
In the original STL the <TT clasS="monofont">count()</TT> and <Tt class="monofont">count_if()</tt> had a fourth input/output parameter that was used as a counter and the return type was <tt class="monofont">void.</tt></p>
</fonT></BLOCKqUOtE>

							</Li>
<LI><P>Note that <I>op</I> should not change its state during a function call. See <A href="0201379260_snode66.html#6">Section 8.1.4</A>, for details.</P>
</LI>
<li><p><i>op</I> should not modify the passed arguments.</P>
</LI>
<li><p>Associative containers (sets, multisets, maps, and multimaps) provide a similar member function, <tT CLAss="monofont">count(),</tt> to count the number of elements that have a certain value as key (see page 234).</p>
</li>
<li><p>Complexity: linear (<i>numberOfElements</i> comparisons or calls of <i>op</i>() respectively).</p>

					</li>
</ul>
				<p>The following example counts elements according to different criteria:</p>

				<PRE>
					
    <I>// algo/count1.cpp</I>

    #include "algostuff.hpp"
    using namespace std;

    bool isEven (int elem)
    {

        return elem % 2 == 0;
    }

    int main()
    {

        vector&lt;int&gt; coll;
        int num;

        INSERT_ELEMENTS(coll,1,9);
        PRINT_ELEMENTS(coll,"coll: ");

        <I>// count and print elements with value</i> 4
        num = count (coll.begin(), coll.end(),           <I>// range</I>
                     4);                                 <i>// value</I>
        cout &lt;&lt; "number of elements equal to 4:          " &lt;&lt; num &lt;&lt; endl;

        <I>// count elements with even value</i>
        num = count_if (coll.begin(), coll.end(),        <I>// range</I>
                        isEven);                         <I>// criterion</I>
        cout &lt;&lt; "number of elements with even value:     " num &lt;&lt; endl;

        <I>// count elements that are greater than value</I> 4
        num = count_if (coll.begin(), coll.end(),        <i>// range</i>
                        bind2nd(greater&lt;int&gt;(),4));      <i>// criterion</i>
        cout &lt;&lt; "number of elements greater than 4:      " &lt;&lt; num &lt;&lt; endl;
    }

				</PRE>

				<P>The program has the following output:</p>

				<pre>
					
   coll: 1 2 3 4 5 6 7 8 9
   number of elements equal to 4:      1
   number of elements with even value: 4
   number of elements greater than 4:  5

				</PRE>

				<P>Instead of using the self-written <tt clASS="monofont">isEven()</Tt> function, you could use the following expression:</p>

				<pre>
					
   not1(bind2nd(modulus&lt;int&gt;(),2))

				</pre>

				<p>See page 306 for more details regarding this expression.</p>

			
			<h4>9.5.2
Minimum and Maximum</h4>
				<p><tt class="monofont">InputIterator</tT></P>

				<P><B>min_element</B> (<Tt CLaSS="monofont">InputIterator</tT>
					<I>beg,</I>
					<TT Class="monofont">InputIterator</TT>
					<I>end</I>)</p>

				<p><tt CLASs="monofont">InputIterator</tt></p>

				<P><B>min_element</B> (<Tt class="monofont">InputIterator</tt>
					<i>beg,</i>
					<tt class="monofont">InputIterator</tt>
					<i>end,</i>
					<TT CLASs="monofont">CompFunc</TT>
					<i>op</I>)</P>

				<p><TT CLASs="monofont">InputIterator</tt></p>

				<P><B>max_element</B> (<Tt claSS="monofont">InputIterator</TT>
					<i>beg,</i>
					<tt CLASs="monofont">InputIterator</tt>
					<i>end</i>)</p>

				<p><tt class="monofont">InputIterator</tt></p>

				<p><b>max_element</b> (<tT CLASS="monofont">InputIterator</tT>
					<I>beg,</i>
					<TT cLASS="monofont">InputIterator</TT>
					<i>end,</i>
					<tt CLASs="monofont">CompFunc</tt>
					<i>op</I>)</P>

				<UL>
<li><p>All algorithms return the position of the minimum or maximum element in the range [<i>beg,end</I>).</P>
</LI>
<li><p>The versions without <i>op</i> compare the elements with operator <tt class="monofont">&lt;.</tt></p>
</li>
<li><p><i>op</I> is used to compare two elements:</P>

						<BLOCkQUoTE>
<p><P><I>op(elem1 ,elem2)</I></P>
</P>
</BlockQUOTe>
						<p>It should return true when the first element is less than the second element.</p>
</lI>
<LI><P>If more than one minimum or maximum element exists, they return the first found.</p>
</li>
<lI><P><I>op</I> should not modify the passed arguments.</p>
</li>
<li><p>Complexity: linear <i>(numberOfElements-1</i> comparisons or calls of <i>op</i>() respectively).</p>

					</li>
</ul>
				<p>The following program prints the minimum and the maximum of the elements in <tt claSS="monofont">coll</TT> and, by using <TT cLAsS="monofont">absLess(),</Tt> prints the minimum and the maximum of the absolute values:</P>

				<PRE>
					
    <I>// algo/minmax1.cpp</I>

    #include &lt;cstdlib&gt;
    #include "algostuff.hpp"
    using namespace std;

    bool absLess (int elem1, int elem2)
    {

        return abs(elem1) &lt; abs (elem2);
    }

    int main()
    {

        deque&lt;int&gt; coll;

        INSERT_ELEMENTS(coll,2,8);
        INSERT_ELEMENTS(coll,-3,5);

        PRINT_ELEMENTS(coll);

        <i>// process and print minimum and maximum</i>
        cout &lt;&lt; "minimum: "
             &lt;&lt; *min_element(coll.begin(),coll.end())
             &lt;&lt; endl;
        cout &lt;&lt; "maximum: "
             &lt;&lt; *max_element(coll.begin(),coll.end())
             &lt;&lt; endl;

        <i>// process and print minimum and maximum of absolute values</i>
        cout &lt;&lt; "minimum of absolute values: "
             &lt;&lt; *min_element(coll.begin(),coll.end(),
                             absLess)
             &lt;&lt; endl;
        cout &lt;&lt; "maximum of absolute values: "
             &lt;&lt; *max_element(coll.begin(),coll.end(),
                             absLess)
             &lt;&lt; endl;
    }

				</PRE>

				<P>The program has the following output:</p>

				<pre>
					
    2 3 4 5 6 7 8 -3 -2 -1 0 1 2 3 4 5
    minimum: -3
    maximum: 8
    minimum of absolute values: 0
    maximum of absolute values: 8

				</PRE>

				<P>Note that the algorithms return the<i>, position</i> of the maximum or minimum element respectively. Thus, you must use the unary operator <tt CLASs="monofont">*</tt> to print their values.</p>

			
			<h4>9.5.3
Searching Elements</h4>
				<h5>Search First Matching Element</h5>
					<p><tt class="monofont">InputIterator</tt></p>

					<p><b>find</B> (<TT CLAsS="monofont">InputIterator</Tt>
						<I>beg,</I>
						<tT CLASS="monofont">InputIterator</tt>
						<i>end,</i>
						<TT CLass="monofont">const</tT>
						<TT Class="monofont">T&amp;</TT>
						<I>value</I>)</p>

					<p><tt class="monofont">InputIterator</tt></p>

					<p><b>find_if</b> (<tt clasS="monofont">InputIterator</TT>
						<I>beg,</I>
						<Tt CLaSS="monofont">InputIterator</tT>
						<I>end,</I>
						<TT Class="monofont">UnaryPredicate</TT>
						<I>op</I>)</p>

					<ul>
<lI><P>The first form returns the position of the first element in the range [<I>beg,end</I>) that has a value equal to <i>value.</i></p>
</lI>
<LI><P>The second form returns the position of the first element in the range [<i>beg,end</i>) for which the unary predicate </p>

							<blockquote>
<p><p><i>op(elem)</i>
									</p>
</p>
</blOCKQUOtE>
							<P>yields <tT ClASS="monofont">true.</TT></P>
</li>
<li><P>Both forms return <I>end</I> if no matching elements are found.</P>
</li>
<li><P>Note that <I>op</I> should not change its state during a function call. See <A href="0201379260_snode66.html#6">Section 8.1.4</A>, for details.</P>
</LI>
<li><p><i>op</i> should not modify the passed arguments.</p>
</li>
<li><p>If the range is sorted, you should use the <tt class="monofont">lower_bound(), upper_bound(), equal_range(),</tt> or <tT CLASS="monofont">binary_search()</tT> algorithms (see <A href="0201379260_snode79.html">Section 9.10</A>).</P>
</LI>
<LI><p>Associative containers (sets, multisets, maps, and multimaps) provide an equivalent member function, <tt cLASS="monofont">find(),</tt> that has logarithmic instead of linear complexity (see page 235).</p>
</lI>
<LI><P>Complexity: linear (at most, <i>numberOfElements</i> comparisons or calls of <i>op</i>() respectively).</P>

						</LI>
</Ul>
					<p>The following example demonstrates how to use <tt class="monofont">find()</tt> to find a subrange starting with the first element with value <tt class="monofont">4</tt> and ending after the second <tT CLASS="monofont">4,</tT> if any:</P>

					<pRE>
						
    <i>// algo/find1.cpp</I>

    #include "algostuff.hpp"
    using namespace std;

    int main()
    {

        list&lt;int&gt; coll;

        INSERT_ELEMENTS(coll,1,9);
        INSERT_ELEMENTS(coll,1,9);

        PRINT_ELEMENTS(coll,"coll: ");

        <I>// find first element with value</I> 4
        list&lt;int&gt;::iterator pos1;
        pos1 = find (coll.begin(), coll.end(),    <I>// range</I>
                     4);                          <I>// value</i>

        <i>/*find second element with value</i> 4
         <i>*- note: continue the search behind the first</I> 4 <I>(if any)</I>
         <I>*/</i>
        list&lt;int&gt;::iterator pos2;
        if (pos1 != coll.end()) {
            pos2 = find (++pos1, coll.end(),      <i>// range</i>
                         4);                      <i>// value</I>
        }

        <I>/*print all elements from first to second</I> 4 <I>(both included)</i>
         <i>*- note: now we need the position of the first</i> 4 <i>again (if any)</I>
         <I>*- note: we have to pass the position behind the second</I> 4 <I>(if any)</i>
         <i>*/</i>
        if (pos1!=coll.end() &amp;&amp; pos2!=coll.end()) {
            copy (--pos1, ++pos2,
                  ostream_iterator&lt;int&gt;(cout," "));
            cout &lt;&lt; endl;
        }
    }

					</pre>

					<p>To find the second <tt class="monofont">4</tt> you must increment the position of the first <tt claSS="monofont">4.</TT> However, incrementing the <TT cLAsS="monofont">end()</Tt> of a collection results in undefined behavior. Thus, if you are not sure, you should check the return value of <TT CLASs="monofont">find()</tt> before you increment it. The program has the following output:</p>

					<PRE>
						
    coll: 1 2 3 4 5 6 7 8 9 1 2 3 4 5 6 7 8 9
    4 5 6 7 8 9 1 2 3 4

					</Pre>

					<p>You can call <tT CLAss="monofont">find()</tt> twice for the same range but with two different values. However, you have to be careful to use the results as the beginning and the end of a subrange of elements; otherwise, the subrange might not be valid. See page 97 for a discussion of possible problems and for an example.</P>

					<P>The following example demonstrates how to use <TT class="monofont">find_if()</tt> to find elements according to very different search criteria:</p>

					<pre>
						
    <i>// algo/find2.cpp</i>

    #include "algostuff.hpp"
    using namespace std;

    int main()
    {

        vector&lt;int&gt; coll;
        vector&lt;int&gt;::iterator pos;

        INSERT_ELEMENTS(coll,1,9);

        PRINT_ELEMENTS(coll,"coll: ");

        <i>// find first element greater than</i> 3
        pos = find_if (coll.begin(), coll.end(),        <i>// range</i>
                       bind2nd(greater&lt;int&gt;(),3));      <i>// criterion</i>

        <i>// print its position</i>

        cout &lt;&lt; "the "
             &lt;&lt; distance(coll.begin(),pos) + 1
             &lt;&lt; ". element is the first greater than 3" &lt;&lt; endl;

        <I>// find first element divisible by</I> 3
        pos = find_if (coll.begin(), coll.end(),
                       not1(bind2nd(modulus&lt;int&gt;(),3)));

        <I>// print its position</I>
        cout &lt;&lt; "the "
             &lt;&lt; distance(coll.begin(),pos) + 1
             &lt;&lt; ". element is the first divisible by 3" &lt;&lt; endl;
    }

					</PRe>

					<P>The first call of <Tt CLaSS="monofont">find()</TT> uses a simple function object combined with the <TT clasS="monofont">bind2nd</TT> adapter to search for the first element that is greater than <Tt claSS="monofont">3.</TT> The second call uses a more complicated combination to find the first element that is divisible by <tt clASS="monofont">3</Tt> without rest.</p>

					<p>The program has the following output:</p>

					<pre>
						
    coll: 1 2 3 4 5 6 7 8 9
    the 4. element is the first greater than 3
    the 3. element is the first divisible by 3

					</pre>

					<p>See page 121 for an example that lets <tt class="monofont">find()</tt> find the first prime number.</p>

				
				<H5>Search First n Matching Consecutive Elements</H5>
					<P><TT ClASs="monofont">InputIterator</TT></p>

					<P><B>search_n</B>
						<TT Class="monofont">(InputIterator</TT>
						<I>beg,</I>
						<tt clASS="monofont">InputIterator</Tt>
						<i>end,</i>
						<tT CLAss="monofont">Size</tt>
						<i>count,</i>
						<tt class="monofont">const T&amp;</tt>
						<i>value</i><tt clASS="monofont">)</TT></P>

					<p><TT cLAsS="monofont">InputIterator</TT></P>

					<P><B>search_n</b>
						<tt cLASS="monofont">(InputIterator</tt>
						<i>beg,</i>
						<TT CLass="monofont">InputIterator</tT>
						<I>end,</I>
						<Tt class="monofont">Size</tt>
						<i>count,</i>
						<tt class="monofont">const T&amp;</tt>
						<i>value,</i>
						<TT CLASs="monofont">BinaryPredicate</TT>
						<i>op</I><Tt CLASS="monofont">)</Tt></p>

					<ul>
<LI><P>The first form returns the position of the first of <I>count</i> consecutive elements in the range [<i>beg,end</i>) that all have a value equal to <i>value.</I></P>
</LI>
<li><p>The second form returns the position of the first of <i>count</I> consecutive elements in the range [<I>beg,end</I>) for which the binary predicate</P>

							<blockquote>
<p><p><i>op(elem, value)</i></p>
</p>
</blockQUOTE>
							<P>yields <tT ClASs="monofont">true.</TT></P>

						</LI>
<Li><p>Both forms return <i>end</i> if no matching elements are found.</P>
</LI>
<Li><p>Note that <i>op</i> should not change its state during a function call. See <A href="0201379260_snode66.html#6">Section 8.1.4</a>, for details.</p>
</lI>
<LI><P><i>op</i> should not modify the passed arguments.</p>
</li>
<li><p>These algorithms were not part of the original STL and were not introduced very carefully. </p>
<p>The fact that the second form uses a binary predicate instead of a unary predicate breaks the consistency of the original STL. See the remarks on page 346.</p>
</li>
<li><p>Complexity: linear (at most, <i>numberOfElements*count</i> comparisons or calls of <i>op</i>() respectively).</p>

						</LI>
</UL>
					<P>The following example searches for three consecutive elements that have a value equal to or greater than <Tt CLaSS="monofont">3:</tT></P>

					<PRE>
						
    <I>// algo/searchn1.cpp</i>

    #include "algostuff.hpp"
    using namespace std;

    int main()
    {

        deque&lt;int&gt; coll;

        INSERT_ELEMENTS(coll,1,9);
        PRINT_ELEMENTS(coll);

        <i>// find three consecutive elements with value</i> 4
        deque&lt;int&gt;::iterator pos;
        pos = search_n (coll.begin(), coll.end(),   <i>// range</I>
                        4,                          <I>// count</I>
                        3);                         <I>// value</i>

        <i>// print result</i>
        if (pos != coll.end()) {
            cout &lt;&lt; "four consecutive elements with value 3 "
                 &lt;&lt; "start with " &lt;&lt; distance(coll.begin(),pos) +1
                 &lt;&lt; ". element" &lt;&lt; endl;
        }
        else {
            cout &lt;&lt; "no four consecutive elements with value 3 found"
                 &lt;&lt; endl;
        }

        <i>// find three consecutive elements with value greater than</I> 4
        pos = search_n (coll.begin(), coll.end(),                   <I>// range</I>
                        4,                                          <I>// count</i>
                        3,                                          <i>// value</i>
                        greater&lt;int&gt;());                            <i>// criterion</I>

        <I>// print result</I>
        if (pos != coll.end()) {
            cout &lt;&lt; "four consecutive elements with value &gt; 3 "
                 &lt;&lt; "start with " &lt;&lt; distance(coll.begin(),pos) +1
                 &lt;&lt; ". element" &lt;&lt; endl;

        }
        else {
            cout &lt;&lt; "no four consecutive elements with value &gt; 3 found"
                 &lt;&lt; endl;
        }
    }

					</Pre>

					<p>The program has the following output:</p>

					<pre>
						
    1 2 3 4 5 6 7 8 9
    no four consecutive elements with value 3 found
    four consecutive elements with value &gt; 3 start with 4. element

					</pre>

					<p>There is a nasty problem with the second form of <tt class="monofont">search_n().</tt> Consider the second call of <tT CLASS="monofont">search_n():</tT></P>

					<pRE>
						
    pos = search_n (coll.begin(), coll.end(),   <i>// range</I>
                    4,                          <I>// count</I>
                    3,                          <I>// value</I>
                    greater&lt;int&gt;());            <I>// criterion</i>

					</pre>

					<P>This kind of searching for elements that matches a special criterion does not conform with the rest of the STL. Following the usual concepts of the STL, the call should be as follows:</P>

					<PRe>
						
    pos = search_n_if (coll.begin(), coll.end(),       <i>// range</i>
                       4,                              <i>// count</I>
                       bind2nd(greater&lt;int&gt;(),3));     <I>// criterion</I>

					</Pre>

					<p>Unfortunately, nobody noticed this inconsistency when these new algorithms were introduced to the standard (they were not part of the original STL). You might argue that the version with four arguments is more convenient. However, it requires a binary predicate even if you only need a unary predicate. For example, to use a self-written unary predicate function, normally you would write:</p>

					<PRE>
						
    bool isPrime (int elem);
    ...
    pos = search_n_if (coll.begin(), coll.end(),   <I>// range</i>
                       4,                          <i>// count</i>
                       isPrime);                   <i>//criterion</i>

					</pre>

					<p>However, with the actual definition you must use a binary predicate. So, either you change the signature of your function or you write a simple wrapper:</p>

					<pre>
						
    bool binaryIsPrime (int elem1, int) {
        return isPrime(elem1);
    }
    ...
    pos = search_n (coll.begin(), coll.end(),     <i>// range</i>
                    4,                            <i>// count</i>
                    0,                            <i>// required dummy value</i>
                    binaryIsPrime);               <i>// binary criterion</i>

					</PRE>

				
				<H5>Search First Subrange</H5>
					<P><tT ClASs="monofont">ForwardIterator1</TT></P>

					<P><B>search</B>
						<tt clASS="monofont">(ForwardIterator1</Tt>
						<i>beg,</i>
						<tT CLAss="monofont">ForwardIterator1</tt>
						<I>end,</I>
						<TT class="monofont">ForwardIterator2</tt>
						<i>searchBeg,</i>
						<tt class="monofont">ForwardIterator2</tt>
						<i>searchEnd</i><tT CLASS="monofont">)</tT></P>

					<p><TT cLASS="monofont">ForwardIterator1</TT></p>

					<p><b>search</b>
						<TT CLass="monofont">(ForwardIterator1</tT>
						<I>beg,</I>
						<Tt claSS="monofont">ForwardIterator1</TT>
						<i>end,</i>
						<tt class="monofont">ForwardIterator2</tt>
						<i>searchBeg,</i>
						<tt class="monofont">ForwardIterator2</tT>
						<I>searchEnd,</I>
						<TT ClASs="monofont">BinaryPredicate</TT>
						<i>op</I><TT CLAss="monofont">)</tt></P>

					<UL>
<Li><p>Both forms return the position of the first element of the first subrange matching the range [<i>searchBeg,searchEnd</i>) in the range [<I>beg,end</I>).</P>
</Li>
<li><p>In the first form the elements of the subrange have to be equal to the elements of the whole range.</P>
</LI>
<Li><p>In the second form for every comparison between elements, the call of the binary predicate</p>

							<blockquote>
<p><p><i>op (elem, searchElem)</i></p>
</p>
</blOCKQUOtE>
							<P>has to yield <tT ClASS="monofont">true.</TT></P>
</li>
<li><P>Both forms return <I>end</I> if no matching elements are found.</P>
</li>
<li><P>Note that <I>op</I> should not change its state during a function call. See <A href="0201379260_snode66.html#6">Section 8.1.4</A>, for details.</P>
</LI>
<li><p><i>op</i> should not modify the passed arguments.</p>
</li>
<li><p>See page 97 for a discussion of how to find a subrange for which you know only the first and the last elements.</p>
</li>
<li><p>Complexity: linear (at most, <i>numberOfElements*numberOfSearchElements</i> comparisons or calls of <i>op<tT CLASS="monofont">()</tT></I> respectively).</p>

						</LI>
</uL>
					<P>The following example demonstrates how to find a sequence as the first subrange of another sequence (compare with the example of <TT CLass="monofont">find_end()</tT> on page 351):</P>

					<PRe>
						
    <i>// algo/search1.cpp</i>

    #include "algostuff.hpp"
    using namespace std;

    int main()
    {

        deque&lt;int&gt; coll;
        list&lt;int&gt; subcoll;

        INSERT_ELEMENTS(coll,1,7);
        INSERT.ELEMENTS(coll,1,7);

        INSERT_ELEMENTS(subcoll,3,6);

        PRINT_ELEMENTS(coll, "coll: ");
        PRINT_ELEMENTS(subcoll,"subcoll: ");

        <i>// search first occurrence of</I> subcoll <I>in</I> coll
        deque&lt;int&gt;::iterator pos;
        pos = search (coll.begin(), coll.end(),            <I>// range</i>
                      subcoll.begin(), subcoll.end());     <i>//subrange</i>

        <i>// loop while subcoll found as subrange of</I> coll
        while (pos != coll.end()) {
            <I>// print position of first element</I>
            cout &lt;&lt; "subcoll found starting with element "
                 &lt;&lt; distance (coll.begin(),pos) + 1
                 &lt;&lt; endl;

            <I>// search next occurrence of</i> subcoll
            ++pos;
            pos = search (pos, coll.end(),                  <i>// range</i>
                          subcoll.begin(), subcoll.end());  <i>// subrange</i>
        }
    }

					</pre>

					<p>The program has the following output:</p>

					<pre>
						
    coll: 1 2 3 4 5 6 7 1 2 3 4 5 6 7
    subcoll: 3 4 5 6
    subcoll found starting with element 3
    subcoll found starting with element 10

					</pre>

					<p>The next example demonstrates how to use the second form of the <tt clASS="monofont">search()</TT> algorithm to find a subsequence that matches a more complicated criterion. Here, the subsequence <I>even, odd, and even value</i> is searched:</P>

					<PrE>
						
    <I>// algo/search2.cpp</i>

    #include "algostuff.hpp"
    using namespace std;

    <I>// checks whether an element is even or odd</I>
    bool checkEven (int elem, bool even)
    {

        if (even) {
            return elem % 2 == 0;
        }
        else {
            return elem % 2 == 1;
        }
    }

    int main()
    {

        vector&lt;int&gt; coll;

        INSERT_ELEMENTS(coll,1,9);
        PRINT_ELEMENTS(coll,"coll: ");

        <I>/* arguments for</I> checkEven()
         <I>* - check for: "even odd even"</I>
         <i>*/</i>
        bool checkEvenArgs[3] = { true, false, true };

        <i>// search first subrange in</i> coll
        vector&lt;int&gt;::iterator pos;
        pos = search (coll.begin(), coll.end(),       <I>// range</I>
                      checkEvenArgs, checkEvenArgs+3, <I>// subrange values</I>
                      checkEven);                     <i>// subrange criterion</i>

        <i>// loop while subrange found</i>
        while (pos != coll.end()) {
            <I>// print position of first element</I>
            cout &lt;&lt; "subrange found starting with element "
                 &lt;&lt; distance(coll.begin(),pos) + 1
                 &lt;&lt; endl;

            <I>// search next subrange in</I> coll
            pos = search (++pos, coll.end(),               <i>// range</i>
                          checkEvenArgs, checkEvenArgs+3,  <i>// subr. values</i>
                          checkEven);                      <I>// subr. criterion</I>
        }
    }

					</PRe>

					<p>The program has the following output:</p>

					<pre>
						
    coll: 1 2 3 4 5 6 7 8 9
    subrange found starting with element 2
    subrange found starting with element 4
    subrange found starting with element 6

					</pre>

				
				<h5>Search Last Subrange</h5>
					<p><tt class="monofont">ForwardIterator</tt></P>

					<P><B>find_end</B>
						<TT cLAsS="monofont">(ForwardIterator</Tt>
						<I>beg,</I>
						<TT CLass="monofont">ForwardIterator</tT>
						<I>end,</I>
						<Tt claSS="monofont">ForwardIterator</TT>
						<i>searchBeg,</i>
						<tt CLASs="monofont">ForwardIterator</tt>
						<i>searchEnd</i><tt class="monofont">)</tt></p>

					<p><tt claSS="monofont">ForwardIterator</TT></P>

					<P><b>find_end</B>
						<Tt CLaSS="monofont">(ForwardIterator</TT>
						<I>beg,</I>
						<tt clASS="monofont">ForwardIterator</Tt>
						<i>end,</i>
						<tT CLAss="monofont">ForwardIterator</tt>
						<I>searchBeg,</I>
						<TT class="monofont">ForwardIterator</tt>
						<i>searchEnd,</i>
						<tt class="monofont">BinaryPredicate</tt>
						<i>op</i><tT CLASS="monofont">)</tT></P>

					<uL>
<Li><P>Both forms return the position of the first element of the last subrange matching the range [<I>saarchBeg,searchEnd</I>) in the range [<I>beg,end</I>).</P>
</li>
<li><P>In the first form the elements of the subrange have to be equal to the elements of the whole range.</P>
</LI>
<li><p>In the second form, for every comparison between elements, the call of the binary predicate</p>

							<BLOCkquoTE>
<P><P><i>op(elem,searchElem)</i></p>
</p>
</blockquote>
							<p>has to yield <tt clasS="monofont">true.</TT></P>
</LI>
<lI><P>Both forms return <i>end</I> if no matching elements are found.</P>
</lI>
<LI><P>Note that <I>op</I> should not change its state during a function call. See <a href="0201379260_snode66.html#6">Section 8.1.4</A>, for details.</P>
</Li>
<li><p><I>op</I> should not modify the passed arguments.</P>
</Li>
<li><p>See page 97 for a discussion of how to find a subrange for which you only know the first and the last elements.</P>
</LI>
<Li><p>These algorithms were not part of the original STL. Unfortunately they were called <tt class="monofont">find_end()</tt> instead of <tt class="monofont">search_end(),</tt> which would be more consistent, because the algorithm used to search the first subrange is called <tT CLASS="monofont">search().</tT></P>
</lI>
<Li><P>Complexity: linear (at most, <I>numberOfElements*numberOfSearchElements</I> comparisons or calls of <I>op<TT clasS="monofont">()</TT></I> respectively).</p>

						</li>
</uL>
					<P>The following example demonstrates how to find a sequence as the last subrange of another sequence (compare with the example of <TT clasS="monofont">search()</TT> on page 348):</P>

					<pre>
						
    <i>// algo/findend1.cpp</i>

    #include "algostuff.hpp"
    using namespace std;

    int main()
    {

        deque&lt;int&gt; coll;
        list&lt;int&gt; subcoll;

        INSERT_ELEMENTS(coll,1,7);
        INSERT_ELEMENTS(coll,1,7);

        INSERT_ELEMENTS(subcoll,3,6);

        PRINT_ELEMENTS(coll,   "coll:    ");
        PRINT_ELEMENTS(subcoll,"subcoll: ");

        <i>// search last occurrence of</i> subcoll <i>in</i> coll
        deque&lt;int&gt;::iterator pos;
        pos = find_end (coll.begin(), coll.end(),         <i>// range</i>
                        subcoll.begin(), subcoll.end());  <i>// subrange</i>

        <i>// loop while subcoll found as subrange of</i> coll
        deque&lt;int&gt;::iterator end(coll.end());
        while (pos != end) {
            <i>// print position of first element</i>
            cout &lt;&lt; "subcoll found starting with element "
                 &lt;&lt; distance(coll.begin(),pos) + 1
                 &lt;&lt; endl;

            <i>// search next occurrence of</i> subcoll
            end = pos;
            pos = find_end (coll.begin(), end,                <i>// range</i>
                            subcoll.begin(), subcoll.end());  <I>// subrange</I>
        }
    }

					</PRE>

					<P>The program has the following output:</p>

					<PRe>
						
    coll:    1 2 3 4 5 6 7 1 2 3 4 5 6 7
    subcoll: 3 4 5 6
    subcoll found starting with element 10
    subcoll found starting with element 3

					</PRe>

					<P>For the second form of this algorithm, see the second example of <TT CLAss="monofont">search()</tt> on page 349. You can use <TT CLass="monofont">find_end()</tT> in a similar manner.</P>

				
				<H5>Search First of Several Possible Elements</H5>
					<p><tt cLASS="monofont">ForwardIterator</tt></p>

					<p><b>find_first_of</b>
						<tt class="monofont">(ForwardIterator1</tt>
						<i>beg,</i>
						<tt clASS="monofont">ForwardIterator1</TT>
						<I>end,</i>
						<TT cLAsS="monofont">ForwardIterator2</TT>
						<I>searchBeg,</I>
						<Tt claSS="monofont">ForwardIterator2</TT>
						<i>searchEnd</i><tt CLASs="monofont">)</tt></p>

					<P><TT Class="monofont">ForwardIterator</tt></p>

					<p><b>find_first_of</b>
						<tt class="monofont">(ForwardIterator1</tt>
						<i>beg,</i>
						<TT CLASs="monofont">ForwardIterator1</TT>
						<i>end,</I>
						<Tt CLASS="monofont">ForwardIterator2</Tt>
						<i>searchBeg,</i>
						<tT CLAss="monofont">ForwardIterator2</tt>
						<I>searchEnd,</I>
						<TT clasS="monofont">BinaryPredicate</TT>
						<I>op</i><tt class="monofont">)</tt></p>

					<ul>
<li><p>The first form returns the position of the first element in the range [<i>beg,end</i>) that is also in the range [<i>searchBeg,searchEnd</i>).</p>
</LI>
<LI><P>The second form returns the position of the first element in the range [<I>beg,end</i>) for which any call with all elements of [<I>searchBeg,searchEnd</I>)</p>

							<BLoCKQUOTe>
<p><p><i>op (elem,searchElem)</I></P>
</P>
</BlockQUOTe>
							<p>yields <tt CLASs="monofont">true.</tt></p>
</li>
<li><p>Both forms return <i>end</i> if no matching elements are found.</p>
</li>
<li><p>Note that <i>op</i> should not change its state during a function call. See <a href="0201379260_snode66.html#6">Section 8.1.4</A>, for details.</P>
</Li>
<LI><p><I>op</I> should not modify the passed arguments.</p>
</LI>
<LI><P>By using reverse iterators, you can find the last of several possible values.</P>
</li>
<li><P>These algorithms were not part of the original STL.</P>
</LI>
<li><p>Complexity: linear (at most, <i>numberOfElements</I> comparisons or calls of <I>op</I><Tt claSS="monofont">()</TT> respectively).</p>

						</li>
</ul>
					<p>The following example demonstrates the use of <tt class="monofont">find_first_of():</tt></p>

					<pre>
						
    <i>// algo/findof1.cpp</i>

    #include "algostuff.hpp"
    using namespace std;

    int main()
    {

        vector&lt;int&gt; coll;
        list&lt;int&gt; searchcoll;

        INSERT_ELEMENTS(coll,1,11);
        INSERT_ELEMENTS(searchcoll,3,5);

        PRINT_ELEMENTS(coll,      "coll:       ");
        PRINT_ELEMENTS(searchcoll,"searchcoll: ");

        <I>// search first occurrence of an element of</I> searchcoll <I>in</I> coll
        vector&lt;int&gt;::iterator pos;
        pos = find_first_of (coll.begin(), coll.end(),     <I>// range</I>
                             searchcoll.begin(),  <i>// beginning of search set</I>
                             searchcoll.end());   <I>// end of search set</i>
        cout &lt;&lt; "first element of searchcoll in coll is element "
             &lt;&lt; distance(coll.begin(),pos) + 1
             &lt;&lt; endl;

        <I>// search last occurrence of an element of</I> searchcoll <i>in</I> coll
        vector&lt;int&gt;::reverse_iterator rpos;
        rpos = find_first_of (coll.rbegin(), coll.rend(),   <I>// range</I>
                              searchcoll.begin(),  <I>// beginning of search set</I>
                              searchcoll.end());   <I>// end of search set</i>
        cout &lt;&lt; "last element of searchcoll in coll is element "
             &lt;&lt; distance (coll.begin(),rpos.base())
             &lt;&lt; endl;
    }

					</pre>

					<P>The second call uses reverse iterators to find the last element that has a value equal to one element in <TT Class="monofont">searchcoll.</TT> To print the position of the element, <TT clasS="monofont">base()</TT> is called to transform the reverse iterator into an iterator. Thus, you can process the distance from the beginning. Normally you would have to add 1 to the result of <Tt class="monofont">distance()</tt> because the first element has distance <tt class="monofont">0</tt> but actually is element <tt clASS="monofont">1.</TT> However, because <Tt CLaSS="monofont">base()</tT> moves the position of the value to which it refers, you have the same effect (see <A href="0201379260_snode62.html#1">Section 7.4.1</a>, for the description of <tt cLASS="monofont">base()</tt>).</p>

					<p>The program has the following output:</P>

					<PRE>
						
    coll:       1 2 3 4 5 6 7 8 9 10 11
    searchcoll: 3 4 5
    first element of searchcoll in coll is element 3
    last element of searchcoll in coll is element 5

					</pre>

				
				<h5>Search Two Adjacent, Equal Elements</H5>
					<P><TT class="monofont">InputIterator</tt></p>

					<p><b>adjacent_find</b>
						<tt class="monofont">(InputIterator</tt>
						<i>beg,</I>
						<TT CLAsS="monofont">InputIterator</Tt>
						<I>end</I><tT CLASS="monofont">)</tt></p>

					<p><TT CLass="monofont">InputIterator</tT></P>

					<P><B>adjacent_find_if</b>
						<tt cLASS="monofont">(InputIterator</tt>
						<i>beg,</i>
						<tt class="monofont">InputIterator</tt>
						<i>end,</i>
						<tt clasS="monofont">BinaryPredicate</TT>
						<I>op</I><Tt CLaSS="monofont">)</tT></P>

					<UL>
<LI><p>The first algorithm returns the first element in the range [<i>beg,end</i>) that has a value equal to the value of the following element.</p>
</LI>
<LI><p>The second algorithm returns the first element in the range [<i>beg,end</i>) for which the binary predicate</p>

							<BLOCkquoTE>
<P><P><i>op(elem,nextElem)</i></p>
</p>
</blockquote>
							<p>yields <tt clasS="monofont">true.</TT></P>
</LI>
<lI><P>Both algorithms return <i>end</I> if no matching elements are found.</P>
</lI>
<LI><P>Note that <I>op</I> should not change its state during a function call. See <a href="0201379260_snode66.html#6">Section 8.1.4</A>, for details.</P>
</Li>
<li><p><I>op</I> should not modify the passed arguments.</P>
</Li>
<li><p>Complexity: linear (at most, <I>numberOfElements</I> comparisons or calls of <I>op</I>() respectively).</p>

						</li>
</ul>
					<p>The following program demonstrates both forms of <tt class="monofont">adjacent_find():</tt></p>

					<pre>
						
    <i>// algo/adjfindl.cpp</i>

    #include "algostuff.hpp"
    using namespace std;

    <I>// return whether the second object has double the value of the first</I>
    bool doubled (int elem1, int elem2)
    {
        return elem1 * 2 == elem2;
    }

    int main()
    {

        vector&lt;int&gt; coll;

        coll.push_back(l);
        coll.push_back(3);
        coll.push_back(2);
        coll.push_back(4);
        coll.push_back(5);
        coll.push_back(5);
        coll.push_back(0);

        PRINT_ELEMENTS(coll,"coll: ");

        <I>// search first two elements with equal value</I>
        vector&lt;int&gt;::iterator pos;
        pos = adjacent_find (coll.begin(), coll.end());

        if (pos != coll.end()) {
            cout &lt;&lt; "first two elements with equal value have position "
                 &lt;&lt; distance(coll.begin(),pos) + 1
                 &lt;&lt; endl;
        }

        <I>//search first two elements for which the second has double the value of the first</I>
        pos = adjacent_find (coll.begin(), coll.end(),   <i>// range</I>
                             doubled);                   <I>// criterion</i>

        if (pos != coll.end()) {
            cout &lt;&lt; "first two elements with second value twice the "
                 &lt;&lt; "first have pos. "
                 &lt;&lt; distance (coll.begin(),pos) + 1
                 &lt;&lt; endl;
        }
    }

					</PRe>

					<P>The first call of <TT CLAss="monofont">adjacent_find()</tt> searches for equal values. The second form uses <TT CLass="monofont">doubled()</tT> to find the first element for which the successor has the double value. The program has the following output:</P>

					<PRe>
						
    coll: 1 3 2 4 5 5 0
    first two elements with equal value have position 5
    first two elements with second value twice the first have pos. 3

					</pre>

				
			
			<A NAMe="11"></a><h4>9.5.4
Comparing Ranges</h4>
				<h5>Testing Equality</h5>
					<p><tt class="monofont">bool</tt></p>

					<p><b>equal</b>
						<tT CLASS="monofont">(InputIterator1</tT>
						<I>beg,</i> InputIterator1 <I>end,</I>
						<tT CLASS="monofont">InputIterator2</tt>
						<i>cmpBeg</i><TT CLass="monofont">)</tT></P>

					<P><Tt claSS="monofont">bool</TT></p>

					<p><b>equal</b>
						<tt class="monofont">(InputIterator1</tt>
						<i>beg,</i> InputIterator1 <i>end,</i>
						<tt clASS="monofont">InputIterator2</TT>
						<I>cmpBeg,</i>
						<TT cLAsS="monofont">BinaryPredicate</TT>
						<I>op</I><Tt claSS="monofont">)</TT></p>

					<ul>
<lI><P>The first form returns whether the elements in the range [<I>beg,end</I>) are equal to the elements in the range starting with <i>cmpBeg.</i></p>
</lI>
<LI><P>The second form returns whether each call of the binary predicate</p>

							<blockquote>
<p><p><i>op</i> (<i>elem, cmpElem</i>)</p>
</p>
</blOCKQUOtE>
							<P>with the corresponding elements in the range [<i>beg,end</I>) and in the range starting with <I>cmpBeg</i> yields <TT CLASs="monofont">true.</tt></p>
</LI>
<LI><p>Note that <i>op</i> should not change its state during a function call. See <a href="0201379260_snode66.html#6">Section 8.1.4</a>, for details.</p>
</li>
<LI><P><I>op</i> should not modify the passed arguments.</p>
</li>
<li><p>The caller must ensure that the range starting with <i>cmpBeg</i> contains enough elements.</p>
</li>
<li><p>To determine the differences when the sequences are not equal, you should use the <tt clasS="monofont">mismatch()</TT> algorithm (see page 358).</P>
</LI>
<lI><P>Complexity: linear (at most, <i>numberOfElements</I> comparisons or calls of <I>op</i>() respectively).</P>

						</LI>
</UL>
					<P>The following example demonstrates both forms of <tt clASS="monofont">equal().</Tt> The first call checks whether the elements have values with equal elements. The second call uses an auxiliary predicate function to check whether the elements of both collections have corresponding even and odd elements:</p>

					<prE>
						
    <I>// algo/equal1.cpp</I>

    #include "algostuff.hpp"
    using namespace std;
    bool bothEvenOrOdd (int elem1, int elem2)
    {
        return elem1 % 2 == elem2 % 2;
    }


    int main()
    {

        vector&lt;int&gt; coll1;
        list&lt;int&gt; coll2;


        INSERT_ELEMENTS(coll1,1,7);
        INSERT_ELEMENTS(coll2,3,9);


        PRINT_ELEMENTS(coll1,"coll1: ");
        PRINT_ELEMENTS(col12,"col12: ");


        <I>//check whether both collections are equal</i>
        if (equal (coll1. begin(), coll1. end(),  <i>//first range</i>
                   coll2.begin())) {              <i>//second range</I>
            cout &lt;&lt; "coll1 == col12" &lt;&lt; endl;
        }
        else {
            cout &lt;&lt; "coll1 != coll2" &lt;&lt; endl;
        }


        <I>//check for corresponding even and odd elements</I>
        if (equal (coll1.begin(), coll1.end(),   <I>//first range</i>
                   coll2. begin(),               <i>//second range</i>
                   bothEvenOrOdd)) {             <i>//comparison criterion</i>
            cout &lt;&lt; "even and odd elements correspond" &lt;&lt; endl;
        }
        else {
            cout &lt;&lt; "even and odd elements do not correspond" &lt;&lt; endl;
        }
    }

					</pre>

					<p>The program has the following output:</p>

					<pre>
						
    coll1: 1 2 3 4 5 6 7
    coll2: 3 4 5 6 7 8 9
    coll1 != coll2
    even and odd elements correspond

					</pre>

				
				<h5>Search the First Difference</h5>
					<p><tt CLASS="monofont">pair&lt;InputIterator1,InputIterator2&gt;</Tt></P>

					<P><b>mismatch</B>
						<Tt CLASS="monofont">(InputIterator1</Tt>
						<i>beg,</i>
						<tT CLAss="monofont">InputIterator1</tt>
						<I>end,</I>
						<TT clasS="monofont">InputIterator2</TT>
						<I>cmpBeg</i><tt class="monofont">)</tt></p>

					<p><tt class="monofont">pair&lt;InputIterator1,InputIterator2&gt;</tt></P>

					<P><B>mismatch</B>
						<TT cLAsS="monofont">(InputIterator1</Tt>
						<I>beg,</I> InputIterator1 <I>end,</I>
						<TT clasS="monofont">InputIterator2</TT>
						<I>cmpBeg,</i>
						<tt cLASS="monofont">BinaryPredicate</tt>
						<i>op</i><TT CLass="monofont">)</tt></p>

					<ul>
<li><p>The first form returns the first two corresponding elements of range [<i>beg,end</i>) and the range starting with <i>cmpBeg</i> that differ.</p>
</li>
<li><p>The second form returns the first two corresponding elements of range [<I>beg,end</I>) and the range starting with <I>cmpBeg</I> for which the binary predicate</P>

							<BlOCkQUoTE>
<P><P><I>op</I> (<i>elem, cmpElem</i>)</p>
</p>
</BLOCkquoTE>
							<P>yields <Tt claSS="monofont">true.</TT></p>
</li>
<li><p>If no difference is found, a pair of <i>end</i> and the corresponding element of the second range is returned. Note that this does not mean that both sequences are equal, because the second sequence might contain more elements.</p>
</li>
<li><p>Note that <i>op</i> should not change its state during a function call. See <a href="0201379260_snode66.html#6">Section 8.1.4</A>, for details.</P>
</LI>
<LI><p><I>op</I> should not modify the passed arguments.</p>
</LI>
<lI><P>The caller must ensure that the range starting with <I>cmpBeg</I> contains enough elements.</P>
</Li>
<li><p>To check whether two ranges are equal, you should use the <TT CLass="monofont">equal()</tT> algorithm (see page 356).</P>
</LI>
<li><p>Complexity: linear (at most, <i>numberOfElements</I> comparisons or calls of <I>op</I><Tt class="monofont">()</tt> respectively).</p>

						</li>
</ul>
					<p>The following example demonstrates both forms of <tt class="monofont">mismatch():</TT></P>

					<PRE>
						
    <i>// algo/misma1.cpp</I>

    #include "algostuff.hpp"
    using namespace std;

    int main()
    {

        vector&lt;int&gt; coll1;
        list&lt;int&gt; coll2;

        INSERT_ELEMENTS(coll1,1,6);

        for (int i=1; i&lt;=16; i*=2) {
            col12.push_back(i);
        }
        coll2.push_back(3);

        PRINT_ELEMENTS(coll1,"coll1: ");
        PRINT_ELEMENTS(coll2,"coll2: ");

        <I>//find first mismatch</i>
        pair&lt;vector&lt;int&gt;::iterator,list&lt;int&gt;::iterator&gt; values;
        values = mismatch (coll1.begin(), coll1.end(),  <I>//first range</I>
                           coll2.begin());              <i>//second range</I>
        if (values.first == coll1.end()) {
            cout &lt;&lt; "no mismatch" &lt;&lt; endl;
        }
        else {
            cout &lt;&lt; "first mismatch: "
                 &lt;&lt; *values.first &lt;&lt; " and "
                 &lt;&lt; *values.second &lt;&lt; endl;
        }

        <I>/*find first position where the element of</I> coll1 <I>is not</I>
         <I>*less than the corresponding element of</i> coll2
         <i>*/</i>
        values = mismatch (coll1.begin(), coll1.end(),   <i>//first range</I>
                           col12. begin(),               <I>//second range</I>
                           less_equal&lt;int&gt;() )           <I>//criterion</i>
        if (values.first == coll1.end()) {
            cout &lt;&lt; "always less-or-equal" &lt;&lt; endl;
        }
        else {
            cout &lt;&lt; "not less-or-equal: "
                 &lt;&lt; *values.first &lt;&lt; " and "
                 &lt;&lt; *values.second &lt;&lt; endl;
        }
    }

					</pre>

					<P>The first call of <TT Class="monofont">mismatch()</TT> searches for the first corresponding elements that are not equal. If such elements exist, their values are written to standard output. The second call searches for the first pair of elements in which the element of the first collection is greater than the corresponding element of the second collection, and returns these elements. The program has the following output:</P>

					<Pre>
						
    coll1: 1 2 3 4 5 6
    coll2: 1 2 4 8 16 3
    first mismatch: 3 and 4
    not less-or-equal: 6 and 3

					</pre>

				
				<h5>Testing for "Less Than"</h5>
					<p><tt class="monofont">bool</tt></p>

					<p><b>lexicographical_compare</b>
						<TT CLASs="monofont">(InputIterator1</TT>
						<i>beg1,</I> Input Iterator1 <I>end1,</i>
						<TT CLASs="monofont">InputIterator2</tt>
						<i>beg2,</I>
						<TT Class="monofont">InputIterator2</TT>
						<I>end2</I><tt clASS="monofont">)</Tt></p>

					<p><tt class="monofont">bool</tt></p>

					<p><b>lexicographical_compare</b>
						<tt claSS="monofont">(InputIterator1</TT>
						<I>begl,</I>
						<tT ClASs="monofont">InputIterator1</TT>
						<I>end1,</I>
						<TT clasS="monofont">InputIterator2</TT>
						<I>beg2,</i>
						<tt cLASS="monofont">InputIterator2</tt>
						<i>end2,</i>
						<TT CLass="monofont">CompFunc</tt>
						<i>op</i><tt class="monofont">)</tt></p>

					<ul>
<li><P>Both forms return whether the elements in the range [<I>beg1,end1</I>) are "lexicographically less than" the elements in the range [<I>beg2,end2</I>).</P>
</lI>
<Li><P>The first form compares the elements by using operator <Tt CLASS="monofont">&lt;.</Tt></p>
</li>
<LI><P>The second form compares the elements by using the binary predicate</P>

							<blocKQUOte>
<p><p><I>op</I>(<I>elem1 ,elem2</I>)</p>
</p>
</blockquote>
							<p>It should return <tt class="monofont">true</tT> when <I>elem1</I> is less than <I>elem2.</I></P>
</lI>
<Li><P><I>Lexicographical comparison</i> means that sequences are compared element-by-element until any of the following occurs:</P>

							<UL>
<LI><P>When two elements are not equal, the result of their comparison is the result of the whole comparison.</p>
</li>
<lI><P>When one sequence has no more elements, then the sequence that has no more elements is less than the other. Thus, the comparison yields <TT clasS="monofont">true</TT> if the first sequence is the one that has no more elements.</P>
</li>
<li><P>When both sequences have no more elements, then both sequences are equal, and the result of the comparison is <TT Class="monofont">false.</tt></p>
</li>
</ul>
						</li>
<li><p>Note that <i>op</i> should not change its state during a function call. See <a href="0201379260_snode66.html#6">Section 8.1.4</A>, for details.</P>
</LI>
<lI><P><i>op</I> should not modify the passed arguments.</P>
</lI>
<LI><P>Complexity: linear (at most, <TT clasS="monofont">2*min</TT>(<I>numberOfElements1,numberOfElements2</i>) comparisons or calls of <i>op</i>() respectively).</p>

						</LI>
</UL>
					<p>The following example demonstrates the use of a lexicographical sorting of collections:</p>

					<prE>
						
   <I>// algo/lexico1.cpp</I>

   #include "algostuff.hpp"
   using namespace std;
   void printCollection (const list&lt;int&gt;&amp; l)
   {
       PRINT_ELEMENTS(l);
   }

   bool lessForCollection (const list&lt;int&gt;&amp; l1, const list&lt;int&gt;&amp; 12)
   {
      return lexicographical_compare
                  (l1.begin(), l1.end(),    <I>// first range</i>
                   12.begin(), 12.end());   <i>// second range</i>
   }

   int main()
   {
       list&lt;int&gt; c1, c2, c3, c4;

       <i>//fill all collections with the same starting values</i>
       INSERT_ELEMENTS(c1,1,5);
       c4 = c3 = c2 = c1;

       <i>//and now some differences</i>
       c1.push_back(7);
       c3.push_back(2);
       c3.push_back(0);
       c4.push_back(2);

       <i>//create collection of collections</i>
       vector&lt;list&lt;int&gt; &gt; cc;

       cc.push_back(c1);
       cc.push_back(c2);
       cc.push_back(c3);
       cc.push_back(c4);
       cc.push_back(c3);
       cc.push_back(c1);
       cc.push_back(c4);
       cc.push_back(c2);

       <i>//print all collections</i>
       for_each (cc.begin(), cc.end(),
                 printCollection);
       cout &lt;&lt; endl;

       <i>//sort collection lexicographically</i>
       sort (cc.begin(), cc.end(),       <i>//range</i>
             lessForCollection) ;        <i>//sorting criterion</i>

       <i>//print all collections again</i>
       for_each (cc.begin(), cc.end(),
                 printCollection);
   }

					</prE>

					<P>The vector <TT CLaSS="monofont">cc</tT> is initialized with several collections (all lists). The call of <Tt CLASS="monofont">sort()</Tt> uses the binary predicate <tt cLASS="monofont">lessForCollection()</tt> to compare two collections (see page 397 for a description of <tt CLASs="monofont">sort()</tt>). In <tT CLAss="monofont">lessForCollection(),</tt> the <tt class="monofont">lexicographical_compare()</tt> algorithm is used to compare the collections lexicographically. The program has the following output:</p>

					<pre>
						
   1 2 3 4 5 7
   1 2 3 4 5
   1 2 3 4 5 2 0
   1 2 3 4 5 2
   1 2 3 4 5 2 0
   1 2 3 4 5 7
   1 2 3 4 5 2
   1 2 3 4 5

   1 2 3 4 5
   1 2 3 4 5
   1 2 3 4 5 2
   1 2 3 4 5 2
   1 2 3 4 5 2 0
   1 2 3 4 5 2 0
   1 2 3 4 5 7
   1 2 3 4 5 7

					</pre>

				
			
		</fONT>
 
<table width="100%" border="0" cellspacing="0" cellpadding="0" bgcolor="#CCCCCC">
<td><font color="black" size=1>I l<font color="#FF0000">@</font>ve RuBoard</td>
<td valign="top" class="v2" align="right"><a href="0201379260_snode74.html"><img src="FILES/previous.gif" width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a> <a href="0201379260_snode76.html"><img src="FILES/next.gif" width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a></td></table>
</BODY></HTML>