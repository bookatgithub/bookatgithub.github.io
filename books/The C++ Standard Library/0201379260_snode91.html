<HTML><HEAD><META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=iso-8859-1">
<!--SafClassName="docSection1Title"--><!--SafTocEntry="11.2 Description of the String Classes"-->
<LINK REL="stylesheet" href="FILES/sbolM.css">
</HEAD>
<BODY link="#354278" vlink="#000066" alink="#000080" topmargin="0">
<table width="100%" border="0" cellspacing="0" cellpadding="0" bgcolor="#CCCCCC">
<td><font color="black" size=1>I l<font color="#FF0000">@</font>ve RuBoard</td>
<td valign="top" class="v2" align="right"><a href="0201379260_snode90.html"><img src="FILES/previous.gif" width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a> <a href="0201379260_snode92.html"><img src="FILES/next.gif" width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a></td></table>
<FONT><h3>11.2
Description of the String Classes</h3>
			<a nAME="1"></A><h4>11.2.1
String Types</h4>
				<h5>Header File</h5>
					<P>All types and functions for strings are defined in the header file <TT Class="monofont">&lt;string&gt;:</TT></P>

					<Pre>
						
    #include &lt;string&gt;

					</pre>

					<p>As usual, it defines all identifiers in namespace <tt class="monofont">std.</tt></p>

				
				<h5>Template Class <tt clASS="monofont">basic_string&lt;&gt;</TT></H5>
					<p>Inside <TT cLAsS="monofont">&lt;string&gt;,</TT> the type <TT Class="monofont">basic_string&lt;&gt;</TT> is defined as a basic template class for all string types:</P>

					<Pre>
						
    namespace std {
        template&lt;class charT,
                 class traits = char_traits&lt;charT&gt;,
                 class Allocator = allocator&lt;charT&gt; &gt;
        class basic_string;
    }

					</prE>

					<P>It is parameterized by the character type, the traits of the character type, and the memory model:</P>

					<Ul>
<li><p>The first parameter is the data type of a single character.</P>
</LI>
<Li><p>The optional second parameter is a traits class, which provides all core operations for the characters of the string class. Such a traits class specifies how to copy or to compare characters (see <a href="0201379260_snode117.html#2">Section 14.1.2</a>, for details). If it is not specified, the default traits class according to the actual character type is used. See <a href="0201379260_snode91.html#36">Section 11.2.14</a>, for a user-defined traits class that lets strings behave in a case-insensitive manner.</p>
</li>
<li><p>The third optional argument defines the memory model that is used by the string class. As usual, the default value is the default memory model <tT CLASS="monofont">allocator</tT> (see <A href="0201379260_snode21.html">Section 3.4</A>, and <A href="0201379260_cnode121.html">Chapter 15</a> for details).<fonT SIZe="1"><sup><A HREf="#FOOTNOTE-3">[3]</a></suP></FONt>
</p>
<blockquote><font size="1">
<p CLASS="footnote">
<SuP><A nAMe="FOOTNOTE-3">[3]</A></SUP>
In systems that do not support default template parameters, the third argument is usually missing.</P>
</Font></bLOCKquotE>

								
						</LI>
</Ul>
				
				<h5>Types <tt CLASs="monofont">string</tt> and <tt class="monofont">wstring</tt></h5>
					<p>Two specializations of class <tt class="monofont">basic_string&lt;&gt;</TT> are provided by the C++ standard library:</P>

					<OL TyPE="1" sTArT="restarts">
<LI><P><TT clasS="monofont">string</TT> is the predefined specialization of that template for characters of type <Tt claSS="monofont">char:</TT></p>

							<pre>
								
        namespace std {
            typedef basic_string&lt;char&gt; string;

        }

							</PRE>

						</Li>
<li><p><tt class="monofont">wstring</tt> is the predefined specialization of that template for characters of type <tt class="monofont">wchar_t:</tT></P>

							<PRE>
								
        namespace std {
            typedef basic_string&lt;wchar_t&gt; wstring;

        }

							</PrE>

							<P>Thus, you can use strings that use wider character sets, such as Unicode or some Asian character sets (see <a href="0201379260_cnode115.html">Chapter 14</A> for details about internationalization).</P>

						</LI>
</Ol>

					<p>In the following sections no distinction is made between these different kinds of strings. The usage and the problems are the same because all string classes have the same interface. So, "string" means any string type, such as <tt CLASs="monofont">string</tt> and <tT CLAss="monofont">wstring.</tt> The examples in this book usually use type <TT CLass="monofont">string</tt> because the European and Anglo-American environment is the common environment for software development.</p>

				
			
			<h4>11.2.2
Operation Overview</h4>
				<p><a href="0201379260_snode91.html#7">Table 11.1</a> lists all operations that are provided for strings.</p>

				<a name="7"></A><P><TABLe BOrDEr="1" CELLSPacinG="0" CELlpadDING="1" widtH="100%">
<CAPtion><h5>Table 11.1. String Operation</h5></caption><colgroup ALIGN="left" SpAN="2">
<tR>
<Th VALIGN="top">
<font SIZE="2"><b>Operation</b>
								</foNT></TH>
<th vaLIGN="top">
<font size="2"><b>Effect</b>
								</font></th>
</tr>
<tr>
<tD VALIGn="top">
<FOnT SiZE="2"><I>constructors</I>
								</FOnt></td>
<TD VAlign="top">
<FONT size="2">Create or copy a string</FONT></td>
</tr>
<tr>
<td valign="top">
<font sizE="2"><I>destructor</I>
								</FONt></TD>
<tD VaLIGN="top">
<FOnt siZE="2">Destroys a string</FOnt></td>
</TR>
<TR>
<td vaLIGN="top">
<font size="2"><tt class="monofont">=, assign()</tt>
								</font></TD>
<TD VAlIGn="top">
<FOnT SIZE="2">Assign a new value</Font></tD>
</TR>
<Tr>
<td vALIGn="top">
<fonT SIZe="2"><tt class="monofont">swap()</tt>
								</font></td>
<td valIGN="top">
<FONt SIzE="2">Swaps values between two strings</FoNT></TD>
</TR>
<tr>
<td VALIgn="top">
<foNT SIze="2"><tt CLASs="monofont">+=, append(), push_back()</tt>
								</font></td>
<td valign="top">
<font SIZE="2">Append characters</FOnT></Td>
</TR>
<tR>
<TD VALign="top">
<fONT Size="2"><tT CLAss="monofont">insert()</tt>
								</FONT></td>
<td valign="top">
<font size="2">Inserts characters</fonT></TD>
</TR>
<Tr>
<TD vALiGN="top">
<FONT size="2"><TT CLass="monofont">erase()</tT>
								</FONt></td>
<tD VALign="top">
<font size="2">Deletes characters</font></td>
</tr>
<tr>
<TD VALIgN="top">
<FoNT sIZE="2"><TT Class="monofont">clear()</TT>
								</FOnt></td>
<TD VAlign="top">
<FONT size="2">Removes all characters (makes it empty)</font></td>
</tr>
<tr>
<td valigN="top">
<FONT SiZE="2"><tT ClASS="monofont">resize()</TT>
								</Font></tD>
<TD ValigN="top">
<FONt sizE="2">Changes the number of characters (deletes or appends characters at the end)</FONt></td>
</tr>
<tr>
<td valign="top">
<font siZE="2"><TT CLaSS="monofont">replace()</tT>
								</FoNT></TD>
<TD valiGN="top">
<FOnt siZE="2">Replaces characters</FOnt></td>
</TR>
<TR>
<td valign="top">
<font size="2"><tt claSS="monofont">+</TT>
								</FOnT></Td>
<TD vALIGN="top">
<Font sIZE="2">Concatenates strings</Font></tD>
</TR>
<Tr>
<td vALIGn="top">
<font size="2"><tt class="monofont">==, !=, &lt;, &lt;=, &gt;, &gt;=, compare()</tt>
								</fonT></TD>
<TD VaLIgN="top">
<FoNT SIZE="2">Compare strings</font></TD>
</TR>
<tr>
<td VALIgn="top">
<foNT SIze="2"><tt class="monofont">size(), length()</tt>
								</font></td>
<td vaLIGN="top">
<FOnT SiZE="2">Return the number of characters</fONT></TD>
</Tr>
<tr>
<tD VALign="top">
<fONT Size="2"><tT CLAss="monofont">max_size()</tt>
								</font></td>
<td valign="top">
<fonT SIZE="2">Returns the maximum possible number of characters</FoNT></tD>
</Tr>
<TR>
<TD VAlign="top">
<FONT size="2"><TT CLass="monofont">empty()</tT>
								</FONt></td>
<td valign="top">
<font size="2">Returns whether the string is empty</foNT></TD>
</TR>
<tR>
<Td VAlIGN="top">
<FONt sizE="2"><TT Class="monofont">capacity()</TT>
								</FOnt></td>
<TD VAlign="top">
<font size="2">Returns the number of characters that can held without be reallocation</font></td>
</tr>
<tR>
<TD VALiGN="top">
<fONt SIZE="2"><TT clasS="monofont">[], at()</TT>
								</Font></tD>
<TD ValigN="top">
<FONt size="2">Access a character</font></td>
</tr>
<tr>
<td valiGN="top">
<FONT sIZe="2"><TT cLASS="monofont">&gt;&gt;, getline()</TT>
								</font></TD>
<TD valiGN="top">
<FOnt siZE="2">Read the value from a stream</FOnt></td>
</tr>
<tr>
<td valign="top">
<font sIZE="2"><TT ClASs="monofont">&lt;&lt;</TT>
								</fONT></TD>
<Td valIGN="top">
<Font sIZE="2">Writes the value to a stream</Font></tD>
</TR>
<Tr>
<td valign="top">
<font size="2"><tt clASS="monofont">copy()</TT>
								</FoNT></tD>
<Td VALIGN="top">
<font SIZE="2">Copies or writes the contents to a C-string</font></TD>
</TR>
<tr>
<td VALIgn="top">
<font size="2"><tt class="monofont">c_str()</tt>
								</foNT></TD>
<TD vALiGN="top">
<fONT SIZe="2">Returns the value as C-string</fonT></TD>
</Tr>
<tr>
<tD VALign="top">
<fONT Size="2"><tt class="monofont">data()</tt>
								</font></td>
<td vALIGN="top">
<FoNT sIZe="2">Returns the value as character array</FONT></TD>
</tr>
<tr>
<TD VAlign="top">
<FONT size="2"><TT CLass="monofont">substr()</tt>
								</font></td>
<td valign="top">
<foNT SIZE="2">Returns a certain substring</fONt></TD>
</tR>
<TR>
<TD ValigN="top">
<FONt sizE="2"><I>find functions</I>
								</Font></tD>
<TD Valign="top">
<font size="2">Search for a certain substring or character</font></td>
</tr>
<TR>
<TD VAlIGn="top">
<FOnT SIZE="2"><Tt claSS="monofont">begin(), end()</TT>
								</font></TD>
<TD valiGN="top">
<FOnt size="2">Provide normal iterator support</font></td>
</tr>
<tr>
<td valIGN="top">
<FONt SIzE="2"><Tt CLASS="monofont">rbegin(), rend()</Tt>
								</fonT></TD>
<Td valIGN="top">
<Font sIZE="2">Provide reverse iterator support</Font></td>
</tr>
<tr>
<td valign="top">
<font SIZE="2"><TT cLAsS="monofont">get_allocator()</Tt>
								</FONT></TD>
<td vaLIGN="top">
<font SIZE="2">Returns the allocator</font></TD>
</TR>
</colgroup>
</table></p>

				<h5>String Operation Arguments</h5>
					<p>Many operations are provided to manipulate strings. In particular, the operations that manipulate the value of a string have several overloaded versions that specify the new value with one, two, or three arguments. All these operations use the argument scheme of <a href="0201379260_snode91.html#9">Table 11.2</A>.</P>

					<A NAmE="9"></A><p><TAbLE BORDer="1" ceLLSPacinG="0" CELlpadDING="1" width="100%">
<caption><h5>Table 11.2. Scheme of String Operation Arguments</h5></caption><COLGROuP AlIGn="left" SPAN="2">
<TR>
<th vaLIGN="top">
<font SIZE="2"><b>Arguments</b>
									</foNT></TH>
<th valign="top">
<font size="2"><b>Interpretation</b>
									</fonT></TH>
</TR>
<Tr>
<TD vALiGN="top">
<FONT size="2"><TT CLass="monofont">const</tT>
										<I><TT clasS="monofont">string &amp;</TT></I>
										<i>str</i>
									</font></td>
<td valign="top">
<font sIZE="2">The whole string <I>str</I>
									</FoNT></tD>
</Tr>
<TR>
<TD VAlign="top">
<FONT size="2"><TT CLass="monofont">const</tT>
										<I><TT class="monofont">string &amp;</tt></i>
										<i>str,</i>
										<tt class="monofont">size_type</tt>
										<i>idx,</i> size_type <I>num</I>
									</FONT></tD>
<Td VAlIGN="top">
<FONt sizE="2">At most, the first <I>num</I> characters of <I>str</i> starting with index <i>idx</i>
									</fONT></Td>
</tr>
<tR>
<TD Valign="top">
<font size="2"><tt class="monofont">const</tT>
										<I><TT CLaSS="monofont">char*</tT></I>
										<i>cstr</I>
									</FONT></Td>
<td vALIGn="top">
<fonT SIZe="2">The whole C-string <i>cstr</i>
									</fONT></Td>
</tr>
<tr>
<td valign="top">
<font size="2"><TT CLASs="monofont">const</TT>
										<i><TT cLASS="monofont">char*</TT></i>
										<i>chars,</i>
										<tT CLAss="monofont">size_type</tt><I> len</I>
									</FOnt></td>
<TD VAlign="top">
<font size="2"><i>len</i> characters of the character array <i>chars</i>
									</font></tD>
</TR>
<TR>
<Td VAlIGn="top">
<FONT SIze="2"><i><tT CLAss="monofont">char</tt></I>
										<I>c</I>
									</Font></tD>
<TD Valign="top">
<font size="2">The character <i>c</i>
									</font></td>
</TR>
<TR>
<TD vALiGN="top">
<fONT SIZe="2"><tt cLASS="monofont">size_type</tt>
										<i>num,</i>
										<I><TT Class="monofont">char</TT></I>
										<I>c</i>
									</font></td>
<td valign="top">
<font siZE="2"><I>num</I> occurrences of the character <I>c</I>
									</fONt></TD>
</tR>
<TR>
<TD ValigN="top">
<FONt sizE="2"><TT Class="monofont">iterator</TT><I> beg,</I>
										<tt class="monofont">iterator</tt>
										<i>end</i>
									</font></td>
<td vaLIGN="top">
<FOnT SiZE="2">All characters in the range [<i>beg,end</I><TT CLAss="monofont">)</tt>
									</FONT></td>
</tr>
</COLGroup>
</TABLe></p>

					<p>Note that only the single-argument version <tt class="monofont">char*</tt> handles the character <tt class="monofont">'\0'</tt> as a special character that terminates the string. In all other cases <TT CLASs="monofont">'\0'</TT> is <i>not</I> a special character:</P>

					<pRE>
						
    std::string s1("nico");      <I>  //initializes</I> s1 <I>with:</I> 'n' 'i' 'c' 'o'
    std::string s2("nico",5) ;   <i>  //initializes</i> s2<i> with:</i> 'n' 'i' 'c' 'o' '\0'
    std::string s3(5,'\0');       <I> //initializes</I> s3 <I>with:</I> '\0' '\0' '\0' '\0' '\0'

    s1.length()                   <i>  //yields</i> 4
    s2.length()                   <i>  //yields</i> 5
    s3.length()                   <I>  //yields</I> 5

					</PRe>

					<p>Thus, in general a string might contain any character. In particular, a string might contain the contents of a binary file.</p>

					<p>See <A href="0201379260_snode91.html#11">Table 11.3</a> for an overview of which operation uses which kind of arguments. All operators can only handle objects as single values. Therefore, to assign, compare, or append a part of a string or C-string, you must use the function that has the corresponding name.</p>

				
				<h5>Operations that Are Not Provided</h5>
					<p>The string classes of the C++ standard library do not solve every possible string problem. In fact, they do not provide direct solutions for</p>

					<ul>
<li><p>Regular expressions</p>
</li>
<li><p>Word processing (capitalization, case-insensitive comparisons)</p>

						</li>
</UL>
					<P>Word processing, however, is not a big problem. See <A href="0201379260_snode91.html#31">Section 11.2.13</A>,  for some examples.</p>

					<A NaME="11"></A><P><TAble bORDEr="1" celLSPAcing="0" CELLpadding="1" width="100%">
<caption><h5>Table 11.3. Available Operations that Have String Parameters</h5></CAPTIOn><COlGRoUP ALIGn="left" spaN="8">
<TR>
<Th valIGN="top">
<Font sIZE="2"> </Font></th>
<th valign="top">
<font size="2"><B>Full String</B>
									</FONT></tH>
<Th VAlIGN="top">
<FONt sizE="2"><B>Part of String</B>
									</Font></tH>
<TH ValigN="top">
<FONt size="2"><b>C-string</b>
										<b><i>(char*)</i></b>
									</font></th>
<th vaLIGN="top">
<FOnT SiZE="2"><b><I>char</I></B>
										<B>Array</B>
									</Font></tH>
<TH ValigN="top">
<FONt sizE="2"><B>Single</B>
										<B><i>char</i></b>
									</font></th>
<th valign="top">
<font SIZE="2"><B><I>num chars</i></B>
									</FoNT></tH>
<TH VALign="top">
<fONT Size="2"><b>Iterator Range</B>
									</FONt></th>
</tR>
<TR>
<Td valign="top">
<font size="2"><i>constructors</i></font></TD>
<TD VAlIGn="top">
<FOnT SIZE="2">Yes</Font></tD>
<TD ValigN="top">
<FONt sizE="2">Yes</FONt></td>
<td valign="top">
<font size="2">Yes</foNT></TD>
<TD vALiGN="top">
<fONT SIZe="2">Yes</fonT></TD>
<Td valIGN="top">
<Font sIZE="2">—</Font></td>
<td valign="top">
<font size="2">Yes</FONT></TD>
<tD VaLIgN="top">
<FONT Size="2">Yes</fONT></Td>
</tr>
<tR>
<TD ValigN="top">
<FONt size="2"><tt class="monofont">=</tt></font></td>
<tD VALIGn="top">
<FOnT SiZE="2">Yes</FONT></td>
<td VALIgn="top">
<foNT SIze="2">—</foNT></TD>
<td valign="top">
<font size="2">Yes</font></tD>
<TD VALiGN="top">
<fONt SIZE="2">—</FOnt></td>
<TD VAlign="top">
<FONT size="2">Yes</FONT></td>
<td valign="top">
<font size="2">—</fonT></TD>
<TD VaLIgN="top">
<FoNT SIZE="2">—</font></TD>
</TR>
<tr>
<td VALIgn="top">
<foNT SIze="2"><tt class="monofont">assign()</tt>
									</font></td>
<td vaLIGN="top">
<FOnT SiZE="2">Yes</fONT></TD>
<Td valIGN="top">
<Font sIZE="2">Yes</Font></tD>
<TD Valign="top">
<font size="2">Yes</font></td>
<td VALIGN="top">
<fONt SIzE="2">Yes</FONT></Td>
<td vALIGn="top">
<fonT SIZe="2">—</fonT></TD>
<Td valign="top">
<font size="2">Yes</font></td>
<TD VALIgN="top">
<FoNT sIZE="2">Yes</FONt></td>
</tR>
<TR>
<Td valIGN="top">
<Font sIZE="2"><Tt class="monofont">+=</tt>
									</font></td>
<td valigN="top">
<FONT SiZE="2">Yes</fONt></TD>
<TD VAlign="top">
<FONT size="2">—</FONT></td>
<td VALIgn="top">
<font size="2">Yes</font></td>
<td valIGN="top">
<FONt SIzE="2">—</FoNT></TD>
<TD valiGN="top">
<FOnt siZE="2">Yes</FOnt></td>
<TD VAlign="top">
<font size="2">—</font></td>
<td vALIGN="top">
<FoNT sIZe="2">—</FONT></TD>
</tr>
<tr>
<TD VAlign="top">
<FONT size="2"><TT CLass="monofont">append( )</tt>
									</font></td>
<td valign="top">
<foNT SIZE="2">Yes</fONt></TD>
<tD VALIGn="top">
<fonT SIZe="2">Yes</fonT></TD>
<Td valIGN="top">
<Font size="2">Yes</font></td>
<td valign="top">
<FONT SIzE="2">Yes</FoNT></tD>
<TD VALign="top">
<fONT Size="2">—</fONT></Td>
<td vALIGn="top">
<font size="2">Yes</font></td>
<td valiGN="top">
<FONT sIZe="2">Yes</FOnT></TD>
</TR>
<Tr>
<td vALIGn="top">
<fonT SIZe="2"><tt cLASS="monofont">push_back()</tt>
									</font></td>
<td valign="top">
<font sIZE="2">—</FONt></TD>
<tD VaLIGN="top">
<FOnt siZE="2">—</FOnt></td>
<TD VAlign="top">
<FONT size="2">—</font></td>
<td valign="top">
<fonT SIZE="2">—</FoNT></tD>
<Td VALIGN="top">
<font SIZE="2">Yes</font></TD>
<TD valiGN="top">
<FOnt size="2">—</font></td>
<td valign="top">
<fONT SIZe="2">—</FOnT></Td>
</TR>
<TR>
<TD valiGN="top">
<FOnt siZE="2"><TT clasS="monofont">insert(),</TT> index version
</Font></td>
<td valign="top">
<font size="2">Yes</FONT></TD>
<tD VaLIgN="top">
<FONT Size="2">Yes</fONT></Td>
<td vALIGn="top">
<fonT SIZe="2">Yes</font></td>
<td valign="top">
<font siZE="2">Yes</FONT></tD>
<Td VAlIGN="top">
<FONt sizE="2">—</FONt></td>
<tD VALign="top">
<fONT Size="2">Yes</font></td>
<td valign="top">
<font SIZE="2">—</FOnT></Td>
</TR>
<tR>
<TD VALign="top">
<fONT Size="2"><tT CLAss="monofont">insert(),</tt> iterator version
</FONT></td>
<td valign="top">
<font size="2">—</fonT></TD>
<TD VaLIgN="top">
<FoNT SIZE="2">—</font></TD>
<TD valiGN="top">
<FOnt siZE="2">—</FOnt></td>
<td valign="top">
<font size="2">—</fONT></TD>
<Td VAlIGn="top">
<FONT SIze="2">Yes</foNT></TD>
<td vaLIGN="top">
<font SIZE="2">Yes</font></td>
<td valign="top">
<font sizE="2">Yes</FONT></Td>
</TR>
<tR>
<Td VALIGN="top">
<font SIZE="2"><tt clASS="monofont">replace(),</Tt> index version
</fonT></TD>
<Td valign="top">
<font size="2">Yes</font></td>
<TD VALIgN="top">
<FoNT sIZE="2">Yes</FONt></td>
<tD VALign="top">
<fONT Size="2">Yes</fONT></Td>
<td valign="top">
<font size="2">Yes</font></TD>
<TD VAlIGn="top">
<FOnT SIZE="2">Yes</Font></tD>
<TD ValigN="top">
<FONt sizE="2">Yes</FONt></td>
<td valign="top">
<font size="2">—</foNT></TD>
</TR>
<tR>
<Td VAlIGN="top">
<FONt sizE="2"><TT Class="monofont">replace(),</TT> iterator vers.
</FOnt></td>
<TD VAlign="top">
<font size="2">Yes</font></td>
<td vALIGN="top">
<FoNT sIZe="2">—</FONT></TD>
<td vaLIGN="top">
<font SIZE="2">Yes</font></TD>
<TD valign="top">
<font size="2">Yes</font></td>
<tD VALIGn="top">
<FOnT SiZE="2">—</FONT></td>
<td VALIgn="top">
<foNT SIze="2">Yes</foNT></TD>
<td valign="top">
<font size="2">—</font></tD>
</TR>
<TR>
<Td VAlIGn="top">
<FONT SIze="2"><i>find functions</i>
									</FONT></td>
<td VALIgn="top">
<foNT SIze="2">Yes</font></td>
<td valign="top">
<font sIZE="2">—</FONt></TD>
<tD VaLIGN="top">
<FOnt siZE="2">Yes</FOnt></td>
<TD VAlign="top">
<FONT size="2">Yes</font></td>
<td valign="top">
<fonT SIZE="2">Yes</FoNT></tD>
<Td VALIGN="top">
<font SIZE="2">—</font></TD>
<TD valiGN="top">
<FOnt size="2">—</font></td>
</tr>
<tr>
<td valIGN="top">
<FONt SIzE="2"><Tt CLASS="monofont">+</Tt>
									</fonT></TD>
<Td valIGN="top">
<Font sIZE="2">Yes</Font></td>
<td valign="top">
<font size="2">—</FONT></TD>
<tD VaLIgN="top">
<FONT Size="2">Yes</fONT></Td>
<td vALIGn="top">
<fonT SIZe="2">—</font></td>
<td valign="top">
<font siZE="2">Yes</FONT></tD>
<Td VAlIGN="top">
<FONt sizE="2">—</FONt></td>
<tD VALign="top">
<fONT Size="2">—</font></td>
</tr>
<tr>
<td valign="top">
<FONT SIzE="2"><Tt CLaSS="monofont">==, !=, &lt;, &lt;=, &gt;, &gt;=</TT>
									</FOnt></td>
<TD VAlign="top">
<FONT size="2">Yes</FONT></td>
<td valign="top">
<font size="2">—</fonT></TD>
<TD VaLIgN="top">
<FoNT SIZE="2">Yes</font></TD>
<TD valiGN="top">
<FOnt siZE="2">—</FOnt></td>
<td valign="top">
<font size="2">—</fONT></TD>
<Td VAlIGn="top">
<FONT SIze="2">—</foNT></TD>
<td vaLIGN="top">
<font SIZE="2">—</font></td>
</tr>
<tr>
<td valign="top">
<fonT SIZE="2"><Tt CLaSS="monofont">compare()</tT>
									</FONT></Td>
<td vALIGn="top">
<fonT SIZe="2">Yes</fonT></TD>
<Td valign="top">
<font size="2">Yes</font></td>
<TD VALIgN="top">
<FoNT sIZE="2">Yes</FONt></td>
<tD VALign="top">
<fONT Size="2">Yes</fONT></Td>
<td valign="top">
<font size="2">—</font></TD>
<TD VAlIGn="top">
<FOnT SIZE="2">—</Font></tD>
<TD ValigN="top">
<FONt sizE="2">—</FONt></td>
</tr>
</colgroup>
</table></p>

				
			
			<h4>11.2.3
Constructors and Destructors</h4>
				<P><A href="0201379260_snode91.html#13">Table 11.4</a> lists all constructors and destructors for strings. These are described in this section. The initialization by a range that is specified by iterators is described in <A href="0201379260_snode91.html#31">Section 11.2.13</a>.</P>

				<A NAME="13"></a><p><taBLE BordeR="1" CELlspaCING="0" cellpadding="1" width="100%">
<captiON><H5>Table 11.4. Constructors and Destructor of Strings</H5></CApTIoN><CoLGROUP aligN="left" SPAn="2">
<tr>
<tH VALign="top">
<fONT Size="2"><b>Expression</b>
								</font></th>
<th valign="top">
<foNT SIZE="2"><b>Effect</B>
								</FoNT></tH>
</TR>
<TR>
<Td valIGN="top">
<Font sIZE="2"><Tt claSS="monofont">string s</TT>
								</font></td>
<td valign="top">
<font sizE="2">Creates the empty string <TT CLAsS="monofont">s</Tt>
								</FOnT></TD>
</TR>
<Tr>
<td vALIGn="top">
<fonT SIZe="2"><tt cLASS="monofont">string s(str)</tt>
								</font></td>
<td valign="top">
<font sIZE="2">Creates a string as a copy of the existing string <TT ClASs="monofont">str</TT>
								</fONT></TD>
</Tr>
<tr>
<tD VALign="top">
<fONT Size="2"><tT CLAss="monofont">string s (str, stridx)</tt>
								</font></td>
<td valign="top">
<fonT SIZE="2">Creates a string <Tt CLaSS="monofont">s</tT> that is initialized by the characters of string <TT CLAss="monofont">str</tt> starting with index <TT CLass="monofont">stridx</tT>
								</FONt></td>
</tR>
<TR>
<Td valign="top">
<font size="2"><tt clasS="monofont">string s(str, stridx, strlen)</TT>
								</FONt></TD>
<tD VaLIGN="top">
<FOnt siZE="2">Creates a string <TT clasS="monofont">s</TT> that is initialized by, at most, <Tt claSS="monofont">strlen</TT> characters of string <tt class="monofont">str</tt> starting with index <tt class="monofont">stridx</tt>
								</fonT></TD>
</TR>
<Tr>
<TD vALiGN="top">
<FONT size="2"><TT CLass="monofont">string s(cstr)</tT>
								</FONt></td>
<tD VALign="top">
<font size="2">Creates a string <tt class="monofont">s</tt> that is initialized by the C-string <tT CLASS="monofont">cstr</tT>
								</FoNT></tD>
</TR>
<TR>
<Td valIGN="top">
<Font sIZE="2"><Tt claSS="monofont">string s (chars, chars_len)</TT>
								</font></td>
<td valign="top">
<font sizE="2">Creates a string <TT CLAsS="monofont">s</Tt> that is initialized by <TT cLASS="monofont">chars_len</TT> characters of the character array <tt clASS="monofont">chars</Tt>
								</fonT></TD>
</Tr>
<tr>
<tD VALign="top">
<font size="2"><tt class="monofont">string s(num,c)</tt>
								</fONT></TD>
<Td VAlIGn="top">
<FONT SIze="2">Creates a string that has <tt CLASs="monofont">num</tt> occurrences of character <tT CLAss="monofont">c</tt>
								</FONT></td>
</tr>
<tr>
<td valign="top">
<font sizE="2"><TT CLAsS="monofont">string s (beg, end)</Tt>
								</FOnT></TD>
<TD ValigN="top">
<FONt sizE="2">Creates a string that is initialized by all characters of the range [<TT Class="monofont">beg, end</TT>)
</FOnt></td>
</tr>
<tr>
<td valign="top">
<font sIZE="2"><TT ClASs="monofont">s.~string()</TT>
								</fONT></TD>
<Td valIGN="top">
<Font sIZE="2">Destroys all characters and frees the memory</Font></tD>
</TR>
</Colgroup>
</table></p>

				<p>You can't initialize a string with a single character. Instead, you must use its address or an additional number of occurrences:</p>

				<pre>
					
    std:: string s('x');      //<i>ERROR</i>
    std:: string s(1, 'x');   //<i>OK, creates a string that has one character</I> 'x'

				</PRE>

				<P>This means that there is an automatic type conversion from type <Tt CLaSS="monofont">const char*</tT> but not from type <TT CLAss="monofont">char</tt> to type <TT CLass="monofont">string.</tT></P>

			
			<H4>11.2.4
Strings and C-Strings</H4>
				<p>In standard C++ the type of string literals was changed from <tt cLASS="monofont">char*</tt> to <tt class="monofont">const char*.</tt> However, to provide backward compatibility there is an implicit but deprecated conversion to <tt class="monofont">char*</tt> for them. However, because string literals don't have type <tT CLASS="monofont">string,</tT> there is a strong relationship between "new" string class objects and ordinary C-strings: You can use ordinary C-strings in almost every situation where strings are combined with other string-like objects (comparing, appending, inserting, etc.). In particular, there is an automatic type conversion from <Tt CLaSS="monofont">const char*</TT> into strings. However, there is <I>no</I> automatic type conversion from a string object to a C-string. This is for safety reasons to prevent unintended type conversions that result in strange behavior (type <tt clASS="monofont">char*</Tt> often has strange behavior) and ambiguities (for example, in an expression that combines a <tt cLASS="monofont">string</tt> and a C-string it would be possible to convert <tt CLASs="monofont">string</tt> into <tt class="monofont">char*</tt> and vice versa). Instead, there are several ways to create or write/copy in a C-string, In particular, <tt class="monofont">c_str()</tt> is provided to generate the value of a string as a C-string (as a character array that has <TT CLASs="monofont">'\0'</TT> as its last character). By using <tT ClASS="monofont">copy(),</TT> you can copy or write the value to an existing C-string or character array.</P>

				<p>Note that strings do <i>not</i> provide a special meaning for the character <tT CLAss="monofont">'\0',</tt> which is used as special character in an ordinary C-string to mark the end of the string. The character <TT CLass="monofont">'\0'</tT> may be part of a string just like every other character.</P>

				<P>Note also that you must not use a null pointer <Tt class="monofont">(NULL)</tt> instead of a <tt class="monofont">char*</tt> parameter. Doing so results in strange behavior. This is because <tt clASS="monofont">NULL</TT> has an integral type and is interpreted as the number zero or the character with value <Tt CLaSS="monofont">0</tT> if the operation is overloaded for a single integral type.</P>

				<P>There are three possible ways to convert the contents of the string into a raw array of characters or C-string:</P>

				<OL type="1" STARt="restarts">
<li><p><B><TT Class="monofont">data()</TT></B></P>

						<p>Returns the contents of the string as an array of characters. Note that the return type is <i>not</i> a valid C-string because no <tt class="monofont">'\0'</tt> character gets appended.</p>
</li>
<li><p><b><tt CLASS="monofont">c_str()</Tt></B></P>

						<p>Returns the contents of the string as a C-string. Thus, the <TT cLASS="monofont">'\0'</TT> character is appended.</p>
</li>
<lI><P><B><Tt claSS="monofont">copy()</TT></b></p>

						<p>Copies the contents of the string into a character array provided by the caller. An <tT CLAss="monofont">'\0'</tt> character is not appended.</p>

					</li>
</ol>

				<p>Note that <tt class="monofont">data()</tt> and <tt CLASS="monofont">c_str()</Tt> return an array that is owned by the string. Thus, the caller must not modify or free the memory. For example:</P>

				<PrE>
					
    std::string s("12345");


    atoi(s.c_str())               //<I>convert string into integer</i>
    f(s.data(), s.length())       //<I>call function for a character array</I>
                                  //<I>and the number of characters</I>


    char buffer [100];
    s.copy (buffer, 100) ;        //<I>copy at most</I> 100 <i>characters of</i> s<i> into</i> buffer
    s.copy (buffer, 100,2) ;      //<I>copy at most</I> 100 <I>characters of</I> s<i> into</i> buffer
                                  //<i>starting with the third character of</i> s

				</PRE>

				<P>You usually should use strings in the whole program and convert them into C-strings or character arrays only just immediately before you need the contents as type <tt clASS="monofont">char*.</Tt> Note that the return value of <tt class="monofont">c_str()</tt> and <tt class="monofont">data()</tt> is valid only until the next call of a nonconstant member function for the same string:</p>

				<pRE>
					
    std::string s;

    ...
    foo (s . c_str());     //s.c_str() <I>is valid during the whole statement</I>


    const char* p;
    p = s.c_str() ;        //p<I> refers to the contents of</I> s<i> as a C-string</I>
    foo (p);               //<I>OK</i>(p<I> is still valid</I>)
    s += " ext" ;          //<i>invalidates</I> p
    foo (p);              //<I>ERROR: argument</I> p <I>is not valid</I>

				</Pre>

			
			<a nAME="15"></A><h4>11.2.5
Size and Capacity</h4>
				<p>To use strings effectively and correctly you need to understand how the size and capacity of strings cooperate. For strings, three "sizes" exist:</p>

				<OL TYpe="1" stART="restarts">
<Li><p><b><tt class="monofont">size()</tt></b> and <b><tt class="monofont">length()</TT></B></P>

						<P>Return the actual number of characters of the string. Both functions are equivalent.<FoNT sIZe="1"><SUP><A HRef="#FOOTNOTE-4">[4]</a></sUP></FOnt>
</p>
<bLOCKquotE><FONt size="1">
<p class="footnote">
<sup><a name="FOOTNOTE-4">[4]</a></sUP>
In this case, two member functions do the same thing because <TT CLaSS="monofont">length()</tT> returns the length of the string, as <Tt CLASS="monofont">strlen()</Tt> does for ordinary C-strings, whereas <tt cLASS="monofont">size()</tt> is the common member function for the number of elements according to the concept of the STL.</p>
</fONT></BlockQUOTe>

							
						<p>The <b><tt class="monofont">empty()</tt></b> member function is a shortcut for checking whether the numbers of characters is zero. Thus, it checks whether the string is empty. You should use it instead of <tt class="monofont">length()</tT> or <TT CLAsS="monofont">size()</Tt> because it might be faster.</P>
</Li>
<LI><P><B><TT clasS="monofont">max_size()</TT></B></p>

						<p>Returns the maximum number of characters that a string may contain. A string typically contains all characters in a single block of memory, so there might be relevant restrictions on PCs. Otherwise, this value usually is the maximum value of the type of the index less one. It is "less one" for two reasons: (a) The maximum value itself is <tt CLASs="monofont">npos</tt> and (b) an implementation might append <tT CLAss="monofont">'\0'</tt> internally at the end of the internal buffer so that it simply returns that buffer when the string is used as a C-string (for example, by <tt class="monofont">c_str()</tt>). Whenever an operation results in a siring that has a length greater than <tt class="monofont">max_size(),</tT> the class throws <TT CLAsS="monofont">length_error.</Tt></P>
</Li>
<LI><P><B><TT clasS="monofont">capacity()</TT></B></p>

						<p>Returns the number of characters that a string could contain without having to reallocate its internal memory.</p>

					</lI>
</OL>

				<P>Having sufficient capacity is important for two reasons:</p>

				<ol tYPE="1" Start="restarts">
<li><p>Reallocation invalidates all references, pointers, and iterators that refer to characters of the string.</p>
</li>
<li><p>Reallocation takes time.</p>

					</li>
</ol>

				<p>Thus, the capacity must be taken into account if a program uses pointers, references, or iterators that refer to a string or to characters of a string, or if speed is a goal.</p>

				<p>The member function <TT CLASs="monofont">reserve()</TT> is provided to avoid reallocations. <tT ClASS="monofont">reserve()</TT> lets you reserve a certain capacity before you really need it to ensure that references are valid as long as the capacity is not exceeded:</P>

				<pre>
					
    std::string s;      //<i>create empty string</I>
    s.reserve(80);      //<I>reserve memory for 80 characters</I>

				</Pre>

				<p>The concept of capacity for strings is, in principle, the same as for vector containers (see <a href="0201379260_snode49.html#4">Section 6.2.1</a>); however, there is one big difference: Unlike vectors, you can call <tt cLASS="monofont">reserve()</tt> for strings to shrink the capacity. Calling <tt class="monofont">reserve()</tt> with an argument that is less than the current capacity is, in effect, a nonbinding shrink request. If the argument is less than the current number of characters, it is a nonbinding shrink-to-fit request. Thus, although you might <i>want</i> to shrink the capacity, it is not guaranteed to happen. The default value of <tt class="monofont">reserve()</tT> for string is <TT CLAsS="monofont">0.</Tt> So, a call of <TT cLASS="monofont">reserve()</TT> without any argument is always a nonbinding shrink-to-fit request:</p>

				<pre>
					
    s.reserve()  ;      //"<I>would like to shrink capacity to fit the current size</I>"

				</PRe>

				<p>The call to shrink capacity is nonbinding because how to reach an optimal performance is implementation-defined. Implementations of the string class might have different design approaches with respect to speed and memory usage. Therefore, implementations might increase capacity in larger steps and might never shrink the capacity.</p>

				<p>The standard, however, specifies that capacity may shrink only because of a call of <TT CLass="monofont">reserve().</tT> Thus, it is guaranteed that references, pointers, and iterators remain valid even when characters are deleted or changed, provided they refer to characters that have a position that is before the manipulated characters.</P>

			
			<A Name="17"></a><h4>11.2.6
Element Access</h4>
				<p>A string allows you to have read or write access to the characters it contains. You can access a single character via either of two methods: the subscript operator <tt class="monofont">[]</tt> and the <tt claSS="monofont">at()</TT> member function. Both return the character at the position of the passed index. As usual, the first character has index 0 and the last character has index <TT cLAsS="monofont">length()-1.</Tt> However, note the following differences:</P>

				<UL>
<LI><P>Operator <tt clASS="monofont">[]</Tt> does <i>not</i> check whether the index passed as an argument is valid; <tT CLAss="monofont">at()</tt> does. If <TT CLass="monofont">at()</tt> is called with an invalid index, it throws an <tt class="monofont">out_of_range</tt> exception. If operator <tt class="monofont">[]</TT> is called with an invalid index, the behavior is undefined. The effect might be an illegal memory access that might then cause some nasty side effects or a crash (you're lucky if the result is a crash, because then you know that you did something wrong).</P>
</LI>
<Li><P>For the <I>constant</i> version of operator <TT cLASS="monofont">[],</TT> the position after the last character is valid. In this case, the actual number of characters is a valid index. The operator returns the value that is generated by the default constructor of the character type. Thus, for objects of type <tt clASS="monofont">string</Tt> it returns the <tt cLASS="monofont">char '\0'.</tt></p>

						<p>In all other cases (for the nonconstant version of operator <TT CLass="monofont">[]</tt> and for the <tt class="monofont">at()</tt> member function), the actual number of characters is an invalid index. Using it might cause an exception or result in undefined behavior.</p>

					</li>
</ul>
				<p>For example:</p>

				<PRE>
					
    const std::string cs("nico");      //cs <I>contains:</I> 'n' 'i' 'c' 'o'
    std::string s("abcde");            //s <I>contains:</i> 'a' 'b' 'c' 'd' 'e'


    s[2]                               //<I>yields</I> 'c'
    s.at(2)                            //<i>yields</I> 'c'


    s[100]                             //<I>ERROR: undefined behavior</i>
    s.at(100)                          //<I>throws</I> out_of_range


    s[s.length()]                      //<I>ERROR: undefined behavior</I>
    cs[cs.length()]                    //<I>yields</I> '\0'
    s.at(s.length())                   //<i>throws</i> out_of _range
    cs.at(cs.length())                 //<i>throws</i> out_of _range

				</PRE>

				<P>To enable you to modify a character of a string, the nonconstant versions of <tt clASS="monofont">[]</Tt> and <tt cLASS="monofont">at()</tt> return a character reference. Note that this reference becomes invalid on reallocation:</p>

				<pre>
					
    std::string s("abcde");        //s <i>contains:</i> 'a' 'b' 'c' 'd' 'e'


    char&amp; r = s[2];                //<i>reference to third character</i>
    char* p = s[3];                //<i>pointer to fourth character</i>


    r = 'X';                       //<i>OK,</i> s<i> contains:</i> 'a' 'b' 'X' 'd' 'e'
    *p = 'Y';                      //<i>OK,</i> s<i> contains:</i> 'a' 'b' 'X' 'Y' 'e'


    s = "new long value";          //<i>reallocation invalidates</I> r <I>and</I> p


    r = 'X';                       //<I>ERROR: undefined behavior</I>
    *p = 'Y';                      //<I>ERROR: undefined behavior</i>

				</PRe>

				<P>Here, to avoid runtime errors, you would have had to <Tt CLASS="monofont">reserve()</Tt> enough capacity before <tt cLASS="monofont">r</tt> and <tt CLASs="monofont">p</tt> were initialized.</p>

				<P>References and pointers that refer to characters of a string may be invalidated by the following operations:</P>

				<UL>
<li><p>If the value is swapped with <tt class="monofont">swap()</tt></p>
</li>
<li><p>If a new value is read by <tt cLASS="monofont">operator&gt;&gt;()</TT> or <tT ClASs="monofont">getline()</TT></P>
</LI>
<Li><p>If the contents are exported by <tt CLASs="monofont">data()</tt> or <tT CLAss="monofont">c_str()</tt></P>
</LI>
<Li><p>If any nonconstant member function is called, except operator <tt class="monofont">[], at(), begin(), rbegin(), end(),</tt> or <tt class="monofont">rend()</tt></p>
</LI>
<LI><P>If any of these functions is followed by operator <Tt CLaSS="monofont">[], at(), begin(), rbegin(), end(),</tT> or <TT CLAss="monofont">rend()</tt></P>

					</LI>
</Ul>
				<p>The same applies to iterators (see <a href="0201379260_snode91.html#31">Section 11.2.13</A>).</p>

			
			<a naME="18"></A><H4>11.2.7
Comparisons</h4>
				<p>The usual comparison operators are provided for strings. The operands may be strings or C-strings:</p>

				<pre>
					
    std::string s1, s2;
    ...


    s1 == s2       //<i>returns</i> true <i>if</i> s1 <i>and</i> s2 <i>contain the same characters</i>
    s1 &lt; "hello"   //<i>return whether</i> s1 <i>is less than the C-string</i> "hello"

				</pre>

				<P>If strings are compared by <TT CLAsS="monofont">&lt;, &lt;=, &gt;,</Tt> or <TT cLASS="monofont">&gt;=,</TT> their characters are compared lexicographically according to the current character traits. For example, all of the following comparisons yield <tt clASS="monofont">true:</Tt></p>

				<prE>
					
    std::string("aaaa") &lt; std::string("bbbb")
    std::string("aaaa") &lt; std::string("abba")
    std::string("aaaa") &lt; std::string("aaaaaa")

				</PRE>

				<p>By using the <tt cLASS="monofont">compare()</tt> member functions you can compare substrings. The <tt class="monofont">compare()</tt> member functions can process more than one argument for each string so that you can specify a substring by its index and by its length. Note that <tt class="monofont">compare()</tt> returns an integral value rather than a Boolean value. This return value has the following meaning: <tT CLASS="monofont">0</tT> means equal, a value less than zero means less than, and a value greater than zero means greater than. For example:</P>

				<pRE>
					
    std::string s("abcd");


    s.compare("abcd")          //<i>returns</I> 0
    s compare ("dcba")         //<I>returns a value &lt;</I> 0 (s<I> is less</I>)
    s compare ("ab")           //<I>returns a value &gt;</i> 0 (<i>s is greater</i>)


    s.compare (s)              //<i>returns 0</I> (<I>s is equal to s</I>)
    s.compare(0,2,s,2,2)       //<I>returns a value</i> &lt;0("ab" <i>is less than</i> "cd")
    s.compare (1,2, "bcx",2)   //<i>returns</I> 0 ("bc" <I>is equal to</I> "bc")

				</Pre>

				<p>To use a different comparison criterion you can define your own comparison criterion and use STL comparison algorithms (see <a href="0201379260_snode91.html#31">Section 11.2.13</a>, for an example), or you can use special character traits that make comparisons on a case-insensitive basis. However, because a string type that has a special traits class is a different data type, you cannot combine or process these strings with objects of type <tt class="monofont">string.</tt> See <a href="0201379260_snode91.html#36">Section 11.2.14</a>, for an example.</p>

				<p>In programs for the international market it might be necessary to compare strings according to a specific locale. Class <tt cLASS="monofont">locale</TT> provides the parenthesis operator as convenient way to do this (see page 703). It uses the string collation facet, which is provided to compare strings for sorting according to some locale conventions. See <a href="0201379260_snode120.html#34">Section 14.4.5</A>, for details.</p>

			
			<A NAME="19"></A><h4>11.2.8
Modifiers</h4>
				<p>You can modify strings by using different member functions and operators.</p>

				<H5>Assignments</H5>
					<P>To modify a string you can use operator <Tt claSS="monofont">=</TT> to assign a new value. The new value may be a string, a C-string, or a single character. In addition, you can use the <tt clASS="monofont">assign()</Tt> member functions to assign strings when more than one argument is needed to describe the new value. For example:</p>

					<pre>
						
    const std::string aString("othello");
    std::string s;


    s = aString;                //<i>assign</i> "othello"
    s = "two\nlines";           //<i>assign a C-string</i>
    s = ' ';                    //<i>assign a single character</i>


    s.assign(aString);        //<i>assign</i> "othello" (<i>equivalent to operator</i> =)
    s.assign(aString, 1,3);     //<i>assign</i> "the"
    s.assign(aString, 2, string::npos);       //<i>assign</i> "hello"


    s.assign("two\nlines") ;    //<i>assign a C-string</i> (<I>equivalent to operator =</I>)
    s.assign("nico" ,5);        //<I>assign the character array:</I> 'n' 'i' 'c' 'o' '\0'
    s.assign(5,'x');            //<I>assign five characters:</I> 'x' 'x' 'x' 'x' 'x'

					</pRE>

					<p>You also can assign a range of characters that is defined by two iterators. See <A href="0201379260_snode91.html#31">Section 11.2.13</A>, for details.</P>

				
				<H5>Swapping Values</H5>
					<p>As with many nontrivial types, the string type provides a specialization of the <tt cLASS="monofont">swap()</tt> function, which swaps the contents of two strings (the global <tt CLASs="monofont">swap()</tt> function was introduced in <a href="0201379260_snode29.html#2">Section 4.4.2</a>). The specialization of <tt class="monofont">swap()</tt> for strings guarantees constant complexity. So you should use it to swap the value of strings and to assign strings if you don't need the assigned string after the assignment.</p>

				
				<h5>Making Strings Empty</h5>
					<p>To remove all characters in a string, you have several possibilities. For example:</p>

					<pre>
						
    std::string s;


    s = "";          //<i> assign the empty string</i>
    s.clear();       //<i> clear contents</I>
    s.erase();       //<I> erase all characters</I>

					</PRE>

				
				<h5>Inserting and Removing Characters</H5>
					<P>There are a lot of member functions to insert, remove, replace, and erase characters of a string. To append characters, you can use operator <tT ClASS="monofont">+=, append(),</TT> and <Tt claSS="monofont">push_back().</TT> For example:</p>

					<pre>
						
    const std::string aString("othello");
    std::string s;


    s += aString;            //<I>append</I> "othello"
    s += "two\nlines";       //<I>append C-string</I>
    s += '\n';               //<i>append single character</i>


    s.append(aString);       //<i>append</i> "othello" <I>(equivalent to operator +=)</I>
    s.append(aString,1,3);   //<I>append</I> "the"
    s.append(aString,2,string::npos);    //<i>append</i> "hello"


    s.append("two\nlines");  //<i>append C-string (equivalent to operator +=)</i>
    s.append("nico" ,5);     //<i>append character array:</i> 'n' 'i' 'c' 'o' '\0'
    s.append(5,'x');         //<i>append five characters:</i> 'x' 'x' 'x' 'x' 'x'


    s.push_back('\n');       //<i>append single character (equivalent to operator +=)</i>

					</pre>

					<p>Operator <tt class="monofont">+=</TT> appends single-argument values, <TT CLaSS="monofont">append()</tT> lets you specify the appended value by using multiple arguments. One additional version of <Tt CLASS="monofont">append()</Tt> lets you append a range of characters specified by two iterators (see <a href="0201379260_snode91.html#31">Section 11.2.13</A>). The <Tt claSS="monofont">push_back()</TT> member function is provided for back inserters so that STL algorithms are able to append characters to a string (see <a href="0201379260_snode62.html#6">Section 7.4.2</A>, for details about back inserters and <A href="0201379260_snode91.html#31">Section 11.2.13</a>, for an example of their use with strings).</p>

					<p>Similar to <tt class="monofont">append(),</tt> several <tt clasS="monofont">insert()</TT> member functions enable you to insert characters. They require the index of the character, behind which the new characters are inserted:</P>

					<PRe>
						
    const std::string aString("age");
    std::string s("p");


    s.insert(1,aString);        //s: page
    s.insert(1, "ersifl");      //s: persiflage

					</PRe>

					<P>Note that no <Tt CLASS="monofont">insert()</Tt> member function is provided to pass the index and a single character. Thus you must pass a string or an additional number:</p>

					<prE>
						
    s.insert(0,' ');     //<I>ERROR</I>
    s.insert(0," ");     //<I>OK</i>

					</pre>

					<P>You might also try</P>

					<PRe>
						
    s.insert(0,1, ' ');   //<i>ERROR: ambiguous</i>

					</pRE>

					<P>However, this results in a nasty ambiguity because <Tt class="monofont">insert()</tt> is overloaded for the following signatures:</p>

					<pre>
						
    insert (size_type idx, size_type num, charT c); //<i>position is index</i>
    insert (iterator  pos, size_type num, charT c); //<i>position is iterator</i>

					</pre>

					<p>For type <tT CLASS="monofont">string, size_type</tT> is usually defined as <Tt CLaSS="monofont">unsigned</TT> and <TT clasS="monofont">iterator</TT> is often defined as <Tt claSS="monofont">char*.</TT> In this case, the first argument <tt clASS="monofont">0</Tt> has two equivalent conversions. So, to get the correct behavior you have to write:</p>

					<pre>
						
    s.insert((string::size_type)0,1,' ');  //<i>OK</i>

					</pre>

					<p>The second interpretation of the ambiguity described here is an example of the use of iterators to insert characters. If you wish to specify the insert position as an iterator, you can do it in three ways: insert a single character, insert a certain number of the same character, and insert a range of characters specified by two iterators (see <a href="0201379260_snode91.html#31">Section 11.2.13</a>).</p>

					<p>Similar to <tt CLASS="monofont">append()</Tt> and <TT cLAsS="monofont">insert(),</TT> several <TT Class="monofont">erase()</TT> functions remove characters, and several <TT clasS="monofont">replace()</TT> functions replace characters. For example:</P>

					<pre>
						
    std::string s = "i18n";                     //s: i18n
    s.replace(1,2, "nternationalizatio");       //s: internationalization
    s.erase(13);                                //s: international
    s.erase(7,5);                               //s: internal
    s.replace(0,2, "ex");                       //s: external

					</pRE>

					<P><Tt class="monofont">resize()</tt> lets you change the number of characters. If the new size that is passed as an argument is less than the actual number of characters, characters are removed from the end. If the new size is greater than the actual number of characters, characters are appended at the end. You can pass the character that is appended if the size of the string grows. If you don't, the default constructor for the character type is used (which is the <tt class="monofont">'\0'</tt> character for type <tt clASS="monofont">char</TT>).</P>

				
			
			<h4>11.2.9
Substrings and String Concatenation</H4>
				<P>You can extract a substring from any string by using the <tT ClASS="monofont">substr()</TT> member function. For example:</P>

				<pre>
					
    std::string s("interchangeability");


    s.substr()                      //<i>returns a copy of</I> s
    s.substr(11)                    //<I>returns</I> string("ability")
    s.substr(5,6)                   //<I>returns</i> string ("change")
    s.substr(s.find('c'))           //<i>returns</i> string ("changeability")

				</pRE>

				<P>You can concatenate two strings or C-strings, or one of those with single characters by using operator <Tt claSS="monofont">+.</TT> For example, the statements</p>

				<pre>
					
    std::string s1("enter");
    std::string s2("nation");
    std::string i18n;


    i18n = 'i' + s1.substr(1) + s2 + "aliz" + s2.substr(1);
    cout &lt;&lt; "i18n means: " + i18n &lt;&lt; endl;

				</pre>

				<p>have the following output:</p>

				<pre>
					
    i18n means: internationalization

				</pre>

			
			<h4>11.2.10
Input/Output Operators</h4>
				<p>The usual I/O operators are defined for strings:</p>

				<ul>
<LI><P><B>Operator &gt;&gt;</B> reads a string from an input stream.</P>
</lI>
<Li><P><B>Operator &lt;&lt;</b> writes a string to an output stream.</P>

					</LI>
</UL>
				<P>These operators behave as they do for ordinary C-strings. In particular, operator <tt clASS="monofont">&gt;&gt;</Tt> operates as follows:</p>

				<ol TYPE="1" starT="restarts">
<LI><P>It skips leading whitespaces if the <tt class="monofont">skipws</tt> flag (see <a href="0201379260_snode108.html">Section 13.7.7</a>) is not set.</p>
</li>
<li><p>It reads all characters until any of the following happens:</P>

						<UL>
<LI><P>The next character is a whitespace</p>
</LI>
<lI><P>The stream is no longer in a good state (for example due to end-of-file)</p>
</LI>
<LI><P>The actual <Tt claSS="monofont">width()</TT> of the stream (see <a href="0201379260_snode107.html#7">Section 13.7.3</A>) is greater than zero and <TT clasS="monofont">width()</TT> characters are read</P>
</li>
<li><p><tt class="monofont">max_size()</tt> characters are read</p>
</li>
</ul>
					</li>
<LI><P>It sets <TT ClASs="monofont">width()</TT> of the stream to <tT CLASS="monofont">0.</tt></p>

					</lI>
</OL>

				<P>Thus, in general, the input operator reads the next word while skipping leading whitespaces. A whitespace is any character for which <tt clASS="monofont">isspace(c,</Tt><i>strm</i><tT CLAss="monofont">.getloc())</tt> is true <tt class="monofont">(isspace()</tt> is explained in <a href="0201379260_snode120.html#21">Section 14.4.4</a>).</p>

				<p>The output operator also takes the <TT CLASs="monofont">width()</TT> of the stream in consideration. That is, if <tT ClASS="monofont">width()</TT> is greater than <Tt claSS="monofont">0,</TT> operator <tt clASS="monofont">&lt;&lt;</Tt> writes at most <tt cLASS="monofont">width()</tt> characters.</p>

				<p>The string classes also provide a special function in namespace std for reading line-by-line: <tt class="monofont">std::getline().</tt> This function ignores leading whitespaces and reads all characters until the line delimiter or end-of-file is reached. The line delimiter is extracted but not appended. By default, the line delimiter is the newline character, but you can pass your own "line" delimiter as an optional argument:<font size="1"><SUP><A HReF="#FOOTNOTE-5">[5]</A></sUP></fONT>
:</P>
<BLockqUOTE><font SIZE="1">
<p claSS="footnote">
<SUp><a name="FOOTNOTE-5">[5]</a></sup>
You don't have to qualify <tt class="monofont">getline()</tt> with <tt CLASS="monofont">std::</Tt> because "Koenig lookup" will always consider the namespace where the class of an argument was defined when calling a function (see page 17).</P>
</FoNT></bLOCKQUote>

					
				<pRE>
					
    std::string s;


    while (getline(std::cin,s)) {       //<I>for each line read from</I> cin
        ...

    }


    while (getline(std:: cin, s,':')) { //<i>for each token separated by</i> ':'
        ...

    }

				</prE>

				<P>Note that if you read token-by-token, the newline character is not a special character. In this case, the tokens might contain a newline character.</P>

			
			<H4>11.2.11
Searching and Finding</h4>
				<p>Strings provide a lot of functions to search and find characters or substrings.<foNT SIze="1"><sup><a href="#FOOTNOTE-6">[6]</a></sup></font>
 You can search</p>
<blOCKQUOtE><FoNT sIZE="1">
<P CLass="footnote">
<sUP><A Name="FOOTNOTE-6">[6]</a></SUP>
Don't be confused because I write about searching "and" finding. They are (almost) synonymous. The search functions use "find" in their name. However, unfortunately they don't guarantee to find anything. In fact, they "search" for something or "try to find" something. So I use the term <I>search</i> for the behavior of these functions and <i>find</i> with respect to their name.</p>
</FONT></blockquote>

					
				<ul>
<li><p>A single character, a character sequence (substring), or one of a certain set of characters</p>
</li>
<li><p>Forward and backward</P>
</LI>
<LI><P>Starting from any position at the beginning or inside the string</p>

					</LI>
</uL>
				<P>In addition, all search algorithms of the STL can be called when iterators are used.</p>

				<P>All search functions have the word <I>find</I> inside their name. They try to find a character position given a <I>value</I> that is passed as an argument. How the search proceeds depends on the exact name of the find function. <A href="0201379260_snode91.html#29">Table 11.5</A> lists all of the search functions for strings.</P>

				<A Name="29"></a><P><TABle boRDER="1" cellspacing="0" cellpaddinG="1" WIDTH="100%">
<cAPtIOn><H5>Table 11.5. Search Functions for Strings</H5></CAPTion><cOLGRoup aLIGN="left" span="2">
<TR>
<TH valign="top">
<font size="2"><b>String Function</b>
								</font></tH>
<TH VALiGN="top">
<fONt SIZE="2"><B>Effect</B>
								</font></TH>
</TR>
<tr>
<td VALIgn="top">
<foNT SIze="2"><tt class="monofont">find()</tt>
								</font></td>
<td vaLIGN="top">
<FOnT SiZE="2">Finds the first occurrence of <i>value</I>
								</FONT></Td>
</tr>
<tR>
<TD ValigN="top">
<FONt sizE="2"><TT Class="monofont">rfind()</tt>
								</font></td>
<td valign="top">
<fONT SIZe="2">Finds the last occurrence of <I>value</I> (reverse find)
</fONt></TD>
</TR>
<TR>
<td vaLIGN="top">
<font SIZE="2"><tt clASS="monofont">find_first_of()</Tt>
								</font></td>
<td valign="top">
<font siZE="2">Finds the first character that is part of <I>value</I>
								</FOnT></Td>
</TR>
<tR>
<TD VALign="top">
<fONT Size="2"><tT CLAss="monofont">find_last_of()</tt>
								</FONT></td>
<td valign="top">
<font size="2">Finds the last character that is part of <i>value</i>
								</fONT></TD>
</Tr>
<TR>
<tD VaLIGN="top">
<FOnt siZE="2"><TT clasS="monofont">find_first_not_of()</TT>
								</Font></tD>
<TD Valign="top">
<font size="2">Finds the first character that is not part of <i>value</i>
								</font></td>
</TR>
<TR>
<TD vALiGN="top">
<fONT SIZe="2"><tt cLASS="monofont">find_last_not_of()</tt>
								</foNT></TD>
<td vaLIGN="top">
<font size="2">Finds the last character that is not part of <i>value</i>
								</font></td>
</tr>
</colGROUP>
</TaBLe></P>

				<P>All search functions return the index of the first character of the character sequence that matches the search. If the search fails, they return <tT CLASS="monofont">npos.</tt> The search functions use the following argument scheme:</p>

				<uL>
<LI><P>The first argument is always the value that is searched.</p>
</li>
<lI><P>The second optional value indicates an index at which to start the search in the string.</P>
</Li>
<li><p>The optional third argument is the number of characters of the value to search.</P>

					</LI>
</Ul>
				<p>Unfortunately, this argument scheme differs from that of the other string functions. With the other string functions, the starting index is the first argument, and the value and its length are adjacent arguments. In particular, each search function is overloaded with the following set of arguments:</p>

				<ul>
<li><p><b><tt class="monofont">const</tt></b>
							<b><i>string</I></B><I><TT ClASs="monofont">&amp;</TT></i>
							<I>value</I></P>

						<P>The function searches against the characters of the string <I>value.</I></p>
</li>
<lI><P><B><Tt claSS="monofont">const</TT></b>
							<b><i>string</i></B><I><TT class="monofont">&amp;</tt></i>
							<i>value,</i>
							<i><tt class="monofont">size_type</tt></i>
							<I>idx</I></P>

						<P>The function searches against the characters of <I>value,</I> starting with index <i>idx</I> in <Tt CLaSS="monofont">*this.</TT></P>
</Li>
<li><p><B><TT Class="monofont">const</TT></B>
							<B><i><tt cLASS="monofont">char*</tt></i></b>
							<i>value</i></p>

						<p>The function searches against the characters of the C-string <i>value.</i></p>
</li>
<li><p><b><tt clASS="monofont">const</TT></B>
							<b><I><Tt CLaSS="monofont">char*</TT></I></B>
							<i>value,</i>
							<b><i><TT CLass="monofont">size_type</tT></I></B>
							<I>idx</i></p>

						<p>The function searches against the characters of the C-string <i>value,</I> starting with index <I>idx</I> in <Tt class="monofont">*this.</tt></p>
</li>
<li><p><b><tt clasS="monofont">const</TT></B>
							<B><I><tT ClASs="monofont">char*</TT></I></B>
							<I>value,</I>
							<b><i><tt CLASs="monofont">size_type</tt></i></B>
							<I>idx,</I>
							<B><i><tt cLASS="monofont">size_type</tt></i></b><i> value_len</i></p>

						<p>The function searches against the <i>value_len</i> characters of the character array <i>value,</i> starting with index <i>idx</i> in <tt class="monofont">*this.</TT> Thus, the null character <TT CLaSS="monofont">('\0'</tT>) has <I>no</i> special meaning here inside <I>value.</I></P>
</LI>
<Li><p><b><tT CLAss="monofont">const</tt></B>
							<B><I><Tt claSS="monofont">char</TT></i></b>
							<i>value</i></p>

						<p>The function searches against the character <i>value.</i></p>
</li>
<li><p><b><tt clasS="monofont">const</TT></B>
							<B><I><tT ClASs="monofont">char</TT></I></B>
							<I>value,</I>
							<b><i><tt CLASs="monofont">size_type</tt></i></B><I> idx</I></P>

						<p>The function searches against the characters <i>value,</i> starting with index <i>idx</I> in <TT Class="monofont">*this.</tt></p>

					</li>
</ul>
				<p>For example:</p>

				<pre>
					
    std::string s("Hi Bill, I'm ill, so please pay the bill");


    s.find ("i1")                        //<i>returns</i> 4 <i>(first substring</i> "i1"<i>)</I>
    s.find("il", 10)                     //<I>returns</I> 13 <I>(first substring</I> "il" <I>starting from</i> s[10]
<DIv><IMg BORDER="0" aligN="left" WIDth="14" heIGHT="9" src="FILES/ccc.gif" aLT="graphics/ccc.gif"></DIv><i>)</i>
    s.rfind("il")                        //<i>returns</i> 37 <i>(last substring "</i>il"<i>)</i>
    s.find_first_of("il")                   //<i>returns</i> 1 <i>(first char</i> 'i'<i> or</i> 'l'<i>)</i>
    s.find_last_of("il")                    //<i>returns</i> 39 <i>(last char</i> 'i' <I>or</I> 'l'<I>)</I>
    s.find_first_not_of("il")               //<I>returns</I> 0<i> (first char neither</I> 'i' <I>nor</i> 'l'<I>)</I>
    s.find_last_not_of("il")                //<i>returns</I> 36 <I>(last char neither</I> 'i'<I> nor</I> 'l'<I>)</i>
    s.find("hi")                            //<i>returns</i> npos

				</pRE>

				<P>You could also use STL algorithms to find characters or substrings in strings. They allow you to use your own comparison criterion (see <A href="0201379260_snode91.html#31">Section 11.2.13</A>, for an example). However, note that the naming scheme of the STL search algorithms differs from the naming scheme for string search functions (see <A href="0201379260_snode72.html#2">Section 9.2.2</a>, for details).</p>

			
			<A NAMe="30"></a><h4>11.2.12
The Value <tt class="monofont">npos</tt></h4>
				<p>If a search function fails, it returns <i>string</i><tt claSS="monofont">::npos.</TT> Consider the following example:</P>

				<PrE>
					
    std::string s;
    std::string::size_type idx;         //<I>be careful: don't use any other type!</i>
    ...


    idx = s.find("substring");
    if (idx == std::string::npos) {
       ...
    }

				</PRe>

				<P>The condition of the <TT CLAss="monofont">if</tt> statement yields <TT CLass="monofont">true</tT> if and only if <TT Class="monofont">"substring"</TT> is not part of string <TT class="monofont">s.</tt></p>

				<p>Be very careful when using the string value <tt class="monofont">npos</tt> and its type. When you want to check the return value always use <tt cLASS="monofont">string::size_type</TT> and <i>not</I>
					<Tt CLaSS="monofont">int</TT> or <TT clasS="monofont">unsigned</TT> for the type of the return value; otherwise, the comparison of the return value with <Tt claSS="monofont">string::npos</TT> might not work.</p>

				<p>This behavior is the result of the design decision that <tt CLASs="monofont">npos</tt> is defined as <tt class="monofont">-1:</tt></p>

				<pre>
					
    namespace std {
        template&lt;class charT,
                 class traits = char_traits&lt;charT&gt;,
                 class Allocator = allocator&lt;charT&gt; &gt;
        class basic_string {
          public:
                typedef typename Allocator::size_type size_type;
                ...
                static const size_type npos = -1;
                ...
        };
    }

				</pre>

				<p>Unfortunately, <tT CLASS="monofont">size_type</tT> (which is defined by the allocator of the string) must be an unsigned integral type. The default allocator, <Tt CLaSS="monofont">allocator,</TT> uses type <TT clasS="monofont">size_t</TT> as <Tt claSS="monofont">size_type</TT> (see <a href="0201379260_snode125.html">Section 15.3</A>). Because <TT class="monofont">-1</tt> is converted into an unsigned integral type, <tt class="monofont">npos</tt> is the maximum unsigned value of its type. However, the exact value depends on the exact definition of type <tt claSS="monofont">size_type.</TT> Unfortunately, these maximum values differ. In fact, <TT cLAsS="monofont">(unsigned long</Tt>)<TT CLASs="monofont">-1</tt>
					<i>differs</I> from <TT Class="monofont">(unsigned short</TT>)<TT clasS="monofont">-1</TT> (provided the size of the types differ). Thus, the comparison</P>

				<pre>
					
    idx == std::string::npos

				</pre>

				<p>might yield <tt class="monofont">false,</tt> if <tt claSS="monofont">idx</TT> has the value <TT cLAsS="monofont">-1</Tt> and <TT CLASs="monofont">idx</tt> and <tT CLAss="monofont">string::npos</tt> have different types:</P>

				<PRE>
					
    string s;

    ...
    int idx = s.find("not found");     //<i>assume it returns</i> npos
    if (idx == std:: string::npos) {   //<i>ERROR: comparison might not work</i>
        ...
    }

				</PRE>

				<P>One way to avoid this error is to check whether the search fails directly:</p>

				<pre>
					
    if (s.find("hi") == std::string::npos) {
        ...
    }

				</pre>

				<p>However, often you need the index of the matching character position. Thus, another simple solution is to define your own signed value for <tt class="monofont">npos:</tt></p>

				<pre>
					
    const int NPOS = -1;

				</PRE>

				<P>Now the comparison looks a bit different (and even more convenient):</P>

				<PrE>
					
    if (idx == NPOS) {     //<I>works almost always</i>
        ...
    }

				</PRe>

				<P>Unfortunately, this solution is not perfect because the comparison fails if either <TT CLAss="monofont">idx</tt> has type <TT CLass="monofont">unsigned short</tT> or the index is greater than the maximum value of <TT Class="monofont">int</TT> (because of these problems the standard did not define it that way). However, because both might happen very rarely, the solution works in most situations. To write portable code, however, you should always use <I>string</I><tt class="monofont">::size_type</tt> for any index of your string type. For a perfect solution you'd need some overloaded functions that consider the exact type of <tt class="monofont">string::size_type.</tt> I hope the standard will provide a better solution in the future.</p>

			
			<a nAME="31"></A><H4>11.2.13
Iterator Support for Strings</H4>
				<p>A string is an ordered collection of characters. As a consequence, the C++ standard library provides an interface for strings that lets you use strings as STL containers.<FOnT SiZE="1"><SUP><A href="#FOOTNOTE-7">[7]</A></SUP></font>
</P>
<BLOckquOTE><Font size="1">
<p class="footnote">
<sup><a name="FOOTNOTE-7">[7]</A></SUP>
The STL is introduced in <A href="0201379260_cnode32.html">Chapter 5</a>.</P>
</FoNT></BLOCkquoTE>

					
				<P>In particular, you can call the usual member functions to get iterators that iterate over the characters of a string. If you are not familiar with iterators, consider them as something that can refer to a single character inside a string, just as ordinary pointers do for C-strings. By using these objects, you can iterate over all characters of a string by calling several algorithms that either are provided by the C++ standard library or that are user defined. For example, you can sort the characters of a string, reverse the order, or find the character that has the maximum value.</P>

				<p>String iterators are random access iterators. This means that they provide random access and that you can use all algorithms (see <a href="0201379260_snode36.html#12">Section 5.3.2</A>, and <A href="0201379260_snode60.html">Section 7.2</A>, for a discussion about iterator categories). As usual, the types of string iterators <TT Class="monofont">(iterator, const_iterator,</tt> and so on) are defined by the string class itself. The exact type is implementation defined, but usually string iterators are defined simply as ordinary pointers. See <a href="0201379260_snode60.html#14">Section 7.2.6</a>, for a discussion of a nasty difference between iterators that are implemented as pointers and iterators that are implemented as classes.</p>

				<p>Iterators are invalidated when reallocation occurs or when certain changes are made to the values to which they refer. See <a href="0201379260_snode91.html#17">Section 11.2.6</a>, for details.</p>

				<H5>Iterator Functions for Strings</H5>
					<P><A href="0201379260_snode91.html#35">Table 11.6</A> shows all of the member functions that strings provide for iterators. As usual, the range specified by <tT ClASS="monofont">beg</TT> and <Tt claSS="monofont">end</TT> is a half-open range that includes <tt clASS="monofont">beg</Tt> but excludes <tt cLASS="monofont">end</tt> (often written as [<tt class="monofont">beg,end</tt>), see <a href="0201379260_snode36.html">Section 5.3</a>).</p>

					<p>To support the use of back inserters for string, the <tt CLASS="monofont">push_back()</Tt> function is defined. See <A href="0201379260_snode62.html#6">Section 7.4.2</a>, for details about back inserters and page 502 for an example of their use with strings.</P>

				
				<H5>Example of Using String Iterators</H5>
					<P>A very useful thing that you can do with string iterators is to make all characters of a string lowercase or uppercase via a single statement. For example:</P>

					<Pre>
						
    //<i>string/iter1.cpp</i>

    #include &lt;string&gt;
    #include &lt;iostream&gt;
    #include &lt;algorithm&gt;
    #include &lt;cctype&gt;
    using namespace std;

					</PRE>

					<A name="35"></A><P><TAble bORDEr="1" cellspacing="0" cellpaddiNG="1" WIDTh="100%">
<CApTIoN><H5>Table 11.6. Iterator Operations of Strings</H5></CAPtion><COLGroup ALIGn="left" spaN="2">
<TR>
<Th valign="top">
<font size="2"><b>Expression</b>
									</font></TH>
<TH VAlIGn="top">
<FOnT SIZE="2"><B>Effect</b>
									</fonT></TH>
</Tr>
<tr>
<tD VALign="top">
<fONT Size="2"><tt class="monofont">s.begin()</tt>
									</font></td>
<td vALIGN="top">
<FoNT sIZe="2">Returns a random access iterator for the first 
character</FONT></TD>
</tr>
<tr>
<TD VAlign="top">
<FONT size="2"><TT CLass="monofont">s.end()</tt>
									</font></td>
<td valign="top">
<foNT SIZE="2">Returns a random access iterator for the position after the last character</fONt></TD>
</tR>
<TR>
<TD ValigN="top">
<FONt sizE="2"><TT Class="monofont">s.rbegin()</TT>
									</FOnt></td>
<td valign="top">
<font size="2">Returns a reverse iterator for the first character of a reverse iteration (thus, for the last character)</fONT></TD>
</Tr>
<TR>
<tD VaLIGN="top">
<FOnt siZE="2"><TT clasS="monofont">s.rend()</TT>
									</Font></tD>
<TD Valign="top">
<font size="2">Returns a reverse iterator for the position after the last character of a reverse iteration (thus, the position before the first character)</font></td>
</tr>
<TR>
<TD VAlIGn="top">
<FOnT SIZE="2"><Tt claSS="monofont">string s(beg,end)</TT>
									</font></TD>
<TD valiGN="top">
<FOnt size="2">Creates a string that is initialized by all characters of the range [<tt class="monofont">beg,end</tt>)
</font></td>
</TR>
<TR>
<TD vALiGN="top">
<fONT SIZe="2"><tt cLASS="monofont">s.append(beg,end)</tt>
									</foNT></TD>
<td vaLIGN="top">
<font size="2">Appends all characters of the range [<tt class="monofont">beg,end</tt>)
</font></TD>
</TR>
<TR>
<tD VaLIgN="top">
<FONT Size="2"><tT CLAss="monofont">s.assign(beg,end)</tt>
									</FONT></td>
<td VALIgn="top">
<font size="2">Assigns all characters of the range [<tt class="monofont">beg,end</tt>)
</foNT></TD>
</TR>
<tR>
<Td VAlIGN="top">
<FONt sizE="2"><TT Class="monofont">s.insert(pos,c)</TT>
									</FOnt></td>
<TD VAlign="top">
<font size="2">Inserts the character <tt class="monofont">c</tt> at iterator position <TT CLASs="monofont">pos</TT> and returns the iterator position of the new character
</fONt></TD>
</TR>
<TR>
<td vaLIGN="top">
<font SIZE="2"><tt clASS="monofont">s.insert(pos,num,c)</Tt>
									</font></td>
<td valign="top">
<font siZE="2">Inserts num occurrences of the character <TT CLaSS="monofont">c</tT> at iterator position <Tt CLASS="monofont">pos</Tt> and returns the iterator position of the first new character
</fonT></TD>
</Tr>
<tr>
<tD VALign="top">
<fONT Size="2"><tt class="monofont">s.insert(pos,beg,end)</tt>
									</font></td>
<td vALIGN="top">
<FoNT sIZe="2">Inserts all characters of the range [<TT CLASs="monofont">beg,end</tt>) at iterator position <tT CLAss="monofont">pos</tt>
									</FONT></td>
</tr>
<TR>
<TD valign="top">
<font size="2"><tt class="monofont">s.erase(pos)</TT>
									</FONT></tD>
<Td VAlIGN="top">
<FONt sizE="2">Deletes the character to which iterator <TT Class="monofont">pos</TT> refers and returns the position of the next character
</FOnt></td>
</TR>
<TR>
<td valign="top">
<font size="2"><tt claSS="monofont">s.erase(beg,end)</TT>
									</FOnT></Td>
<TD vALIGN="top">
<Font sIZE="2">Deletes all characters of the range [<Tt claSS="monofont">beg,end</TT>) and returns the next position of the next character
</font></TD>
</TR>
<tr>
<td valign="top">
<font size="2"><tt cLASS="monofont">s.replace(beg, end, str)</TT>
									</fONt></TD>
<tD VALIGn="top">
<fonT SIZe="2">Replaces all characters of the range [<tt cLASS="monofont">beg,end</tt>) with the characters of string <tt CLASs="monofont">str</tt>
									</font></td>
</tr>
<tr>
<td valign="top">
<FONT SIzE="2"><Tt CLaSS="monofont">s.replace(beg,end,cstr)</TT>
									</FOnt></td>
<TD VAlign="top">
<FONT size="2">Replaces all characters of the range [<TT CLass="monofont">beg,end</tt>) with the characters of the C-string <tt class="monofont">cstr</tt>
									</font></td>
</tR>
<TR>
<TD VaLIgN="top">
<FoNT SIZE="2"><tt clASS="monofont">s.replace(beg,end,cstr,len)</Tt>
									</fonT></TD>
<Td valIGN="top">
<Font size="2">Replaces all characters of the range [<tt class="monofont">beg,end</tt>) with <tt claSS="monofont">len</TT> characters of the character array <TT cLAsS="monofont">cstr</Tt>
									</FONT></TD>
</tr>
<tr>
<TD VAlign="top">
<FONT size="2"><TT CLass="monofont">s.replace(beg,end,num,c)</tt>
									</font></td>
<td valign="top">
<foNT SIZE="2">Replaces all characters of the range [<tT ClASs="monofont">beg,end</TT>) with num occurrences of the character <TT CLass="monofont">c</tT>
									</FONt></td>
</tR>
<TR>
<Td valIGN="top">
<Font size="2"><tt class="monofont">s.replace(beg,end,newBeg,newEnd)</tt>
									</font></tD>
<TD VALiGN="top">
<fONt SIZE="2">Replaces all characters of the range [<TT clasS="monofont">beg,end</TT>) with all characters of the range <Tt claSS="monofont">[newBeg,newEnd)</TT>
									</font></TD>
</TR>
</colgroup>
</table></p>

					<pre>
						
    int main()
    {
        //<i>create a string</i>
        string s("The zip code of Hondelage in Germany is 38108");
        cout &lt;&lt; "original: " &lt;&lt; s &lt;&lt; endl;


        <i>//lowercase all characters</i>
        transform (s.begin(), s.end(),    //<I>source</I>
                   s.begin(),             //<I>destination</I>
                   tolower);              //<I>operation</I>
        cout &lt;&lt; "lowered: " &lt;&lt; s &lt;&lt; endl;


        <i>//uppercase all characters</I>
        transform (s.begin(), s.end(),    //<I>source</i>
                   s.begin(),             //<I>destination</I>
                   toupper);              //<i>operation</I>
        cout &lt;&lt; "uppered: " &lt;&lt; s &lt;&lt; endl;

    }

					</PRE>

					<P>The output of the program is as follows:</P>

					<pre>
						
    original: The zip code of Hondelage in Germany is 38108
    lowered:  the zip code of hondelage in germany is 38108
    uppered:  THE ZIP CODE OF HONDELAGE IN GERMANY IS 38108

					</pRE>

					<P>Note that <Tt claSS="monofont">tolower()</TT> and <tt clASS="monofont">toupper()</Tt> are old C functions that use the global locale. If you have a different locale or more than one locale in your program, you should use the new form of <tt class="monofont">tolower()</tt> and <tt class="monofont">toupper().</tt> See <a href="0201379260_snode120.html#21">Section 14.4.4</A>, for details.</P>

					<P>The following example demonstrates how the STL enables you to use your own search and sort criteria. It compares and searches strings in a case-insensitive way:</p>

					<PRe>
						
    //<I>string/iter2.cpp</I>

    #include &lt;string&gt;
    #include &lt;iostream&gt;
    #include &lt;algorithm&gt;
    using namespace std;


    bool nocase_compare (char c1, char c2)
    {
        return toupper(c1) == toupper(c2);
    }
    int main()
    {
        string s1("This is a string");
        string s2("STRING");


        <i>//compare case insensitive</I>
        if (s1.size() == s2.size() &amp;&amp;        //<I>ensure same sizes</I>
            equal (s1.begin(),s1.end(),      //<I>first source string</I>
                   s2.begin(),               //<I>second source string</i>
                   nocase_compare)) {        //<i>comparison criterion</i>
            cout &lt;&lt; "the strings are equal" &lt;&lt; endl;
        }
        else {
            cout &lt;&lt; "the strings are not equal" &lt;&lt; endl;
        }


        <i>//search case insensitive</I>
        string::iterator pos;
        pos = search (s1.begin() ,s1.end(),  //<I>source string in which to search</I>
                      s2.begin(), s2.end(),  //<I>substring to search</i>
                      nocase_compare);       //<i>comparison criterion</i>
        if (pos == s1.end()) {
            cout &lt;&lt; "s2 is not a substring of s1" &lt;&lt; endl;
        }
        else {
            cout &lt;&lt; ' " ' &lt;&lt; s2 &lt;&lt; "\" is a substring of \""
                 &lt;&lt; s1 &lt;&lt; "\" (at index " &lt;&lt; pos - s1.begin() &lt;&lt; ")"
                 &lt;&lt; endl;
        }
    }

					</pRE>

					<P>Note that the caller of <Tt claSS="monofont">equal()</TT> has to ensure that the second range has at least as many elements/characters as the first range. Thus, comparing the string size is necessary; otherwise, the behavior will be undefined.</p>

					<p>In the last output statement you can process the difference of two string iterators to get the index of the character position:</p>

					<pre>
						
    pos - s1.begin()

					</pre>

					<p>This is because string iterators are random access iterators. Similar to transferring an index into the iterator position, you can simply add the value of the index.</p>

					<p>In this example the user-defined auxiliary function <tt class="monofont">nocase_compare()</tt> is provided to compare two strings in a case-insensitive way. Instead, you can also use a combination of some function adapters and replace the expression <TT CLASs="monofont">nocase_compare</TT> with the following expression:</p>

					<PRe>
						
    compose_f_gx_hy(equal_to&lt;int&gt;(),
                     ptr_fun(toupper),
                     ptr_fun(toupper))

					</PRE>

					<P>See page 309 and page 318 for further details.</P>

					<P>If you use strings in sets or maps, you might need a special sorting criterion to let the collections sort the string in a case-insensitive way. See page 213 for an example that demonstrates how to do this.</p>

					<p>The following program demonstrates other examples of strings using iterator functions:</p>

					<pRE>
						
    //<I>string/iter3.cpp</I>

    #include &lt;string&gt;
    #include &lt;iostream&gt;
    #include &lt;algorithm&gt;
    using namespace std;


    int main()
    {
        //<i>create constant string</i>
        const string hello("Hello, how are you?");


        <i>//initialize string s with all characters of string hello</i>
        string s(hello.begin(),hello.end());


        <I>//iterate through all of the characters</I>
        string::iterator pos;
        for (pos = s.begin(); pos != s.end(); ++pos) {
            cout &lt;&lt; *pos;
        }
        cout &lt;&lt; endl;


        <I>//reverse the order of all characters inside the string</I>
        reverse (s.begin(), s.end());
        cout &lt;&lt; "reverse:       " &lt;&lt; s &lt;&lt; endl;


        <i>//sort all characters inside the string</i>
        sort (s.begin(), s.end());
        cout &lt;&lt; "ordered:       " &lt;&lt; s &lt;&lt; endl;


        /*<i>remove adjacent duplicates</i>
         *-unique() <I>reorders and returns new end</I>
         *-erase() <I>shrinks accordingly</I>
         */
        s.erase (unique(s.begin(),
                        s.end()),
                 s.end());
        cout &lt;&lt; "no duplicates: " &lt;&lt; s &lt;&lt; endl;
    }

					</pre>

					<p>The program has the following output:</p>

					<pre>
						
    Hello, how are you?
    reverse:       ?uoy era woh ,olleH
    ordered:          ,?Haeehlloooruwy
    no duplicates:  ,?Haehloruwy

					</pre>

					<p>The following example uses back inserters to read the standard input into a string:</p>

					<pre>
						
    //<i>string/unique.cpp</i>

    #include &lt;iostream&gt;
    #include &lt;string&gt;
    #include &lt;algorithm&gt;
    #include &lt;locale&gt;
    using namespace std;


    class bothWhiteSpaces {
      private:
        const locale&amp; loc; //<i>locale</i>
      public:
        /*<i>constructor</I>
         *-<I>save the locale object</I>
         */
        bothWhiteSpaces (const locale&amp; l) : loc(l) {
        }
        /*<I>function call</I>
         *-<I>returns whether both characters are whitespaces</i>
         */
        bool operator() (char elem1, char elem2) {
            return isspace(elem1,loc) &amp;&amp; isspace(elem2,loc);
        }
    };


    int main()
    {
        string contents;


        //<I>don't skip leading whitespaces</I>
        cin.unsetf (ios::skipws);


        //<i>read all characters while compressing whitespaces</I>
        unique_copy(istream_iterator&lt;char&gt;(cin) ,      //<I>beginning of source</i>
                    istream_iterator&lt;char&gt;(),          //<I>end of source</I>
                    back_inserter (contents),          //<I>destination</I>
                    bothWhiteSpaces (cin. getloc ())); //<I>criterion for removing</I>
        //<i>process contents</i>
        //-<i>here: write it to the standard output</i>
        cout &lt;&lt; contents;
    }

					</PRE>

					<P>By using the <tt clASS="monofont">unique_copy()</Tt> algorithm (see <a href="0201379260_snode77.html#4">Section 9.7.2</A>), all characters are read from the input stream <Tt class="monofont">cin</tt> and inserted into the string <tt class="monofont">contents.</tt> The <tt clASS="monofont">bothWhiteSpaces</TT> function object is used to check whether two consecutive characters are both whitespaces. To do this, it is initialized by the locale of <Tt CLaSS="monofont">cin</tT> and calls <TT CLAss="monofont">isspace(),</tt> which checks whether a character is a whitespace character (see <A href="0201379260_snode120.html#21">Section 14.4.4</a>, for a discussion of <tt CLASs="monofont">isspace()</tt>). <tT CLAss="monofont">unique_copy()</tt> uses the criterion <tt class="monofont">bothWhiteSpaces</tt> to remove adjacent duplicate whitespaces. You can find a similar example in the reference section about <tt class="monofont">unique_copy()</tT> on page 385.</P>

				
			
			<A NAMe="36"></A><H4>11.2.14
Internationalization</h4>
				<P>As mentioned in the introduction of the string class (see <A href="0201379260_snode91.html#1">Section 11.2.1</A>), the template string class <TT clasS="monofont">basic_string&lt;&gt;</TT> is parameterized by the character type, the traits of the character type, and the memory model. Type <Tt claSS="monofont">string</TT> is the specialization for characters of type <tt clASS="monofont">char,</Tt> and type <tt class="monofont">wstring</tt> is the specialization for characters of type <tt class="monofont">wchar_t.</tt></p>

				<p>The character traits are provided to specify the details of how to deal with aspects depending on the representation of a character type. An additional class is necessary because you can't change the interface of built-in types (such as <TT CLASs="monofont">char</TT> and <tT ClASS="monofont">wchar_t</TT>), and the same character type may have different traits. The details about the traits classes are described in <A href="0201379260_snode117.html#2">Section 14.1.2</A>.</P>

				<P>The following code defines a special traits class for strings so that they operate in a case-insensitive way:</P>

				<pre>
					
    //<i>string/icstring.hpp</I>

    #include &lt;string&gt;
    #include &lt;iostream&gt;
    #include &lt;cctype&gt;


    /* <I>replace functions of the standard</I> char_traits&lt;char&gt;
     * <I>so that strings behave in a case-insensitive way</i>
     */
    struct ignorecase_traits : public std::char_traits&lt;char&gt; {
        //<i>return whether</i> c1 <i>and</I> c2 <I>are equal</I>
        static bool eq(const char&amp; c1, const char&amp; c2) {
            return std::toupper(c1)==std::toupper(c2);
        }
        //<I>return whether</i> cl <i>is less than</i> c2
        static bool It(const char&amp; c1, const char&amp; c2){
            return std::toupper(c1)&lt;std::toupper(c2);
        }
        //<i>compare up to</i> n <i>characters of</i> s1<i> and</i> s2
        static int compare(const char* s1, const char* s2, size_t n) {
            for (size_t i=0; i&lt;n; ++i) {
                if (!eq(s1[i],s2[i])) {
                    return lt(s1 [i],s2[i])?-1:1;
                }
            }
            return 0;
        }
        //<i>search</i> c<i> in</i> s
        static const char* find(const char* s, size_t n,
                                const char&amp; c) {
            for (size_t i=0; i&lt;n; ++i) {
                 if (eq(s[i],c)) {
                     return &amp;(s[i]);
                 }
            }
            return 0;
        }
    };
    //<i>define a special type for such strings</i>
    typedef std::basic_string&lt;char,ignorecase_traits&gt; icstring;


    /*<i>define an output operator</i>
     *<i>because the traits type is different than that for</i> std::ostream
     */
    std::ostream&amp; operator &lt;&lt; (std::ostream&amp; strm, const icstring&amp; s)
    {
        //<i>simply convert the icstring into a normal string</i>
        return strm &lt;&lt; std::string(s.data(), s.length());
    }

				</PRE>

				<P>The definition of the output operator is necessary because the standard only defines I/O operators for streams that use the same character and traits type. But here, the traits type differs, so we have to define our own output operator. For input operators the same problem occurs.</P>

				<P>The following program demonstrates how to use these special kinds of strings:</p>

				<PRe>
					
    //<I>string/icstring1.cpp</I>

    #include "icstring.hpp"


    int main()
    {
        using std::cout;
        using std::endl;


        icstring s1("hallo");
        icstring s2("otto");
        icstring s3("hALLo");


        cout &lt;&lt; std::boolalpha;
        cout &lt;&lt; s1 &lt;&lt; " == " &lt;&lt; s2 &lt;&lt; " : " &lt;&lt; (s1==s2) &lt;&lt; endl;
        cout &lt;&lt; s1 &lt;&lt; " == " &lt;&lt; s3 &lt;&lt; " : " &lt;&lt; (s1==s3) &lt;&lt; endl;


        icstring::size_type idx = s1.find("All");
        if (idx != icstring::npos) {
            cout &lt;&lt; "index of \"A11\" in \"" &lt;&lt; s1 &lt;&lt; "\": "
                 &lt;&lt; idx &lt;&lt; endl;
        }
        else {
            cout &lt;&lt; "\"All\" not found in \"" &lt;&lt; s1 &lt;&lt; endl;
        }
    }

				</pRE>

				<P>The program has the following output:</P>

				<PRe>
					
    hallo == otto : false
    hallo == hALLo : true
    index of "All" in "hallo": 1

				</pre>

				<P>See <A href="0201379260_cnode115.html">Chapter 14</a> for more details about internationalization.</p>

			
			<H4>11.2.15
Performance</H4>
				<P>The standard does <I>not</i> specify <i>how</i> the string class is to be implemented. It only specifies the interface. There may be important differences in speed and memory usage depending on the concept and priorities of the implementation.</p>

				<P>If you prefer better speed, make sure that your string class uses a concept such as <I>reference counting.</I> Reference counting makes copies and assignments faster because the implementation only copies and assigns references instead of the contents of a string (see <A href="0201379260_snode55.html">Section 6.8</a>, for a smart pointer class that enables reference counting for any type). By using reference counting you might not even need to pass strings by constant reference; however, to maintain flexibility and portability, you always should.</p>

			
			<h4>11.2.16
Strings and Vectors</h4>
				<p>Strings and vectors behave similarly. This is not a surprise because both are containers that are typically implemented as dynamic arrays. Thus, you could consider a string as a special kind of a vector that has characters as elements. In fact, you can use a string as an STL container. This is covered by <a href="0201379260_snode91.html#31">Section 11.2.13</a>. However, considering a string as a special kind of vector is dangerous because there are many fundamental differences between the two. Chief of these are their two primary goals:</p>

				<ul>
<li><p>The primary goal of vectors is to handle and to manipulate the elements of the container, not the container as a whole. Thus, vectors implementations are optimized to operate on elements inside the container.</P>
</LI>
<LI><P>The primary goal of strings is to handle and to manipulate the container (the string) as a whole. Thus, strings are optimized to reduce the costs of assigning and passing the whole container.</p>

					</LI>
</uL>
				<P>These different goals typically result in completely different implementations. For example, strings are often implemented by using reference counting; vectors never are. Nevertheless, you can also use vectors as ordinary C-strings. See <a href="0201379260_snode49.html#21">Section 6.2.3</A>, for details.</P>

			
		</font>
 
<table width="100%" border="0" cellspacing="0" cellpadding="0" bgcolor="#CCCCCC">
<td><font color="black" size=1>I l<font color="#FF0000">@</font>ve RuBoard</td>
<td valign="top" class="v2" align="right"><a href="0201379260_snode90.html"><img src="FILES/previous.gif" width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a> <a href="0201379260_snode92.html"><img src="FILES/next.gif" width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a></td></table>
</BODY></HTML>