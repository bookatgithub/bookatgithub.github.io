<HTML><HEAD><META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=iso-8859-1">
<!--SafClassName="docSection1Title"--><!--SafTocEntry="11.3 String Class in Detail"-->
<LINK REL="stylesheet" href="FILES/sbolM.css">
</HEAD>
<BODY link="#354278" vlink="#000066" alink="#000080" topmargin="0">
<table width="100%" border="0" cellspacing="0" cellpadding="0" bgcolor="#CCCCCC">
<td><font color="black" size=1>I l<font color="#FF0000">@</font>ve RuBoard</td>
<td valign="top" class="v2" align="right"><a href="0201379260_snode91.html"><img src="FILES/previous.gif" width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a> <a href="0201379260_cnode93.html"><img src="FILES/next.gif" width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a></td></table>
<FONT><h3>11.3
String Class in Detail</h3>
			<p>In this section <i>string</I> means the actual string class. It might be <TT Class="monofont">string, wstring,</TT> or any other specialization of class <TT clasS="monofont">basic_string&lt;&gt;.</TT> Type <I>char</i> means the actual character type, which is <tt class="monofont">char</tt> for <tt class="monofont">string</tt> and <tt CLASS="monofont">wchar_t</Tt> for <TT cLAsS="monofont">wstring.</TT> Other types and values that are in italic type have definitions that depend on individual definitions of the character type or traits class. The details about traits classes are provided in <A href="0201379260_snode117.html#2">Section 14.1.2</a>.</p>

			<H4>11.3.1
Type Definitions and Static Values</H4>
				<P><B><i>string</i></b><b>::traits_type</B></P>

				<UL>
<li><p>The type of the character traits.</p>
</LI>
<LI><p>The second template parameter of class <tt class="monofont">basic_string.</tt></p>
</li>
<li><p>For type <tt claSS="monofont">string,</TT> it is equivalent to <TT cLAsS="monofont">char_traits&lt;char&gt;.</Tt></P>

					</LI>
</UL>
				<P><b><i>string</i></b><B>::value_type</B></P>

				<Ul>
<li><p>The type of the characters.</P>
</LI>
<Li><p>It is equivalent to <tt CLASs="monofont">traits_type::char_type.</tt></p>
</li>
<li><p>For type <tt class="monofont">string,</tt> it is equivalent to <tt cLASS="monofont">char.</TT></p>

					</LI>
</uL>
				<P><b><I>string</I></B><B>::size_type</B></P>

				<ul>
<li><P>The unsigned integral type for size values and indices.</P>
</LI>
<li><p>It is equivalent to <tT CLAss="monofont">allocator_type::size_type.</tt></P>
</LI>
<Li><p>For type <tt class="monofont">string,</tt> it is equivalent to <tt class="monofont">size_t.</tt></p>

					</LI>
</UL>
				<P><B><i>string</I></B><b>::difference_type</B></P>

				<uL>
<LI><P>The signed integral type for difference values.</P>
</Li>
<li><p>It is equivalent to <TT CLass="monofont">allocator_type::difference_type.</tT></P>
</LI>
<li><p>For type <tT CLAss="monofont">string,</tt> it is equivalent to <tt class="monofont">ptrdiff_t.</tt></p>

					</li>
</ul>
				<p><b><i>string</I></B><B>::reference</B></P>

				<Ul>
<LI><p>The type of character references.</P>
</Li>
<LI><P>It is equivalent to <TT Class="monofont">allocator_type::reference.</TT></P>
</Li>
<li><p>For type <TT CLass="monofont">string,</tT> it is equivalent to <TT Class="monofont">char&amp;.</tt></p>

					</li>
</ul>
				<p><b><i>string</i></b><b>::const_reference</b></p>

				<ul>
<LI><P>The type of constant character references.</P>
</LI>
<lI><P>It is equivalent to <tT ClASS="monofont">allocator_type::const_reference.</TT></P>
</li>
<li><P>For type <TT Class="monofont">string,</TT> it is equivalent to <TT clasS="monofont">const char&amp;.</TT></P>

					</li>
</ul>
				<p><b><i>string</i></b><b>::pointer</b></p>

				<ul>
<li><p>The type of character pointers.</p>
</li>
<lI><P>It is equivalent to <TT CLaSS="monofont">allocator_type::pointer.</tT></P>
</lI>
<LI><P>For type <TT clasS="monofont">string,</TT> it is equivalent to <Tt claSS="monofont">char*.</TT></p>

					</li>
</uL>
				<P><B><I>string</i></b><b>::const_pointer</b></p>

				<ul>
<li><p>The type of constant character pointers.</p>
</li>
<li><p>It is equivalent to <tt claSS="monofont">allocator_type::const_pointer.</TT></P>
</Li>
<LI><p>For type <TT cLASS="monofont">string,</TT> it is equivalent to <tt clASS="monofont">const char*.</Tt></p>

					</li>
</UL>
				<P><B><i>string</i></b><b>::iterator</B></P>

				<UL>
<li><p>The type of iterators.</p>
</li>
<li><p>The exact type is implementation defined.</p>
</li>
<li><p>For type <tt clasS="monofont">string,</TT> it is typically <TT ClASs="monofont">char*.</TT></p>

					</LI>
</UL>
				<P><B><i>string</i></b><b>::const_iterator</B></P>

				<UL>
<li><p>The type of constant iterators.</p>
</LI>
<LI><p>The exact type is implementation defined.</p>
</li>
<LI><P>For type <Tt class="monofont">string,</tt> it is typically <tt class="monofont">const char*.</tt></p>

					</li>
</uL>
				<P><B><I>string</I></B><b>::reverse_iterator</B></P>

				<uL>
<Li><P>The type of reverse iterators.</P>
</LI>
<LI><p>It is equivalent to <tt cLASS="monofont">reverse_iterator&lt;iterator&gt;.</tt></p>

					</lI>
</UL>
				<P><b><i>string</i></b><B>::const_reverse_iterator</B></P>

				<Ul>
<li><p>The type of constant reverse iterators.</p>
</li>
<li><p>It is equivalent to <tt class="monofont">reverse_iterator&lt;const_iterator&gt;.</tt></p>

					</lI>
</UL>
				<P><TT cLAsS="monofont">static const</Tt>
					<I>size_type</I>
					<B><I>string</I></B><b>::npos</b></p>

				<uL>
<LI><P>A special value that indicates one of the following:</p>

						<ul>
<lI><P>"not found"</P>
</Li>
<li><p>"all remaining characters"</P>
</LI>
</Ul>
					</li>
<li><p>It is an unsigned integral value that is initialized by <tt class="monofont">-1.</tt></p>
</li>
<li><p>Be careful when you use <TT CLASs="monofont">npos.</TT> See <a href="0201379260_snode91.html#30">Section 11.2.12</A>, for details.</P>

					</LI>
</Ul>
			
			<a naME="2"></A><H4>11.3.2
Create, Copy, and Destroy Operations</h4>
				<p><b><i>string</I></B><B>::string</B>
					<tt clASS="monofont">()</Tt></p>

				<ul>
<li><p>The default constructor.</p>
</li>
<li><p>Creates an empty string.</p>

					</li>
</ul>
				<p><b><i>string</I></B><B>::string</B>
					<TT cLAsS="monofont">(const</Tt>
					<I>string</I><TT CLass="monofont">&amp;</tT>
					<I>str</I><Tt claSS="monofont">)</TT></p>

				<ul>
<lI><P>The copy constructor.</P>
</Li>
<li><p>Creates a new string as a copy of <i>str.</i></p>

					</li>
</ul>
				<p><i>string::</i><b>string</b>
					<tt claSS="monofont">(const</TT>
					<I>string</I><tT ClASs="monofont">&amp;</TT>
					<I>str,</I>
					<TT clasS="monofont">size_type</TT>
					<I>str_idx</i><tt cLASS="monofont">)</tt></p>

				<p><I>string::</I><B>string</B>
					<tt class="monofont">(const</tt>
					<i>string</i><tt class="monofont">&amp;</tt>
					<i>str,</I>
					<TT CLAsS="monofont">size_type</Tt>
					<I>str_idx,</I>
					<tT CLASS="monofont">size_type</tt>
					<i>str_num</i><TT CLass="monofont">)</tT></P>

				<UL>
<li><p>Create a new string that is initialized by, at most, the first <i>str_num</I> characters of <I>str</I> starting with index <I>str_idx.</i></p>
</li>
<li><p>If <i>str_num</i> is missing, all characters from <i>str_idx</i> to the end of <i>str</i> are used.</p>
</li>
<li><p>Throws <tt CLASS="monofont">out_of_range</Tt> if <I>str_idx</I>
							<tT ClASS="monofont">&gt;</TT>
							<I>str.</i><tt cLASS="monofont">size().</tt></p>

					</lI>
</UL>
				<P><i>string::</i><b>string</b>
					<TT CLass="monofont">(const</tt>
					<i>char* cstr</i><tt class="monofont">)</tt></p>

				<ul>
<li><P>Creates a string that is initialized by the C-string <I>cstr.</I></P>
</LI>
<lI><P>The string is initialized by all characters of <i>cstr</I> up to but not including <Tt CLASS="monofont">'\0'.</Tt></p>
</li>
<LI><P>Note that <I>cstr</i> may not be a null pointer (<tt cLASS="monofont">NULL</tt>).</p>
</lI>
<LI><P>Throws <tt class="monofont">length_error</tt> if the resulting size exceeds the maximum number of characters.</p>

					</li>
</ul>
				<p><i>string::</i><b>string</b>
					<tt CLASS="monofont">(const</Tt>
					<I>char* chars,</I>
					<tT ClASS="monofont">size_type</TT>
					<I>chars_len</i><tt cLASS="monofont">)</tt></p>

				<uL>
<LI><P>Creates a string that is initialized by <i>chars_len</i> characters of the character array <i>chars.</i></P>
</LI>
<Li><p>Note that <i>chars</i> must have at least <i>chars_len</i> characters. The characters may have arbitrary values. Thus, <tt class="monofont">'\0'</tt> has no special meaning.</p>
</li>
<li><p>Throws <TT CLASs="monofont">length_error</TT> if <i>chars_len</I> is equal to <I>string</i><TT CLASs="monofont">::npos.</tt></p>
</LI>
<LI><p>Throws <tt cLASS="monofont">length_error</tt> if the resulting size exceeds the maximum number of characters.</p>

					</lI>
</UL>
				<P><i>string::</i><b>string</b>
					<tt class="monofont">(size_type</tt>
					<i>num, char c</i><tt clasS="monofont">)</TT></P>

				<UL>
<lI><P>Creates a string that is initialized by <i>num</I> occurrences of character <I>c.</i></P>
</LI>
<LI><P>Throws <tt clASS="monofont">length_error</Tt> if <i>num</i> is equal to <i>string</I><TT Class="monofont">::npos.</TT></P>
</Li>
<li><p>Throws <tt class="monofont">length_error</tt> if the resulting size exceeds the maximum number of characters.</p>

					</li>
</ul>
				<p><b><i>string</I></B>
					<B>::string</B>
					<TT cLAsS="monofont">(InputIterator</Tt>
					<I>beg,</I>
					<TT CLass="monofont">Input Iterator</tT>
					<I>end</I><Tt claSS="monofont">)</TT></p>

				<ul>
<lI><P>Creates a string that is initialized by all characters of the range [<I>beg,end</I>).</p>
</li>
<li><p>Throws <tt class="monofont">length_error</tt> if the resulting size exceeds the maximum number of characters.</p>

					</li>
</ul>
				<p><B><I>string</I></B><B>::<SuP>~</SuP>string</B>
					<tT CLASS="monofont">()</tt></p>

				<uL>
<LI><P>The destructor.</p>
</li>
<lI><P>Destroys all characters and frees the memory.</P>

					</Li>
</ul>
				<p>Most constructors allow you to pass an allocator as an additional argument (see <A href="0201379260_snode92.html#26">Section 11.3.12</a>).</p>

			
			<h4>11.3.3
Operations for Size and Capacity</h4>
				<h5>Size Operations</h5>
					<p><tt class="monofont">size_type</tt>
						<b><i>string</i></b><B>::size</B>
						<TT CLaSS="monofont">() const</tT></P>

					<p><TT CLASs="monofont">size_type</tt>
						<b><I>string</I></B><B>::length</b>
						<tt cLASS="monofont">() const</tt></p>

					<uL>
<LI><P>Both functions return the actual number of characters.</p>
</li>
<li><p>They are equivalent.</p>
</li>
<li><p>To check whether the string is empty, you should use <tt class="monofont">empty()</tt> because it might be faster.</P>

						</LI>
</UL>
					<P><tT ClASs="monofont">bool</TT>
						<B><I>string</I></B><b>::empty</b>
						<tt CLASs="monofont">() const</tt></p>

					<UL>
<LI><p>Returns whether the string is empty (contains no characters).</p>
</li>
<LI><P>It is equivalent to <I>string</i><tt class="monofont">::size()==0,</tt> but it might be faster.</p>

						</li>
</ul>
					<p><tt claSS="monofont">size_type</TT>
						<B><I>string</i></B><B>::max_size</b>
						<TT cLASS="monofont">() const</TT></p>

					<ul>
<lI><P>Returns the maximum number of characters a string could contain.</P>
</Li>
<li><p>Whenever an operation results in a string that has a length greater than <TT CLass="monofont">max_size(),</tT> the class throws <TT Class="monofont">length_error.</tt></p>

						</li>
</ul>
				
				<h5>Capacity Operations</h5>
					<p><tt class="monofont">size_type</TT>
						<B><I>string</I></B><b>::capacity</B>
						<Tt CLaSS="monofont">() const</TT></P>

					<Ul>
<li><p>Returns the number of characters the string could contain without reallocation.</P>

						</LI>
</Ul>
					<p><tt CLASs="monofont">void</tt>
						<b><I>string</I></B><B>::reserve</b>
						<tt class="monofont">()</tt></p>

					<p><tt class="monofont">Void</tt>
						<B><I>string</I></B><B>::reserve</B>
						<tT ClASs="monofont">(size_type</TT>
						<I>num</I><TT clasS="monofont">)</TT></P>

					<ul>
<li><P>The second form reserves internal memory for at least <I>num</I> characters.</P>
</li>
<li><P>If <I>num</I> is less than the actual capacity, the call is taken as a nonbinding request to shrink the capacity.</P>
</li>
<li><p>If <i>num</i> is less than the current number of characters, the call is taken as a nonbinding request to shrink the capacity to fit the actual number of characters.</p>
</li>
<li><p>If no argument is passed, the call is always a nonbinding shrink-to-fit request.</p>
</li>
<li><p>The capacity is never reduced below the current number of characters.</p>
</lI>
<LI><P>Each reallocation invalidates all references, pointers, and iterators and takes some time, so a preemptive call to <TT cLAsS="monofont">reserve()</Tt> is useful to increase speed and to keep references, pointers, and iterators valid (see <A href="0201379260_snode91.html#15">Section 11.2.5</A>, for details).</p>

						</li>
</uL>
				
			
			<H4>11.3.4
Comparisons</H4>
				<P><tt clASS="monofont">bool</Tt>
					<b><i>comparison</i></B>
					<TT Class="monofont">(const</tt>
					<i>string</i><tt class="monofont">&amp;</tt>
					<i>str1,</i>
					<tt CLASS="monofont">const</Tt>
					<I>string</I><tT ClASS="monofont">&amp;</TT>
					<I>str2</i><tt cLASS="monofont">)</tt></p>

				<p><TT CLass="monofont">bool</tT>
					<B><I>comparison</I></b>
					<tt class="monofont">(const</tt>
					<i>string</i><tt class="monofont">&amp;</tt>
					<I>str,</I>
					<TT CLaSS="monofont">const</tT>
					<I>char* cstr</i><TT CLASs="monofont">)</tt></p>

				<P><TT Class="monofont">bool</TT>
					<B><I>comparison</i></b>
					<tt CLASs="monofont">(const</tt>
					<i>char* cstr,</i>
					<tt class="monofont">const</tt>
					<i>string</i><tt claSS="monofont">&amp;</TT>
					<I>str</I><tT ClASs="monofont">)</TT></P>

				<UL>
<Li><p>The first form returns the result of the comparison of two strings.</p>
</lI>
<LI><P>The second and third form return the result of the comparison of a string with a C-string.</p>
</li>
<lI><P><B><I>comparison</i></b> might be any of the following:</p>

						<pRE>
							
    Operator ==
    operator !=
    operator &lt;
    operator &gt;
    operator &lt;=
    operator &gt;=

						</PRe>

					</li>
<li><p>The values are compared lexicographically (see page 488).</p>

					</li>
</ul>
				<p><tt class="monofont">int</tt>
					<B><I>string</I></B><B>::compare</B>
					<tT ClASs="monofont">(const</TT>
					<I>string</I><TT clasS="monofont">&amp;</TT>
					<I>str</i><tt cLASS="monofont">)</tt>
					<tt CLASs="monofont">const</tt></p>

				<ul>
<li><p>Compares the string <tt class="monofont">*this</tt> with the string <i>str.</i></p>
</LI>
<LI><P>Returns</P>

						<uL>
<Li><P><Tt CLASS="monofont">0</Tt> if both strings are equal</p>
</li>
<LI><P>A value <Tt claSS="monofont">&lt; 0</TT> if <tt clASS="monofont">*this</Tt> is lexicographically less than <i>str</i></p>
</li>
<li><p>A value <tt class="monofont">&gt; 0</tt> if <tt cLASS="monofont">*this</TT> is lexicographically greater than <i>str</I></P>
</lI>
</Ul>
					</LI>
<LI><P>For the comparison, <Tt claSS="monofont">traits::compare()</TT> is used (see <a href="0201379260_snode117.html#2">Section 14.1.2</A>).</P>
</Li>
<li><p>See <A href="0201379260_snode91.html#18">Section 11.2.7</a>, for details.</p>

					</li>
</ul>
				<p><tt class="monofont">int</tt>
					<b><i>string</i></b><B>::compare</B>
					<TT CLaSS="monofont">(size_type</tT>
					<I>idx,</i>
					<TT CLASs="monofont">size_type</tt>
					<i>len,</I>
					<TT Class="monofont">const</TT>
					<I>string</I><tt clASS="monofont">&amp;</Tt>
					<i> str</i><tt class="monofont">)</tt>
					<tt class="monofont">const</tt></P>

				<UL>
<LI><P>Compares, at most, <i>len</I> characters of string <Tt CLaSS="monofont">*this,</TT> starting with index <I>idx</I> with the string <i>str.</i></p>
</lI>
<LI><P>Throws <tt clASS="monofont">out_of_range</Tt> if <i>idx</i>
							<tT CLAss="monofont">&gt; size().</tt></p>
</li>
<li><p>The comparison is performed as just described for <tt class="monofont">compare (</tt><i>str</i><TT CLASs="monofont">).</TT></p>

					</LI>
</uL>
				<P><TT CLass="monofont">int</tT>
					<B><I>string</I></b><b>::compare</b>
					<tT CLAss="monofont">(size_type</tt>
					<I>idx,</I>
					<TT class="monofont">size_type</tt>
					<i>len,</i>
					<tt class="monofont">const</tt>
					<i>string</i><tT CLASS="monofont">&amp;</tT>
					<I>str,</i>
					<TT cLASS="monofont">size_type</TT>
					<i>str_idx,</i>
					<tt CLASs="monofont">size_type</tt>
					<i>str_len</I><TT Class="monofont">) const</TT></P>

				<Ul>
<li><p>Compares, at most, <i>len</i> characters of string <tt class="monofont">*this,</tt> starting with index <i>idx</i> with, at most, <i>str_len</i> characters of string <i>str</i> starting with index <I>str_idx.</I></P>
</LI>
<Li><P>Throws <Tt CLaSS="monofont">out_of_range</TT> if <I>idx</I>
							<tt clASS="monofont">&gt; size().</Tt></p>
</li>
<LI><P>Throws <Tt claSS="monofont">out_of_range</TT> if <i>str_idx</i>
							<tt class="monofont">&gt;</tt>
							<i>str.</i><tt class="monofont">size()</tT><I>.</I></P>
</LI>
<lI><P>The comparison is performed as just described for <tT ClASS="monofont">compare (</TT><I>str</i><tt cLASS="monofont">).</tt></p>

					</lI>
</UL>
				<P><tt clASS="monofont">int</Tt>
					<b><i>string</i></b><b>::compare</b>
					<tt class="monofont">(const</tt>
					<i>char* cstr</i><tt cLASS="monofont">)</TT>
					<tT ClASs="monofont">const</TT></P>

				<UL>
<Li><p>Compares the characters of string <tt CLASs="monofont">*this</tt> with the characters of the C-string <i>cstr.</I></P>
</LI>
<li><p>The comparison is performed as just described for <tT CLAss="monofont">compare (</tt><i>str</i><tt class="monofont">).</tt></p>

					</li>
</ul>
				<p><TT CLASs="monofont">int</TT>
					<b>string::compare</B>
					<Tt CLASS="monofont">(size_type</Tt>
					<i>idx,</i>
					<tT CLAss="monofont">size_type</tt>
					<I>len,</I>
					<TT clasS="monofont">const </TT><I>char* cstr</i><tt class="monofont">)</tt>
					<tt class="monofont">const</tt></p>

				<uL>
<LI><P>Compares, at most, <I>len</I> characters of string <tT ClASs="monofont">*this,</TT> starting with index <I>idx</I> with all characters of the C-string <I>cstr.</I><font SIZE="1"><sup><a HREF="#FOOTNOTE-8">[8]</a></sup></FONT>
</p>
<blockquote><font size="1">
<p cLASS="footnote">
<SUp><A NaME="FOOTNOTE-8">[8]</a></SUP>
The standard specifies the behavior of this form of <TT Class="monofont">compare()</TT> differently: It states that <I>cstr</I> is not considered a C-string but a character array, and passes <tt clASS="monofont">npos</Tt> as its length (in fact, it calls the following form of <tt cLASS="monofont">compare()</tt> by using <tt class="monofont">npos</tt> as an additional parameter). This is a bug in the standard (it would always throw a <tt class="monofont">length_error</tt> exception).</p>
</FONT></BLoCKqUOtE>

							</LI>
<LI><P>The comparison is performed as just described for <tt clASS="monofont">compare(</Tt><i>str</i><tT CLAss="monofont">).</tt></P>
</LI>
<Li><p>Note that <i>cstr</i> may not be a null pointer (<tt class="monofont">NULL</tt>).</p>

					</li>
</ul>
				<p><tt CLASS="monofont">int</Tt>
					<B><I>string</i></B><B>::compare</b>
					<TT CLASs="monofont">(size_type</tt>
					<i>idx,</I><TT Class="monofont">size_type</TT>
					<I>len,</I>
					<tt clASS="monofont">const</Tt>
					<i>char* chars, </i><tt class="monofont">size_type</tt>
					<i>chars_len</i><tt class="monofont">)</TT><TT CLaSS="monofont">const</tT></P>

				<uL>
<LI><P>Compares, at most, <I>len</I> characters of string <tt clASS="monofont">*this,</Tt> starting with index <i>idx</i> with <i>chars_len</I> characters of the character array <I>chars.</I></P>
</li>
<li><P>The comparison is performed as just described for <TT Class="monofont">compare(</tt><i>str</i><tt class="monofont">).</tt></p>
</li>
<lI><P>Note that <I>chars</I> must have at least <I>chars_len</I> characters. The characters may have arbitrary values. Thus, <tT ClASs="monofont">'\0'</TT> has no special meaning.</P>
</LI>
<Li><p>Throws <tt CLASs="monofont">length_error</tt> if <i>chars_len</I> is equal to <I>string</I><Tt claSS="monofont">::npos.</TT></p>

					</li>
</ul>
			
			<h4>11.3.5
Character Access</h4>
				<p><i>char</i><tt class="monofont">&amp;</tt>
					<b><i>string</I></B><B>::operator [ ]</B>
					<TT cLAsS="monofont">(size_type</Tt>
					<I>idx</I><TT CLass="monofont">)</tT></P>

				<P><I>char</i>
					<b><i>string</i></B><B>::operator [ ]</B>
					<Tt claSS="monofont">(size_type</TT>
					<i>idx</i><tt class="monofont">)</tt>
					<tt class="monofont">const</tt></p>

				<UL>
<LI><P>Both forms return the character with the index <I>idx</i> (the first character has index <TT cLAsS="monofont">0</TT>).</P>
</LI>
<li><p>For constant strings, <tT CLAss="monofont">length()</tt> is a valid index and the operator returns the value generated by the default constructor of the character type (for <TT CLass="monofont">string: '\0'</tT>).</P>
</LI>
<li><p>For nonconstant strings, using <tt class="monofont">length()</tt> as index value is invalid.</p>
</li>
<li><p>Passing an invalid index results in undefined behavior.</p>
</li>
<LI><P>The reference returned for the nonconstant string may become invalidated due to string modifications or reallocations (see <A href="0201379260_snode91.html#17">Section 11.2.6</A>, for details).</p>
</LI>
<lI><P>If the caller can't ensure that the index is valid, <TT CLass="monofont">at()</tT> should be used.</P>

					</LI>
</ul>
				<p><i>char</I><TT Class="monofont">&amp;</TT>
					<B><I>string</i></b><b>::at</b>
					<tt class="monofont">(size_type</tt>
					<i>idx</i><tt clasS="monofont">)</TT></P>

				<P><Tt CLaSS="monofont">const</tT>
					<I>char</I><TT Class="monofont">&amp;</TT>
					<B><I>string</i></b><b>::at</b>
					<TT CLass="monofont">(size_type</tT>
					<I>idx</I><Tt class="monofont">)</tt>
					<tt class="monofont">const</tt></p>

				<ul>
<lI><P>Both forms return the character that has the index <I>idx</I> (the first character has index <TT cLAsS="monofont">0</Tt>).</P>
</LI>
<LI><P>For all strings, an index with <tt clASS="monofont">length()</Tt> as value is invalid.</p>
</li>
<LI><P>Passing an invalid index (less than <Tt claSS="monofont">0</TT> or greater than or equal to <tt class="monofont">size()</tt>) throws an <tt class="monofont">out_of_range</tt> exception.</p>
</li>
<LI><P>The reference returned for the nonconstant string may become invalidated due to string modifications or reallocations (see <A href="0201379260_snode91.html#17">Section 11.2.6</A>, for details).</p>
</LI>
<lI><P>If the caller ensures that the index is valid, she can use operator <TT CLass="monofont">[],</tT> which is faster.</P>

					</LI>
</ul>
			
			<a nAME="9"></A><h4>11.3.6
Generating C-Strings and Character Arrays</h4>
				<p><tT CLAss="monofont">const</tt>
					<i>char*</i>
					<b><i>string</i></b><b>::c_str</b>
					<tt class="monofont">() const</tt></P>

				<UL>
<LI><P>Returns the contents of the string as a C-string (an array of characters that has the null character <tT ClASs="monofont">'\0'</TT> appended).</P>
</LI>
<Li><p>The return value is owned by the string. Thus, the caller must neither modify nor free or delete the return value.</p>
</lI>
<LI><P>The return value is valid only as long as the string exists, and as long as only constant functions are called for it.</p>

					</li>
</uL>
				<P><TT clasS="monofont">const</TT>
					<I>char*</i>
					<b><i>string</i></b><b>::data</b>
					<tt class="monofont">() const</tt></p>

				<ul>
<li><P>Returns the contents of the string as a character array.</P>
</LI>
<LI><p>The return value contains all characters of the string without any modification or extension. In particular, no null character is appended. Thus, the return value is, in general, <I>not</I> a valid C-string.</p>
</LI>
<lI><P>The return value is owned by the string. Thus, the caller must neither modify nor free or delete the return value.</P>
</LI>
<Li><p>The return value is valid only as long as the string exists, and as long as only constant functions are called for it.</p>

					</lI>
</UL>
				<P><tt clASS="monofont">size_type</Tt>
					<b><i>string</i></B><B>::copy</B>
					<Tt class="monofont">(</tt><i>char* buf,</i>
					<tt class="monofont">size_type</tt>
					<i>buf_size</i><TT CLASs="monofont">)</TT>
					<tT ClASS="monofont">const</TT></P>

				<p><tt cLASS="monofont">size_type</tt>
					<b><i>string</I></B><B>::copy</B>
					<tt clASS="monofont">(</Tt><i>char* buf,</i>
					<tt class="monofont">size_type</tt>
					<i>buf_size,</i>
					<tt class="monofont">size_type</TT>
					<I>idx</I><TT cLAsS="monofont">)</Tt>
					<TT CLASs="monofont">const</tt></p>

				<UL>
<LI><p>Both forms copy, at most, <i>buf_size</i> characters of the string (beginning with index <i>idx</I>) into the character array <I>buf.</I></P>
</li>
<li><P>They return the number of characters copied.</P>
</LI>
<li><p>No null character is appended. Thus, the contents of <i>buf</i> may be <i>not</i> a valid C-string after the call.</p>
</li>
<li><p>The caller must ensure that <i>buf</i> has enough memory; otherwise, the call results in undefined behavior.</p>
</li>
<li><p>Throws <TT CLASs="monofont">out_of_range</TT> if<i> idx</I>
							<Tt CLASS="monofont">&gt; size().</Tt></p>

					</li>
</UL>
			
			<H4>11.3.7
Modifying Operations</H4>
				<h5>Assignments</h5>
					<p><i>string</I><TT Class="monofont">&amp;</TT>
						<B><I>string</i></b><b>::operator =</b>
						<tt class="monofont">(const</tt>
						<i>string</i><tt clasS="monofont">&amp;</TT>
						<I>str</I><Tt CLaSS="monofont">)</tT></P>

					<P><I>string</I><Tt claSS="monofont">&amp;</TT>
						<b><i>string</i></b><B>::assign</B>
						<TT clasS="monofont">(const</TT>
						<I>string</i><tt class="monofont">&amp;</tt>
						<i>str</i><tt class="monofont">)</tt></P>

					<UL>
<LI><P>Both operations assign the value of string <i>str.</I></P>
</lI>
<Li><P>They return <TT CLAss="monofont">*this.</tt></P>

						</LI>
</Ul>
					<p><i>string</i><TT CLass="monofont">&amp;</tT>
						<B><I>string</I></b><b>::assign</b>
						<tt class="monofont">(const</tt>
						<i>string</i><tt class="monofont">&amp;</TT>
						<I>str,</I>
						<TT cLAsS="monofont">size_type</Tt>
						<I>str_idx,</I>
						<TT CLass="monofont">size_type</tT>
						<I>str_num</I><Tt claSS="monofont">)</TT></p>

					<ul>
<lI><P>Assigns at most <I>str_num</I> characters of <i>str</i> starting with index <i>str_idx.</i></p>
</li>
<li><p>Returns <tt class="monofont">*this.</tt></p>
</lI>
<LI><P>Throws <TT cLAsS="monofont">out_of _range</Tt> if <I>str_idx</I>
								<TT CLass="monofont">&gt;</tT>
								<I>str.</I>
								<Tt claSS="monofont">size().</TT></p>

						</li>
</uL>
					<P><I>string</I>
						<tt class="monofont">&amp;</tt>
						<b><i>string</i></b><b>:: operator =</b>
						<tt clasS="monofont">(const</TT>
						<I>char* cstr)</I></P>

					<p><I>string</I>
						<tT ClASS="monofont">&amp;</TT>
						<B><i>string::assign</i></b>
						<tT CLAss="monofont">(const</tt>
						<I>char* cstr</I><TT clasS="monofont">)</TT></P>

					<ul>
<li><p>Both operations assign the characters of the C-string <i>cstr.</i></p>
</li>
<li><p>They assign all characters of <i>cstr</i> up to but not including <tt clasS="monofont">'\0'.</TT></P>
</LI>
<lI><P>Both operations return <tT ClASS="monofont">*this.</TT></P>
</li>
<li><P>Note that <I>cstr</I> may not be a null pointer (<Tt claSS="monofont">NULL</TT>).</p>
</li>
<lI><P>Both operations throw <TT class="monofont">length_error</tt> if the resulting size exceeds the maximum number of characters.</p>

						</li>
</ul>
					<p><i>string</i><tt clasS="monofont">&amp;</TT>
						<B><I>string</I></b><B>::assign</B>
						<tT ClASS="monofont">(const</TT>
						<I>char* chars,</i>
						<tt cLASS="monofont">size_type</tt>
						<i>chars_len</i><TT CLass="monofont">)</tT></P>

					<UL>
<li><p>Assigns <i>chars_len</i> characters of the character array <i>chars.</i></p>
</li>
<li><p>Returns <tt class="monofont">*this.</tT></P>
</LI>
<LI><p>Note that <I>chars</I> must have at least <i>chars_len</I> characters. The characters may have arbitrary values. Thus, <Tt CLASS="monofont">'\0'</Tt> has no special meaning.</p>
</li>
<LI><P>Throws <Tt claSS="monofont">length_error</TT> if the resulting size exceeds the maximum number of characters.</p>

						</li>
</uL>
					<P><I>string</I><tt class="monofont">&amp;</tt>
						<b><i>string</i></b><b>:: operator =</b>
						<tt clasS="monofont">(</TT><I>char c</I><Tt CLaSS="monofont">)</tT></P>

					<UL>
<LI><p>Assigns character <i>c</i> as the new value.</p>
</LI>
<LI><p>Returns <tt cLASS="monofont">*this.</tt></p>
</lI>
<LI><P>After this call, <tt class="monofont">*this</tt> contains only this single character.</p>

						</li>
</ul>
					<p><i>string</i>
						<tt clASS="monofont">&amp;</TT>
						<B><i>string</I></B><b>::assign</B>
						<Tt CLASS="monofont">(size_type</Tt><i> num, char c)</i></p>

					<UL>
<LI><p>Assigns <i>num</i> occurrences of character <i>c.</I></P>
</LI>
<li><p>Returns <tT CLAss="monofont">*this.</tt></p>
</li>
<li><p>Throws <tt class="monofont">length_error</tt> if <i>num</i> is equal to <I>string</I><TT CLaSS="monofont">::npos.</tT></P>
</lI>
<LI><P>Throws <TT clasS="monofont">length_error</TT> if the resulting size exceeds the maximum number of characters.</P>

						</li>
</ul>
					<P><TT Class="monofont">void</TT>
						<B><I>string</i></b><b>::swap</b>
						<tt class="monofont">(</tt><i>string</i><tt clasS="monofont">&amp;</TT>
						<I>str</I><Tt CLaSS="monofont">)</tT></P>

					<P><TT Class="monofont">void</TT>
						<B>swap</B>
						<tt clASS="monofont">(</Tt><i>string</i><tT CLAss="monofont">&amp;</tt>
						<i>str1, string</i><tt class="monofont">&amp;</tt>
						<i>str2</i><tt clASS="monofont">)</TT></P>

					<uL>
<Li><P>Both forms swap the value of two strings:</P>

							<uL>
<LI><P>The member function swaps the contents of <TT clasS="monofont">*this</TT> and <I>str.</i></p>
</li>
<LI><P>The global function swaps the contents of <I>str1</i> and <i>str2.</i></p>
</LI>
</UL>
						</li>
<li><p>You should prefer these functions over assignment if possible because they are faster. In fact, they are guaranteed to have constant complexity. See <a href="0201379260_snode91.html#19">Section 11.2.8</a>, for details.</p>

						</li>
</ul>
				
				<h5>Appending Characters</h5>
					<p><i>string</i><TT CLASs="monofont">&amp;</TT>
						<b><I>string</I></b><B>::operator +=</B>
						<TT CLass="monofont">(const</tT>
						<I>string</I><Tt claSS="monofont">&amp;</TT>
						<i>str</i><tt CLASs="monofont">)</tt></p>

					<p><i>string</i><tt class="monofont">&amp;</tt>
						<b><i>string</i></b><b>::append</B>
						<TT CLAsS="monofont">(const</Tt>
						<I>string</I><tT CLASS="monofont">&amp;</tt>
						<i>str</i><TT CLass="monofont">)</tT></P>

					<UL>
<li><p>Both operations append the characters of <i>str.</I></P>
</LI>
<li><p>They return <tt class="monofont">*this.</tt></p>
</li>
<li><p>Both operations throw <tt cLASS="monofont">length_error</TT> if the resulting size exceeds the maximum number of characters.</p>

						</LI>
</uL>
					<P><i>string</I><TT CLAss="monofont">&amp;</tt>
						<B><I>string</I></B><b>::append</b>
						<tt CLASs="monofont">(const</tt>
						<i>string</I><TT Class="monofont">&amp;</tt>
						<i>str,</i>
						<tt class="monofont">size_type</tt>
						<i>str_idx,</i>
						<tt CLASS="monofont">size_type</Tt>
						<I>str_num</I><tT ClASS="monofont">)</TT></P>

					<ul>
<li><P>Appends, at most, <I>str_num</I> characters of <I>str,</i> starting with index <i>str_idx.</i></p>
</LI>
<LI><p>Returns <tt cLASS="monofont">*this.</tt></p>
</li>
<li><p>Throws <tt class="monofont">out_of_range</tt> if <i>str_idx</i>
								<tt CLASS="monofont">&gt;</Tt>
								<I>str.</I>
								<tT ClASS="monofont">size().</TT></P>
</li>
<li><P>Throws <TT Class="monofont">length_error</TT> if the resulting size exceeds the maximum number of characters.</P>

						</Li>
</ul>
					<p><I>string</I><TT class="monofont">&amp;</tt>
						<b><i>string</i></b><b>:: operator +=</b>
						<tt class="monofont">(const</tT>
						<I>char* cstr</I><TT ClASs="monofont">)</TT></p>

					<P><I>string</I><TT Class="monofont">&amp;</TT>
						<B><I>string</i></b><b>::append</b>
						<TT CLass="monofont">(const</tT>
						<I>char* cstr</I><Tt class="monofont">)</tt></p>

					<ul>
<li><p>Both operations append the characters of the C-string <i>cstr.</i></p>
</li>
<li><P>They return <TT CLAsS="monofont">*this.</Tt></P>
</Li>
<LI><P>Note that <I>cstr</I> may not be a null pointer (<Tt claSS="monofont">NULL</TT>).</p>
</li>
<lI><P>Both operations throw <TT clasS="monofont">length_error</TT> if the resulting size exceeds the maximum number of characters.</P>

						</li>
</ul>
					<p><i>string</i><tt class="monofont">&amp;</tt>
						<b><i>string</i></b><b>::append</B>
						<TT CLAsS="monofont">(const</Tt>
						<I>char* chars,</I>
						<tT CLASS="monofont">size_type</tt>
						<i>chars_len</i><TT CLass="monofont">)</tT></P>

					<UL>
<li><p>Appends <i>chars_len</I> characters of the character array <I>chars.</I></P>
</li>
<li><p>Returns <tt class="monofont">*this.</tt></p>
</li>
<li><p>Note that <i>chars</I> must have at least <I>chars_len</I> characters. The characters may have arbitrary values. Thus, <TT ClASs="monofont">'\0'</TT> has no special meaning.</p>
</LI>
<LI><P>Throws <Tt claSS="monofont">length_error</TT> if the resulting size exceeds the maximum number of characters.</p>

						</li>
</uL>
					<P><I>string</I><tt clASS="monofont">&amp;</Tt>
						<b><i>string</i></b><b>::append</b>
						<tt class="monofont">(size_type</tt>
						<i>num, char c</i><tt cLASS="monofont">)</TT></p>

					<UL>
<lI><P>Appends <i>num</I> occurrences of character <I>c.</I></P>
</LI>
<li><p>Returns <tT CLAss="monofont">*this.</tt></P>
</LI>
<Li><p>Throws <tt CLASs="monofont">length_error</tt> if the resulting size exceeds the maximum number of characters.</p>

						</li>
</ul>
					<p><i>string</i><tt class="monofont">&amp;</tt>
						<b><I>string</I></B><B>::operator +=</B>
						<Tt CLaSS="monofont">(</tT><I>char c</I><TT Class="monofont">)</TT></P>

					<P><tt clASS="monofont">void</Tt>
						<b><i>string</i></B><B>:: push_back</B>
						<Tt class="monofont">(</tt><i>char c</i><tt class="monofont">)</tt></p>

					<uL>
<LI><P>Both operations append character <I>c.</I></p>
</LI>
<lI><P>Operator <tT CLASS="monofont">+=</tt> returns <tt CLASs="monofont">*this.</tt></p>
</LI>
<LI><p>Both operations throw <tt cLASS="monofont">length_error</tt> if the resulting size exceeds the maximum number of characters.</p>

						</li>
</ul>
					<p><i>string</i><tt class="monofont">&amp;</tt>
						<b><i>string</I></B><B>::append</B>
						<TT cLAsS="monofont">(InputIterator</Tt>
						<I>beg,</I>
						<TT CLass="monofont">InputIterator</tT>
						<I>end</I><Tt claSS="monofont">)</TT></p>

					<ul>
<lI><P>Appends all characters of the range [<I>beg,end</I>).</p>
</li>
<li><p>Returns <tt class="monofont">*this.</tt></p>
</li>
<li><p>Throws <TT CLASs="monofont">length_error</TT> if the resulting size exceeds the maximum number of characters.</p>

						</LI>
</uL>
				
				<H5>Inserting Characters</H5>
					<P><I>string</I><tt clASS="monofont">&amp;</Tt>
						<b>string::insert</b>
						<tT CLAss="monofont">(size_type</tt>
						<I>idx,</I>
						<TT class="monofont">const</tt>
						<i>string</i><tt class="monofont">&amp;</tt>
						<i>str</i><tT CLASS="monofont">)</tT></P>

					<uL>
<Li><P>Inserts the characters of <I>str</I> so that the new characters start with index <I>idx.</I></P>
</li>
<li><P>Returns <TT Class="monofont">*this.</TT></P>
</Li>
<li><p>Throws <TT CLass="monofont">out_of_range</tt> if <i>idx</i>
								<tt class="monofont">&gt; size().</tt></p>
</li>
<li><P>Throws <TT CLAsS="monofont">length_error</Tt> if the resulting size exceeds the maximum number of characters.</P>

						</Li>
</UL>
					<P><I>string</I><Tt claSS="monofont">&amp;</TT>
						<b><i>string</i></b><B>::insert</B>
						<TT clasS="monofont">(size_type</TT>
						<I>idx,</i>
						<tt class="monofont">const</tt>
						<i>string</i><tt class="monofont">&amp;</tt>
						<I>str,</I>
						<TT CLaSS="monofont">size_type</tT>
						<I>str_idx,</i>
						<TT CLASs="monofont">size_type</tt>
						<i>str_num</I><TT Class="monofont">)</TT></P>

					<Ul>
<li><p>Inserts, at most, <I>str_num</I> characters of <I>str,</I> starting with index <i>str_idx,</i> so that the new characters start with index <i>idx.</i></p>
</li>
<li><p>Returns <tt class="monofont">*this.</tt></p>
</lI>
<LI><P>Throws <TT cLAsS="monofont">out_of_range</Tt> if <I>idx</I>
								<TT CLass="monofont">&gt; size().</tT></P>
</LI>
<li><p>Throws <tT CLAss="monofont">out_of_range</tt> if <I>str_idx</I>
								<TT class="monofont">&gt;</tt>
								<i>str.</i><tt class="monofont">size().</tt></p>
</li>
<LI><P>Throws <TT ClASs="monofont">length_error</TT> if the resulting size exceeds the maximum number of characters.</p>

						</LI>
</UL>
					<P><I>string</i><tt cLASS="monofont">&amp;</tt>
						<b><i>string</I></B><B>::insert</B>
						<tt clASS="monofont">(size_</Tt>
						<i>type idx,</i>
						<tt class="monofont">const</tt>
						<i>char* cstr</i><tt class="monofont">)</TT></P>

					<UL>
<Li><P>Inserts the characters of the C-string <I>cstr</i> so that the new characters start with index <I>idx.</I></p>
</LI>
<LI><P>Returns <Tt claSS="monofont">*this.</TT></p>
</li>
<lI><P>Note that <I>cstr</I> may not be a null pointer (<tt clASS="monofont">NULL</Tt>).</p>
</li>
<li><p>Throws <tt class="monofont">out_of_range</tt> if <i>idx</i>
								<tt cLASS="monofont">&gt; size().</TT></p>
</LI>
<lI><P>Throws <tT CLASS="monofont">length_error</tt> if the resulting size exceeds the maximum number of characters.</p>

						</lI>
</UL>
					<P><i>string</i><tt CLASs="monofont">&amp;</tt>
						<b><I>string</I></B><B>::insert</b>
						<tt class="monofont">(size_type</tt>
						<i>idx,</i>
						<tt class="monofont">const</tt>
						<I>char* chars,</I>
						<TT CLaSS="monofont">size_type</tT>
						<I>chars_len</i><TT CLASs="monofont">)</tt></p>

					<UL>
<LI><p>Inserts <i>chars_len</i> characters of the character array <i>chars</I> so that the new characters start with index <I>idx.</I></P>
</li>
<li><P>Returns <TT Class="monofont">*this.</tt></p>
</li>
<li><p>Note that <i>chars</i> must have at least <i>chars_len</i> characters. The characters may have arbitrary values. Thus, <tt claSS="monofont">'\0'</TT> has no special meaning.</P>
</Li>
<LI><p>Throws <TT cLASS="monofont">out_of_range</TT> if <i>idx</i>
								<tt CLASs="monofont">&gt; size().</tt></p>
</LI>
<LI><p>Throws <tt cLASS="monofont">length_error</tt> if the resulting size exceeds the maximum number of characters.</p>

						</li>
</ul>
					<p><i>string</i><tt class="monofont">&amp;</tt>
						<b><i>string</I></B>
						<B>::insert</B>
						<TT cLAsS="monofont">(size_type</Tt>
						<I>idx,</I>
						<TT CLass="monofont">size_type</tT>
						<I>num, char c</I><Tt claSS="monofont">)</TT></p>

					<p><tt CLASs="monofont">void</tt>
						<b><i>string</i></b><i> ::</i><b>insert</b>
						<tt class="monofont">(iterator</tt>
						<i>pos,</I>
						<TT CLAsS="monofont">size_type</Tt>
						<I>num, char c</I><tT CLASS="monofont">)</tt></p>

					<uL>
<LI><P>Both forms insert <i> num</i> occurrences of character <i> c</i> at the position specified by <I> idx</I> or <I> pos</I> respectively.</p>
</li>
<lI><P>The first form inserts the new characters so that they start with index <I> idx.</I></p>
</li>
<li><p>The second form inserts the new characters before the character to which iterator <i>pos</i> refers.</p>
</li>
<li><p>Note that the overloading of these two functions results in a possible ambiguity. If you pass <tt class="monofont">0</TT> as first argument, it can be interpreted as an index (which is typically a conversion to <TT CLaSS="monofont">unsigned</tT>) or as an iterator (which is often a conversion to <Tt CLASS="monofont">char*</Tt>). So in this case you should pass an index as the exact type. For example:</p>

							<prE>
								
    string s;
    ...
    s.insert (0,1, ' ') ;                   //<I>ERROR: ambiguous</I>
    s.insert((string::size_type)0,1,' ');   //<I>OK</i>
</pre>
</LI>
<LI><p>Both forms return <tt cLASS="monofont">*this.</tt></p>
</li>
<li><p>Both forms throw <tt class="monofont">out_of_range</tt> if <i>idx</i>
								<tt CLASS="monofont">&gt; size().</Tt></P>
</Li>
<LI><p>Both forms throw <TT CLASs="monofont">length_error</tt> if the resulting size exceeds the maximum number of characters.</p>

						</LI>
</UL>
					<p><tt cLASS="monofont">iterator </tt><b><i>string</I></B>
						<B>::insert</B>
						<tt class="monofont">(iterator</tt>
						<i>pos, char c</i>
						<tt class="monofont">)</tt></p>

					<UL>
<LI><P>Inserts a copy of character <I>c</i> before the character to which iterator <I>pos</I> refers.</p>
</LI>
<lI><P>Returns the position of the character inserted.</P>
</LI>
<Li><p>Throws <tt CLASs="monofont">length_error</tt> if the resulting size exceeds the maximum number of characters.</p>

						</LI>
</UL>
					<p><tt cLASS="monofont">void</tt>
						<b><i>string</i> ::insert</b>
						<tt class="monofont">(iterator</tt>
						<i>pos,</i>
						<tt clASS="monofont">InputIterator</TT>
						<I>beg,</i>
						<TT cLAsS="monofont">InputIterator</TT>
						<I>end</I>
						<Tt claSS="monofont">)</TT></p>

					<ul>
<lI><P>Inserts all characters of the range [<I> beg,end</I> ) before the character to which iterator <i>pos</i> refers.</p>
</lI>
<LI><P>Throws <tt class="monofont">length_error</tt> if the resulting size exceeds the maximum number of characters.</p>

						</li>
</ul>
				
				<h5>Erasing Characters</h5>
					<p><tt clASS="monofont">void</TT>
						<B><i>string</I></B>
						<b>::clear</B>
						<Tt CLASS="monofont">()</Tt></p>

					<p><i>string</I><TT Class="monofont">&amp;</TT>
						<B><I>string</i></b>
						<b>::erase</b>
						<TT CLass="monofont">()</tt></p>

					<ul>
<li><p>Both functions delete all characters of the string. Thus, the string is empty after the call.</p>
</li>
<li><p><tt clASS="monofont">erase()</TT> returns <Tt CLaSS="monofont">*this.</tT></P>

						</LI>
</UL>
					<p><i>string</i><tT CLAss="monofont">&amp;</tt>
						<B><I>string</I></B>
						<b>::erase</b>
						<tt CLASs="monofont">(size_type</tt>
						<i>idx</i>
						<tt class="monofont">)</tt></p>

					<p><i>string</i><tt cLASS="monofont">&amp;</TT>
						<b><I>string</I></b><I> ::</I><b>erase</B>
						<TT CLAss="monofont">(size_type</tt>
						<I>idx,</I>
						<TT clasS="monofont">size_type</TT>
						<I>len</i>
						<tt cLASS="monofont">)</tt></p>

					<ul>
<li><p>Both forms erase, at most, <i>len</i> characters of <tt class="monofont">*this,</tt> starting at index <i>idx.</i></P>
</LI>
<LI><P>They return <tT ClASs="monofont">*this.</TT></P>
</LI>
<Li><p>If <i>len</i> is missing, all remaining characters are removed.</P>
</LI>
<Li><p>Both forms throw <tt CLASs="monofont">out_of_range</tt> if <i>idx</I>
								<TT Class="monofont">&gt; size().</tt></p>

						</li>
</ul>
					<p><i>string</i><tt class="monofont">&amp;</TT>
						<B><I>string</I></B>
						<b>::erase</B>
						<Tt CLaSS="monofont">(iterator</TT>
						<I>pos</I><tt clASS="monofont">)</Tt></p>

					<p><i>string</I><TT Class="monofont">&amp;</TT>
						<B><I>string</i></b>
						<b>::erase</b>
						<tt class="monofont">(iterator</tt>
						<i>beg,</i>
						<tt clasS="monofont">iterator</TT>
						<I>end</I>
						<Tt CLaSS="monofont">)</tT></P>

					<UL>
<LI><p>Both forms erase the single character at iterator position <i>pos</i> or all characters of the range [<i> beg,end</I>) respectively.</P>
</LI>
<li><p>They return the first character after the last character removed (thus, the second form returns <i>end</I>)<FONt sizE="1"><SUP><a href="#FOOTNOTE-9">[9]</a></sup></font>
</p>
<blockquOTE><FONt SIzE="1">
<P cLASS="footnote">
<SUp><a naME="FOOTNOTE-9">[9]</A></Sup>
The standard specifies that the second form of this function returns the position after <i>end.</i> This is a bug in the standard.</P>
</FONt></bloCKQUote>

								
						</li>
</ul>
				
				<h5>Changing the Size</h5>
					<p><tt class="monofont">void</tt>
						<b><i>string</I></B>
						<B>::resize</B>
						<TT cLAsS="monofont">(size_type</Tt>
						<I>num</I><TT CLass="monofont">)</tT></P>

					<P><Tt claSS="monofont">void</TT>
						<b><i>string</i></b>
						<B>::resize</B>
						<TT class="monofont">(size_type</tt>
						<i>num, char c</i>
						<tt class="monofont">)</tt></p>

					<ul>
<LI><P>Both forms change the number of characters of <TT ClASs="monofont">*this</TT> to <i>num.</I> Thus, if <I>num</I> is not equal to <TT Class="monofont">size(),</TT> they append or remove characters at the end according to the new size.</P>
</Li>
<li><p>If the number of characters increases, the new characters are initialized by <I>c.</I> If <I>c</I> is missing, the characters are initialized by the default constructor of the character type (for <tt clASS="monofont">string: '\0'</Tt>).</p>
</li>
<li><p>Both forms throw <tt class="monofont">length_error</tt> if <i>num</i> is equal to <i>string</i>
								<tT CLASS="monofont">::npos.</tT></P>
</lI>
<Li><P>Both forms throw <TT CLAss="monofont">length_error</tt> if the resulting size exceeds the maximum number of characters.</P>

						</LI>
</Ul>
				
				<h5>Replacing Characters</h5>
					<p><I>string</I><TT clasS="monofont">&amp;</TT>
						<B><i>string</i></b>
						<b>::replace</b>
						<tt class="monofont">(size_type</tt>
						<i>idx,</i>
						<tt claSS="monofont">size_type</TT>
						<I>len,</I>
						<tT ClASs="monofont">const</TT>
						<I>string</I><TT clasS="monofont">&amp;</TT>
						<I>str</i><tt cLASS="monofont">)</tt></p>

					<p><I>string</I><TT class="monofont">&amp;</tt>
						<b><i>string</i></b>
						<b>::replace</b>
						<tt class="monofont">(iterator</tT>
						<I>beg,</I>
						<TT ClASs="monofont">iterator</TT>
						<i>end,</I>
						<TT CLAss="monofont">const</tt>
						<I>string</I><TT clasS="monofont">&amp;</TT>
						<I>str</i><tt cLASS="monofont">)</tt></p>

					<ul>
<li><p>The first form replaces, at most, <i>len</i> characters of <tt class="monofont">*this,</tt> starting with index <i>idx,</i> with all characters of <I>str.</I></P>
</LI>
<Li><P>The second form replaces all characters of the range [<I> beg,end</i>) with all characters of <I>str.</I></p>
</LI>
<LI><P>Both forms return <Tt claSS="monofont">*this.</TT></p>
</li>
<lI><P>Both forms throw <TT clasS="monofont">out_of_range</TT> if<I> idx</i>
								<tt class="monofont">&gt; size().</tt></p>
</li>
<li><p>Both forms throw <tt claSS="monofont">length_error</TT> if the resulting size exceeds the maximum number of characters.</P>

						</Li>
</UL>
					<p><I>string</I><tT CLASS="monofont">&amp;</tt>
						<b><i>string</I></B><B>::replace</B>
						<tt clASS="monofont">(size_type</Tt>
						<i>idx,</i>
						<tT CLAss="monofont">size_type</tt>
						<i>len,</i>
						<tt class="monofont">const</tt>
						<i>string</i><tt clASS="monofont">&amp;</TT>
						<I>str,</i>
						<TT cLAsS="monofont">size_type</TT>
						<I>str_idx,</I>
						<Tt claSS="monofont">size_type</TT>
						<i>str_num</i><tt CLASs="monofont">)</tt></p>

					<UL>
<LI><p>Replaces, at most, <i>len</i> characters of <tt class="monofont">*this,</tt> starting with index <i>idx,</i> with at most <i>str_num</i> characters of <i>str</i> starting with index <i>str_idx.</i></p>
</LI>
<LI><P>Returns <Tt CLaSS="monofont">*this.</tT></P>
</LI>
<LI><p>Throws <tt cLASS="monofont">out_of_range</tt> if <i>idx</i>
								<TT CLass="monofont">&gt; size().</tT></P>
</LI>
<li><p>Throws <tt class="monofont">out_of_range</tt> if <i>str_idx</i>
								<tt class="monofont">&gt;</TT>
								<I>str.</I>
								<TT cLAsS="monofont">size().</Tt></P>
</LI>
<LI><P>Throws <tt clASS="monofont">length_error</Tt> if the resulting size exceeds the maximum number of characters.</p>

						</li>
</UL>
					<P><I>string</i><tt cLASS="monofont">&amp;</tt>
						<b><i>string</i></b><b>::replace</b>
						<tt class="monofont">(size_type</tt>
						<i>idx,</i>
						<tt CLASS="monofont">size_type</Tt>
						<I>len,</I>
						<tT ClASS="monofont">const</TT>
						<I>char* cstr</i><tt cLASS="monofont">)</tt></p>

					<p><I>string</I><TT clasS="monofont">&amp;</TT>
						<B><i>string</i></b><b>::replace</b>
						<tt class="monofont">(iterator</tt>
						<i>beg,</i>
						<tt claSS="monofont">iterator</TT>
						<I>end,</I>
						<tT ClASs="monofont">const</TT>
						<I>char* cstr</I><TT clasS="monofont">)</TT></P>

					<ul>
<li><P>Both forms replace, at most, <I>len</I> characters of <Tt claSS="monofont">*this,</TT> starting with index <i>idx,</i> or all characters of the range [<i>beg,end</i>), respectively, with all characters of the C-string <i>cstr.</i></p>
</li>
<li><p>Both forms return <tt class="monofont">*this.</tt></P>
</LI>
<LI><P>Note that <i>cstr</I> may not be a null pointer (<Tt CLaSS="monofont">NULL</TT>).</P>
</Li>
<li><p>Both forms throw <TT CLass="monofont">out_of_range</tT> if <I>idx</I>
								<Tt claSS="monofont">&gt; size().</TT></p>
</li>
<li><p>Both forms throw <tt class="monofont">length_error</tt> if the resulting size exceeds the maximum number of characters.</p>

						</li>
</ul>
					<p><I>string</I><TT CLaSS="monofont">&amp;</tT>
						<B><i>string</I></B><B>::replace</B>
						<TT clasS="monofont">(size_type</TT>
						<I>idx,</i>
						<tt cLASS="monofont">size_type</tt>
						<i>len,</i>
						<TT CLass="monofont">const</tt>
						<i>char* chars,</i>
						<tt class="monofont">size_type</tt>
						<i>chars_len</i><tt cLASS="monofont">)</TT></p>

					<P><I>string</i><TT cLASS="monofont">&amp;</TT>
						<b><i>string</i></b><B>::replace</B>
						<TT clasS="monofont">(iterator</TT>
						<I>beg,</i>
						<tt cLASS="monofont">iterator</tt>
						<i>end,</i>
						<tt class="monofont">const</tt>
						<i>char* chars,</i>
						<tt clasS="monofont">size_type</TT>
						<I>chars_len</I><Tt CLaSS="monofont">)</tT></P>

					<UL>
<LI><p>Both forms replace, at most, <i>len</i> characters of <tT CLAss="monofont">*this,</tt> starting with index <I>idx,</I> or all characters of the range [<I>beg,end</I>), respectively, with <i>chars_len</i> characters of the character array <i>chars.</i></P>
</LI>
<Li><p>They return <tt class="monofont">*this.</tt></p>
</li>
<li><p>Note that <i>chars</i> must have at least <i>chars_len</i> characters. The characters may have arbitrary values. Thus, <TT CLASs="monofont">'\0'</TT> has no special meaning.</p>
</LI>
<lI><P>Both forms throw <TT CLass="monofont">out_of_range</tT> if <I>idx</I>
								<Tt claSS="monofont">&gt; size().</TT></p>
</li>
<lI><P>Both forms throw <TT class="monofont">length_error</tt> if the resulting size exceeds the maximum number of characters.</p>

						</li>
</ul>
					<p><i>string</i><tt clasS="monofont">&amp;</TT>
						<B><I>string</I></b><B>::replace</B>
						<tT ClASS="monofont">(size_type</TT>
						<I>idx,</i>
						<tt cLASS="monofont">size_type</tt>
						<i>len,</i>
						<TT CLass="monofont">size_type</tT>
						<I>num, char c</I><Tt class="monofont">)</tt></p>

					<p><i>string</i><tt class="monofont">&amp;</tt>
						<B><I>string</I></B><B>::replace</B>
						<tT ClASs="monofont">(iterator</TT>
						<I>beg,</I>
						<TT clasS="monofont">iterator</TT>
						<I>end,</i>
						<tt cLASS="monofont">size_type</tt>
						<i>num, char c</i><TT CLass="monofont">)</tt></p>

					<ul>
<li><p>Both forms replace, at most, <i>len</i> characters of <tt class="monofont">*this,</tT> starting with index <I>idx,</I> or all characters of the range [<I>beg,end</I>), respectively, with <I>num</i> occurrences of character <I>c</I></p>
</LI>
<lI><P>They return <TT CLass="monofont">*this.</tT></P>
</LI>
<li><p>Both forms throw <tT CLAss="monofont">out_of_range</tt> if <I>idx</I>
								<TT class="monofont">&gt; size().</tt></p>
</li>
<li><p>Both forms throw <tt class="monofont">length_error</tT> if the resulting size exceeds the maximum number of characters.</P>

						</LI>
</UL>
					<p><I>string</I><tT ClASS="monofont">&amp;</TT>
						<B><i>string</i></b><b>::replace</B>
						<TT Class="monofont">(iterator</TT>
						<I>beg,</I>
						<tt clASS="monofont">iterator</Tt>
						<i>end</i>
						<tt class="monofont">InputIterator</tt>
						<i>newBeg,</i>
						<tt class="monofont">InputIterator</TT>
						<I>newEnd</I><TT cLAsS="monofont">)</Tt></P>

					<UL>
<LI><P>Replaces all characters of the range [<i>beg,end</i>) with all characters of the range [<i>newBeg,newEnd</i>).</P>
</LI>
<Li><p>Returns <tt CLASs="monofont">*this.</tt></p>
</LI>
<LI><p>Throws <tt class="monofont">length_error</tt> if the resulting size exceeds the maximum number of characters.</p>

						</li>
</ul>
				
			
			<h4>11.3.8
Searching and Finding</h4>
				<h5>Find a Character</h5>
					<p><tT CLASS="monofont">size_type</tT>
						<B><i>string</I></B><b>::find</B>
						<TT CLAss="monofont">(</tt><I>char c</I><TT clasS="monofont">)</TT>
						<Tt claSS="monofont">const</TT></p>

					<p><tt class="monofont">size_type</tt>
						<b><i>string</i></b><b>::flnd</b>
						<tt clASS="monofont">(</TT><I>char c,</i>
						<TT cLAsS="monofont">size_type</TT>
						<I>idx</I><Tt claSS="monofont">)</TT>
						<tt clASS="monofont">const</Tt></p>

					<p><tT CLAss="monofont">size_type</tt>
						<b><i>string</i></b><b>::rfind</b>
						<tt class="monofont">(</tt><i>char c</i><TT CLASs="monofont">)</TT>
						<tT ClASS="monofont">const</TT></P>

					<p><tt cLASS="monofont">size_type</tt>
						<b><i>string</I></B><B>::rfind</B>
						<tt clASS="monofont">(</Tt><i>char c,</i>
						<tt class="monofont">size_type</tt>
						<i>idx</i><tt class="monofont">)</TT>
						<TT CLaSS="monofont">const</tT></P>

					<uL>
<LI><P>These functions search for the first/last character <I>c</I> (starting at index <i>idx</i>).</p>
</lI>
<LI><P>The <tt clASS="monofont">find()</Tt> functions search forward and return the first substring.</p>
</li>
<LI><P>The <Tt class="monofont">find()</tt> functions search backward and return the last substring.</p>
</li>
<li><p>These functions return the index of the character when successful or <i>string</i><tt claSS="monofont">::npos</TT> if they fail.</P>

						</Li>
</UL>
				
				<h5>Find a Substring</H5>
					<P><tT CLASS="monofont">size_type</tt>
						<b><i>string</I></B><B>::find</B>
						<tt clASS="monofont">(const</Tt>
						<i>string</i><tT CLAss="monofont">&amp;</tt>
						<i>str</i><tt class="monofont">)</tt>
						<tt clasS="monofont">const</TT></P>

					<P><Tt CLaSS="monofont">size_type</tT>
						<B><I>string</I></B><B>::find</b>
						<tt cLASS="monofont">(const</tt>
						<i>string</i><TT CLass="monofont">&amp;</tT>
						<I>str,</I>
						<Tt class="monofont">size_type</tt>
						<i>idx</i><tt class="monofont">)</tt>
						<tt CLASS="monofont">const</Tt></P>

					<P><tT ClASS="monofont">size_type</TT>
						<B><i>string</i></b><b>::rfind</B>
						<TT Class="monofont">(const</TT>
						<I>string</I><tt clASS="monofont">&amp;</Tt>
						<i>str</i><tt class="monofont">)</tt>
						<tt class="monofont">const</tt></P>

					<P><TT CLaSS="monofont">size_type</tT>
						<B><i>string</I></B><B>::rfind</B>
						<TT clasS="monofont">(const</TT>
						<I>string</i><tt cLASS="monofont">&amp;</tt>
						<i>str,</i>
						<TT CLass="monofont">size_type</tt>
						<i>idx</i><tt class="monofont">)</tt>
						<tt claSS="monofont">const</TT></P>

					<Ul>
<LI><p>These functions search for the first/last substring <I>str</I> (starting at index <i>idx</I>).</P>
</LI>
<LI><p>The <tt cLASS="monofont">find()</tt> functions search forward and return the first substring.</p>
</lI>
<LI><P>The <tt clASS="monofont">find()</Tt> functions search backward and return the last substring.</p>
</li>
<li><p>These functions return the index of the first character of the substring when successful or <i>string</i><tt class="monofont">::npos</tt> if they fail.</p>

						</li>
</UL>
					<P><TT ClASs="monofont">size_type</TT>
						<b><I>string</I></B><B>::find</B>
						<Tt claSS="monofont">(const</TT>
						<i>char* cstr</i><tt CLASs="monofont">)</tt>
						<tT CLAss="monofont">const</tt></p>

					<p><tt class="monofont">size_type</tt>
						<b><i>string</i></b><b>::find</b>
						<TT CLASs="monofont">(const</TT>
						<i>char* cstr,</I>
						<Tt CLASS="monofont">size_type</Tt>
						<i>idx</i><tT CLAss="monofont">)</tt>
						<TT CLass="monofont">const</tT></P>

					<P><Tt class="monofont">size_type</tt>
						<b><i>string</i></b><b>::rfind</b>
						<tt class="monofont">(const</TT>
						<I>char* cstr</I><TT cLAsS="monofont">)</Tt>
						<TT CLASs="monofont">const</tt></p>

					<P><TT Class="monofont">size_type</TT>
						<B><I>string</i></b><b>::rfind</b>
						<TT CLass="monofont">(const</tt>
						<i>char* cstr,</i>
						<tt class="monofont">size_type</tt>
						<i>idx</i><tt cLASS="monofont">)</TT>
						<tT ClASs="monofont">const</TT></P>

					<UL>
<Li><p>These functions search for the first/last substring that has the characters of the C-string <i>cstr</i> (starting at index <I>idx</I>).</P>
</Li>
<li><p>The <TT CLass="monofont">find()</tT> functions search forward and return the first substring.</P>
</LI>
<li><p>The <tt class="monofont">rfind()</tt> functions search backward and return the last substring.</p>
</li>
<li><p>These functions return the index of the first character of the substring when successful or <i>string</i><tT CLASS="monofont">::npos</tT> if they fail.</P>
</lI>
<Li><P>Note that <I>cstr</I> may not be a null pointer (<TT Class="monofont">NULL</TT>).</P>

						</Li>
</ul>
					<p><TT CLass="monofont">size_type</tT>
						<B><I>string</I></b><b>::find</b>
						<tt class="monofont">(const</tt>
						<i>char* chars,</i>
						<tt class="monofont">size_type</TT>
						<I>idx,</I>
						<TT cLAsS="monofont">size_type</Tt>
						<I>chars_len</I><TT CLass="monofont">)</tT>
						<TT Class="monofont">const</TT></P>

					<P><tt clASS="monofont">size_type</Tt>
						<b><i>string</i></b><b>::rfind</b>
						<tt class="monofont">(const</tt>
						<i>char* chars,</i>
						<tt cLASS="monofont">size_type</TT>
						<i>idx,</I>
						<Tt CLaSS="monofont">size_type</TT>
						<I>chars_len</I><tt clASS="monofont">)</Tt>
						<tt cLASS="monofont">const</tt></p>

					<uL>
<LI><P>These functions search for the first/last substring that has <i>chars_len</i> characters of the character array <i>chars</i> (starting at index <i>idx</i>).</p>
</li>
<li><p><tt class="monofont">find()</tt> searches forward and returns the first substring.</P>
</LI>
<LI><P><tT ClASs="monofont">find()</TT> searches backward and returns the last substring.</P>
</LI>
<Li><p>These functions return the index of the first character of the substring when successful or <i>string</i><B></B><TT clasS="monofont">::npos</TT> if they fail.</P>
</li>
<li><P>Note that <I>chars</I> must have at least <I>chars_len</i> characters. The characters may have arbitrary values. Thus, <tt class="monofont">'\0'</tt> has no special meaning.</p>

						</li>
</ul>
				
				<h5>Find First of Different Characters</h5>
					<p><tt cLASS="monofont">size_type</TT>
						<b><I>string</I></b><B>::find_first_of</B>
						<tT CLASS="monofont">(const</tt>
						<i>string</i><TT CLass="monofont">&amp;</tT>
						<I>str</I><Tt claSS="monofont">)</TT>
						<tt class="monofont">const</tt></p>

					<p><tt class="monofont">size_type</tt>
						<b><I>string</I></B><B>::find_first_of</B>
						<Tt CLaSS="monofont">(const</tT>
						<I>string</I><TT Class="monofont">&amp;</TT>
						<I>str,</I>
						<tt clASS="monofont">size_type</Tt>
						<i>idx</i><tT CLAss="monofont">)</tt>
						<tt class="monofont">const</tt></p>

					<p><tt clasS="monofont">size_type</TT>
						<B><I>string</I></b><B>::find_first_not_of</B>
						<tT ClASS="monofont">(const</TT>
						<I>string</i><tt cLASS="monofont">&amp;</tt>
						<i>str</i><TT CLass="monofont">)</tT>
						<TT Class="monofont">const</tt></p>

					<p><tt class="monofont">size_type</tt>
						<b><i>string</i></b><B>::find_first_not_of</B>
						<TT CLaSS="monofont">(const</tT>
						<I>string</i><TT CLASs="monofont">&amp;</tt>
						<i>str,</I>
						<TT Class="monofont">size_type</TT>
						<I>idx</I><tt clASS="monofont">)</Tt>
						<tt class="monofont">const</tt></p>

					<ul>
<li><p>These functions search for the first character that is or is not also an element of the string <i>str</i> (starting at index <i>idx</i>).</p>
</LI>
<LI><P>These functions return the index of that character or substring when successful or <B><i>string</I></B><tT ClASS="monofont">::npos</TT> if they fail.</P>

						</li>
</ul>
					<P><TT Class="monofont">size_type</TT>
						<B><I>string</i></b><b>:: find_first_of</b>
						<TT CLass="monofont">(const</tt>
						<i>char* cstr</i><tt class="monofont">)</tt>
						<tt claSS="monofont">const</TT></P>

					<P><tT ClASs="monofont">size_type</TT>
						<B><I>string</I></B><b>::find_first_of</b>
						<tt CLASs="monofont">(const</tt>
						<i>char* cstr,</I>
						<TT Class="monofont">size_type</TT>
						<I>idx</I><tt class="monofont">) const</tt></p>

					<p><tt class="monofont">size_type</tt>
						<b><I>string</I></B><B>::find_first_not_of</B>
						<Tt CLaSS="monofont">(const</tT>
						<I>char* cstr</I><TT Class="monofont">)</TT>
						<TT clasS="monofont">const</TT></P>

					<p><tt cLASS="monofont">size_type</tt>
						<b><i>string</i></b><b>:: find_first_not_of</b>
						<tt class="monofont">(const</tt>
						<i>char* cstr,</i>
						<tt CLASS="monofont">size_type</Tt>
						<I>idx</I><tT ClASS="monofont">)</TT>
						<Tt claSS="monofont">const</TT></p>

					<ul>
<lI><P>These functions search for the first character that is or is not also an element of the C-string <I>cstr</I> (starting at index <i>idx</i>).</p>
</lI>
<LI><P>These functions return the index of that character when successful or <i>string</i><tt class="monofont">::npos</tt> if they fail.</p>
</li>
<li><p>Note that <i>cstr</i> may not be a null pointer (<tt CLASS="monofont">NULL</Tt>).</P>

						</Li>
</UL>
					<p><TT CLASs="monofont">size_type</tt>
						<b><I>string</I></B><B>::find_first_of</b>
						<tt cLASS="monofont">(const</tt>
						<i>char* chars,</i>
						<TT CLass="monofont">size_type</tt>
						<i>idx,</i>
						<tt class="monofont">size_type</tt>
						<i>chars_len</i><tt cLASS="monofont">)</TT>
						<tT ClASs="monofont">const</TT></P>

					<P><TT clasS="monofont">size_type</TT>
						<B><i>string</i></b><b>::find_first_not_of</B>
						<TT Class="monofont">(const</TT>
						<I>char* chars,</I>
						<tt class="monofont">size_type</tt>
						<i>idx,</i>
						<tt class="monofont">size_type</tt>
						<i>chars_len</I><TT CLAsS="monofont">)</Tt>
						<TT cLASS="monofont">const</TT></p>

					<ul>
<lI><P>These functions search for the first character that is or is not also an element of the <I>chars_len</I> characters of the character array <i>chars</i> (starting at index <i>idx</i>).</P>
</LI>
<Li><p>These functions return the index of that character when successful or <b><i>string</I></B><TT class="monofont">::npos</tt> if they fail.</p>
</li>
<li><p>Note that <i>chars</i> must have at least <i>chars_len</i> characters. The characters may have arbitrary values. Thus, <tt clASS="monofont">'\0'</TT> has no special meaning.</P>

						</lI>
</Ul>
					<P><Tt CLASS="monofont">size_type</Tt>
						<b><i>string</i></B><B>::find_first_of</B>
						<Tt claSS="monofont">(</TT><i>char c</i><tt CLASs="monofont">)</tt>
						<tt class="monofont">const</tt></p>

					<p><tt class="monofont">size_type</TT>
						<B><I>string</I></B><b>::find_first_of</B>
						<Tt CLaSS="monofont">(</TT><I>char c,</I>
						<tt clASS="monofont">size_type</Tt>
						<i>idx</i><tT CLAss="monofont">)</tt>
						<TT CLass="monofont">const</tt></p>

					<p><tt class="monofont">size_type</tt>
						<b><i>string</i></b><b>::find_first_not_of</B>
						<TT CLAsS="monofont">(</Tt><I>char c</I><tT CLASS="monofont">)</tt>
						<tt CLASs="monofont">const</tt></p>

					<P><TT Class="monofont">size_type</TT>
						<B><I>string</i></b><b>::find_first_not_of</b>
						<tt class="monofont">(</tt><i>char c,</i>
						<tt clasS="monofont">size_type</TT>
						<I>idx</I><Tt CLaSS="monofont">)</tT>
						<TT CLAss="monofont">const</tt></P>

					<UL>
<Li><p>These functions search for the first character that has or does not have the value <i>c</i> (starting at index <I>idx</I>).</P>
</Li>
<li><p>These functions return the index of that character when successful or <I>string::</I>npos if they fail.</P>

						</Li>
</ul>
				
				<h5>Find Last of Different Characters</h5>
					<p><tt class="monofont">size_type</tt>
						<b><i>string</i></b><b>::find_last_of</b>
						<TT CLASs="monofont">(const</TT>
						<i>string</I><Tt CLASS="monofont">&amp;</Tt>
						<i>str</i><tT CLAss="monofont">)</tt>
						<TT CLass="monofont">const</tT></P>

					<P><Tt class="monofont">size_type</tt>
						<b><i>string</i></b><b>::find_last_of</b>
						<tt class="monofont">(const</TT>
						<I>string</I><TT cLAsS="monofont">&amp;</Tt>
						<I>str,</I>
						<TT CLass="monofont">size_type</tT>
						<I>idx</I><Tt claSS="monofont">)</TT>
						<tt clASS="monofont">const</Tt></p>

					<p><tt class="monofont">size_type</tt>
						<b><i>string</i></b><b>::find_last_not_of</b>
						<tt cLASS="monofont">(const</TT>
						<i>string</I><Tt CLaSS="monofont">&amp;</TT>
						<I>str</I><tt clASS="monofont">)</Tt>
						<tt cLASS="monofont">const</tt></p>

					<p><TT CLass="monofont">size_type</tt>
						<b><i>string</i></b><b>::find_last_not_of</b>
						<tt class="monofont">(const</tt>
						<i>string</I><TT CLAsS="monofont">&amp;</Tt>
						<I>str,</I>
						<tT CLASS="monofont">size_type</tt>
						<i>idx</i><TT CLass="monofont">)</tT>
						<TT Class="monofont">const</TT></P>

					<Ul>
<li><p>These functions search for the last character that is or is not also an element of the string <i>str</i> (starting at index <i>idx</i>).</p>
</li>
<li><p>These functions return the index of that character or substring when successful or <i>string</i><tt claSS="monofont">::npos</TT> if they fail.</P>

						</Li>
</UL>
					<p><TT cLASS="monofont">size_type</TT>
						<b><i>string</i></b><B>::find_last_of</B>
						<TT clasS="monofont">(const</TT>
						<I>char* cstr</i><tt cLASS="monofont">)</tt>
						<tt class="monofont">const</tt></p>

					<p><tt class="monofont">size_type</tT>
						<B><I>string</I></B><B>::find_last_of</b>
						<TT cLAsS="monofont">(const</TT>
						<I>char* cstr,</I>
						<Tt claSS="monofont">size_type</TT>
						<i>idx</i><tt CLASs="monofont">)</tt>
						<tT CLAss="monofont">const</tt></p>

					<p><tt class="monofont">size_type</tt>
						<b><i>string</i></b><b>::find_last_not_of</b>
						<TT CLASs="monofont">(const</TT>
						<i>char* cstr</I><Tt CLASS="monofont">)</Tt>
						<tt cLASS="monofont">const</tt></p>

					<p><TT CLass="monofont">size_type</tT>
						<B><I>string</I></b><b>::find_last_not_of</b>
						<tt class="monofont">(const</tt>
						<i>char* cstr,</i>
						<tt class="monofont">size_type</TT>
						<I>idx</I><TT cLAsS="monofont">)</Tt>
						<TT CLASs="monofont">const</tt></p>

					<UL>
<LI><p>These functions search for the last character that is or is not also an element of the C-string <i>cstr</i> (starting at index <i>idx</I>).</P>
</LI>
<li><p>These functions return the index of that character when successful or <i>string</I><TT Class="monofont">::npos</tt> if they fail.</p>
</li>
<li><p>Note that <i>cstr</i> may not be a null pointer (<tt class="monofont">NULL</TT>).</P>

						</LI>
</Ul>
					<P><Tt CLaSS="monofont">size_type</TT>
						<B><I>string</i></b><b>::find_last_of</b>
						<TT CLass="monofont">(const</tT>
						<I>char* chars,</I>
						<Tt claSS="monofont">size_type</TT>
						<i>idx,</i>
						<tt class="monofont">size_type</tt>
						<i>chars_len</i><tt class="monofont">)</tT>
						<TT CLAsS="monofont">const</Tt></P>

					<P><tT CLASS="monofont">size_type</tt>
						<b><i>string</I></B><B>::find_last_not_of</B>
						<tt clASS="monofont">(const</Tt>
						<i>char* chars,</i>
						<tT CLAss="monofont">size_type</tt>
						<i>idx,</i>
						<tt class="monofont">size_type</tt>
						<i>chars_len</i><tt clASS="monofont">)</TT>
						<Tt CLaSS="monofont">const</tT></P>

					<UL>
<LI><p>These functions search for the last character that is or is not also an element of the <i>chars_len</i> characters of the character array <i>chars</I> (starting at index <I>idx</I>).</P>
</li>
<li><P>These functions return the index of that character when successful or <I>string:</I><Tt claSS="monofont">:npos</TT> if they fail.</p>
</li>
<li><p>Note that <i>chars</i> must have at least <i>chars_len</i> characters. The characters may have arbitrary values. Thus, <tt class="monofont">'\0'</tt> has no special meaning.</p>

						</lI>
</UL>
					<P><TT cLAsS="monofont">size_type</Tt>
						<B><I>string</I></B><B>::find_last_of</B>
						<tt clASS="monofont">(</Tt><i> char c</i><tT CLAss="monofont">) const</tt></P>

					<P><TT class="monofont">size_type</tt>
						<b><i>string</i></b><b>::find_last_of</b>
						<tt class="monofont">(</tT><I>char c,</I>
						<TT ClASs="monofont">size_type</TT>
						<i>idx</I><TT CLAss="monofont">)</tt>
						<TT CLass="monofont">const</tT></P>

					<P><Tt claSS="monofont">size_type</TT>
						<b><i>string</i></b><b>::find_last_not_of</b>
						<tt class="monofont">(</tt><i>char c</i><tt clASS="monofont">)</TT>
						<Tt CLaSS="monofont">const</tT></P>

					<P><TT Class="monofont">size_type</TT>
						<B><I>string</i></b><b>::find_last_not_of</b>
						<TT CLass="monofont">(</tT><I>char c,</I>
						<Tt class="monofont">size_type</tt>
						<i>idx</i><tt class="monofont">)</tt>
						<tt CLASS="monofont">const</Tt></P>

					<Ul>
<LI><p>These functions search for the last character that has or does not have the value <I>c</I> (starting at index <I>idx</I>).</P>
</Li>
<li><p>These functions return the index of that character when successful or <I>string:</I><TT clasS="monofont">:npos</TT> if they fail.</P>

						</li>
</ul>
				
			
			<H4>11.3.9
Substrings and String Concatenation</H4>
				<P><I>string</i>
					<b><i>string</i></b><b>::substr</b>
					<tt class="monofont">() const</tt></p>

				<p><i>string</i>
					<b><I>string</I></B><B>::substr</B>
					<Tt CLaSS="monofont">(size_type</tT>
					<I>idx</I><TT Class="monofont">)</TT>
					<TT clasS="monofont">const</TT></P>

				<p><i>string</i>
					<b><I>string</I></B><B>::substr</b>
					<tt class="monofont">(size_type</tt>
					<i>idx,</i>
					<tt class="monofont">size_type</tt>
					<I>len</I><TT CLaSS="monofont">)</tT>
					<Tt CLASS="monofont">const</Tt></p>

				<ul>
<LI><P>All forms return a substring of, at most, <I>len</i> characters of the string <tt cLASS="monofont">*this</tt> starting with index <i>idx.</i></P>
</LI>
<Li><p>If <i>len</i> is missing, all remaining characters are used.</p>
</li>
<li><p>If <i>idx</i> and <i>len</i> are missing, a copy of the string is returned.</p>
</li>
<li><p>All forms throw <tT CLASS="monofont">out_of_range</tT> if <I>idx</i>
							<TT cLASS="monofont">&gt; size().</TT></p>

					</li>
</uL>
				<P><I>string</I>
					<b>operator +</b>
					<tt CLASs="monofont">(const</tt>
					<i>string</I><TT Class="monofont">&amp;</tt>
					<i>str1,</i>
					<tt class="monofont">const</tt>
					<i>string</i><tt CLASS="monofont">&amp;</Tt>
					<I>str2</I><tT ClASS="monofont">)</TT></P>

				<p><i>string</i>
					<b>operator +</B>
					<TT Class="monofont">(const</TT>
					<I>string</I><tt clASS="monofont">&amp;</Tt>
					<i>str,</i>
					<tt class="monofont">const</tt>
					<i>char* cstr</i><tt class="monofont">)</TT></P>

				<P><I>string</I>
					<b>operator +</B>
					<Tt CLaSS="monofont">(const</TT>
					<I>char* cstr,</I>
					<tt clASS="monofont">const</Tt>
					<i>string</i><tT CLAss="monofont">&amp;</tt>
					<I>str</I><TT class="monofont">)</tt></p>

				<p><i>string</i>
					<b>operator +</b>
					<tt class="monofont">(const</tT>
					<I>string</I><TT ClASs="monofont">&amp;</TT>
					<i>str, char c</I><TT CLAss="monofont">)</tt></P>

				<P><I>string</I>
					<b>operator +</b> (<i>char c,</i>
					<TT CLass="monofont">const</tT>
					<I>string</I><Tt class="monofont">&amp;</tt>
					<i>str</i><tt class="monofont">)</tt></p>

				<uL>
<LI><P>All forms concatenate all characters of both operands and return the sum string.</P>
</Li>
<LI><p>The operands may be any of the following:</P>

						<Ul>
<LI><P>A string</P>
</LI>
<li><p>A C-string</p>
</LI>
<LI><p>A single character</p>
</li>
</UL>
					</LI>
<li><p>All forms throw <tT CLAss="monofont">length_error</tt> if the resulting size exceeds the maximum number of characters.</p>

					</li>
</ul>
			
			<h4>11.3.10
Input/Output Functions</h4>
				<p><i>ostream</i><tt class="monofont">&amp;</TT>
					<B>operator&lt;&lt;</B>
					<TT cLAsS="monofont">(</Tt><I>ostream</I><TT CLass="monofont">&amp;</tT>
					<I>strm,</I>
					<Tt claSS="monofont">const</TT>
					<i>string</i><tt CLASs="monofont">&amp;</tt>
					<i>str</i><tt class="monofont">)</tt></p>

				<ul>
<li><p>Writes the characters of <i>str</I> to the stream <I>strm.</I></P>
</LI>
<lI><P>If <i>strm</I><Tt CLASS="monofont">.width()</Tt> is greater than <tt cLASS="monofont">0,</tt> at most <tt CLASs="monofont">width()</tt> characters are written and <tT CLAss="monofont">width()</tt> is set to <tt class="monofont">0.</tt></p>
</li>
<li><p><i>ostream</i> is the <TT CLASs="monofont">ostream</TT> type <tT ClASS="monofont">basic_ostream</TT><Tt claSS="monofont">&lt;</TT><i>char</i><tt CLASs="monofont">&gt;</tt> according to the character type (see <a href="0201379260_snode102.html#1">Section 13.2.1</a>).</p>

					</li>
</ul>
				<p><i>istream</i><tt class="monofont">&amp;</tt>
					<b>operator &gt;&gt;</b>
					<tT CLASS="monofont"> (</tT><I>istream</i><TT cLASS="monofont">&amp;</TT>
					<i>strm, string</i><tt CLASs="monofont">&amp;</tt>
					<i>str</I><TT Class="monofont">)</TT></P>

				<Ul>
<li><p>Reads the characters of the next word from <i>strm</i> into the string <i>str.</i></p>
</li>
<li><p>If the <tt class="monofont">skipws</TT> flag is set for <I>strm,</I> leading whitespaces are ignored.</P>
</Li>
<LI><p>Characters are extracted until any of the following happens:</P>

						<Ul>
<LI><P><I>strm.</I><Tt claSS="monofont">width()</TT> is greater than <tt clASS="monofont">0</Tt> and <tt cLASS="monofont">width()</tt> characters are stored</p>
</li>
<li><p><i>strm.</i> good() is <tt class="monofont">false</tt> (which might cause an appropriate exception)</p>
</lI>
<LI><P><TT cLAsS="monofont">isspace</Tt>
									<TT CLASs="monofont">(</tt><i>c, strm.</I>
									<TT Class="monofont">getloc())</TT> is true for the next character <I>c</I></p>
</li>
<lI><P><I>str</I><tt class="monofont">.max_size()</tt> characters are stored</p>
</li>
</ul>
					</li>
<li><p>The internal memory is reallocated accordingly.</p>
</lI>
<LI><P><I>istream</I> is the istream type <tT ClASs="monofont">basic_istream&lt;</TT><I>char</I><TT clasS="monofont">&gt;</TT> according to the character type (see <A href="0201379260_snode102.html#1">Section 13.2.1</A>).</P>

					</LI>
</ul>
				<p><i>istream</I><TT Class="monofont">&amp;</tt>
					<b>getline</b>
					<tt class="monofont">(</tt><i>istream</i><tt CLASS="monofont">&amp;</Tt>
					<I>strm, string</I><tT ClASS="monofont">&amp;</TT>
					<I>str</i><tt cLASS="monofont">)</tt></p>

				<p><I>istream</I><TT clasS="monofont">&amp;</TT>
					<B>getline</b>
					<tt class="monofont">(</tt><i>istream</i><tt class="monofont">&amp;</tt>
					<I>strm, string</I><TT CLaSS="monofont">&amp;</tT>
					<I>str, char delim</i><TT CLASs="monofont">)</tt></p>

				<UL>
<LI><p>Read the characters of the next line from <i>strm</i> into the string <i>str.</I></P>
</LI>
<li><p>All characters (including leading whitespaces) are extracted until any of the following happens:</p>

						<UL>
<LI><p><i>strm.</i>
									<tt class="monofont">width()</tt> is greater than <tt class="monofont">0</tt> and <TT CLASs="monofont">width()</TT> characters are stored</p>
</LI>
<lI><P><I>strm.</I>good() is <TT clasS="monofont">false</TT> (which might cause an appropriate exception)</P>
</li>
<li><P><I>delim</I> or <I>strm.</i>
									<tt cLASS="monofont">widen('\n')</tt> is extracted</p>
</li>
<li><p><i>str.</i><tt class="monofont">max_size()</tt> characters are stored</p>
</lI>
</UL>
					</LI>
<Li><P>The line delimiter is extracted but not appended.</P>
</lI>
<Li><P>The internal memory is reallocated accordingly.</P>
</LI>
<LI><p><i>istream</i> is the istream type <tT CLAss="monofont">basic_istream&lt;</tt><I>char</I><TT clasS="monofont">&gt;</TT> according to the character type (see <A href="0201379260_snode102.html#1">Section 13.2.1</a>).</p>

					</li>
</ul>
			
			<h4>11.3.11
Generating Iterators</h4>
				<p><tt class="monofont">iterator</tT>
					<B><I>string</I></B><B>::begin</b>
					<TT cLAsS="monofont">()</TT></P>

				<P><Tt claSS="monofont">const_iterator</TT>
					<b><i>string</i></b><B>::begin</B><TT clasS="monofont">() const</TT></P>

				<ul>
<li><p>Both forms return a random access iterator for the beginning of the string (the position of the first character).</p>
</li>
<li><p>If the string is empty, the call is equivalent to <tt class="monofont">end().</tt></p>

					</LI>
</UL>
				<P><Tt CLaSS="monofont">iterator</tT>
					<B><I>string</I></B><B>::end</b>
					<tt cLASS="monofont">()</tt></p>

				<p><TT CLass="monofont">const_iterator</tT>
					<B><I>string</I></b><b>::end</b><tt class="monofont">() const</tt></p>

				<ul>
<li><p>Both forms return a random access iterator for the end of the string (the position after the last character).</p>
</li>
<LI><P>Note that the character at the end is not defined. Thus, *<I>s.</I>
							<Tt CLaSS="monofont">end()</tT> results in undefined behavior.</P>
</LI>
<LI><p>If the string is empty, the call is equivalent to <tt cLASS="monofont">begin().</tt></p>

					</lI>
</UL>
				<P><tt clASS="monofont">reverse_iterator</Tt>
					<b><i>string</i></b><b>::rbegin</b>
					<tt class="monofont">()</tt></p>

				<p><tt cLASS="monofont">const_reverse_iterator</TT>
					<b><I>string::</I></b><B>rbegin</B>
					<tT CLASS="monofont">() const</tt></p>

				<uL>
<LI><P>Both forms return a random access iterator for the beginning of a reverse iteration over the string (the position of the last character).</p>
</li>
<lI><P>If the string is empty, the call is equivalent to <TT clasS="monofont">rend().</TT></P>
</li>
<li><p>For details about reverse iterators see <a href="0201379260_snode62.html#1">Section 7.4.1</a>.</p>

					</li>
</ul>
				<p><tt clASS="monofont">reverse_iterator</TT>
					<B><i>string</I></B><b>::rend</B>
					<Tt CLASS="monofont">()</Tt></p>

				<p><tT CLAss="monofont">const_reverse_iterator</tt>
					<B><I>string::</I></B><b>rend</b>
					<tt CLASs="monofont">() const</tt></p>

				<ul>
<li><p>Both forms return a random access iterator for the end of the reverse iteration over the string (the position before the first character).</p>
</li>
<li><p>Note that the character at the reverse end is not defined. Thus, *<i>s.</i><tt clASS="monofont">rend()</TT> results in undefined behavior.</P>
</lI>
<Li><P>If the string is empty, the call is equivalent to <Tt CLASS="monofont">rbegin().</Tt></p>
</li>
<LI><P>For details about reverse iterators see <A href="0201379260_snode62.html#1">Section 7.4.1</A>.</P>

					</LI>
</ul>
			
			<a nAME="26"></A><h4>11.3.12
Allocator Support</h4>
				<p>Strings provide the usual members of classes with allocator support.</p>

				<p><b><i>string</i></b><b>::allocator_type</b></p>

				<ul>
<li><p>The type of the allocator.</p>
</li>
<lI><P>Third template parameter of class <TT CLaSS="monofont">basic_string&lt;&gt;.</tT></P>
</lI>
<LI><P>For type <TT clasS="monofont">string,</TT> it is equivalent to <Tt claSS="monofont">allocator&lt;char&gt;.</TT></p>

					</li>
</uL>
				<P><TT class="monofont">allocator_type</tt>
					<b><i>string</i></b><b>::get_allocator</b>
					<tt class="monofont">() const</tT></P>

				<UL>
<LI><p>Returns the memory model of the string.</P>

					</Li>
</UL>
				<p>Strings also provide all constructors with optional allocator arguments. The following are all of the string constructors, including their optional allocator arguments, according to the standard:</P>

				<PRE>
					
    namespace std {
        template&lt;class charT,
                 class traits = char_traits&lt;charT&gt;,
                 class Allocator = allocator&lt;charT&gt; &gt;
        class basic_string {
          public:
            //<I>default constructor</I>
            explicit basic_string(const Allocator&amp; a = Allocator());


            //<i>copy constructor and substrings</i>
            basic_string(const basic_string&amp; str,
                         size_type str_idx = 0,
                         size_type str_num = npos);
            basic_string(const basic_string&amp; str,
                         size_type str_idx, size_type str_nnm,
                         const Allocator&amp;);


            //<i>constructor for C-strings</i>
            basic_string(const charT* cstr,
                         const Allocator&amp; a = Allocator());


            //<I>constructor for character arrays</I>
            basic_string(const charT* chars, size_type chars_len,
                         const Allocator&amp; a = Allocator());


            //<I>constructor for</I> num <i>occurrences of a character</i>
            basic_string(size_type num, charT c,
                         const Allocator&amp; a = Allocator());


            //<i> constructor for a range of characters</i>
            template&lt;class InputIterator&gt;
            basic_string(InputIterator beg, InputIterator end,
                         const Allocator&amp; a = Allocator());
            ...

        };

   }

				</PRE>

				<P>These constructors behave as described in <a href="0201379260_snode92.html#2">Section 11.3.2</A>, with the additional ability that you can pass your own memory model object. If the string is initialized by another string, the allocator also gets copied.<FOnt size="1"><sup><a href="#FOOTNOTE-10">[10]</a></sup></fonT>
 See <A href="0201379260_cnode121.html">Chapter 15</a> for more details about allocators.</P>
<BlOCkQUOTE><Font sIZE="1">
<P clasS="footnote">
<SUP><a namE="FOOTNOTE-10">[10]</A></SUp>
The original standard states that the default allocator is used when a string gets copied. However, this does not make much sense, so this is the proposed resolution to fix this behavior.</p>
</font></blockquote>

					
			
		</font>
 
<table width="100%" border="0" cellspacing="0" cellpadding="0" bgcolor="#CCCCCC">
<td><font color="black" size=1>I l<font color="#FF0000">@</font>ve RuBoard</td>
<td valign="top" class="v2" align="right"><a href="0201379260_snode91.html"><img src="FILES/previous.gif" width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a> <a href="0201379260_cnode93.html"><img src="FILES/next.gif" width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a></td></table>
</BODY></HTML>