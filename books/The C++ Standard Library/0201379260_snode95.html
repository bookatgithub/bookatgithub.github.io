<HTML><HEAD><META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=iso-8859-1">
<!--SafClassName="docSection1Title"--><!--SafTocEntry="12.1 Complex Numbers"-->
<LINK REL="stylesheet" href="FILES/sbolM.css">
</HEAD>
<BODY link="#354278" vlink="#000066" alink="#000080" topmargin="0">
<table width="100%" border="0" cellspacing="0" cellpadding="0" bgcolor="#CCCCCC">
<td><font color="black" size=1>I l<font color="#FF0000">@</font>ve RuBoard</td>
<td valign="top" class="v2" align="right"><a href="0201379260_cnode93.html"><img src="FILES/previous.gif" width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a> <a href="0201379260_snode96.html"><img src="FILES/next.gif" width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a></td></table>
<FONT><h3>12.1
Complex Numbers</h3>
			<p>The C++ standard library provides the template class <tT CLAss="monofont">complex&lt;&gt;</tt> to operate on complex numbers. Just to remind you: Complex numbers are numbers that have two parts — real and imaginary. The imaginary part has the property that its square is a negative number. In other words, the imaginary part of a complex number is the factor <I>i,</I> which is the square root of minus 1.</P>

			<P>The class <tt clASS="monofont">complex</Tt> is declared in the header file <tt class="monofont">&lt;complex&gt;:</tt></p>

			<pre>
				
    #include &lt;complex&gt;

			</pre>

			<p>In <tt cLASS="monofont">&lt;complex&gt;,</TT> the class <tT ClASs="monofont">complex</TT> is defined as follows:</P>

			<PRE>
				
    namespace std {
        template &lt;class T&gt;
        class complex;
    }

			</pre>

			<p>The template parameter <TT CLass="monofont">T</tT> is used as the scalar type of both the real and the imaginary parts of the complex number.</P>

			<P>In addition, the C++ standard library provides three specializations for <Tt claSS="monofont">float, double,</TT> and <tt class="monofont">long double:</tt></p>

			<pre>
				
   namespace std {
       template&lt;&gt; class complex&lt;float&gt;;
       template&lt;&gt; class complex&lt;double&gt;;
       template&lt;&gt; class complex&lt;long double&gt;;
   }

			</pre>

			<p>These types are provided to allow certain optimizations and some safer conversions from one complex type to the other.</p>

			<h4>12.1.1
Examples Using Class Complex</h4>
				<p>The following program demonstrates some of the abilities of class <TT CLASs="monofont">complex</TT> to create complex numbers, print different representations of complex numbers, and perform some common operations on complex numbers.</p>

				<PRe>
					
   // <I>num/complex1.cpp</I>

   #include &lt;iostream&gt;
   #include &lt;complex&gt;
   using namespace std;


   int main()
   {
       /*<I>complex number with real and imaginary parts</I>
        *<I>-real part:</I> 4.0
        *<i>-imaginary part:</i> 3.0
        */
       complex&lt;double&gt; c1(4.0,3.0);


       /*<i>create complex number from polar coordinates</i>
        *<I>-magnitude:</I>5.0
        *<I>-phase angle:</I>0.75
        */
       complex&lt;float&gt; c2(polar(5.0,0.75));


       <i>// print complex numbers with real and imaginary parts</i>
       cout &lt;&lt; "c1: " &lt;&lt; c1 &lt;&lt; endl;
       cout &lt;&lt; "c2: " &lt;&lt; c2 &lt;&lt; endl;


       <i>//print complex numbers as polar coordinates</i>
       cout &lt;&lt; "c1: magnitude: " &lt;&lt; abs (c1)
            &lt;&lt; " (squared magnitude: " &lt;&lt; norm(c1) &lt;&lt; ") "
            &lt;&lt; " phase angle: " &lt;&lt; arg(c1) &lt;&lt; endl;
       cout &lt;&lt; "c2: magnitude: " &lt;&lt; abs(c2)
            &lt;&lt; " (squared magnitude: " &lt;&lt; norm (c2) &lt;&lt; ") "
            &lt;&lt; " phase angle: " &lt;&lt; arg(c2) &lt;&lt; endl;


       <I>//print complex conjugates</I>
       cout &lt;&lt; "c1 conjugated: " &lt;&lt; conj(c1) &lt;&lt; endl;
       cout &lt;&lt; "c2 conjugated: " &lt;&lt; conj(c2) &lt;&lt; endl;


       <I>//print result of a computation</I>
       cout &lt;&lt; "4.4 + c1 * 1.8: " &lt;&lt; 4.4 + c1 * 1.8 &lt;&lt; endl;


       /*<i>print sum of</i> c1<i> and</i> c2:
        *<I>-note: different types</I>
        */
       cout &lt;&lt; "c1 + c2:        "
            &lt;&lt; c1 + complex&lt;double&gt;(c2.real(),c2.imag()) &lt;&lt; endl;


       <I>// add square root of</I> c1 <i>to</i> c1<i> and print the result</i>
       cout &lt;&lt; "c1 += sqrt(c1): " &lt;&lt; (c1 += sqrt(c1)) &lt;&lt; endl;
   }

				</pre>

				<p>The program might have the following output (the exact output depends on the implementation specific properties of the type <tt class="monofont">double</tt>):</p>

				<pre>
					
   c1: (4,3)
   c2: (3.65844,3.40819)
   c1: magnitude: 5 (squared magnitude: 25) phase angle: 0.643501
   c2: magnitude: 5 (squared magnitude: 25) phase angle: 0.75
   c1 conjugated:  (4,-3)
   c2 conjugated:  (3.65844,-3.40819)
   4.4 + c1 * 1.8: (11.6,5.4)
   c1 + c2:        (7.65844,6.40819)
   c1 += sqrt(c1): (6.12132,3.70711)

				</PRE>

				<P>A second example contains a loop that reads two complex numbers and processes the first complex number raised to the power of the second complex number:</P>

				<PrE>
					
   // <I>num/complex2.cpp</i>

   #include &lt;iostream&gt;
   #include &lt;complex&gt;
   #include &lt;cstdlib&gt;
   #include &lt;limits&gt;
   using namespace std;


   int main()
   {
       complex&lt;long double&gt; c1, c2;


       while (cin.peek() != E0F) {


           <I>// read first complex number</I>
           cout &lt;&lt; "complex number c1: ";
           cin &gt;&gt; c1;
           if (!cin) {
               cerr &lt;&lt; "input error" &lt;&lt; endl;
               return EXIT_FAILURE;
           }


           <i>//read second complex number</I>
           cout &lt;&lt; "complex number c2: ";
           cin &gt;&gt; c2;
           if (!cin) {
               cerr &lt;&lt; "input error" &lt;&lt; endl;
               return EXIT.FAILURE;
           }


           if (c1 == c2) {
               cout &lt;&lt; "c1 and c2 are equal !" &lt;&lt; endl;
           }


           cout &lt;&lt; "c1 raised to the c2: " &lt;&lt; pow(c1,c2)
                &lt;&lt; endl &lt;&lt; endl;


           <I>// skip rest of line</I>
           cin.ignore (numeric_limits&lt;int&gt;::max(),'\n');
       }
   }

				</PRE>

				<p><a href="0201379260_snode95.html#2">Table 12.1</A> shows some possible input and output of this program.</P>

				<a namE="2"></A><P><Table BORDer="1" cellspacing="0" cellpaddING="1" WIDtH="100%">
<CaPTiON><H5>Table 12.1. Possible I/O of <TT Class="monofont">complex2</TT> Example</H5></CaptiON><COlgroUP ALign="left" span="3">
<tr>
<th valign="top">
<font SIZE="2"><B><Tt CLaSS="monofont">c1</tT></B>
								</FONT></th>
<th VALIgn="top">
<foNT SIze="2"><b><tT CLAss="monofont">c2</tt></b>
								</font></th>
<th valign="top">
<foNT SIZE="2"><b>Output</B>
								</FoNT></tH>
</TR>
<TR>
<Td valIGN="top">
<Font sIZE="2"><Tt claSS="monofont">2</TT>
								</font></td>
<td valign="top">
<font sizE="2"><TT CLAsS="monofont">2</Tt>
								</FOnT></TD>
<TD ValigN="top">
<FONt sizE="2"><TT Class="monofont">c1 raised to c2: (4,0)</TT>
								</FOnt></td>
</tr>
<tr>
<td valign="top">
<font sIZE="2"><TT ClASs="monofont">(16)</TT>
								</fONT></TD>
<Td valIGN="top">
<Font sIZE="2"><Tt claSS="monofont">0.5</TT>
								</font></td>
<td valign="top">
<font sizE="2"><TT CLAsS="monofont">c1 raised to c2: (4,0)</Tt>
								</FOnT></TD>
</TR>
<Tr>
<td vALIGn="top">
<fonT SIZe="2"><tt cLASS="monofont">(8,0)</tt>
								</font></td>
<td valign="top">
<font sIZE="2"><TT ClASs="monofont">0.333333333</TT>
								</fONT></TD>
<Td valIGN="top">
<Font sIZE="2"><Tt claSS="monofont">c1 raised to c2: (2,0)</TT>
								</font></td>
</tr>
<tr>
<td valign="top">
<fonT SIZE="2"><Tt CLaSS="monofont">0.99</tT>
								</FONT></Td>
<td vALIGn="top">
<fonT SIZe="2"><tt cLASS="monofont">(5)</tt>
								</font></td>
<td valign="top">
<font sIZE="2"><TT ClASs="monofont">c1 raised to c2: (0.95099,0)</TT>
								</fONT></TD>
</Tr>
<tr>
<tD VALign="top">
<fONT Size="2"><tT CLAss="monofont">(0,2)</tt>
								</font></td>
<td valign="top">
<fonT SIZE="2"><Tt CLaSS="monofont">2</tT>
								</FONT></Td>
<td vALIGn="top">
<fonT SIZe="2"><tt cLASS="monofont">c1 raised to c2: (-4,4.89843e-16)</tt>
								</font></td>
</tr>
<tr>
<td valign="top">
<fONT SIZe="2"><TT cLAsS="monofont">(1.7,0.3)</TT>
								</FONt></td>
<tD VALign="top">
<fONT Size="2"><tT CLAss="monofont">0</tt>
								</font></td>
<td valign="top">
<fonT SIZE="2"><Tt CLaSS="monofont">c1 raised to c2: (1,0)</tT>
								</FONT></Td>
</tr>
<tR>
<TD ValigN="top">
<FONt sizE="2"><TT Class="monofont">(3,4)</tt>
								</font></td>
<td valign="top">
<fONT SIZe="2"><TT cLAsS="monofont">(-4,3)</TT>
								</FONt></td>
<tD VALign="top">
<fONT Size="2"><tT CLAss="monofont">c1 raised to c2: (4.32424e-05,8.91396e-05)</tt>
								</font></td>
</tr>
<tr>
<td valigN="top">
<FONT SiZE="2"><tT ClASS="monofont">(1.7,0.3)</TT>
								</Font></tD>
<TD ValigN="top">
<FONt sizE="2"><TT Class="monofont">(4.3,2.8)</tt>
								</font></td>
<td valign="top">
<fONT SIZe="2"><TT cLAsS="monofont">c1 raised to c2: (-4.17622,4.86871)</TT>
								</FONt></td>
</tR>
</COLgrouP>
</TABle></p>

				<p>Note that you can input a complex number by passing only the real part as a single value with or without parentheses or by passing the real and imaginary parts separated by a comma in parentheses.</P>

			
			<H4>12.1.2
Operations for Complex Numbers</H4>
				<P>The template class <tt class="monofont">complex</tt> provides the operations described in the following subsections.</p>

				<h5>Create, Copy, and Assign Operations</h5>
					<p><a href="0201379260_snode95.html#5">Table 12.2</a> lists the constructors and assignment operations for <tt CLASS="monofont">complex.</Tt> The constructors provide the ability to pass the initial values of the real and the imaginary parts. If they are not passed, they are initialized by the default constructor of the value type.</P>

					<P>The assignment operators are the only way to modify the value of an existing complex number. The computed assignment operators <tT ClASS="monofont">+=, -=, *=,</TT> and <Tt claSS="monofont">/=</TT> add, subtract, multiply, and divide the value of the second operand to, from, by, and into the real part of the first operand. The imaginary part of both operands is left unchanged.</p>

					<p>The auxiliary <tt CLASs="monofont">polar()</tt> function provides the ability to create a complex number that is initialized by polar coordinates (magnitude and phase angle in radians):</p>

					<PRE>
						
   <I>// create a complex number initialized from polar coordinates</i>
   std::complex&lt;double&gt; c2(std::polar(4.2,0.75));

					</pre>

					<p>A problem exists when you have an implicit type conversion during the creation. For example, this notation works:</p>

					<pre>
						
   std::complex&lt;float&gt; c2(std::polar(4.2,0.75));      <i>// OK</i>

					</pre>

					<p>However, the following notation with the equal sign does not:</p>

					<pre>
						
   std::complex&lt;float&gt; c2 = std::polar(4.2,0.75);     <i>// ERROR</i>

					</PRE>

					<A NAmE="5"></A><p><TAbLE BORDer="1" ceLLSPacinG="0" CELlpadDING="1" width="100%">
<caption><h5>Table 12.2. Constructors and Assignment Operations of Class <tt class="monofont">complex&lt;&gt;</tT></H5></CAPTiON><cOLgROUP ALign="left" sPAN="2">
<Tr>
<th vALIGn="top">
<fonT SIZe="2"><b>Expression</b>
									</font></th>
<th valign="top">
<font SIZE="2"><B>Effect</B>
									</fONt></TH>
</tR>
<TR>
<TD ValigN="top">
<FONt sizE="2"><TT Class="monofont">complex c</TT>
									</FOnt></td>
<td valign="top">
<font size="2">Creates a complex number with <tT CLASS="monofont">0</tT> as the real part and <Tt CLaSS="monofont">0</TT> as the imaginary part (<TT clasS="monofont">0 + 0</TT><I>i</i>)
</fonT></TD>
</Tr>
<tr>
<tD VALign="top">
<font size="2"><tt class="monofont">complex c(1.3)</tt>
									</fONT></TD>
<Td VAlIGn="top">
<FONT SIze="2">Creates a complex number with <tt CLASs="monofont">1.3</tt> as the real part and <tT CLAss="monofont">0</tt> as the imaginary part (<TT CLass="monofont">1.3 + 0</tt><i>i</i>)
</font></td>
</tr>
<tr>
<td vaLIGN="top">
<FOnT SiZE="2"><tT CLASS="monofont">complex c(1.3,4.2)</tt>
									</foNT></TD>
<td vaLIGN="top">
<font SIZE="2">Creates a complex number with <tt class="monofont">1.3</tt> as the real part and <tt class="monofont">4.2</tt> as the imaginary part (<tt cLASS="monofont">1.3 + 4.2</TT><i>i</I>)
</FoNT></tD>
</TR>
<TR>
<Td valIGN="top">
<Font sIZE="2"><Tt claSS="monofont">complex c1(c2)</TT>
									</font></td>
<td valign="top">
<font sizE="2">Creates <TT CLAsS="monofont">c1</Tt> as a copy of <TT cLASS="monofont">c2</TT>
									</font></TD>
</TR>
<tr>
<td VALIgn="top">
<foNT SIze="2"><tt class="monofont">polar (4. 2)</tt>
									</font></td>
<td vaLIGN="top">
<FOnT SiZE="2">Creates a temporary complex number from polar coordinates (<tT CLASS="monofont">4.2</tt> as magnitude rho and <tt CLASs="monofont">0</tt> as phase angle theta)
</fONT></Td>
</tr>
<tR>
<TD Valign="top">
<font size="2"><tt class="monofont">polar (4. 2, 0.75)</tT>
									</FONT></Td>
<TD vALiGN="top">
<FONT size="2">Creates a temporary complex number from polar coordinates (<TT CLass="monofont">4.2</tT> as magnitude rho and <TT Class="monofont">0.75</TT> as phase angle theta)
</FOnt></td>
</tr>
<tr>
<td valign="top">
<font sIZE="2"><TT ClASs="monofont">conj (c)</TT>
									</fONT></TD>
<Td valIGN="top">
<Font sIZE="2">Creates a temporary complex number that is the conjugated complex number of <Tt claSS="monofont">c</TT> (the complex number with the negated imaginary part)
</font></td>
</tr>
<tr>
<td valign="top">
<fonT SIZE="2"><Tt CLaSS="monofont">c1 = c2</tT>
									</FONT></Td>
<td vALIGn="top">
<fonT SIZe="2">Assigns the values of <tt cLASS="monofont">c2</tt> to <tt class="monofont">c1</tt>
									</font></td>
</tr>
<tr>
<TD VALIgN="top">
<FoNT sIZE="2"><TT Class="monofont">c1 += c2</TT>
									</FOnt></td>
<TD VAlign="top">
<FONT size="2">Adds the value of <tt class="monofont">c2</tt> to <tt class="monofont">c1</tT>
									</FONT></Td>
</TR>
<tR>
<Td VALIGN="top">
<font SIZE="2"><tt clASS="monofont">c1 -= c2</Tt>
									</fonT></TD>
<Td valign="top">
<font size="2">Subtracts the value of <tt clasS="monofont">c2</TT> from <TT ClASs="monofont">c1</TT>
									</fONT></TD>
</Tr>
<tr>
<tD VALign="top">
<fONT Size="2"><tT CLAss="monofont">c1 *= c2</tt>
									</font></td>
<td valign="top">
<fonT SIZE="2">Multiplies the value of <Tt CLaSS="monofont">c2</tT> by <TT CLAss="monofont">c1</tt>
									</FONT></td>
</tr>
<TR>
<TD valiGN="top">
<FOnt size="2"><tt class="monofont">c1 /= c2</tt>
									</font></td>
<TD VALIgN="top">
<FoNT sIZE="2">Divides the value of <TT Class="monofont">c2</TT> into <TT clasS="monofont">c1</TT>
									</Font></tD>
</TR>
</Colgroup>
</table></p>

					<p>This problem is discussed in the next subsection.</p>

					<p>The auxiliary <tt claSS="monofont">conj()</TT> function provides the ability to create a complex number that is initialized by the conjugated complex value of another complex number (a conjugated complex value is the value with a negated imaginary part):</P>

					<PrE>
						
   std::complex&lt;double&gt; c1(1.1,5.5);
   std::complex&lt;double&gt; c2(std::conj (c1)) ; <I>// initialize with</i>
                                             // complex&lt;double&gt;(1.1,-5.5)

					</PRe>

				
				<H5>Implicit Type Conversions</H5>
					<P>The constructors of the specializations for <TT Class="monofont">float, double,</TT> and <TT clasS="monofont">long double</TT> are designed in such a way that safe conversions such as <Tt claSS="monofont">complex&lt;float&gt;</TT> to <tt class="monofont">complex&lt;double&gt;</tt> are allowed to be implicit, but less safe conversions such as <tt class="monofont">complex&lt;long double&gt;</tt> to <tt cLASS="monofont">complex&lt;double&gt;</TT> must be explicit (see page 542 for the declarations in detail):</p>

					<PRe>
						
   std::complex&lt;float&gt; cf;
   std::complex&lt;double&gt; cd;
   std::complex&lt;long double&gt; cld;
   ...
   std:: complex&lt;double&gt; cd1 = cf;    <I>// OK: safe conversion</I>
   std::complex&lt;double&gt; cd2 = cld;    <i>// ERROR: no implicit conversion</I>
   std::complex&lt;double&gt; cd3(cld);     <I>// OK: explicit conversion</I>

					</PRE>

					<p>In addition, there are no constructors from any other complex type defined. In particular, you can't convert a <tt cLASS="monofont">complex</tt> with an integral value type into a complex with value type <tt CLASs="monofont">float, double,</tt> or <tT CLAss="monofont">long double.</tt> However, you can convert the values by passing the real and imaginary parts as separate arguments:</p>

					<pre>
						
   std::complex&lt;double&gt; cd;
   std::complex&lt;int&gt; ci;
   ...
   std::complex&lt;double&gt; cd4 = ci;    <i>// ERROR: no implicit conversion</i>
   std::complex&lt;double&gt; cd5(ci);     <i>// ERROR: no explicit conversion</i>
   std::complex&lt;double&gt; cd6(ci.real(), ci.imag());  <i>// OK</i>

					</pre>

					<p>Unfortunately, the assignment operators allow less safe conversions. They are provided as template functions for all types. So, you can assign any complex type as long as the value types are convertible<fonT SIZE="1"><SuP><A hREf="#FOOTNOTE-1">[1]</A></SUP></FOnt>
:</p>
<bLOCKquotE><FONt sizE="1">
<P CLass="footnote">
<sup><a name="FOOTNOTE-1">[1]</a></sup>
The fact that constructors for the complex specializations allow only safe implicit conversions, whereas the assignment operations allow any implicit conversion, is probably a mistake in the standard.</p>
</font></bLOCKQUoTE>

					<pRE>
						
   std::complex&lt;double&gt; cd;
   std::complex&lt;long double&gt; cld;
   std::complex&lt;int&gt; ci;
   ...
   cd = ci;     <i>// OK</I>
   cd = cld;    <I>// OK</I>

					</PRE>

					<p>This problem also relates to <tt cLASS="monofont">polar()</tt> and <tt CLASs="monofont">conj().</tt> For example, the following notation works fine:</p>

					<PRE>
						
   std::complex&lt;float&gt; c2(std::polar(4.2,0.75));    <I>// OK</i>

					</pre>

					<p>But, the notation with the equal sign does not:</p>

					<pre>
						
   std::complex&lt;float&gt; c2 = std::polar(4.2,0.75);   <i>// ERROR</i>

					</pre>

					<p>The reason for this is that the expression</p>

					<pre>
						
   std::polar(4.2,0.75)

					</prE>

					<P>creates a temporary <TT CLaSS="monofont">complex&lt;double&gt;</tT> and the implicit conversion from <Tt CLASS="monofont">complex&lt;double&gt;</Tt> to <tt cLASS="monofont">complex&lt;float&gt;</tt> is not defined.<foNT SIze="1"><suP><A HRef="#FOOTNOTE-2">[2]</a></sup></font>
</p>
<blockquote><FONT SIzE="1">
<P cLAsS="footnote">
<SUP><A Name="FOOTNOTE-2">[2]</a></SUP>
There is a minor difference between</P>
</font></BLOCkquoTE>

							<PRe>
								
   X x;
   Y y(x); <i>// explicit conversion</i>


							</pre>

						
					<p>and</p>

					<pre>
						
   X x;
   Y y = x; // <i>implicit conversion</i>


					</pre>

					<p>The former creates a new object of type <tt clASS="monofont">Y</TT> by using an explicit conversion from type <Tt CLaSS="monofont">X,</tT> whereas the latter creates a new object of type <TT CLAss="monofont">Y</tt> by using an implicit conversion.</P>

				
				<H5>Value Access</H5>
					<P><a href="0201379260_snode95.html#10">Table 12.3</A> shows the different functions provided to access the attributes of complex numbers.</P>

					<A name="10"></A><P><TAble border="1" cellspacing="0" cELLPADdINg="1" WIdTH="100%">
<CAPTion><h5>Table 12.3. Operations for Value Access of Class <TT CLass="monofont">complex&lt;&gt;</tT></H5></CAptioN><COLgroup align="left" span="2">
<tr>
<th valIGN="top">
<FONt SIzE="2"><B>Expression</b>
									</FONT></TH>
<th vaLIGN="top">
<font SIZE="2"><b>Effect</b>
									</foNT></TH>
</tr>
<tr>
<td valign="top">
<font size="2"><tT CLASS="monofont">c.real()</tT>
									</FoNT></tD>
<TD VALign="top">
<fONT Size="2">Returns the value of the real part (as a member function)</fONT></Td>
</tr>
<tR>
<TD Valign="top">
<font size="2"><tt class="monofont">real(c)</tT>
									</FONT></Td>
<TD vALiGN="top">
<FONT size="2">Returns the value of the real part (as a global function)</FONT></td>
</tr>
<TR>
<TD valiGN="top">
<FOnt size="2"><tt class="monofont">c.imag()</tt>
									</font></td>
<TD VALIgN="top">
<FoNT sIZE="2">Returns the value of the imaginary part (as a member function)</FONt></td>
</tR>
<TR>
<Td valIGN="top">
<Font sIZE="2"><Tt class="monofont">imag(c)</tt>
									</font></td>
<td valigN="top">
<FONT SiZE="2">Returns the value of the imaginary part (as a global function)</fONt></TD>
</TR>
<TR>
<td vaLIGN="top">
<font SIZE="2"><tt clASS="monofont">abs(c)</Tt>
									</font></td>
<td valign="top">
<font siZE="2">Returns the absolute value of <TT CLaSS="monofont">c</tT><ImG BORDEr="0" widTH="200" HEight="35" src="FILES/root1.gif" Alt="graphics/root1.gif">
									</foNT></TD>
</tr>
<tr>
<td valign="top">
<font size="2"><tT CLASS="monofont">norm(c)</tT>
									</FoNT></tD>
<TD VALign="top">
<fONT Size="2">Returns the squared absolute value of <tT CLAss="monofont">c(c.real()2 + c.imag()2)</tt>
									</FONT></td>
</tr>
<tr>
<td valign="top">
<font sizE="2"><TT CLAsS="monofont">arg(c)</Tt>
									</FOnT></TD>
<TD ValigN="top">
<FONt sizE="2">Returns the angle of the polar representation of <TT Class="monofont">c <IMG Border="0" width="28" height="21" src="FILES/angle.gif" alT="graphics/angle.gif"></TT> (equivalent to <TT ClASs="monofont">atan2(c.imag(), c.real()</TT>) as phase angle)
</fONT></TD>
</Tr>
</colGROUp>
</tabLE></P>

					<P>Note that <tt clASS="monofont">real()</Tt> and <tt class="monofont">imag()</tt> provide only read access to the real and the imaginary parts. To change only the real part or only the imaginary part you must assign a new complex number. For example, the following statement sets the imaginary part of <tt class="monofont">c</tt> to <tt CLASS="monofont">3.7:</Tt></P>

					<PrE>
						
   std::complex&lt;double&gt; c;
   ...
   c = std::complex&lt;double&gt;(c.real(),3.7);

					</PrE>

				
				<H5>Comparison Operations</H5>
					<P>To compare complex numbers, you can only check for equality (<A href="0201379260_snode95.html#12">Table 12.4</a>). The operators <TT CLass="monofont">==</tT> and <TT Class="monofont">!=</TT> are defined as global functions so that one of the operands may be a scalar value. If you use a scalar value as the operand it is interpreted as the real part, with the imaginary part having the default value of its type (which is usually <TT class="monofont">0</tt>).</p>

					<a name="12"></a><p><table bORDER="1" CeLLsPAcING="0" CELlpadDING="1" widtH="100%">
<CAPtion><H5>Table 12.4. Comparison Operations of Class <TT Class="monofont">complex&lt;&gt;</tt></h5></caption><colgrouP ALIGN="left" sPAn="2">
<TR>
<tH VALIGn="top">
<fonT SIZe="2"><b>Expression</b>
									</fONT></Th>
<th vALIGn="top">
<font size="2"><b>Effect</b>
									</font></th>
</tr>
<tr>
<TD VALIgN="top">
<FoNT sIZE="2"><TT Class="monofont">c1 == c2</TT>
									</FOnt></td>
<TD VAlign="top">
<FONT size="2">Returns whether <tt class="monofont">c1</tt> is equal to <tt class="monofont">c2 (c1.real()==c2.real() &amp;&amp; c1.imag()==c2. imag())</tT>
									</FONT></Td>
</TR>
<tR>
<Td VALIGN="top">
<font SIZE="2"><tt clASS="monofont">c == 1.7</Tt>
									</fonT></TD>
<Td valign="top">
<font size="2">Returns whether <tt clasS="monofont">c</TT> is equal to <TT ClASs="monofont">1.7 (c.real()==1.7 &amp;&amp; c.imag()==0.0)</TT>
									</fONT></TD>
</Tr>
<tr>
<tD VALign="top">
<fONT Size="2"><tT CLAss="monofont">1.7 == c</tt>
									</font></td>
<td valign="top">
<fonT SIZE="2">Returns whether <Tt CLaSS="monofont">c</tT> is equal to <TT CLAss="monofont">1.7 (c.real()==1.7 &amp;&amp; c.imag()==0.0)</tt>
									</FONT></td>
</tr>
<TR>
<TD valiGN="top">
<FOnt size="2"><tt class="monofont">c1 != c2</tt>
									</font></td>
<TD VALIgN="top">
<FoNT sIZE="2">Returns whether <TT Class="monofont">c1</TT> differs from <TT clasS="monofont">c2 (c1.real()!=c2.real() || c1.imag() !=c2 imag()).</TT>
									</Font></tD>
</TR>
<Tr>
<td valign="top">
<font size="2"><tt clASS="monofont">c != 1.7</TT>
									</FoNT></tD>
<Td VALIGN="top">
<font SIZE="2">Returns whether <tt clASS="monofont">c</Tt> differs from <tt cLASS="monofont">1.7 (c.real() !=1.7 || c.imag() !=0.0)</tt>
									</font></td>
</tr>
<tr>
<td valign="top">
<fONT SIZe="2"><TT cLAsS="monofont">1.7 != c</TT>
									</FONt></td>
<tD VALign="top">
<fONT Size="2">Returns whether <tT CLAss="monofont">c</tt> differs from <tt class="monofont">1.7 (c.real() !=1.7 || c.imag() !=0.0)</tt>
									</font></td>
</tr>
</COLGROuP>
</TaBLe></P>

					<P>Other comparison operations, such as operator <TT CLass="monofont">&lt;,</tT> are not defined. Although it is not impossible to define an ordering for complex values, such orderings are neither very intuitive nor very useful. Note, for example, that the magnitude of complex numbers by itself is not a good basis to order complex values because two complex values can be very different and yet have identical magnitude (<TT Class="monofont">1</TT> and <TT clasS="monofont">-1</TT> are two such numbers). An add hoc criterion can be added to create a valid ordering. For example, given two complex values <Tt class="monofont">c1</tt> and <tt class="monofont">c2,</tt> you could deem <tt clASS="monofont">c1 &lt; c2</TT> when <Tt CLaSS="monofont">|c1| &lt; |c2|</tT> or, if both magnitudes are equal, when <TT CLAss="monofont">arg(c1) &lt; arg(c2).</tt> However, such a criterion invariably has little or no mathematical meaning.<FONT size="1"><SUP><A href="#FOOTNOTE-3">[3]</A></SUP></font>
</p>
<blockquote><font siZE="1">
<P CLAsS="footnote">
<SuP><A nAME="FOOTNOTE-3">[3]</A></SUp>
<sup>
								</SUP>Thanks to David Vandevoorde for pointing this out.</P>
</font></BLOCkquoTE>

						
					<P>As a consequence, you can't use <Tt class="monofont">complex</tt> as the element type of an associative container (provided you use no user-defined sorting criterion). This is because associative containers use the function object <tt class="monofont">less&lt;&gt;,</tt> which calls operator <tt clASS="monofont">&lt;,</TT> to be able to sort the elements (see <A href="0201379260_snode43.html#1">Section 5.10.1</A>,).</P>

					<p>By implementing a user-defined operator <TT CLASs="monofont">&lt;</tt> you could sort complex numbers and use them in associative containers. Note that you should be very careful not to pollute the standard namespace. For example:</p>

					<PRE>
						
   template &lt;class T&gt;
   bool operator&lt; (const std::complex&lt;T&gt;&amp; c1,
                   const std::complex&lt;T&gt;&amp; c2)
   {
       return std::abs(c1)&lt;std::abs(c2) ||
              (std::abs(c1)==std::abs(c2) &amp;&amp;
               std::arg(c1)&lt;std::arg(c2));
   }

					</Pre>

				
				<h5>Arithmetic Operations</h5>
					<P>Complex numbers provide the four basic arithmetic operations and the negative and positive signs (<A href="0201379260_snode95.html#15">Table 12.5</a>).</p>

					<A NAMe="15"></a><p><table border="1" cellspaCING="0" CElLPaDDiNG="1" WIDTh="100%">
<capTION><h5>Table 12.5. Arithmetic Operations of Class <tt cLASS="monofont">complex&lt;&gt;</tt></h5></cAPTIon><colgroup align="left" span="2">
<tr>
<TH VALIgN="top">
<FoNT sIZE="2"><B>Expression</B>
									</Font></tH>
<TH ValigN="top">
<FONt sizE="2"><B>Effect</B>
									</Font></th>
</tr>
<tr>
<td valign="top">
<font SIZE="2"><TT cLAsS="monofont">c1 + c2</Tt>
									</FONT></TD>
<td vaLIGN="top">
<font SIZE="2">Returns the sum of <tt clASS="monofont">c1</Tt> and <tt class="monofont">c2</tt>
									</font></td>
</tr>
<tr>
<tD VALIGn="top">
<FOnT SiZE="2"><TT CLass="monofont">c + 1.7</tT>
									</FONt></td>
<tD VALign="top">
<fONT Size="2">Returns the sum of <tt class="monofont">c</tt> and <tt class="monofont">1.7</tt>
									</FONT></TD>
</tR>
<Tr>
<TD vALIGN="top">
<Font sIZE="2"><Tt claSS="monofont">1.7 + c</TT>
									</font></TD>
<TD valign="top">
<font size="2">Returns the sum of <tt class="monofont">1.7</TT> and <TT CLaSS="monofont">c</tT>
									</FoNT></TD>
</TR>
<tr>
<td VALIgn="top">
<foNT SIze="2"><tt CLASs="monofont">c1 - c2</tt>
									</font></td>
<td valign="top">
<font SIZE="2">Returns the difference between <TT cLAsS="monofont">c1</Tt> and <TT CLASs="monofont">c2</tt>
									</fONT></Td>
</tr>
<tR>
<TD ValigN="top">
<FONt size="2"><tt class="monofont">c - 1.7</tt>
									</font></td>
<tD VALIGn="top">
<FOnT SiZE="2">Returns the difference between <TT CLass="monofont">c</tT> and <TT Class="monofont">1.7</TT>
									</FOnt></td>
</TR>
<TR>
<td valign="top">
<font size="2"><tt claSS="monofont">1.7 - c</TT>
									</FOnT></Td>
<TD vALIGN="top">
<Font sIZE="2">Returns the difference between <Tt claSS="monofont">1. 7</TT> and <tt clASS="monofont">c</Tt>
									</font></td>
</tr>
<tr>
<td valign="top">
<foNT SIZE="2"><tT ClASs="monofont">c1 * c2</TT>
									</FONT></td>
<td VALIgn="top">
<foNT SIze="2">Returns the product of <tt CLASs="monofont">c1</tt> and <tt class="monofont">c2</tt>
									</font></td>
</tr>
<tR>
<TD VALiGN="top">
<fONt SIZE="2"><TT clasS="monofont">c * 1.7</TT>
									</Font></tD>
<TD ValigN="top">
<FONt size="2">Returns the product of <tt class="monofont">c</tt> and <tt class="monofont">1.7</TT>
									</FONT></tD>
</Tr>
<TR>
<tD VALIGn="top">
<fonT SIZe="2"><tt cLASS="monofont">1.7 * c</tt>
									</foNT></TD>
<td valign="top">
<font size="2">Returns the product of <tt claSS="monofont">1.7</TT> and <TT cLAsS="monofont">c</Tt>
									</FONT></TD>
</tr>
<tr>
<TD VAlign="top">
<FONT size="2"><TT CLass="monofont">c1 / c2</tt>
									</font></td>
<td valign="top">
<foNT SIZE="2">Returns the quotient of <tT ClASs="monofont">c1</TT> and <TT CLass="monofont">c2</tT>
									</FONt></td>
</tR>
<TR>
<Td valIGN="top">
<Font size="2"><tt class="monofont">c / 1.7</tt>
									</font></tD>
<TD VALiGN="top">
<fONt SIZE="2">Returns the quotient of <TT clasS="monofont">c</TT> and <Tt claSS="monofont">1.7</TT>
									</font></TD>
</TR>
<tr>
<td valign="top">
<font size="2"><tt cLASS="monofont">1.7 / c</TT>
									</fONt></TD>
<tD VALIGn="top">
<fonT SIZe="2">Returns the quotient of <tt cLASS="monofont">1.7</tt> and <tt CLASs="monofont">c</tt>
									</font></td>
</tr>
<tr>
<td valign="top">
<FONT SIzE="2"><Tt CLaSS="monofont">- c</TT>
									</FOnt></td>
<TD VAlign="top">
<FONT size="2">Returns the negated value of <TT CLass="monofont">c</tt>
									</font></td>
</tr>
<tr>
<td valiGN="top">
<FONT sIZe="2"><TT cLASS="monofont">+ c</TT>
									</font></TD>
<TD valiGN="top">
<FOnt siZE="2">Returns <TT class="monofont">c</tt>
									</font></td>
</tr>
<tr>
<td vaLIGN="top">
<FOnT SiZE="2"><tT CLASS="monofont">c1 += c2</tt>
									</foNT></TD>
<td vaLIGN="top">
<font SIZE="2">Equivalent to <tt class="monofont">c1 = c1 + c2</tt>
									</font></td>
</tr>
<tr>
<td VALIGN="top">
<fONt SIzE="2"><TT CLAss="monofont">c1 -= c2</tt>
									</FONT></td>
<td VALIgn="top">
<foNT SIze="2">Equivalent to <tt class="monofont">c1 = c1 - c2</tt>
									</font></td>
</tr>
<tr>
<TD VALIgN="top">
<FoNT sIZE="2"><TT Class="monofont">c1 *= c2</TT>
									</FOnt></td>
<TD VAlign="top">
<FONT size="2">Equivalent to <tt class="monofont">c1 = c1 * c2</tt>
									</font></td>
</tr>
<TR>
<TD VAlIGn="top">
<FOnT SIZE="2"><Tt claSS="monofont">c1 /= c2</TT>
									</font></TD>
<TD valiGN="top">
<FOnt size="2">Equivalent to <tt class="monofont">c1 = c1 / c2</tt>
									</font></td>
</TR>
</COLGrOUp>
</TAbLE></P>

				
				<H5>Input/Output Operations</H5>
					<P>Class <tt clASS="monofont">complex</Tt> provides the common I/O operators <tt cLASS="monofont">&lt;&lt;</tt> and <tt CLASs="monofont">&gt;&gt;</tt> (<a href="0201379260_snode95.html#17">Table 12.6</a>).</p>

					<a name="17"></a><p><tablE BORDEr="1" CElLSpACING="0" CellpADDIng="1" wiDTH="100%">
<CaptiON><H5>Table 12.6. I/O Operations of Class <Tt class="monofont">complex&lt;&gt;</tt></h5></caption><colgrOUP ALIgN="left" SpAN="2">
<tR>
<TH VALign="top">
<fONT Size="2"><b>Expression</B>
									</FONt></th>
<tH VALign="top">
<font size="2"><b>Effect</b>
									</font></th>
</tr>
<TR>
<TD VAlIGn="top">
<FOnT SIZE="2"><Tt claSS="monofont">strm &lt;&lt; c</TT>
									</font></TD>
<TD valiGN="top">
<FOnt size="2">Writes the complex number <tt class="monofont">c</tt> to the ostream <tt clasS="monofont">strm</TT>
									</FONt></TD>
</tR>
<Tr>
<TD VALIgn="top">
<foNT SIze="2"><tt CLASs="monofont">strm &gt;&gt; c</tt>
									</fONT></Td>
<td valign="top">
<font size="2">Reads the complex number <tt clASS="monofont">c</TT> from the istream <Tt CLaSS="monofont">strm</tT>
									</FONT></Td>
</tr>
</cOLGRoup>
</tABLE></p>

					<p>The output operator writes the complex number with respect to the actual stream state with the format:</p>

					<pRE>
						
   <I>(realpart, imagpart)</I>

					</pre>

					<p>In particular, the output operator is defined as equivalent to the following implementation:</p>

					<pre>
						
   template &lt;class T, class charT, class traits&gt;
   std::basic_ostream&lt;charT, traits&gt;&amp;
   operator&lt;&lt; (std::basic_ostream&lt;charT, traits&gt;&amp; strm,
               const std::complex&lt;T&gt;&amp; c)
   {
       <i>// temporary value string to do the output with one argument</i>
       std::basic_ostringstream&lt;charT, traits&gt; s;

       s.flags (strm.flags());         <i>// copy stream flags</i>
       s.imbue (strm.getloc());        <i>// copy stream locale</i>
       s.precision(strm.precision());  <i>// copy stream precision</i>

       <i>// prepare the value string</i>
       s &lt;&lt; '(' &lt;&lt; c.real() &lt;&lt; ',' &lt;&lt; c.imag() &lt;&lt; ')' &lt;&lt; std::ends;

       <i>// write the value string</i>
       strm &lt;&lt; s.str();

       return strm;
   }

					</pRE>

					<P>The input operator provides the ability to read a complex number with one of the following formats:</P>

					<PRe>
						
   (<I>realpart, imagpart</I>)
   (<i>realpart</I>)
   <I>realpart</i>

					</PRE>

					<P>If none of the formats fits according to the next characters in the input stream, the <TT clasS="monofont">ios::failbit</TT> is set, which might throw a corresponding exception (see <A href="0201379260_snode104.html#7">Section 13.4.4</A>,).</P>

					<P>Unfortunately, you can't specify the separator of complex numbers between the real and the imaginary parts. So if you have a comma as a "decimal point" (as is the case in German), I/O looks really strange. For example, a complex number with <Tt claSS="monofont">4.6</TT> as the real part and <tt class="monofont">2.7</tt> as the imaginary part would be written as</p>

					<pre>
						
   (4,6,2,7)

					</pre>

					<p>See page 532 for an example of how to use the I/O operations.</p>

				
				<h5>Transcendental Functions</h5>
					<p><A href="0201379260_snode95.html#19">Table 12.7</A> lists the transcendental functions (trigonometric, exponential, and so on) for <tT ClASs="monofont">complex.</TT></P>

					<A NAme="19"></a><p><TABLe borDER="1" CellsPACIng="0" cellpadding="1" width="100%">
<capTION><H5>Table 12.7. Transcendental Functions of Class <Tt CLaSS="monofont">complex&lt;&gt;</tT></H5></CAPTion><cOLGRoup aLIGN="left" span="2">
<TR>
<TH valign="top">
<font size="2"><b>Expression</b>
									</font></tH>
<TH VALiGN="top">
<fONt SIZE="2"><B>Effect</B>
									</font></TH>
</TR>
<tr>
<td VALIgn="top">
<foNT SIze="2"><tt class="monofont">pow(c, 3)</tt>
									</font></td>
<td vaLIGN="top">
<FOnT SiZE="2">Complex power <i><TT CLASs="monofont">c</tt></i><TT CLass="monofont"><sUP>3</SUp></tt>
									</fONT></Td>
</tr>
<tr>
<td valign="top">
<font size="2"><TT CLASs="monofont">pow(c, 1.7)</TT>
									</fONt></TD>
<TD VAlign="top">
<FONT size="2">Complex power <I><TT Class="monofont">c</TT></I><Tt class="monofont"><sup>1.7</sup></tt>
									</font></td>
</tR>
<TR>
<TD VaLIgN="top">
<FoNT SIZE="2"><tt clASS="monofont">pow(c1, c2)</Tt>
									</fonT></TD>
<Td valIGN="top">
<Font size="2">Complex power <i><tt class="monofont">c1<sup>c2</sup></TT></I>
									</FONt></TD>
</tR>
<Tr>
<TD VALIgn="top">
<foNT SIze="2"><tt CLASs="monofont">pow(1.7, c)</tt>
									</fONT></Td>
<td valign="top">
<font size="2">Complex power <tt clASS="monofont">1.7<SUP>C</sUP></tT>
									</FoNT></TD>
</TR>
<tr>
<td VALIgn="top">
<foNT SIze="2"><tt CLASs="monofont">exp(c)</tt>
									</font></td>
<td valign="top">
<font SIZE="2">Base <I>e</I> exponential of <tT ClASs="monofont">c (e<SUP>c</SUP>)</tt>
									</foNT></TD>
</tr>
<tr>
<TD VAlign="top">
<FONT size="2"><tt class="monofont">sqrt(c)</tt>
									</font></td>
<td VALIGN="top">
<fONt SIzE="2">Square root of <TT CLAss="monofont">c (<imG BORder="0" wIDTH="29" heigHT="24" src="FILES/rootc.gif" alt="graphics/rootc.gif">)</tt>
									</font></td>
</tr>
<tr>
<td valIGN="top">
<FONt SIzE="2"><Tt CLASS="monofont">log(c)</Tt>
									</fonT></TD>
<Td valIGN="top">
<Font sIZE="2">Complex natural logarithm of <Tt class="monofont">c</tt> with base <i>e</i> (ln <i>c</i>)
</font></td>
</tr>
<tR>
<TD VALiGN="top">
<fONt SIZE="2"><TT clasS="monofont">log10(c)</TT>
									</Font></tD>
<TD ValigN="top">
<FONt size="2">Complex common logarithm of <tt class="monofont">c</tt> with base 10 (lg <i>c</i>)
</font></tD>
</TR>
<TR>
<Td VAlIGn="top">
<FONT SIze="2"><tt CLASs="monofont">sin(c)</tt>
									</fONT></Td>
<td vALIGn="top">
<font size="2">Sine of <tt class="monofont">c</tt> (sin <i>c</i>)
</fONT></TD>
</Tr>
<TR>
<tD VaLIGN="top">
<FOnt siZE="2"><TT clasS="monofont">cos(c)</TT>
									</Font></tD>
<TD Valign="top">
<font size="2">Cosine of <tt class="monofont">c</tT> (cos <I>c</I>)
</FONt></TD>
</tR>
<Tr>
<TD VALIgn="top">
<foNT SIze="2"><tt CLASs="monofont">tan(c)</tt>
									</fONT></Td>
<td valign="top">
<font size="2">Tangent of <tt clASS="monofont">c</TT> (tan <I>c</i>)
</FOnT></Td>
</TR>
<TR>
<TD valiGN="top">
<FOnt siZE="2"><TT clasS="monofont">sinh(c)</TT>
									</Font></td>
<td valign="top">
<font size="2">Hyperbolic sine of <TT CLASs="monofont">c</TT> (sinh <i>c</I>)
</FoNT></TD>
</TR>
<tr>
<td VALIgn="top">
<foNT SIze="2"><tt CLASs="monofont">cosh(c)</tt>
									</font></td>
<td valign="top">
<font SIZE="2">Hyperbolic cosine of <TT cLAsS="monofont">c</Tt> (cosh <I>c</I>)
</FONT></td>
</tr>
<TR>
<TD valiGN="top">
<FOnt siZE="2"><TT class="monofont">tanh(c)</tt>
									</font></td>
<td valign="top">
<FONT SIzE="2">Hyperbolic tangent of <Tt CLaSS="monofont">c</TT> (tanh <I>c</I>)
</font></TD>
</TR>
</colgROUP>
</tablE></P>

				
			
			<H4>12.1.3
Class <Tt class="monofont">complex&lt;&gt;</tt> in Detail</h4>
				<p>This subsection describes all operations of class <tt class="monofont">complex&lt;&gt;</tt> in detail. In the following definitions, <tt CLASS="monofont">T</Tt> is the template parameter of class <TT cLAsS="monofont">complex&lt;&gt;,</TT> which is the type of the real and the imaginary parts of the <TT Class="monofont">complex</TT> value.</P>

				<H5>Type Definitions</h5>
					<p><b><i>complex::</I></B>
						<I>value_type</I></p>

					<ul>
<lI><P>The type of the real and the imaginary parts.</P>

						</Li>
</ul>
				
				<h5>Create, Copy, and Assign Operations</h5>
					<p><b><i>complex::complex</i></b>
						<tt class="monofont">()</tt></p>

					<uL>
<LI><P>The default constructor.</P>
</Li>
<LI><p>Creates a complex value in which the real and the imaginary parts are initialized by an explicit call of their default constructor. Thus, for fundamental types, the initial value of the real and the imaginary parts is <TT cLASS="monofont">0</TT> (see page 14 for the default value of fundamental types).</p>

						</li>
</uL>
					<P><B><I>complex</i></b><i>::complex</i>
						<TT CLass="monofont">(const T&amp;</tT>
						<I>re</I><Tt class="monofont">)</tt></p>

					<ul>
<li><p>Creates a complex value in which <i>re</i> is the value of the real part, and the imaginary part is initialized by an explicit call of its default constructor (<tt claSS="monofont">0</TT> for fundamental data types).</P>
</Li>
<LI><p>This constructor also defines an automatic type conversion from <TT cLASS="monofont">T</TT> to <tt clASS="monofont">complex.</Tt></p>

						</li>
</UL>
					<P><B><i>complex</i></b><i>::complex</I>
						<TT Class="monofont">(const T&amp;</tt>
						<i>re,</i>
						<tt class="monofont">const T&amp;</tt>
						<i>im</i><tt CLASS="monofont">)</Tt></P>

					<Ul>
<LI><p>Creates a complex value, with <I>re</I> as the real part and <I>im</I> as the imaginary part.</P>

						</Li>
</ul>
					<p><I>complex</I>
						<B>polar</B>
						<tt clASS="monofont">(const T&amp;</Tt>
						<i>rho</i><tT CLAss="monofont">)</tt></p>

					<p><i>complex</i>
						<b>polar</b>
						<tt class="monofont">(const T&amp;</tt>
						<i>rho,</i>
						<TT CLASs="monofont">const T&amp;</TT>
						<i>theta</I><Tt CLASS="monofont">)</Tt></p>

					<ul>
<LI><P>Both forms create and return the complex number that is initialized by polar coordinates.</P>
</li>
<li><P><I>rho</I> is the magnitude.</P>
</li>
<li><P><I>theta</I> is the phase angle in radians (default: <Tt class="monofont">0</tt>).</p>

						</li>
</ul>
					<p><i>complex</i>
						<b>conj</b>
						<tt cLASS="monofont">(const</TT>
						<i>complex</I><Tt CLaSS="monofont">&amp;</TT>
						<I>cmplx</I><tt clASS="monofont">)</Tt></p>

					<ul>
<LI><P>Creates and returns the complex number that is initialized by the conjugated complex value (the value with the negated imaginary part) of <I>cmplx.</i></p>

						</li>
</UL>
					<P><B><i>complex</i></b>
						<b>:: complex</b>
						<tt class="monofont">(const</tt>
						<i>complex</i><tt claSS="monofont">&amp;</TT>
						<I>cmplx</I><tT ClASs="monofont">)</TT></P>

					<UL>
<Li><p>The copy constructor.</p>
</lI>
<LI><P>Creates a new complex as a copy of <i>cmplx.</i></p>
</lI>
<LI><P>Copies the real and imaginary parts.</p>
</li>
<lI><P>In general, this function is provided as both a nontemplate and a template function (see page 11 for an introduction to member templates). Thus, in general, automatic type conversions of the element type are provided.</P>
</Li>
<li><p>However, the specializations for <tt class="monofont">float, double,</tt> and <tt class="monofont">long double</tT> restrict copy constructors, so the less safe conversions from <TT CLAsS="monofont">double</Tt> and <TT cLASS="monofont">long double</TT> to <tt clASS="monofont">float,</Tt> as well as from <tt cLASS="monofont">long double</tt> to <tt CLASs="monofont">double,</tt> must be explicit and allow <i>no</i> other element type conversions:</p>

							<pre class="monofont">
   namespace std {
       template&lt;&gt; class complex&lt;float&gt; {
         public:
           explicit complex(const complex&lt;double&gt;&amp;);
           explicit complex(const complex&lt;long double&gt;&amp;);
           <i>// no other kinds of copy constructors</i>
           ...
   };
   template&lt;&gt; class complex&lt;double&gt; {
     public:
       complex(const complex&lt;float&gt;&amp;);
       explicit complex(const complex&lt;long double&gt;&amp;);<i>
       // no other kinds of copy constructors</i>
       ...
   };
   template&lt;&gt; class complex&lt;long double&gt; {
     public:
       complex(const complex&lt;float&gt;&amp;);
       complex(const complex&lt;double&gt;&amp;);
       <i>// no other kinds of copy constructors</i>
        ...
   };
}
</pRE><P>See page 534 for more information about the implications from this.</P>

						</LI>
</uL>
					<P><i>complex</I><Tt CLASS="monofont">&amp;</Tt>
						<b><i>complex</i></B><I>::operator =</I>
						<Tt claSS="monofont">(const</TT>
						<i>complex</i><tt CLASs="monofont">&amp;</tt>
						<i>cmplx</i><tt class="monofont">)</tt></p>

					<ul>
<li><p>Assigns the value of complex <i>cmplx.</I></P>
</LI>
<LI><p>Returns <TT cLAsS="monofont">*this.</TT></P>
</LI>
<li><p>This function is provided as both a nontemplate and a template function (see page 11 for an introduction to member templates). Thus, automatic type conversions of the element type are provided. (This is also the case for the specializations that are provided by the C++ standard library.)</p>

						</LI>
</UL>
					<p><i>complex</i><tT CLAss="monofont">&amp;</tt>
						<B><I>complex</I></B><i>::operator</i>
						<b>+=</b>
						<tt class="monofont">(const</tt>
						<i>complex</i><tt clasS="monofont">&amp;</TT>
						<I>cmplx</I><Tt CLaSS="monofont">)</tT></P>

					<P><I>complex</I><Tt claSS="monofont">&amp;</TT>
						<b><i>complex</i></b><I>::operator</I>
						<B>-=</B>
						<tt clASS="monofont">(const</Tt>
						<i>complex</i><tt class="monofont">&amp;</tt>
						<i>cmplx</i><tt class="monofont">)</TT></P>

					<P><I>complex</I><tT ClASs="monofont">&amp;</TT>
						<B><I>complex</I></B><i>::operator</i>
						<b>*=</b>
						<TT CLass="monofont">(const</tT>
						<I>complex</I><Tt claSS="monofont">&amp;</TT>
						<i>cmplx</i><tt class="monofont">)</tt></p>

					<p><i>complex</i><tt clasS="monofont">&amp;</TT>
						<B><I>complex</I></b><I>::operator</I>
						<b>/=</B>
						<Tt CLASS="monofont">(const</Tt>
						<i>complex</i><tT CLAss="monofont">&amp;</tt>
						<I>cmplx</I><TT clasS="monofont">)</TT></P>

					<ul>
<li><p>These operations add, subtract, multiply, and divide the value of <i>cmplx</i> to, from, by, and into <tt class="monofont">*this</tt> respectively and store the result in <tt claSS="monofont">*this.</TT></P>
</Li>
<LI><p>They return <TT cLASS="monofont">*this.</TT></p>
</li>
<lI><P>These operations are provided as both a nontemplate and a template function (see page 11 for an introduction to member templates). Thus, automatic type conversions of the element type are provided. (This is also the case for the specializations that are provided by the C++ standard library.)</P>

						</Li>
</ul>
					<p>Note that the assignment operators are the only functions that allow you to modify the value of an existing <TT CLass="monofont">complex.</tT></P>

				
				<H5>Element Access</H5>
					<p><tt class="monofont">T</tt>
						<b><i>complex :: real</i></b>
						<tt class="monofont">() const</TT></P>

					<P><TT cLAsS="monofont">T</Tt>
						<B>real</B>
						<TT CLass="monofont">(const</tT>
						<I>complex</I><Tt claSS="monofont">&amp;</TT>
						<i>cmplx</i><tt CLASs="monofont">)</tt></p>

					<p><tt class="monofont">T</tt>
						<b><i>complex</i></b><i>::imag</i>
						<tT CLASS="monofont">() const</tT></P>

					<p><TT cLASS="monofont">T</TT>
						<b>imag</b>
						<tt CLASs="monofont">(const</tt>
						<i>complex</I><TT Class="monofont">&amp;</TT>
						<I>cmplx</I><tt class="monofont">)</tt></p>

					<ul>
<li><p>These functions return the real or imaginary part respectively.</p>
</li>
<li><p>Note that the return value is not a reference. Thus, you can't use these functions to modify the real or the imaginary parts. To change only the real part or only the imaginary part you must assign a new complex number (see page 536).</P>

						</LI>
</UL>
					<P><tT ClASs="monofont">T</TT>
						<B>abs</B>
						<TT clasS="monofont">(const</TT>
						<I>complex</i><tt cLASS="monofont">&amp;</tt>
						<i>cmplx</i><TT CLass="monofont">)</tt></p>

					<ul>
<li><p>Returns the absolute value (magnitude) of <i>cmplx</i><i>.</i></p>
</li>
<li><p>The absolute value is <IMG BORdER="0" wIDtH="200" HEIGHt="27" src="FILES/root.gif" ALT="graphics/root.gif"></P>

						</li>
</ul>
					<P><TT Class="monofont">T</TT>
						<B>norm</B>
						<tt class="monofont">(const</tt>
						<i>complex</i><tt class="monofont">&amp;</tt>
						<i>cmplx</I><TT CLAsS="monofont">)</Tt></P>

					<Ul>
<LI><P>Returns the squared absolute value (squared magnitude) of<I> cmplx.</I></P>
</li>
<li><P>The squared absolute value is <I>cmplx</I><Tt claSS="monofont">.real()<SUp>2</sup> +</TT>
								<I>cmplx</I><tt class="monofont">.imag()<sup>2</sup>.</tt></p>

						</li>
</ul>
					<p><TT CLASs="monofont">T</TT>
						<b>arg</B>
						<Tt CLASS="monofont">(const</Tt>
						<i>complex</i><tT CLAss="monofont">&amp;</tt>
						<I>cmplx</I><TT clasS="monofont">)</TT></P>

					<ul>
<li><p>Returns the angle of the polar representation <img border="0" width="28" heIGHT="21" src="FILES/angle.gif" ALt="graphics/angle.gif"> of <I>cmplx</I> in radians.</p>
</LI>
<LI><P>It is equivalent to <Tt claSS="monofont">atan2(</TT><i>cmplx</i><tt CLASs="monofont">.imag(),</tt>
								<i>cmplx</I><TT Class="monofont">.real())</tt> as the phase angle.</p>

						</li>
</ul>
				
				<h5>Input/Output Operations</h5>
					<p><i>ostream</i><tt claSS="monofont">&amp;</TT>
						<B>operator &lt;&lt;</B>
						<tT ClASs="monofont">(</TT><I>ostream</I><TT clasS="monofont">&amp;</TT>
						<I>strm,</i>
						<tt cLASS="monofont">const</tt>
						<i>complex</i><TT CLass="monofont">&amp;</tt>
						<i>cmplx</i><tt class="monofont">)</tt></p>

					<ul>
<li><P>Writes the value of <I>cmplx</I> to the stream <I>strm</I> in the format (<I>realpart, imagpart</i>)</P>
</Li>
<LI><p>See page 539 for the exact behavior of this operation.</P>

						</LI>
</UL>
					<P><i>istream</i><tt CLASs="monofont">&amp;</tt>
						<b>operator &gt;&gt;</B>
						<TT Class="monofont">(</TT><I>istream</I><tt class="monofont">&amp;</tt><i> strm, complex</i><tt class="monofont">&amp;</tt><i> cmplx</I><TT CLAsS="monofont">)</Tt></P>

					<Ul>
<LI><P>Reads a new value from <I>strm</I> into <I>cmplx.</i></p>
</li>
<LI><P>Valid input formats are</P>

							<blocKQUOte>
<p><p>(<I>realpart, imagpart</I>)</P>
</P>
<p><p>(<i>realpart</i>)</p>
</p>
<p><p><i>realpart</i></p>
</p>
</blockquotE>
						</LI>
<LI><P>See page 539 for the exact behavior of this operation.</p>

						</LI>
</uL>
				
				<H5>Operators</h5>
					<P><I>complex</I>
						<B>operator+</B>
						<Tt claSS="monofont">(const</TT>
						<i>complex</i><tt CLASs="monofont">&amp;</tt><i> cmplx</I><TT Class="monofont">)</tt></p>

					<ul>
<li><p>The positive sign.</p>
</li>
<li><p>Returns <i>cmplx.</i></p>

						</LI>
</UL>
					<P><I>complex</i>
						<B>operator-</B>
						<tT ClASS="monofont">(const</TT>
						<I>complex</i><tt cLASS="monofont">&amp;</tt><i> cmplx</i><TT CLass="monofont">)</tT></P>

					<UL>
<li><p>The negative sign.</p>
</li>
<li><p>Returns the value of <i>cmplx</i> with the negated real and the negated imaginary parts.</p>

						</li>
</ul>
					<p><i>complex</i>
						<b><i>binary-op</I></B>
						<TT CLaSS="monofont">(const</tT>
						<I>complex</i><TT CLASs="monofont">&amp;</tt><i> cmplx1,</I>
						<TT Class="monofont">const</TT>
						<I>complex</I><tt clASS="monofont">&amp;</Tt><i> cmplx2</i><tt class="monofont">)</tt></p>

					<p><i>complex</i>
						<b><i>binary-op</i></b>
						<tT CLASS="monofont">(const</tT>
						<I>complex</i><TT cLASS="monofont">&amp;</TT><i> cmplx,</i>
						<tt CLASs="monofont">const T&amp;</tt>
						<i>value</I><TT Class="monofont">)</TT></P>

					<P><i>complex</i>
						<b><i>binary-op</i></b>
						<tt class="monofont">(const T&amp;</tt>
						<i>value,</i>
						<tt clASS="monofont">const</TT>
						<I>complex</i><TT cLAsS="monofont">&amp;</TT><I> cmplx</I><Tt claSS="monofont">)</TT></p>

					<ul>
<lI><P>All forms return a complex number with the result of<B><I>binary-op.</i></b></p>
</lI>
<LI><P><b><i>binary-op</i></b> may be any of the following:</p>

							<pre class="monofont">
   operator +
   operator -
   operator *
   operator /
</pre></li>
<li><p>If a scalar value of the element type is passed, it is interpreted as the real part, with the imaginary part having the default value of its type (which is <TT CLASs="monofont">0</TT> for fundamental types).</p>

						</LI>
</uL>
					<P><TT CLass="monofont">bool</tT>
						<B><I>comparison</I></b>
						<tt cLASS="monofont">(const</tt>
						<i>complex</i><TT CLass="monofont">&amp;</tt><i> cmplx1,</i>
						<tt class="monofont">const</tt>
						<i>complex</i><tt cLASS="monofont">&amp;</TT><i>, cmplx2</I><Tt CLaSS="monofont">)</TT></P>

					<P><tt clASS="monofont">bool</Tt>
						<b><i>comparison</i></B>
						<TT Class="monofont">(const</TT>
						<I>complex</I><tt class="monofont">&amp;</tt><i> cmplx,</i>
						<tt class="monofont">const T&amp;</tt>
						<i>value</I><TT CLAsS="monofont">)</Tt></P>

					<P><tT CLASS="monofont">bool</tt>
						<b><i>comparison</I></B>
						<TT clasS="monofont">(const T&amp;</TT>
						<I>value,</i>
						<tt cLASS="monofont">const</tt>
						<i>complex</i><tt class="monofont">&amp;</tt>
						<i>cmplx</i><tt clasS="monofont">)</TT></P>

					<UL>
<lI><P>Returns the result of the comparison of two complex numbers or the result of the comparison of a complex number with a scalar value.</p>
</LI>
<lI><P><B><I>comparison</I></B> may be any of the following:</p>

							<pre CLASs="monofont">
   operator ==
   operator !=
</pre></LI>
<LI><p>If a scalar value of the element type is passed, it is interpreted as the real part, with the imaginary part having the default value of its type (which is <tt cLASS="monofont">0</tt> for fundamental types).</p>
</li>
<li><p>Note that no operators <tt class="monofont">&lt;, &lt;=, &gt;,</tt> and <tt clASS="monofont">&gt;=</TT> are provided.</P>

						</lI>
</Ul>
				
				<H5>Transcendental Functions</H5>
					<p><I>complex</I>
						<B>pow</B>
						<TT clasS="monofont">(const</TT>
						<I>complex</i><tt cLASS="monofont">&amp;</tt><i> base,</i>
						<TT CLass="monofont">int</tt>
						<i>exp</i><tt class="monofont">)</tt></p>

					<p><i>complex</i>
						<b>pow</B>
						<TT CLAsS="monofont">(const</Tt>
						<I>complex</I><tT CLASS="monofont">&amp;</tt><i> base,</i>
						<TT CLass="monofont">const T&amp;</tT>
						<I>exp</I><Tt claSS="monofont">)</TT></p>

					<p><i>complex</i>
						<b>pow</b>
						<tt class="monofont">(const</tt>
						<i>complex</i><tt clASS="monofont">&amp;</TT><I> base,</i>
						<TT cLAsS="monofont">const</TT>
						<I>complex</I><Tt claSS="monofont">&amp;</TT><i> exp</i><tt CLASs="monofont">)</tt></p>

					<P><I>complex</I>
						<B>pow</b>
						<tt class="monofont">(const T&amp;</tt>
						<i>base,</i>
						<tt class="monofont">const</tt>
						<I>complex</I><TT CLaSS="monofont">&amp;</tT><I> exp</i><TT CLASs="monofont">)</tt></p>

					<UL>
<LI><p>All forms return the complex power of <i>base</i> raised to the <i>exp</I>th power, defined as <TT Class="monofont">exp (</TT><I>exp</I><tt class="monofont">*log(</tt><i>base</i><tt class="monofont">)).</tt></p>
</LI>
<LI><P>The branch cuts are along the negative real axis.</P>
</lI>
<Li><P>The value returned for <Tt CLASS="monofont">pow (0,0)</Tt> is implementation defined.</p>

						</li>
</UL>
					<P><I>complex</i>
						<b>exp</b>
						<tT CLAss="monofont">(const</tt>
						<I>complex</I><TT class="monofont">&amp;</tt><i> cmplx</i><tt class="monofont">)</tt></p>

					<ul>
<LI><P>Returns the complex base <I>e</I> exponential of <I>cmplx.</i></P>

						</Li>
</UL>
					<p><I>complex</I>
						<B>sqrt</B>
						<TT clasS="monofont">(const</TT>
						<I>complex</i><tt cLASS="monofont">&amp;</tt><i> cmplx</i><TT CLass="monofont">)</tt></p>

					<ul>
<li><p>Returns the complex square root of <i>cmplx</i> in the range of the right halt plane.</p>
</li>
<li><p>If the argument is a negative real number, the value returned lies on the positive imaginary axis.</p>
</lI>
<LI><P>The branch cuts are along the negative real axis.</P>

						</Li>
</UL>
					<p><I>complex</I>
						<b>log</B>
						<TT CLAss="monofont">(const</tt>
						<I>complex</I><TT clasS="monofont">&amp;</TT><I> cmplx</i><tt cLASS="monofont">)</tt></p>

					<ul>
<li><p>Returns the complex natural base <i>e</i> logarithm of<i> cmplx.</i></p>
</li>
<li><p>When <i>cmplx</i> is a negative real number, <tT CLASS="monofont">imag(log(</tT><I>cmplx</i><TT cLASS="monofont">))</TT> is pi.</p>
</li>
<lI><P>The branch cuts are along the negative real axis.</P>

						</Li>
</ul>
					<p><I>complex</I>
						<B>log10</B>
						<tt clASS="monofont">(const</Tt>
						<i>complex</i><tt class="monofont">&amp;</tt><i> cmplx</i><tt class="monofont">)</TT></P>

					<UL>
<Li><P>Returns the complex base 10 logarithm of <I>cmplx.</i></P>
</Li>
<LI><P>It is equivalent to <TT Class="monofont">log(</TT><I>cmplx</I><tt clASS="monofont">)/log(10).</Tt></p>
</li>
<LI><P>The branch cuts are along the negative real axis.</P>

						</li>
</ul>
					<p><i>complex</i>
						<b>sin</b>
						<tt class="monofont">(const</tt>
						<i>complex</i><tT CLASS="monofont">&amp;</tT><I> cmplx</i><TT cLASS="monofont">)</TT></p>

					<p><i>complex</i>
						<B>cos</B>
						<TT clasS="monofont">(const</TT>
						<I>complex</i><tt cLASS="monofont">&amp;</tt><i> cmplx</i><tt class="monofont">)</tt></p>

					<p><i>complex</i>
						<b>tan</b>
						<tt CLASS="monofont">(const</Tt>
						<I>complex</I><tT ClASS="monofont">&amp;</TT><I> cmplx</i><tt cLASS="monofont">)</tt></p>

					<p><I>complex</I>
						<B>sinh</B>
						<tt clASS="monofont">(const</Tt>
						<i>complex</i><tt class="monofont">&amp;</tt><i> cmplx</i><tt class="monofont">)</TT></P>

					<P><I>complex</I>
						<b>cosh</B>
						<Tt CLaSS="monofont">(const</TT>
						<I>complex</I><tt clASS="monofont">&amp;</Tt><i> cmplx</i><tT CLAss="monofont">)</tt></P>

					<P><I>complex</I>
						<b>tanh</b>
						<tt class="monofont">(const</tt>
						<i>complex</i><tt class="monofont">&amp;</tT><I> cmplx</I><TT ClASs="monofont">)</TT></p>

					<UL>
<LI><P>These operations return the corresponding complex trigonometric operation on <I>cmplx.</i></p>

						</li>
</UL>
				
			
		</FOnt>
 
<table width="100%" border="0" cellspacing="0" cellpadding="0" bgcolor="#CCCCCC">
<td><font color="black" size=1>I l<font color="#FF0000">@</font>ve RuBoard</td>
<td valign="top" class="v2" align="right"><a href="0201379260_cnode93.html"><img src="FILES/previous.gif" width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a> <a href="0201379260_snode96.html"><img src="FILES/next.gif" width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a></td></table>
</BODY></HTML>