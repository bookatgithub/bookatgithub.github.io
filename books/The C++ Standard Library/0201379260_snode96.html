<HTML><HEAD><META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=iso-8859-1">
<!--SafClassName="docSection1Title"--><!--SafTocEntry="12.2 Valarrays"-->
<LINK REL="stylesheet" href="FILES/sbolM.css">
</HEAD>
<BODY link="#354278" vlink="#000066" alink="#000080" topmargin="0">
<table width="100%" border="0" cellspacing="0" cellpadding="0" bgcolor="#CCCCCC">
<td><font color="black" size=1>I l<font color="#FF0000">@</font>ve RuBoard</td>
<td valign="top" class="v2" align="right"><a href="0201379260_snode95.html"><img src="FILES/previous.gif" width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a> <a href="0201379260_snode97.html"><img src="FILES/next.gif" width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a></td></table>
<FONT><h3>12.2
Valarrays</h3>
			<p>The C++ standard library provides the class <tT CLAss="monofont">valarray</tt> for the processing of arrays of numeric values. A valarray is a representation of the mathematical concept of a linear sequence of values. It has one dimension, but you can get the illusion of higher dimensionality by special techniques of computed indices and powerful subsetting capabilities. Therefore, a valarray can be used as a base both for vector and matrix operations as well as for the processing of mathematical systems of polynomial equations with good performance.</P>

			<P>The valarray classes enable some tricky optimizations to get good performance for the processing of value arrays. However, it is not clear how important this component of the C++ standard library will be in the future because there are other interesting developments that perform even better. One of the most interesting examples is the Blitz system. If you are interested in numeric processing, you should look at it. For details, see <A TargeT="_blank" HREf="http://../monet.uwaterloo.ca/blitz/default.htm">http://monet.uwaterloo.ca/blitz/</a>.</p>

			<p>The valarray classes were not designed very well. In fact, nobody tried to determine whether the final specification worked. This happened because nobody felt "responsible" for these classes. The people who introduced valarrays to the C++ standard library left the committee a long time before the standard was finished. For example, to use valarrays, you often need some inconvenient and time-consuming type conversions (see page 554).</p>

			<h4>12.2.1
Getting to Know Valarrays</h4>
				<p>Valarrays are one-dimensional arrays with elements numbered sequentially from zero. They provide the ability to do some numeric processing for all or a subset of the values in one or more value arrays. For example, you can process the statement</p>

				<pre>
					
   z = a*x*x + b*x + c

				</pre>

				<p>with <tt claSS="monofont">a, b, c, x,</TT> and <TT cLAsS="monofont">z</Tt> being arrays that contain hundreds of numeric values. In doing this, you have the advantage of a simple notation. Also, the processing is done with good performance because the classes provide some optimizations that avoid the creation of temporary objects while processing the whole statement. In addition, special interfaces and auxiliary classes provide the ability to process only a certain subset of value arrays or to do some multidimensional processing. In this way, the valarray concept also helps to implement vector and matrix operations and classes.</P>

				<P>The standard guarantees that valarrays are alias free. That is, any value of a nonconstant valarray is accessed through a unique path. Thus, operations on these values can get optimized better because the compiler does not have to take into account that the data could be accessed through another path.</P>

				<H5>Header File</H5>
					<P>Valarrays are declared in the header file <tt clASS="monofont">&lt;valarray&gt;:</Tt></p>

					<prE>
						
   #include &lt;valarray&gt;

					</PRE>

					<p>In particular, in <tt cLASS="monofont">&lt;valarray&gt;</tt> the following classes are declared:</p>

					<pre>
						
   namespace std {
       template&lt;class T&gt; class valarray;               // <i>numeric array of type</i> T

       class slice;                                    // <i>slice out of a valarray</i>
       template&lt;class T&gt; class slice_array;

       class gslice;                                   // <i>a generalized slice</i>
       template&lt;class T&gt; class gslice_array;

       template&lt;class T&gt; class mask_array;             // <i>a masked valarray</i>

       template&lt;class T&gt; class indirect_array;         // <i>an indirected valarray</i>
   }

					</pre>

					<p>The classes have the following meanings:</p>

					<UL>
<LI><P><Tt CLaSS="monofont">valarray</tT> is the core class that manages an array of numeric values.</P>
</LI>
<LI><p><tt cLASS="monofont">slice</tt> and <tt CLASs="monofont">gslice</tt> arc provided to define a BLAS-like<fONT Size="1"><sup><a href="#FOOTNOTE-4">[4]</a></sup></font>
 slice as a subset of a valarray.</p>
<bLOCKQUoTE><fONt SIZE="1">
<P Class="footnote">
<SUP><A name="FOOTNOTE-4">[4]</A></SUP>
The Basic Linear Algebra Subprograms (BLAS) library provides computational kernels for several of the fundamental linear algebra operations, such as matrix multiply, the solution of triangular systems, and simple vector operations.</p>
</fonT></BLOckquote>

								</li>
<li><p><tt class="monofont">slice_array, gslice_array, mask_array,</tt> and <TT CLASs="monofont">indirect_array</TT> are internal auxiliary classes that are used to store temporary values or data. You can't use them in your programming interface directly. They are created indirectly by certain valarray operations.</p>

						</LI>
</uL>
					<P>All classes are templatized for the type of the elements. In principle, the type could be any data type. However, according to the nature of valarrays it should be a numeric data type.</P>

				
				<H5>Creating Valarrays</H5>
					<P>When you create a valarray you usually pass the number of elements as a parameter:</p>

					<pre>
						
   std::valarray&lt;int&gt; va1(10);              // <I>valarray of ten</I> ints <I>with value</I> 0
   std::valarray&lt;float&gt; va2(5.7, 10);       // <i>valarray of ten</i> float<i>s with value</i> 5.7
                                            // <I>(note the order)</I>

					</PRe>

					<p>If you pass one argument, it is used as the size. The elements are initialized by the default constructor of their type. Elements of fundamental data types are initialized by zero (see <a href="0201379260_snode14.html#10">Section 2.2.2</A>, for a description of why fundamental data types may be initialized by a default constructor). If you pass a second value, the first is used as the initial value for the elements, whereas the second specifies the number of elements. Note that the order of passing two arguments to the constructor differs from that of all other classes of the C++ standard library. All STL container classes use the first numeric argument as the number of elements and the second argument as the initial value.</p>

					<p>You can also initialize a valarray with an ordinary array:</p>

					<pre>
						
   int array[] = { 3, 6, 18, 3, 22 };

   // <i>initialize valarray by elements of an ordinary array</i>
   std::valarray&lt;int&gt; va3(array, sizeof (array)/sizeof (array[0]));

   // <i>initialize by the second to the fourth element</i>
   std::valarray&lt;int&gt; va4(array+1, 3);

					</pre>

					<p>The valarray creates copies of the passed values. Thus, you can pass temporary data for initialization.</p>

				
				<h5>Valarray Operations</h5>
					<p>For valarrays, the subscript operator is defined to access the element of a valarray. As usual, the first element has the index <tt cLASS="monofont">0:</TT></p>

					<PRe>
						
   va[0] = 3 * va[1] + va[2];

					</PRe>

					<P>In addition, all ordinary numeric operators are defined (addition, subtraction, multiplication, modulo, negation, bit operators, comparison operators, and logical operators, as well as all assignment operators). These operators are called for each element in the valarrays that is processed by the operation. Thus, the result of a valarray operation is a valarray that has the same number of elements as the operands and that contains the result of the elementwise computation. For example, the statement</P>

					<PRE>
						
   va1 = va2 * va3;

					</Pre>

					<p>is equivalent to</p>

					<PRE>
						
   va1[0] = va2[0] * va3[0];
   va1[l] = va2[l] * va3[l];
   va1[2] = va2[2] * va3[2];
   ...

					</Pre>

					<p>If the number of elements of the combined valarrays differs, the result is undefined.</p>

					<P>Of course, the operations are available only if the element's type supports them. And the exact meaning of the operation depends on the meaning of the operation for the elements. Thus, all of these operations simply do the same for each element or pair of elements in the valarrays they process.</P>

					<P>For binary operations, one of the operands may be a single value of the element's type. In this case, the single value is combined with each element of the valarray that is used as the other operand. For example, the statement</P>

					<pre>
						
   va1 = 4 * va2;

					</pRE>

					<P>is equivalent to</P>

					<pre>
						
   va1[0] = 4 * va2[0];
   va1[1] = 4 * va2[l];
   va1[2] = 4 * va2[2];
   ...

					</pre>

					<p>Note that the type of the single value has to match exactly the element type of the valarray. Thus, the previous example works only if the element type is <tt class="monofont">int.</tt> The following statement would fail:</p>

					<pre>
						
   std::valarray&lt;double&gt; va(20);
   ...
   va = 4 * va;    // <i>ERROR: type mismatch</I>

					</PRE>

					<P>The schema of binary operations also applies to comparison operators. Thus, operator <Tt CLaSS="monofont">==</tT> does <I>not</I> return a single Boolean value that shows whether both valarrays are equal. Instead, it returns a new valarray with the same number of elements of type <TT Class="monofont">bool,</TT> where each value is the result of the individual comparison. For example, in the following code</P>

					<Pre>
						
   std::valarray&lt;double&gt; val(10);
   std::valarray&lt;double&gt; va2(10);
   std::valarray&lt;bool&gt; vab(10);
   ...
   vab = (va1 == va2);

					</prE>

					<P>the last statement is equivalent to</P>

					<Pre>
						
   vab[0] = (va1[0] == va2[0]);
   vab[1] = (va1[1] == va2[1]);
   vab[2] = (va1[2] == va2[2]);
   ...
   vab[9] = (va1 [9] == va2[9]);

					</prE>

					<P>For this reason, you can't sort valarrays by using operator <TT class="monofont">&lt;,</tt> and you can't use them as elements in STL containers if the test for equality is performed with operator == (see <a href="0201379260_snode43.html#1">Section 5.10.1</a>, for the requirements of elements of STL containers).</p>

					<p>The following program demonstrates a simple use of valarrays:</p>

					<pre>
						
   <i>// num/val1.cpp</i>

   #include &lt;iostream&gt;
   #include &lt;valarray&gt;
   using namespace std;

   <I>// print valarray</I>
   template &lt;class T&gt;
   void printValarray (const valarray&lt;T&gt;&amp; va)
   {
       for (int i=0; i&lt;va.size(); i++) {
           cout &lt;&lt; va[i] &lt;&lt; ' ';
       }
       cout &lt;&lt; endl;
   }
   int main()
   {
       <I>// define two valarrays with ten elements</I>
       valarray&lt;double&gt; va1(10), va2(10);

       <I>// assign values</I> 0.0, 1.1, <i>up to</I> 9.9 <I>to the first valarray</i>
       for (int i=0; i&lt;10; i++) {
           va1[i] = i * 1.1;
       }

       <I>// assign</I> -1 <i>to all elements of the second valarray</I>
       va2 = -1;

       <I>// print both valarrays</I>
       printValarray(va1);
       printValarray(va2);

       <I>// print minimum, maximum, and sum of the first valarray</I>
       cout &lt;&lt; "min(): " &lt;&lt; val.min() &lt;&lt; endl;
       cout &lt;&lt; "max(): " &lt;&lt; val.max() &lt;&lt; endl;
       cout &lt;&lt; "sum(): " &lt;&lt; val.sum() &lt;&lt; endl;

       <I>// assign values of the first to the second valarray</i>
       va2 = va1;

       <i>// remove all elements of the first valarray</i>
       va1.resize (0);

       <i>// print both valarrays again</I>
       printValarray(va1);
       printValarray(va2);
   }

					</PRE>

					<p>The program has the following output:</p>

					<prE>
						
   0 1.1 2.2 3.3 4.4 5.5 6.6 7.7 8.8 9.9
   -1 -1 -1 -1 -1 -1 -1 -1 -1 -1
   min():0
   max(): 9.9
   sum(): 49.5

   0 1.1 2.2 3.3 4.4 5.5 6.6 7.7 8.8 9.9

					</PRE>

				
				<h5>Transcendental Functions</h5>
					<p>The transcendental operations (trigonometric and exponential) are defined as equivalent to the numeric operators. The operations are performed with all elements in the valarrays, and for binary operations, one of the operands may be a single value, which is used as one operand, with all elements of the valarrays as the other operand.</p>

					<P>All of these operations are defined as global functions instead of member functions. This is to provide automatic type conversion for subsets of valarrays for both operands (subsets of valarrays are covered in <A href="0201379260_snode96.html#7">Section 12.2.2</a>,).</p>

					<p>Here is a second example of the use of valarrays. It demonstrates the use of transcendental operations:</p>

					<pre>
						
   <i>// num/val2.cpp</i>

   #include &lt;iostream&gt;
   #include &lt;valarray&gt;
   using namespace std;

   <i>// print valarray</i>
   template &lt;class T&gt;
   void printValarray (const valarray&lt;T&gt;&amp; va)
   {
       for (int i=0; i&lt;va.size(); i++) {
           cout &lt;&lt; va[i] &lt;&lt; ' ';
       }
       cout &lt;&lt; endl;
   }

   int main()
   {

       <i>// create and initialize valarray with nine elements</i>
       valarray&lt;double&gt; va(9);
       for (int i=0; i&lt;va.size(); i++) {
            va[i] = i * 1.1;
       }

       <i>// print valarray</i>
       printValarray(va);

       <i>// double values in the valarray</i>
       va *= 2.0;

       <i>// print valarray again</i>
       printValarray(va);

       <I>// create second valarray initialized by the values of the first plus</I> 10
       valarray&lt;double&gt; vb(va+10.0);

       <I>// print second valarray</I>
       printValarray(vb);

       <I>// create third valarray as a result of processing both existing valarrays</I>
       valarray&lt;double&gt; vc;
       vc = sqrt(va) + vb/2.0 - 1.0;

       <i>// print third valarray</I>
       printValarray(vc);
   }

					</PrE>

					<P>The program has the following output:</p>

					<PRE>
						
   0 1.1 2.2 3.3 4.4 5.5 6.6 7.7 8.8
   0 2.2 4.4 6.6 8.8 11 13.2 15.4 17.6
   10 12.2 14.4 16.6 18.8 21 23.2 25.4 27.6
   4 6.58324 8.29762 9.86905 11.3665 12.8166 14.2332 15.6243 16.9952

					</PRE>

				
			
			<a namE="7"></A><H4>12.2.2
Valarray Subsets</H4>
				<p>The subscript operator <tt cLASS="monofont">[]</tt> is overloaded for special auxiliary objects of valarrays. These auxiliary objects define subsets of valarrays in different ways. In doing this, they provide an elegant way to operate on certain subsets of valarrays (with both read and write access).</p>

				<p>The subset of a valarray is defined by using a certain subset definition as the index. For example:</P>

				<PRE>
					
   va[std::slice (2, 4, 3)]     <i>// four elements with distance</i> 3 <i>starting from index</i> 2
   va[va&gt;7]                     <i>// all elements with a value greater than</i> 7

				</pre>

				<p>If a subset definition such as <tt class="monofont">std::slice(2, 4, 3)</tt> or <tt CLASS="monofont">va&gt;7</Tt> is used with a constant valarray, the expression returns a new valarray with the corresponding elements. However, if such a subset definition is used with a nonconstant valarray, the expression returns a temporary object of a special auxiliary valarray class. This temporary object does not contain the subset values, only the definition of the subset. Thus, the evaluation of expressions is deferred until the values are needed to compute a final result.</P>

				<P>This mechanism is called <i>lazy evaluation.</I> It has the advantage that no temporary values for expressions are computed. This saves time and memory. In addition, the technique provides reference semantics. Thus, the subsets are logical sets of references to the original values. You can use these subsets as the destination (lvalue) of a statement. For example, you could assign one subset of a valarray the result of a multiplication of two other subsets of the same valarray (examples follow shortly).</P>

				<p>However, because "temporaries" are avoided, some unexpected conditions might occur when elements in the destination subset are also used in a source subset. Therefore, any operation of valarrays is guaranteed to work only if the elements of the destination subset and the elements of all source subsets are distinct.</P>

				<P>With smart definitions of subsets you can give valarrays the semantics of two or more dimensions. Thus, in a way, valarrays may be used as multidimensional arrays.</P>

				<P>There are four ways to define subsets of valarrays:</P>

				<Ol typE="1" STArt="restarts">
<li><P>Slices</P>
</LI>
<li><p>General slices</p>
</LI>
<LI><p>Masked subsets</p>
</li>
<li><p>Indirect subsets</p>

					</li>
</ol>

				<p>The following subsections discuss them and give examples.</p>

				<h5>Valarray Subset Problems</h5>
					<p>Before I start with the individual subsets, I have to mention a general problem. The handling of valarray subsets is not well designed. You can create subsets easily, but you can't combine them easily with other subsets. Unfortunately, you almost always need an explicit type conversion to valarray. This is because the C++ standard library does not specify that <tt clASS="monofont">valarray</TT> subsets provide the same operations as valarrays.</P>

					<p>For example, to multiply two subsets and assign the result to a third subset, you can't write the following:</P>

					<PrE>
						
    <I>// ERROR: conversions missing</i>
    va[std::slice(0,4,3)]
        = va[std::slice (1,4,3)] * va[std::slice (2,4,3)];

					</PRE>

					<P>Instead, you have to code by using a new-style cast (see page 19)<FOnt siZE="1"><SUp><a hrEF="#FOOTNOTE-5">[5]</A></Sup></foNT>
:</P>
<Blockquote><font size="1">
<p claSS="footnote">
<SUP><A nAMe="FOOTNOTE-5">[5]</A></SuP>
Note that you have to put a space between the two <TT CLAss="monofont">"&gt;"</tt> characters. <TT CLass="monofont">"&gt;&gt;"</tT> would be parsed as shift operator, which would result in a syntax error.</P>
</FOnt></blOCKQuote>

						
					<pre>
						
    va[std::slice (0,4,3)]
        = static_cast&lt;std::valarray&lt;double&gt; &gt;(va[std::slice (l,4,3)]) *
          static_cast&lt;std::valarray&lt;double&gt; &gt;(va[std::slice (2,4,3)]);

					</pre>

					<p>or by using an old-style cast:</p>

					<pre>
						
   va[std::slice(0,4,3)]
       = std::valarray&lt;double&gt;(va[std::slice (1,4,3)]) *
         std::valarray&lt;double&gt;(va[std::slice (2,4,3)]);

					</pre>

					<p>This is tedious and error prone. Even worse, without good optimization it may cost performance because each cast creates a temporary object, which could be avoided without the cast.</p>

					<p>To make the handling a bit more convenient, you can use the following template function:</P>

					<PRE>
						
   /* <I>template to convert valarray subset into valarray</I>
    */
   template &lt;class T&gt;
   inline
   std::valarray&lt;typename T::value_type&gt; VA (const T&amp; valarray_subset)
   {
       return std::valarray&lt;typename T::value_type&gt;(valarray_subset);
   }

					</pRE>

					<p>By using this template, you could write</P>

					<PrE>
						
   va[std::slice (0,4,3)] = VA(va[std::slice (l,4,3)]) *
                            VA(va[std::slice (2,4,3)]); <I>// OK</I>

					</PRE>

					<p>However, the performance penalty remains.</p>

					<p>If you use a certain element type you could also use a simple type definition:</p>

					<PRE>
						
   typedef valarray&lt;double&gt; VAD;

					</Pre>

					<p>By using this type definition you could also write</p>

					<PRE>
						
   va[std::slice (0,4,3)] = VAD(va[std::slice(l,4,3)]) *
                            VAD (va[std:: slice (2,4,3)]); <I>// OK</i>

					</pre>

					<P>provided the elements of va have type double.</P>

				
				<H5>Slices</H5>
					<p>A slice defines a set of indices that has three properties:</p>

					<ol type="1" start="restarts">
<li><p>The starting index</p>
</li>
<li><P>The number of elements (size)</P>
</LI>
<LI><p>The distance between elements (stride)</P>

						</Li>
</OL>

					<p>You can pass these three properties exactly in the same order as parameters to the constructor of class <TT CLASs="monofont">slice.</tt> For example, the following expression specifies four elements, starting with index <tT CLAss="monofont">2</tt> with distance <TT CLass="monofont">3:</tT></P>

					<PRe>
						
   std::slice (2,4,3)

					</pre>

					<p>In other words, the expression specifies the following set of indices:</p>

					<pre>
						
   2  5  8  11

					</pre>

					<p>The stride may be negative. For example, the expression</p>

					<pre>
						
   std::slice (9,5,-2)

					</pre>

					<p>specifies the following indices:</P>

					<PRE>
						
   9  7  5  3  1

					</PRe>

					<P>To define the subset of a valarray, you simply use a slice as an argument of the subscript operator. For example, the following expression specifies the subset of the valarray <Tt CLaSS="monofont">va</TT> that contains the elements with the indices <TT clasS="monofont">2, 5, 8,</TT> and <Tt claSS="monofont">11:</TT></p>

					<pre>
						
   va[std::slice (2,4,3)]

					</PRE>

					<P>It's up to the caller to ensure that all these indices are valid.</p>

					<p>If the subset qualified by a slice is a subset of a constant valarray, the subset is a new valarray. If the valarray is nonconstant, the subset has reference semantics to the original valarray. The auxiliary class <tt class="monofont">slice_array</tt> is provided for this:</p>

					<pre>
						
   namespace std {
       class slice;

       template &lt;class T&gt;
       class slice_array;

       template &lt;class T&gt;
       class valarray {
         public:
           <i>// slice of a constant valarray returns a new valarray</i>
           valarray&lt;T&gt; operator[] (slice) const;

           <i>// slice of a variable valarray returns a slice_array</i>
           slice_array&lt;T&gt; operator[] (slice);
           ...
       };
   }

					</prE>

					<P>For <TT CLaSS="monofont">slice_array</tT>s, the following operations are defined:</P>

					<uL>
<LI><P>Assign a single value to all elements.</P>
</Li>
<li><p>Assign another valarray (or valarray subset).</P>
</LI>
<Li><p>Call any computed assignment operation, such as operators <tt CLASs="monofont">+=</tt> and <tT CLAss="monofont">*=.</tt></p>

						</li>
</ul>
					<p>For any other operation you have to convert the subset to a valarray (see page 554). Note that the class <tt class="monofont">slice_array&lt;&gt;</tt> is intended purely as an internal helper class for slices, and it should be transparent to the user. Thus, all constructors and the assignment operator of class <tt CLASS="monofont">slice_array&lt;&gt;</Tt> are private.</P>

					<P>For example, the statement</p>

					<PRe>
						
   va[std::slice (2,4,3)] = 2;

					</PRE>

					<P>assigns <TT clasS="monofont">2</TT> to the third, sixth, ninth, and twelfth elements of the valarray <Tt claSS="monofont">va.</TT> It is equivalent to the following statements:</p>

					<pre>
						
   va[2] = 2;
   va[5] = 2;
   va[8] = 2;
   va[11] = 2;

					</PRE>

					<P>As another example, the following statement squares the values of the elements with index <tt class="monofont">2, 5, 8,</tt> and <tt class="monofont">11:</tt></p>

					<prE>
						
   va[std::slice (2,4,3)]
       *= std::valarray&lt;double&gt;(va[std::slice(2,4,3)]);

					</PRE>

					<P>As mentioned on page 554, you can't write</P>

					<pRE>
						
   va[std::slice (2,4,3)] *= va[std::slice (2,4,3)]; <i>//            ERROR</I>

					</PrE>

					<P>But using the <TT CLass="monofont">VA()</tT> template function mentioned on page 555, you can write</P>

					<PRe>
						
   va[std::slice(2,4,3)] *= VA(va[std::slice (2,4,3)]);.      <i>// OK</i>

					</pRE>

					<P>By passing different slices of the same valarray you can combine different subsets and store the result in another subset of the valarray. For example, the statement</P>

					<pre>
						
   va[std::slice (0,4,3)] = VA(va[std::slice (l,4,3)]) *
                            VA(va[std::slice (2,4,3)]);

					</pRE>

					<P>is equivalent to the following:</P>

					<pre>
						
   va[0] = va[1] * va[2];
   va[3] = va[4] * va[5];
   va[6] = va[7] * va[8];
   va[9] = va[10] * va[11];

					</pre>

					<p>If you consider your valarray as a two-dimensional matrix, this example is nothing else but vector multiplication (<a href="0201379260_snode96.html#11">Figure 12.1</a>). However, note that the order of the individual assignments is not defined. Therefore, the behavior is undefined if the destination subset contains elements that are used in the source subsets.</p>

					<center>
						<h5>
<A NAME="11"></A>Figure 12.1. Vector Multiplication by Valarray Slices</h5><IMg BOrDER="0" WIDth="500" heIGHT="252" src="FILES/12fig01.gif" aLT="graphics/12fig01.gif"></CEnter>

					<P>In the same way, more complicated statements are possible. For example:</P>

					<PRe>
						
   va[std::slice (0,100,3)]
       = std::pow(VA(va[std::slice (l,100,3)]) * 5.0,
                  VA(va[std::slice (2,100,3)]));

					</pre>

					<p>Note again that a single value, such as <tt class="monofont">5.0</tt> in this example, has to match the element type of the valarray exactly.</p>

					<p>The following program demonstrates a complete example of using valarray slices:</p>

					<pre>
						
   <i>// num/slice1.cpp</I>

   #include &lt;iostream&gt;
   #include &lt;valarray&gt;
   using namespace std;

   <I>// print valarray line-by-line</I>
   template&lt;class T&gt;
   void printValarray (const valarray&lt;T&gt;&amp; va, int num)
   {
       for (int i=0; i&lt;va.size()/num; ++i) {
           for (int j=0; j&lt;num; ++j) {
               cout &lt;&lt; va[i*num+j] &lt;&lt; ' ';
           }
           cout &lt;&lt; endl;
       }
       cout &lt;&lt; endl;
   }

   int main()
   {
       <I>/* valarray with 12 elements</I>
        <I>* - four rows</i>
        <I>* - three columns</I>
        <i>*/</I>
       valarray&lt;double&gt; va(12);

       <I>// fill valarray with values</i>
       for (int i=0; i&lt;12; i++) {
           va[i] = i;
       }

       printValarray (va, 3);

       <I>// first column = second column raised to the third column</I>
       va [slice (0,4,3)] = pow (valarray&lt;double&gt;(va[slice (l,4,3)]),
                                 valarray&lt;double&gt;(va[slice (2,4,3)]));

       printValarray (va, 3);

       <I>// create valarray with three times the third element of</I> va
       valarray&lt;double&gt; vb(va[slice (2,4,0)]);

       <I>// multiply the third column by the elements of</I> vb
       va[slice (2,4,3)] *= vb;

       printValarray (va, 3);

       <i>// print the square root of the elements in the second row</i>
       printValarray (sqrt(valarray&lt;double&gt;(va[slice (3,3,1)])), 3);

       <i>// double the elements in the third row</i>
       va[slice (2,4,3)] = valarray&lt;double&gt;(va[slice (2,4,3)]) * 2.0;

       printValarray (va, 3);
   }

					</PRE>

					<P>The program has the following output:</p>

					<pre>
						
   0 1 2
   3 4 5
   6 7 8
   9 10 11

   1 1 2
   1024 4 5
   5.7648e+006 7 8
   1e+011 10 11

   1 1 4
   1024 4 10
   5.7648e+006 7 16
   1e+011 10 22

   32 2 3.16228

   1 1 8
   1024 4 20
   5.7648e+006 7 32
   1e+011 10 44

					</PRE>

				
				<H5>General Slices</h5>
					<p>General slices, or <i>gslices,</i> are the general form of slices. Similar to slices, which provide the ability to handle a subset that is one dimension out of two dimensions, gslices allow the handling of subsets of multidimensional arrays. In principle, gslices have the same properties as slices:</P>

					<UL>
<Li><p>Starting index</p>
</li>
<li><p>Number of elements (size)</p>
</li>
<li><p>Distance between elements (stride)</p>

						</li>
</ul>
					<p>Unlike slices, however, the number and distance of elements in a gslice are arrays of values. The number of elements in such an array is equivalent to the number of dimensions used. For example, if a gslice has the state</p>

					<PRE>
						
   start:  2
   size:   [ 4 ]
   stride: [ 3 ]

					</PRE>

					<p>then the gslice is equivalent to a slice because the array handles one dimension. Thus, it defines four elements with distance <TT cLAsS="monofont">3,</TT> starting with index <TT Class="monofont">2:</TT></P>

					<Pre>
						
   2  5  8  11

					</prE>

					<P>However, if a gslice has the state</P>

					<Pre>
						
   start:  2
   size:   [ 2 4]
   stride: [ 10 3]

					</prE>

					<P>then the gslice handles two dimensions. The smallest index handles the highest dimension. Thus, this gslice specifies starting from index <TT class="monofont">2,</tt> twice with distance <tt class="monofont">10,</tt> four elements with distance <tt claSS="monofont">3:</TT></P>

					<PrE>
						
    2  5  8 11
   12 15 18 21

					</PrE>

					<P>Here is an example of a slice with three dimensions:</p>

					<PRE>
						
   start:  2
   size:   [  3  2 4 ]
   stride: [ 30 10 3 ]

					</PRE>

					<p>It specifies starting from index <tt cLASS="monofont">2,</tt> three times with distance <tt CLASs="monofont">30,</tt> twice with distance <tT CLAss="monofont">10,</tt> four elements with distance <tt class="monofont">3:</tt></p>

					<pre>
						
    2  5  8 11
   12 15 18 21

   32 35 38 41
   42 45 48 51

   62 65 68 71
   72 75 78 81

					</pre>

					<p>The ability to use arrays to define size and stride is the only difference between gslices and slices. Apart from this, gslices behave the same as slices:</P>

					<OL TYPe="1" STaRT="restarts">
<lI><P>To define a concrete subset of a valarray, you simply pass a gslice as the argument to the subscript operator of the valarray.</P>
</LI>
<Li><p>If the valarray is constant, the resulting expression is a new valarray.</p>
</lI>
<LI><P>If the valarray is nonconstant, the resulting expression is a <tt clASS="monofont">gslice_array</Tt> that represents the elements of the valarray with reference semantics:</p>

							<prE CLAss="monofont">
       namespace std {
           class gslice;

           template &lt;class T&gt;
           class gslice_array;

           template &lt;class T&gt;
           class valarray {
             public:
               <i>// gslice of a constant valarray returns a new valarray</i>
               valarray&lt;T&gt; operator[] (const gslice&amp;) const;
               <i>// gslice of a variable valarray returns a gslice_array</i>
               gslice_array&lt;T&gt; operator[] (const gslice&amp;);
               ...

           };

       }
</pre></li>
<li><p>For <tt class="monofont">gslice_array,</TT> the assignment and computed assignment operators are provided to modify the elements of the subset.</P>
</LI>
<Li><P>By using type conversions you can combine a gslice array with other valarrays and subsets of valarrays (see page 554).</P>

						</lI>
</Ol>

					<P>The following program demonstrates the use of valarray gslices:</P>

					<PRE>
						
   <I>// num/gslice1.cpp</i>

   #include &lt;iostream&gt;
   #include &lt;valarray&gt;
   using namespace std;

   <i>// print three-dimensional valarray line-by-line</i>
   template&lt;class T&gt;
   void printValarray3D (const valarray&lt;T&gt;&amp; va, int dim1, int dim2)
   {
       for (int i=0; i&lt;va.size()/(dim1*dim2); ++i) {
           for (int j=0; j&lt;dim2; ++j) {
               for (int k=0; k&lt;dim1; ++k) {
                   cout &lt;&lt; va[i*dim1*dim2+j*dim1+k] &lt;&lt; ' ';
               }
               cout &lt;&lt; '\n';
           }
           cout &lt;&lt; '\n';
       }
       cout &lt;&lt; endl;
   }

   int main()
   {
       <i>/* valarray with 24 elements</I>
        <I>* - two groups</I>
        <I>* -four rows</i>
        <i>* - three columns</i>
        <i>*/</I>
       valarray&lt;double&gt; va(24);
       <I>// fill valarray with values</I>
       for (int i=0; i&lt;24; i++) {
           va[i] = i;
       }
       <I>// print valarray</i>
       printValarray3D (va, 3, 4);
       <i>// we need two two-dimensional subsets of three times</i> 3 <i>values</I>
       <I>// in two 12-element arrays</I>
       size_t lengthvalues[] = { 2, 3 };
       size_t stridevalues[] = { 12, 3 };
       valarray&lt;size_t&gt; length(lengthvalues, 2);
       valarray&lt;size_t&gt; stride(stridevalues, 2);
       <I>// assign the second column of the first three rows</i>
       <i>// to the first column of the first three rows</i>
       va[gslice (0, length, stride)]
           = valarray&lt;double&gt;(va[gslice (1, length, stride)]);
       <i>// add and assign the third of the first three rows</i>
       <i>// to the first of the first three rows</i>
       va[gslice (0, length, stride)]
           += valarray&lt;double&gt;(va[gslice (2, length, stride)]);
       <i>// print valarray</i>
       printValarray3D (va, 3, 4);
   }

					</pre>

					<p>The program has the following output:</p>

					<pre>
						
   0  1  2
   3  4  5
   6  7  8
   9  10  11

   12  13  14
   15  16  17
   18  19  20
   21  22  23

   3  1  2
   9  4  5
   15  7  8
   9  10  11

   27  13  14
   33  16  17
   39  19  20
   21  22  23

					</pre>

				
				<h5>Masked Subsets</H5>
					<P>Mask arrays provide another way to define a subset of a valarray. You can mask the elements with a Boolean expression. For example, in the expression</P>

					<PRE>
						
   va[va &gt; 7]

					</pRE>

					<p>the subexpression</P>

					<PrE>
						
   va &gt; 7

					</PRE>

					<P>returns a valarray with the size of <Tt claSS="monofont">va,</TT> where for each element a Boolean value states whether the element is greater than <tt clASS="monofont">7.</Tt> The Boolean valarray is used by the subscript operator to specify all elements for which the Boolean expression yields <tt cLASS="monofont">true.</tt> Thus,</p>

					<pre>
						
   va[va &gt; 7]

					</pre>

					<p>specifies the subset of elements in the valarray va that is greater than <tt class="monofont">7.</tt></p>

					<p>Apart from this, mask arrays behave the same as all valarray subsets:</P>

					<OL TYPe="1" STaRT="restarts">
<lI><P>To define a concrete subset of a valarray, you simply pass a valarray of Boolean values as the argument to the subscript operator of the valarray.</P>
</LI>
<Li><p>If the valarray is constant, the resulting expression is a new valarray.</p>
</lI>
<LI><P>If the valarray is nonconstant, the resulting expression is a <tt clASS="monofont">mask_array</Tt> that represents the elements of the valarray with reference semantics:</p>

							<prE CLAss="monofont">
        namespace std {              
            template &lt;class T&gt;
            class mask_array;
            template &lt;class T&gt;
            class valarray {
              public:
                // <i>masking a constant valarray returns a new valarray</i>
                valarray&lt;T&gt; operator[] (const valarray&lt;bool&gt;&amp;) const;
                // <i>masking a variable valarray returns a</i> mask_array
                mask_array&lt;T&gt; operator[] (const valarray&lt;bool&gt;&amp;);
                ...
            };
        }
</pre></li>
<li><p>For <tt class="monofont">mask_array,</TT> the assignment and computed assignment operators are provided to modify the elements of the subset.</P>
</LI>
<Li><P>By using type conversions you can combine a mask array with other valarrays and subsets of valarrays (see page 554).</P>

						</lI>
</Ol>

					<P>The following program demonstrates the use of masked subsets of valarrays:</P>

					<PRE>
						
   // <I>num/masked1.cpp</i>
   #include &lt;iostream&gt;
   #include &lt;valarray&gt;
   using namespace std;
   <i>// print valarray line-by-line</i>
   template&lt;class T&gt;
   void printValarray (const valarray&lt;T&gt;&amp; va, int num)
   {
       for (int i=0; i&lt;va.size()/num; ++i) {
           for (int j=0; j&lt;num; ++j) {
               cout &lt;&lt; va[i*num+j] &lt;&lt; ' ';
           }
           cout &lt;&lt; endl;
       }
       cout &lt;&lt; endl;
   }
   int main()
   {
       <i>/* valarray with 12 elements</I>
        <I>* - four rows</I>
        <I>* - three columns</i>
        <i>*/</i>
       valarray&lt;double&gt; va(12);
       <i>// fill valarray with values</I>
       for (int i=0; i&lt;12; i++) {
           va[i] = i;
       }
       printValarray (va, 3);
       // <I>assign</I> 77 <I>to all values that are less than</i> 5
       va[va&lt;5.0] = 77.0;
       <i>// add</i> 100 <i>to all values that are greater than</I> 5 <I>and less than</I> 9
       va[va&gt;5.0 &amp;&amp; va9.0]
           = valarray&lt;double&gt;(va[va&gt;5.0 &amp;&amp; va&lt;9.0]) + 100.0;
       printValarray (va, 3);
   }

					</Pre>

					<p>The program has the following output:</p>

					<pre>
						
   0  1  2
   3  4  5
   6  7  8
   9  10  11

   77  77 77
   77  77 5
   106  107  108
   9 10  11

					</pre>

					<p>Note that the type of a numeric value that is compared with the valarray has to match the type of the valarray exactly. So, using an <tt class="monofont">int</tt> value to compare it with a valarray of <tT CLASS="monofont">doubles</tT> would not compile:</P>

					<pRE>
						
   valarray&lt;double&gt; va(12);
   ...
   va[va&lt;5] = 77;      <i>// ERROR</I>

					</PRE>

				
				<H5>Indirect Subsets</H5>
					<p>The fourth and last way to define a subset of a valarray is provided by indirect arrays. Here you simply define the subset of a valarray by passing an array of indices. Note that the indices that specify the subset don't have to be sorted and may occur twice.</p>

					<p>Apart from this, indirect arrays behave the same as all valarray subsets:</p>

					<OL TYpe="1" stART="restarts">
<Li><p>To define a concrete subset of a valarray you simply pass a valarray of elements of type <tt CLASs="monofont">size_t</tt> as the argument to the subscript operator of the valarray.</p>
</li>
<li><p>If the valarray is constant, the resulting expression is a new valarray.</p>
</li>
<li><p>If the valarray is nonconstant, the resulting expression is an <tt clasS="monofont">indirect_array</TT> that represents the elements of the valarray with reference semantics:</P>

							<PRe CLaSS="monofont">
        namespace std {              
            template &lt;class T&gt;
            class indirect_array;


            template &lt;class T&gt;
            class valarray {
              public:
                // <i>indexing a constant valarray returns a new valarray</I>
                valarray&lt;T&gt; operator[] (const valarray&lt;bool&gt;&amp;) const;
                // <I>indexing a variable valarray returns a</I> indirect_array
                indirect_array&lt;T&gt; operator[] (const valarray&lt;bool&gt;&amp;);
                ...
            };
        }
</PRE></li>
<li><P>For <TT Class="monofont">indirect_array,</TT> the assignment and computed assignment operators are provided to modify the elements of the subset.</P>
</Li>
<li><p>By using type conversions you can combine an indirect array with other valarrays and subsets of valarrays (see page 554).</P>
</LI>
</Ol>

					<p>The following program demonstrates how to use indirect arrays:</p>

					<pre>
						
   // <i>num/indi1.cpp</i>


   #include &lt;iostream&gt;
   #include &lt;valarray&gt;
   using namespace std;


   <i>// print valarray as two-dimensional array</i>
   template&lt;class T&gt;
   void printValarray (const valarray&lt;T&gt;&amp; va, int num)
   {
       for (int i=0; i&lt;va.size()/num; i++) {
           for (int j=0; j&lt;num; j++) {
               cout &lt;&lt; va[i*num+j] &lt;&lt; ' ';
           }
           cout &lt;&lt; endl;
       }
       cout &lt;&lt; endl;
   }
   int main()
   {
       <i>// create valarray for 12 elements</i>
       valarray&lt;double&gt; va(12);
       // <i>initialize valarray by values</i> 1.01, 2.02, ... 12.12
       for (int i=0; i&lt;12; i++) {
           va[i] = (i+1) * 1.01;
       }
       printValarray(va, 4);
       /* <i>create array of indexes</i>
        * <i>- note: element type has to be</i> size_t
        */
       valarray&lt;size_t&gt; idx(4);
       idx[0] = 8;
       idx[1] = 0;
       idx[2] = 3;
       idx[3] = 7;
       <i>// use array of indexes to print the ninth, first, fourth, and eighth elements</i>
       printValarray(valarray&lt;double&gt;(va[idx]), 4);
       <i>// change the first and fourth elements and print them again indirectly</I>
       va[0] = 11.11;
       va[3] = 44.44;
       printValarray(valarray&lt;double&gt;(va[idx]), 4);
       <I>// now select the second, third, sixth, and ninth elements</I>
       <I>// and assign</I> 99 <I>to them</i>
       idx[0] = 1;
       idx[l] = 2;
       idx[2] = 5;
       idx[3] = 8;
       va[idx] = 99;
       <I>// print the whole valarray again</I>
       printValarray (va, 4);
   }

					</pRE>

					<p>The valarray <TT CLASs="monofont">idx</tt> is used to define the subset of the elements in valarray <tT CLAss="monofont">va.</tt> The program has the following output:</P>

					<PRE>
						
   1.01 2.02 3.03 4.04
   5.05 6.06 7.07 8.08
   9.09 10.1 11.11 12.12

   9.09 1.01 4.04 8.08

   9.09 11.11 44.44 8.08

   11.11 99 99 44.44
   5.05 99 7.07 8.08
   99 10.1 11.11 12.12

					</pre>

				
			
			<h4>12.2.3
Class <TT CLass="monofont">valarray</tt> in Detail</h4>
				<p>The class <tt class="monofont">valarray&lt;&gt;</tt> is the core part of the valarray component. It is defined as a template class parameterized on the type of the elements:</p>

				<pre>
					
   namespace std {
       template &lt;class T&gt;
       class valarray;
   }

				</pRE>

				<P>The size is not part of the type. Thus, in principle you can process valarrays with different sizes and you can change the size. However, changing the size of a valarray is provided only to make a two-step initialization (creating and setting the size), which you can't avoid to manage arrays of valarrays. Beware that the result of combining valarrays of different size is undefined.</P>

				<H5>Create, Copy, and Destroy Operations</H5>
					<p><B><I>valarray</i></B><I>::valarray</i>
						<TT CLASs="monofont">()</tt></p>

					<UL>
<LI><p>The default constructor.</p>
</li>
<LI><P>Creates an empty valarray.</P>
</li>
<li><P>This constructor is provided only to enable the creation of arrays of valarrays. The next step is to give them the correct size using the <TT Class="monofont">resize()</tt> member function.</p>

						</li>
</ul>
					<p><tt class="monofont">explicit</tt>
						<B><I>valarray</I></B><I>::valarray</I>
						<tT ClASs="monofont">(size_t</TT>
						<I>num</I><TT clasS="monofont">)</TT></P>

					<ul>
<li><P>Creates a valarray that contains <I>num</I> elements.</P>
</li>
<li><P>The elements are initialized by their default constructor (which is <TT Class="monofont">0</tt> for fundamental data types).</p>

						</li>
</ul>
					<p><b><i>valarray</i></b><i>::valarray</i>
						<tt cLASS="monofont">(const T&amp;</TT>
						<i>value,</I>
						<Tt CLaSS="monofont">size_t</TT>
						<I>num</I><tt clASS="monofont">)</Tt></p>

					<ul>
<LI><P>Creates a valarray that contains <I>num</i> elements.</p>
</li>
<LI><P>The elements are initialized by <I>value.</i></p>
</li>
<li><p>Note that the order of parameters is unusual. All other classes of the C++ standard library provide an interface in which <i>num</i> is the first parameter and <i>value</i> is the second parameter.</p>

						</li>
</ul>
					<p><b><i>valarray</i></b><I>::valarray</I>
						<TT CLaSS="monofont">(const T*</tT>
						<I>array,</i>
						<TT CLASs="monofont">size_t</tt>
						<i>num</I><TT Class="monofont">)</TT></P>

					<Ul>
<li><p>Creates a valarray that contains <I>num</I> elements.</P>
</Li>
<li><p>The elements are initialized by the values of the elements in <i>array.</i></p>
</li>
<li><p>The caller must ensure that <i>array</i> contains <i>num</i> elements; otherwise, the behavior is undefined.</p>

						</li>
</ul>
					<P><B><I>valarray</I></B><I>::valarray</i>
						<TT cLAsS="monofont">(const</TT>
						<I>valarray</I><Tt claSS="monofont">&amp;</TT><i> va</i><tt CLASs="monofont">)</tt></p>

					<UL>
<LI><p>The copy constructor.</p>
</li>
<li><p>Creates a valarray as a copy of <i>va.</i></p>

						</li>
</ul>
					<p><b><i>valarray</i></b><i>::~valarray</i>
						<TT CLASs="monofont">()</TT></p>

					<UL>
<lI><P>The destructor.</P>
</LI>
<Li><p>Destroys all elements and frees the memory.</p>

						</lI>
</UL>
					<P>In addition, you can create valarrays initialized by objects of the internal auxiliary classes <tt clASS="monofont">slice_array, gslice_array, mask_array,</Tt> and <tt cLASS="monofont">indirect_array.</tt> See pages 575, 577, 578, and 579, respectively, for details about these classes.</p>

				
				<h5>Assignment Operations</h5>
					<p><i>valarray</i><tt class="monofont">&amp;</tt>
						<b>valarray::operator =</b>
						<tt CLASS="monofont">(const</Tt>
						<I>valarray</I><tT ClASS="monofont">&amp;</TT>
						<I>va</i><tt cLASS="monofont">)</tt></p>

					<uL>
<LI><P>Assigns the elements of the valarray <i>va.</i></p>
</lI>
<LI><P>If <i>va</i> has a different size, the behavior is undefined.</p>
</li>
<li><p>The value of an element on the left side of any valarray assignment operator should not depend on the value of another element on that left side. In other words, if an assignment overwrites values that are used on the right side of the assignment, the result is undefined. This means you should not use an element on the left side anywhere in the expression on the right side. The reason for this is that the order of the evaluation of valarray statements is not defined. See page 557 and page 554 for details.</p>

						</li>
</ul>
					<p><i>valarray</i><tt claSS="monofont">&amp;</TT>
						<B><I>valarray</i></B><I>::operator =</i>
						<TT cLASS="monofont">(const T&amp;</TT>
						<i>value</i><tt CLASs="monofont">)</tt></p>

					<UL>
<LI><p>Assigns <i>value</i> to each element of the valarray.<fONT Size="1"><sup><a href="#FOOTNOTE-6">[6]</a></sup></font>
</p>
<bLOCKQUoTE><fONt SIZE="1">
<P Class="footnote">
<SUP><A name="FOOTNOTE-6">[6]</A></SUP>
In earlier versions single values were assigned by the member function <tt clASS="monofont">fill().</Tt></p>
</font></blockquote>

								</li>
<li><p>The size of the valarray is not changed. Pointers and references to the elements remain valid.</P>

						</LI>
</UL>
					<P>In addition, you can assign values of the internal auxiliary classes <tT ClASs="monofont">slice_array, gslice_array, mask_array,</TT> and <TT CLass="monofont">indirect_array.</tT> See pages 575, 577, 578, and 579, respectively, for details about these classes.</P>

				
				<H5>Member Functions</H5>
					<p>Class <tt cLASS="monofont">valarray</tt> provides the following member functions.</p>

					<p><TT CLass="monofont">size_t</tt>
						<b><i>valarray</i></b><i>::size</i>
						<tt class="monofont">() const</tt></p>

					<UL>
<LI><P>Returns the actual number of elements.<FoNT sIZe="1"><SUP><A HRef="#FOOTNOTE-7">[7]</a></sUP></FOnt>
</p>
<bLOCKquotE><FONt size="1">
<p class="footnote">
<sup><a name="FOOTNOTE-7">[7]</a></sUP>
The member function <TT CLaSS="monofont">size()</tT> was called <Tt CLASS="monofont">length()</Tt> in earlier versions.</p>
</foNT></BLockqUOTE>

								
						</li>
</ul>
					<P><TT Class="monofont">void</tt>
						<b><i>valarray</i></b><i>::resize</i>
						<tt class="monofont">(size_t</tt>
						<I>num</I><TT CLaSS="monofont">)</tT></P>

					<p><TT CLASs="monofont">void</tt>
						<b><I>valarray</I></B><I>::resize</i>
						<tt cLASS="monofont">(size_t</tt>
						<i>num,</i>
						<TT CLass="monofont">T</tt>
						<i>value</i><tt class="monofont">)</tt></p>

					<ul>
<li><P>Both forms change the size of the valarray to <I>num.</I></P>
</LI>
<lI><P>If the size grows, the new elements are initialized by their default constructor or with <i>value</I> respectively.</P>
</lI>
<LI><P>Both forms invalidate all pointers and references to elements of the valarray.</P>
</Li>
<li><p>These functions are provided only to enable the creation of arrays of valarrays. After creating them with the default constructor you should give them the correct size by calling this function.</P>

						</LI>
</Ul>
					<p><tt CLASs="monofont">T</tt><b> valarray::</B><B>min</B>
						<Tt class="monofont">() const</tt></p>

					<p><tt class="monofont">T</tt>
						<b><i>valarray</I></B><I>::max</I>
						<TT cLAsS="monofont">() const</Tt></P>

					<UL>
<LI><P>The first form returns the minimum value of all elements.</p>
</li>
<lI><P>The second form returns the maximum value of all elements.</P>
</Li>
<li><p>The elements are compared with operator <TT CLass="monofont">&lt;</tT> or <TT Class="monofont">&gt;.</tt> Thus, these operators must be provided for the element type.</p>
</li>
<li><p>If the valarray contains no elements, the return value is undefined.</p>

						</li>
</ul>
					<p><tt cLASS="monofont">T</TT>
						<b><I>valarray</I></b><I>::sum</I>
						<tT CLASS="monofont">() const</tt></p>

					<uL>
<LI><P>Returns the sum of all elements.</p>
</li>
<lI><P>The elements are processed by operator <TT clasS="monofont">+=.</TT> Thus, this operator has to be provided for the element type.</P>
</li>
<li><p>If the valarray contains no elements, the return value is undefined.</p>

						</li>
</ul>
					<p><i>valarray</i>
						<b><i>valarray</i></b><i>::shift</i>
						<tt CLASS="monofont">(int</Tt>
						<I>num</I><tT ClASS="monofont">) const</TT></P>

					<ul>
<li><P>Returns a new valarray in which all elements are shifted by <I>num</I> positions.</P>
</li>
<li><P>The returned valarray has the same number of elements.</P>
</LI>
<li><p>Elements of positions that were shifted are initialized by their default constructor.</p>
</LI>
<LI><p>The direction of the shifting depends on the sign of <i>num:</i></p>

							<ul>
<li><p>If <i>num</i> is positive, it shifts to the left/front. Thus, elements get a smaller index.</p>
</li>
<li><p>If <i>num</i> is negative, it shifts to the right/back. Thus, elements get a higher index.</p>
</lI>
</UL>
						</LI>
</Ul>
					<P><I>valarray</i>
						<B><I>valarray</i></B><I>::cshift</I>
						<TT Class="monofont">(int</TT>
						<I>num</I><tt clASS="monofont">) const</Tt></p>

					<ul>
<LI><P>Returns a new valarray in which all elements are shifted cyclically by <I>num</i> positions.</p>
</li>
<li><p>The returned valarray has the same number of elements.</p>
</li>
<li><p>The direction of the shifting depends on the sign of <i>num:</i></p>

							<ul>
<li><p>If <I>num</I> is positive, it shifts to the left/front. Thus, elements get a smaller index or are inserted at the back.</P>
</LI>
<Li><P>If <I>num</i> is negative, it shifts to the right/back. Thus, elements get a higher index or are inserted at the front.</P>
</Li>
</UL>
						</LI>
</UL>
					<p><i>valarray</i>
						<b><I>valarray</I></B><I>::apply</i>
						<tt cLASS="monofont">(T</tt>
						<i>op</i>
						<TT CLass="monofont">(T)) const</tt></p>

					<p><i>valarray</i>
						<b><i>valarray</i></b><i>::apply</i>
						<tt clasS="monofont">(T</TT>
						<I>op</I>
						<Tt CLaSS="monofont">(const T&amp;)) const</tT></P>

					<UL>
<LI><p>Both forms return a new valarray with all elements processed by <i>op</i><tT CLAss="monofont">().</tt></P>
</LI>
<Li><p>The returned valarray has the same number of elements.</p>
</lI>
<LI><P>For each element of <tt class="monofont">*this,</tt> it calls <i>op</i><tt class="monofont">(</tt><i>elem</I><TT CLAsS="monofont">)</Tt> and initializes the corresponding element in the new returned valarray by its result.</P>

						</Li>
</UL>
				
				<H5>Element Access</H5>
					<P><Tt claSS="monofont">T &amp;</TT>
						<b><i>valarray</i></b><I>::operator [ ]</I>
						<TT clasS="monofont">(size_t</TT>
						<I>idx</i><tt class="monofont">)</tt></p>

					<p><tt class="monofont">T</tt>
						<B><I>valarray</I></B><I>::operator [ ]</I>
						<tT ClASs="monofont">(size_t</TT>
						<I>idx</I><TT clasS="monofont">) const</TT></P>

					<ul>
<li><P>Both forms return the valarray element that has index <I>idx</I> (the first element has index <Tt claSS="monofont">0</TT>).</p>
</li>
<li><p>The nonconstant version returns a reference. So, you can modify the element that is specified and returned by this operator. The reference is guaranteed to be valid as long as the valarray exists, and no function is called that modifies the size of the valarray.</p>

						</li>
</ul>
				
				<h5>Valarray Operators</h5>
					<p>Unary valarray operators have the following format:</p>

					<p><i>valarray</i>
						<b><i>valarray ::</i></B><I> unary-op</I>
						<TT ClASs="monofont">() const</TT></p>

					<UL>
<LI><P>A unary operator returns a new valarray that contains all values of <Tt claSS="monofont">*this</TT> modified by <b><i>unary-op.</i></b></P>
</LI>
<Li><p><b><i>unary-op</I></B> may he any of the following:</P>

							<Pre class="monofont">
   operator +
   operator -
   operator ~
   operator !
</pre>
						</li>
<li><p>The return type for operator <tt clasS="monofont">!</TT> is <TT ClASs="monofont">valarray&lt;bool&gt;.</TT></p>

						</LI>
</UL>
					<P>The binary operators for valarrays (except comparison and assignment operators) have the following format:</P>

					<p><i>valarray</i>
						<b><I>binary-op</I></B>
						<Tt claSS="monofont">(const</TT>
						<i>valarray</i><tt CLASs="monofont">&amp;</tt><i> va1,</i>
						<tt class="monofont">const</tt>
						<i>valarray</i><tt claSS="monofont">&amp;</TT><I> va2</I><tT ClASs="monofont">)</TT></P>

					<P><I>valarray</I>
						<b><i>binary-op</i></b>
						<TT CLass="monofont">(const</tT>
						<I>valarray</I><Tt claSS="monofont">&amp;</TT><i> va,</i>
						<tt class="monofont">const T&amp;</tt>
						<i>value</i><tt class="monofont">)</tT></P>

					<P><I>valarray</I>
						<B><i>binary-op</I></B>
						<tT ClASS="monofont">(const T&amp;</TT>
						<I>value,</i>
						<tt cLASS="monofont">const</tt>
						<i>valarray</i><TT CLass="monofont">&amp;</tT><I> va</I><Tt class="monofont">)</tt></p>

					<ul>
<li><p>These operators return a new valarray with the same number of elements as <tt class="monofont">va, va1,</TT> or <TT CLaSS="monofont">va2.</tT> The new valarray contains the result of computing <B><i>binary-op</I></B> for each value pair.</P>
</LI>
<Li><p>If only one operand is passed as a single <i>value,</i> it is combined with each element of <I>va.</I></P>
</Li>
<li><p><B><I>binary-op</I></B> may be any of the following:</p>

							<pre CLASs="monofont">
   operator +
   operator -
   operator *
   operator /
   operator %
   operator ~
   operator &amp;
   operator |
   operator &lt;&lt;
   operator &gt;&gt;
</pre>
						</li>
<li><p>If <i>va1</i> and <i>va2</i> have different numbers of elements, the result is undefined.</p>

						</li>
</ul>
					<p>The logical and comparison operators follow the same schema. However, their return values are a valarray of Boolean values:</p>

					<p><TT CLASs="monofont">valarray&lt;bool&gt;</TT>
						<b><I>logical-op</I></b>
						<TT CLASs="monofont">(const</tt>
						<i>valarray</I><TT Class="monofont">&amp;</TT><I> va1,</I>
						<tt clASS="monofont">const</Tt>
						<i>valarray</i><tt class="monofont">&amp;</tt><i> va2</i><tt class="monofont">)</TT></P>

					<P><TT cLAsS="monofont">valarray&lt;bool&gt;</Tt>
						<B><I>logical-op</I></B>
						<TT clasS="monofont">(const</TT>
						<I>valarray</i><tt cLASS="monofont">&amp;</tt><i> va,</i>
						<TT CLass="monofont">const T&amp;</tt>
						<i>value</i><tt class="monofont">)</tt></p>

					<p><tt cLASS="monofont">valarray&lt;bool&gt;</TT>
						<b><I>logical-op</I></b>
						<TT cLASS="monofont">(const T&amp;</TT>
						<i>value,</i>
						<tt CLASs="monofont">const</tt>
						<i>valarray</I><TT Class="monofont">&amp;</TT><I> va</I><tt class="monofont">)</tt></p>

					<ul>
<li><p>These operators return a new valarray with the same number of elements as <tt clasS="monofont">va, va1,</TT> or <TT ClASs="monofont">va2.</TT> The new valarray contains the result of computing <b><I>logical-op</I></B> for each value pair.</P>
</LI>
<li><p>If only one operand is passed as a single <i>value,</I> it is combined with each element of <I>va.</I></P>
</li>
<li><P><B><I>logical-op</I></b> may be any of the following:</p>

							<prE CLAss="monofont">
 
    operator ==
    operator !=
    operator &lt;
    operator &lt;=
    operator &gt;
    operator &gt;=
    operator &amp;&amp;
    operator ||
</pre>
						</li>
<li><p>If <i>va1</i> and <i>va2</i> have different numbers of elements, the result is undefined.</p>

						</li>
</ul>
					<p>Similarly, computed assignment operators are defined for valarrays:</p>

					<P><I>valarray</I><TT ClASs="monofont">&amp;</TT>
						<b><I>valarray::</I></B><I>assign-op</I>
						<Tt claSS="monofont">(const</TT>
						<i>valarray</i><tt CLASs="monofont">&amp;</tt><i> va</I><TT Class="monofont">)</tt></p>

					<p><i>valarray</i><tt class="monofont">&amp;</tt>
						<b><i>valarray::</I></B><I>assign-op</I>
						<TT cLAsS="monofont">(const T&amp;</Tt>
						<I>value</I><TT CLass="monofont">)</tT></P>

					<UL>
<li><p>Both forms call for each element in <tT CLAss="monofont">*this</tt>
								<B><I>assign-op</I></B> with the corresponding element of <i>va</i> or <i>value,</i> respectively, as the second operand.</p>
</li>
<li><p>They return a reference to the modified valarray.</p>
</li>
<li><p><b><i>assign-op</i></b> may be any of the following:</p>

							<PRE CLAsS="monofont">
     operator +=
     operator -=
     operator *=
     operator /=
     operator %=
     operator ^=
     operator &amp;=
     operator |=
     operator &lt;&lt;=
     operator &gt;&gt;=
</PrE>
						</Li>
<LI><P>If <TT Class="monofont">*this</TT> and <I>va2</I> have different numbers of elements, the result is undefined.</p>
</li>
<lI><P>References and pointers to modified elements stay valid as long as the valarray exists, and no function is called that modifies the size of the valarray.</P>

						</Li>
</ul>
				
				<h5>Transcendental Functions</H5>
					<P><I>valarray</I>
						<b>abs</b>
						<tt class="monofont">(const</tt>
						<i>valarray</i><tt class="monofont">&amp;</tT><I> va</I><TT ClASs="monofont">)</TT></p>

					<P><I>valarray</I>
						<B>pow</B>
						<Tt claSS="monofont">(const</TT>
						<i>valarray</i><tt CLASs="monofont">&amp;</tt><i> va1,</I>
						<TT Class="monofont">const</tt>
						<i>valarray</i><tt class="monofont">&amp;</tt><i> va2</i><tt CLASS="monofont">)</Tt></P>

					<P><i>valarray</I>
						<B>pow</b>
						<TT CLASs="monofont">(const</tt>
						<i>valarray</I><TT Class="monofont">&amp;</TT><I> va,</I>
						<tt clASS="monofont">const T&amp;</Tt>
						<i>value</i><tt class="monofont">)</tt></p>

					<p><i>valarray</i>
						<b>pow</b>
						<tt cLASS="monofont">(const T&amp;</TT>
						<i>value,</I>
						<Tt CLaSS="monofont">const</TT>
						<I>valarray</I><tt clASS="monofont">&amp;</Tt>
						<i>va</i><tT CLAss="monofont">)</tt></P>

					<P><I>valarray</I>
						<b>exp</b>
						<tt class="monofont">(const</tt>
						<i>valarray</i><tt class="monofont">&amp;</tT>
						<I>va</I><TT ClASs="monofont">)</TT></p>

					<P><I>valarray</I>
						<B>sqrt</B>
						<Tt claSS="monofont">(const</TT>
						<i>valarray</i><tt CLASs="monofont">&amp;</tt>
						<i>va</I><TT Class="monofont">)</tt></p>

					<p><i>valarray</i>
						<b>log</b>
						<tt class="monofont">(const</tt>
						<I>valarray</I><TT CLaSS="monofont">&amp;</tT>
						<I>va</i><TT CLASs="monofont">)</tt></p>

					<P><I>valarray</I>
						<B>log10</b>
						<tt cLASS="monofont">(const</tt>
						<i>valarray</i><TT CLass="monofont">&amp;</tt>
						<i>va</i><tt class="monofont">)</tt></p>

					<p><i>valarray</i>
						<b>sin</B>
						<TT CLAsS="monofont">(const</Tt>
						<I>valarray</I><tT CLASS="monofont">&amp;</tt>
						<i>va</i><TT CLass="monofont">)</tT></P>

					<P><I>valarray</i>
						<b>cos</b>
						<tT CLAss="monofont">(const</tt>
						<i>valarray</i><tt class="monofont">&amp;</tt>
						<i>va</i><tt clASS="monofont">)</TT></P>

					<p><I>valarray</I>
						<b>tan</B>
						<Tt CLASS="monofont">(const</Tt>
						<i>valarray</i><tT CLAss="monofont">&amp;</tt>
						<I>va</I><TT clasS="monofont">)</TT></P>

					<p><i>valarray</i>
						<b>sinh</b>
						<tt class="monofont">(const</tt>
						<i>valarray</i><tt claSS="monofont">&amp;</TT>
						<I>va</I><tT ClASs="monofont">)</TT></P>

					<P><I>valarray</I>
						<b>cosh</b>
						<tt CLASs="monofont">(const</tt>
						<i>valarray</I><TT Class="monofont">&amp;</TT>
						<I>va</I><tt class="monofont">)</tt></p>

					<p><i>valarray</i>
						<b>tanh</b>
						<tt clasS="monofont">(const</TT>
						<I>valarray</I><Tt CLaSS="monofont">&amp;</tT>
						<I>va</I><TT Class="monofont">)</TT></P>

					<P><i>valarray</i>
						<b>asin</b>
						<TT CLass="monofont">(const</tT>
						<I>valarray</I><Tt class="monofont">&amp;</tt>
						<i>va</i><tt class="monofont">)</tt></p>

					<p><I>valarray</I>
						<B>acos</B>
						<TT cLAsS="monofont">(const</Tt>
						<I>valarray</I><TT CLass="monofont">&amp;</tT>
						<I>va</I><Tt claSS="monofont">)</TT></p>

					<p><i>valarray</i>
						<B>atan</B>
						<TT class="monofont">(const</tt>
						<i>valarray</i><tt class="monofont">&amp;</tt>
						<i>va</i><tT CLASS="monofont">)</tT></P>

					<p><I>valarray</I>
						<b>atan2</B>
						<TT CLAss="monofont">(const</tt>
						<I>valarray</I><TT clasS="monofont">&amp;</TT>
						<I>va1,</i>
						<tt cLASS="monofont">const</tt>
						<i>valarray</i><tt class="monofont">&amp;</tt>
						<i>va2</i><tt clasS="monofont">)</TT></P>

					<P><I>valarray</i>
						<B>atan2</B>
						<tT ClASS="monofont">(const</TT>
						<I>valarray</i><tt cLASS="monofont">&amp;</tt>
						<i>va,</i>
						<TT CLass="monofont">const T&amp;</tT>
						<I>value</I><Tt class="monofont">)</tt></p>

					<p><i>valarray</i>
						<b>atan2</b>
						<tt class="monofont">(const T&amp;</TT>
						<I>value,</I>
						<TT cLAsS="monofont">const</Tt>
						<I>valarray</I><TT CLass="monofont">&amp;</tT>
						<I>va</I><Tt claSS="monofont">)</TT></p>

					<ul>
<lI><P>All of these functions return a new valarray with the same number of elements as <TT class="monofont">va, va1,</tt> or <tt class="monofont">va2.</tt> The new valarray contains the result of the corresponding operation called for each element or pair of elements.</p>
</li>
<li><P>If <I>va1</I> and <I>va2</I> have different numbers of elements, the result is undefined.</P>

						</lI>
</Ul>
				
			
			<H4>12.2.4
Valarray Subset Classes in Detail</H4>
				<p>This subsection describes the subset classes for valarray in detail. However, these classes are very simple and do not provide many operations, thus I provide only their declarations along with a few remarks.</P>

				<H5>Class <TT CLass="monofont">slice</tT> and Class <TT Class="monofont">slice_array</TT></H5>
					<P>Objects of class <tt clASS="monofont">slice_array</Tt> are created by using a <tt class="monofont">slice</tt> as the index of a nonconstant valarray:</p>

					<pre>
						
   namespace std {
       template&lt;class T&gt;
       class valarray {
         public:
           ...
           slice_array&lt;T&gt; operator[] (slice);
           ...
        };
   }

					</pre>

					<p>The exact definition of the public interface of class <tt cLASS="monofont">slice</TT> is as follows:</p>

					<PRe>
						
   namespace std {
       class slice {
         public:
           slice (); <I>// empty subset</I>
           slice (size_t start, size_t size, size_t stride);
           size_t start() const;
           size_t size() const;
           size_t stride() const;
       };
   }

					</pRE>

					<P>The default constructor creates an empty subset. With the <TT Class="monofont">start(), size(),</TT> and <TT clasS="monofont">stride()</TT> member functions, you can query the properties of a slice.</P>

					<p>The class <tt cLASS="monofont">slice_array</tt> provides the following operations:</p>

					<pre>
						
   namespace std {
       template &lt;class T&gt;
       class slice_array {
         public:
           typedef T value_type;


           void operator= (const T&amp;);
           void operator= (const valarray&lt;T&gt;&amp;) const;
           void operator*= (const valarray&lt;T&gt;&amp;) const;
           void operator/= (const valarray&lt;T&gt;&amp;) const;
           void operator%= (const valarray&lt;T&gt;&amp;) const;
           void operator+= (const valarray&lt;T&gt;&amp;) const;
           void operator-= (const valarray&lt;T&gt;&amp;) const;
           void operator~= (const valarray&lt;T&gt;&amp;) const;
           void operator&amp;= (const valarray&lt;T&gt;&amp;) const;
           void operator|= (const valarray&lt;T&gt;&amp;) const;
           void operator&lt;&lt;=(const valarray&lt;T&gt;&amp;) const;
           void operator&gt;&gt;=(const valarray&lt;T&gt;&amp;) const;
           ~slice_array();
         private:
           slice_array();
           slice_array(const slice_array&amp;);
           slice_array&amp; operator=(const slice_array&amp;);
           ...
       };
   }

					</pre>

					<p>Note that class <tt class="monofont">slice_array&lt;&gt;</tt> is intended purely as an internal helper class for slices and should be transparent to the user. Thus, all constructors and the assignment operator of class <tt CLASS="monofont">slice_array&lt;&gt;</Tt> are private.</P>

				
				<H5>Class <tT ClASS="monofont">gslice</TT> and Class <Tt claSS="monofont">gslice_array</TT></h5>
					<p>Objects of class <tt CLASs="monofont">gslice_array</tt> are created by using a <tT CLAss="monofont">gslice</tt> as the index of a nonconstant valarray:</p>

					<pre>
						
   namespace std {
       template&lt;class T&gt;
       class valarray {
         public:
           ...
           gslice_array&lt;T&gt; operator[] (const gslice&amp;);
           ...
       };
   }

					</pre>

					<p>The exact definition of the public interface of <tt class="monofont">gslice</tt> is as follows:</P>

					<PRE>
						
   namespace std {
       class gslice {
         public:
           gslice (); // <I>empty subset</I>
           gslice (size_t start,
                  const valarray&lt;size_t&gt;&amp; size,
                  const valarray&lt;size_t&gt;&amp; stride);
           size_t start() const;
           valarray&lt;size_t&gt; size() const;
           valarray&lt;size_t&gt; stride() const;
       };
   }

					</pRE>

					<p>The default constructor creates an empty subset. With the <TT cLASS="monofont">start(), size(),</TT> and <tt clASS="monofont">stride()</Tt> member functions you can query the properties of a gslice.</p>

					<p>The class <tT CLAss="monofont">gslice_array</tt> provides the following operations:</P>

					<PRE>
						
   namespace std {
       template &lt;class T&gt;
       class gslice_array {
         public:
           typedef T value_type;


           void operator= (const T&amp;);
           void operator= (const valarray&lt;T&gt;&amp;) const;
           void operator*= (const valarray&lt;T&gt;&amp;) const;
           void operator/= (const valarray&lt;T&gt;&amp;) const;
           void operator%= (const valarray&lt;T&gt;&amp;) const;
           void operator+= (const valarray&lt;T&gt;&amp;) const;
           void operator-= (const valarray&lt;T&gt;&amp;) const;
           void operator~= (const valarray&lt;T&gt;&amp;) const;
           void operator&amp;= (const valarray&lt;T&gt;&amp;) const;
           void operator|= (const valarray&lt;T&gt;&amp;) const;
           void operator&lt;&lt;=(const valarray&lt;T&gt;&amp;) const;
           void operator&gt;&gt;=(const valarray&lt;T&gt;&amp;) const;
           ~gslice_array();
         private:
           gslice_array();
           gslice_array(const gslice_array&lt;T&gt;&amp;);
           gslice_array&amp; operator=(const gslice_array&lt;T&gt;&amp;);
           ...
       };
   }

					</pre>

					<p>As with <tt class="monofont">slice_array&lt;&gt;,</tt> note that class <tt class="monofont">gslice_array&lt;&gt;</tT> is intended purely as an internal helper class for gslices and should be transparent to the user. Thus, all constructors and the assignment operator of class <TT CLAsS="monofont">gslice_array&lt;&gt;</Tt> are private.</P>

				
				<H5>Class <tT CLASS="monofont">mask_array</tt></h5>
					<p>Objects of class <TT CLass="monofont">mask_array</tT> are created by using a <TT Class="monofont">valarray&lt;bool&gt;</TT> as the index of a nonconstant valarray:</P>

					<Pre>
						
   namespace std {
       template&lt;class T&gt;
       class valarray {
         public:
          ...
          mask_array&lt;T&gt; operator[](const valarray&lt;bool&gt;&amp;);
          ...
      };
   }

					</pre>

					<p>The class <tt class="monofont">mask_array</tt> provides the following operations:</p>

					<pre>
						
   namespace std {
       template &lt;class T&gt;
       class mask_array {
         public:
           typedef T value_type;


           void operator= (const T&amp;);
           void operator= (const valarray&lt;T&gt;&amp;) const;
           void operator*= (const valarray&lt;T&gt;&amp;) const;
           void operator/= (const valarray&lt;T&gt;&amp;) const;
           void operator%= (const valarray&lt;T&gt;&amp;) const;
           void operator+= (const valarray&lt;T&gt;&amp;) const;
           void operator-= (const valarray&lt;T&gt;&amp;) const;
           void operator^= (const valarray&lt;T&gt;&amp;) const;
           void operator&amp;= (const valarray&lt;T&gt;&amp;) const;
           void operator|= (const valarray&lt;T&gt;&amp;) const;
           void operator&lt;&lt;=(const valarray&lt;T&gt;&amp;) const;
           void operator&gt;&gt;=(const valarray&lt;T&gt;&amp;) const;
           ~mask_array();
         private:
           mask_array();
           mask_array(const mask_array&lt;T&gt;&amp;);
           mask_array&amp; operator=(const mask_array&lt;T&gt;&amp;);
           ...
       };
   }

					</prE>

					<P>Again, note that class <TT CLaSS="monofont">mask_array&lt;&gt;</tT> is intended purely as an internal helper class and should be transparent to the user. Thus, all constructors and the assignment operator of class <Tt CLASS="monofont">mask_array&lt;&gt;</Tt> are private.</p>

				
				<h5>Class <tT CLAss="monofont">indirect_array</tt></H5>
					<P>Objects of class <TT clasS="monofont">indirect_array</TT> are created by using a <Tt class="monofont">valarray&lt;size_t&gt;</tt> as the index of a nonconstant valarray:</p>

					<pre>
						
   namespace std {
       template&lt;class T&gt;
       class valarray {
         public:
          ...
          indirect_array&lt;T&gt; operator[](const valarray&lt;size_t&gt;&amp;);
          ...
       };
   }

					</pre>

					<p>The class <tt claSS="monofont">indirect_array</TT> provides the following operations:</P>

					<PrE>
						
   namespace std {
       template &lt;class T&gt;
       class indirect_array {
         public:
          typedef T value_type;


          void operator= (const T&amp;);
          void operator= (const valarray&lt;T&gt;&amp;) const;
          void operator*= (const valarray&lt;T&gt;&amp;) const;
          void operator/= (const valarray&lt;T&gt;&amp;) const;
          void operator%= (const valarray&lt;T&gt;&amp;) const;
          void operator+= (const valarray&lt;T&gt;&amp;) const;
          void operator-= (const valarray&lt;T&gt;&amp;) const;
          void operator~= (const valarray&lt;T&gt;&amp;) const;
          void operator&amp;= (const valarray&lt;T&gt;&amp;) const;
          void operator|= (const valarray&lt;T&gt;&amp;) const;
          void operator&lt;&lt;=(const valarray&lt;T&gt;&amp;) const;
          void operator&gt;&gt;=(const valarray&lt;T&gt;&amp;) const;
          ~indirect_array();
        private:
          indirect_array();
          indirect_array(const indirect_array&lt;T&gt;&amp;);
          indirect_array&amp; operator=(const indirect_array&lt;T&gt;&amp;);
          ...
      };
   }

					</PrE>

					<P>As usual, class <tT CLASS="monofont">indirect, array &lt;&gt;</tt> is intended purely as an internal helper class and should he transparent to the user. Thus, all constructors and the assignment operator of <tt CLASs="monofont">indirect_array&lt;&gt;</tt> are private.</p>

				
			
		</FONT>
 
<table width="100%" border="0" cellspacing="0" cellpadding="0" bgcolor="#CCCCCC">
<td><font color="black" size=1>I l<font color="#FF0000">@</font>ve RuBoard</td>
<td valign="top" class="v2" align="right"><a href="0201379260_snode95.html"><img src="FILES/previous.gif" width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a> <a href="0201379260_snode97.html"><img src="FILES/next.gif" width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a></td></table>
</BODY></HTML>