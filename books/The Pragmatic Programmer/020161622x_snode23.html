<HTML><HEAD><META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=iso-8859-1">
<!--SafClassName="docSection1Title"--><!--SafTocEntry="Orthogonality"-->
<LINK REL="stylesheet" href="FILES/proquestM.css">
</HEAD>
<BODY link="#354278" vlink="#000066" alink="#000080" topmargin="0">
<table width="100%" border="0" cellspacing="0" cellpadding="0" bgcolor="#CCCCCC">
<td><font color="black" size=1>I l<font color="#FF0000">@</font>ve RuBoard</td>
<td valign="top" class="v2" align="right"><a href="020161622x_snode22.html"><img src="FILES/previous.gif" width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a> <a href="020161622x_snode24.html"><img src="FILES/next.gif" width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a></td></table>
<FONT><h3>Orthogonality</h3>
			<p>Orthogonality is a critical concept if you want to produce systems that are easy to design, build, test, and extend. However, the concept of orthogonality is rarely taught directly. Often it is an implicit feature of various other methods and techniques you learn. This is a mistake. Once you learn to apply the principle of orthogonality directly, you'll notice an immediate improvement in the quality of systems you produce.</p>

			<H4>What Is Orthogonality?</H4>
				<P>"Orthogonality" is a term borrowed from geometry. Two lines are orthogonal if they meet at right angles, such as the axes on a graph. In vector terms, the two lines are <I>independent.</i> Move along one of the lines, and your position projected onto the other doesn't change.</p>

				<br>

					
						
							<IMG BordeR="0" WIDth="250" height="167" src="FILES/orthogonality.gif" alt="graphics/orthogonality.gif"><br>
				<p>In computing, the term has come to signify a kind of independence or decoupling. Two or more things are orthogonal if changes in one do not affect any of the others. In a well-designed system, the database code will be orthogonal to the user interface: you can change the interface without affecting the database, and swap databases without changing the interface.</p>

				<p>Before we look at the benefits of orthogonal systems, let's first look at a system that isn't orthogonal.</p>

				<H5>A Nonorthogonal System</H5>
					<P>You're on a helicopter tour of the Grand Canyon when the pilot, who made the obvious mistake of eating fish for lunch, suddenly groans and faints. Fortunately, he left you hovering 100 feet above the ground. You rationalize that the collective pitch lever<Font siZe="1"><Sup><a HREF="#FOOTNOTE-2">[2]</A></sup></fONT>
 controls overall lift, so lowering it slightly will start a gentle descent to the ground. However, when you try it, you discover that life isn't that simple. The helicopter's nose drops, and you start to spiral down to the left. Suddenly you discover that you're flying a system where every control input has secondary effects. Lower the left-hand lever and you need to add compensating backward movement to the right-hand stick and push the right pedal. But then each of these changes affects all of the other controls again. Suddenly you're juggling an unbelievably complex system, where every change impacts all the other inputs. Your workload is phenomenal: your hands and feet are constantly moving, trying to balance all the interacting forces.</P>
<blocKQUOte><foNT SIze="1">
<p class="footnote">
<sup><a name="FOOTNOTE-2">[2]</a></sup>
Helicopters have four basic controls. The <I>cyclic</I> is the stick you hold in your right hand. Move it, and the helicopter moves in the corresponding direction. Your left hand holds the <I>collective pitch lever.</I> Pull up on this and you increase the pitch on all the blades, generating lift. At the end of the pitch lever is the <i>throttle.</i> Finally you have two foot <i>pedals,</i> which vary the amount of tail rotor thrust and so help turn the helicopter.</p>
</FoNt></blOCKQUote>

						
					<p>Helicopter controls are decidedly not orthogonal.</P>

				
			
			<H4>Benefits of Orthogonality</H4>
				<P>As the helicopter example illustrates, nonorthogonal systems are inherently more complex to change and control. When components of any system are highly interdependent, there is no such thing as a local fix.</p>

				<div CLASs="note"><p clASS="notetitle"><B>Tip 13</b></p><p>

					<p>Eliminate Effects Between Unrelated Things</p>

				</p></div>
<br>
<br>

				<p>We want to design components that are self-contained: independent, and with a single, well-defined purpose (what Yourdon and Constantine call <i>cohesion</i> [<a href="020161622x_snode87.html#44">YC86</A>]). When components are isolated from one another, you know that you can change one without having to worry about the rest. As long as you don't change that component's external interfaces, you can be comfortable that you won't cause problems that ripple through the entire system.</P>

				<P>You get two major benefits if you write orthogonal systems: increased productivity and reduced risk.</p>

				<h5>Gain Productivity</h5>
					<ul>
<Li><P>Changes are localized, so development time and testing time are reduced. It is easier to write relatively small, self-contained components than a single large block of code. Simple components can be designed, coded, unit tested, and then forgotten—there is no need to keep changing existing code as you add new code.</p>
</li>
<LI><P>An orthogonal approach also promotes reuse. If components have specific, well-defined responsibilities, they can be combined with new components in ways that were not envisioned by their original implementors. The more loosely coupled your systems, the easier they are to reconfigure and reengineer.</P>
</Li>
<li><p>There is a fairly subtle gain in productivity when you combine orthogonal components. Assume that one component does <I>M</I> distinct things and another does <I>N</I> things. If they are orthogonal and you combine them, the result does <i>M × N</i> things. However, if the two components are not orthogonal, there will be overlap, and the result will do less. You get more functionality per unit effort by combining orthogonal components.</p>

						</lI>
</UL>
				
				<H5>Reduce Risk</h5>
					<p>An orthogonal approach reduces the risks inherent in any development.</p>

					<uL>
<LI><P>Diseased sections of code are isolated. If a module is sick, it is less likely to spread the symptoms around the rest of the system. It is also easier to slice it out and transplant in something new and healthy.</p>
</li>
<li><p>The resulting system is less fragile. Make small changes and fixes to a particular area, and any problems you generate will be restricted to that area.</p>
</li>
<li><p>An orthogonal system will probably be better tested, because it will be easier to design and run tests on its components.</p>
</li>
<li><p>You will not be as tightly tied to a particular vendor, product, or platform, because the interfaces to these third-party components will be isolated to smaller parts of the overall development.</p>

						</lI>
</UL>
					<P>Let's look at some of the ways you can apply the principle of orthogonality to your work.</p>

				
			
			<h4>Project Teams</h4>
				<p>Have you noticed how some project teams are efficient, with everyone knowing what to do and contributing fully, while the members of other teams are constantly bickering and don't seem able to get out of each other's way?</p>

				<P>Often this is an orthogonality issue. When teams are organized with lots of overlap, members are confused about responsibilities. Every change needs a meeting of the entire team, because any one of them <i>might</I> be affected.</p>

				<p>How do you organize teams into groups with well-defined responsibilities and minimal overlap? There's no simple answer. It depends partly on the project and your analysis of the areas of potential change. It also depends on the people you have available. Our preference is to start by separating infrastructure from application. Each major infrastructure component (database, communications interface, middleware layer, and so on) gets its own subteam. Each obvious division of application functionality is similarly divided. Then we look at the people we have (or plan to have) and adjust the groupings accordingly.</p>

				<P>You can get an informal measure of the orthogonality of a project team's structure. Simply see how many people <I>need</I> to be involved in discussing each change that is requested. The larger the number, the less orthogonal the group. Clearly, an orthogonal team is more efficient. (Having said this, we also encourage subteams to communicate constantly with each other.)</P>

			
			<H4>Design</h4>
				<p>Most developers are familiar with the need to design orthogonal systems, although they may use words such as <i>modular, component-based,</i> and <I>layered</I> to describe the process. Systems should be composed of a set of cooperating modules, each of which implements functionality independent of the others. Sometimes these components are organized into layers, each providing a level of abstraction. This layered approach is a powerful way to design orthogonal systems. Because each layer uses only the abstractions provided by the layers below it, you have great flexibility in changing underlying implementations without affecting code. Layering also reduces the risk of runaway dependencies between modules. You'll often see layering expressed in diagrams such as <A href="020161622x_snode23.html#9">Figure 2.1</a> on the next page.</P>

				<CENter>
					<h5>
<A NAMe="9"></a>Figure 2.1. Typical layer diagram</h5><img border="0" width="317" heiGHT="204" src="FILES/02fig01.gif" alt="graphics/02fig01.gif"></CeNter>

				<P>There is an easy test for orthogonal design. Once you have your components mapped out, ask yourself: <I>If I dramatically change the requirements behind a particular function, how many modules are affected?</I> In an orthogonal system, the answer should be "one."<FOnt siZE="1"><SUp><a hrEF="#FOOTNOTE-3">[3]</A></Sup></foNT>
 Moving a button on a GUI panel should not require a change in the database schema. Adding context-sensitive help should not change the billing subsystem.</P>
<Blockquote><font size="1">
<p clASS="footnote">
<Sup><a naMe="FOOTNOTE-3">[3]</A></sup>
In reality, this is naive. Unless you are remarkably lucky, most real-world requirements changes will affect multiple functions in the system. However, if you analyze the change in terms of functions, each functional change should still ideally affect just one module.</P>
</FONT></blocKQUOte>

					
				<p>Let's consider a complex system for monitoring and controlling a heating plant. The original requirement called for a graphical user interface, but the requirements were changed to add a voice response system with touchtone telephone control of the plant. In an orthogonally designed system, you would need to change only those modules associated with the user interface to handle this: the underlying logic of controlling the plant would remain unchanged. In fact, if you structure your system carefully, you should be able to support both interfaces with the same underlying code base. <a href="020161622x_snode58.html">It's Just a View</a>, talks about writing decoupled code using the Model-View-Controller (MVC) paradigm, which works well in this situation.</p>

				<p>Also ask yourself how decoupled your design is from changes in the real world. Are you using a telephone number as a customer identifier? What happens when the phone company reassigns area codes? <i>Don't rely on the properties of things you can't control.</I></P>

			
			<H4>Toolkits and Libraries</H4>
				<p>Be careful to preserve the orthogonality of your system as you introduce third-party toolkits and libraries. Choose your technologies wisely.</p>

				<p>We once worked on a project that required that a certain body of Java code run both locally on a server machine and remotely on a client machine. The alternatives for distributing classes this way were RMI and CORBA. If a class were made remotely accessible using RMI, every call to a remote method in that class could potentially throw an exception, which means that a naive implementation would require us to handle the exception whenever our remote classes were used. Using RMI here is clearly not orthogonal: code calling our remote classes should not have to be aware of their locations. The alternative—using CORBA—did not impose that restriction: we could write code that was unaware of our classes' locations.</p>

				<p>When you bring in a toolkit (or even a library from other members of your team), ask yourself whether it imposes changes on your code that shouldn't be there. If an object persistence scheme is transparent, then it's orthogonal. If it requires you to create or access objects in a special way, then it's not. Keeping such details isolated from your code has the added benefit of making it easier to change vendors in the future.</p>

				<p>The Enterprise Java Beans (EJB) system is an interesting example of orthogonality. In most transaction-oriented systems, the application code has to delineate the start and end of each transaction. With EJB, this information is expressed declaratively as metadata, outside any code. The same application code can run in different EJB transaction environments with no change. This is likely to be a model for many future environments.</p>

				<p>Another interesting twist on orthogonality is Aspect-Oriented Programming (AOP), a research project at Xerox Parc ([<a href="020161622x_snode87.html#20">KLM<sup>+</sup>97</A>] and [<A href="020161622x_snode86.html#57">URL 49</a>]). AOP lets you express in one place behavior that would otherwise be distributed throughout your source code. For example, log messages are normally generated by sprinkling explicit calls to some log function throughout your source. With AOP, you implement logging orthogonally to the things being logged. Using the Java version of AOP, you could write a log message when entering any method of class <tt ClAss="monofont">Fred</tT> by coding the <I>aspect:</I></P>

				<Pre>
					
    <b>aspect</b> Trace {
      <B>advise</B> * Fred.*(..) {
        <B>static before</B> {
          Log.write("-&gt; <i>Entering</i> " + thisJoinPoint.methodName);
        }
      }
    }
</prE>

				<P>If you <I>weave</I> this aspect into your code, trace messages will be generated. If you don't, you'll see no messages. Either way, your original source is unchanged.</p>

			
			<h4>Coding</h4>
				<p>Every time you write code you run the risk of reducing the orthogonality of your application. Unless you constantly monitor not just what you are doing but also the larger context of the application, you might unintentionally duplicate functionality in some other module, or express existing knowledge twice.</P>

				<P>There are several techniques you can use to maintain orthogonality:</P>

				<Ul>
<li><p><b>Keep your code decoupled.  </b>

							Write shy code—modules that don't reveal anything unnecessary to other modules and that don't rely on other modules' implementations. Try the Law of Demeter [<a href="020161622x_snode87.html#27">LH89</a>], which we discuss in <a href="020161622x_snode55.html">Decoupling and the Law of Demeter</a>. If you need to change an object's state, get the object to do it for you. This way your code remains isolated from the other code's implementation and increases the chances that you'll remain orthogonal.</p>
</lI>
<LI><P><b>Avoid global data.  </b>

							Every time your code references global data, it ties itself into the other components that share that data. Even globals that you intend only to read can lead to trouble (for example, if you suddenly need to change your code to be multithreaded). In general, your code is easier to understand and maintain if you explicitly pass any required context into your modules. In object-oriented applications, context is often passed as parameters to objects' constructors. In other code, you can create structures containing the context and pass around references to them.</p>
<p>The Singleton pattern in <i>Design Patterns</I> [<a href="020161622x_snode87.html#15">GHJV95</A>] is a way of ensuring that there is only one instance of an object of a particular class. Many people use these singleton objects as a kind of global variable (particularly in languages, such as Java, that otherwise do not support the concept of globals). Be careful with singletons—they can also lead to unnecessary linkage.</P>
</LI>
<Li><p><b>Avoid similar functions.  </b>

							Often you'll come across a set of functions that all look similar—maybe they share common code at the start and end, but each has a different central algorithm. Duplicate code is a symptom of structural problems. Have a look at the Strategy pattern in <I>Design Patterns</I> for a better implementation.</P>

					</Li>
</ul>
				<p>Get into the habit of being constantly critical of your code. Look for any opportunities to reorganize it to improve its structure and orthogonality. This process is called <I>refactoring,</I> and it's so important that we've dedicated a section to it (see <A href="020161622x_snode64.html">Refactoring</a>).</P>

			
			<H4>Testing</H4>
				<P>An orthogonally designed and implemented system is easier to test. Because the interactions between the system's components are formalized and limited, more of the system testing can be performed at the individual module level. This is good news, because module level (or unit) testing is considerably easier to specify and perform than integration testing. In fact, we suggest that every module have its own unit test built into its code, and that these tests be performed automatically as part of the regular build process (see <a href="020161622x_snode65.html">Code That's Easy to Test</a>).</p>

				<p>Building unit tests is itself an interesting test of orthogonality. What does it take to build and link a unit test? Do you have to drag in a large percentage of the rest of the system just to get a test to compile or link? If so, you've found a module that is not well decoupled from the rest of the system.</p>

				<p>Bug fixing is also a good time to assess the orthogonality of the system as a whole. When you come across a problem, assess how localized the fix is. Do you change just one module, or are the changes scattered throughout the entire system? When you make a change, does it fix everything, or do other problems mysteriously arise? This is a good opportunity to bring automation to bear. If you use a source code control system (and you will after reading <a href="020161622x_snode34.html">Source Code Control</a>), tag bug fixes when you check the code back in after testing. You can then run monthly reports analyzing trends in the number of source files affected by each bug fix.</p>

			
			<h4>Documentation</h4>
				<p>Perhaps surprisingly, orthogonality also applies to documentation. The axes are content and presentation. With truly orthogonal documentation, you should be able to change the appearance dramatically without changing the content. Modern word processors provide style sheets and macros that help (see <A href="020161622x_snode79.html">It's All Writing</a>).</p>

			
			<h4>Living with Orthogonality</h4>
				<P>Orthogonality is closely related to the <i>DRY</I> principle introduced on page 27. With <i>DRY,</i> you're looking to minimize duplication within a system, whereas with orthogonality you reduce the interdependency among the system's components. It may be a clumsy word, but if you use the principle of orthogonality, combined closely with the <i>DRY</I> principle, you'll find that the systems you develop are more flexible, more understandable, and easier to debug, test, and maintain.</P>

				<P>If you're brought into a project where people are desperately struggling to make changes, and where every change seems to cause four other things to go wrong, remember the nightmare with the helicopter. The project probably is not orthogonally designed and coded. It's time to refactor.</P>

				<P>And, if you're a helicopter pilot, don't eat the fish….</p>

				<h5>Related sections include:</h5>
					<uL>
<LI><P><a href="020161622x_snode22.html">The Evils of Duplication</A></P>
</Li>
<li><p><A href="020161622x_snode34.html">Source Code Control</a></p>
</li>
<li><p><a href="020161622x_snode43.html">Design by Contract</a></p>
</li>
<li><p><A href="020161622x_snode55.html">Decoupling and the Law of Demeter</a></p>
</li>
<Li><P><a href="020161622x_snode56.html">Metaprogramming</A></P>
</Li>
<li><p><A href="020161622x_snode58.html">It's Just a View</a></p>
</lI>
<LI><P><a href="020161622x_snode64.html">Refactoring</A></P>
</Li>
<li><p><a href="020161622x_snode65.html">Code That's Easy to Test</a></p>
</li>
<li><p><a href="020161622x_snode66.html">Evil Wizards</A></P>
</Li>
<li><p><a href="020161622x_snode76.html">Pragmatic Teams</a></p>
</LI>
<LI><P><a href="020161622x_snode79.html">It's All Writing</A></P>

						</Li>
</ul>
				
				<h5>Challenges</H5>
					<UL>
<Li><p>Consider the difference between large GUI-oriented tools typically found on Windows systems and small but combinable command line utilities used at shell prompts. Which set is more orthogonal, and why? Which is easier to use for exactly the purpose for which it was intended? Which set is easier to combine with other tools to meet new challenges?</p>
</lI>
<LI><P>C++ supports multiple inheritance, and Java allows a class to implement multiple interfaces. What impact does using these facilities have on orthogonality? Is there a difference in impact between using multiple inheritance and multiple interfaces? Is there a difference between using delegation and using inheritance?</p>

						</li>
</ul>
				
			
			<h4>Exercises</h4>
				<p><table boder="0" ceLLSPacing="16" CeLlpaDDING="0">
					<tr vaLIGN="top"><td alIGN="right"><A name="19"></A><FONt><b>1.</b></font></td><td><font><p> <a href="020161622x_cnode88.html#1">You are writing a class called Split, which splits input lines into fields. Which of the following two Java class signatures is the more orthogonal design?</A></P>

							<Pre>
								
    <b>class</b> Split1 {
      <b>public</B> Split1(InputStreamReader rdr) { ...
      <b>public void</B> readNextLine() <b>throws</b> IOException { ...
      <b>public int</B> numFields() { ...
      <B>public</B> String getField(<B>int</B> fieldNo) { ...
    }
    <b>class</b> Split2 {
      <b>public</b> Split2(String line) { ...
      <B>public int</B> numFields()     { ...
      <B>public</B> String getField(<b>int</b> fieldNo) { ...
    }
</prE>

						</FONt></td></tR>
					<TR Valign="top"><td align="right"><a name="20"></a><foNT><B>2.</B></font></tD><tD><fonT><P> <A href="020161622x_cnode88.html#2">Which will lead to a more orthogonal design: modeless or modal dialog boxes?</a></p>
</FONT></td></tr>
					<TR VAlign="top"><TD ALign="right"><a name="21"></a><font><b>3.</b></font></tD><TD><Font><p> <a href="020161622x_cnode88.html#3">How about procedural languages versus object technology? Which results in a more orthogonal system?</a></p>
</FONT></Td></tr>
				</tABLE></p>
			
		</fonT>
 
<table width="100%" border="0" cellspacing="0" cellpadding="0" bgcolor="#CCCCCC">
<td><font color="black" size=1>I l<font color="#FF0000">@</font>ve RuBoard</td>
<td valign="top" class="v2" align="right"><a href="020161622x_snode22.html"><img src="FILES/previous.gif" width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a> <a href="020161622x_snode24.html"><img src="FILES/next.gif" width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a></td></table>
</BODY></HTML>