<HTML><HEAD><META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=iso-8859-1">
<!--SafClassName="docSection1Title"--><!--SafTocEntry="Text Manipulation"-->
<LINK REL="stylesheet" href="FILES/proquestM.css">
</HEAD>
<BODY link="#354278" vlink="#000066" alink="#000080" topmargin="0">
<table width="100%" border="0" cellspacing="0" cellpadding="0" bgcolor="#CCCCCC">
<td><font color="black" size=1>I l<font color="#FF0000">@</font>ve RuBoard</td>
<td valign="top" class="v2" align="right"><a href="020161622x_snode37.html"><img src="FILES/previous.gif" width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a> <a href="020161622x_snode39.html"><img src="FILES/next.gif" width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a></td></table>
<FONT><h3>Text Manipulation</h3>
			<p>Pragmatic Programmers manipulate text the same way woodworkers shape wood. In previous sections we discussed some specific tools—shells, editors, debuggers—that we use. These are similar to a wood-worker's chisels, saws, and planes—tools specialized to do one or two jobs well. However, every now and then we need to perform some transformation not readily handled by the basic tool set. We need a general-purpose text manipulation tool.</p>

			<P>Text manipulation languages are to programming what routers<FONt sizE="1"><SUP><a hreF="#FOOTNOTE-8">[8]</A></SUp></font>
 are to woodworking. They are noisy, messy, and somewhat brute force. Make mistakes with them, and entire pieces can be ruined. Some people swear they have no place in the toolbox. But in the right hands, both routers and text manipulation languages can be incredibly powerful and versatile. You can quickly trim something into shape, make joints, and carve. Used properly, these tools have surprising finesse and subtlety. But they take time to master.</p>
<blockquote><font SIZE="1">
<p clasS="footnote">
<sUp><a nAME="FOOTNOTE-8">[8]</A></Sup>
Here <i>router</i> means the tool that spins cutting blades very, very fast, not a device for interconnecting networks.</P>
</FONt></bloCKQUote>

				
			<p>There is a growing number of good text manipulation languages. Unix developers often like to use the power of their command shells, augmented with tools such as <TT CLass="monofont">awk</tt> and <tt class="monofont">sed.</tt> People who prefer a more structured tool like the object-oriented nature of Python [<a href="020161622x_snode86.html#13">URL 9</a>]. Some people use Tcl [<A href="020161622x_snode86.html#27">URL 23</a>] as their tool of choice. We happen to prefer Perl [<a href="020161622x_snode86.html#12">URL 8</A>] for hacking out short scripts.</p>

			<p>These languages are important enabling technologies. Using them, you can quickly hack up utilities and prototype ideas—jobs that might take five or ten times as long using conventional languages. And that multiplying factor is crucially important to the kind of experimenting that we do. Spending 30 minutes trying out a crazy idea is a whole lot better that spending five hours. Spending a day automating important components of a project is acceptable; spending a week might not be. In their book <i>The Practice of Programming</I> [<A href="020161622x_snode87.html#24">KP99</a>], Kernighan and Pike built the same program in five different languages. The Perl version was the shortest (17 lines, compared with C's 150). With Perl you can manipulate text, interact with programs, talk over networks, drive Web pages, perform arbitrary precision arithmetic, and write programs that look like Snoopy swearing.</p>

			<dIV CLass="note"><p CLASs="notetitle"><b>Tip 28</b></p><P>

				<P>Learn a Text Manipulation Language</P>

			</P></div>
<br>
<br>

			<p>To show the wide-ranging applicability of text manipulation languages, here's a sample of some applications we've developed over the last few years.</p>

			<ul>
<li><p><b>Database schema maintenance.  </b>

						A set of Perl scripts took a plain text file containing a database schema definition and from it generated:</p>

					<ul>
<lI><P>The SQL statements to create the database</P>
</Li>
<li><p>Flat data files to populate a data dictionary</p>
</Li>
<Li><p>C code libraries to access the database</p>
</LI>
<LI><P>Scripts to check database integrity</p>
</li>
<lI><P>Web pages containing schema descriptions and diagrams</P>
</Li>
<li><p>An XML version of the schema</P>

						</LI>
</Ul>
				</li>
<lI><P><B>Java property access.  </B>

						It is good OO programming style to restrict access to an object's properties, forcing external classes to get and set them via methods. However, in the common case where a property is represented inside the class by a simple member variable, creating a get and set method for each variable is tedious and mechanical. We have a Perl script that modifies the source files and inserts the correct method definitions for all appropriately flagged variables.</p>
</li>
<li><p><b>Test data generation.  </b>

						We had tens of thousands of records of test data, spread over several different files and formats, that needed to be knitted together and converted into a form suitable for loading into a relational database. Perl did it in a couple of hours (and in the process found a couple of consistency errors in the original data).</p>
</li>
<li><p><b>Book writing.  </b>

						We think it is important that any code presented in a book should have been tested first. Most of the code in this book has been. However, using the <i>DRY</i> principle (see <a href="020161622x_snode22.html">The Evils of Duplication</A>) we didn't want to copy and paste lines of code from the tested programs into the book. That would have meant that the code was duplicated, virtually guaranteeing that we'd forget to update an example when the corresponding program was changed. For some examples, we also didn't want to bore you with all the framework code needed to make our example compile and run. We turned to Perl. A relatively simple script is invoked when we format the book—it extracts a named segment of a source file, does syntax highlighting, and converts the result into the typesetting language we use.</p>
</li>
<li><P><b>C to Object Pascal interface.  </B>

						A client had a team of developers writing Object Pascal on PCs. Their code needed to interface to a body of code written in C. We developed a short Perl script that parsed the C header files, extracting the definitions of all exported functions and the data structures they used. We then generated Object Pascal units with Pascal records for all the C structures, and imported procedure definitions for all the C functions. This generation process became part of the build, so that whenever the C header changed, a new Object Pascal unit would be constructed automatically.</p>
</li>
<LI><P><B>Generating Web documentation.  </B>

						Many project teams are publishing their documentation to internal Web sites. We have written many Perl programs that analyze database schemas, C or C++ source files, makefiles, and other project sources to produce the required HTML documentation. We also use Perl to wrap the documents with standard headers and footers, and to transfer them to the Web site.</p>

				</li>
</uL>
			<P>We use text manipulation languages almost every day. Many of the ideas in this book can be implemented more simply in them than in any other language of which we're aware. These languages make it easy to write code generators, which we'll look at next.</P>

			<H4>Related sections include:</h4>
				<ul>
<lI><P><A href="020161622x_snode22.html">The Evils of Duplication</a></P>

					</LI>
</Ul>
			
		</font>
 
<table width="100%" border="0" cellspacing="0" cellpadding="0" bgcolor="#CCCCCC">
<td><font color="black" size=1>I l<font color="#FF0000">@</font>ve RuBoard</td>
<td valign="top" class="v2" align="right"><a href="020161622x_snode37.html"><img src="FILES/previous.gif" width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a> <a href="020161622x_snode39.html"><img src="FILES/next.gif" width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a></td></table>
</BODY></HTML>