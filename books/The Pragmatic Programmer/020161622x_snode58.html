<HTML><HEAD><META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=iso-8859-1">
<!--SafClassName="docSection1Title"--><!--SafTocEntry="It's Just a View"-->
<LINK REL="stylesheet" href="FILES/proquestM.css">
</HEAD>
<BODY link="#354278" vlink="#000066" alink="#000080" topmargin="0">
<table width="100%" border="0" cellspacing="0" cellpadding="0" bgcolor="#CCCCCC">
<td><font color="black" size=1>I l<font color="#FF0000">@</font>ve RuBoard</td>
<td valign="top" class="v2" align="right"><a href="020161622x_snode57.html"><img src="FILES/previous.gif" width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a> <a href="020161622x_snode59.html"><img src="FILES/next.gif" width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a></td></table>
<FONT size="-1"><H3>It's Just a View</H3>
			<P><I>Still, a man hears</i></p>

			<p><i>What he wants to hear</I></P>

			<P><I>And disregards the rest</i></p>

			<p><i>La la la…</I></P>

			<P><I></i>
				<b>Simon and Garfunkel, "The Boxer"</b></p>

			<p>Early on we are taught not to write a program as a single big chunk, but that we should "divide and conquer" and separate a program into modules. Each module has its own responsibilities; in fact, a good definition of a module (or class) is that it has a single, well-defined responsibility.</p>

			<p>But once you separate a program into different modules based on responsibility, you have a new problem. At runtime, how do the objects talk to each other? How do you manage the logical dependencies between them? That is, how do you synchronize changes in state (or updates to data values) in these different objects? It needs to be done in a clean, flexible manner—we don't want them to know too much about each other. We want each module to be like the man in the song and just hear what it wants to hear.</p>

			<p>We'll start off with the concept of an <i>event</i>. An event is simply a special message that says "something interesting just happened" (interesting, of course, lies in the eye of the beholder). We can use events to signal changes in one object that some other object may be interested in.</p>

			<p>Using events in this way minimizes coupling between those objects—the sender of the event doesn't need to have any explicit knowledge of the receiver. In fact, there could be multiple receivers, each one focused on its own agenda (of which the sender is blissfully unaware).</p>

			<p>We need to exercise some care in using events, however. In an early version of Java, for example, one routine received <i>all</i> the events destined for a particular application. Not exactly the road to easy maintenance or evolution.</p>

			<h4>Publish/Subscribe</h4>
				<P>Why is it bad to push all the events through a single routine? It violates object encapsulation—that one routine now has to have intimate knowledge of the interactions among many objects. It also increases the coupling—and we're trying to <I>decrease</I> coupling. Because the objects themselves have to have knowledge of these events as well, you are probably going to violate the <I>DRY</i> principle, orthogonality, and perhaps even sections of the Geneva Convention. You may have seen this kind of code—it is usually dominated by a huge <tt clAsS="monofont">case</tt> statement or multiway <tT CLASs="monofont">if-then.</tt> We can do better.</p>

				<P>Objects should be able to register to receive only the events they need, and should never be sent events they don't need. We don't want to spam our objects! Instead, we can use a <I>publish/subscribe</I> protocol, illustrated using the <I>UML sequence diagram</i> in <a href="020161622x_snode58.html#3">Figure 5.4</A> on the next page.<Font sIZE="1"><Sup><a href="#FOOTNOTE-7">[7]</a></sup></font>
</p>
<blocKQUOte><fonT sIze="1">
<p CLASS="footnote">
<sup><a NAME="FOOTNOTE-7">[7]</a></sup>
See also the Observer pattern in [<A href="020161622x_snode87.html#15">GHJV95</a>] for more information.</p>
</fONT></Blockquote>

					
				<center>
					<h5>
<a namE="3"></A>Figure 5.4. Publish/subscribe protocol</H5><Img borDeR="0" widTH="344" HEIght="269" src="FILES/05fig04.gif" ALt="graphics/05fig04.gif"></cenTER>

				<P>A sequence diagram shows the flow of messages among several objects, with objects arranged in columns. Each message is shown as a labeled arrow from the sender's column to the receiver's column. An asterisk in the label means that more than one message of this type can be sent.</p>

				<p>If we are interested in certain events generated by a <tt CLASs="monofont">Publisher,</tt> all we have to do is register ourselves. The <tt class="monofont">Publisher</tt> keeps track of all interested <tt class="monofont">Subscriber</tT> objects; when the <TT Class="monofont">Publisher</tT> generates an event of interest, it will call each <tT claSS="monofont">Subscriber</TT> in turn and notify them that the event has occurred.</P>

				<p>There are several variations on this theme—mirroring other communication styles. Objects may use publish/subscribe on a peer-to-peer basis (as we saw above); they may use a "software bus" where a centralized object maintains the database of listeners and dispatches messages appropriately. You might even have a scheme where critical events get broadcast to all listeners—registered or not. One possible implementation of events in a distributed environment is illustrated by the CORBA Event Service, described in the box on the following page.</p>

				<p>We can use this publish/subscribe mechanism to implement a very important design concept: the separation of a model from views of the model. Let's start with a GUI-based example, using the Smalltalk design in which this concept was born.</p>

			
			<H4>Model-View-Controller</H4>
				<P>Suppose you have a spreadsheet application. In addition to the numbers in the spreadsheet itself, you also have a graph that displays the numbers as a bar chart and a running total dialog box that shows the sum of a column in the spreadsheet.</P>

				<p><tabLE CEllspACINg="0" width="90%" border="1"><tr><td><centER><H2>
The CORBA Event Service</H2></centeR>
					<p>The CORBA Event Service allows participating objects to send and receive event notifications via a common bus, the <I>event channel.</i> The event channel arbitrates event handling, and also decouples event producers from event consumers. It works in two basic ways: <i>push</i> and <I>pull.</I></P>

					<P>In push mode, event suppliers inform the event channel that an event has occurred. The channel then automatically distributes that event to all client objects that have registered interest.</P>

					<p>In pull mode, clients periodically poll the event channel, which in turn polls the supplier that offers event data corresponding to the request.</p>

					<p>Although the CORBA Event Service can be used to implement all of the event models discussed in this section, you can also view it as a different animal. CORBA facilities communication among objects written in different programming languages running on geographically dispersed machines with different architectures. Sitting on top of CORBA, the event service give you a decoupled way of interacting with applications around the world, written by people you've never met, using programming languages you'd rather not know about.</p>

				</TD></TR></tablE></P>

				<P>Obviously, we don't want to have three separate copies of the data. So we create a <I>model—</i>the data itself, with common operations to manipulate it. Then we can create separate <i>views</i> that display the data in different ways: as a spreadsheet, as a graph, or in a totals box. Each of these views may have its own <i>controller.</I> The graph view may have a controller that allows you to zoom in or out, or pan around the data, for example. None of this affects the data itself, just that view.</P>

				<P>This is the key concept behind the Model-View-Controller (MVC0 idiom: separating the model from both the GUI that represents it and the controls that manage the view.<Font size="1"><sup><a href="#FOOTNOTE-8">[8]</a></sup></fONT>
</P>
<blockQuOte><fONT SIze="1">
<p cLASS="footnote">
<sup><a NAME="FOOTNOTE-8">[8]</a></sup>
The view and controller are tightly coupled, and in some Implementations of MVC the view and controller are a single component.</P>
</FONt></blockquote>

					
				<p>By doing so, you can take advantage of some interesting possibilities. You can support multiple views of the same data model. You can use common viewers on many different data models. You can even support multiple controllers to provide nontraditional input mechanisms.</p>

				<div clasS="note"><P CLass="notetitle"><b>Tip 42</b></P><p>

					<P>Separate Views from Models</p>

				</p></dIV>
<BR>
<Br>

				<p>By loosening the coupling between the model and the view/controller, you buy yourself a lot of flexibility at low cost. In fact, this technique is one of the most important ways of maintaining reversibility (see <a href="020161622x_snode24.html">Reversibility</A>).</p>

				<h5>Java Tree View</h5>
					<p>A good example of an MVC design can be found in the Java tree widget. The tree widget (which displays a clickable, traversable tree) is actually a set of several different classes organized in an MVC pattern.</P>

					<P>To produce a fully functional tree widget, all you need to do is provide a data source that conforms to the <TT clasS="monofont">TreeModel</TT> interface. Your code now becomes the model for the tree.</P>

					<p>The view is created by the <tt class="monofont">TreeCellRenderer</tt> and <tt class="monofont">TreeCellEditor</tt> classes, which can be inherited from and customized to provide different colors, fonts, and icons in the widget. <tT CLAss="monofont">JTree</tt> acts as the controller for the tree widget and provides some general viewing functionality.</p>

					<P>Because we have decoupled the model from the view, we simplify the programming a great deal. You don't have to think about programming a tree widget anymore. Instead, you just provide a data source.</p>

					<P>Suppose the vice president comes up to you and wants a quick application that lets her navigate the company's organizational chart, which is held in a legacy database on the mainframe. Just write a wrapper that takes the mainframe data, presents it as a <tt cLASS="monofont">TreeModel,</Tt> and <i>voilà:</i> you have a fully navigable tree widget.</p>

					<P>Now you can get fancy and start using the viewer classes; you can change how nodes are rendered, and use special icons, fonts, or colors. When the VP comes back and says the new corporate standards dictate the use of a Skull and Crossbones icon for certain employees, you can make the changes to <TT Class="monofont">TreeCellRenderer</TT> without touching any other code.</P>

				
			
			<H4>Beyond GUIs</h4>
				<p>While MVC is typically taught in the context of GUI development, it is really a general-purpose programming technique. The view is an interpretation of the model (perhaps a subset)—it doesn't need to be graphical. The controller is more of a coordination mechanism, and doesn't have to be related to any sort of input device.</p>

				<uL>
<LI><P><b>Model.  </b>

							The abstract data model representing the target object. The model has no direct knowledge of any views or controllers.</p>
</li>
<li><p><b>View.  </b>

							A way to interpret the model. It subscribes to changes in the model and logical events from the controller.</p>
</li>
<li><p><b>Controller.  </b>

							A way to control the view and provide the model with new data. It publishes events to both the model and the view.</p>

					</lI>
</UL>
				<P>Let's look at a nongraphical example.</p>

				<p>Baseball is a unique institution. Where else can you learn such gems of trivia as "this has become the highest-scoring game played on a Tuesday, in the rain, under artificial lights, between teams whose names start with a vowel?" Suppose we were charged with developing software to support those intrepid announcers who must dutifully report on the scores, the statistics, and the trivia.</p>

				<p>Clearly we need information on the game in progress—the teams playing, the conditions, the player at bat, the score, and so on. These facts form our models; they will be updated as new information arrives (a pitcher is changed, a player strikes out, it starts raining…).</p>

				<P>We'll then have a number of view objects that use these models. One view might look for runs so it can update the current score. Another may receive notifications of new batters, and retrieve a brief summary of their year-to-date statistics. A third viewer may look at the data and check for new world records. We might even have a trivia viewer, responsible for coming up with those weird and useless facts that thrill the viewing public.</p>

				<P>But we don't want to flood the poor announcer with all of these views directly. Instead, we'll have each view generate notifications of "interesting" events, and let some higher-level object schedule what gets shown.<fonT SIZE="1"><sup><a HREF="#FOOTNOTE-9">[9]</a></sup></FONT>
</p>
<bloCKQUote><font size="1">
<p class="footnote">
<sup><A NAMe="FOOTNOTE-9">[9]</a></sup>
The fact that a plane flies overhead probably isn't interesting unless it's the 100th plane to fly overhead that night.</P>
</fOnt></bLOCKQuote>

					
				<P>These viewer objects have suddenly become models for the higher-level object, which itself might then be a model for different formatting viewers. One formatting viewer might create the teleprompter script for the announcer, another might generate video captions directly on the satellite uplink, another might update the network's or team's Web pages (see <A href="020161622x_snode58.html#9">Figure 5.5</a>).</p>

				<CENTer>
					<h5>
<a NAME="9"></a>Figure 5.5. Baseball reporting, Viewers subscribe to models.</h5><img border="0" width="461" heigHT="299" src="FILES/05fig05.gif" alt="graphics/05fig05.gif"></cEnTer>

				<p>This kind of model-viewer network is a common (and valuable) design technique. Each link decouples raw data from the events that created it—each new viewer is an abstraction. And because the relationships are a network (not just a linear chain), we have a lot of flexibility. Each model may have <I>many</I> viewers, and one viewer may work with multiple models.</P>

				<P>In advanced systems such as this one, it can be handy to have <I>debugging views—</i>specialized views that show you in-depth details of the model. Adding a facility to trace individual events can be a great time saver as well.</p>

			
			<h4>Still Coupled (After All These Years)</h4>
				<P>Despite the decrease in coupling we have achieved, listeners and event generators (subscribers and publishers) still have <I>some</I> knowledge of each other. In Java, for instance, they must agree on common interface definitions and calling conventions.</P>

				<p>In the next section, we'll look at ways of reducing coupling even further by using a form of publish and subscribe where <i>none</i> of the participants need know about each other, or call each other directly.</p>

				<H5>Related sections include:</H5>
					<UL>
<li><p><a href="020161622x_snode23.html">Orthogonality</a></p>
</li>
<li><p><a href="020161622x_snode24.html">Reversibility</a></p>
</li>
<li><p><a href="020161622x_snode55.html">Decoupling and the Law of Demeter</a></p>
</li>
<lI><p><A href="020161622x_snode59.html">Blackboards</A></P>
</LI>
<li><p><a href="020161622x_snode79.html">It's All Writing</a></p>

						</li>
</UL>
				
			
			<H4>Exercises</H4>
				<p><tabLE BOder="0" cellspacing="16" cellpaDDINg="0">
					<tr vaLiGn="top"><td ALIGN="right"><a namE="13"></A><FOnt siZE="-1"><B>29.</B></font></TD><TD><font size="-1"><p> <a href="020161622x_cnode88.html#29">Suppose you have an airline reservation system that includes the concept of a flight</a>:</p>

							<pre>
								
     <b>public interface</B> Flight {
       // <I>Return false if flight full.</I>
 <B>      public boolean</b> addPassenger(Passenger p);
 <b>      public void</b> addToWaitList(Passenger p);
 <b>      public int</b> getFlightCapacity();
 <B>      public int</b> getNumPassengers();
     }
</Pre>

							<p>If you add a passenger to the wait list, they'll be put on the flight automatically when an opening becomes available.</P>

							<P>There's a massive reporting job that goes through looking for overbooked or full flights to suggest when additional flights might be scheduled. It works fine, but it takes hours to run.</P>

							<P>We'd like to have a little more flexibility in processing wait-list passengers, and we've got to do something about that big report—it takes too long to run. Use the ideas from this section to redesign this interface.</P>
</font></TD></TR>
				</tablE></P>
			
		</FOnt>
 
<table width="100%" border="0" cellspacing="0" cellpadding="0" bgcolor="#CCCCCC">
<td><font color="black" size=1>I l<font color="#FF0000">@</font>ve RuBoard</td>
<td valign="top" class="v2" align="right"><a href="020161622x_snode57.html"><img src="FILES/previous.gif" width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a> <a href="020161622x_snode59.html"><img src="FILES/next.gif" width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a></td></table>
</BODY></HTML>