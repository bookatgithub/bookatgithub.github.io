<HTML><HEAD><META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=iso-8859-1">
<!--SafClassName="docSection1Title"--><!--SafTocEntry="Refactoring"-->
<LINK REL="stylesheet" href="FILES/proquestM.css">
</HEAD>
<BODY link="#354278" vlink="#000066" alink="#000080" topmargin="0">
<table width="100%" border="0" cellspacing="0" cellpadding="0" bgcolor="#CCCCCC">
<td><font color="black" size=1>I l<font color="#FF0000">@</font>ve RuBoard</td>
<td valign="top" class="v2" align="right"><a href="020161622x_snode63.html"><img src="FILES/previous.gif" width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a> <a href="020161622x_snode65.html"><img src="FILES/next.gif" width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a></td></table>
<FONT size="-1"><H3>Refactoring</H3>
			<P><I>Change and decay in all around I see …</i></p>

			<p><b><I></I> H. F. Lyte, "Abide With Me"</B></P>

			<p>As a program evolves, it will become necessary to rethink earlier decisions and rework portions of the code. This process is perfectly natural. Code needs to evolve; it's not a static thing.</p>

			<p>Unfortunately, the most common metaphor for software development is building construction (Bertrand Meyer [<a href="020161622x_snode87.html#33">Mey97b</a>] uses the term "Software Construction"). But using construction as the guiding metaphor implies these steps:</p>

			<p>
				<p>
				<p>
			<ol>
<li value="1">

					<p>An architect draws up blueprints.</p>

				</li><li VALUe="2">

					<p>Contractors dig the foundation, build the superstructure, wire and plumb, and apply finishing touches.</p>

				</li><Li ValuE="3">

					<P>The tenants move in and live happily ever after, calling building maintenance to fix any problems.</P>

				</LI></ol>

			<p>Well, software doesn't quite work that way. Rather than construction, software is more like <i>gardening—</I>it is more organic than concrete. You plant many things in a garden according to an initial plan and conditions. Some thrive, others are destined to end up as compost. You may move plantings relative to each other to take advantage of the interplay of light and shadow, wind and rain. Overgrown plants get split or pruned, and colors that clash may get moved to more aesthetically pleasing locations. You pull weeds, and you fertilize plantings that are in need of some extra help. You constantly monitor the health of the garden, and make adjustments (to the soil, the plants, the layout) as needed.</P>

			<P>Business people are comfortable with the metaphor of building construction: it is more scientific than gardening, it's repeatable, there's a rigid reporting hierarchy for management, and so on. But we're not building skyscrapers—we aren't as constrained by the boundaries of physics and the real world.</P>

			<p>The gardening metaphor is much closer to the realities of software development. Perhaps a certain routine has grown too large, or is trying to accomplish too much—it needs to be split into two. Things that don't work out as planned need to be weeded or pruned.</p>

			<p>Rewriting, reworking, and re-architecting code is collectively known as <i>refactoring.</I></P>

			<H4>When Should You Refactor?</H4>
				<p>When you come across a stumbling block because the code doesn't quite fit anymore, or you notice two things that should really be merged, or anything else at all strikes you as being "wrong,"
					<i>don't hesitate to change it</i> There's no time like the present. Any number of things may cause code to qualify for refactoring:</p>

				<UL>
<LI><p><b>Duplication.  </b>

							You've discovered a violation of the <i>DRY</i> principle (<a href="020161622x_snode22.html">The Evils of Duplication</a>).</p>
</li>
<li><p><b>Nonorthogonal design.  </b>

							You've discovered some code or design that could be made more orthogonal (<a href="020161622x_snode23.html">Orthogonality</a>).</p>
</li>
<lI><p><B>Outdated knowledge.  </b>

							Things change, requirements drift, and your knowledge of the problem increases. Code needs to keep up.</p>
</lI>
<LI><P><B>Performance.  </b>

							You need to move functionality from one area of the system to another to improve performance.</p>

					</li>
</UL>
				<P>Refactoring your code—moving functionality around and updating earlier decisions—is really an exercise in <I>pain management.</i> Let's face it, changing source code around can be pretty painful: it was almost working, and now it's <i>really</i> torn up. Many developers are reluctant to start ripping up code just because it isn't quite right.</p>

				<H5>Real-World Complications</H5>
					<P>So you go to your boss or client and say, "This code works, but I need another week to refactor it."</P>

					<p>We can't print their reply.</p>

					<p>Time pressure is often used as an excuse for not refactoring. But this excuse just doesn't hold up: fail to refactor now, and there'll be a far greater time investment to fix the problem down the road—when there are more dependencies to reckon with. Will there be more time available then? Not in our experience.</p>

					<P>You might want to explain this principle to the boss by using a medical analogy: think of the code that needs refactoring as a "growth." Removing it requires invasive surgery. You can go in now, and take it out while it is still small. Or, you could wait while it grows and spreads—but removing it then will be both more expensive and more dangerous. Wait even longer, and you may lose the patient entirely.</P>

					<DIv class="note"><p class="notetitle"><b>Tip 47</b></p><p>

						<p>Refactor Early, Refactor Often</p>

					</p></dIV>
<BR>
<br>

					<p>Keep track of the things that need to be refactored. If you can't refactor something immediately, make sure that it gets placed on the schedule. Make sure that users of the affected code <i>know</i> that it is scheduled to be refactored and how this might affect them.</P>

				
			
			<h4>How Do You Refactor?</H4>
				<p>Refactoring started out in the Smalltalk community, and, along with other trends (such as design patterns), has started to gain a wider audience. But as a topic it is still fairly new; there isn't much published on it. The first major book on refactoring ([<a href="020161622x_snode87.html#12">FBB<SUp>+</sup>99</A>], and also [<A href="020161622x_snode86.html#55">URL 47</a>]) is being published around the same time as this book.</p>

				<P>At its heart, refactoring is redesign. Anything that you or others on your team designed can be redesigned in light of new facts, deeper understandings, changing requirements, and so on. But if you proceed to rip up vast quantities of code with wild abandon, you may find yourself in a worse position than when you started.</P>

				<P>Clearly, refactoring is an activity that needs to be undertaken slowly, deliberately, and carefully. Martin Fowler offers the following simple tips on how to refactor without doing more harm than good (see the box on in [<A href="020161622x_snode87.html#14">FS97</A>]):</P>

				<OL type="1">
<li>
<p>Don't try to refactor and add functionality at the same time.</p>
</li>
<li>
<p>Make sure you have good tests before you begin refactoring. Run the tests as often as possible. That way you will know quickly if your changes have broken anything.</p>

						<p><table CELLspaciNg="0" WidtH="90%" BORDer="1"><tr><TD><CEnter><H2>
Automatic Refactoring</H2></CEnter>
							<P>Historically, Smalltalk users have always enjoyed a <I>class browser</I> as part of the IDE. Not to be confused with Web browsers, class browsers let users navigate through and examine class hierarchies and methods.</P>

							<p>Typically, class browsers allow you to edit code, create new methods and classes, and so on. The next variation on this idea is the <i>refactoring browser.</i></p>

							<p>A refactoring browser can semiautomatically perform common refactoring operations for you: splitting up a long routine into smaller ones, automatically propagating changes to method and variable names, drag and drop to assist you in moving code, and so on.</p>

							<p>As we write this book, this technology has yet to appear outside of the Smalltalk world, but this is likely to change at the same speed that Java changes—rapidly. In the meantime, the pioneering Small-talk refactoring browser can be found online at [<a href="020161622x_snode86.html#24">URL 20</a>].</p>

						</td></tr></taBLE></P>

					</li>
<li>
<p>Take short, deliberate steps: move a field from one class to another, fuse two similar methods into a superclass. Refactoring often involves making many localized changes that result in a larger-scale change. If you keep your steps small, and test after each step, you will avoid prolonged debugging.</P>

					</lI>
</ol>

				<p>We'll talk more about testing at this level in <A href="020161622x_snode65.html">Code That's Easy to Test</a>, and larger-scale testing in <a href="020161622x_snode78.html">Ruthless Testing</A>, but Mr. Fowler's point of maintaining good regression tests is the key to refactoring with confidence.</P>

				<p>It can also be helpful to make sure that drastic changes to a module—such as altering its interface or its functionality in an incompatible manner—break the build. That is, old clients of this code should fall to compile. You can then quickly find the old clients and make the necessary changes to bring them up to date.</p>

				<p>So next time you see a piece of code that isn't quite as it should be, fix both it and everything that depends on it. Manage the pain: if it hurts now, but is going to hurt even more later, you might as well get it over with. Remember the lessons of <a href="020161622x_snode14.html">Software Entropy</a>, don't live with broken windows.</p>

				<h5>Related sections include:</h5>
					<UL>
<LI><p><a href="020161622x_snode13.html">The Cat Ate My Source Code</a></p>
</li>
<li><p><a href="020161622x_snode14.html">Software Entropy</a></p>
</LI>
<LI><p><a href="020161622x_snode15.html">Stone Soup and Boiled Frogs</a></P>
</li>
<lI><P><A href="020161622x_snode22.html">The Evils of Duplication</a></p>
</LI>
<LI><p><a href="020161622x_snode23.html">Orthogonality</A></P>
</li>
<li><P><A href="020161622x_snode15.html">Programming by Coincidence</a></p>
</li>
<li><p><a href="020161622x_snode15.html">Code That's Easy to Test</a></p>
</li>
<li><P><A href="020161622x_snode15.html">Ruthless Testing</a></p>

						</lI>
</uL>
				
			
			<h4>Exercises</h4>
				<p><TABLE bodeR="0" CELlspaCING="16" cellPADDing="0">
					<tr valign="top"><td align="right"><a nAME="6"></A><font sIzE="-1"><b>38.</b></fONT></TD><td><foNT SIze="-1"><p> <a href="020161622x_cnode88.html#38">The following code has obviously been updated several times over the years, but the changes haven't improved its structure. Refactor it</a>.</p>

							<prE>
								
    <B>if</B> (state == TEXAS) {
      rate = TX_RATE;
      amt  = base * TX_RATE;
      calc = 2*basis(amt) + extra(amt)*1.05;
    }
 <B>   else if</b> ((state == OHIO) || (state == MAINE;
      rate = (state == OHIO) ? OH_RATE : MN_RATE]
      amt  = base * rate;
      calc = 2*basis(amt) + extra(amt)*1.05;
      <b>if</b> (state == OHIO)
        points = 2;
    }
    <b>else</b> {
      rate = 1;
      amt  = base;
      calc = 2*basis(amt) + extra(amt)*1.05;
    }
</pre>

						</font></td></tr>
					<tr vaLIGN="top"><td aliGn="right"><A namE="7"></A><FONt sizE="-1"><B>39.</B></Font></tD><TD><Font sIZE="-1"><P> <a href="020161622x_cnode88.html#39">The following Java class needs to support a few more shapes. Refactor the class to prepare it for the additions</a>.</p>

							<pre>
								
<b>   public class</b> Shape {

<b>     public static final int</b> SQUARE   = 1;
<b>     public static final int</b> CIRCLE   = 2;
<b>     public static final int</b> RIGHT_TRIANGLE = 3;

<b>     private int</b> shapeType;
<B>     private double</B> size;

<B>     public</B> Shape(<b>int</b> shapeType, <b>double</b> size) {
       <b>this.</B>shapeType = shapeType;
       <b>this.</B>size = size;
     }
     // ... <i>other methods ...</i>
<b>     public double</B> area(){
<B>       switch</B> (shapeType) {
<B>       case</B> SQUARE:   <b>return</b> size*size;
<b>       case</b> CIRCLE:   <B>return</B> Math.PI*size*size/4.0;
<B>       case</B> RIGHT_TRIANGLE: <b>return</b> size*size/2.0;
       }
<b>       return 0;</b>
      }
    }
</PRE>

						</Font></tD></TR>
					<Tr valign="top"><td align="right"><a name="8"></a><FONT size="-1"><b>40.</B></fOnt></tD><TD><FOnt siZE="-1"><P> <A href="020161622x_cnode88.html#40">This Java code is part of a framework that will be used throughout your project. Refactor it to be more general and easier to extend in the future</A>.</P>

							<PRe>
								
    <b>public class</b> Window {
 <b>     public</B> Window(<I>int</I> width, int height) { ... }
 <B>     public void</b> setSize(<i>int</i> width, <i>int</i> height) { ... }
 <b>     public boolean</b> overlaps(Window w) { ... }
 <b>     public int</b> getArea() { ... }
 <b>   }</b>
								</pre>

						</font></td></TR>
				</TAble></p>
			
		</fOnT>
 
<table width="100%" border="0" cellspacing="0" cellpadding="0" bgcolor="#CCCCCC">
<td><font color="black" size=1>I l<font color="#FF0000">@</font>ve RuBoard</td>
<td valign="top" class="v2" align="right"><a href="020161622x_snode63.html"><img src="FILES/previous.gif" width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a> <a href="020161622x_snode65.html"><img src="FILES/next.gif" width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a></td></table>
</BODY></HTML>