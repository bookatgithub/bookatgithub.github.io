<HTML><HEAD><META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=iso-8859-1">
<!--SafClassName="docSection1Title"--><!--SafTocEntry="The Requirements Pit"-->
<LINK REL="stylesheet" href="FILES/proquestM.css">
</HEAD>
<BODY link="#354278" vlink="#000066" alink="#000080" topmargin="0">
<table width="100%" border="0" cellspacing="0" cellpadding="0" bgcolor="#CCCCCC">
<td><font color="black" size=1>I l<font color="#FF0000">@</font>ve RuBoard</td>
<td valign="top" class="v2" align="right"><a href="020161622x_cnode67.html"><img src="FILES/previous.gif" width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a> <a href="020161622x_snode70.html"><img src="FILES/next.gif" width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a></td></table>
<FONT size="-1"><H3>The Requirements Pit</H3>
			<P><I>Perfection is achieved, not when there is nothing left to add, but when there is nothing left to take away….</i></p>

			<p><b>Antoine de St. Exupery, <I>Wind, Sand, and Stars,</I> 1939</B></P>

			<p>Many books and tutorials refer to <i>requirements gathering</i> as an early phase of the project. The word "gathering" seems to imply a tribe of happy analysts, foraging for nuggets of wisdom that are lying on the ground all around them while the Pastoral Symphony plays gently in the background. "Gathering" implies that the requirements are already there—you need merely find them, place them in your basket, and be merrily on your way.</p>

			<P>It doesn't quite work that way. Requirements rarely lie on the surface. Normally, they're buried deep beneath layers of assumptions, misconceptions, and politics.</P>

			<DIv class="note"><p class="notetitle"><b>Tip 51</b></p><p>

				<p>Don't Gather Requirements—Dig for Them</p>

			</p></dIV>
<BR>
<br>

			<h4>Digging for Requirements</h4>
				<p>How can you recognize a true requirement while you're digging through all the surrounding dirt? The answer is both simple and complex.</P>

				<p>The simple answer is that a requirement is a statement of something that needs to be accomplished. Good requirements might include the following:</P>

				<ul>
<lI><P>An employee record may be viewed only by a nominated group of people.</P>
</LI>
<li><p>The cylinder-head temperature must not exceed the critical value, which varies by engine.</p>
</LI>
<LI><p>The editor will highlight keywords, which will be selected depending on the type of file being edited.</p>

					</li>
</UL>
				<P>However, very few requirements are as clear-cut, and that's what makes requirements analysis complex.</P>

				<p>The first statement in the list above may have been stated by the users as "Only an employee's supervisors and the personnel department may view that employee's records." Is this statement truly a requirement? Perhaps today, but it embeds business policy in an absolute statement. Policies change regularly, so we probably don't want to hardwire them into our requirements. Our recommendation is to document these policies separately from the requirement, and hyperlink the two. Make the requirement the general statement, and give the developers the policy information as an example of the type of thing they'll need to support in the implementation. Eventually, policy may end up as metadata in the application.</p>

				<p>This is a relatively subtle distinction, but it's one that will have profound implications for the developers. If the requirement is stated as "Only personnel can view an employee record," the developer may end up coding an explicit test every time the application accesses these files. However, if the statement is "Only authorized users may access an employee record," the developer will probably design and implement some kind of access control system. When policy changes (and it will), only the metadata for that system will need to be updated. In fact, gathering requirements in this way naturally leads you to a system that is well factored to support metadata.</p>

				<P>The distinctions among requirements, policy, and implementation can get very blurred when user interfaces are discussed. "The system must let you choose a loan term" is a statement of requirement. "We need a list box to select the loan term" may or may not be. If the users absolutely must have a list box, then it is a requirement. If instead they are describing the ability to choose, but are using <I>listbox</I> as an example, then it may not be. The box on page 205 discusses a project that went horribly wrong because the users' interface needs were ignored.</P>

				<p>It's important to discover the underlying reason <i>why</i> users do a particular thing, rather than just <i>the way</i> they currently do it. At the end of the day, your development has to solve their <i>business problem,</i> not just meet their stated requirements. Documenting the reasons behind requirements will give your team invaluable information when making daily implementation decisions.</p>

				<p>There's a simple technique for getting inside your users' requirements that isn't used often enough: become a user. Are you writing a system for the help desk? Spend a couple of days monitoring the phones with an experienced support person. Are you automating a manual stock control system? Work in the warehouse for a week.<font size="1"><sup><A HREf="#FOOTNOTE-1">[1]</a></sup></FoNt>
 As well as giving you insight into how the system will <i>really</i> be used, you'd be amazed at how the request "May I sit in for a week while you do your job?" helps build trust and establishes a basis for communication with your users. Just remember not to get in the way!</P>
<BLOCkquoTE><FOnt siZE="1">
<P Class="footnote">
<SUP><A name="FOOTNOTE-1">[1]</a></sup>
Does a week sound like a long time? It really isn't, particularly when you're looking at processes in which management and workers occupy different worlds. Management will give you one view of how things operate, but when you get down on the floor, you'll find a very different reality—one that will take time to assimilate.</p>
</font></blockquOTE>

					
				<Div claSs="note"><P claSS="notetitle"><B>Tip 52</B></P><p>

					<p>Work with a User to Think Like a User</p>

				</p></DIV>
<Br>
<br>

				<p>The requirements mining process is also the time to start to build a rapport with your user base, learning their expectations and hopes for the system you are building. See <A href="020161622x_snode80.html">Great Expectations</a>, for more.</p>

			
			<h4>Documenting Requirements</H4>
				<P>So you are sitting down with the users and prying genuine requirements from them. You come across a few likely scenarios that describe what the application needs to do. Ever the professional, you want to write these down and publish a document that everyone can use as a basis for discussions—the developers, the end users, and the project sponsors.</P>

				<P>That's a pretty wide audience.</p>

				<p>Ivar Jacobson [<a href="020161622x_snode87.html#19">Jac94</a>] proposed the concept of <i>use cases</i> to capture requirements. They let you describe a particular <i>use</i> of the system— not in terms of user interface, but in a more abstract fashion. Unfortunately, Jacobson's book was a little vague on details, so there are now many different opinions on what a use case should be. Is it formal or informal, simple prose or a structured document (like a form)? What level of detail is appropriate (remember we have a wide audience)?</p>

				<p><table cELLSpacinG="0" wIdth="90%" BORDEr="1"><tr><tD><CENter><h2>
Sometimes the Interface Is the System</H2></CENter>
					<p>In an article in <I>Wired</I> magazine (January 1999, page 176), producer and musician Brian Eno described an incredible piece of technology—the ultimate mixing board. It does anything to sound that can be done. And yet, instead of letting musicians make better music, or produce a recording faster or less expensively, it gets in the way; it disrupts the creative process.</P>

					<P>To see why, you have to look at how recording engineers work. They balance sounds intuitively. Over the years, they develop an innate feedback loop between their fingertips—sliding faders, rotating knobs, and so on However, the interface to the new mixer didn't leverage off those abilities. Instead, it forced its users to type on a keyboard or click a mouse. The functions it provided were comprehensive, but they were packaged in unfamiliar and exotic ways. The functions the engineers needed were sometimes hidden behind obscure names, or were achieved with nonintuitive combinations of basic facilities.</p>

					<p>That environment has a requirement to leverage existing skill sets. While slavishly duplicating what already exists doesn't allow for progress, we must be able to provide a <i>transition</i> to the future.</p>

					<p>For example, the recording engineers may have been better served by some sort of touchscreen interface—still tactile, still mounted as a traditional mixing board might be, yet allowing the software to go beyond the realm of fixed knobs and switches. Providing a comfortable transition through familiar metaphors is one way to help get buy-in.</p>

					<p>This example also illustrates our belief that successful tools adapt to the hands that use them. In this case, it is the tools that you build for others that must be adaptable.</p>

				</td></tr></table></p>

				<p>One way of looking at use cases is to emphasize their goal-driven nature. Alistair Cockburn has a paper that describes this approach, as well as templates that can be used (strictly or not) as a starting place ([<A href="020161622x_snode87.html#8">Coc97a</a>], also online at [<a href="020161622x_snode86.html#54">URL 46</A>]). <a href="020161622x_snode69.html#4">Figure 7.1</A> on the following page shows an abbreviated example of his template, while <A href="020161622x_snode69.html#5">Figure 7.2</a> shows his sample use case.</P>

				<CENter>
					<h5>
<A NAMe="4"></a>Figure 7.1. Cockburn's use case template</h5><iMG BOrder="0" width="271" height="398" src="FILES/07fig01.gif" alT="graphics/07fig01.gif"></CENter>

				<ceNtEr>
					<h5>
<a NAME="5"></A>Figure 7.2. A sample use case</h5><img BORDer="0" wiDTH="463" HeighT="639" src="FILES/07fig02.gif" alt="graphics/07fig02.gif"></center>

				<p>By using a formal template as an <i>aide-mémoire,</i> you can be sure that you include all the information you need in a use case: performance characteristics, other involved parties, priority, frequency, and various errors and exceptions that can crop up ("nonfunctional requirements"). This is also a great place to record user comments such as "oh, except if we get a <i>xxx</i> condition, then we have to do <i>yyy</i> instead." The template also serves as a ready-made agenda for meetings with your users.</p>

				<p>This sort of organization supports the hierarchical structuring of use cases—nesting more detailed use cases inside higher-level ones. For example, <i>post debit</i> and <I>post credit</I> both elaborate on <I>post transaction.</I></p>

				<h5>Use Case Diagrams</h5>
					<p>Workflow can be captured with UML activity diagrams, and conceptual-level class diagrams can sometimes be useful for modeling the business at hand. But true use cases are textual descriptions, with a hierarchy and cross-links. Use cases can contain hyperlinks to other use cases, and they can be nested within each other.</p>

					<P>It seems incredible to us that anyone would seriously consider documenting information this dense using only simplistic stick people such as <a href="020161622x_snode69.html#7">Figure 7.3</A>. Don't be a slave to any notation; use whatever method best communicates the requirements with your audience.</P>

					<CENter>
						<h5>
<A NAMe="7"></a>Figure 7.3. UML use cases—so simple a child could do it!</h5><iMG BOrder="0" WIDTh="309" height="85" src="FILES/07fig03.gif" alt="graphics/07fig03.gif"></center>

				
			
			<h4>Overspecifying</H4>
				<P>A big danger in producing a requirements document is being too specific. Good requirements documents remain abstract. Where requirements are concerned, the simplest statement that accurately reflects the business need is best. This doesn't mean you can be vague—you must capture the underlying semantic invariants as requirements, and document the specific or current work practices as policy.</P>

				<P>Requirements are not architecture. Requirements are not design, nor are they the user interface. Requirements are <i>need.</i></p>

			
			<h4>Seeing Further</h4>
				<P>The Year 2000 problem is often blamed on short-sighted programmers, desperate to save a few bytes in the days when mainframes had less memory than a modern TV remote control.</p>

				<P>But it wasn't the programmers' doing, and it wasn't really a memory usage issue. If anything, it was the system analysts' and designers' fault. The Y2K problem came about from two main causes: a failure to see beyond current business practice, and a violation of the <i>DRY</i> principle.</p>

				<P>Businesses were using the two-digit shortcut long before computers came on the scene. It was common practice. The earliest data processing applications merely automated existing business processes, and simply repeated the mistake. Even if the architecture required two-digit years for data input, reporting, and storage, there should have been an abstraction of a <TT CLass="monofont">DATE</tT> that "knew" the two digits were an abbreviated form of the real date.</P>

				<DIv claSS="note"><P Class="notetitle"><B>Tip 53</B></P><P>

					<p>Abstractions Live Longer than Details</p>

				</p></div>
<br>
<br>

				<p>Does "seeing further" require you to predict the future? No. It means generating statements such as</p>

				<blockquoTE>
<P><P><i>The system makes active use of an abstraction of DATEs. The system will implement DATE services, such as formatting, storage, and math operations, consistently and universally.</i></p>
</p>
</bLoCkquOTE>
				<P>The requirements will specify only that dates are used. It may hint that some math may be done on dates. It may tell you that dates will be stored on various forms of secondary storage. These are genuine requirements for a <Tt claSS="monofont">DATE</TT> module or class.</p>

			
			<h4>Just One More Wafer-Thin Mint…</h4>
				<p>Many projects failures are blamed on an increase in scope—also known as feature bloat, creeping featurism, or requirements creep. This is an aspect of the boiled-frog syndrome from <A href="020161622x_snode15.html">Stone Soup and Boiled Frogs</a>. What can we do to prevent requirements from creeping up on us?</p>

				<p>In the literature, you will find descriptions of many metrics, such as bugs reported and fixed, defect density, cohesion, coupling, function points, lines of code, and so on. These metrics may be tracked by hand or with software.</P>

				<P>Unfortunately, not many projects seem to track requirements actively. This means that they have no way to report on changes of scope—who requested a feature, who approved it, total number of requests approved, and so on.</P>

				<P>The key to managing growth of requirements is to point out each new feature's impact on the schedule to the project sponsors. When the project is a year late from initial estimates and accusations start flying, it can be helpful to have an accurate, complete picture of how, and when, requirements growth occurred.</p>

				<p>It's easy to get sucked into the "just one more feature" maelstrom, but by tracking requirements you can get a clearer picture that "just one more feature" is really the fifteenth new feature added this month.</p>

			
			<h4>Maintain a Glossary</h4>
				<p>As soon as you start discussing requirements, users and domain experts will use certain terms that have specific meaning to them. They may differentiate between a "client" and a "customer," for example. It would then be inappropriate to use either word casually in the system.</p>

				<p>Create and maintain a <i>project glossary</i>—one place that defines all the specific terms and vocabulary used in a project. All participants in the project, from end users to support staff, should use the glossary to ensure consistency. This implies that the glossary needs to be widely accessible—a good argument for Web-based documentation (more on that in a moment).</p>

				<div class="note"><p CLASs="notetitle"><b>Tip 54</b></p><p>

					<P>Use a Project Glossary</p>

				</P></div>
<BR>
<BR>

				<P>It's very hard to succeed on a project where the users and developers refer to the same thing by different names or, even worse, refer to different things by the same name.</p>

			
			<h4>Get the Word Out</h4>
				<p>In <A href="020161622x_snode79.html">It's All Writing</a>, we discuss publishing of project documents to internal Web sites for easy access by all participants. This method of distribution is particularly useful for requirements documents.</p>

				<p>By presenting requirements as a hypertext document, we can better address the needs of a diverse audience—we can give each reader what they want. Project sponsors can cruise along at a high level of abstraction to ensure that business objectives are met. Programmers can use hyperlinks to "drill down" to increasing levels of detail (even referencing appropriate definitions or engineering specifications).</P>

				<P>Web-based distribution also avoids the typical two-inch-thick binder entitled <I>Requirements Analysis</I> that no one ever reads and that becomes outdated the instant ink hits paper.</p>

				<p>If it's on the Web, the programmers may even read it.</p>

				<h5>Related sections include:</H5>
					<UL>
<Li><p><a href="020161622x_snode15.html">Stone Soup and Boiled Frogs</a></p>
</li>
<li><p><a href="020161622x_snode16.html">Good-Enough Software</a></P>
</LI>
<Li><p><a href="020161622x_snode73.html">Circles and Arrows</A></p>
</li>
<LI><P><A href="020161622x_snode79.html">It's All Writing</a></P>
</LI>
<Li><p><a href="020161622x_snode80.html">Great Expectations</A></p>

						</li>
</uL>
				
				<H5>Challenges</H5>
					<Ul>
<li><p>Can you use the software you are writing? Is it possible to have a good feel for requirements <i>without</i> being able to use the software yourself?</p>
</li>
<li><p>Pick a non-computer-related problem you currently need to solve. Generate requirements for a noncomputer solution.</p>

						</li>
</ul>
				
			
			<h4>Exercises</h4>
				<p><TABLe bodeR="0" cEllsPACINg="16" celLPADding="0">
					<TR VAlign="top"><TD ALign="right"><font size="-1"><b>42.</b></font></td><tD><FONt size="-1"><P> <a href="020161622x_cnode88.html#42">Which of the following are probably genuine requirements? Restate those that are not to make them more useful (if possible)</A>.</P>

							<OL Type="1">
<lI>
<P>The response time must be less than 500 ms.</P>
</Li>
<li>
<p>Dialog boxes will have a gray background.</P>
</LI>
<Li>
<p>The application will be organized as a number of front-end processes and a back-end server.</p>
</lI>
<LI>
<P>If a user enters non-numeric characters in a numeric field, the system will beep and not accept them.</p>
</li>
<li>
<p>The application code and data must fit within 256kB.</p>

								</li>
</ol>

						</font></td></tr>
				</tABLE></p>
			
		</font>
 
<table width="100%" border="0" cellspacing="0" cellpadding="0" bgcolor="#CCCCCC">
<td><font color="black" size=1>I l<font color="#FF0000">@</font>ve RuBoard</td>
<td valign="top" class="v2" align="right"><a href="020161622x_cnode67.html"><img src="FILES/previous.gif" width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a> <a href="020161622x_snode70.html"><img src="FILES/next.gif" width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a></td></table>
</BODY></HTML>