<html>
<META http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<head>
<title>Section A.2.&nbsp; Header &lt;unordered_set&gt; Synopsis</title>
<link rel="STYLESHEET" type="text/css" href="images/style.css">
<link rel="STYLESHEET" type="text/css" href="images/docsafari.css">
</head>
<body>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<tr><td><div STYLE="MARGIN-LEFT: 0.15in;">
<a href=app01lev1sec1.html><img src="images/prev.gif" width="60" height="17" border="0" align="absmiddle" alt="Previous Page"></a>
<td align="right"><div STYLE="MARGIN-LEFT: 0.15in;">
<a href=app01lev1sec3.html><img src="images/next.gif" width="60" height="17" border="0" align="absmiddle" alt="Next Page"></a>
</div></td></tr></table>
<br><table width="100%" border="0" cellspacing="0" cellpadding="0"><tr><td valign="top"><a name="app01lev1sec2"></a>
<h3 id="680422-932" class="docSection1Title">A.2. <a name="iddle1861"></a><a name="iddle1862"></a><a name="iddle1863"></a>Header <tt>&lt;unordered_set&gt;</tt> Synopsis</h3>
<div class="docText"><pre>namespace std {     <span class="docEmphasis">// C++ standard library</span>
 namespace tr1 {    <span class="docEmphasis">// TR1 additions</span>

    <span class="docEmphasis">// CLASS TEMPLATE unordered_set</span>
template &lt; class Key,
  class Hash = hash &lt;Key&gt;,
  class Pred = equal_to &lt;Key &gt;,
  class Alloc = allocator &lt;Key &gt;&gt;
    class <span class="docEmphasis">unordered_set</span> ;

    <span class="docEmphasis">// CLASS TEMPLATE unordered_multiset</span>
template &lt;class Key,
  class Hash = hash &lt;Key &gt;,
  class Pred = equal_to &lt;Key &gt;,
  class Alloc = allocator &lt;Key &gt;&gt;
    class <span class="docEmphasis">unordered_multiset</span> ;

    <span class="docEmphasis">// FUNCTION TEMPLATES swap</span>
template &lt;class Key, class Hash, class Pred, class Alloc&gt;
void <span class="docEmphasis">swap</span> (unordered_set (Key, Hash, Pred, Alloc&gt;&amp; left,
    unordered_set (Key, Hash, Pred, Alloc&gt;&amp; right);
template &lt;class Key, class Hash, class Pred, class Alloc&gt;
void <span class="docEmphasis">swap</span> ( unordered_multiset (Key, Hash, Pred, Alloc&gt;&amp; left,
  unordered_multiset (Key, Hash, Pred, Alloc&gt;&amp; right);

    <span class="docEmphasis">// CLASS TEMPLATE unordered_set</span>
template &lt;class Key,
  class Hash = hash &lt;Key &gt;,
  class Pred = equal_to &lt;Key &gt;,
  class Alloc = allocator &lt;Key &gt;&gt;
  class unordered_set {
public :

    <span class="docEmphasis">// NESTED TYPES</span>
  typedef Key <span class="docEmphasis">key_type</span> ;
  typedef Hash <span class="docEmphasis">hasher</span> ;
  typedef Pred <span class="docEmphasis">key_equal</span> ;
  typedef Key <span class="docEmphasis">value_type</span> ;

  typedef Alloc <span class="docEmphasis">allocator_type</span> ;
  typedef Alloc :: pointer <span class="docEmphasis">pointer</span> ;
  typedef Alloc :: const_pointer <span class="docEmphasis">const_pointer</span> ;
  typedef Alloc :: reference <span class="docEmphasis">reference</span> ;
  typedef Alloc :: const_reference <span class="docEmphasis">const_reference</span> ;

  typedef T0 <span class="docEmphasis">iterator</span> ;
  typedef T1 <span class="docEmphasis">const_iterator</span> ;
  typedef T2 <span class="docEmphasis">local_iterator</span> ;
  typedef T3 <span class="docEmphasis">const_local_iterator</span> ;
  typedef T4 <span class="docEmphasis">size_type</span> ;
  typedef T5 <span class="docEmphasis">difference_type</span> ;

    <span class="docEmphasis">// CONSTRUCTING AND ASSIGNING</span>
  explicit <span class="docEmphasis">unordered_set</span> (
    size_type n = n0 , <span class="docEmphasis">// implementation-defined</span>
    const hasher &amp; h = hasher (),
    const key_equal &amp; comp = key_equal (),
    const allocator_type &amp; alloc = allocator_type ());
  template &lt;class InIt&gt;
    <span class="docEmphasis">unordered_set</span> (InIt first, InIt last,
    size_type n = n0 , <span class="docEmphasis">// implementation-defined</span>
    const hasher &amp; h = hasher (),
    const key_equal &amp; comp = key_equal (),
    const allocator_type &amp; alloc = allocator_type ());
  <span class="docEmphasis">unordered_set</span> (const unordered_set &amp; right);
  unordered_set &amp; <span class="docEmphasis">operator=</span> (const unordered_set &amp; right );

    <span class="docEmphasis">// MODIFYING</span>
  pair &lt;iterator, bool&gt; <span class="docEmphasis">insert</span> (const value_type &amp; val);
  iterator <span class="docEmphasis">insert</span> (
    iterator where, const value_type &amp; val);
  const_iterator <span class="docEmphasis">insert</span> (
    const_iterator where, const value_type&amp; val);
  template &lt;class InIt&gt;
    void <span class="docEmphasis">insert</span> (InIt first, InIt last);

  iterator <span class="docEmphasis">erase</span> (iterator where);
  const_iterator <span class="docEmphasis">erase</span> ( const_iterator where);
  size_type <span class="docEmphasis">erase</span> (const Key &amp; key);
  iterator <span class="docEmphasis">erase</span> (
    iterator first, iterator last);
  const_iterator <span class="docEmphasis">erase</span> (
    const_iterator first, const_iterator last);
  void <span class="docEmphasis">clear</span> ();

  void <span class="docEmphasis">swap</span> (unordered_set &amp; right);

    <span class="docEmphasis">// ITERATING</span>
  iterator <span class="docEmphasis">begin</span> ();
  iterator <span class="docEmphasis">end</span> ();
  const_iterator <span class="docEmphasis">begin</span> () const;
  const_iterator <span class="docEmphasis">end</span> () const ;

    <span class="docEmphasis">// SEARCHING</span>
  iterator <span class="docEmphasis">find</span> (const Key &amp; key);
  const_iterator <span class="docEmphasis">find</span> (const Key &amp; key) const;
  size_type <span class="docEmphasis">count</span> (const Key &amp; key) const;
  pair &lt;iterator, iterator&gt;
    <span class="docEmphasis">equal_range</span> (const Key &amp; key);
  pair &lt;const_iterator, const_iterator&gt;
    <span class="docEmphasis">equal_range</span> (const Key &amp; key) const;

    <span class="docEmphasis">// QUERYING</span>
  size_type <span class="docEmphasis">size</span> () const ;
  size_type <span class="docEmphasis">max_size</span> () const;
  bool <span class="docEmphasis">empty</span> () const;

  allocator_type <span class="docEmphasis">get_allocator</span> () const;
  hasher <span class="docEmphasis">hash_function</span> () const ;
  key_equal <span class="docEmphasis">key_eq</span> () const ;

    <span class="docEmphasis">// TUNING</span>
  local_iterator <span class="docEmphasis">begin</span> (size_type n);
  const_local_iterator <span class="docEmphasis">begin</span> (size_type n) const;
  local_iterator <span class="docEmphasis">end</span> (size_type n);
  const_local_iterator <span class="docEmphasis">end</span> (size_type n) const ;

  size_type <span class="docEmphasis">bucket_count</span> () const ;
  size_type <span class="docEmphasis">max_bucket_count</span> () const ;
  size_type <span class="docEmphasis">bucket_size</span> (size_type n) const;
  size_type <span class="docEmphasis">bucket</span> (const key_type &amp; val) const ;

  float <span class="docEmphasis">load_factor</span> () const ;
  float <span class="docEmphasis">max_load_factor</span> () const;
  void <span class="docEmphasis">max_load_factor</span> (float fact);
  void <span class="docEmphasis">rehash</span> (size_type n);
  };

    <span class="docEmphasis">// CLASS TEMPLATE unordered_multiset</span>
template &lt;class Key,
  class Ty,
  class Hash = hash &lt;Key &gt;,
  class Pred = equal_to &lt;Key &gt;,
  class Alloc = allocator &lt;Key &gt;
  class unordered_multiset {
    <span class="docEmphasis">// CONTENTS ARE THE SAME AS unordered_set</span>
  };

} }
</pre></div><br>

</TD></TR></table>
<br>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<tr><td><div STYLE="MARGIN-LEFT: 0.15in;">
<a href=app01lev1sec1.html><img src="images/prev.gif" width="60" height="17" border="0" align="absmiddle" alt="Previous Page"></a>
<td align="right"><div STYLE="MARGIN-LEFT: 0.15in;">
<a href=app01lev1sec3.html><img src="images/next.gif" width="60" height="17" border="0" align="absmiddle" alt="Next Page"></a>
</div></td></tr></table>
</body></html>