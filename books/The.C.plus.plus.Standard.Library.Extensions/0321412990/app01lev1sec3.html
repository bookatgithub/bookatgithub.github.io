<html>
<META http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<head>
<title>Section A.3.&nbsp; Header &lt;unordered_map&gt; Synopsis</title>
<link rel="STYLESHEET" type="text/css" href="images/style.css">
<link rel="STYLESHEET" type="text/css" href="images/docsafari.css">
</head>
<body>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<tr><td><div STYLE="MARGIN-LEFT: 0.15in;">
<a href=app01lev1sec2.html><img src="images/prev.gif" width="60" height="17" border="0" align="absmiddle" alt="Previous Page"></a>
<td align="right"><div STYLE="MARGIN-LEFT: 0.15in;">
<a href=app01lev1sec4.html><img src="images/next.gif" width="60" height="17" border="0" align="absmiddle" alt="Next Page"></a>
</div></td></tr></table>
<br><table width="100%" border="0" cellspacing="0" cellpadding="0"><tr><td valign="top"><a name="app01lev1sec3"></a>

<h3 id="title-IDAURFII" class="docSection1Title">A.3. <a name="iddle1858"></a><a name="iddle1859"></a><a name="iddle1860"></a>Header <tt>&lt;unordered_map&gt;</tt> Synopsis</h3>
<div class="docText"><pre>namespace std {    <span class="docEmphasis">// C++ standard library</span>
 namespace tr1 {   <span class="docEmphasis">// TR1 additions</span>

    <span class="docEmphasis">// CLASS TEMPLATE unordered_map</span>
template &lt;class Key, class Ty,
  class Hash = hash &lt;Key&gt;,
  class Pred = equal_to &lt;Key&gt;,
  class Alloc = allocator &lt;pair &lt;const Key, Ty&gt;&gt;&gt;
    class <span class="docEmphasis">unordered_map</span> ;

    <span class="docEmphasis">// CLASS TEMPLATE unordered_multimap</span>
template &lt;class Key, class Ty,
  class Hash = hash &lt;Key&gt;,
  class Pred = equal_to &lt;Key&gt;,
  class Alloc = allocator &lt;pair &lt;const Key, Ty&gt;&gt;&gt;
  class <span class="docEmphasis">unordered_multimap</span> ;

    <span class="docEmphasis">// FUNCTION TEMPLATES swap</span>
template &lt;class Key, class Ty, class Hash,
  class Pred, class Alloc&gt;
void <span class="docEmphasis">swap</span> (unordered_map (Key, Ty, Hash, Pred, Alloc&gt;&amp; left,
  unordered_map (Key, Ty, Hash, Pred, Alloc&gt;&amp; right);
template &lt;class Key, class Ty, class Hash, class Pred,
  class Alloc&gt;
void <span class="docEmphasis">swap</span> (
  unordered_multimap (Key, Ty, Hash, Pred, Alloc&gt;&amp; left,
  unordered_multimap (Key, Ty, Hash, Pred, Alloc&gt;&amp; right);

    <span class="docEmphasis">// CLASS TEMPLATE unordered_map</span>
template &lt;class Key,
  class Ty,
  class Hash = hash &lt;Key&gt;,
  class Pred = equal_to &lt;Key&gt;,
  class Alloc = allocator &lt;pair &lt;const Key, Ty&gt;&gt;&gt;
  class unordered_map {
public :

    <span class="docEmphasis">// NESTED TYPES</span>
  typedef Key <span class="docEmphasis">key_type</span> ;
  typedef Hash <span class="docEmphasis">hasher</span> ;
  typedef Pred <span class="docEmphasis">key_equal</span> ;
  typedef pair &lt;const Key, Ty&gt; <span class="docEmphasis">value_type</span> ;
  typedef Ty <span class="docEmphasis">mapped_type</span> ;
  typedef Alloc <span class="docEmphasis">allocator_type</span> ;
  typedef Alloc :: pointer <span class="docEmphasis">pointer</span> ;
  typedef Alloc :: const_pointer <span class="docEmphasis">const_pointer</span> ;
  typedef Alloc :: reference <span class="docEmphasis">reference</span> ;
  typedef Alloc :: const_reference <span class="docEmphasis">const_reference</span> ;

  typedef T0 <span class="docEmphasis">iterator</span> ;
  typedef T1 <span class="docEmphasis">const_iterator</span> ;
  typedef T2 <span class="docEmphasis">local_iterator</span> ;
  typedef T3 <span class="docEmphasis">const_local_iterator</span> ;
  typedef T4 <span class="docEmphasis">size_type</span> ;
  typedef T5 <span class="docEmphasis">difference_type</span> ;

    <span class="docEmphasis">// CONSTRUCTING AND ASSIGNING</span>
explicit <span class="docEmphasis">unordered_map</span> (
  size_type n = n0, <span class="docEmphasis">// implementation-defined</span>
  const hasher &amp; h = hasher (),
  const key_equal &amp; comp = key_equal (),
  const allocator_type &amp; alloc = allocator_type ());
template &lt;class InIt&gt;
  <span class="docEmphasis">unordered_map</span> (InIt first, InIt last,
  size_type n = n0, <span class="docEmphasis">// implementation-defined</span>
  const hasher &amp; h = hasher (),
  const key_equal &amp; comp = key_equal (),
  const allocator_type &amp; alloc = allocator_type ());
<span class="docEmphasis">unordered_map</span> (const unordered_map &amp; right);
unordered_map &amp; <span class="docEmphasis">operator=</span> (const unordered_map &amp; right);

    <span class="docEmphasis">// MODIFYING</span>
  pair &lt;iterator, bool&gt; <span class="docEmphasis">insert</span> (const value_type &amp; val);
  iterator <span class="docEmphasis">insert</span> (
    iterator where, const value_type &amp; val);
  const_iterator <span class="docEmphasis">insert</span> (
    const_iterator where, const value_type&amp; val);
  template &lt;class InIt&gt;
    void <span class="docEmphasis">insert</span> (InIt first, InIt last);

  iterator <span class="docEmphasis">erase</span> (iterator where);
  const_iterator <span class="docEmphasis">erase</span> ( const_iterator where);
  size_type <span class="docEmphasis">erase</span> (const Key &amp; keyval);
  iterator <span class="docEmphasis">erase</span> (
    iterator first, iterator last);
  const_iterator <span class="docEmphasis">erase</span> (
    const_iterator first, const_iterator last);
  void <span class="docEmphasis">clear</span> ();

  void <span class="docEmphasis">swap</span> (unordered_map &amp; right);

    <span class="docEmphasis">// ITERATING</span>
  iterator <span class="docEmphasis">begin</span> ();
  iterator <span class="docEmphasis">end</span> ();
  const_iterator <span class="docEmphasis">begin</span> () const;
  const_iterator <span class="docEmphasis">end</span> () const ;

    <span class="docEmphasis">// SEARCHING</span>
  iterator <span class="docEmphasis">find</span> (const Key &amp; keyval);
  const_iterator <span class="docEmphasis">find</span> (const Key &amp; keyval) const;
  size_type <span class="docEmphasis">count</span> (const Key &amp; keyval) const;
  pair &lt;iterator, iterator&gt;
    <span class="docEmphasis">equal_range</span> (const Key &amp; keyval);
  pair &lt;const_iterator, const_iterator&gt;
    <span class="docEmphasis">equal_range</span> (const Key &amp; keyval) const;
  mapped_type &amp; operator []( const Key &amp; keyval);
  const mapped_type &amp; operator []( const Key &amp; keyval) const;

    <span class="docEmphasis">// QUERYING</span>
  size_type <span class="docEmphasis">size</span> () const ;
  size_type <span class="docEmphasis">max_size</span> () const;
  bool <span class="docEmphasis">empty</span> () const;

  allocator_type <span class="docEmphasis">get_allocator</span> () const;
  hasher <span class="docEmphasis">hash_function</span> () const ;
  key_equal <span class="docEmphasis">key_eq</span> () const ;

    <span class="docEmphasis">// TUNING</span>
  local_iterator <span class="docEmphasis">begin</span> (size_type n);
  const_local_iterator <span class="docEmphasis">begin</span> (size_type n) const;
  local_iterator <span class="docEmphasis">end</span> (size_type n);
  const_local_iterator <span class="docEmphasis">end</span> (size_type n) const ;

  size_type <span class="docEmphasis">bucket_count</span> () const;
  size_type <span class="docEmphasis">max_bucket_count</span> () const ;
  size_type <span class="docEmphasis">bucket_size</span> (size_type n) const;
  size_type <span class="docEmphasis">bucket</span> (const key_type &amp; val) const ;

  float <span class="docEmphasis">load_factor</span> () const ;
  float <span class="docEmphasis">max_load_factor</span> () const ;
  void <span class="docEmphasis">max_load_factor</span> (float fact);
  void <span class="docEmphasis">rehash</span> (size_type n);
  };

    <span class="docEmphasis">// CLASS TEMPLATE unordered_multimap</span>
template &lt;class Key,
  class Ty,
  class Hash = hash &lt;Key&gt;,
  class Pred = equal_to &lt;Key&gt;,
  class Alloc = allocator &lt;pair &lt;const Key, Ty&gt;&gt;&gt;
  class unordered_multimap {
    <span class="docEmphasis">// CONTENTS ARE THE SAME AS unordered_map WITHOUT operator[]</span>
  };

} }
</pre></div><br>

</TD></TR></table>
<br>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<tr><td><div STYLE="MARGIN-LEFT: 0.15in;">
<a href=app01lev1sec2.html><img src="images/prev.gif" width="60" height="17" border="0" align="absmiddle" alt="Previous Page"></a>
<td align="right"><div STYLE="MARGIN-LEFT: 0.15in;">
<a href=app01lev1sec4.html><img src="images/next.gif" width="60" height="17" border="0" align="absmiddle" alt="Next Page"></a>
</div></td></tr></table>
</body></html>