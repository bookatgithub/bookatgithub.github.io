<html>
<META http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<head>
<title>Section A.6.&nbsp; Header &lt;functional&gt; Synopsis</title>
<link rel="STYLESHEET" type="text/css" href="images/style.css">
<link rel="STYLESHEET" type="text/css" href="images/docsafari.css">
</head>
<body>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<tr><td><div STYLE="MARGIN-LEFT: 0.15in;">
<a href=app01lev1sec5.html><img src="images/prev.gif" width="60" height="17" border="0" align="absmiddle" alt="Previous Page"></a>
<td align="right"><div STYLE="MARGIN-LEFT: 0.15in;">
<a href=app01lev1sec7.html><img src="images/next.gif" width="60" height="17" border="0" align="absmiddle" alt="Next Page"></a>
</div></td></tr></table>
<br><table width="100%" border="0" cellspacing="0" cellpadding="0"><tr><td valign="top"><a name="app01lev1sec6"></a>
<h3 id="title-IDAR0TTF" class="docSection1Title">A.6. <a name="iddle1337"></a>Header <tt>&lt;functional&gt;</tt> Synopsis</h3>
<div class="docText"><pre>namespace std {
template &lt;class Arg, class Result&gt;
  struct <span class="docEmphasis">unary_function</span> ;
template &lt;class Arg1, class Arg2, class Result&gt;
  struct <span class="docEmphasis">binary_function</span> ;
template &lt;class Ty&gt;
  struct <span class="docEmphasis">plus</span> ;
template &lt;class Ty&gt;
  struct <span class="docEmphasis">minus</span> ;
template &lt;class Ty&gt;
  struct <span class="docEmphasis">multiplies</span> ;
template &lt;class Ty&gt;
  struct <span class="docEmphasis">divides</span> ;
template &lt;class Ty&gt;
  struct <span class="docEmphasis">modulus</span> ;
template &lt;class Ty&gt;
  struct <span class="docEmphasis">negate</span> ;
template &lt;class Ty&gt;
  struct <span class="docEmphasis">equal_to</span> ;
template &lt;class Ty&gt;
  struct <span class="docEmphasis">not_equal_to</span> ;
template &lt;class Ty&gt;
  struct <span class="docEmphasis">greater</span> ;
template &lt;class Ty&gt;
  struct <span class="docEmphasis">less</span> ;
template &lt;class Ty&gt;
  struct <span class="docEmphasis">greater_equal</span> ;
template &lt;class Ty&gt;
  struct <span class="docEmphasis">less_equal</span> ;
template &lt;class Ty&gt;
  struct <span class="docEmphasis">logical_and</span> ;
template &lt;class Ty&gt;
  struct <span class="docEmphasis">logical_or</span> ;
template &lt;class Ty&gt;
  struct <span class="docEmphasis">logical_not</span> ;
template &lt;class Fn1&gt;
  struct <span class="docEmphasis">unary_negate</span> ;
template &lt;class Fn2&gt;
  struct <span class="docEmphasis">binary_negate</span> ;
template &lt;class Fn2&gt;
  class <span class="docEmphasis">binder1st</span> ;
template &lt;class Fn2&gt;
  class <span class="docEmphasis">binder2nd</span> ;
template &lt;class Arg, class Result&gt;
  class <span class="docEmphasis">pointer_to_unary_function</span> ;
template &lt;class Arg1, class Arg2, class Result&gt;
  class <span class="docEmphasis">pointer_to_binary_function</span> ;
template &lt;class Result, class Ty&gt;
  struct <span class="docEmphasis">mem_fun_t</span> ;
template &lt;class Result, class Ty, class Arg&gt;
  struct <span class="docEmphasis">mem_fun1_t</span> ;
template &lt;class Result, class Ty&gt;
  struct <span class="docEmphasis">const_mem_fun_t</span> ;
template &lt;class Result, class Ty, class Arg&gt;
  struct <span class="docEmphasis">const_mem_fun1_t</span> ;
template &lt;class Result, class Ty&gt;
  struct <span class="docEmphasis">mem_fun_ref_t</span> ;
template &lt;class Result, class Ty, class Arg&gt;
  struct <span class="docEmphasis">mem_fun1_ref_t</span> ;
template &lt;class Result, class Ty&gt;
  struct <span class="docEmphasis">const_mem_fun_ref_t</span> ;
template &lt;class Result, class Ty, class Arg&gt;
  struct <span class="docEmphasis">const_mem_fun1_ref_t</span> ;

    <span class="docEmphasis">// TEMPLATE FUNCTIONS</span>
template &lt;class Fn1&gt;
  unary_negate &lt;Fn1&gt; <span class="docEmphasis">not1</span> (const Fn1 &amp; func);
template &lt;class Fn2&gt;
  binary_negate &lt;Fn2&gt; <span class="docEmphasis">not2</span> (const Fn2 &amp; func);
template &lt;class Fn2, class Ty&gt;
  binder1st &lt;Fn2&gt; <span class="docEmphasis">bind1st</span> (const Fn2 &amp; func, const Ty&amp; left);
template &lt;class Fn2, class Ty&gt;
  binder2nd &lt;Fn2&gt; <span class="docEmphasis">bind2nd</span> (
    const Fn2 &amp; func, const Ty&amp; right);
template &lt;class Arg, class Result&gt;
  pointer_to_unary_function &lt;Arg, Result&gt;
    <span class="docEmphasis">ptr_fun</span> (Result (*)( Arg));
template &lt;class Arg1, class Arg2, class Result&gt;
  pointer_to_binary_function &lt;Arg1, Arg2, Result&gt;
    <span class="docEmphasis">ptr_fun</span> (Result (*)( Arg1, Arg2));
template &lt;class Result, class Ty&gt;
  mem_fun_t &lt;Result, Ty&gt; <span class="docEmphasis">mem_fun</span> (Result (Ty::* pm)());
template &lt;class Result, class Ty, class Arg&gt;
  mem_fun1_t &lt;Result, Ty, Arg&gt; <span class="docEmphasis">mem_fun</span> (
    Result (Ty::* pm)(Arg left));
template &lt;class Result, class Ty&gt;
  const_mem_fun_t &lt;Result, Ty&gt; <span class="docEmphasis">mem_fun</span> (
    Result (Ty::* pm)() const);
template &lt;class Result, class Ty, class Arg&gt;
  const_mem_fun1_t &lt;Result, Ty, Arg&gt; <span class="docEmphasis">mem_fun</span> (
    Result (Ty::* pm)(Arg left) const);
template &lt;class Result, class Ty&gt;
  mem_fun_ref_t &lt;Result, Ty&gt; <span class="docEmphasis">mem_fun_ref</span> (
    Result (Ty::* pm)());
template &lt;class Result, class Ty, class Arg&gt;
  mem_fun1_ref_t &lt;Result, Ty, Arg&gt;
    <span class="docEmphasis">mem_fun_ref</span> (Result (Ty::* pm)(Arg left));
template &lt;class Result, class Ty&gt;
  const_mem_fun_ref_t &lt;Result, Ty&gt; <span class="docEmphasis">mem_fun_ref</span> (
    Result (Ty::* pm)() const);
template &lt;class Result, class Ty, class Arg&gt;
  const_mem_fun1_ref_t &lt;Result, Ty, Arg&gt;
    <span class="docEmphasis">mem_fun_ref</span> (Result (Ty::* pm)(Arg left) const);

  namespace tr1 {
    <span class="docEmphasis">// REFERENCE WRAPPERS</span>
template &lt;class Ty&gt; reference_wrapper &lt;Ty&gt;
  <span class="docEmphasis">ref</span> (Ty&amp;);
template &lt;class Ty&gt; reference_wrapper &lt;Ty&gt;
  <span class="docEmphasis">ref</span> (reference_wrapper &lt;Ty&gt;&amp;);
template &lt;class Ty&gt; reference_wrapper &lt;const Ty&gt;
  <span class="docEmphasis">cref</span> (const Ty&amp;);
template &lt;class Ty&gt; reference_wrapper &lt;const Ty&gt;
  <span class="docEmphasis">cref</span> (const reference_wrapper &lt;Ty&gt;&amp;);
template &lt;class Ty&gt;
  struct <span class="docEmphasis">reference_wrapper</span> ;

    <span class="docEmphasis">// FUNCTION OBJECT RETURN TYPES</span>
template &lt;class Ty&gt;
  struct <span class="docEmphasis">result_of</span> ;

    <span class="docEmphasis">// ENHANCED MEMBER POINTER ADAPTER</span>
template &lt;class Ret, class Ty&gt;
  <span class="docEmphasis">unspecified mem_fn</span> (Ret Ty ::*);

    <span class="docEmphasis">// FUNCTION OBJECT WRAPPERS</span>
class <span class="docEmphasis">bad_function_call</span> ;
template &lt;class Fty&gt;
  class <span class="docEmphasis">function</span> ;
template &lt;class Fty&gt;
  void <span class="docEmphasis">swap</span> (function &lt;Fty&gt;&amp; f1,
    function &lt;Fty&gt;&amp; f2);
template &lt;class Fty&gt;
  bool <span class="docEmphasis">operator!=</span> (const function &lt;Fty&gt;&amp;,
    null_ptr_type);
template &lt;class Fty&gt;
  bool <span class="docEmphasis">operator!=</span> (null_ptr_type,
    const function &lt;Fty&gt;&amp;);
template &lt;class Fty&gt;
  bool <span class="docEmphasis">operator==</span> (const function &lt;Fty&gt;&amp;,
    null_ptr_type);
template &lt;class Fty&gt;
  bool <span class="docEmphasis">operator==</span> (null_ptr_type,
    const function &lt;Fty&gt;&amp;);

    <span class="docEmphasis">// ENHANCED BINDERS</span>
template &lt;class Fty, class T1, class T2, ..., class TN&gt;
  <span class="docEmphasis">unspecified bind</span> (Fty, T1, T2, ..., TN);
template &lt;class Ret,
  class Fty, class T1, class T2, ..., class TN&gt;
  <span class="docEmphasis">unspecified bind</span> (Fty, T1, T2, ..., TN);
template &lt;class Ret,
  class Ty, class T1, class T2, ..., class TN&gt;
  <span class="docEmphasis">unspecified bind</span> (Ret Ty::*, T1, T2, ..., TN);

template &lt;class Ty&gt;
  struct <span class="docEmphasis">is_bind_expression</span> ;
template &lt;class Ty&gt;
  struct <span class="docEmphasis">is_placeholder</span> ;

    namespace placeholders {
extern <span class="docEmphasis">unspecified _1 ; // _2, _3, ... _M</span>
    }<span class="docEmphasis">// namespace placeholders</span>
  }  <span class="docEmphasis">// namespace tr1</span>
}  <span class="docEmphasis">// namespace std</span>
</pre></div><br>

<a href="31031536.html"><img src="images/pixel.jpg" alt="" width="1" height="1" border="0"></a></TD></TR></table>
<br>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<tr><td><div STYLE="MARGIN-LEFT: 0.15in;">
<a href=app01lev1sec5.html><img src="images/prev.gif" width="60" height="17" border="0" align="absmiddle" alt="Previous Page"></a>
<td align="right"><div STYLE="MARGIN-LEFT: 0.15in;">
<a href=app01lev1sec7.html><img src="images/next.gif" width="60" height="17" border="0" align="absmiddle" alt="Next Page"></a>
</div></td></tr></table>
</body></html>