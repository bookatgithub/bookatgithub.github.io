<html>
<META http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<head>
<title>Chapter 1.&nbsp; Tuples</title>
<link rel="STYLESHEET" type="text/css" href="images/style.css">
<link rel="STYLESHEET" type="text/css" href="images/docsafari.css">
</head>
<body>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<tr><td><div STYLE="MARGIN-LEFT: 0.15in;">
<a href=part01.html><img src="images/prev.gif" width="60" height="17" border="0" align="absmiddle" alt="Previous Page"></a>
<td align="right"><div STYLE="MARGIN-LEFT: 0.15in;">
<a href=ch01lev1sec1.html><img src="images/next.gif" width="60" height="17" border="0" align="absmiddle" alt="Next Page"></a>
</div></td></tr></table>
<br><table width="100%" border="0" cellspacing="0" cellpadding="0"><tr><td valign="top"><a name="ch01"></a>


<h2 id="title-IDAWMYLP" class="docChapterTitle">Chapter 1. Tuples</H2>


<blockquote>
<p class="docText"><a name="iddle1445"></a><a name="iddle1508"></a><a name="iddle1776"></a><a name="iddle1805"></a>You cannot conceive of the many without the one.</P>

<p class="docText"><span class="docEmphasis">Parmenides</span> <br>P<span class="docEmphSmaller">LATO</span></P></blockquote>
<p class="docText">The class template <tt>tuple</tt> is a generalization of the standard C++ library class template <tt>pair</tt>. The <tt>pair</tt> template takes two type arguments; objects of type <tt>pair&lt;T</tt><sub>1</sub><tt>, T</tt><sub>2</sub><tt>&gt;</tt> hold two elements: one of type <tt>T</tt><sub>1</sub> and one of type <tt>T</tt><sub>2</sub>. The <tt>tuple</tt> template extends this by taking an arbitrary number of type arguments. Objects of type <tt>tuple&lt;T</tt><sub>1</sub><tt>, T</tt><sub>2</sub><tt>, ..., T</tt><span class="docEmphasis"><sub>N</sub></span><tt>&gt;</tt> hold <span class="docEmphasis">N</span> elements of types <tt>T</tt><sub>1</sub><tt>, T</tt><sub>2</sub><tt>, ..., T</tt><span class="docEmphasis"><sub>N</sub></span>, respectively.<sup class="docFootnote"><a class="docLink" href="#ch01fn1">[1]</a></sup></p><blockquote><p class="docFootnote"><sup><a name="ch01fn1">[1]</a></sup> Each library implementation is allowed to put an upper limit on the value of <span class="docEmphasis">N</span>. The Library Technical Report recommends that this upper limit be at least 10.</P></blockquote>
<a name="ch01ex01"></a><H5 id="title-IDA0PYLP" class="docExampleTitle">Example 1.1. Tuple Declarations (<tt>tuples/typedefs.cpp</tt>)</H5><P><table cellspacing="0" width="90%" border="1" cellpadding="5"><tr><TD>



<pre>#include &lt;tuple&gt;
using std::tr1::tuple;

tuple&lt;&gt; none;                      // <span class="docEmphasis">holds no elements</span>
tuple&lt;int&gt; one;                    // <span class="docEmphasis">holds one element, of type int</span>

int i; double d;
tuple&lt;int&amp;, const double&amp;&gt;
    two(i,d);                      // <span class="docEmphasis">holds two elements, one of</span>
                                   // <span class="docEmphasis">type reference to int and one</span>
                                   // <span class="docEmphasis">of type reference to const double</span>
tuple&lt;int, int, int, int, int,
   int, int, int, int, int&gt; ten ;  // <span class="docEmphasis">holds ten elements, all of type int</span>
</pre><br>

</TD></TR></table></p>
<p class="docText">You can create <tt>tuple</tt> objects through each <tt>tuple</tt> type's constructors. In addition, two function templates<tt>make_tuple</tt> and <tt>tie</tt>return <tt>tuple</tt> objects whose types are based on the arguments to the functions. These techniques for creating <tt>tuple</tt> objects are covered in <a class="docLink" href="ch01lev1sec2.html#ch01lev2sec1">Section 1.2.1</a>.</P>
<p class="docText"><a name="iddle1232"></a><a name="iddle1341"></a><a name="iddle1500"></a><a name="iddle1785"></a><a name="iddle1789"></a><a name="iddle1797"></a><a name="iddle1801"></a>The function template <tt>get</tt> returns a reference to an element of a <tt>tuple</tt> object. The result can be used to examine the value of the element and to modify an element of a non-const <tt>tuple</tt> object. The values of elements can also be changed by assigning one <tt>tuple</tt> object to another. These access mechanisms are covered in <a class="docLink" href="ch01lev1sec2.html#ch01lev2sec2">Section 1.2.2</a>.</P>
<p class="docText">You can ask about the size of a specialization of <tt>tuple</tt> and the type of each of its elements through the class templates <tt>tuple_size</tt> and <tt>tuple_element</tt>. These templates are covered in <a class="docLink" href="ch01lev1sec2.html#ch01lev2sec3">Section 1.2.3</a>.</p>
<p class="docText">You can compare two <tt>tuple</tt> objects of the same size for equality and for relative order. See <a class="docLink" href="ch01lev1sec2.html#ch01lev2sec4">Section 1.2.4</a>.</p>




</TD></TR></table>
<br>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<tr><td><div STYLE="MARGIN-LEFT: 0.15in;">
<a href=part01.html><img src="images/prev.gif" width="60" height="17" border="0" align="absmiddle" alt="Previous Page"></a>
<td align="right"><div STYLE="MARGIN-LEFT: 0.15in;">
<a href=ch01lev1sec1.html><img src="images/next.gif" width="60" height="17" border="0" align="absmiddle" alt="Next Page"></a>
</div></td></tr></table>
</body></html>