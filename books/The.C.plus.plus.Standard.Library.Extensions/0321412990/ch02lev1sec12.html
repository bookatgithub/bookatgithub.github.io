<html>
<META http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<head>
<title>Exercises</title>
<link rel="STYLESHEET" type="text/css" href="images/style.css">
<link rel="STYLESHEET" type="text/css" href="images/docsafari.css">
</head>
<body>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<tr><td><div STYLE="MARGIN-LEFT: 0.15in;">
<a href=ch02lev1sec11.html><img src="images/prev.gif" width="60" height="17" border="0" align="absmiddle" alt="Previous Page"></a>
<td align="right"><div STYLE="MARGIN-LEFT: 0.15in;">
<a href=part02.html><img src="images/next.gif" width="60" height="17" border="0" align="absmiddle" alt="Next Page"></a>
</div></td></tr></table>
<br><table width="100%" border="0" cellspacing="0" cellpadding="0"><tr><td valign="top"><a name="ch02lev1sec12"></a>
<h3 id="title-IDAW1MWG" class="docSection1Title">Exercises</H3>
<a name="ch02lev2sec26"></a>
<H4 id="title-IDA51MWG" class="docSection2Title">Exercise 1</h4>
<P><table border="0" cellspacing="16" cellpadding="0"><tr valign="top"><TD align="right" class="docText" width="50"><a name="ch02qa1q1"></a><B></b></TD><TD><p class="docText">For each of the following errors, write a simple test case containing the error, and try to compile it. In the error messages, look for the key words that relate to the error in the code.</p>
<div style="font-weight:bold"><ol class="docList" type="1"><LI><div style="font-weight:normal"><p class="docList">Attempting to construct a <tt>shared_ptr</tt> object with a pointer type that is not convertible to the pointer type held by the <tt>shared_ptr</tt></p></div></LI><LI><div style="font-weight:normal"><p class="docList">Attempting to construct a <tt>shared_ptr</tt> object with another <tt>shared_ptr</tt> object that holds a pointer type that is not convertible to the pointer type held by the object being constructed</p></div></LI><LI><div style="font-weight:normal"><p class="docList">Attempting to construct a <tt>shared_ptr</tt> object with a pointer and a deleter object whose function call operator can't be called with the original pointer</p></div></li><li><div style="font-weight:normal"><p class="docList">Attempting to convert a <tt>shared_ptr&lt;int&gt;</tt> to a <tt>shared_ptr&lt;double&gt;</tt> with <tt>static_pointer_cast</tt></p></div></LI></ol></div>
</td></tr></table></P>

<a name="ch02lev2sec27"></a>
<H4 id="title-IDA53MWG" class="docSection2Title">Exercise 2</H4>
<p><table border="0" cellspacing="16" cellpadding="0"><tr valign="top"><TD align="right" class="docText" width="50"><a name="ch02qa2q1"></a><b></b></td><td><p class="docText">Write a program that demonstrates the use of <tt>shared_ptr</tt> accessors. Begin by defining a simple struct that has one public data member and a default constructor that initializes that data member. Create a <tt>shared_ptr</tt> object that points to an object of this type. Display the value of the stored object's data member three times: once using <tt>shared_ptr::get()</tt>, once using <tt>shared_ptr::operator*</tt>, and once using <tt>shared_ptr::operator-&gt;</tt>.</p>
</td></tr></table></p>

<a name="ch02lev2sec28"></a>
<h4 id="title-IDAB5MWG" class="docSection2Title">Exercise 3</h4>
<p><table border="0" cellspacing="16" cellpadding="0"><tr valign="top"><td align="right" class="docText" width="50"><a name="ch02qa3q1"></a><B></b></td><TD><p class="docText">How many different ways can you think of to determine whether a <tt>shared_ptr</tt> object holds a non-null pointer? Write a program to verify that they all work correctly.</p>
</td></tr></table></P>

<a name="ch02lev2sec29"></a>
<H4 id="title-IDA15MWG" class="docSection2Title">Exercise 4</h4>
<P><table border="0" cellspacing="16" cellpadding="0"><tr valign="top"><TD align="right" class="docText" width="50"><a name="ch02qa4q1"></a><B></b></TD><TD><p class="docText">Write a program consisting of a type definition, a function template, and a <tt>main</tt> function. The type definition should be a class whose constructor and destructor write logging messages to <tt>cout</tt>. (Use the <tt>instrumented</tt> class from <tt>sputil.h</tt> if you like). The function template should take an argument of an arbitrary type by value. Its body should simply write a logging message to <tt>cout</tt>, showing that it was called. In <tt>main</tt>, create an object of your logging type on the heap, and create a <tt>shared_ptr</tt> object to manage it. Call the function template with this <tt>shared_ptr</tt> object. Add logging messages to <tt>main</tt> so that you can see when the heap object is destroyed relative to the call to the function template. Do the same thing using an <tt>auto_ptr</tt> object to manage the heap object. Explain the output.</p>
</TD></tr></table></P>

<a name="ch02lev2sec30"></a>
<H4 id="title-IDAMZNWG" class="docSection2Title">Exercise 5</h4>
<P><table border="0" cellspacing="16" cellpadding="0"><TR valign="top"><td align="right" class="docText" width="50"><a name="ch02qa5q1"></a><b></b></td><td><p class="docText">Write a program that allocates an array of objects on the heap and manages that array with a <tt>shared_ptr</tt> object. Check that the array is properly deleted when it is no longer in use.</P>
</td></tr></table></P>

<a name="ch02lev2sec31"></a>
<H4 id="title-IDAG0NWG" class="docSection2Title">Exercise 6</H4>
<p><table border="0" cellspacing="16" cellpadding="0"><tr valign="top"><TD align="right" class="docText" width="50"><a name="ch02qa6q1"></a><b></b></td><td><p class="docText">I said in <a class="docLink" href="ch02lev1sec4.html#ch02lev2sec2">Section 2.4.2</a> that you shouldn't construct two <tt>shared_ptr</tt> objects from the same pointer. The danger is that both <tt>shared_ptr</tt> objects or their progeny will eventually try to delete the resource, and that usually leads to trouble. In fact, you can do this if you're careful. It's not particularly useful, but write a program that constructs two <tt>shared_ptr&lt;instrumented&gt;</tt> objects from the same pointer and deletes the resource only once.</p>
</td></tr></table></p>

<a name="ch02lev2sec32"></a>
<h4 id="title-IDAL1NWG" class="docSection2Title">Exercise 7</h4>
<p><table border="0" cellspacing="16" cellpadding="0"><tr valign="top"><td align="right" class="docText" width="50"><a name="ch02qa7q1"></a><B></b></td><TD><p class="docText">Write a program consisting of two functionsthe <tt>main</tt> function and a function named <tt>write</tt>. The <tt>write</tt> function should take an argument of type <tt>shared_ptr&lt;FILE&gt;</tt> and should write some text to the C-style stream identified by the <tt>FILE*</tt> held in the <tt>shared_ptr</tt> object. (Use the member function <tt>get()</tt> to get the pointer.) The <tt>main</tt> function should create two <tt>shared_ptr&lt;FILE&gt;</tt> objects. One should hold the pointer returned by a call to <tt>fopen</tt> and should properly close the stream when the last <tt>shared_ptr</tt> object managing that file is destroyed. The other should hold the pointer <tt>stdout</tt> and should not close the stream. The <tt>main</tt> function should call <tt>write</tt> with each of <tt>shared_ptr</tt> objects.</p>
</td></tr></table></P>

<a name="ch02lev2sec33"></a>
<H4 id="title-IDAB3NWG" class="docSection2Title">Exercise 8</h4>
<P><table border="0" cellspacing="16" cellpadding="0"><tr valign="top"><TD align="right" class="docText" width="50"><a name="ch02qa8q1"></a><B></b></TD><TD><p class="docText">Assume that you have the following objects:</p>
<div class="docText"><pre><span class="docEmphasis">// EMPTY <tt>shared_ptr</tt> OBJECTS</span>
shared_ptr&lt;int&gt; sp0;
shared_ptr&lt;int&gt; sp1 (sp0);
shared_ptr&lt;int&gt; sp2;

<span class="docEmphasis">// <tt>shared_ptr</tt> OBJECTS HOLDING NULL POINTERS</span>
shared_ptr&lt;int&gt; sp3 ((int *)0);
shared_ptr&lt;int&gt; sp4 (sp3);
shared_ptr&lt;int&gt; sp5 ((int *)0);

<span class="docEmphasis">// <tt>shared_ptr</tt> OBJECTS HOLDING NON-NULL POINTERS</span>
shared_ptr&lt;int&gt; sp6 (new int (3));
shared_ptr&lt;int&gt; sp7 (sp6);
shared_ptr&lt;int&gt; sp8 (new int (3));
</pre></div><BR>
<div style="font-weight:bold"><ol class="docList" type="1"><li><div style="font-weight:normal"><p class="docList">What should the result of the following comparisons be?</P><div style="font-weight:bold"><ol class="docList" type="a"><LI><div style="font-weight:normal"><p class="docList"><tt>sp0 == sp1</tt></p></div></LI><LI><div style="font-weight:normal"><p class="docList"><tt>sp0 == sp2</tt></p></div></li><li><div style="font-weight:normal"><p class="docList"><tt>sp0 == sp3</tt></p></div></LI><li><div style="font-weight:normal"><p class="docList"><tt>sp3 == sp4</tt></p></div></LI><LI><div style="font-weight:normal"><p class="docList"><tt>sp3 == sp5</tt></P></div></li><li><div style="font-weight:normal"><p class="docList"><tt>sp0 == sp6</tt></P></div></li><li><div style="font-weight:normal"><p class="docList"><tt>sp6 == sp7</tt></p></div></li><li><div style="font-weight:normal"><p class="docList"><tt>sp6 == sp8</tt></p></div></li></ol></div></div></li><li><div style="font-weight:normal"><p class="docList">Write a program to verify your answers.</p></div></li><li><div style="font-weight:normal"><p class="docList">Consider the following function:</P><div class="docText"><pre>template &lt;class Ty1, class Ty2&gt;
bool equiv(shared_ptr&lt;Ty1&gt; left,
  shared_ptr&lt;Ty2&gt; right)
  {
  return !(left &lt; right) &amp;&amp; !(right &lt; left);
  }
</pre></div><p class="docList">Logically, it makes sense to say that <tt>left</tt> and <tt>right</tt> are equivalent if <tt>left</tt> is not less than <tt>right</tt> and <tt>right</tt> is not less than <tt>left</tt>. In fact, since <tt>operator&lt;</tt> for <tt>shared_ptr</tt> types defines a strict weak ordering, it can be shown that <tt>equiv</tt> in turn is an equivalence relation, as its name suggests. In <a class="docLink" href="ch02lev1sec4.html#ch02lev2sec8">Section 2.4.8</a>, we saw that this equivalence relation is required to be true only for objects that are empty or share ownership of the same resource. That's different from the rule for <tt>operator==</tt>. What should the result of the following function calls be?</p><div style="font-weight:bold"><ol class="docList" type="a"><LI><div style="font-weight:normal"><p class="docList"><tt>equiv(sp0, sp1)</tt></p></div></li><li><div style="font-weight:normal"><p class="docList"><tt>equiv(sp0, sp2)</tt></P></div></LI><li><div style="font-weight:normal"><p class="docList"><tt>equiv(sp0, sp3)</tt></P></div></li><LI><div style="font-weight:normal"><p class="docList"><tt>equiv(sp3, sp4)</tt></P></div></LI><LI><div style="font-weight:normal"><p class="docList"><tt>equiv(sp3, sp5)</tt></p></div></LI><li><div style="font-weight:normal"><p class="docList"><tt>equiv(sp0, sp6)</tt></P></div></LI><li><div style="font-weight:normal"><p class="docList"><tt>equiv(sp6, sp7)</tt></P></div></LI><li><div style="font-weight:normal"><p class="docList"><tt>equiv(sp6, sp8)</tt></p></div></li></ol></div></div></li><LI><div style="font-weight:normal"><p class="docList">Write a program to verify your answers.</p></div></li></ol></div>
</TD></TR></table></P>

<a name="ch02lev2sec34"></a>
<h4 id="title-IDAPDOWG" class="docSection2Title">Exercise 9</h4>
<P><table border="0" cellspacing="16" cellpadding="0"><tr valign="top"><td align="right" class="docText" width="50"><a name="ch02qa9q1"></a><b></b></td><td><p class="docText">
<div style="font-weight:bold"><ol class="docList" type="1"><li><div style="font-weight:normal"><p class="docList">Use the function template <tt>equiv</tt> given in the previous exercise and the following data types and data objects:</p><div class="docText"><pre><span class="docEmphasis">// TYPES</span>
struct base1 {};
struct base2 {};
struct derived : base1, base2 {};

<span class="docEmphasis">// OBJECTS</span>
shared_ptr&lt;derived&gt; sp0(new derived);
shared_ptr&lt;base1&gt; sp1(sp0);
shared_ptr&lt;base2&gt; sp2(sp0);
shared_ptr&lt;derived&gt; sp3(new derived);
</pre></div><p class="docList">What should the result of the following function calls be?</p><div style="font-weight:bold"><ol class="docList" type="a"><li><div style="font-weight:normal"><p class="docList"><tt>equiv(sp0, sp1)</tt></p></div></li><li><div style="font-weight:normal"><p class="docList"><tt>equiv(sp0, sp2)</tt></P></div></li><LI><div style="font-weight:normal"><p class="docList"><tt>equiv(sp1, sp2)</tt></p></div></li><li><div style="font-weight:normal"><p class="docList"><tt>equiv(sp3, sp1)</tt></P></div></LI><li><div style="font-weight:normal"><p class="docList"><tt>equiv(sp3, sp2)</tt></P></div></li></ol></div><p class="docList">Write a program to verify your answers.</P></div></LI><LI><div style="font-weight:normal"><p class="docList">What should happen if you use <tt>==</tt> instead of <tt>equiv</tt> for the comparisons? Write a program to verify your answers.</P></div></li></ol></div>
</P>
</td></TR></table></P>

<a name="ch02lev2sec35"></a>
<h4 id="title-IDANGOWG" class="docSection2Title">Exercise 10</H4>
<P><table border="0" cellspacing="16" cellpadding="0"><tr valign="top"><td align="right" class="docText" width="50"><a name="ch02qa10q1"></a><b></b></td><TD><p class="docText">Write a program consisting of a function named <tt>do_search</tt> and a <tt>main</tt> function. The <tt>do_search</tt> function should take one argument of type <tt>shared_ptr&lt;int&gt;</tt> and one argument of type <tt>const std::vector&lt;shared_ptr&lt;int&gt;&gt;&amp;</tt>. Assuming that the contents of the <tt>vector</tt> object are sorted, it should search for the <tt>shared_ptr&lt;int&gt;</tt> object in the <tt>vector</tt> object twice, first using the <tt>std::find</tt> algorithm and then using the <tt>std::binary_search</tt> algorithm, and report the results of both searches.</p>
<p class="docText">The <tt>main</tt> function should create several objects of type <tt>shared_ptr&lt;int&gt;</tt>, with each holding a pointer to an <tt>int</tt> object allocated on the heap. These <tt>int</tt> objects should all have different values. It should also create a <tt>shared_ptr&lt;int&gt;</tt> object that holds a null pointer and an empty <tt>shared_ptr&lt;int&gt;</tt> object. It should insert each of those <tt>shared_ptr&lt;int&gt;</tt> objects into an <tt>std:: vector&lt;shared_ptr&lt;int&gt;&gt;</tt> and use <tt>std::sort</tt> to sort the contents of the vector. Then it should do the following:</p>
<div style="font-weight:bold"><ol class="docList" type="1"><LI><div style="font-weight:normal"><p class="docList">Iterate through the container, showing the value, in order, of each of the <tt>int</tt> objects that the container elements control. Be careful not to dereference any null pointers.</P></div></LI><li><div style="font-weight:normal"><p class="docList">Call <tt>do_search</tt>, passing the empty <tt>shared_ptr</tt> object and the <tt>vector</tt> object.</p></div></LI><li><div style="font-weight:normal"><p class="docList">Call <tt>do_search</tt>, passing the <tt>shared_ptr</tt> object that holds a null pointer and the <tt>vector</tt> object.</p></div></li><li><div style="font-weight:normal"><p class="docList">Call <tt>do_search</tt>, passing one of the <tt>shared_ptr</tt> objects that holds a non-null pointer and the <tt>vector</tt> object.</p></div></li><li><div style="font-weight:normal"><p class="docList">Create another empty <tt>shared_ptr&lt;int&gt;</tt> object that is not a copy of the original one, and call <tt>do_search</tt> with the new object and the <tt>vector</tt> object.</p></div></li><li><div style="font-weight:normal"><p class="docList">Create another <tt>shared_ptr&lt;int&gt;</tt> object that holds a null pointer and is not a copy of the original one, and call <tt>do_search</tt> with the new object and the <tt>vector</tt> object.</p></div></li><LI><div style="font-weight:normal"><p class="docList">Create another <tt>shared_ptr&lt;int&gt;</tt> object that holds a pointer to an <tt>int</tt> object allocated on the heap and is not a copy of any of the original ones. The value of the <tt>int</tt> object should be the same as the value of one of the original ones. Call <tt>do_search</tt> with the new object and the <tt>vector</tt> object.</p></div></LI></ol></div>
<p class="docText">Explain the results.</p>
</td></tr></table></P>

<a name="ch02lev2sec36"></a>
<H4 id="title-IDAJLOWG" class="docSection2Title">Exercise 11</h4>
<P><table border="0" cellspacing="16" cellpadding="0"><tr valign="top"><TD align="right" class="docText" width="50"><a name="ch02qa11q1"></a><B></b></TD><TD><p class="docText">A double-linked list consists of nodes that hold a data item, a pointer to the next node in the list, and a pointer to the previous node in the list. For purposes of this exercise, the last node in the list stores a null pointer as its pointer to its next node, and the first node in the list stores a null pointer as its pointer to its previous node. You access the contents of the list through a pointer that points to the first node in the list.</p>
<div style="font-weight:bold"><ol class="docList" type="1"><LI><div style="font-weight:normal"><p class="docList">Write a class template <tt>template &lt;class Data&gt; node</tt> that holds an object of type <tt>Data</tt> named <tt>data</tt> and two pointers named <tt>next</tt> and <tt>prev</tt> that point to other objects of type <tt>node&lt;Data&gt;</tt>. Write another class template, <tt>template &lt;class Data&gt; list</tt>, that holds a pointer named <tt>head</tt> that points to an object of type <tt>node&lt;Data&gt;</tt>. The constructor for this template should initialize <tt>head</tt> to 0. Add a member function <tt>void list::insert(const Data&amp; val)</tt> that inserts a new <tt>node&lt;Data&gt;</tt> object holding the value <tt>val</tt> at the head of the linked list. Add a member function <tt>bool list::remove(const Data&amp; val)</tt> that removes all nodes whose <tt>data</tt> member is equal to <tt>val</tt> from the list. Make sure that <tt>list</tt>'s destructor deletes any nodes remaining in the list.</p></div></LI><LI><div style="font-weight:normal"><p class="docList">Rewrite the previous example, using objects of type <tt>shared_ptr&lt;node &lt;Data&gt;&gt;</tt> instead of pointers in the template <tt>node</tt> and in place of the pointer named <tt>head</tt> in the template <tt>list</tt>. Remove the destructor from <tt>list</tt>; it shouldn't be needed, because you're now using <tt>shared_ptr</tt> objects instead of pointers. Why doesn't this version of <tt>list</tt> destroy the remaining nodes when the <tt>list</tt> object goes out of scope?</p></div></LI><LI><div style="font-weight:normal"><p class="docList">Fix the memory leak in the previous example.</p></div></li></ol></div>
</td></tr></table></P>

<a name="ch02lev2sec37"></a>
<h4 id="title-IDAKOOWG" class="docSection2Title">Exercise 12</h4>
<P><table border="0" cellspacing="16" cellpadding="0"><TR valign="top"><TD align="right" class="docText" width="50"><a name="ch02qa12q1"></a><b></b></td><TD><p class="docText">Write three functions that each take a <tt>weak_ptr</tt> object and return a <tt>shared_ptr</tt> object. If the <tt>weak_ptr</tt> object has expired, the <tt>shared_ptr</tt> object returned by each function should be empty; otherwise, it should own the resource that the <tt>weak_ptr</tt> argument points to. Each function should, of course, use a different technique to make this determination. Write a program to verify that all three functions work correctly.</p>
</td></tr></table></p>

<a name="ch02lev2sec38"></a>
<h4 id="title-IDAMPOWG" class="docSection2Title">Exercise 13</h4>
<p><table border="0" cellspacing="16" cellpadding="0"><tr valign="top"><td align="right" class="docText" width="50"><a name="ch02qa13q1"></a><b></b></td><td><p class="docText">In <a class="docLink" href="ch02lev1sec8.html#ch02lev1sec8">Section 2.8</a>, we talked about implicit conversions between <tt>shared_ptr</tt> types and the three function templates for explicit conversions. Consider this class hierarchy:</P>
<div class="docText"><pre>class A { virtual void f () {} };
class B {};
class G : public A {};
class H : public B {};
class I : public virtual A {};
class J : public virtual B {};
class Z : public G, public H,
  public I, public J {};
</pre></div><br>
<div style="font-weight:bold"><ol class="docList" type="1"><LI><div style="font-weight:normal"><p class="docList">Beginning with an object <tt>shared_ptr&lt;Z&gt; spz(new Z)</tt>, which of the following assignments is valid as written, which can be made valid with an explicit conversion, and which ones are simply not allowed?</p><div style="font-weight:bold"><ol class="docList" type="a"><li><div style="font-weight:normal"><p class="docList"><tt>shared_ptr&lt;G&gt; spg = spz;</tt></p></div></LI><LI><div style="font-weight:normal"><p class="docList"><tt>shared_ptr&lt;Z&gt; t0 = spg;</tt></p></div></LI><li><div style="font-weight:normal"><p class="docList"><tt>shared_ptr&lt;A&gt; spa0 = spg;</tt></P></div></LI><LI><div style="font-weight:normal"><p class="docList"><tt>shared_ptr&lt;G&gt; t1 = spa0;</tt></P></div></li><LI><div style="font-weight:normal"><p class="docList"><tt>shared_ptr&lt;H&gt; sph = spz;</tt></p></div></LI><LI><div style="font-weight:normal"><p class="docList"><tt>shared_ptr&lt;const B&gt; spb0 = sph;</tt></p></div></LI><LI><div style="font-weight:normal"><p class="docList"><tt>shared_ptr&lt;H&gt; t2 = spb0;</tt></p></div></li><li><div style="font-weight:normal"><p class="docList"><tt>shared_ptr&lt;I&gt; spi = spz;</tt></p></div></LI><li><div style="font-weight:normal"><p class="docList"><tt>shared_ptr&lt;A&gt; spa1 = spi;</tt></p></div></LI><LI><div style="font-weight:normal"><p class="docList"><tt>shared_ptr&lt;I&gt; t3 = spa1;</tt></P></div></li><li><div style="font-weight:normal"><p class="docList"><tt>shared_ptr&lt;J&gt; spj = spz;</tt></P></div></li><li><div style="font-weight:normal"><p class="docList"><tt>shared_ptr&lt;B&gt; spb1 = spj;</tt></p></div></li><li><div style="font-weight:normal"><p class="docList"><tt>shared_ptr&lt;J&gt; t4 = spb1;</tt></p></div></li><li><div style="font-weight:normal"><p class="docList"><tt>shared_ptr&lt;G&gt; spgx = spb1;</tt></p></div></li><li><div style="font-weight:normal"><p class="docList"><tt>shared_ptr&lt;H&gt; sphx = spa1;</tt></p></div></LI></ol></div></div></li><LI><div style="font-weight:normal"><p class="docList">Write and compile some code to verify your answers.
</p></div></li></ol></div>
</td></TR></table></P>


<a href="31031536.html"><img src="images/pixel.jpg" alt="" width="1" height="1" border="0"></a></TD></TR></table>
<br>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<tr><td><div STYLE="MARGIN-LEFT: 0.15in;">
<a href=ch02lev1sec11.html><img src="images/prev.gif" width="60" height="17" border="0" align="absmiddle" alt="Previous Page"></a>
<td align="right"><div STYLE="MARGIN-LEFT: 0.15in;">
<a href=part02.html><img src="images/next.gif" width="60" height="17" border="0" align="absmiddle" alt="Next Page"></a>
</div></td></tr></table>
</body></html>