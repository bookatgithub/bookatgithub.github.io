<html>
<META http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<head>
<title>Section 2.4.&nbsp; The shared_ptr Class Template</title>
<link rel="STYLESHEET" type="text/css" href="images/style.css">
<link rel="STYLESHEET" type="text/css" href="images/docsafari.css">
</head>
<body>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<tr><td><div STYLE="MARGIN-LEFT: 0.15in;">
<a href=ch02lev1sec3.html><img src="images/prev.gif" width="60" height="17" border="0" align="absmiddle" alt="Previous Page"></a>
<td align="right"><div STYLE="MARGIN-LEFT: 0.15in;">
<a href=ch02lev1sec5.html><img src="images/next.gif" width="60" height="17" border="0" align="absmiddle" alt="Next Page"></a>
</div></td></tr></table>
<br><table width="100%" border="0" cellspacing="0" cellpadding="0"><tr><td valign="top"><a href="31031536.html"><img src="images/pixel.jpg" alt="" width="1" height="1" border="0"></a><a name="ch02lev1sec4"></a>
<h3 id="title-IDA1UEK" class="docSection1Title">2.4. The <tt>shared_ptr</tt> Class Template</H3><p class="docText"><a name="iddle1681"></a><a name="iddle1723"></a></P>
<div class="docText"><pre>template&lt;class Ty&gt; class shared_ptr {
public:
  typedef Ty <span class="docEmphasis">element_type</span>;

  <span class="docEmphasis">shared_ptr</span>();
  template&lt;class Other&gt;
    explicit <span class="docEmphasis">shared_ptr</span>(Other *ptr);
  template&lt;class Other, class D&gt;
    <span class="docEmphasis">shared_ptr</span>(Other *ptr, D dtor);
  <span class="docEmphasis">shared_ptr</span>(const shared_ptr&amp; sp);
  template&lt;class Other&gt;
    <span class="docEmphasis">shared_ptr</span>(const shared_ptr&lt;Other&gt;&amp; sp);
  template &lt;class Other&gt;
    <span class="docEmphasis">shared_ptr</span>(const weak_ptr&lt;Other&gt;&amp; wp);
  template&lt;class Other&gt;
    <span class="docEmphasis">shared_ptr</span>(const std::auto_ptr&lt;Other&gt;&amp; ap);
  ~<span class="docEmphasis">shared_ptr</span>();

  shared_ptr&amp; <span class="docEmphasis">operator=</span>(const shared_ptr&amp; sp);
  template&lt;class Other&gt;
    shared_ptr&amp; <span class="docEmphasis">operator=</span>(const shared_ptr&lt;Other&gt;&amp; sp);
  template&lt;class Other&gt;
    shared_ptr&amp; <span class="docEmphasis">operator=</span>(auto_ptr&lt;Other&gt;&amp; ap);

  void <span class="docEmphasis">swap</span>(shared_ptr&amp; s);
  void <span class="docEmphasis">reset</span>();
  template&lt;class Other&gt;
    void <span class="docEmphasis">reset</span>(Other *ptr);
  template&lt;class Other, class D&gt;
    void <span class="docEmphasis">reset</span>(Other *ptr, D dtor);

  Ty <span class="docEmphasis">*get</span>() const;
  Ty&amp; <span class="docEmphasis">operator*</span>() const;
  Ty *<span class="docEmphasis">operator-&gt;</span>() const;
  long <span class="docEmphasis">use_count</span>() const;
  bool <span class="docEmphasis">unique</span>() const;
  <span class="docEmphasis">operator boolean-type</span>() const;
  };
</pre></div><br>
<a name="ch02lev2sec1"></a>
<H4 id="title-IDASXEK" class="docSection2Title">2.4.1. <tt>shared_ptr</tt> Summary</h4>
<p class="docText"><a name="iddle1577"></a><a name="iddle1683"></a><a name="iddle1701"></a>The template's default constructor can create an object of type <tt>shared_ptr&lt;Ty&gt;</tt> from a pointer to <tt>Ty</tt> or to a type that is derived from <tt>Ty</tt>, from another <tt>shared_ptr</tt> object, from a <tt>weak_ptr</tt> object, and from an <tt>auto_ptr</tt> object. These constructors are discussed in more detail in <a class="docLink" href="#ch02lev2sec2">Section 2.4.2</a>.</P>
<p class="docText">The destructor for <tt>shared_ptr</tt> is discussed in <a class="docLink" href="#ch02lev2sec3">Section 2.4.3</a>.</P>
<p class="docText">You can get to the controlled resource with <tt>operator-&gt;</tt> and with <tt>operator*</tt>. You can get a pointer to the controlled resource with the member function <tt>get</tt>. These functions are discussed in <a class="docLink" href="#ch02lev2sec4">Section 2.4.4</a>.</P>
<p class="docText">A conversion operator tells you whether a <tt>shared_ptr</tt> object is empty. You can get the value of the reference count with the member function <tt>use_count</tt>, and you can check whether any other <tt>shared_ptr</tt> objects point to the same controlled resource with the member function <tt>unique</tt>. These functions are discussed in <a class="docLink" href="#ch02lev2sec5">Section 2.4.5</a>.</P>
<p class="docText">You can change a <tt>shared_ptr</tt> object so that it is empty or so that it controls a different resource. This is done with <tt>operator=</tt>, discussed in <a class="docLink" href="#ch02lev2sec6">Section 2.4.6</a>, or with the <tt>reset</tt> and <tt>swap</tt> member functions or the <tt>swap</tt> function template, discussed in <a class="docLink" href="#ch02lev2sec7">Section 2.4.7</a>.</p>
<p class="docText">Destruction of the controlled resource and the use of deleter objects are discussed in <a class="docLink" href="ch02lev1sec9.html#ch02lev1sec9">Section 2.9</a>.</P>
<p class="docText">The implementation is allowed to throw exceptions when control of a newly created resource is assigned to a <tt>shared_ptr</tt> object.<sup class="docFootnote"><a class="docLink" href="#ch02fn03">[3]</a></sup> The effects of such an exception are discussed in <a class="docLink" href="ch02lev1sec10.html#ch02lev1sec10">Section 2.10</a>.</p><blockquote><p class="docFootnote"><sup><a name="ch02fn03">[3]</a></sup> This typically happens when not enough memory is available to create a manager object to track the original pointer and its reference count.</P></blockquote>
<p class="docText">Several non-member templates can be used with <tt>shared_ptr</tt> objects. Tests for equality and inequality, as well as ordering, are discussed in <a class="docLink" href="#ch02lev2sec8">Section 2.4.8</a>. The stream inserter for <tt>shared_ptr</tt> objects is discussed in <a class="docLink" href="#ch02lev2sec9">Section 2.4.9</a>. The function template <tt>get_deleter</tt> is discussed in <a class="docLink" href="#ch02lev2sec10">Section 2.4.10</a>. Explicit type conversions are discussed in <a class="docLink" href="ch02lev1sec8.html#ch02lev2sec23">Section 2.8.3</a>.</P>

<a name="ch02lev2sec2"></a>

<h4 id="title-IDAO3EK" class="docSection2Title">2.4.2. Constructing a <tt>shared_ptr</tt> Object</H4>
<div class="docText"><pre>shared_ptr::<span class="docEmphasis">shared_ptr</span> ()
</pre></div><BR>
<p class="docText">The default constructor constructs an empty <tt>shared_ptr</tt> object.</p>
<a name="ch02ex01"></a><h5 id="title-IDAJ4EK" class="docExampleTitle">Example 2.1. Default Constructor for <tt>shared_ptr</tt> (<tt>smartptr/defcon.cpp</tt>)</h5><p><table cellspacing="0" width="90%" border="1" cellpadding="5"><TR><td>



<pre>#include &lt;memory&gt;
#include "sputil.h"
using std::tr1::shared_ptr;

int main()
  {
  shared_ptr&lt;int&gt; sp;           <span class="docEmphasis">// default constructor</span>
  show("default constructor", sp);
  return 0;
  }
</pre><br>

</TD></TR></table></P>
<div class="docText"><pre>template&lt;class Other&gt;
  explicit shared_ptr::<span class="docEmphasis">shared_ptr</span>(Other *ptr)
template&lt;class Other, class D&gt;
  shared_ptr::<span class="docEmphasis">shared_ptr</span>(Other *ptr, D dtor)
</pre></div><br>
<blockquote>
<p class="docText">The constructors assign control (<a class="docLink" href="ch02lev1sec1.html#ch02lev1sec1">Section 2.1</a>) of their arguments to the newly constructed <tt>shared_ptr</tt> object.</p>
</blockquote>
<p class="docText">When you construct a <tt>shared_ptr</tt> object with a pointer that isn't null, you construct a <tt>shared_ptr</tt> object that owns the resource that the pointer points to.</P>
<a name="ch02ex02"></a><h5 id="title-IDAHAFK" class="docExampleTitle">Example 2.2. Construct from a Resource Pointer (<tt>smartptr/ptrcon.cpp</tt>)</h5><p><table cellspacing="0" width="90%" border="1" cellpadding="5"><tr><td>



<pre>#include &lt;ostream&gt;
#include &lt;memory&gt;
#include "sputil.h"
using std::tr1::shared_ptr;

int main()
  {
  shared_ptr&lt;resource&gt; sp(new resource(3));
  show("construct from pointer", sp);
  return 0;
  }
</pre><br>

</td></tr></table></p>
<p class="docText">You can also construct a <tt>shared_ptr</tt> object from a pointer to a resource and a deleter object; when the last <tt>shared_ptr</tt> object that owns that resource releases control, the deleter object's <tt>operator()</tt> will be called with the resource pointer as its argument. For more details, see <a class="docLink" href="ch02lev1sec9.html#ch02lev1sec9">Section 2.9</a>.</p>
<a name="ch02ex03"></a><h5 id="title-IDALBFK" class="docExampleTitle">Example 2.3. Construct with a Deleter (<tt>smartptr/dtrcon.cpp</tt>)</h5><P><table cellspacing="0" width="90%" border="1" cellpadding="5"><tr><TD>



<pre>#include &lt;iostream&gt;
#include &lt;ostream&gt;
#include &lt;memory&gt;
#include "sputil.h"
using std::tr1::shared_ptr;
using std::cout;

struct deleter
  {
  void operator()(resource *res)
    {
    cout &lt;&lt; "destroying resource at"
         &lt;&lt; (void*)res &lt;&lt; '\n';
    delete res;
    }
  };

int main()
  {
  shared_ptr&lt;resource&gt; sp(new resource(3), deleter());
  show("construct from pointer", sp);
  return 0;
  }
</pre><br>

</td></tr></table></P>
<p class="docText">These constructors can be called with a null pointer. This creates a slightly peculiar object; it technically isn't an empty <tt>shared_ptr</tt> object, even though it doesn't own any resources. See <a class="docLink" href="#ch02lev2sec8">Section 2.4.8</a> for a discussion of how this affects comparison operators.</P>
<a name="ch02ex04"></a><h5 id="title-IDALCFK" class="docExampleTitle">Example 2.4. Construct from a Null Pointer (<tt>smartptr/nullptrcon.cpp</tt>)</H5><p><table cellspacing="0" width="90%" border="1" cellpadding="5"><TR><TD>



<pre>#include &lt;ostream&gt;
#include &lt;memory&gt;
#include "sputil.h"
using std::tr1::shared_ptr;

int main()
  {
  shared_ptr&lt;resource&gt; sp((resource*)0);
  show("construct from null pointer", sp);
  return 0;
  }
</pre><BR>

</TD></tr></table></P>
<div class="docText"><pre>shared_ptr::<span class="docEmphasis">shared_ptr</span>(const shared_ptr &amp; sp)
template&lt;class Other&gt;
  shared_ptr::<span class="docEmphasis">shared_ptr</span>(const shared_ptr &lt;Other&gt;&amp; sp)
</pre></div><br>
<blockquote>
<p class="docText">The constructors assign control (<a class="docLink" href="ch02lev1sec1.html#ch02lev1sec1">Section 2.1</a>) of their arguments to the newly constructed <tt>shared_ptr</tt> object.</P>
</blockquote>
<p class="docText">Don't use the same pointer to create two <tt>shared_ptr</tt> objects; if you do, the destructor for the controlled resource will be called twice when the <tt>shared_ptr</tt> objects are destroyed. Instead, copy the first <tt>shared_ptr</tt> object to create a second <tt>shared_ptr</tt> object that controls the resource.</P>
<a name="ch02ex05"></a><h5 id="title-IDAFEFK" class="docExampleTitle">Example 2.5. Copy a <tt>shared_ptr</tt> Object (<tt>smartptr/spcon.cpp</tt>)</H5><P><table cellspacing="0" width="90%" border="1" cellpadding="5"><tr><td>



<pre>#include &lt;memory&gt;
#include "sputil.h"
using std::tr1::shared_ptr;

int main()
  {
  shared_ptr&lt;resource&gt; sp0(new resource(4));
                                   <span class="docEmphasis">// sp0 holds pointer to resource</span>
  show("construct from pointer", sp0);
  shared_ptr&lt;resource&gt; sp1(sp0); <span class="docEmphasis">// sp1 manages same object</span>
                                   <span class="docEmphasis">// as sp0</span>
  show("construct from shared_ptr object", sp1);
  show("after copying", sp0);
  return 0;
  }   <span class="docEmphasis">// sp1 destroyed, then sp0 destroyed</span>
</pre><br>

</td></TR></table></p>
<div class="docText"><pre>template&lt;class Other&gt;
  shared_ptr::<span class="docEmphasis">shared_ptr</span>(const weak_ptr&lt;Other&gt;&amp; wp)
</pre></div><br>
<blockquote>
<p class="docText"><a name="iddle1077"></a><a name="iddle1687"></a>The constructors assign control (<a class="docLink" href="ch02lev1sec1.html#ch02lev1sec1">Section 2.1</a>) of their arguments to the newly constructed <tt>shared_ptr</tt> object.</P>
</blockquote>
<p class="docText">We'll look at constructing <tt>shared_ptr</tt> objects from <tt>weak_ptr</tt> objects when we talk about the <tt>weak_ptr</tt> template in <a class="docLink" href="ch02lev1sec5.html#ch02lev2sec14">Section 2.5.4</a>.</P>
<div class="docText"><pre>template&lt;class Other&gt;
  shared_ptr::<span class="docEmphasis">shared_ptr</span>(const std::auto_ptr&lt;Other&gt;&amp; sp)
</pre></div><BR>
<blockquote>
<p class="docText">The constructors assign control (<a class="docLink" href="ch02lev1sec1.html#ch02lev1sec1">Section 2.1</a>) of their arguments to the newly constructed <tt>shared_ptr</tt> object.</p>
</blockquote>
<p class="docText">Finally, the <tt>shared_ptr</tt> template has a constructor that takes an object of type <tt>std::auto_ptr&lt;Other&gt;</tt>. If the constructor succeeds, it calls <tt>release()</tt> on its argument, so the <tt>auto_ptr</tt> object no longer controls the resource. If the constructor failstypically by failing to allocate memoryit doesn't change the <tt>auto_ptr</tt> object.</p>
<a name="ch02ex06"></a><H5 id="title-IDADIFK" class="docExampleTitle">Example 2.6. Construct from an <tt>auto_ptr</tt> Object (<tt>smartptr/apcon.cpp</tt>)</h5><p><table cellspacing="0" width="90%" border="1" cellpadding="5"><tr><td>



<pre>#include &lt;memory&gt;
#include "sputil.h"
using std::tr1::shared_ptr ; using std :: auto_ptr;

int main()
  {
  auto_ptr &lt;resource&gt; ap(new resource (5));
  show ("construct auto_ptr from pointer", ap);
  shared_ptr &lt;resource&gt; sp(ap);
  show ("auto_ptr", ap);
  show ("shared_ptr", sp);
  return 0;
  }
</pre><br>

</td></tr></table></p>

<a name="ch02lev2sec3"></a>
<h4 id="title-IDAXIFK" class="docSection2Title">2.4.3. Destroying a <tt>shared_ptr</tt> Object</h4>
<div class="docText"><pre>shared_ptr::<span class="docEmphasis">~shared_ptr</span>();
</pre></div><br>
<blockquote>
<p class="docText"><a name="iddle1690"></a><a name="iddle1694"></a>The destructor releases the controlled resource.</p>
</blockquote>
<p class="docText">See <a class="docLink" href="ch02lev1sec9.html#ch02lev1sec9">Section 2.9</a> for details.</P>

<a name="ch02lev2sec4"></a>
<h4 id="title-IDAQKFK" class="docSection2Title">2.4.4. Accessing the Controlled Resource</H4>
<div class="docText"><pre>Ty *shared_ptr::<span class="docEmphasis">get</span>() const;
</pre></div><br>
<blockquote>
<p class="docText">The member function returns a pointer to the controlled resource.</p>
</blockquote>
<a name="ch02ex07"></a><h5 id="title-IDAJLFK" class="docExampleTitle">Example 2.7. <tt>shared_ptr::get</tt> (<tt>smartptr/get.cpp</tt>)</H5><P><table cellspacing="0" width="90%" border="1" cellpadding="5"><tr><TD>



<pre>#include &lt;memory&gt;
#include &lt;iostream&gt;
using std::tr1::shared_ptr;
using std::cout;

int main()
  { <span class="docEmphasis">// demonstrate use of get</span>
  int *ip = new int(3);                   <span class="docEmphasis">// allocate int resource</span>
  cout &lt;&lt; (void*)ip &gt;&gt; '\n';              <span class="docEmphasis">// show address</span>
  shared_ptr&lt;int&gt; sp(ip);                 <span class="docEmphasis">// create shared_ptr object</span>
  cout &lt;&lt; (void*)sp.get () &gt;&gt; '\n';       <span class="docEmphasis">// show stored address</span>
  return 0;
  }
</pre><br>

</TD></TR></table></P>
<div class="docText"><pre>Ty&amp; shared_ptr::<span class="docEmphasis">operator*</span>() const;
</pre></div><BR>
<blockquote>
<p class="docText">The member function returns a reference to the controlled resource. If the object does not control any resource (<tt>get() == 0</tt>), the behavior is undefined.</p>
</blockquote>
<a name="ch02ex08"></a><H5 id="title-IDA1MFK" class="docExampleTitle">Example 2.8. <tt>shared_ptr::operator*</tt> (<tt>smartptr/opstar.cpp</tt>)</h5><P><table cellspacing="0" width="90%" border="1" cellpadding="5"><TR><td>



<pre>#include &lt;memory&gt;
#include &lt;iostream&gt;
using std::tr1::shared_ptr;
using std::cout;

int main()
  { <span class="docEmphasis">// demonstrate use of operator*</span>

  int *ip = new int(3);               <span class="docEmphasis">// allocate int resource</span>
  cout &lt;&lt; (void*)ip &gt;&gt; '\n';          <span class="docEmphasis">// show address</span>
  shared_ptr&lt;int&gt; sp(ip);             <span class="docEmphasis">// create shared_ptr object</span>
  cout &lt;&lt; *sp &gt;&gt; '\n';                <span class="docEmphasis">// show stored value</span>
  cout &lt;&lt; (void*)&amp;*sp &lt;&lt; '\n';        <span class="docEmphasis">// show address of stored value</span>
  return 0;
  }
</pre><BR>

</TD></tr></table></p>
<div class="docText"><pre>Ty *shared_ptr::<span class="docEmphasis">operator-&gt;</span>() const;
</pre></div><br>
<blockquote>
<p class="docText"><a name="iddle1695"></a>The selection operator returns <tt>get()</tt>, so the expression <tt>sp-&gt;member</tt> behaves the same as <tt>(sp.get())-&gt;member</tt>, where <tt>sp</tt> is an object of class <tt>shared_ptr&lt;Ty&gt;</tt>. Hence, the stored pointer must not be null, and <tt>Ty</tt> must be a class, structure, or union type with a member <tt>member</tt>.</p>
</blockquote>
<a name="ch02ex09"></a><H5 id="title-IDADPFK" class="docExampleTitle">Example 2.9. <tt>shared_ptr::operator</tt>-&gt; (<tt>smartptr/oparrow.cpp</tt>)</h5><p><table cellspacing="0" width="90%" border="1" cellpadding="5"><TR><TD>



<pre>#include &lt;memory&gt;
#include &lt;iostream&gt;
using std::tr1::shared_ptr;
using std::cout;

struct S
  {
  int member;
  };

int main()
  { <span class="docEmphasis">// demonstrate use of operator-&gt;</span>
  S *s = new S;                            <span class="docEmphasis">// create object</span>
  s-&gt;member = 4;                           <span class="docEmphasis">// assign to member</span>
  shared_ptr&lt;S&gt; sp(s);                     <span class="docEmphasis">// create shared_ptr object</span>
  cout &lt;&lt; sp -&gt; member &lt;&lt; '\n';            <span class="docEmphasis">// show value of member</span>
  return 0;
  }
</pre><BR>

</td></tr></table></P>

<a name="ch02lev2sec5"></a>

<h4 id="title-IDAGQFK" class="docSection2Title">2.4.5. Querying a <tt>shared_ptr</tt> Object's State</h4>
<div class="docText"><pre>operator shared_ptr::<span class="docEmphasis">operator boolean-type</span>() const;
</pre></div><br>
<blockquote>
<p class="docText"><a name="iddle1692"></a>The conversion operator returns an object of an unspecified type that is convertible to <tt>bool</tt>. The resulting value is <tt>false</tt> if the object does not control a resource (<tt>get() == 0</tt>); otherwise, it is <tt>true</tt>.</p>
</blockquote>
<p class="docText">Objects of <tt>shared_ptr</tt> types can be used in contexts that require a Boolean value. This conversion operator provides the usual pointer semantics: A value of <tt>false</tt> means that the <tt>shared_ptr</tt> object does not point to an actual resource, and a value of <tt>true</tt> means that it does.</p>
<a name="ch02ex10"></a><h5 id="title-IDA4RFK" class="docExampleTitle">Example 2.10. Conversion Operator (<tt>smartptr/boolconv.cpp</tt>)</h5><p><table cellspacing="0" width="90%" border="1" cellpadding="5"><tr><td>



<pre>#include &lt;memory&gt;
#include &lt;iostream&gt;
#include &lt;string&gt;
using std::tr1::shared_ptr;
using std::cout;
using std::string;

typedef shared_ptr&lt;string&gt; stp;

void show(stp s)
  { <span class="docEmphasis">// show contents of target string</span>
  if (s)
    cout &lt;&lt; "string holds '" &lt;&lt; *s &lt;&lt; " '\n";
  else
    cout &lt;&lt; "string is empty \n";
  }

int main()
  { <span class="docEmphasis">// demonstrate conversion operator</span>
  stp s;
  show(s);
  s.reset(new string("Hello, world"));
  show(s);
  return 0;
  }
</pre><BR>

</td></TR></table></p>
<blockquote>
<p class="docText">The type returned by the conversion operator is up to the implementation.</p>
</blockquote>
<p class="docText"><a name="iddle1706"></a><a name="iddle1707"></a>Converting directly to <tt>bool</tt> can lead to problems because the resulting value can, in turn, be converted to a numeric value, so that an expresion like <tt>sp + 1</tt>, although an error, will compile and produce a value. Similarly, converting to <tt>void*</tt> leads to problems if someone writes <tt>delete sp</tt>. The TR1 specification recommends returning a pointer to member function, since you can do very few things accidentally with such a returned object.</p>
<div class="docText"><pre>long shared_ptr::<span class="docEmphasis">use_count</span>() const;
</pre></div><BR>
<blockquote>
<p class="docText">The member function returns the number of <tt>shared_ptr</tt> objects that own the resource controlled by <tt>*this</tt>. For an empty <tt>shared_ptr</tt> object, returns 0.</P>
</blockquote>
<a name="ch02ex11"></a><h5 id="title-IDANUFK" class="docExampleTitle">Example 2.11. <tt>shared_ptr::use_count</tt> (<tt>smartptr/spcount.cpp</tt>)</H5><p><table cellspacing="0" width="90%" border="1" cellpadding="5"><TR><TD>



<pre>#include &lt;memory&gt;
#include &lt;iostream&gt;
using std::tr1::shared_ptr;
using std::cout;

typedef shared_ptr&lt;int&gt; spi;

int main()
  { <span class="docEmphasis">// demonstrate member function use_count</span>
  spi sp0 ;                          <span class="docEmphasis">// empty object</span>
  cout &lt;&lt; "empty object: " &lt;&lt; sp0.use_count() &lt;&lt; '\n';
  spi sp1 ((int *)0);               <span class="docEmphasis">// no resource</span>
  cout &lt;&lt; "null pointer: " &lt;&lt; sp1.use_count() &lt;&lt; '\n';
  spi sp2 (new int);                <span class="docEmphasis">// controls resource</span>
  cout &lt;&lt; "one object: " &lt;&lt; sp2.use_count() &lt;&lt; '\n';
  { <span class="docEmphasis">// create short-lived object</span>
  spi sp3(sp2);                     <span class="docEmphasis">// copy</span>
  cout &lt;&lt; "two objects: " &lt;&lt; sp2.use_count() &lt;&lt; '\n';
  } <span class="docEmphasis">// sp3 destroyed</span>
  cout &lt;&lt; "one object: " &lt;&lt; sp2.use_count() &lt;&lt; '\n';
  return 0;
  }
</pre><BR>

</TD></tr></table></P>
<div class="docText"><pre>bool shared_ptr :: <span class="docEmphasis">unique</span> () const;
</pre></div><br>
<blockquote>
<p class="docText"><a name="iddle1699"></a>The member function returns <tt>TRue</tt> if no other <tt>shared_ptr</tt> object owns the resource that is owned by <tt>*this</tt>; otherwise, <tt>false</tt>.</P>
</blockquote>
<a name="ch02ex12"></a><h5 id="title-IDAQWFK" class="docExampleTitle">Example 2.12. <tt>shared_ptr::unique</tt> (<tt>smartptr/unique.cpp</tt>)</H5><P><table cellspacing="0" width="90%" border="1" cellpadding="5"><tr><td>



<pre>#include &lt;memory&gt;
#include &lt;iomanip&gt;
#include &lt;iostream&gt;
using std::tr1::shared_ptr;
using std::cout; using std::boolalpha;
typedef shared_ptr&lt;int&gt; spi;

int main()
  { <span class="docEmphasis">// demonstrate member function unique</span>
  cout &lt;&lt; boolalpha;
  spi sp0;                          <span class="docEmphasis">// empty object</span>
  cout &lt;&lt; "empty object: " &lt;&lt; sp0.unique() &lt;&lt; '\n';
  spi sp1((int *)0);                <span class="docEmphasis">// no resource</span>
  cout &lt;&lt; "null pointer: " &lt;&lt; sp1.unique() &lt;&lt; '\n';
  spi sp2(new int);                 <span class="docEmphasis">// controls resource</span>
  cout &lt;&lt; "one object: " &lt;&lt; sp2.unique() &lt;&lt; '\n';
  { <span class="docEmphasis">// create short-lived object</span>
  spi sp3(sp2);                     <span class="docEmphasis">// copy</span>
  cout &lt;&lt; "two objects: " &lt;&lt; sp2.unique() &lt;&lt; '\n';
  } <span class="docEmphasis">// sp3 destroyed</span>
  cout &lt;&lt; "one object: " &lt;&lt; sp2.unique() &lt;&lt; '\n';
  return 0;
  }
</pre><br>

</td></TR></table></p>

<a name="ch02lev2sec6"></a>
<h4 id="title-IDARXFK" class="docSection2Title">2.4.6. Assign to a <tt>shared_ptr</tt> Object</H4>
<div class="docText"><pre>shared_ptr&amp; shared_ptr::<span class="docEmphasis">operator=</span> (
  const shared_ptr&amp; sp);
template&lt;class Other&gt;
  shared_ptr&amp; shared_ptr::<span class="docEmphasis">operator=</span>(
    const shared_ptr&lt;Other&gt;&amp; sp);
template&lt;class Other&gt;
  shared_ptr&amp; shared_ptr::<span class="docEmphasis">operator=</span>(
    auto_ptr&lt;Other&gt;&amp; ap);
</pre></div><BR>
<blockquote>
<p class="docText">Each of these operators releases the resource controlled by <tt>*this</tt>, if any, and assigns control (<a class="docLink" href="ch02lev1sec1.html#ch02lev1sec1">Section 2.1</a>) of the resource on the right-hand side of the assignment to <tt>*this</tt>.</P>
</blockquote>
<a name="ch02ex13"></a><h5 id="title-IDAAZFK" class="docExampleTitle">Example 2.13. Assign to a <tt>shared_ptr</tt> Object (<tt>smartptr/asgn.cpp</tt>)</h5><P><table cellspacing="0" width="90%" border="1" cellpadding="5"><tr><td>



<pre>#include &lt;memory&gt;
#include &lt;iostream&gt;
#include "sputil.h"
using std::tr1::shared_ptr; using std::auto_ptr;

typedef shared_ptr&lt;resource&gt; sps;
typedef auto_ptr&lt;resource&gt; aps;

static void asgn0()
  { <span class="docEmphasis">// assign shared_ptr object to shared_ptr object</span>
  sps sp0(new resource(1));                  <span class="docEmphasis">// allocate resource</span>
  show("construct sp0", sp0);
  sps sp1(new resource(2));                  <span class="docEmphasis">// allocate resource</span>
  show(" construct sp1", sp1);
  sp1 = sp0 ;                                 <span class="docEmphasis">// assign, deallocate resource</span>
  show("assign, sp0", sp0);
  show("assign, sp1", sp1);
  }

static void asgn1 ()
  { <span class="docEmphasis">// assign auto_ptr object to shared_ptr object</span>
  sps sp2(new resource(3));                   <span class="docEmphasis">// allocate resource</span>
  show("construct sp2", sp2);
  aps ap0(new resource(4));                   <span class="docEmphasis">// allocate resource</span>
  show("construct ap0", ap0);
  sp2 = ap0 ;                                 <span class="docEmphasis">// assign, deallocate resource</span>
  show("assign, ap0", ap0);
  show("assign, sp2", sp2);
  }

int main()
  { <span class="docEmphasis">// demonstrate effects of assignment</span>
  asgn0();
  asgn1();
  return 0;
  }
</pre><br>

</td></tr></table></p>

<a name="ch02lev2sec7"></a>

<h4 id="title-IDAJ0FK" class="docSection2Title">2.4.7. Modify a <tt>shared_ptr</tt> Object</h4>
<div class="docText"><pre>void shared_ptr::<span class="docEmphasis">reset</span>();
</pre></div><br>
<blockquote>
<p class="docText"><a name="iddle1703"></a>The member function releases control of the object's controlled resource. After the function returns, <tt>*this</tt> is empty.</p>
</blockquote>
<a name="ch02ex14"></a><h5 id="title-IDAQ1FK" class="docExampleTitle">Example 2.14. <tt>shared_ptr::reset()</tt> (<tt>smartptr/reset.cpp</tt>)</h5><P><table cellspacing="0" width="90%" border="1" cellpadding="5"><tr><TD>



<pre>#include &lt;memory&gt;
#include "sputil.h"
using std::tr1::shared_ptr;

int main()
  { <span class="docEmphasis">// demonstrate member function reset()</span>
  shared_ptr&lt;resource&gt; sp0;
  show("empty object before reset", sp0);
  sp0.reset();
  show("empty object after reset", sp0);
  shared_ptr&lt;resource&gt; sp1(new resource(1));
  show("non-empty object before reset", sp1);
  sp1.reset();
  show("non-empty object after reset", sp1);
  return 0;
  }
</pre><br>

</td></tr></table></P>
<div class="docText"><pre>template&lt;class Other&gt;
  void shared_ptr::<span class="docEmphasis">reset</span> (Other *ptr);
template&lt;class Other, class D&gt;
  void shared_ptr::<span class="docEmphasis">reset</span> (Other *ptr, D dtor);
</pre></div><BR>
<blockquote>
<p class="docText">The member functions release control of the object's controlled resource and assign control of the resource pointed to by <tt>ptr</tt> to the object.</p>
</blockquote>
<a name="ch02ex15"></a><H5 id="title-IDA22FK" class="docExampleTitle">Example 2.15. <tt>shared_ptr::reset</tt> (<tt>smartptr/resetptr.cpp</tt>)</h5><P><table cellspacing="0" width="90%" border="1" cellpadding="5"><TR><TD>



<pre>#include &lt;memory&gt;
#include "sputil.h"
using std::tr1::shared_ptr;

int main()
  { <span class="docEmphasis">// demonstrate member function reset</span>
  shared_ptr&lt;resource&gt; sp0;
  show("empty object before reset", sp0);
  sp0.reset (new resource(1));
  show("empty object after reset", sp0);
  sp0.reset(new resource(2));
  show("non-empty object after reset", sp0);
  return 0;
  }
</pre><BR>

</td></TR></table></p>
<div class="docText"><pre>void shared_ptr::<span class="docEmphasis">swap</span>(shared_ptr&amp; sp);
template&lt;class Ty&gt;
  void <span class="docEmphasis">swap</span>(shared_ptr&lt;Ty&gt;&amp; left, shared_ptr&lt;Ty&gt;&amp; right);
</pre></div><BR>
<blockquote>
<p class="docText"><a name="iddle1705"></a>The member function swaps the controlled resources between <tt>*this</tt> and <tt>sp</tt>. The function template calls <tt>left.swap(right)</tt>.</P>
</blockquote>
<a name="ch02ex16"></a><h5 id="title-IDAU4FK" class="docExampleTitle">Example 2.16. <tt>swap</tt> Functions (<tt>smartptr/swap.cpp</tt>)</H5><P><table cellspacing="0" width="90%" border="1" cellpadding="5"><tr><td>



<pre>#include &lt;memory&gt;
#include "sputil.h"
using std::tr1::shared_ptr;

int main()
  { <span class="docEmphasis">// demonstrate member function swap</span>
  shared_ptr&lt;resource&gt; sp0 (new resource(0));
  shared_ptr&lt;resource&gt; sp1 (new resource(1));
  show("sp0 before swap", sp0);
  show("sp1 before swap", sp1);
  sp0. swap (sp1);
  show("sp0 after swap", sp0);
  show("sp1 after swap", sp1);
  swap(sp0, sp1);
  show("sp0 after second swap", sp0);
  show("sp1 after second swap", sp1);
  return 0;
  }
</pre><br>

</td></TR></table></p>

<a name="ch02lev2sec8"></a>

<h4 id="title-IDAM5FK" class="docSection2Title">2.4.8. Comparing <tt>shared_ptr</tt> Objects</H4>
<p class="docText"><a name="iddle1693"></a><a name="iddle1696"></a><a name="iddle1700"></a>Two <tt>shared_ptr&lt;Ty&gt;</tt> objects can be compared for equality and for relative order.</P>
<div class="docText"><pre>template&lt;class Ty1, class Ty2&gt;
  bool <span class="docEmphasis">operator==</span>(
    const shared_ptr&lt;Ty1&gt;&amp; left,
    const shared_ptr&lt;Ty2&gt;&amp; right);
template&lt;class Ty1, class Ty2&gt;
  bool <span class="docEmphasis">operator!=</span>(
    const shared_ptr&lt;Ty1&gt;&amp; left,
    const shared_ptr&lt;Ty2&gt;&amp; right);
</pre></div><BR>
<blockquote>
<p class="docText">The first function returns <tt>left.get() == right.get()</tt>. The second function returns <tt>!(left == right)</tt>.</p>
</blockquote>
<a name="ch02ex17"></a><h5 id="title-IDARBGK" class="docExampleTitle">Example 2.17. Equality Comparisons (<tt>smartptr/spequal.cpp</tt>)</H5><p><table cellspacing="0" width="90%" border="1" cellpadding="5"><tr><td>



<pre>#include &lt;memory&gt;
#include &lt;iomanip&gt;
#include &lt;iostream&gt;
using std::tr1:: shared_ptr;
using std::cout; using std::boolalpha;

int main()
  {
  cout &lt;&lt; boolalpha;
  shared_ptr&lt;int&gt; sp0(new int(0));
  shared_ptr&lt;int&gt; sp1(sp0);
  shared_ptr&lt;int&gt; sp2(new int(2));
  cout &lt;&lt; "sp0 == sp1:" &lt;&lt; (sp0 == sp1) &lt;&lt; '\n';
  cout &lt;&lt; "sp0 == sp2:" &lt;&lt; (sp0 == sp2) &lt;&lt; '\n';
  cout &lt;&lt; "sp0 != sp1:" &lt;&lt; (sp0 != sp1) &lt;&lt; '\n';
  cout &lt;&lt; "sp0 != sp2:" &lt;&lt; (sp0 != sp2) &lt;&lt; '\n';
  return 0;
  }
</pre><br>

</td></tr></table></p>
<div class="docText"><pre>template&lt;class Ty1, class Ty2&gt;
  bool <span class="docEmphasis">operator&lt;</span>(
    const shared_ptr&lt;Ty1&gt;&amp; left,
    const shared_ptr&lt;Ty2&gt;&amp; right);
</pre></div><br>
<blockquote>
<p class="docText">The function defines a strict weak orderingas defined in <tt>[lib.alg. sorting]</tt> in the C++ standardon <tt>shared_ptr</tt> objects, with the additional constraint that <tt>!(left &lt; right) &amp;&amp; !(right &lt; left)</tt> is true only if <tt>left</tt> and <tt>right</tt> are both empty or both control the same resource.</p>
</blockquote>
<p class="docText">Because <tt>operator&lt;</tt> defines a strict weak ordering, you can use <tt>shared_ptr</tt> objects as keys in associative containers.</p>
<a name="ch02ex18"></a><h5 id="title-IDAIDGK" class="docExampleTitle">Example 2.18. Less-Than Comparison (<tt>smartptr/splt.cpp</tt>)</h5><P><table cellspacing="0" width="90%" border="1" cellpadding="5"><tr><TD>



<pre>#include &lt;algorithm&gt;
#include &lt;memory&gt;
#include &lt;iostream&gt;
#include &lt;set&gt;
using std::tr1::shared_ptr;
using std::lower_bound; using std::set;
using std::cout;

typedef shared_ptr&lt;int&gt; spi;
typedef set&lt;spi&gt; iset;
typedef iset::const_iterator citer;

static void lookup (const iset&amp; data, spi sp)
  { <span class="docEmphasis">// look for stored object that matches sp</span>
  citer res = lower_bound(data.begin(), data.end(), sp);
  cout &lt;&lt; *sp;
  if (res == data.end () || * res != sp)
    cout &lt;&lt; "not found \n";
  else
    cout &lt;&lt; "found\n";
  }

int main()
  { <span class="docEmphasis">// demonstrate less-than comparison</span>
  iset data;
  spi sp0(new int(0));
  spi sp1(new int(1));
  spi sp2(new int(2));
  spi sp3(sp1);           <span class="docEmphasis">// shares ownership with sp1</span>
  spi sp4(new int(1));    <span class="docEmphasis">// same value as sp1, but different resource</span>
  data.insert (sp0);
  data.insert (sp1);
  data.insert (sp2);
  lookup (data, sp1);    <span class="docEmphasis">// search for sp1</span>
  lookup (data, sp3);    <span class="docEmphasis">// search for sp3</span>
  lookup (data, sp4);    <span class="docEmphasis">// search for sp4</span>
  return 0;
  }
</pre><br>

</td></tr></table></P>
<p class="docText"><a name="iddle1697"></a><a name="iddle1702"></a>In this example, the call to <tt>lookup(data, sp1)</tt> succeeds because <tt>sp1</tt> is in the container.<sup class="docFootnote"><a class="docLink" href="#ch02fn04">[4]</a></sup> Similarly, the call to <tt>lookup(data, sp3)</tt> succeeds because <tt>sp3</tt> is a copy of <tt>sp1</tt>, so it owns the same resource as <tt>sp1</tt>. However, the call to <tt>lookup(data, sp4)</tt> fails;<tt>sp4</tt> owns a different resource, even though the two resources hold the same value.</P><blockquote><p class="docFootnote"><sup><a name="ch02fn04">[4]</a></sup> Actually, a copy of <tt>sp1</tt> is in the container; the copy owns the same resource as the original.</p></blockquote>
<a name="ch02lev3sec1"></a>
<H5 id="title-IDAVFGK" class="docSection3Title">Quirks: Empty Objects and Null Pointers</h5>
<p class="docText">As we've just seen, <tt>!(left &lt; right) &amp;&amp; !(right &lt; left)</tt> is true only if <tt>left</tt> and <tt>right</tt> are both empty or both control the same resource. Let's use that relation to define a new function template <tt>equiv</tt>, as follows:</P>
<div class="docText"><pre>template &lt;class Ty1, class Ty2&gt;
bool equiv(shared_ptr&lt;Ty1&gt; left, shared_ptr&lt;Ty2&gt; right)
  {
  return !(left &lt; right) &amp;&amp; !(right &lt; left);
  }
</pre></div><BR>
<p class="docText">That is, <tt>equiv</tt> returns <tt>TRue</tt> only if <tt>left</tt> and <tt>right</tt> are both empty or both control the same resource. As the name suggests, it is an equivalence relation; however, it's not the same equivalence relation as the one given by <tt>operator==</tt>. The member function <tt>shared_ptr::get()</tt> returns a null pointer when called on a <tt>shared_ptr&lt;Ty&gt;</tt> object that was constructed with the default constructor. It also returns a null pointer when called on a <tt>shared_ptr&lt;Ty&gt;</tt> object that was constructed with a null pointer, so an object constructed with the default constructor will compare equal to an object constructed with a null pointer. These two objects do not control the same resource, however, so a call to <tt>equiv</tt> with these two objects will return <tt>false</tt>. We'll look at this in more detail in one of the exercises.</P>


<a name="ch02lev2sec9"></a>
<h4 id="title-IDAKHGK" class="docSection2Title">2.4.9. Inserting <tt>shared_ptr</tt> Objects into Streams</H4>
<div class="docText"><pre>template&lt;class Elem, class Tr, class Ty&gt;
  std::basic_ostream&lt;Elem, Tr&gt;&amp; <span class="docEmphasis">operator&lt;&lt;</span>(
  std::basic_ostream&lt;Elem, Tr&gt;&amp; str,
  const shared_ptr&lt;Ty&gt;&amp; sp);
</pre></div><br>
<p class="docText"><a name="iddle1691"></a>The function inserts <tt>sp.get()</tt> into the stream <tt>str</tt>.</P>
<a name="ch02ex19"></a><H5 id="title-IDAVIGK" class="docExampleTitle">Example 2.19. Stream Inserter (<tt>smartptr/inserter.cpp</tt>)</h5><P><table cellspacing="0" width="90%" border="1" cellpadding="5"><TR><td>



<pre>#include &lt;memory&gt;
#include &lt;iostream&gt;
using std::tr1::shared_ptr;
using std::cout;

int main()
  { <span class="docEmphasis">// demonstrate stream inserter</span>
  shared_ptr&lt;int&gt; sp(new int);
  cout &lt;&lt; "   get: " &lt;&lt; sp.get() &lt; &lt; '\n';
  cout &lt;&lt; "object: " &lt;&lt; sp &lt;&lt; '\n';
  return 0;
  }
</pre><br>

</td></tr></table></P>
<p class="docText">If you have an object of type <tt>shared_ptr&lt;char&gt;</tt>, the stream inserter will insert the resulting pointer to <tt>char</tt>. Just aswitha <tt>char*</tt>, if the pointer doesn't point to a null-terminated byte string, the result is unpredictable.</p>

<a name="ch02lev2sec10"></a>
<h4 id="title-IDASJGK" class="docSection2Title">2.4.10. Function Template <tt>get_deleter</tt></H4>
<div class="docText"><pre>template&lt;class D, class Ty&gt;
  D *<span class="docEmphasis">get_deleter</span>(const shared_ptr&lt;Ty&gt;&amp; sp);
</pre></div><BR>
<blockquote>
<p class="docText">If the argument <tt>sp</tt> has a deleter of type <tt>D</tt>, the function template returns a pointer to that deleter object; otherwise, it returns a null pointer.</P>
</blockquote>
<a name="ch02ex20"></a><h5 id="title-IDAUKGK" class="docExampleTitle">Example 2.20. <tt>get_deleter</tt> (<tt>smartptr/getdeleter.cpp</tt>)</h5><P><table cellspacing="0" width="90%" border="1" cellpadding="5"><tr><td>



<pre>#include &lt;memory&gt;
#include &lt;iostream&gt;
using std::tr1::shared_ptr; using std::tr1::get_deleter;
using std::cout;

struct del
  { <span class="docEmphasis">// trivial deleter object</span>
  void operator ()(void *ptr)
    { <span class="docEmphasis">// simply delete</span>
    delete ptr;
    }
  };

int main()
  { <span class="docEmphasis">// demonstrate function function get_deleter</span>
  shared_ptr&lt;int&gt; sp0(new int);             <span class="docEmphasis">// no deleter</span>
  shared_ptr&lt;int&gt; sp1(new int, del());      <span class="docEmphasis">// has deleter</span>
  cout &lt;&lt; get_deleter &lt;del&gt;(sp0) &lt;&lt; '\n';
  cout &lt;&lt; get_deleter &lt;del&gt;(sp1) &lt;&lt; '\n';
  return 0;
  }
</pre><br>

</td></tr></table></p>


<a href="31031536.html"><img src="images/pixel.jpg" alt="" width="1" height="1" border="0"></a></TD></TR></table>
<br>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<tr><td><div STYLE="MARGIN-LEFT: 0.15in;">
<a href=ch02lev1sec3.html><img src="images/prev.gif" width="60" height="17" border="0" align="absmiddle" alt="Previous Page"></a>
<td align="right"><div STYLE="MARGIN-LEFT: 0.15in;">
<a href=ch02lev1sec5.html><img src="images/next.gif" width="60" height="17" border="0" align="absmiddle" alt="Next Page"></a>
</div></td></tr></table>
</body></html>