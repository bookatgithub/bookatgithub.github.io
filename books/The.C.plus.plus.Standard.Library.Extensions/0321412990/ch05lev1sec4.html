<html>
<META http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<head>
<title>Section 5.4.&nbsp; Requirements for Unordered Containers</title>
<link rel="STYLESHEET" type="text/css" href="images/style.css">
<link rel="STYLESHEET" type="text/css" href="images/docsafari.css">
</head>
<body>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<tr><td><div STYLE="MARGIN-LEFT: 0.15in;">
<a href=ch05lev1sec3.html><img src="images/prev.gif" width="60" height="17" border="0" align="absmiddle" alt="Previous Page"></a>
<td align="right"><div STYLE="MARGIN-LEFT: 0.15in;">
<a href=ch05lev1sec5.html><img src="images/next.gif" width="60" height="17" border="0" align="absmiddle" alt="Next Page"></a>
</div></td></tr></table>
<br><table width="100%" border="0" cellspacing="0" cellpadding="0"><tr><td valign="top"><a name="ch05lev1sec4"></a>
<h3 id="title-IDACOBWC" class="docSection1Title">5.4. Requirements for Unordered Containers</H3>
<a name="ch05lev2sec1"></a>
<H4 id="title-IDALOBWC" class="docSection2Title">5.4.1. Container Requirements</h4>
<p class="docText">According to the definition in the C++ standard, a <span class="docEmphasis">container</span> must support the requirements set out in this section.</P>
<p class="docText">A container type <tt>X</tt> must provide the following nested type names:</p>
<UL><LI><p class="docList"><tt>X::value_type:</tt> the type of the objects held in the container.</P></LI><li><p class="docList"><tt>X::reference:</tt> the type of an lvalue of <tt>X::value_type</tt>.</P></li><LI><p class="docList"><tt>X::const_reference:</tt> the type of a const lvalue of <tt>X::value_type</tt>.</P></li><LI><p class="docList"><tt>X::const_iterator:</tt> a constant iterator type whose value type is <tt>X::value_type</tt>. It can belong to any iterator category except output iterator.</P></li><li><p class="docList"><tt>X::iterator:</tt> an iterator type whose value type is <tt>X::value_type</tt>. It can belong to any iterator category except output iterator, and objects of type <tt>X::iterator</tt> must be convertible to type <tt>X::const_iterator</tt>.</p></li><LI><p class="docList"><tt>X::difference_type:</tt> the same type as <tt>iterator_traits&lt;X::iterator&gt;::difference_type</tt>.</p></li><LI><p class="docList"><tt>X::size_type:</tt> an unsigned integer type that can represent any non-negative value of <tt>X::difference_type</tt>.</P></LI></ul>                                       
<p class="docText">The following expressions must be valid and must have the given meaning. Here, <tt>a</tt> and <tt>b</tt> are objects of type <tt>X</tt>, and <tt>r</tt> has type <tt>X&amp;</tt>.</p>
<UL><li><p class="docList"><tt>X();X u;</tt>: constructs an object with an empty controlled sequence.</p></li><li><p class="docList"><tt>X(a);X u(a); X u = a;</tt>: constructs an object that is a copy of <tt>a</tt>.</p></li><li><p class="docList"><tt>(&amp;a)-&gt; X();</tt>: the destructor destroys each object in the controlled <a name="iddle1170"></a><a name="iddle1852"></a>sequence and frees any memory allocated by <tt>a</tt>.</p></li><li><p class="docList"><tt>a.begin(); a.end();</tt>:for a <tt>const</tt> object <tt>a</tt>, returns an iterator object of type <tt>X::const_iterator</tt>; otherwise, returns an iterator object of type <tt>X::iterator</tt>. The range <tt>[a.begin(), a.end())</tt> consists of iterators that point at each of the objects in <tt>a</tt>.</p></li><LI><p class="docList"><tt>a.swap(b);</tt>: swaps the contents of <tt>a</tt> and <tt>b</tt>.</p></LI><li><p class="docList"><tt>r=a;</tt>: the function returns <tt>X&amp;</tt>, replacing <tt>r</tt>'s controlled sequence with a copy of <tt>b</tt>'s controlled sequence.</p></li><LI><p class="docList"><tt>a.size();</tt>: returns a value of type <tt>X::size_type</tt> that holds the number of objects in <tt>a</tt>'s controlled sequence.</P></li><LI><p class="docList"><tt>a.max_size();</tt>: returns a value of type <tt>X::size_type</tt> that holds the largest possible number of elements in a container of type <tt>X</tt>.</p></LI><LI><p class="docList"><tt>a.empty();</tt>: returns a value of type <tt>bool</tt> that holds the value of <tt>a.size() == 0</tt>.</P><p class="docList">The following expressions must be valid and must have the given meaning:</P></li><LI><p class="docList"><tt>a==b</tt>: returns a value that is convertible to <tt>bool</tt>, with the value <tt>true</tt> only if <tt>a.size() == b.size()</tt> and <tt>std::equal(a.begin(), a.end(), b.begin())</tt>.</P></LI><li><p class="docList"><tt>a != b</tt>: returns a value that is convertible to <tt>bool</tt> and holds the value <tt>!(a == b)</tt>.</P></LI><li><p class="docList"><tt>a &lt; b</tt>: returns a value convertible to <tt>bool</tt> and holds the value returned by the call <tt>std::lexicographical_compare(a.begin(), a.end(), b.begin(), b.end())</tt>. If this expression is used, then for two objects <tt>c</tt> and <tt>d</tt> of type <tt>X::value_type</tt>, the expression <tt>c&lt;d</tt> must be defined and must be a total ordering relationship.</p></li><li><p class="docList"><tt>a&gt;b</tt>: returns a value that is convertible to <tt>bool</tt> and holds the value <tt>b &lt; a</tt>.</P></li><li><p class="docList"><tt>a&lt;=b</tt>: returns a value that is convertible to <tt>bool</tt> and holds the value <tt>!(a&gt;b)</tt>.</P></LI><LI><p class="docList"><tt>a&gt;=b</tt>: returns a value that is convertible to <tt>bool</tt> and holds the value <tt>!(a&lt;b)</tt>.</p></li></UL>                                       
                                            
<a name="ch05lev2sec2"></a>
<h4 id="title-IDAGXBWC" class="docSection2Title">5.4.2. Unordered Container Requirements</h4>
<p class="docText">According to the definition in TR1, an <span class="docEmphasis">unordered associative container</span> must meet all the requirements for a container, as described in <a class="docLink" href="#ch05lev2sec1">Section 5.4.1</a>, except <a name="iddle1854"></a><a name="iddle1855"></a>for the equality and inequality operations at the end. In addition, unordered associative containers must meet the requirements in this section.</p>
<p class="docText">Unordered associative containers must provide the following nested type names:</p>
<ul><li><p class="docList"><tt>key_type</tt>: the type of the container's keys.</p></li><li><p class="docList"><tt>key_equal</tt>: the type of the object used to compare keys for equality.</p></li><li><p class="docList"><tt>hasher</tt>: the type used to produce hash values.</P></li><LI><p class="docList"><tt>local_iterator</tt>: an iterator type used to iterate within a bucket. The members of <tt>iterator_traits&lt;local_iterator&gt;</tt> must name the same types as the members of <tt>iterator</tt>.</p></li><li><p class="docList"><tt>const_ local_iterator</tt>: an iterator type used to iterate within a bucket. The members of <tt>iterator_traits&lt;const_local_iterator&gt;</tt> must name the same types as the members of <tt>const_iterator</tt>.</P></LI></ul>                                       
<p class="docText">In the following lists, <tt>X</tt> is an unordered associative container type, <tt>a</tt> is an object of type <tt>X</tt>, <tt>b</tt> is an object of type <tt>X</tt> or <tt>const X</tt>, <tt>first</tt> and <tt>last</tt> are input iterators that point at objects of type <tt>X::value_type</tt> and <tt>[first, last)</tt> is a valid range, <tt>hf</tt> is an object of type <tt>X::hasher</tt> or <tt>const X::hasher</tt>, <tt>eq</tt> is an object of type <tt>X::key_equal</tt> or <tt>const X::key_equal</tt>, and <tt>n</tt> is a value of type <tt>X::size_type</tt>.</P>
<p class="docText">Unordered associative containers provide constructors that support the following code constructs.</p>
<UL><LI><p class="docList"><tt>X(n, hf, eq); X a(n, hf, eq);</tt> constructs an object with at least <tt>n</tt> buckets, holding no objects. The container will use a copy of <tt>hf</tt> to compute hash values and a copy of <tt>eq</tt> to compare keys. Its time complexity is <span class="docEmphasis">O</span>(<span class="docEmphasis">n</span>).</P></LI><li><p class="docList"><tt>X(n, hf); X a(n, hf);</tt> constructs an object with at least <tt>n</tt> buckets, holding no objects. The container will use a copy of <tt>hf</tt> to compute hash values and <tt>key_equal()</tt> to compare keys. Its time complexity is <span class="docEmphasis">O</span>(<span class="docEmphasis">n</span>).</P></li><LI><p class="docList"><tt>X(n); X a(n);</tt> constructs an object with at least <tt>n</tt> buckets, holding no objects. The container will use <tt>hasher()</tt> to compute hash values and <tt>key_equal()</tt> to compare keys. Its time complexity is <span class="docEmphasis">O</span>(<span class="docEmphasis">n</span>).</P></li><LI><p class="docList"><tt>X(); X a;</tt> constructs an object with an unspecified number of buckets, holding no objects. The container will use <tt>hasher()</tt> to compute hash values and <tt>key_equal()</tt> to compare keys. Its time complexity is <span class="docEmphasis">O</span>(1).</P></li><li><p class="docList"><tt>X(first, last, n, hf, eq); X a(first, last, n, hf, eq);</tt> constructs an object with at least <tt>n</tt> buckets, holding no objects, then inserts the objects in the range <tt>[first, last)</tt> into the container. The container will use a copy of <tt>hf</tt> to compute hash values and a copy of <tt>eq</tt> to compare keys. Its average time complexity is <span class="docEmphasis">O</span>(<span class="docEmphasis">N</span>), where <span class="docEmphasis">N</span> is <tt>distance(first, last)</tt>. Its worst-case time complexity is <span class="docEmphasis">O</span>(<span class="docEmphasis">N</span><sup>2</sup>).</p></li><LI><p class="docList"><tt>X(first, last, n, hf); X a(first, last, n, hf);</tt> constructs an object with at least <tt>n</tt> buckets, holding no objects, then inserts the objects in the range <tt>[first, last)</tt> into the container. The container will use a copy of <tt>hf</tt> to compute hash values and <tt>key_equal()</tt> to compare keys. Its average time complexity is <span class="docEmphasis">O</span>(<span class="docEmphasis">N</span>), where <span class="docEmphasis">N</span> is <tt>distance(first, last)</tt>. Its worst-case time complexity is <span class="docEmphasis">O</span>(<span class="docEmphasis">N</span><sup>2</sup>).</p></li><LI><p class="docList"><tt>X(first, last, n); X a(first, last, n);</tt> constructs an object with at least <tt>n</tt> buckets, holding no objects, then inserts the objects in the range <tt>[first, last)</tt> into the container. The container will use <tt>hasher()</tt> to compute hash values and <tt>key_equal()</tt> to compare keys. Its average time complexity is <span class="docEmphasis">O</span>(<span class="docEmphasis">N</span>), where <span class="docEmphasis">N</span> is <tt>distance(first, last)</tt>. Its worst-case time complexity is <span class="docEmphasis">O</span>(<span class="docEmphasis">N</span><sup>2</sup>).</P></LI><li><p class="docList"><tt>X(first, last); X a(first, last);</tt> constructs an object with an unspecified number of buckets, holding no objects, then inserts the objects in the range <tt>[first, last)</tt> into the container. The container will use <tt>hasher()</tt> to compute hash values and <tt>key_equal()</tt> to compare keys. Its average time complexity is <span class="docEmphasis">O</span>(<span class="docEmphasis">N</span>), where <span class="docEmphasis">N</span> is <tt>distance(first, last)</tt>. Its worst-case time complexity is <span class="docEmphasis">O</span>(<span class="docEmphasis">N</span><sup>2</sup>).</p></LI><li><p class="docList"><tt>X(b); X a(b);</tt> constructs an object that is a copy of <tt>b</tt>, including copies of <tt>b</tt>'s hash object, equality predicate, and maximum load factor. Its average time complexity is <span class="docEmphasis">O</span>(<span class="docEmphasis">b.size</span>()), and its worst-case time complexity is <span class="docEmphasis">O</span>(<span class="docEmphasis">b.size</span>()<sup>2</sup>).</p></li><li><p class="docList"><tt>a = b;</tt> replaces the contents of <tt>a</tt> with the contents of <tt>b</tt>, including copies of <tt>b</tt>'s hash object, equality predicate, and maximum load factor. Its average time complexity is <span class="docEmphasis">O</span>(<span class="docEmphasis">b</span><span class="docEmphasis">.</span><span class="docEmphasis">size</span>()), and its worst-case time complexity is <span class="docEmphasis">O</span>(<span class="docEmphasis">b.size</span>()<sup>2</sup>).</p></li></ul>                                       
<p class="docText">The following functions insert single objects into an unordered associative container. If the container does not allow duplicate keys, the functions return an object of type <tt>pair&lt;X::iterator, bool&gt;</tt>. The <tt>iterator</tt> object points at the element that compares equal to the function's argument. The <tt>bool</tt> value indicates whether the object was newly insertedwhich happens only when there is no object equal to the argument in the containeror whether the object was already present. The object <tt>q</tt> is a valid, dereferenceable iterator that points at an element of <tt>a</tt>, and <tt>r</tt> is a valid, dereferenceable const iterator that points at an element of <tt>a</tt>. The average time complexity of these functions is <span class="docEmphasis">O</span>(1), and their worst-case time complexity is <span class="docEmphasis">O</span>(<span class="docEmphasis">a.size</span>()).</p>
<ul><li><p class="docList"><tt>a.insert(t);</tt> inserts an object equal to <tt>t</tt> into <tt>a</tt>.</p></li><LI><p class="docList"><tt>a.insert(q, t);</tt> inserts an object equal to <tt>t</tt> into <tt>a</tt>, The iterator <tt>q</tt> points at an element that might be close to the position where <tt>t</tt> belongs.</p></LI><li><p class="docList"><tt>a.insert(r, t);</tt> inserts an object equal to <tt>t</tt> into <tt>a</tt>, The iterator <tt>r</tt> points at an element that might be close to the position where <tt>t</tt> belongs.</p></li></UL>                                       
<p class="docText">This function inserts multiple objects into an unordered associative container.</P>
<ul><LI><p class="docList"><tt>a.insert(i, j);</tt> the iterators <tt>i</tt> and <tt>j</tt> must not point at objects in <tt>a</tt>. The function returns <tt>void</tt>. It calls <tt>a.insert(t)</tt> for each of the objects pointed at by the iterators in the range <tt>[i, j)</tt>.</p></LI></UL>                                       
<p class="docText">The following functions remove objects from an unordered associative container. The objects <tt>q1</tt> and <tt>q2</tt> are objects of type <tt>X::iterator</tt> that point at elements in the container, and the objects <tt>r1</tt> and <tt>r2</tt> are objects of type <tt>X::const_iterator</tt> that point at elements of the container.</P>
<UL><li><p class="docList"><tt>a.erase(k);</tt> the function returns a value of type <tt>X::size_type</tt>. It removes all elements whose key compares equal to the <tt>Key</tt> value <tt>k</tt> and returns the number of elements that were removed. Its average time complexity is <span class="docEmphasis">O</span>(<span class="docEmphasis">a count</span>(<span class="docEmphasis">k</span>)), and its worst-case time complexity is <span class="docEmphasis">O</span>(<span class="docEmphasis">a.size</span>()).</P></li><LI><p class="docList"><tt>a.erase(q); a.erase(r);</tt> the first function returns an object of type <tt>X::iterator</tt> and the second function returns an object of type <tt>X:: const_iterator</tt>. The functions remove the element pointed at by <tt>q</tt> and <tt>r</tt>, respectively, and return an iterator object that points at the element that followed that element. Their average time complexity is <span class="docEmphasis">O</span>(1), and their worst-case time complexity is <span class="docEmphasis">O</span>(<span class="docEmphasis">a.size</span>()).</P></li><LI><p class="docList"><tt>a.erase(q1, q2); a.erase(r1, r2);</tt> the first function returns an object of type <tt>X::iterator</tt>. The second function returns an object of type <tt>X::const_iterator</tt>. The functions remove the elements pointed at by the iterators in the range <tt>[q1, q2)</tt> and <tt>[r1, r2)</tt>, respectively, and return an iterator object that points at the element that followed the erased elements. Their average time complexity is <span class="docEmphasis">O</span>(<span class="docEmphasis">distance</span>(<span class="docEmphasis">q</span>1,<span class="docEmphasis">q</span>2)) and <span class="docEmphasis">O</span>(<span class="docEmphasis">distance</span>(<span class="docEmphasis">r</span>1,<span class="docEmphasis">r</span>2)), respectively, and their worst-case time complexity is <span class="docEmphasis">O</span>(<span class="docEmphasis">a.size</span>()).</P></li><li><p class="docList"><tt>a.clear();</tt> the function returns <tt>void</tt>. It removes all the elements from the container. Its time complexity is <span class="docEmphasis">O</span>(<span class="docEmphasis">a.size</span>()).</p></li></UL>                                       
<p class="docText">The following functions search an unordered associative container for objects that match a given key <tt>k</tt>:</p>
<ul><LI><p class="docList"><tt>b.find(k);</tt> for a <tt>const</tt> object <tt>b</tt>, returns an iterator object of type <tt>X::const_iterator</tt>;otherwise, returns an iterator object of type <tt>X ::iterator</tt>. The returned object points at an object in <tt>b</tt> whose key compares equal to the <tt>X::Key</tt> value <tt>k</tt>. If no such object exists, the returned object is equal to <tt>b.end()</tt>. Its average time complexity is <span class="docEmphasis">O</span>(1), and its worst-case time complexity is <span class="docEmphasis">O</span>(<span class="docEmphasis">b.size</span>()).</P></LI><li><p class="docList"><tt>b.count(k);</tt> returns a value of type <tt>X::size_type</tt>, equal to the number of objects in <tt>b</tt> whose key compares equal to the <tt>X::Key</tt> value <tt>k</tt>. Its average time complexity is <span class="docEmphasis">O</span>(1), and its worst-case time complexity is <span class="docEmphasis">O</span>(<span class="docEmphasis">b.size</span>()).</p></LI><li><p class="docList"><tt>b.equal_range(k);</tt> for a <tt>const</tt> object <tt>b</tt>, returns an object of type <tt>pair&lt;X::const_iterator, X::const_iterator&gt;</tt>; otherwise, returns an object of type <tt>pair&lt;X::iterator, X::iterator&gt;</tt>. The pair defines a range that contains all the objects in <tt>b</tt> whose key compares equal to the <tt>X::Key</tt> value <tt>k</tt>. If no such object exists, the function returns <tt>make_pair(b.end(), b.end())</tt>. Its average time complexity is <span class="docEmphasis">O</span>(<span class="docEmphasis">b.count</span>(<span class="docEmphasis">k</span>)), and its worst-case time complexity is <span class="docEmphasis">O</span>(<span class="docEmphasis">b.size</span>()).</p></li></ul>                                       
<p class="docText">The preceding member functions are all required for associative containers.<sup class="docFootnote"><a class="docLink" href="#ch05fn6">[6]</a></sup> Unordered associative constainers provide additional member functions that support the following code constructs.</p><blockquote><p class="docFootnote"><sup><a name="ch05fn6">[6]</a></sup> The main difference between associative containers and unordered associative containers is in the time-complexity requirements. The complexity of inserting an object into an associative container and of searching an associative container is <span class="docEmphasis">O</span>(log <span class="docEmphasis">n</span>). As we've seen, in unordered associative containers, it is often <span class="docEmphasis">O</span>(1) but sometimes <span class="docEmphasis">O</span>(<span class="docEmphasis">n</span>).</p></blockquote>
<ul><li><p class="docList"><tt>b.hash_function()</tt> returns an object of type <tt>X::hasher</tt> that is a copy of <tt>b</tt>'s hash object.</p></li><li><p class="docList"><tt>b.key_eq()</tt> returns an object of type <tt>X::key_equal</tt> that is a copy of <tt>b</tt>'s equality predicate.</p></LI><li><p class="docList"><tt>b.bucket_count()</tt> returns a value of type <tt>X::size_type</tt> that is the number of buckets in <tt>b</tt>.</P></li><li><p class="docList"><tt>b.max_bucket_count()</tt> returns a value of type <tt>X::size_type</tt> that is an upper bound on the number of buckets that <tt>b</tt> can contain.</p></LI><LI><p class="docList"><tt>b.bucket(key)</tt> returns a value of type <tt>X::size_type</tt> that is the index of the bucket where objects whose key is equal to <tt>key</tt> would be found.</p></LI><li><p class="docList"><tt>b.bucket_size(n)</tt> returns a value of type <tt>X::size_type</tt> that is the number of objects in the bucket at index <tt>n</tt>. Its time complexity is <span class="docEmphasis">O</span>(<span class="docEmphasis">M</span>), where <span class="docEmphasis">M</span> is the number of objects in the bucket.</P></LI><LI><p class="docList"><tt>b.begin(n); b.end(n);</tt> for a <tt>const</tt> object <tt>b</tt>, returns an object of type <tt>X::const_local_iterator</tt>;otherwise, returns an object of type <tt>X::local_iterator</tt>. The range <tt>[b.begin(n), b.end(n))</tt> contains all the objects in the <span class="docEmphasis">n</span>th bucket.</P></li><LI><p class="docList"><tt>b.load_factor()</tt> returns a value of type <tt>float</tt> whose value is the average number of objects in each bucket.</p></LI><LI><p class="docList"><tt>b.max_load_factor()</tt> returns a value of type <tt>float</tt> whose value is the target load factor. See <a class="docLink" href="ch05lev1sec10.html#ch05lev1sec10">Section 5.10</a>.</p></LI><LI><p class="docList"><tt>a.max_load_factor(z)</tt> sets the target load factor to the positive floating-point value <tt>z</tt>. See <a class="docLink" href="ch05lev1sec10.html#ch05lev1sec10">Section 5.10</a>.</p></li><li><p class="docList"><tt>a.rehash(n)</tt> resizes the container so that it has at least <tt>n</tt> buckets and its load factor is less than or equal to its target load factor. See <a class="docLink" href="ch05lev1sec10.html#ch05lev1sec10">Section 5.10</a>.</p></LI></ul>                                       
                                            
<a name="ch05lev2sec3"></a>
<h4 id="title-IDAKQCWC" class="docSection2Title">5.4.3. Exception Safety</H4>
<p class="docText">The first rule of exception safety is: Don't write hash objects or equality predicates that throw exceptions. I can't imagine a reason for wanting to do that, but the TR1 specification doesn't prohibit it. It just doesn't promise much of anything if either of those functions throws an exception.</P>
<p class="docText">Here are the rules that unordered associative containers must follow with regard to exceptions.</P>
<ul><li><p class="docList">The <tt>clear</tt> member function does not throw exceptions.</P></li><li><p class="docList">The <tt>erase</tt> member functions do not throw exceptions other than those thrown by the hash object or the equality predicate.</p></li><li><p class="docList">The <tt>insert</tt> member functions that insert one element have no effect if an exception is thrown during their execution other than by the hash object.</p></li><li><p class="docList">The <tt>swap</tt> function does not throw exceptions other than any exceptions thrown by the copy constructor or the copy assignment operator of the hash object or the predicate object.</p></li><li><p class="docList">The <tt>rehash</tt> function has no effect if an exception is thrown during its execution other than by the hash object or the equality predicate.</p></LI></ul>                                       
                                            

<a href="31031536.html"><img src="images/pixel.jpg" alt="" width="1" height="1" border="0"></a></TD></TR></table>
<br>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<tr><td><div STYLE="MARGIN-LEFT: 0.15in;">
<a href=ch05lev1sec3.html><img src="images/prev.gif" width="60" height="17" border="0" align="absmiddle" alt="Previous Page"></a>
<td align="right"><div STYLE="MARGIN-LEFT: 0.15in;">
<a href=ch05lev1sec5.html><img src="images/next.gif" width="60" height="17" border="0" align="absmiddle" alt="Next Page"></a>
</div></td></tr></table>
</body></html>