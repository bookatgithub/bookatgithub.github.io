<html>
<META http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<head>
<title>Section 11.4.&nbsp; Composite Type Categories</title>
<link rel="STYLESHEET" type="text/css" href="images/style.css">
<link rel="STYLESHEET" type="text/css" href="images/docsafari.css">
</head>
<body>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<tr><td><div STYLE="MARGIN-LEFT: 0.15in;">
<a href=ch11lev1sec3.html><img src="images/prev.gif" width="60" height="17" border="0" align="absmiddle" alt="Previous Page"></a>
<td align="right"><div STYLE="MARGIN-LEFT: 0.15in;">
<a href=ch11lev1sec5.html><img src="images/next.gif" width="60" height="17" border="0" align="absmiddle" alt="Next Page"></a>
</div></td></tr></table>
<br><table width="100%" border="0" cellspacing="0" cellpadding="0"><tr><td valign="top"><a name="ch11lev1sec4"></a>
<h3 id="title-IDA40EVF" class="docSection1Title">11.4. Composite Type Categories</H3>
<p class="docText">Each of these class templates defines a type predicate. The templates remove any top-level <tt>const</tt> or <tt>volatile</tt> qualifiers from their type argument <tt>Ty</tt> and then determine whether the resulting type belongs to the template's type category. Defined in various places in the C++ standard, these type categories are referred to as <span class="docEmphasis">composite</span> because they can be composed from the primary predicates discussed in <a class="docLink" href="ch11lev1sec3.html#ch11lev1sec3">Section 11.3</a>.</P>
<div class="docText"><pre>template &lt; class Ty &gt; struct is_arithmetic;
</pre></div><br>
<blockquote>
<p class="docText">The template specialization <tt>is_arithmetic&lt;Ty&gt;</tt> is derived from <tt>TRue_-type</tt> if the type <tt>Ty</tt> is a cv-qualified form of an arithmetic type. Otherwise, it is derived from <tt>false_type</tt>.</p>
</blockquote>
<p class="docText">An <span class="docEmphasis">arithmetic type</span> is an integral type or a floating-point type.</P>
<div class="docText"><pre>template &lt; class Ty &gt; struct is_fundamental;
</pre></div><BR>
<blockquote>
<p class="docText">The template specialization <tt>is_fundamental&lt;Ty&gt;</tt> is derived from <tt>TRue_-type</tt> if the type <tt>Ty</tt> is a cv-qualified form of a fundamental type. Otherwise, it is derived from <tt>false_type</tt>.</P>
</blockquote>
<p class="docText">A <span class="docEmphasis">fundamental type</span> is an integral type, a floating-point type, or the type <tt>void</tt>.</p>
<div class="docText"><pre>template &lt; class Ty &gt; struct is_object;
</pre></div><BR>
<blockquote>
<p class="docText"><a name="iddle1161"></a><a name="iddle1466"></a><a name="iddle1495"></a><a name="iddle1669"></a><a name="iddle1819"></a>The template specialization <tt>is_object&lt;Ty&gt;</tt> is derived from <tt>true_type</tt> if the type <tt>Ty</tt> is a cv-qualified form of an object type. Otherwise, it is derived from <tt>false_type</tt>.</P>
</blockquote>
<p class="docText">An <span class="docEmphasis">object type</span> is any type that is not a function type, not a reference type, and not <tt>void</tt>.</P>
<div class="docText"><pre>template &lt; class Ty &gt; struct is_scalar;
</pre></div><br>
<blockquote>
<p class="docText">The template specialization <tt>is_scalar&lt;Ty&gt;</tt> is derived from <tt>TRue_type</tt> if the type <tt>Ty</tt> is a cv-qualified form of a scalar type. Otherwise, it is derived from <tt>false_type</tt>.</P>
</blockquote>
<p class="docText">A <span class="docEmphasis">scalar type</span> is an arithmetic type, an enumeration type, a pointer type, or a pointer to member type.</p>
<div class="docText"><pre>template &lt; class Ty &gt; struct is_compound;
</pre></div><br>
<blockquote>
<p class="docText">The template specialization <tt>is_compound&lt;Ty&gt;</tt> is derived from <tt>true_type</tt> if the type <tt>Ty</tt> is a cv-qualified form of a compound type. Otherwise, it is derived from <tt>false_type</tt>.</p>
</blockquote>
<p class="docText">A <span class="docEmphasis">compound type</span> is a type that is not a fundamental type.</P>
<div class="docText"><pre>template &lt; class Ty &gt; struct is_member_pointer;
</pre></div><br>
<blockquote>
<p class="docText">The template specialization <tt>is_member_pointer&lt;Ty&gt;</tt> is derived from <tt>true_type</tt> if the type <tt>Ty</tt> is a cv-qualified form of a pointer to member. Otherwise, it is derived from <tt>false_type</tt>.</P>
</blockquote>
<p class="docText">A <span class="docEmphasis">member pointer</span> is a pointer to member function or a pointer to member data.</P>

<a href="31031536.html"><img src="images/pixel.jpg" alt="" width="1" height="1" border="0"></a></TD></TR></table>
<br>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<tr><td><div STYLE="MARGIN-LEFT: 0.15in;">
<a href=ch11lev1sec3.html><img src="images/prev.gif" width="60" height="17" border="0" align="absmiddle" alt="Previous Page"></a>
<td align="right"><div STYLE="MARGIN-LEFT: 0.15in;">
<a href=ch11lev1sec5.html><img src="images/next.gif" width="60" height="17" border="0" align="absmiddle" alt="Next Page"></a>
</div></td></tr></table>
</body></html>