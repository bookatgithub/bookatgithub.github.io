<html>
<META http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<head>
<title>Section 12.4.&nbsp; Infinities, Denormals, NaNs, and Comparisons</title>
<link rel="STYLESHEET" type="text/css" href="images/style.css">
<link rel="STYLESHEET" type="text/css" href="images/docsafari.css">
</head>
<body>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<tr><td><div STYLE="MARGIN-LEFT: 0.15in;">
<a href=ch12lev1sec3.html><img src="images/prev.gif" width="60" height="17" border="0" align="absmiddle" alt="Previous Page"></a>
<td align="right"><div STYLE="MARGIN-LEFT: 0.15in;">
<a href=ch12lev1sec5.html><img src="images/next.gif" width="60" height="17" border="0" align="absmiddle" alt="Next Page"></a>
</div></td></tr></table>
<br><table width="100%" border="0" cellspacing="0" cellpadding="0"><tr><td valign="top"><a name="ch12lev1sec4"></a>

<h3 id="title-IDASYULD" class="docSection1Title">12.4. Infinities, Denormals, NaNs, and Comparisons</H3>
<p class="docText"><a name="iddle1207"></a><a name="iddle1367"></a><a name="iddle1481"></a><a name="iddle1482"></a><a name="iddle1740"></a>The IEC 60559 standard formalizes several special kinds of floating-point values that can arise when something goes wrong in a floating-point computation. For example, dividing a nonzero value by zero is an error. However, code that checks the divisor of every division operation to detect division by zero will be bulky and slow. So the IEC 60559 standard provides the values <span class="docEmphasis">positive infinity</span> and <span class="docEmphasis">negative infinity</span>; division by zero produces one of these two values, and because of the rules for mathematical operations whose operands are infinities, such values persist. As a result, you don't need to check for division by zero; you can wait until the end of a computation and check whether the result is infinity.</P>
<p class="docText">At the other extreme, dividing a small positive value by a large positive value can produce a result that is too small to represent in normalized (<a class="docLink" href="ch12lev1sec2.html#ch12lev2sec1">Section 12.2.1</a>) form. Usually, such a value becomes 0. However, IEC 60559 allows, but does not require, implementations to represent such values in denormalized (<a class="docLink" href="ch12lev1sec2.html#ch12lev2sec1">Section 12.2.1</a>) form. The leading zeros in the significand of a denormalized value mean that the value has less precision than the number of bits in the significand implies. The significand of the smallest possible denormalized value has all its digits equal to 0 except for the last, which is 1. The next smaller value is 0.</p>
<p class="docText">An operation that has no meaningful result, such as dividing 0 by 0, produces a value known as not-a-number, or <span class="docEmphasis">NaN</span> . NaNs, too, persist in a computation; operations, other than comparisons, that involve NaN values produce NaN results. IEC 60559 requires implementations to support at least one NaN value and allows more than one.<sup class="docFootnote"><a class="docLink" href="#ch12fn15">[15]</a></sup></P><blockquote><p class="docFootnote"><sup><a name="ch12fn15">[15]</a></sup> In fact, it permits two flavors of NaN, as well: quiet NaNs and signaling NaNs. Any operation on a signaling NaN produces a quiet NaN, so you can do very little with signaling NaNs.</p></blockquote>
<p class="docText"><a name="iddle1219"></a><a name="iddle1351"></a><a name="iddle1456"></a><a name="iddle1457"></a><a name="iddle1458"></a><a name="iddle1565"></a><a name="iddle1850"></a>The usual comparison operators, when applied to any NaN value, evaluate to <tt>false</tt>. Technically, NaN values are <span class="docEmphasis">unordered</span>. The TR1 library provides functions to determine whether a number is a NaN and whether a particular comparison is unordered, so you can check whether a comparison is telling you what you think it is.</P>
<p class="docText">If the value of <tt>std::numeric_limits&lt;double&gt;::is_iec559</tt> is <tt>TRue</tt>, the implementation supports the IEC 60559 standard. If <tt>std::numeric_limits&lt;double&gt;::has_denorm</tt> equals <tt>std::denorm_present</tt>, the implementation supports denormalized values. If the value of <tt>std::numeric_limits&lt; double&gt;::has_quiet_NaN</tt> is <tt>TRue</tt>, the implementation supports NaN values, and you can get a NaN value by calling <tt>std::numeric_limits&lt;double&gt;:: quiet_NaN()</tt>.</P>

<a href="31031536.html"><img src="images/pixel.jpg" alt="" width="1" height="1" border="0"></a></TD></TR></table>
<br>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<tr><td><div STYLE="MARGIN-LEFT: 0.15in;">
<a href=ch12lev1sec3.html><img src="images/prev.gif" width="60" height="17" border="0" align="absmiddle" alt="Previous Page"></a>
<td align="right"><div STYLE="MARGIN-LEFT: 0.15in;">
<a href=ch12lev1sec5.html><img src="images/next.gif" width="60" height="17" border="0" align="absmiddle" alt="Next Page"></a>
</div></td></tr></table>
</body></html>