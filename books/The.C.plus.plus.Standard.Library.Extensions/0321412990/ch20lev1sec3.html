<html>
<META http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<head>
<title>Section 20.3.&nbsp; Replacing Text</title>
<link rel="STYLESHEET" type="text/css" href="images/style.css">
<link rel="STYLESHEET" type="text/css" href="images/docsafari.css">
</head>
<body>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<tr><td><div STYLE="MARGIN-LEFT: 0.15in;">
<a href=ch20lev1sec2.html><img src="images/prev.gif" width="60" height="17" border="0" align="absmiddle" alt="Previous Page"></a>
<td align="right"><div STYLE="MARGIN-LEFT: 0.15in;">
<a href=ch20lev1sec4.html><img src="images/next.gif" width="60" height="17" border="0" align="absmiddle" alt="Next Page"></a>
</div></td></tr></table>
<br><table width="100%" border="0" cellspacing="0" cellpadding="0"><tr><td valign="top"><a name="ch20lev1sec3"></a>

<h3 id="title-IDAX5QTF" class="docSection1Title">20.3. Replacing Text</h3>
<div class="docText"><pre>
template &lt;class OutIt , class BidIt ,
    class RXtraits, class Elem&gt;
  OutIt <span class="docEmphasis">regex_replace (</span>
    OutIt out , BidIt first , BidIt last ,
    const basic_regex &lt;Elem , RXtraits&gt;&amp; rgx ,
    const basic_string &lt;Elem&gt;&amp; fmt ,
    match_flag_type flags = match_default);
template &lt;class RXtraits , class Elem&gt;
  basic_string &lt;Elem&gt; <span class="docEmphasis">regex_replace (</span>
    const basic_string &lt;Elem&gt;&amp; str ,
    const basic_regex &lt;Elem , RXtraits&gt;&amp; rgx ,
    const basic_string &lt;Elem&gt;&amp; fmt,
    match_flag_type flags = match_default);
</pre></div><br>
<blockquote>
<p class="docText"><a name="iddle1595"></a><a name="iddle1651"></a>The first algorithm begins by constructing a <tt>regex_iterator</tt> object iter (<tt>first</tt>, <tt>last</tt>, <tt>rgx</tt>, <tt>flags</tt>) and using it to split its input range <tt>[first, last)</tt> into a series of alternating nonmatching and matching subsequences <span class="docEmphasis">T</span><sub>0</sub><span class="docEmphasis">M</span><sub>0</sub><span class="docEmphasis">T</span><sub>1</sub><span class="docEmphasis">M</span><sub>1</sub>...<span class="docEmphasis">T</span><span class="docEmphasis"><sub>N</sub></span><span class="docEmphasis"><sub>-</sub></span><sub>1</sub><span class="docEmphasis">M</span><span class="docEmphasis"><sub>N</sub></span><span class="docEmphasis"><sub>-</sub></span><sub>1</sub><span class="docEmphasis">T</span><span class="docEmphasis"><sub>N</sub></span>, where <span class="docEmphasis">M</span><span class="docEmphasis"><sub>n</sub></span> is the <span class="docEmphasis">n</span>th match detected by the iterator. If no matches are found, <span class="docEmphasis">T</span><sub>0</sub> is the entire input range and <span class="docEmphasis">N</span> is 0. If <tt>(flags &amp; format_first_only) != 0</tt>, only the first match is used, <span class="docEmphasis">T</span><sub>1</sub> is all the input text that follows the match, and <span class="docEmphasis">N</span> is 1. The algorithm then generates an output sequence as follows: For each index <span class="docEmphasis">i</span> in the range <tt>[0, N)</tt>, if <tt>(flags &amp; format_no_copy) == 0</tt>, the algorithm appends the text in the range <span class="docEmphasis">T</span><span class="docEmphasis"><sub>i</sub></span> to the output sequence; regardless of the value of <tt>flags &amp; format_no_copy</tt>, it then appends the text generated by a call to <tt>match.format(outseq, fmt, flags)</tt>, where <tt>match</tt> is the <tt>match_results</tt> object returned by the iterator object <tt>iter</tt> for the subsequence <span class="docEmphasis">M</span><span class="docEmphasis"><sub>i</sub></span>, and <tt>outseq</tt> is an output iterator that points at the current position in the output sequence. Finally, if <tt>(flags &amp; format_no_copy) == 0</tt>, it appends the text in the range <span class="docEmphasis">T</span><span class="docEmphasis"><sub>N</sub></span> to the output sequence. Then it sequentially assigns each character in the output sequence to <tt>*out++</tt> and returns the resulting value of <tt>out</tt>.</p>
<p class="docText">The second algorithm constructs a local variable <tt>result</tt> of type <tt>basic_string&lt;Elem&gt;</tt> and then calls <tt>regex_replace(back_inserter(result), str.begin(), str.end(), rgx, fmt, flags)</tt>, returning <tt>result</tt>.</p>
</blockquote>
<p class="docText">That first description is pretty dense. It has to be, to get the formal requirements right. Informally, the function copies text from the input sequence <tt>[first, last)</tt> to the output sequence pointed at by <tt>out</tt>. Whenever it finds text that matches the regular expression <tt>rgx</tt>, it replaces that text with the output sequence produced by calling <tt>match_results::format</tt> with the format string <tt>fmt</tt>. If you pass the flag <tt>format_no_copy</tt>, it skips the text that doesn't match the regular expression and copies only the output sequences produced by <tt>match_results::format</tt>. If you pass the flag <tt>format_first_only</tt>, it looks only for the first match to the regular expression; all the text after that match is either copied without change or ignored, depending on whether you also passed <tt>format_no_copy</tt>.</p>
<p class="docText">For example, to replace every occurrence of the word &quot;Intel&quot; in a text sequence with the word &quot;Microsoft&quot;, try this.<sup class="docFootnote"><a class="docLink" href="#ch20fn4">[4]</a></sup></p><blockquote><p class="docFootnote"><sup><a name="ch20fn4">[4]</a></sup> That intriguing coinage in the last sentence of the result happened in draft documentation at a company where I worked.</p></blockquote>
<a name="ch20ex05"></a><h5 id="title-IDAHFRTF" class="docExampleTitle">Example 20.5. Basic Search and Replace (<tt>regexform/basicrepl.cpp</tt>)</h5><p><table cellspacing="0" width="90%" border="1" cellpadding="5"><tr><td>



<pre>#include &lt;regex&gt;
#include &lt;iostream&gt;
#include &lt;string&gt;
using std::tr1::regex; using std::tr1::regex_replace;
using std::cout;
using std::string;

static const string text =
"For some reason , instead of using the name Microsoft ,\n"
"I used the name Intel when I wrote this.Now I need \n"
"to change it , since I wasn ' t talking about Intel ,\n"
"but about Microsoft.Intelligent people like to think \n"
"they don't make such silly mistakes , but sometimes ,\n"
"alas , they do.\n";

int main ()
  { <span class="docEmphasis">// demonstrate basic search and replace</span>
  regex rgx ("Intel");
  string replacement ("Microsoft");
  string result;
  regex_replace (back_inserter (result),
    text.begin (), text.end (), rgx, replacement);
  cout &lt;&lt; result;
  return 0;
  }
</pre><br>

</TD></tr></table></P>
<p class="docText">To display only text that matches a regular expression, with each match on a separate line, try this.</p>
<a name="ch20ex06"></a><h5 id="title-IDA5FRTF" class="docExampleTitle">Example 20.6. Basic Search (<tt>regexform/basicsrch.cpp</tt>)</H5><P><table cellspacing="0" width="90%" border="1" cellpadding="5"><tr><td>



<pre>#include &lt;regex&gt;
#include &lt;iostream&gt;
#include &lt;string&gt;
using std::tr1::regex; using std::tr1::regex_replace;
using namespace std::tr1::regex_constants;
using std::cout;
using std::string;

static const string text =
"Each morning I check http :// www.nytimes.com and \n"
"http :// www.boston.com for news of what happened \n"
"overnight.I also look at http :// www.tnr.com to\n"
"see any new articles they have posted.";

int main ()
  { <span class="docEmphasis">// demonstrate basic search</span>
  regex rgx ("http ://([^/: ]+)");
  string replacement ("$&amp;\n");
  string result;
  regex_replace (back_inserter (result) ,
    text.begin () , text.end () ,
    rgx , replacement , format_no_copy);
  cout  &lt;&lt; result;
  return 0;
  }
</pre><br>

</td></TR></table></P>
<p class="docText">These examples don't take advantage of the iterator that they pass to receive the output sequence. They could just as easily have been written using the second form of <tt>regex_replace</tt>. To use that function to replace only the first URL in a text sequence, try this.</P>
<a name="ch20ex07"></a><H5 id="title-IDA1GRTF" class="docExampleTitle">Example 20.7. Replace First (<tt>regexform/basicfirst.cpp</tt>)</h5><p><table cellspacing="0" width="90%" border="1" cellpadding="5"><TR><TD>



<pre>#include &lt;regex&gt;
#include &lt;iostream&gt;
#include &lt;string&gt;
using std::tr1::regex; using std::tr1::regex_replace;
using namespace std::tr1::regex_constants;
using std::cout;
using std::string;
static const string text =
"Each morning I check http :// www.nytimes.com and \n"
"http :// www.boston.com for news of what happened \n"
"overnight. I also look at http :// www.tnr.com to\n"
"see any new articles they have posted.";

int main ()
  { <span class="docEmphasis">// demonstrate basic search</span>
  regex rgx ("http ://([^/: ]+)");
  string replacement ("http :// www.wsj.com");
  string result;
  regex_replace (back_inserter (result),
    text.begin (), text.end (),
    rgx, replacement , format_first_only);
  cout &lt;&lt; result;
  return 0;
  }
</pre><br>

</td></TR></table></P>

</TD></TR></table>
<br>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<tr><td><div STYLE="MARGIN-LEFT: 0.15in;">
<a href=ch20lev1sec2.html><img src="images/prev.gif" width="60" height="17" border="0" align="absmiddle" alt="Previous Page"></a>
<td align="right"><div STYLE="MARGIN-LEFT: 0.15in;">
<a href=ch20lev1sec4.html><img src="images/next.gif" width="60" height="17" border="0" align="absmiddle" alt="Next Page"></a>
</div></td></tr></table>
</body></html>