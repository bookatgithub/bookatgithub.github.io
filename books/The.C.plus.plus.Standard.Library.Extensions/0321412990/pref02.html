<html>
<META http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<head>
<title>About This Book</title>
<link rel="STYLESHEET" type="text/css" href="images/style.css">
<link rel="STYLESHEET" type="text/css" href="images/docsafari.css">
</head>
<body>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<tr><td><div STYLE="MARGIN-LEFT: 0.15in;">
<a href=pref01.html><img src="images/prev.gif" width="60" height="17" border="0" align="absmiddle" alt="Previous Page"></a>
<td align="right"><div STYLE="MARGIN-LEFT: 0.15in;">
<a href=pref03.html><img src="images/next.gif" width="60" height="17" border="0" align="absmiddle" alt="Next Page"></a>
</div></td></tr></table>
<br><table width="100%" border="0" cellspacing="0" cellpadding="0"><tr><td valign="top"><a name="pref02"></a><h2 id="title-IDAQKBWC" class="docPrefaceTitle">About This Book</H2>


<p class="docText"><a name="iddle1301"></a>This book is divided into seven parts, each one covering one area of the new facilities. Each part begins with an overview of those facilities. The overview usually includes some remarks about their history and, in some cases, reasons why some obvious features are not in the TR1 library.</P>
<p class="docText">Each part has a synopsis of the header or headers that define the library components discussed in that part. The synopsis is not, in general, compilable code but instead presents an overview of the components that the header defines, listing all the templates, classes, non-member functions, objects, constants, and so on, that are defined in that header. Each of those things is defined in more detail later. However, even the more detailed definitions often are not compilable code. Many of the details are implementation dependent, and nothing would be gained by slogging through them.</p>
<p class="docText">Each synopsis is highlighted in gray. Most are followed by the formal requirements from the C++ standard. These formal requirements are indented. Informal discussions are not indented. For example:</P>
<div class="docText"><pre>class C
{
};
</pre></div><br>
<blockquote>
<p class="docText">This text gives the formal requirements for the class C. It is usually dense and technical. While its words are definitive, they are often hard to read. Text that is not indented is informal. It provides a more approachable, but sometimes less precise, description.</P>
</blockquote>
<p class="docText">Most chapters end with a set of exercises that review the concepts covered in the chapter. Some exercises are easy, and some are deliberately difficult. Don't worry if you can't solve all of them.</P>
<p class="docText">To avoid confusion, I often use formal language to identify the things that I'm talking about. It's far too common for discussions to bog down because the participants don't know whether they're talking about templates, classes, or objects. For example, the TR1 library has a template named <tt>function</tt> that holds function objects. Rather than make you guess whether the word <span class="docEmphasis">function</span> refers to that template or to an object created from that template, I've tried to consistently use such phrases as &quot;the class template <tt>function</tt>,&quot; &quot;specialization of the class template <tt>function</tt>,&quot; and &quot;object of type <tt>function&lt;T&gt;</tt>.&quot;</P>
<p class="docText">All the code examples are complete: They will compile with a suitable compiler and library. Examples that have a <tt>main</tt> function will also link and <a name="iddle1165"></a><a name="iddle1210"></a><a name="iddle1846"></a>run. The examples have been tested with Microsoft's C/C++ compiler,<sup class="docFootnote"><a class="docLink" href="#pref02fn5">[5]</a></sup> version 7.1; and with the GNU Project's gcc compiler,<sup class="docFootnote"><a class="docLink" href="#pref02fn6">[6]</a></sup> version 3.4.3, using the Dinkum TR1 Library Version 1.0 from Dinkumware, Ltd.<sup class="docFootnote"><a class="docLink" href="#pref02fn7">[7]</a></sup> Source code for the examples can be downloaded from my Web site.<sup class="docFootnote"><a class="docLink" href="#pref02fn8">[8]</a></sup></P><blockquote><p class="docFootnote"><sup><a name="pref02fn5">[5]</a></sup> <a class="docLink" target="_blank" href="http://www.microsoft.com">www.microsoft.com</a></p></blockquote><blockquote><p class="docFootnote"><sup><a name="pref02fn6">[6]</a></sup> <a class="docLink" target="_blank" href="http://www.gnu.org">www.gnu.org</a></P></blockquote><blockquote><p class="docFootnote"><sup><a name="pref02fn7">[7]</a></sup> <a class="docLink" target="_blank" href="http://www.dinkumware.com">www.dinkumware.com</a></p></blockquote><blockquote><p class="docFootnote"><sup><a name="pref02fn8">[8]</a></sup> <a class="docLink" target="_blank" href="http://www.petebecker.com/tr1book">www.petebecker.com/tr1book</a></P></blockquote>
<a name="pref02lev1sec1"></a>
<H3 id="669163-906" class="docSection1Title">ISO, Conformance, and the TR1 library</h3>
<p class="docText">The ISO C++ standard is a specification for the C++ programming language, defining what is and is not a valid C++ program and for valid programs telling you, within certain limits, what that program should do. The TR1 library is not part of the C++ standard, although most of the library will almost certainly become part of the standard in its next revision, around 2010. In the meantime, compilers that conform to the C++ standard do not need to include the TR1 library.<sup class="docFootnote"><a class="docLink" href="#pref02fn9">[9]</a></sup></P><blockquote><p class="docFootnote"><sup><a name="pref02fn9">[9]</a></sup> Technically, they should not include it, because it adds names that could conflict with names that are already in use in valid programs. In practice, this won't be a significant problem. The TR1 library puts its names in the namespace <tt>TR1</tt>, which is nested in the namespace <tt>std</tt>. As a result, the directive <tt>using namespace std;</tt> will hoist the name <tt>tr1</tt> into the global namespace, possibly clashing with existing code that uses that name. In addition, code that defines macros with the same names as any of the contents of the TR1 library will run into problems. Of course, we all write macro names in capitals, so this shouldn't cause any problems.</p></blockquote>
<p class="docText">The standard defines and uses several technical terms to talk about valid and invalid programs and about the meaning of a valid program. The Library Technical Report uses the same terminology. Programmers are often confused about the meanings of these terms.<sup class="docFootnote"><a class="docLink" href="#pref02fn10">[10]</a></sup> They're not particularly complicated, though, so if you're interested, read on.</p><blockquote><p class="docFootnote"><sup><a name="pref02fn10">[10]</a></sup> In fact, many of the original proposals that turned into the TR1 library misused them; the Library Working Group tried to fix these misuses, but a few mistakes may still be left in the Technical Report.</p></blockquote>
<p class="docText">A <span class="docEmphasis">diagnostic message</span> is any compiler<sup class="docFootnote"><a class="docLink" href="#pref02fn11">[11]</a></sup> output message that results from a violation of the rules that the standard sets out. The compiler is allowed to give other messages as well, but the compiler's documentation is required to tell you which messages are diagnostic messages.</P><blockquote><p class="docFootnote"><sup><a name="pref02fn11">[11]</a></sup> The standard uses the term <span class="docEmphasis">implementation</span> to refer to the compiler, linker, and whatever else is needed to convert source code into an executable program. I'll use the conventional shorthand term <span class="docEmphasis">compiler</span> to mean the same thing.</p></blockquote>
<p class="docText">When the standard says that some code results in <span class="docEmphasis">undefined behavior,</span> <a name="iddle1209"></a><a name="iddle1356"></a><a name="iddle1497"></a><a name="iddle1660"></a><a name="iddle1901"></a>it means that the standard does not impose any requirements on what a compiler does when compiling a program that uses that code. Unfortunately, code whose behavior is undefined often results in a program that does exactly what you thought it would do but only until you change to a different compiler. This makes debugging very difficult, so it's best to avoid writing code whose behavior is undefined.</p>
<p class="docText">A <span class="docEmphasis">diagnosable rule</span> is any standard rule that doesn't say &quot;no diagnostic required&quot; and that doesn't result in undefined behavior. If your code violates a rule that doesn't require a diagnostic, the standard allows your compiler to do anything at all; you've done something that the C++ standard does not recognize, so you're on your own. If your code violates a diagnosable rule, the compiler must issue at least one diagnostic message.<sup class="docFootnote"><a class="docLink" href="#pref02fn12">[12]</a></sup> That doesn't mean that the compiler must report every diagnosable error; nor does it mean that it cannot give diagnostic messages when compiling a program without diagnosable errors. Technically, a compiler that reports &quot;an error occurred&quot; every time you compile code meets the requirements of the C++ standard. Of course, nobody would use a compiler that did that, if they could avoid it.</P><blockquote><p class="docFootnote"><sup><a name="pref02fn12">[12]</a></sup> You'll often hear that the compiler should refuse to compile code that violates a diagnosable rule. That's wrong. The only requirement is that the compiler must issue a diagnostic. That's the hook for language extensions: Once it has issued a diagnostic, the compiler can do whatever the compiler writer thinks is appropriate.</P></blockquote>
<p class="docText">The <span class="docEmphasis">One Definition Rule</span> requires that definitions of things that ought to be the same must in fact be the same. For example, if you define a <tt>struct</tt> named <tt>data</tt> with two members of type <tt>int</tt> in one source file and you define a <tt>struct</tt> named <tt>data</tt> with three members of type <tt>double</tt> in another source file, you've violated the One Definition Rule. Such violations don't require a diagnostic. They can lead to very mysterious problems.</P>
<p class="docText">A <span class="docEmphasis">well-formed program</span> is one that doesn't violate any diagnosable rule and doesn't violate the One Definition Rule. An <span class="docEmphasis">ill-formed program</span> is one that isn't well formed.</p>
<p class="docText">Because they run on systems with finite amounts of storage, compilers have <span class="docEmphasis">resource limits,</span> which prevent them from compiling programs that are too complicated. The C++ standard recommends some minimum values for such things as the maximum nesting level of compound statements (256), the maximum number of case labels for a <tt>switch</tt> statement (16, 384), and the maximum number of nested template instantiations (17). Compilers are required to document these limits when they are known. These days, however, compilers are getting away from fixed-size tables, instead allocating their internal data structures dynamically as needed; this means that the limits change, depending on what else is being done in the program. What this comes down <a name="iddle1166"></a><a name="iddle1365"></a><a name="iddle1489"></a><a name="iddle1494"></a><a name="iddle1864"></a>to is that you can't assume that a well-formed program that compiles with one compiler will also compile with another compiler, including a different version of the &quot;same&quot; compiler. The program can run up against more restrictive resource limits when you change compilers.</p>
<p class="docText">A <span class="docEmphasis">conforming implementation</span> is a compiler that correctly compiles well-formed programs that do not exceed its resource limits. The resulting executable must, of course, do what the C++ standard says it should do. That's not quite as clear-cut as it seems, though; in many cases, the standard allows executables compiled from the same source code to behave differently.</P>
<p class="docText">The C++ standard sometimes says that code has <span class="docEmphasis">unspecified behavior</span>. Usually, this means that it could do several reasonable things, and the C++ standard doesn't require any particular one of them. For example, the order of evaluation of arguments to a function is unspecified. This means that for code like <tt>f(g(), h())</tt>, the compiler is free to call the function <tt>g</tt> before it calls the function <tt>h</tt> or to call <tt>h</tt> before it calls <tt>g</tt>. If your code assumes that <tt>g</tt> will be called before <tt>h</tt>, you may be in for a surprise when you change compilers or when you change the optimization settings for the compiler you've been using.</p>
<p class="docText">The standard also says that some code has <span class="docEmphasis">implementation-defined behavior</span>. Like code with unspecified behavior, there are usually several reasonable alternatives, and the standard doesn't require any particular one. It does, however, require the implementation to document what it does. For example, the basic type <tt>char</tt> can be either signed or unsigned, and the compiler's documentation must tell you which one you get.</p>
<p class="docText">Finally, the <span class="docEmphasis">normative</span> text in the standard is what you look to for the syntactic and semantic requirements. Text enclosed by &quot;[Note: ... -- end note]&quot;, examples, text in footnotes, and chapter and section titles are <span class="docEmphasis">non-normative</span>; they help you find your way through the standard, but they do not impose requirements. For example, if a footnote and a piece of ordinary text conflict, the ordinary text wins.</p>


</TD></TR></table>
<br>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<tr><td><div STYLE="MARGIN-LEFT: 0.15in;">
<a href=pref01.html><img src="images/prev.gif" width="60" height="17" border="0" align="absmiddle" alt="Previous Page"></a>
<td align="right"><div STYLE="MARGIN-LEFT: 0.15in;">
<a href=pref03.html><img src="images/next.gif" width="60" height="17" border="0" align="absmiddle" alt="Next Page"></a>
</div></td></tr></table>
</body></html>