<html>
<META http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<head>
<title>Section F.4.&nbsp; Byte Ordering</title>
<link rel="STYLESHEET" type="text/css" href="images/style.css">
<link rel="STYLESHEET" type="text/css" href="images/docsafari.css">
</head>
<body>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<tr><td><div STYLE="MARGIN-LEFT: 0.15in;">
<a href=app06lev1sec4.html><img src="images/prev.gif" width="60" height="17" border="0" align="absmiddle" alt="Previous Page"></a>
<td align="right"><div STYLE="MARGIN-LEFT: 0.15in;">
<a href=app06lev1sec6.html><img src="images/next.gif" width="60" height="17" border="0" align="absmiddle" alt="Next Page"></a>
</div></td></tr></table>
<br><table width="100%" border="0" cellspacing="0" cellpadding="0"><TR><td valign="top"><a name="app06lev1sec5"></a>
<H3 id="title-IDAUPQUQ" class="docSection1Title">F.4. <a name="iddle1111"></a><a name="iddle1589"></a>Byte Ordering</h3>
<p class="docText">The term <span class="docEmphasis">byte ordering</span> refers to the order in which the bytes of a word are stored in memory. You can store 32-bit binary values, such as <tt>4A3B2C1D</tt>, in several ways, including the following:</P>
<ul><li><p class="docList">A big-endian scheme stores the most significant byte (MSB) first, yielding</p><div class="docText"><pre>0x4A 0x3B 0x2C 0x1D
</pre></div></li><LI><p class="docList">A little-endian scheme stores the least significant byte (LSB) first, yielding</P><div class="docText"><pre>0x1D 0x2C 0x3B 0x4A
</pre></div></LI></ul>
<p class="docText">The <a name="iddle1211"></a>IBM zSeries is big-endian system<a name="d0e128980"></a>. When porting source code that was originally developed for a machine that is little-endian, you might occasionally stumble over subtle problems. The <a name="iddle1268"></a>Endianess Checking Tool, provided as part of IBM's Migration Kit for Solaris OS to Linux,<sup class="docFootnote"><a class="docLink" href="#app06fn17">[17]</a></sup> can help you locate parts of your code that depend on endianness.<a name="d0e128994"></a><a name="d0e128995"></a><a name="d0e128996"></a></P><blockquote><p class="docFootnote"><sup><a name="app06fn17">[17]</a></sup> <a class="docLink" target="_blank" href="http://www-1.ibm.com/partnerworld/pwhome.nsf/weblook/pat_linux_migrate_solaris.html">http://www-1.ibm.com/partnerworld/pwhome.nsf/weblook/pat_linux_migrate_solaris.html</a></p></blockquote>
<p class="docText">If you need to support multiple platforms with different endianness, you can include the Linux kernel header file asm/byteorder.h, which defines one of the two symbols <tt>__BIG_ENDIAN</tt> and <tt>__LITTLE_ENDIAN</tt>, respectively, depending on the machine's endianness. The header files found in /usr/src/linux/include/linux/byteorder/ provide macros for converting between <a name="iddle1082"></a>big- and <a name="iddle1767"></a>little-endian representations<a name="d0e129016"></a><a name="d0e129017"></a>. If the order is the same, they do nothing. Otherwise, the macros return the converted value.</p>
<p class="docText">A set of similar functions handle byte-order issues related to data transferred via the network. These functions, declared in /usr/include/netinet/in.h, convert values between the network and host byte order. Note that networks often use big-endian byte order, so an application running on zSeries does not need a conversion here. It is, however, good programming practice to insert appropriate conversion routines.</p>

</TD></TR></table>
<br>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<tr><td><div STYLE="MARGIN-LEFT: 0.15in;">
<a href=app06lev1sec4.html><img src="images/prev.gif" width="60" height="17" border="0" align="absmiddle" alt="Previous Page"></a>
<td align="right"><div STYLE="MARGIN-LEFT: 0.15in;">
<a href=app06lev1sec6.html><img src="images/next.gif" width="60" height="17" border="0" align="absmiddle" alt="Next Page"></a>
</div></td></tr></table>
</body></html>