<html>
<META http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<head>
<title>Section 1.2.&nbsp; The Porting Process</title>
<link rel="STYLESHEET" type="text/css" href="images/style.css">
<link rel="STYLESHEET" type="text/css" href="images/docsafari.css">
</head>
<body>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<tr><td><div STYLE="MARGIN-LEFT: 0.15in;">
<a href=ch01lev1sec1.html><img src="images/prev.gif" width="60" height="17" border="0" align="absmiddle" alt="Previous Page"></a>
<td align="right"><div STYLE="MARGIN-LEFT: 0.15in;">
<a href=ch01lev1sec3.html><img src="images/next.gif" width="60" height="17" border="0" align="absmiddle" alt="Next Page"></a>
</div></td></tr></table>
<br><table width="100%" border="0" cellspacing="0" cellpadding="0"><tr><TD valign="top"><a name="ch01lev1sec2"></a>
<H3 id="588026-891" class="docSection1Title">1.2. The Porting Process</H3>
<p class="docText">Developers involved in porting projects tend to follow similar steps when porting any software application. These steps include scoping, analyzing, porting, and testing. Each step in the process builds a foundation for the next step in the process. Each step, when done properly, makes the next step of the process easier to accomplish. <a class="docLink" href="#ch01fig01">Figure 1-1</a> shows the high-level steps taken during a porting project.</P>

<p class="docText"></P><a name="ch01fig01"></a><p><center>

<h5 class="docFigureTitle">Figure 1-1. High-level steps taken during a porting project</h5>

<p class="docText">
<img border="0" alt="" id="195131084199" width="483" height="61" SRC="images/01ulp01.jpg"></P>


</center></P><BR>
<a name="ch01lev2sec1"></a>
<H4 id="title-IDA1FIRY" class="docSection2Title">1.2.1. <a name="iddle1992"></a>Scoping</H4>
<p class="docText">Scoping is the step in which the project manager asks the porting expert<sup class="docFootnote"><a class="docLink" href="#ch01fn2">[2]</a></sup> and a domain expert<sup class="docFootnote"><a class="docLink" href="#ch01fn3">[3]</a></sup> to get together to identify the products, development, and test environment the application to be ported relies on. The key areas to identify during the <a name="iddle2130"></a>scoping process include product dependencies, development environment components, build environment components, and test environment components:</p><blockquote><p class="docFootnote"><sup><a name="ch01fn2">[2]</a></sup> A software developer who is experienced in porting applications and has knowledge of source and target platforms as well as other third-party products the application uses. We also refer to this person as a porting engineer in this book.</P></blockquote><blockquote><p class="docFootnote"><sup><a name="ch01fn3">[3]</a></sup> A person who is knowledgeable about the application to be ported. This could be the application architect or the chief developer of the application.</p></blockquote>
<ul><LI><p class="docText"><span class="docEmphStrong">Product/software dependencies.</span> Identifying which products the application to be ported relies on means determining which versions of database, middleware, and third-party libraries it uses. By knowing the products and versions, the porting expert can assess whether those products and versions are available for the Linux platform.</P></li><li><p class="docText"><span class="docEmphStrong">Development environment components.</span> Assessing the development environment includes identifying what programming language the application is written in. Applications written in a more recent programming language such as Java tend to port more easily, whereas applications written in C or C++ usually require more analysis and porting effort.</p></li><LI><p class="docText"><span class="docEmphStrong">Build environment components.</span> Assessing the build environment includes making sure the build tools are available on Linux. Platform-dependent compiler and link flags used on the source platform must be investigated to determine whether equivalent flags exist on Linux. Some build environments may have dependencies on the source platform that will require a little more effort to port to Linux.</p></li><li><p class="docText"><span class="docEmphStrong">Test environment components.</span> Identifying the test environment for the ported application leads to questions pertaining to the ownership of testing after the application is ported. Usually porting engineers do unit testing for the part of the application they port and then hand it off to a testing group for more verification and systems tests. But who is the testing group?<a name="d0e1076"></a><a name="d0e1077"></a></p></LI></UL>
<p class="docText">In most cases, the <a name="iddle1975"></a><a name="iddle2107"></a>scoping step leads to identifying associated <a name="iddle2131"></a>risks that will be assumed by the project as a whole when it begins<a name="d0e1102"></a><a name="d0e1103"></a><a name="d0e1104"></a>. Some risks that can be identified in the scoping step are included in the following scenarios:</p>
<ul><li><p class="docList">Versions of the database, middleware, or third-party libraries are not available for the Linux platform.</p></li><li><p class="docList">The application has some assembler routines that need to be translated to assembly language instructions on the Linux platform.</p></li><li><p class="docList">The application was written using a set of APIs or a programming model unique to the source platform. This also includes assumptions about such things as word size or &quot;endian-ness.&quot;</p></li><li><p class="docList">The application was written to draft-standard C++ semantics that relied on the source platform's native compiler framework.</p></li><LI><p class="docList">The test environment requires a complicated client/server framework.</p></li><li><p class="docList">The development environment requires third-party tools that need to be compiled or ported to the Linux platform.</P></LI><LI><p class="docList">The application's distribution or installation method requires facilities or tools unique to the source platform.</P></LI></ul>
<p class="docText">Scoping is an involved step in the porting process that takes into account every new piece of information that can be learned from asking the right questionsquestions about documentation, packaging, and performance tuning, to name a few. These and others are mentioned in the &quot;sample porting questionnaire&quot; near the end of this chapter.</p>

<a name="ch01lev2sec2"></a>
<h4 id="title-IDATDJRY" class="docSection2Title">1.2.2. <a name="iddle1064"></a><a name="iddle1989"></a>Analysis</H4>
<p class="docText">There are two views in the analysis step of the porting process: a project management point of view, and a porting point of view. From a project management point of view, analysis is the step that assesses the various porting issues and risks identified in the preceding step and what impact they bring to the <a name="iddle1991"></a>porting project as a whole. The analysis step involves the formulation of the project plan, which includes identifying scope and objectives, creating work schedules, procuring resources needed, and assigning roles within the project.<a name="d0e1168"></a><a name="d0e1169"></a></P>
<p class="docText">Identification of scope and objectives defines the boundaries and responsibilities of the project manager and the members of the project team. Boundaries are clearly identified sets of work that need to be done for the project. For example, a simple statement such as &quot;Module A in application XYZ needs to be ported and tested on platform B&quot; can be a good start to defining the boundaries of the work.</P>
<p class="docText">After boundaries have been identified, tasks for the porting work can be defined, leading to a work breakdown schedule.<sup class="docFootnote"><a class="docLink" href="#ch01fn4">[4]</a></sup> The work breakdown schedule helps define which tasks need to be done and whether those tasks can be done in sequence or in parallel. In addition, the work breakdown schedule identifies the resources needed. An overall schedule for the entire porting project results from identifying tasks and resources needed.</P><blockquote><p class="docFootnote"><sup><a name="ch01fn4">[4]</a></sup> A project management term used to denote work as an activity arranged in a hierarchical order that has tangible results otherwise referred to as a deliverable.</P></blockquote>
<p class="docText">From a porting point of view, analysis is a <a name="iddle1986"></a>step in the porting process during which a porting engineer examines the application architecture in more detail. The porting engineer begins to identify the APIs and system calls used in the application. In addition, the application is assessed as to its use of dynamic linking and loading, networking, threads, and more. This analysis feeds information back to the project manager that can be used to formulate more detailed tasks and accurate schedules.</p>

<a name="ch01lev2sec3"></a>
<H4 id="title-IDAFGJRY" class="docSection2Title">1.2.3. Porting</h4>
<p class="docText">Porting is the step in the process during which the porting engineers perform their assigned tasks. Depending on the application and the work breakdown schedule that resulted from the preceding step, porting engineers may only be able to work their assigned tasks in a serial fashion. Serial tasks are a product of tightly coupled applications. This means that some modules of the application are highly dependent on other parts of the application and that these modules can be worked on only when the part they depend on is ported. A prime example of this is the build environment. If the build environment was designed to build the whole application as a monolithic procedure, chances are all modules depend on common configuration files that need to be modified before any porting work can be performed.<a name="d0e1201"></a><a name="d0e1202"></a></p>
<p class="docText">If the porting tasks are independent of each other, however, the work effort can be parallelized. Loosely coupled modules can be worked on separately and simultaneously by different porting engineers. A key example of this are shared libraries that can be built independently of each other, do not have common components, and exist for other modules to build on. Identifying which tasks can be done in parallel is important and should be done as part of the analysis step of the process.</P>
<p class="docText">The porting engineers' task of compiling the code on the Linux platform includes identifying and removing architectural dependencies and nonstandard practices if possible. Identifying and removing architectural dependencies means heeding compiler errors and warnings produced at compile time and correcting them as needed. Removing architectural dependencies and nonstandard practices involves examining and changing the code to use more portable structures or coding standards. Experienced and quality-conscious porting engineers usually do the latter as they correct compiler errors and warnings.</P>
<p class="docText">The porting effort includes porting the build environment to the Linux platform, too. This task should be identified during the scoping step. Although some build environments are portable, some are not. Making sure the build environment does not create any potential problems is a task easily overlooked and needs to be scoped and analyzed with extreme caution.</p>
<p class="docText">After the application has been portedmeaning it compiles on the Linux platform without errorsthe porting engineer is expected to run unit tests on the application. The unit tests can be as simple as executing the application to determine whether it produces any runtime problems. If runtime problems are detected, they are debugged and fixed before the application is handed to the <a name="iddle1994"></a><a name="iddle2457"></a>testing group; the test group then runs more thorough tests on the ported software.</p>

<a name="ch01lev2sec4"></a>
<h4 id="title-IDA2HJRY" class="docSection2Title">1.2.4. Testing</h4>
<p class="docText">During testing, the assigned testers run the ported application against a set of test cases, which vary from simple execution of the application to stress-type tests that ensure the application is robust enough when run on the Linux platform. Stress testing the application on the target platform is where most porting problems related to architectural dependencies and bad coding practices are uncovered. Most applicationsespecially multithreaded applicationsbehave differently during stress testing on a different platform, in part because of different operating system implementations, especially in the threading area. If problems are found during testing, porting engineers are called in to debug and fix them.<a name="d0e1237"></a><a name="d0e1238"></a></P>
<p class="docText">Some application porting may also include porting a test harness to test the application. Porting this test harness is a task that is also identified during scoping and analysis. Most of the time, the testers need to be trained on the application before they can test it. Learning about the application is a task that is independent of the porting tasks and can be performed in parallel.</p>
<p class="docText">If bugs are found, they are fixed and the source recompiled; the testing process repeats until the application passes all testing requirements.</p>

<a name="ch01lev2sec5"></a>
<h4 id="title-IDA2QJRY" class="docSection2Title">1.2.5. <a name="iddle1993"></a><a name="iddle2312"></a>Support</h4>
<p class="docText">When the port is complete, the development phase ends, and the support phase begins. Some of the porting engineers are retained to help answer any porting-specific questions the customer may have. In addition, the developers are expected to train the customer on configuring and running the application on the Linux platform. The typical support phase lasts from 60 to 90 days after the port. During this time, the porting engineers train and answer technical support and sales personnel questions regarding the newly ported application on the Linux environment. After the technical support and sales personnel have been trained in the newly ported product, the porting engineer's task is done.<a name="d0e1264"></a><a name="d0e1265"></a></P>


</TD></TR></table>
<br>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<tr><td><div STYLE="MARGIN-LEFT: 0.15in;">
<a href=ch01lev1sec1.html><img src="images/prev.gif" width="60" height="17" border="0" align="absmiddle" alt="Previous Page"></a>
<td align="right"><div STYLE="MARGIN-LEFT: 0.15in;">
<a href=ch01lev1sec3.html><img src="images/next.gif" width="60" height="17" border="0" align="absmiddle" alt="Next Page"></a>
</div></td></tr></table>
</body></html>