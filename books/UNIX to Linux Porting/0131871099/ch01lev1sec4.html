<html>
<META http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<head>
<title>Section 1.4.&nbsp; Estimating</title>
<link rel="STYLESHEET" type="text/css" href="images/style.css">
<link rel="STYLESHEET" type="text/css" href="images/docsafari.css">
</head>
<body>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<tr><td><div STYLE="MARGIN-LEFT: 0.15in;">
<a href=ch01lev1sec3.html><img src="images/prev.gif" width="60" height="17" border="0" align="absmiddle" alt="Previous Page"></a>
<td align="right"><div STYLE="MARGIN-LEFT: 0.15in;">
<a href=ch01lev1sec5.html><img src="images/next.gif" width="60" height="17" border="0" align="absmiddle" alt="Next Page"></a>
</div></td></tr></table>
<br><table width="100%" border="0" cellspacing="0" cellpadding="0"><tr><TD valign="top"><a href="9001536.html"><img src="images/pixel.jpg" alt="" width="1" height="1" border="0"></a><a name="ch01lev1sec4"></a>
<H3 id="title-IDASNSP2" class="docSection1Title">1.4. <a name="iddle1954"></a>Estimating</H3>
<p class="docText">Many porting projects go over budget and miss schedules because risks were <a name="iddle1878"></a>not managed properly<a name="d0e1442"></a>. Risks play a major part in <a name="iddle1313"></a>estimating the schedule as well as resources needed for porting projects. In an application porting project, such risks come from different aspects that relate to application porting, including the following:</P>
<UL><li><p class="docList"><a name="iddle1318"></a><a name="iddle1959"></a><a name="iddle2216"></a>Skill levels and porting <a name="iddle1327"></a>experience<a name="d0e1480"></a><a name="d0e1481"></a><a name="d0e1482"></a><a name="d0e1483"></a><a name="d0e1484"></a><a name="d0e1485"></a></p></li><LI><p class="docList">Compiler used</P></LI><LI><p class="docList">Programming language used</P></li><LI><p class="docList">Third-party and middleware product availability</p></li><LI><p class="docList">Build environment and tools</P></li><li><p class="docList">Platform-dependent constructs</p></li><LI><p class="docList">Platform- and hardware-dependent code</p></li><li><p class="docList">Test environment setup needed</p></LI><LI><p class="docList">User interface requirements</p></li></ul>
<p class="docText">Depending on the application to be ported, each of these aspects presents varying levels of complexity and risks to the project. Assessing complexity and risk level help you determine whether they are manageable.</p>
<a name="ch01lev2sec6"></a>
<h4 id="title-IDAUSSP2" class="docSection2Title">1.4.1. Skill Levels and Porting Experience</h4>
<p class="docText">The most glaring difference between porting applications and software development is the skill set of the programmers. Although software application developers tend to be more specialized in their knowledge domain, software developers who do porting and migration need broader and more generalized skill sets. An application developer can be someone who is an expert in Java and works on a Windows development environment. Another may be a programmer specializing in database programming on a Sun Solaris operating system environment. On the other hand, engineers who port code are expected to be experts in two or more operating system platforms, programming languages, compilers, debuggers, databases, middleware, and the latest Web-based technologies. They are expected to know how to install and configure third-party database applications and middleware.</p>
<p class="docText">Whereas application developers tend to be specialists, porting engineers need to be generalists. Application developers may work on an application for about 18 months (the typical development cycle), whereas porting engineers work on a 3- to 6-month project cycle and are ready to start on a new port as soon as the last one is finished. Finding skilled porting engineers who fit the exact requirements of a porting project may be difficult at times. This is most true when the porting efforts require porting from legacy technologies to newer ones.</p>

<a name="ch01lev2sec7"></a>

<h4 id="title-IDAFTSP2" class="docSection2Title">1.4.2. Compiler</h4>
<p class="docText">The <a name="iddle1167"></a>compiler and compiler framework used by the source platform make a big difference when porting applications to the Linux environment.<a name="d0e1551"></a> If the same compiler is used in both the source and target platforms, the task becomes easier. An example in this case is when the GNU compiler is used in both the source and the target platform. Besides the <tt>-g</tt> and <tt>-c</tt> flags, different brands of <a name="iddle1315"></a><a name="iddle1956"></a>compilers use flags differently<a name="d0e1575"></a><a name="d0e1576"></a>. Compiler differences become more difficult if the programming language used is C++.</p>
<p class="docText">Another thing to consider is the version of the compilers. Source code compiled a few years back with older versions of compilers may have syntax that does not conform to present syntax checking by compilers (because of standards conformity). This makes it more difficult to port on different compilers because these compilers may or may not support backward compatibility for standards. Even if the compilers support older standards, different compilers may implement support for these standards differently.</p>

<a name="ch01lev2sec8"></a>
<h4 id="title-IDAPVSP2" class="docSection2Title">1.4.3. <a name="iddle1320"></a><a name="iddle1961"></a><a name="iddle2459"></a>Third-Party and <a name="iddle1836"></a>Middleware Product Availability</h4>
<p class="docText">The complexity of the port increases when the application to be ported uses third-party and middleware products. Complexity increases even more when the versions of those products are not available for the target platform. In rare cases, some third-party products may not even be available on the target platform. In the past few years, middleware vendors such as IBM, Oracle, Sybase, and many more have ported their middleware products to Linux. They have made efforts to make their products available for companies that are ready and willing to make Linux their enterprise platform. This is partly why we are seeing more and more companies willing to port their applications to Linux.<a name="d0e1614"></a><a name="d0e1615"></a><a name="d0e1616"></a><a name="d0e1617"></a></P>

<a name="ch01lev2sec9"></a>
<h4 id="title-IDA2XSP2" class="docSection2Title">1.4.4. <a name="iddle1314"></a><a name="iddle1955"></a>Build Environment and <a name="iddle2482"></a>Tools</h4>
<p class="docText">The simpler the build environment, the less time the porting team takes to understand how to build the source code. More complicated <a name="iddle1086"></a>build environments include multipass builds where objects are built with different compiler flags to get around dependencies between modules. After a first-pass build to build some modules, a second pass compiles yet more modules, but this time builds on top of the previously compiled modules (and so on until the build completes). Sometimes the build scripts call other scripts that automatically generate files on-the-fly based on nonstandard configuration files. Most of these files may be interpreted as ordinary files to be ported, but in fact, it is really the tools and the configuration files that need to be ported to work on the target module. These types of tools are mostly missed during assessment and analysis, which can result in less-than-perfect schedules.<a name="d0e1654"></a><a name="d0e1655"></a><a name="d0e1656"></a><a name="d0e1657"></a></p>
<p class="docText">One build environment that came into fashion sometime in the early 1990s was the use of <a name="iddle1605"></a>imake<a name="d0e1666"></a>. Imake is a makefile generator intended to ease build environment portability issues. Instead of writing <a name="iddle1795"></a>makefiles, one writes imakefiles<a name="d0e1673"></a>. Imakefiles are files that contain machine-independent descriptions of the application build environment. Imake creates makefiles by reading the imakefile and combining it with machine-dependent configuration files on the target platform. The whole concept of architecting a build environment around the imake facility to make it portable is a noble idea. Of the most recent 50 porting projects done by our porting group, only a few were built around the imake facility. Unfortunately, all of them needed as many modifications to their own environment and imakefiles, negating the ease that imake is intended to provide. And because imake was rarely used, anyone who needed to do a port needed to &quot;relearn&quot; the utility every time.</P>
<p class="docText">Nowadays, makefiles are written for the open source make facility called GNU Make (or gmake for short). Most makefile syntax used in different UNIX platforms is syntax that gmake can understand or has an easy equivalent to. Architecting applications around the gmake<sup class="docFootnote"><a class="docLink" href="#ch01fn6">[6]</a></sup> facility is the most accepted and widely used method in build environments today.</P><blockquote><p class="docFootnote"><sup><a name="ch01fn6">[6]</a></sup> Some may favor Autoconf even though it had a certain level of complexity compared to using plain old makefiles.</P></blockquote>
<p class="docText">Source code control is another aspect that must be considered. In the Linux environment, CVS is the most frequently used source code control environment. Other source code control environments are Subversion<sup class="docFootnote"><a class="docLink" href="#ch01fn7">[7]</a></sup> and Arch.<sup class="docFootnote"><a class="docLink" href="#ch01fn8">[8]</a></sup> A porting project needs to have source code control if there is a possibility of several porting engineers working on the same modules at the same time.</P><blockquote><p class="docFootnote"><sup><a name="ch01fn7">[7]</a></sup> <a class="docLink" target="_blank" href="http://subversion.tigris.org">http://subversion.tigris.org</a></P></blockquote><blockquote><p class="docFootnote"><sup><a name="ch01fn8">[8]</a></sup> <a class="docLink" target="_blank" href="http://www.gnu.org/software/gnu-arch/">www.gnu.org/software/gnu-arch/</a></p></blockquote>

<a name="ch01lev2sec10"></a>

<h4 id="title-IDAQ2SP2" class="docSection2Title">1.4.5. <a name="iddle1317"></a><a name="iddle1935"></a><a name="iddle1936"></a><a name="iddle1957"></a><a name="iddle1958"></a>Platform-Dependent <a name="iddle1194"></a>Constructs</h4>
<p class="docText">When porting from UNIX platforms based on RISC architecture to x86-based platforms, a chance exists that application <a name="iddle1133"></a>code needs to be assessed for byte-endian dependencies<a name="d0e1748"></a>. For example, the application implements functions that use byte swapping for calculations or data manipulation purposes. Porting the code that uses byte-swapping logic to an Intel-based machine, which is little-endian architecture, requires that code be modified to adhere to little-endian semantics. In cases where byte-swapping logic is not changed between platforms, debugging becomes a chore because it is difficult to track where data corruption takes place. When this happens several instructions before the application fail. Make sure to identify platform-dependent constructs in the scoping and analysis steps.<a name="d0e1750"></a><a name="d0e1751"></a><a name="d0e1752"></a><a name="d0e1753"></a><a name="d0e1754"></a><a name="d0e1755"></a></P>

<a name="ch01lev2sec11"></a>
<H4 id="title-IDARATP2" class="docSection2Title">1.4.6. Platform- and <a name="iddle1491"></a>Hardware-Dependent Code</H4>
<p class="docText">Applications that require kernel extensions and device drivers to operate are the hardest to port. Kernel APIs for all platforms do not follow any standards. In this case, API calls, number of arguments, and even how to load these extensions into the kernel for a specific <a name="iddle1316"></a>platform will be different<a name="d0e1777"></a>. In most cases, new code that needs to run on Linux must be developed. One thing is for certain: Kernel code will usually, if not always, be written in C or platform-dependent assembler language.<a name="d0e1779"></a></P>

<a name="ch01lev2sec12"></a>
<H4 id="title-IDA5BTP2" class="docSection2Title">1.4.7. <a name="iddle1319"></a><a name="iddle1960"></a><a name="iddle2456"></a>Test Environment and Setup</h4>
<p class="docText">When the port is done and the project scope includes system tests and verification, equipment required to test the code may contribute to the port's complexity. If the application needs to be tested on specialized devices that need to be ordered or leased, this can add complexity to the project. If the application needs to be tested in a complicated clustered and networked environment, setting up the environment and scheduling the resource adds time to the project.<a name="d0e1808"></a><a name="d0e1809"></a><a name="d0e1810"></a></P>
<p class="docText">Testing may also include performance testing. Normally, performance tests require the maximum configuration setup one can afford to be able to load up the application to see how it scales in big installations.</p>
<p class="docText">Porting of the application test harness needs to be included in the porting schedule. A test harness that includes both software tests and specialized hardware configurations needs to be assessed as to how much time it will take to port and configure.</p>

<a name="ch01lev2sec13"></a>

<H4 id="title-IDAEETP2" class="docSection2Title">1.4.8. <a name="iddle1321"></a><a name="iddle1962"></a>User Interface Requirements</H4>
<p class="docText">Porting <a name="iddle2508"></a>user interfaces can range from being easy to complex. User interfaces based on Java technology are easy to port, whereas user interfaces based on X11 technology are more complex. In this type of application, the code may be written in C or C++.</p>
<p class="docText"><a class="docLink" href="#ch01table02">Table 1-2</a> is a summary of the various aspects involved. Each aspect is ranked as easy, medium, or high complexity, depending on the technology used for each aspect.</p>
<a name="ch01table02"></a><p><table cellspacing="0" FRAME="hsides" RULES="groups" cellpadding="5"><caption><h5 class="docTableTitle">Table 1-2. Software Porting Risks and Complexities</H5></caption><colgroup align="left" span="4"><col width="35"><col width="100"><col width="115"><col width="250"></colgroup><thead><tr><th class="bottomBorder thead" scope="col" align="left" valign="top"><p class="docText">Aspect</p></th><th class="bottomBorder thead" scope="col" align="left" valign="top"><p class="docText">Easy</p></th><th class="bottomBorder thead" scope="col" align="left" valign="top"><p class="docText">Medium Complexity</p></th><th class="bottomBorder thead" scope="col" align="left" valign="top"><p class="docText">High Complexity</P></th></TR></thead><tr><td class="docTableCell" align="left" valign="top"><p class="docText">Compiler/ programming language</p></td><td class="docTableCell" align="left" valign="top"><p class="docText">Java Shell scripts</p></td><td class="docTableCell" align="left" valign="top"><p class="docText">Use of C, COBOL, Fortran language</p></td><td class="docTableCell" align="left" valign="top"><p class="docText">C++ using compiler-specific framework that supports varying levels of the C++ standard</p></td></tr><TR><td class="docTableCell" align="left" valign="top">&nbsp;</td><td class="docTableCell" align="left" valign="top">&nbsp;</TD><TD class="docTableCell" align="left" valign="top"><p class="docText">Use of nonportable syntax</P></TD><TD class="docTableCell" align="left" valign="top"><p class="docText">Source code written in languages other than Java or C</p></td></tr><TR><TD class="docTableCell" align="left" valign="top">&nbsp;</TD><TD class="docTableCell" align="left" valign="top">&nbsp;</TD><td class="docTableCell" align="left" valign="top"><p class="docText">Original source code written to other standards of compiler</P></td><td class="docTableCell" align="left" valign="top"><p class="docText">Use of nonstandard compilers such as ASN or customer-built interpreters</P></TD></tr><tr><td class="docTableCell" align="left" valign="top">&nbsp;</td><TD class="docTableCell" align="left" valign="top">&nbsp;</td><td class="docTableCell" align="left" valign="top">&nbsp;</td><td class="docTableCell" align="left" valign="top"><p class="docText">Use of assembler language</P></TD></tr><tr><td class="docTableCell" align="left" valign="top">&nbsp;</td><td class="docTableCell" align="left" valign="top">&nbsp;</td><td class="docTableCell" align="left" valign="top">&nbsp;</td><td class="docTableCell" align="left" valign="top"><p class="docText">Use of RPG language</p></td></tr><tr><td class="docTableCell" align="left" valign="top"><p class="docText">Use of third-party products or middleware</P></td><td class="docTableCell" align="left" valign="top"><p class="docText">None</p></TD><TD class="docTableCell" align="left" valign="top"><p class="docText">Supported and available on target platform</P></TD><TD class="docTableCell" align="left" valign="top"><p class="docText">Not supported on target platform</p></td></tr><TR><TD class="docTableCell" align="left" valign="top">&nbsp;</TD><TD class="docTableCell" align="left" valign="top">&nbsp;</TD><td class="docTableCell" align="left" valign="top">&nbsp;</TD><td class="docTableCell" align="left" valign="top"><p class="docText">Use of third-party tools written in C++</p></TD></TR><tr><td class="docTableCell" align="left" valign="top"><p class="docText">Build environment and tools</p></td><TD class="docTableCell" align="left" valign="top"><p class="docText">Simple makefiles</p></td><td class="docTableCell" align="left" valign="top"><p class="docText">Combination of make- files and build scripts</p></TD><TD class="docTableCell" align="left" valign="top"><p class="docText">Use of noncommon build tools such as imake, multiple-pass builds, on-the-fly-generated code modules</p></td></tr><tr><td class="docTableCell" align="left" valign="top"><p class="docText">Platform/hardware-dependent code</p></td><td class="docTableCell" align="left" valign="top"><p class="docText">No platform- or hardware-dependent code</p></td><td class="docTableCell" align="left" valign="top"><p class="docText">Platform/hardware-dependent code comes from third-party products already ported to target platform</p></td><td class="docTableCell" align="left" valign="top"><p class="docText">Extensive use of kernel extensions and device driver code</P></td></tr><tr><TD class="docTableCell" align="left" valign="top"><p class="docText">Test environment and setup</P></TD><TD class="docTableCell" align="left" valign="top"><p class="docText">Stand-alone</P></td><td class="docTableCell" align="left" valign="top"><p class="docText">Client/server setup</p></TD><TD class="docTableCell" align="left" valign="top"><p class="docText">Networked, high availability, clustered</P></TD></TR><tr><TD class="docTableCell" align="left" valign="top">&nbsp;</td><td class="docTableCell" align="left" valign="top">&nbsp;</TD><TD class="docTableCell" align="left" valign="top">&nbsp;</td><td class="docTableCell" align="left" valign="top"><p class="docText">Needs external peripherals to test such as printers, Fibre Channel-attached disks</p></td></TR><tr><td class="docTableCell" align="left" valign="top"><p class="docText">User interface</p></td><TD class="docTableCell" align="left" valign="top"><p class="docText">Java-based</P></td><td class="docTableCell" align="left" valign="top"><p class="docText">Standard-based interface such as X11, CDE</p></td><td class="docTableCell" align="left" valign="top"><p class="docText">Nonportable user interface such as custom interfaces using proprietary code</p></td></tr></table></p><br>
<p class="docText">Experience shows that real efforts needed to port the application are uncovered during the first two or three weeks of the porting project. This is the time when the code is delivered to the project team and porting engineers get a first glimpse of the software application. In other cases, this is the first time porting engineers work on the application in a Linux environment. They begin to dissect the application components and start preliminary build environment setups. Within the first two to three weeks, the porting engineers will have configured the build environment and started compiling some modules using GNU-based tools and compilers.<a name="d0e2098"></a><a name="d0e2099"></a><a name="d0e2100"></a></p>
<p class="docText">After two to three weeks, it is good to revisit the estimated time <a name="iddle2127"></a>schedules to determine whether they need to be adjusted based on preliminary real experiences of porting the application into the Linux platform.</p>


<a href="9001536.html"><img src="images/pixel.jpg" alt="" width="1" height="1" border="0"></a></TD></TR></table>
<br>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<tr><td><div STYLE="MARGIN-LEFT: 0.15in;">
<a href=ch01lev1sec3.html><img src="images/prev.gif" width="60" height="17" border="0" align="absmiddle" alt="Previous Page"></a>
<td align="right"><div STYLE="MARGIN-LEFT: 0.15in;">
<a href=ch01lev1sec5.html><img src="images/next.gif" width="60" height="17" border="0" align="absmiddle" alt="Next Page"></a>
</div></td></tr></table>
</body></html>