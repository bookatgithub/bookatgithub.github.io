<html>
<META http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<head>
<title>Section 4.11.&nbsp; System Calls</title>
<link rel="STYLESHEET" type="text/css" href="images/style.css">
<link rel="STYLESHEET" type="text/css" href="images/docsafari.css">
</head>
<body>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<tr><td><div STYLE="MARGIN-LEFT: 0.15in;">
<a href=ch04lev1sec10.html><img src="images/prev.gif" width="60" height="17" border="0" align="absmiddle" alt="Previous Page"></a>
<td align="right"><div STYLE="MARGIN-LEFT: 0.15in;">
<a href=ch04lev1sec12.html><img src="images/next.gif" width="60" height="17" border="0" align="absmiddle" alt="Next Page"></a>
</div></td></tr></table>
<br><table width="100%" border="0" cellspacing="0" cellpadding="0"><tr><TD valign="top"><a name="ch04lev1sec11"></a>
<H3 id="title-IDAOZAXQ" class="docSection1Title">4.11. <a name="iddle2274"></a>System Calls</H3>
<p class="docText">System calls are interfaces used by user programs to have the kernel perform a specific function on behalf of the calling thread or process. Some Solaris-proprietary system calls may not be available on Linux. When this happens, a replacement version may have to be implemented on the Linux side.<a name="d0e28933"></a></P>
<p class="docText">A list of system calls in Linux can be located at /usr/include/asm/unistd.h.</P>
<p class="docText"><a class="docLink" href="app01lev1sec2.html#app01table02">Table A-2</a> in <a class="docLink" href="app01.html#app01">appendix A</a> provides a system call comparison between Solaris and Linux.</p>
<p class="docText">In the following subsections, we highlight important system calls that have minor differences, primarily with their flags.</p>
<a name="ch04lev2sec45"></a>
<h4 id="title-IDA50AXQ" class="docSection2Title">4.11.1. <a name="iddle1890"></a><a name="iddle2279"></a><a name="iddle2424"></a>open()</H4>
<div class="docText"><pre>int open(const char *pathname, int flags, mode_t mode);
</pre></div><BR>
<p class="docText">The possible values for the argument <tt>flags</tt> are constructed by a <tt>bitwise-inclusive-OR</tt> between one of the following and any combination of the flags provided in:</P>
<div class="docText"><pre>O_RDONLY or
O_WRONLY or
O_RDWR
</pre></div><BR>
<p class="docText">Some of these flags are available only on Solaris and some only on Linux (see <a class="docLink" href="#ch04table18">Table 4-18</a>).</P>
<a name="ch04table18"></a><p><table cellspacing="0" FRAME="hsides" RULES="none" cellpadding="5"><caption><H5 class="docTableTitle">Table 4-18. Argument Flags for open()</h5></caption><colgroup align="left" span="3"><col width="150"><col width="150"><col width="250"></colgroup><thead><tr><th class="bottomBorder thead" scope="col" align="left" valign="top"><p class="docText">Solaris</P></th><th class="bottomBorder thead" scope="col" align="left" valign="top"><p class="docText">Linux</P></th><th class="bottomBorder thead" scope="col" align="left" valign="top"><p class="docText">Description<sup class="docFootnote"><a class="docLink" href="#ch04tn32">[32]</a></sup></p></th></tr></thead><tr><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>O_APPEND</tt></P></td><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>O_APPEND</tt></p></td><TD class="docTableCell" align="left" valign="top"><p class="docText">If set, the file offset is set to the end of the file prior to each write.</P></td></tr><tr><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>O_CREATE</tt></p></td><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>O_CREATE</tt></p></td><td class="docTableCell" align="left" valign="top"><p class="docText">Create the file if it does not exist.</p></td></tr><tr><TD class="docTableCell" align="left" valign="top"><p class="docText"><tt>O_DSYNC</tt></p></td><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>O_DSYNC</tt></P></TD><TD class="docTableCell" align="left" valign="top"><p class="docText">Write I/O operations on the file descriptor complete as defined by synchronized I/O data-integrity completion.</P></TD></tr><tr><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>O_EXCL</tt></P></TD><TD class="docTableCell" align="left" valign="top"><p class="docText"><tt>O_EXCL</tt></P></TD><td class="docTableCell" align="left" valign="top"><p class="docText">If <tt>O_CREATE</tt> and <tt>O_EXCL</tt> are set, <tt>open()</tt> fails if the file exists. If <tt>O_EXCL</tt> and <tt>O_CREATE</tt> are set, and <span class="docEmphasis">path</span> names a symbolic link, <tt>open()</tt> fails and sets <tt>errno</tt> to <tt>EEXIST</tt>, regardless of the contents of the symbolic link. If <tt>O_EXCL</tt> is set and <tt>O_CREATE</tt> is not set, the result is undefined.</P></td></tr><TR><TD class="docTableCell" align="left" valign="top"><p class="docText"><tt>O_LARGEFILE</tt></p></td><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>O_LARGEFILE</tt></p></TD><td class="docTableCell" align="left" valign="top"><p class="docText">If set, the offset maximum in the open file description is the largest value that can be represented correctly in an object of type <tt>off64_t</tt>.</p></td></tr><TR><TD class="docTableCell" align="left" valign="top"><p class="docText"><tt>O_NOCTTY</tt></p></td><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>O_NOCTTY</tt></p></td><td class="docTableCell" align="left" valign="top"><p class="docText">If set and <span class="docEmphasis">path</span> identifies a terminal device, <tt>open()</tt> does not cause the terminal device to become the controlling terminal for the process.</p></td></tr><tr><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>O_NOFOLLOW</tt></p></td><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>O_NOFOLLOW</tt></P></td><td class="docTableCell" align="left" valign="top"><p class="docText">If the path names a symbolic link, <tt>open()</tt> fails and sets <tt>errno</tt> to <tt>ELOOP</tt>.</p></TD></TR><TR><TD class="docTableCell" align="left" valign="top"><p class="docText"><tt>O_NOLINKS</tt></P></td><td class="docTableCell" align="left" valign="top"><p class="docText">N/A</p></TD><TD class="docTableCell" align="left" valign="top"><p class="docText">If the link count of the named file is greater than 1, <tt>open()</tt> fails and sets <tt>errno</tt> to <tt>EMLINK</tt>.</P></TD></TR><tr><TD class="docTableCell" align="left" valign="top"><p class="docText"><tt>O_NONBLOCK</tt> or <tt>O_NDELAY</tt></p></td><TD class="docTableCell" align="left" valign="top"><p class="docText"><tt>O_NONBLOCK</tt> or<BR><tt>O_NDELAY</tt></p></td><td class="docTableCell" align="left" valign="top"><p class="docText">The file is open in nonblocking mode.</p></TD></tr><tr><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>O_RSYNC</tt></p></TD><TD class="docTableCell" align="left" valign="top"><p class="docText"><tt>O_RSYNC</tt></p></td><td class="docTableCell" align="left" valign="top"><p class="docText">Read I/O operations on the file descriptor complete at the same level of integrity as specified by the <tt>O_DSYNC</tt> and <tt>O_SYNC</tt> flags.</p></td></tr><tr><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>O_SYNC</tt></p></td><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>O_SYNC</tt></p></td><td class="docTableCell" align="left" valign="top"><p class="docText">Write I/O operations on the file descriptor complete as defined by synchronized I/O file-integrity completion.</P></td></tr><tr><TD class="docTableCell" align="left" valign="top"><p class="docText"><tt>O_TRUNC</tt></P></TD><TD class="docTableCell" align="left" valign="top"><p class="docText"><tt>O_TRUNC</tt></P></td><td class="docTableCell" align="left" valign="top"><p class="docText">If the file already exists, it will be truncated.</p></TD></TR><TR><TD class="docTableCell" align="left" valign="top"><p class="docText"><tt>O_XATTR</tt></P></td><TD class="docTableCell" align="left" valign="top"><p class="docText">N/A</p></td><TD class="docTableCell" align="left" valign="top"><p class="docText">If set in <tt>open()</tt>, the implied file descriptor is that for the current working directory. Extended attributes must be referenced with a relative path; providing an absolute path results in a normal file reference.</P></td></tr><tr><td class="docTableCell" align="left" valign="top"><p class="docText">N/A</P></td><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>O_DIRECTORY</tt></p></td><TD class="docTableCell" align="left" valign="top"><p class="docText">If <span class="docEmphasis">pathname</span> is not a directory, cause the open to fail.</P></td></tr><tr><td class="docTableCell" align="left" valign="top"><p class="docText">N/A</p></td><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>O_DIRECT</tt></p></td><td class="docTableCell" align="left" valign="top"><p class="docText">File I/O is done directly to/from user space buffers.</p></td></tr><tr><TD class="docTableCell" align="left" valign="top"><p class="docText">N/A</p></td><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>O_ASYNC</tt></P></TD><TD class="docTableCell" align="left" valign="top"><p class="docText">Generate a signal (<tt>SIGIO</tt>, by default) when input or output becomes possible on this file descriptor.</P></TD></tr></table></p><br><blockquote><p class="docFootnote"><sup><a name="ch04tn32">[32]</a></sup> Solaris and Linux man pages.</P></blockquote>

<a name="ch04lev2sec46"></a>

<H4 id="title-IDAFSBXQ" class="docSection2Title">4.11.2. fcntl()</H4>
<div class="docText"><pre>int <a name="iddle2277"></a><a name="iddle2422"></a>fcntl( int fildes, int cmd, /* arg */ ...) ;
</pre></div><BR>
<p class="docText">This <a name="iddle1344"></a>system call is used to perform various control functions as specified by the <tt>cmd</tt> argument on an open file associated with the <tt>fildes</tt> file descriptor. The call may require the third argument depending on the value of <tt>cmd</tt>. The available values of <tt>cmd</tt> are provided in <a class="docLink" href="#ch04table19">Table 4-19</a>.<a name="d0e29457"></a><a name="d0e29458"></a><a name="d0e29459"></a></P>

<p class="docText"></p><a name="ch04table19"></a><P><table cellspacing="0" FRAME="hsides" RULES="groups" cellpadding="5"><caption><h5 class="docTableTitle">Table 4-19. The cmd Flags for fcntl()</h5></caption><colgroup align="left" span="3"><col width="150"><col width="150"><col width="250"></colgroup><thead><TR><th class="bottomBorder thead" scope="col" align="left" valign="top"><p class="docText">Solaris</P></th><th class="bottomBorder thead" scope="col" align="left" valign="top"><p class="docText">Linux</p></th><th class="bottomBorder thead" scope="col" align="left" valign="top"><p class="docText">Description</p></th></tr></thead><tr><TD class="docTableCell" align="left" valign="top"><p class="docText"><tt>F_DUPFD</tt></p></td><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>F_DUPFD</tt></p></TD><TD class="docTableCell" align="left" valign="top"><p class="docText">Find the lowest-numbered file descriptor available that is greater than or equal to <tt>arg</tt> and make it a copy of <tt>fildes</tt>.</p></td></tr><tr><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>F_DUP2FD</tt></p></td><td class="docTableCell" align="left" valign="top"><p class="docText">N/A</p></td><td class="docTableCell" align="left" valign="top"><p class="docText">Similar to <tt>F_DUPFD</tt>, but always returns <tt>arg</tt>. <tt>F_DUP2FD</tt> closes <tt>arg</tt> if it is open and not equal to <tt>fildes</tt>. <tt>F_DUP2FD</tt> is equivalent to <tt>dup2( fildes, arg)</tt>, which is available on Linux.</p></td></tr><TR><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>F_FREESP</tt></p></td><TD class="docTableCell" align="left" valign="top"><p class="docText">N/A</P></TD><TD class="docTableCell" align="left" valign="top"><p class="docText">Free storage space associated with a section of the ordinary file <tt>fildes</tt>. The section is specified by a variable of data type <tt>struct flock</tt> pointed to by <tt>arg</tt>.</P></td></tr><tr><TD class="docTableCell" align="left" valign="top"><p class="docText"><tt>F_FREESP64</tt></P></TD><TD class="docTableCell" align="left" valign="top"><p class="docText">N/A</P></td><TD class="docTableCell" align="left" valign="top"><p class="docText">Same as <tt>F_FREESP</tt>, but takes a <tt>struct flock64</tt> argument rather than a <tt>struct flock</tt> argument.</p></td></TR><TR><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>F_GETFD</tt></p></td><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>F_GETFD</tt></P></td><td class="docTableCell" align="left" valign="top"><p class="docText">Get the file descriptor flags that are associated with the file descriptor <tt>fildes</tt><span class="docEmphasis">.</span></p></td></TR><TR><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>F_GETFL</tt></p></td><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>F_GETFL</tt></p></td><td class="docTableCell" align="left" valign="top"><p class="docText">Get the file status flags and file access modes for the file descriptor specified by <tt>fildes</tt><span class="docEmphasis">.</span></p></td></tr><tr><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>F_GETOWN</tt></p></td><TD class="docTableCell" align="left" valign="top"><p class="docText"><tt>F_GETOWN</tt></p></td><td class="docTableCell" align="left" valign="top"><p class="docText">In Solaris, if the file descriptor refers to a socket, get the process or process group ID specified to receive <tt>SIGURG</tt> signals when out of band data is available.</P></TD></TR><TR><TD class="docTableCell" align="left" valign="top">&nbsp;</td><td class="docTableCell" align="left" valign="top">&nbsp;</td><TD class="docTableCell" align="left" valign="top"><p class="docText">In Linux, it gets the process ID or process group ID specified to receive the <tt>SIGIO</tt> or <tt>SIGURG</tt> signal for events on the file descriptor.</P></TD></TR><TR><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>F_GETXFL</tt></P></td><td class="docTableCell" align="left" valign="top"><p class="docText">N/A</P></TD><td class="docTableCell" align="left" valign="top"><p class="docText">Get the file status flags, file access modes, and file creation and assignment flags for the file descriptor specified by <tt>fildes</tt>.</p></td></tr><TR><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>F_SETFD</tt></p></td><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>F_SETFD</tt></P></TD><td class="docTableCell" align="left" valign="top"><p class="docText">Set the file descriptor flags that are associated with <tt>fildes</tt> to the third argument, <tt>arg</tt>.</p></td></tr><tr><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>F_SETFL</tt></p></td><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>F_SETFL</tt></p></td><td class="docTableCell" align="left" valign="top"><p class="docText">Set the file status flags part of the descriptor's flag to the value specified by <tt>arg</tt>.</p></td></TR><tr><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>F_SETOWN</tt></p></TD><TD class="docTableCell" align="left" valign="top"><p class="docText"><tt>F_SETOWN</tt></P></TD><TD class="docTableCell" align="left" valign="top"><p class="docText">In Solaris, if <tt>fildes</tt> refers to a socket, set the process or process group ID specified to receive <tt>SIGURG</tt> signals when out-of-band data is available, using the value of the third argument, <tt>arg</tt>.</p></td></tr><TR><TD class="docTableCell" align="left" valign="top">&nbsp;</TD><TD class="docTableCell" align="left" valign="top">&nbsp;</TD><td class="docTableCell" align="left" valign="top"><p class="docText">In Linux, it sets the process ID or process group that will receive <tt>SIGIO</tt> or <tt>SIGURG</tt> signals for events on file descriptor <tt>fd</tt>.</P></td></tr><TR><TD class="docTableCell" align="left" valign="top"><p class="docText"><tt>F_GETLK</tt></p></td><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>F_GETLK</tt></p></TD><td class="docTableCell" align="left" valign="top"><p class="docText">Return the flock structure that prevents you from getting the lock, or set the <tt>l_type</tt> field of the lock to <tt>F_UNLCK</tt> if there is no conflict.</p></td></tr><TR><TD class="docTableCell" align="left" valign="top"><p class="docText"><tt>F_GETLK64</tt></p></td><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>F_GETLK64</tt></p></td><td class="docTableCell" align="left" valign="top"><p class="docText">Equivalent to <tt>F_GETLK</tt>, but takes a <tt>struct flock64</tt> argument instead.</p></td></tr><tr><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>F_SETLK</tt></p></td><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>F_SETLK</tt></P></td><td class="docTableCell" align="left" valign="top"><p class="docText">Set or clean a file segment lock according to the lock description pointed to by <tt>arg</tt>.</p></TD></TR><TR><TD class="docTableCell" align="left" valign="top"><p class="docText"><tt>F_SETLK64</tt></P></td><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>F_SETLK64</tt></p></TD><TD class="docTableCell" align="left" valign="top"><p class="docText">Equivalent to <tt>F_SETLK</tt>, but takes a <tt>struct flock64</tt> argument instead.</P></TD></TR><tr><TD class="docTableCell" align="left" valign="top"><p class="docText"><tt>F_SETLKW</tt></p></td><TD class="docTableCell" align="left" valign="top"><p class="docText"><tt>F_SETLKW</tt></P></td><td class="docTableCell" align="left" valign="top"><p class="docText">Similar to <tt>F_SETLK</tt>, except that if a shared or exclusive lock is blocked by other locks, the process waits until the request can be satisfied.</p></td></TR><tr><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>F_SETLKW64</tt></p></td><TD class="docTableCell" align="left" valign="top"><p class="docText"><tt>F_SETLKW64</tt></P></td><td class="docTableCell" align="left" valign="top"><p class="docText">Equivalent to <tt>F_SETLKW64</tt>, but takes a <tt>struct flock64</tt> argument instead.</p></td></tr><tr><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>F_SHARE</tt></p></td><td class="docTableCell" align="left" valign="top"><p class="docText">N/A</p></td><td class="docTableCell" align="left" valign="top"><p class="docText">Set a share reservation on a file with the specified access mode and designate the types of access to deny.</p></TD></tr><tr><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>F_UNSHARE</tt></P></TD><TD class="docTableCell" align="left" valign="top"><p class="docText">N/A</P></TD><td class="docTableCell" align="left" valign="top"><p class="docText">Remove an existing share reservation.</p></td></TR><TR><TD class="docTableCell" align="left" valign="top"><p class="docText"><tt>F_RDACC</tt></P></TD><td class="docTableCell" align="left" valign="top"><p class="docText">N/A</P></td><td class="docTableCell" align="left" valign="top"><p class="docText">Set a file share reservation for read-only access.</P></TD></tr><tr><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>F_WRACC</tt></p></TD><td class="docTableCell" align="left" valign="top"><p class="docText">N/A</p></td><td class="docTableCell" align="left" valign="top"><p class="docText">Set a file share reservation for write-only access.</P></TD></tr><tr><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>F_RWACC</tt></p></td><td class="docTableCell" align="left" valign="top"><p class="docText">N/A</p></td><td class="docTableCell" align="left" valign="top"><p class="docText">Set a file share reservation for read and write access.</p></td></tr><tr><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>F_COMPAT</tt></P></td><td class="docTableCell" align="left" valign="top"><p class="docText">N/A</p></TD><TD class="docTableCell" align="left" valign="top"><p class="docText">Set a file share reservation to compatibility mode.</P></TD></TR><tr><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>F_RDDNY</tt></p></TD><TD class="docTableCell" align="left" valign="top"><p class="docText">N/A</P></TD><TD class="docTableCell" align="left" valign="top"><p class="docText">Set a file share reservation to deny read access to other processes.</p></TD></tr><tr><TD class="docTableCell" align="left" valign="top"><p class="docText"><tt>F_WRDNY</tt></P></td><td class="docTableCell" align="left" valign="top"><p class="docText">N/A</p></td><TD class="docTableCell" align="left" valign="top"><p class="docText">Set a file share reservation to deny write access to other processes.</p></td></tr><tr><TD class="docTableCell" align="left" valign="top"><p class="docText"><tt>F_RWDNY</tt></P></td><td class="docTableCell" align="left" valign="top"><p class="docText">N/A</p></td><td class="docTableCell" align="left" valign="top"><p class="docText">Set a file share reservation to deny read and write access to other process.</p></td></tr><tr><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>F_NODNY</tt></p></td><td class="docTableCell" align="left" valign="top"><p class="docText">N/A</p></TD><td class="docTableCell" align="left" valign="top"><p class="docText">Do not deny read or write access to any other process.</p></td></TR><TR><TD class="docTableCell" align="left" valign="top"><p class="docText">N/A</P></TD><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>F_GETSIG</tt></p></td><TD class="docTableCell" align="left" valign="top"><p class="docText">Get the signal sent when input or output becomes possible.</P></TD></TR><TR><td class="docTableCell" align="left" valign="top"><p class="docText">N/A</P></td><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>F_SETSIG</tt></P></TD><td class="docTableCell" align="left" valign="top"><p class="docText">Set the signal sent when input or output becomes possible.</p></td></tr><TR><td class="docTableCell" align="left" valign="top"><p class="docText">N/A</p></td><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>F_SETLEASE</tt></P></TD><td class="docTableCell" align="left" valign="top"><p class="docText">Set or remove a file lease according to the values specified in <tt>arg</tt>.</p></td></tr><tr><td class="docTableCell" align="left" valign="top"><p class="docText">N/A</p></td><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>F_GETLEASE</tt></p></td><td class="docTableCell" align="left" valign="top"><p class="docText">Indicate what type of lease we hold on the file referred to by <tt>fd</tt>.</p></td></TR><tr><td class="docTableCell" align="left" valign="top"><p class="docText">N/A</p></TD><TD class="docTableCell" align="left" valign="top"><p class="docText"><tt>F_RDLCK</tt></P></TD><TD class="docTableCell" align="left" valign="top"><p class="docText">Take out a read lease. We will be notified when another process opens the file for writting or truncates it.</p></td></tr><TR><TD class="docTableCell" align="left" valign="top"><p class="docText">N/A</P></TD><TD class="docTableCell" align="left" valign="top"><p class="docText"><tt>F_WRLCK</tt></p></TD><td class="docTableCell" align="left" valign="top"><p class="docText">Take out a write lease. We will be notified when another process opens the file for reading or writing or truncates it.</p></TD></TR><tr><td class="docTableCell" align="left" valign="top"><p class="docText">N/A</p></td><TD class="docTableCell" align="left" valign="top"><p class="docText"><tt>F_UNLCK</tt></p></td><td class="docTableCell" align="left" valign="top"><p class="docText">Remove our lease from the file.</p></TD></TR><tr><td class="docTableCell" align="left" valign="top"><p class="docText">N/A</p></td><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>F_NOTIFY</tt></p></td><td class="docTableCell" align="left" valign="top"><p class="docText">Provide notification when the directory referred to by <tt>fd</tt> or any of the files that it contains is changed.</p></td></tr></table></p><br>
<p class="docText">The data type <tt>struct flock</tt> is defined differently in Solaris and Linux. On Solaris, the <tt>flock</tt> structure (defined in /usr/include/sys/fcntl.h) contains at least the following elements:<a name="d0e30238"></a><a name="d0e30239"></a><a name="d0e30240"></a></p>
<div class="docText"><pre>short  l_type;      /* lock operation type */
short  l_whence;    /* lock base indicator */
off_t  l_start;     /* starting offset from base */
off_t  l_len;       /* lock length; l_len == 0 means
 until end of file  */
int  l_sysid;       /* system ID running process holding lock */
pid_t  l_pid;       /* process ID of process holding lock */
</pre></div><BR>
<p class="docText">But Linux requires <tt>flock</tt> to have the following fields (<tt>struct flock</tt> is defined in /usr/include/bits/<a name="iddle1342"></a><a name="iddle2414"></a>fcntl.h):<a name="d0e30268"></a><a name="d0e30269"></a></p>
<div class="docText"><pre>short l_type;   /* Type of lock: F_RDLCK,
           F_WRLCK, F_UNLCK */
short l_whence; /* How to interpret l_start:
           SEEK_SET, SEEK_CUR, SEEK_END */
off_t l_start;  /* Starting offset for lock */
off_t l_len;    /* Number of bytes to lock */
pid_t l_pid;    /* PID of process blocking our lock
           (F_GETLK only) */
</pre></div><br>

<a name="ch04lev2sec47"></a>
<h4 id="title-IDAY5CXQ" class="docSection2Title">4.11.3. <a name="iddle1220"></a><a name="iddle2276"></a><a name="iddle2421"></a>dirent</H4>
<p class="docText">The <tt>dirent</tt> structure in Solaris is different from that in Linux.<a name="d0e30310"></a><a name="d0e30311"></a><a name="d0e30312"></a></P>
<p class="docText">On Linux, dirent is defined in /usr/include/bits/dirent.h, as follows:</P>
<div class="docText"><pre>struct dirent
      {
#ifndef __USE_FILE_OFFSET64
        __ino_t d_ino;
        __off_t d_off;
#else
       __ino64_t d_ino;
       _off64_t d_off;
#endif
      unsigned short int d_reclen;
      unsigned char d_type;
      char d_name[256];
      };
</pre></div><BR>
<p class="docText">On Solaris, dirent is defined in /usr/include/sys/dirent.h, as follows:</P>
<div class="docText"><pre>typedef struct dirent {
   ino_t  d_ino;            /* "inode number" of entry */
   off_t  d_off;            /* offset of disk directory entry */
   unsigned short d_reclen; /* length of this record */
   char  d_name[1];         /* name of file */
} dirent_t;
</pre></div><br>

<a name="ch04lev2sec48"></a>
<h4 id="title-IDASCDXQ" class="docSection2Title">4.11.4. <a name="iddle1196"></a><a name="iddle2275"></a><a name="iddle2420"></a>CPU Affinity</h4>
<p class="docText">A process in a multiprocessor system by default bounces among several CPUs. Explicitly binding a process to certain CPUs (assigning CPU affinity) may yield performance gain in some cases. System calls for CPU affinity on Solaris are different from those on Linux. The Linux 2.6 kernel provides <tt>sched_setaffinity()</tt> and <tt>sched_getaffinity()</tt> for CPU affinity. You can find more information about this topic at <a class="docLink" target="_blank" href="http://www.linuxjournal.com/article/6799">www.linuxjournal.com/article/6799</a>. Also, <tt>taskset</tt> (<a class="docLink" target="_blank" href="http://rlove.org/schedutils">http://rlove.org/schedutils</a>) is a nice tool that enables you to manipulate task CPU affinity.<a name="d0e30379"></a><a name="d0e30380"></a><a name="d0e30381"></a></P>

<a name="ch04lev2sec49"></a>
<H4 id="title-IDADFDXQ" class="docSection2Title">4.11.5. <a name="iddle2278"></a><a name="iddle2423"></a>fork()</H4>
<p class="docText">In <a name="iddle2428"></a>Solaris 10, calls to <tt>fork()</tt> or <tt>fork1()</tt> are identical to a call to <tt>fork()</tt> in Linux<a name="d0e30425"></a>. That is, only the calling thread is replicated in the child process. Note that this is the POSIX-specified behavior for <tt>fork()</tt>. In the previous release of Solaris, the behavior of <tt>fork()</tt> depends on whether the application is linked with the POSIX thread library. When linked with the Solaris threads (<tt>-lthread</tt>) but not linked with POSIX threads (<tt>-lpthread</tt>), <tt>fork()</tt> is the same as <tt>forkall()</tt>. (All the threads are replicated in the child process.) When linked with POSIX threads, <tt>fork()</tt> is the same as <tt>fork1()</tt>. Linux does not support <tt>forkall()</tt>.<a name="d0e30454"></a><a name="d0e30455"></a></P>


</TD></TR></table>
<br>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<tr><td><div STYLE="MARGIN-LEFT: 0.15in;">
<a href=ch04lev1sec10.html><img src="images/prev.gif" width="60" height="17" border="0" align="absmiddle" alt="Previous Page"></a>
<td align="right"><div STYLE="MARGIN-LEFT: 0.15in;">
<a href=ch04lev1sec12.html><img src="images/next.gif" width="60" height="17" border="0" align="absmiddle" alt="Next Page"></a>
</div></td></tr></table>
</body></html>