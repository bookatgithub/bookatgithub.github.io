<html>
<META http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<head>
<title>Section 4.13.&nbsp; Solaris and Linux APIs</title>
<link rel="STYLESHEET" type="text/css" href="images/style.css">
<link rel="STYLESHEET" type="text/css" href="images/docsafari.css">
</head>
<body>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<tr><td><div STYLE="MARGIN-LEFT: 0.15in;">
<a href=ch04lev1sec12.html><img src="images/prev.gif" width="60" height="17" border="0" align="absmiddle" alt="Previous Page"></a>
<td align="right"><div STYLE="MARGIN-LEFT: 0.15in;">
<a href=ch04lev1sec14.html><img src="images/next.gif" width="60" height="17" border="0" align="absmiddle" alt="Next Page"></a>
</div></td></tr></table>
<br><table width="100%" border="0" cellspacing="0" cellpadding="0"><tr><TD valign="top"><a href="9001536.html"><img src="images/pixel.jpg" alt="" width="1" height="1" border="0"></a><a name="ch04lev1sec13"></a>

<H3 id="title-IDABUG1N" class="docSection1Title">4.13. Solaris and <a name="iddle1747"></a><a name="iddle2256"></a>Linux APIs</H3>
<p class="docText">Linux 2.6 comes with the latest GNU C library. As of this writing, the latest release of the GNU <tt>glibc</tt> is 2.3.5. As seen in the preceding section, the GNU <tt>libc</tt> distribution installs several libraries, which may come in both archived and shared form. The main objective of this section is to compare Solaris APIs as documented in the Solaris 10 man pages and GNU <tt>libc</tt> as referenced through available online manuals, header files, and Linux man pages.</P>
<p class="docText">The C library used on every Linux system is GNU <tt>libc</tt>. Much of the interface of GNU <tt>libc</tt> has been determined by the history of UNIX and various standards. GNU <tt>libc</tt> supports most standards that modern UNIX systems support today, such as ISO C and the POSIX standards. GNU <tt>libc</tt> also supports features of the two major UNIX variants, namely BSD and System V. The list of libraries included in GNU <tt>libc</tt> can be found in <a class="docLink" href="ch03.html#ch03">Chapter 3</a>. To learn what version of <tt>glibc</tt> you have on your installation, run <tt>/lib/libc.so</tt> (that is, just type the following on the command line):</P>
<div class="docText"><pre><span class="docEmphStrong"># ./libc.so.6</span>
GNU C Library stable release version 2.3.3 (20040405), by Roland McGrath et al.
Copyright (C) 2004 Free Software Foundation, Inc.
This is free software; see the source for copying conditions.
There is NO warranty; not even for MERCHANTABILITY or FITNESS FOR A
PARTICULAR PURPOSE.
Configured for i686-suse-linux.
Compiled by GNU CC version 3.3.3 (SuSE Linux).
Compiled on a Linux 2.6.4 system on 2004-04-05.
Available extensions:
    <a name="iddle1454"></a>GNU libio by Per Bothner
    crypt add-on version 2.1 by Michael Glad and others
    linuxthreads-0.10 by Xavier Leroy
    GNU Libidn by Simon Josefsson
    NoVersion patch for broken glibc 2.0 binaries
    BIND-8.2.3-T5B
    libthread_db work sponsored by Alpha Processor Inc
    NIS(YP)/NIS+ NSS modules 0.19 by Thorsten Kukuk
Thread-local storage support included.
Report bugs using the 'glibcbug' script to &lt;bugs@gnu.org&gt;.<a name="d0e30741"></a>
</pre></div><br>
<p class="docText"><a class="docLink" href="app01lev1sec3.html#app01table03">Table A-3</a> in <a class="docLink" href="app01.html#app01">appendix A</a> shows Solaris basic library functions and their equivalents on Linux as implemented through the GNU <tt>libc</tt> distribution.</p>
<p class="docText">In the following subsections, we turn our focus to the basic system interfaces, such as memory management and interprocess communication.</p>
<a name="ch04lev2sec50"></a>

<H4 id="title-IDAVXG1N" class="docSection2Title">4.13.1. <a name="iddle1068"></a><a name="iddle1815"></a>Memory Management</H4>
<p class="docText"><a class="docLink" href="#ch04table21">Table 4-21</a> compares library functions that applications use for memory management on <a name="iddle1634"></a>Solaris and Linux.<a name="d0e30791"></a><a name="d0e30792"></a><a name="d0e30793"></a><a name="d0e30794"></a><a name="d0e30795"></a></P>
<a name="ch04table21"></a><P><table cellspacing="0" FRAME="hsides" RULES="groups" cellpadding="5"><caption><H5 class="docTableTitle">Table 4-21. Memory Management APIs</h5></caption><colgroup align="left" span="3"><col width="125"><col width="150"><col width="150"></colgroup><thead><TR><th class="bottomBorder thead" scope="col" align="left" valign="top"><p class="docText">Solaris</p></th><th class="bottomBorder thead" scope="col" align="left" valign="top"><p class="docText">Linux</p></th><th class="bottomBorder thead" scope="col" align="left" valign="top"><p class="docText">Description</P></th></TR></thead><tr><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>mlock</tt></p></td><TD class="docTableCell" align="left" valign="top"><p class="docText"><tt>mlock</tt><sup class="docFootnote"><a class="docLink" href="#ch04tn33">[*]</a></sup></p></td><td class="docTableCell" align="left" valign="top"><p class="docText">Locks pages in memory.</p></TD></TR><tr><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>munlock</tt></p></td><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>munlock</tt></p></td><td class="docTableCell" align="left" valign="top"><p class="docText">Unlocks pages in memory.</p></td></tr><tr><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>mlockall</tt></p></TD><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>mlockall</tt><sup class="docFootnote"><a class="docLink" href="#ch04tn33">[*]</a></sup></p></td><TD class="docTableCell" align="left" valign="top"><p class="docText">Locks address space.</P></TD></TR><TR><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>munlockall</tt></p></td><TD class="docTableCell" align="left" valign="top"><p class="docText"><tt>munlockall</tt></P></TD><TD class="docTableCell" align="left" valign="top"><p class="docText">Unlocks address space.</P></td></TR><tr><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>msync</tt></P></TD><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>msync</tt><sup class="docFootnote"><a class="docLink" href="#ch04tn33">[*]</a></sup></p></td><td class="docTableCell" align="left" valign="top"><p class="docText">Synchronizes memory with physical storage.</P></td></tr><tr><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>malloc</tt></P></TD><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>malloc</tt></p></td><td class="docTableCell" align="left" valign="top"><p class="docText">Returns a pointer to a block of memory at least as large as the amount of requested memory.</p></td></tr><tr><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>free</tt></p></td><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>free</tt></p></td><TD class="docTableCell" align="left" valign="top"><p class="docText">Returns the memory.</p></td></tr><TR><TD class="docTableCell" align="left" valign="top"><p class="docText"><tt>calloc</tt></P></TD><TD class="docTableCell" align="left" valign="top"><p class="docText"><tt>calloc</tt></p></td><td class="docTableCell" align="left" valign="top"><p class="docText">Returns a pointer to a block of memory that is initialized to 0.</P></TD></TR><TR><TD class="docTableCell" align="left" valign="top"><p class="docText"><tt>memalign</tt></p></TD><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>memalign</tt><sup class="docFootnote"><a class="docLink" href="#ch04tn33">[*]</a></sup></p></TD><TD class="docTableCell" align="left" valign="top"><p class="docText">Allocates a specified number of bytes on a specified alignment boundary.</p></td></tr><tr><TD class="docTableCell" align="left" valign="top"><p class="docText"><tt>valloc</tt></p></td><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>valloc</tt><sup class="docFootnote"><a class="docLink" href="#ch04tn33">[*]</a></sup></p></TD><TD class="docTableCell" align="left" valign="top"><p class="docText">Allocates a specified number of bytes that are aligned on a page boundary.</p></td></tr><tr><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>realloc</tt></p></td><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>realloc</tt></p></td><td class="docTableCell" align="left" valign="top"><p class="docText">Changes the size of the memory block allocated to a process.</p></td></tr></table></P><br><blockquote><p class="docFootnote"><sup><a name="ch04tn33">[*]</a></sup> <tt>errno</tt> for this function in Solaris is different from what is used in Linux.</p></blockquote>

<a name="ch04lev2sec51"></a>
<h4 id="title-IDA3KH1N" class="docSection2Title">4.13.2. <a name="iddle1627"></a>Interprocess Communication (<a name="iddle1067"></a><a name="iddle1648"></a><a name="iddle2244"></a>IPC)</H4>
<p class="docText">Here we provide information about a set of techniques that processes can use to communicate with each other. These techniques are collectively called IPC and include pipes, FIFOs, message queues, shared memory, and semaphores.<a name="d0e31064"></a></P>
<a name="ch04lev3sec1"></a>

<H5 id="title-IDALNH1N" class="docSection3Title">4.13.2.1. <a name="iddle1636"></a>Pipes</H5>
<p class="docText">A pipe is a technique used to communicate between two threads in a process or between parent and child processes. When a process calls <tt>fork</tt>, its file descriptors are copied to the new child process. As a result, the parent can communicate with the child. A pipe can be created by calling the <tt>pipe</tt> function:<a name="d0e31090"></a></P>
<div class="docText"><pre>#include &lt;unistd.h&gt;

int pipe (int fildes [2]);
</pre></div><br>
<p class="docText">Pipes in Linux, however, are half duplex. Pipes in <a name="iddle1934"></a><a name="iddle1351"></a>Solaris are full duplex<a name="d0e31113"></a>. In Linux, the file descriptor <tt>fildes[0]</tt> is only for reading, and the file descriptor <tt>fildes[1]</tt> is only for writing.</p>
<p class="docText">The <tt>popen</tt> and <tt>pclose</tt> functions are both supported in Solaris and Linux:</p>
<div class="docText"><pre>#include &lt;stdio.h&gt;

FILE *popen(const char *command, const char *mode);
int pclose(FILE *stream);
</pre></div><BR>
<p class="docText">The call to <tt>popen</tt> creates a pipe between the calling process and the program specified by <span class="docEmphasis"><tt>command</tt></span> in the child process. The calling process can either read from or write to the pipe, as specified by the <span class="docEmphasis"><tt>mode</tt></span> argument. The return value is a stream pointer such that one can write to the standard input of the <span class="docEmphasis"><tt>command</tt></span><span class="docEmphasis">,</span> if the mode is <tt>w</tt><span class="docEmphasis">,</span> by writing to the file stream, and one can read from the standard output of the command, if the mode is <tt>r</tt>, by reading from the file stream.</P>

<a name="ch04lev3sec2"></a>
<H5 id="title-IDABRGXQ" class="docSection3Title">4.13.2.2. <a name="iddle1635"></a>FIFOs</H5>
<p class="docText">A first-in, first-out (FIFO) file (also known as a named pipe) is a pipe that has a name in the filesystem associated with it. This enables the pipe to be open or closed by any process. The processes on either end of the pipe need not be related to each other.</P>
<p class="docText">You can create a FIFO programmatically by calling the <tt>mkfifo</tt> function:</p>
<div class="docText"><pre>#include &lt;sys/types.h&gt;
#include &lt;sys/stat.h&gt;

int mkfifo(const char *pathname, mode_t mode);
</pre></div><BR>
<p class="docText">This function works the same way on both Solaris and Linux. A FIFO can have multiple readers and writers. A write request of <tt>PIPE_BUF</tt> bytes or less from a writer is guaranteed not to be interleaved with data from other processes. On Linux, PIPE_BUF is 4096 bytes,<sup class="docFootnote"><a class="docLink" href="#ch04fn33">[33]</a></sup> whereas it is 5120 bytes on Solaris.<sup class="docFootnote"><a class="docLink" href="#ch04fn34">[34]</a></sup><a name="d0e31209"></a><a name="d0e31210"></a></p><blockquote><p class="docFootnote"><sup><a name="ch04fn33">[33]</a></sup> /usr/include/linux/limits.h</p></blockquote><blockquote><p class="docFootnote"><sup><a name="ch04fn34">[34]</a></sup> /usr/include/limits.h</P></blockquote>

<a name="ch04lev3sec3"></a>
<H5 id="title-IDACTGXQ" class="docSection3Title">4.13.2.3. <a name="iddle1637"></a><a name="iddle1832"></a><a name="iddle2011"></a>POSIX Messages</h5>
<p class="docText">Messages enable multiple processes to send formatted data streams to arbitrary processes. On Linux, POSIX messages are supported only when the option <tt>_POSIX_MESSAGE_PASSING</tt> is defined. You can determine whether your Linux system has the option <tt>_POSIX_MESSAGE_PASSING</tt> set by issuing the following command:</p>
<div class="docText"><pre>$ getconf _POSIX_MESSAGE_PASSING
200112
</pre></div><br>
<p class="docText"><a class="docLink" href="#ch04table22">Table 4-22</a> compares message queue interfaces in Solaris and Linux.</p>
<a name="ch04table22"></a><P><table cellspacing="0" FRAME="hsides" RULES="groups" cellpadding="5"><caption><h5 class="docTableTitle">Table 4-22. Comparison Between POSIX Message Queue Interfaces in Solaris and Linux</h5></caption><colgroup align="left" span="3"><col width="150"><col width="150"><col width="250"></colgroup><thead><tr><th class="bottomBorder thead" scope="col" align="left" valign="top"><p class="docText">Solaris Interfaces</p></th><th class="bottomBorder thead" scope="col" align="left" valign="top"><p class="docText">Linux Interfaces</P></th><th class="bottomBorder thead" scope="col" align="left" valign="top"><p class="docText">Description</P></th></tr></thead><tr><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>mq_close</tt></p></td><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>mq_close</tt></p></td><td class="docTableCell" align="left" valign="top"><p class="docText">Closes a message queue.</p></td></tr><tr><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>mq_getattr</tt></P></td><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>mq_getattr</tt></p></TD><TD class="docTableCell" align="left" valign="top"><p class="docText">Gets message queue attributes.</P></TD></TR><tr><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>mq_notify</tt></p></TD><TD class="docTableCell" align="left" valign="top"><p class="docText"><tt>mq_notify</tt></P></TD><TD class="docTableCell" align="left" valign="top"><p class="docText">Notifies the process (or thread) that a message is available on a queue.</p></TD></tr><tr><TD class="docTableCell" align="left" valign="top"><p class="docText"><tt>mq_open</tt></P></td><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>mq_open</tt></p></td><TD class="docTableCell" align="left" valign="top"><p class="docText">Opens a message queue.</p></td></tr><tr><TD class="docTableCell" align="left" valign="top"><p class="docText"><tt>mq_receive</tt></P></td><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>mq_receive</tt></p></td><td class="docTableCell" align="left" valign="top"><p class="docText">Receives a message from a message queue.</p></td></tr><tr><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>mq_reltimed receive_np</tt></p></td><td class="docTableCell" align="left" valign="top"><p class="docText">N/A</p></TD><td class="docTableCell" align="left" valign="top"><p class="docText">Receives a message from a message queue and stops waiting if the specified timeout expires. (Timeout is specified as a relative time interval.)</p></td></TR><TR><TD class="docTableCell" align="left" valign="top"><p class="docText"><tt>mq_reltimedsend_np</tt></P></TD><td class="docTableCell" align="left" valign="top"><p class="docText">N/A</p></td><TD class="docTableCell" align="left" valign="top"><p class="docText">Sends a message to a message queue and stops blocking on the full message queue if the specified timeout expires. (Timeout is specified as a relative time interval.)</P></TD></TR><TR><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>mq_send</tt></P></td><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>mq_send</tt></P></TD><td class="docTableCell" align="left" valign="top"><p class="docText">Sends a message to a message queue.</p></td></tr><TR><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>mq_setattr</tt></p></td><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>mq_setattr</tt></P></TD><td class="docTableCell" align="left" valign="top"><p class="docText">Sets/gets message queue attributes.</p></td></tr><tr><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>mq_timedreceive</tt></p></td><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>mq_timedreceive</tt></p></td><td class="docTableCell" align="left" valign="top"><p class="docText">Receives a message from a message queue and stops waiting if the specified timeout expires.</p></td></TR><tr><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>mq_timedsend</tt></p></TD><TD class="docTableCell" align="left" valign="top"><p class="docText"><tt>mq_timedsend</tt></P></TD><TD class="docTableCell" align="left" valign="top"><p class="docText">Sends a message to a message queue and stops blocking on the full message queue if the specified timeout expires.</p></td></tr><TR><TD class="docTableCell" align="left" valign="top"><p class="docText"><tt>mq_unlink</tt></P></TD><TD class="docTableCell" align="left" valign="top"><p class="docText"><tt>mq_unlink</tt></p></TD><td class="docTableCell" align="left" valign="top"><p class="docText">Removes a message queue.</p></TD></TR></table></p><br>

<a name="ch04lev3sec4"></a>

<h5 id="title-IDAMFHXQ" class="docSection3Title">4.13.2.4. <a name="iddle1638"></a>POSIX Semaphores</h5>
<p class="docText">Similar to POSIX messages, if your Linux system supports POSIX semaphores, you should see the following output:<a name="d0e31516"></a><a name="d0e31517"></a><a name="d0e31518"></a><a name="d0e31519"></a></P>
<div class="docText"><pre>$getconf _POSIX_SEMAPHORES
200112
</pre></div><br>
<p class="docText"><a class="docLink" href="#ch04table23">Table 4-23</a> compares POSIX semaphore <a name="iddle2243"></a>interfaces in <a name="iddle2006"></a><a name="iddle2137"></a>Solaris and Linux.</p>
<a name="ch04table23"></a><p><table cellspacing="0" FRAME="hsides" RULES="groups" cellpadding="5"><caption><h5 class="docTableTitle">Table 4-23. Comparison Between POSIX Semaphore Interfaces in Solaris and Linux</H5></caption><colgroup align="left" span="3"><col width="150"><col width="150"><col width="150"></colgroup><thead><TR><th class="bottomBorder thead" scope="col" align="left" valign="top"><p class="docText">Solaris Interfaces</p></th><th class="bottomBorder thead" scope="col" align="left" valign="top"><p class="docText">Linux Interfaces</p></th><th class="bottomBorder thead" scope="col" align="left" valign="top"><p class="docText">Description</p></th></tr></thead><tr><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>sem_close</tt></p></td><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>sem_close</tt></p></td><td class="docTableCell" align="left" valign="top"><p class="docText">Closes a named semaphore.</p></td></TR><tr><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>sem_destroy</tt></p></TD><TD class="docTableCell" align="left" valign="top"><p class="docText"><tt>sem_destroy</tt></P></TD><TD class="docTableCell" align="left" valign="top"><p class="docText">Destroys an unnamed semaphore.</p></td></tr><TR><TD class="docTableCell" align="left" valign="top"><p class="docText"><tt>sem_getvalue</tt></P></TD><TD class="docTableCell" align="left" valign="top"><p class="docText"><tt>sem_getvalue</tt></p></TD><td class="docTableCell" align="left" valign="top"><p class="docText">Gets the value of a semaphore.</p></TD></TR><tr><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>sem_init</tt></p></td><TD class="docTableCell" align="left" valign="top"><p class="docText"><tt>sem_init</tt></p></td><td class="docTableCell" align="left" valign="top"><p class="docText">Initializes an unnamed semaphore.</p></TD></TR><tr><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>sem_open</tt></p></td><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>sem_open</tt></p></td><td class="docTableCell" align="left" valign="top"><p class="docText">Initializes/opens a named semaphore.</p></td></tr><tr><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>sem_post</tt></p></TD><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>sem_post</tt></p></td><TD class="docTableCell" align="left" valign="top"><p class="docText">Increments the count of a semaphore.</P></TD></TR><TR><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>sem_reltimedwait_np</tt></p></td><TD class="docTableCell" align="left" valign="top"><p class="docText">N/A</P></TD><TD class="docTableCell" align="left" valign="top"><p class="docText">Locks a semaphore, but stops waiting when the specified timeout expires. (Timeout is specified as relative time interval.)</P></td></TR><tr><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>sem_timedwait</tt></P></TD><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>sem_timedwait</tt></p></td><td class="docTableCell" align="left" valign="top"><p class="docText">Locks a semaphore, but stops waiting when the specified timeout expires.</P></td></tr><tr><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>sem_trywait</tt></P></TD><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>sem_trywait</tt></p></td><td class="docTableCell" align="left" valign="top"><p class="docText">Acquires or waits for a semaphore.</p></td></tr><tr><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>sem_unlink</tt></p></td><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>sem_unlink</tt></p></td><TD class="docTableCell" align="left" valign="top"><p class="docText">Removes a named semaphore.</p></td></tr><TR><TD class="docTableCell" align="left" valign="top"><p class="docText"><tt>sem_wait</tt></P></TD><TD class="docTableCell" align="left" valign="top"><p class="docText"><tt>sem_wait</tt></p></td><td class="docTableCell" align="left" valign="top"><p class="docText">Acquires or waits for a semaphore.</P></TD></TR></table></P><BR>

<a name="ch04lev3sec5"></a>

<h5 id="title-IDAQIJXQ" class="docSection3Title">4.13.2.5. <a name="iddle1639"></a><a name="iddle1812"></a>POSIX Shared Memory</H5>
<p class="docText"><a class="docLink" href="#ch04table24">Table 4-24</a> compares POSIX shared memory interfaces in <a name="iddle2008"></a><a name="iddle2152"></a><a name="iddle1834"></a><a name="iddle2431"></a>Solaris and Linux.<a name="d0e31849"></a><a name="d0e31850"></a><a name="d0e31851"></a><a name="d0e31852"></a><a name="d0e31853"></a><a name="d0e31854"></a><a name="d0e31855"></a></p>
<a name="ch04table24"></a><p><table cellspacing="0" FRAME="hsides" RULES="groups" cellpadding="5"><caption><H5 class="docTableTitle">Table 4-24. Comparison Between POSIX Shared Memory Interfaces in Solaris and Linux</H5></caption><colgroup align="left" span="3"><col width="150"><col width="150"><col width="150"></colgroup><thead><tr><th class="bottomBorder thead" scope="col" align="left" valign="top"><p class="docText">Solaris Interfaces</p></th><th class="bottomBorder thead" scope="col" align="left" valign="top"><p class="docText">Linux Interfaces</p></th><th class="bottomBorder thead" scope="col" align="left" valign="top"><p class="docText">Description</p></th></TR></thead><tr><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>shm_open</tt></p></td><TD class="docTableCell" align="left" valign="top"><p class="docText"><tt>shm_open</tt></P></td><td class="docTableCell" align="left" valign="top"><p class="docText">Opens a shared memory object. In Linux, using <tt>O_TRUNC</tt> with <tt>O_RDONLY</tt> successfully truncates an existing shared memory object, whereas the result of this combination is undefined in Solaris.</p></td></tr><tr><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>shm_unlink</tt></p></td><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>shm_unlink</tt></p></td><td class="docTableCell" align="left" valign="top"><p class="docText">Removes a shared memory object.</p></TD></tr></table></p><br>
<p class="docText">On Linux, these two functions are available in <tt>glibc</tt> version 2.2 and later. To use these functions in your code, you need to use the required real-time library by specifying the <tt>-lrt</tt> flag with the compiler.</P>

<a name="ch04lev3sec6"></a>
<H5 id="title-IDA2PJXQ" class="docSection3Title">4.13.2.6. <a name="iddle1640"></a>System V Messages</H5>
<p class="docText"><a class="docLink" href="#ch04table25">Table 4-25</a> compares System V message interfaces in Solaris and Linux.</P>
<a name="ch04table25"></a><P><table cellspacing="0" FRAME="hsides" RULES="groups" cellpadding="5"><caption><h5 class="docTableTitle">Table 4-25. Comparison Between System V Message Interfaces in Solaris and Linux</h5></caption><colgroup align="left" span="3"><col width="150"><col width="150"><col width="150"></colgroup><thead><tr><th class="bottomBorder thead" scope="col" align="left" valign="top"><p class="docText">Solaris</P></th><th class="bottomBorder thead" scope="col" align="left" valign="top"><p class="docText">Linux</P></th><th class="bottomBorder thead" scope="col" align="left" valign="top"><p class="docText">Description</P></th></TR></thead><TR><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>msgctl</tt></P></td><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>msgctl</tt></P></TD><td class="docTableCell" align="left" valign="top"><p class="docText">Message control operation</p></td></tr><TR><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>msgget</tt></p></td><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>msgget</tt></P></TD><td class="docTableCell" align="left" valign="top"><p class="docText">Get message queue</p></td></tr><tr><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>msgids</tt></p></td><td class="docTableCell" align="left" valign="top"><p class="docText">N/A</p></td><td class="docTableCell" align="left" valign="top"><p class="docText">Discover all message queue identifiers</p></td></TR><tr><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>msgrcv</tt></p></TD><TD class="docTableCell" align="left" valign="top"><p class="docText"><tt>msgrcv</tt></P></TD><TD class="docTableCell" align="left" valign="top"><p class="docText">Message receive operation</p></td></tr><TR><TD class="docTableCell" align="left" valign="top"><p class="docText"><tt>msgsnap</tt></P></TD><TD class="docTableCell" align="left" valign="top"><p class="docText">N/A</p></TD><td class="docTableCell" align="left" valign="top"><p class="docText">Message queue snapshot operation</p></TD></TR><tr><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>msgsnd</tt></p></td><TD class="docTableCell" align="left" valign="top"><p class="docText"><tt>msgsnd</tt></p></td><td class="docTableCell" align="left" valign="top"><p class="docText">Message send operation</p></TD></TR></table></p><br>
<p class="docText">The definition of <tt>struct msqid_ds</tt> used in the function <tt>msgctl()</tt> is not the same on Solaris and Linux.</p>
<p class="docText">In Solaris, /usr/include/sys/msg.h:</p>
<div class="docText"><pre>struct msqid_ds {
    struct ipc_perm msg_perm;     /* operation permission struct */
    struct msg   *msg_first;      /* ptr to first message on q */
    struct msg   *msg_last;       /* ptr to last message on q */
    msglen_t    msg_cbytes;       /* current # bytes on q */
    msgqnum_t    msg_qnum;        /* # of messages on q */
    msglen_t    msg_qbytes;       /* max # of bytes on q */
    pid_t      msg_lspid;         /* pid of last msgsnd */
    pid_t      msg_lrpid;         /* pid of last msgrcv */
#if defined(_LP64)
    time_t     msg_stime;         /* last msgsnd time */
    time_t     msg_rtime;         /* last msgrcv time */
    time_t     msg_ctime;         /* last change time */
#else
    time_t     msg_stime;         /* last msgsnd time */
    int32_t     msg_pad1;         /* reserved for time_t expansion */
    time_t     msg_rtime;         /* last msgrcv time */
    int32_t     msg_pad2;         /* time_t expansion */
    time_t     msg_ctime;         /* last change time */
    int32_t     msg_pad3;         /* time_t expansion */
#endif
    short      msg_cv;
    short      msg_qnum_cv;
    long      msg_pad4[3];   /* reserve area */
};
</pre></div><br>
<p class="docText">In Linux, /usr/include/bits/msq.h:</p>
<div class="docText"><pre>struct msqid_ds
{
 struct ipc_perm msg_perm;        /* structure describing operation permission */
 __time_t msg_stime;              /* time of last msgsnd command */
 unsigned long int __unused1;
 __time_t msg_rtime;              /* time of last msgrcv command */
 unsigned long int __unused2;
  __time_t msg_ctime;             /* time of last change */
 unsigned long int __unused3;
unsigned long int __msg_cbytes;   /* current number of bytes on queue */
 msgqnum_t msg_qnum;               /* number of messages currently on queue */
 msglen_t msg_qbytes;              /* max number of bytes allowed on queue */
 __pid_t msg_lspid;                /* pid of last msgsnd() */
 __pid_t msg_lrpid;                /* pid of last msgrcv() */
 unsigned long int __unused4;
 unsigned long int __unused5;
};
</pre></div><br>
<p class="docText">The default maximum size of a message queue (<tt>msg_qbytes</tt>) on Linux is set to the system parameter <tt>MSGMNB</tt> (16384 bytes). The <tt>msg_qbytes</tt> value can be raised beyond <tt>MSGMNB</tt> by using the <tt>msgctl</tt> function with the appropriate privileges. On Linux, the maximum size for a message text is set to <tt>MSGMAX</tt> (8192 bytes).<a name="d0e32151"></a><a name="d0e32152"></a><a name="d0e32153"></a></p>

<a name="ch04lev3sec7"></a>
<h5 id="title-IDAY5JXQ" class="docSection3Title">4.13.2.7. <a name="iddle1641"></a>System V Semaphores</h5>
<p class="docText"><a class="docLink" href="#ch04table26">Table 4-26</a> compares System V semaphore interfaces in <a name="iddle2139"></a><a name="iddle2433"></a>Solaris and Linux.</p>
<a name="ch04table26"></a><p><table cellspacing="0" FRAME="hsides" RULES="groups" cellpadding="5"><caption><h5 class="docTableTitle">Table 4-26. Comparison Between System V Semaphore Interfaces in Solaris and Linux</h5></caption><colgroup align="left" span="3"><col width="150"><col width="150"><col width="150"></colgroup><thead><TR><th class="bottomBorder thead" scope="col" align="left" valign="top"><p class="docText">Solaris</p></th><th class="bottomBorder thead" scope="col" align="left" valign="top"><p class="docText">Linux</p></th><th class="bottomBorder thead" scope="col" align="left" valign="top"><p class="docText">Description</p></th></TR></thead><TR><TD class="docTableCell" align="left" valign="top"><p class="docText"><tt>semctl</tt></P></TD><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>semctl</tt><sup class="docFootnote"><a class="docLink" href="#ch04tn35">[35]</a></sup></p></td><TD class="docTableCell" align="left" valign="top"><p class="docText">Semaphore control operation</P></TD></TR><TR><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>semget</tt></P></td><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>semget</tt></P></TD><td class="docTableCell" align="left" valign="top"><p class="docText">Get set of semaphores</p></td></tr><TR><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>semids</tt></p></td><td class="docTableCell" align="left" valign="top"><p class="docText">N/A</P></TD><td class="docTableCell" align="left" valign="top"><p class="docText">Discover all semaphore IDs</p></td></tr><tr><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>semop</tt></p></td><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>semop</tt></p></td><td class="docTableCell" align="left" valign="top"><p class="docText">Semaphore operation</p></td></TR><tr><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>semtimedop</tt></p></TD><TD class="docTableCell" align="left" valign="top"><p class="docText"><tt>semtimedop</tt></P></TD><TD class="docTableCell" align="left" valign="top"><p class="docText">Semaphore operation with time limit</p></td></tr></table></P><BR><blockquote><p class="docFootnote"><sup><a name="ch04tn35">[35]</a></sup> See the text following the table.</P></blockquote>
<p class="docText">Here is how Linux defines <tt>struct semid_ds</tt> (which is different from Solaris):</P>
<div class="docText"><pre>struct semid_ds
{
 struct ipc_perm sem_perm;       /* operation permission struct */
 __time_t sem_otime;          /* last semop() time */
 unsigned long int __unused1;
 __time_t sem_ctime;          /* last time changed by semctl() */
 unsigned long int __unused2;
 unsigned long int sem_nsems;     /* number of semaphores in set */
 unsigned long int __unused3;
 unsigned long int __unused4;
};
</pre></div><BR>
<p class="docText">Linux programmers should define a union like the following to use for the fourth argument of the <tt>semctl</tt> function:<a name="d0e32338"></a><a name="d0e32339"></a><a name="d0e32340"></a></p>
<div class="docText"><pre>union semun
{
 int val;                    /* value for SETVAL */
 struct semid_ds *buf;       /* buffer for IPC_STAT &amp; IPC_SET */
 unsigned short int *array;  /* array for GETALL &amp; SETALL */
 struct seminfo *__buf;      /* buffer for IPC_INFO */
};
</pre></div><BR>

<a name="ch04lev3sec8"></a>
<h5 id="title-IDAU54WQ" class="docSection3Title">4.13.2.8. <a name="iddle1642"></a><a name="iddle1814"></a>System V Shared Memory</h5>
<p class="docText"><a class="docLink" href="#ch04table27">Table 4-27</a> compares System V shared memory interfaces in <a name="iddle2154"></a><a name="iddle2435"></a>Solaris and Linux.</P>
<a name="ch04table27"></a><P><table cellspacing="0" FRAME="hsides" RULES="groups" cellpadding="5"><caption><h5 class="docTableTitle">Table 4-27. Comparison Between System V Shared Memory Interfaces in Solaris and Linux</h5></caption><colgroup align="left" span="3"><col width="150"><col width="150"><col width="200"></colgroup><thead><tr><th class="bottomBorder thead" scope="col" align="left" valign="top"><p class="docText">Solaris</p></th><th class="bottomBorder thead" scope="col" align="left" valign="top"><p class="docText">Linux</P></th><th class="bottomBorder thead" scope="col" align="left" valign="top"><p class="docText">Description</p></th></tr></thead><tr><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>shmat</tt></P></TD><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>shmat</tt> (see comment following this table)</p></td><td class="docTableCell" align="left" valign="top"><p class="docText">Attach the shared memory segment to the data segment of the calling process</p></td></tr><tr><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>shmctl</tt></p></td><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>shmctl</tt></p></td><TD class="docTableCell" align="left" valign="top"><p class="docText">Shared memory control</p></td></tr><TR><TD class="docTableCell" align="left" valign="top"><p class="docText"><tt>shmdt</tt></P></TD><TD class="docTableCell" align="left" valign="top"><p class="docText"><tt>shmdt</tt></p></td><td class="docTableCell" align="left" valign="top"><p class="docText">Detach the shared memory segment</P></TD></TR><TR><TD class="docTableCell" align="left" valign="top"><p class="docText"><tt>shmget</tt></p></TD><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>shmget</tt></p></TD><TD class="docTableCell" align="left" valign="top"><p class="docText">Get shared memory segment identifier</p></td></tr><tr><TD class="docTableCell" align="left" valign="top"><p class="docText"><tt>shmids</tt></p></td><td class="docTableCell" align="left" valign="top"><p class="docText">N/A</p></TD><TD class="docTableCell" align="left" valign="top"><p class="docText">Discover all shared memory identifiers</p></td></tr></table></p><br>
<p class="docText">There is a slight difference in the possible values of the third argument in the function <tt>shmat</tt>.</p>
<div class="docText"><pre>void *shmat(int shmid, const void *shmaddr, int <a name="iddle2159"></a>shmflg);
</pre></div><br>
<p class="docText"><a class="docLink" href="#ch04table28">Table 4-28</a> compares the value of <tt>shmflg</tt> available in Solaris and Linux.<a name="d0e32542"></a></p>
<a name="ch04table28"></a><p><table cellspacing="0" FRAME="hsides" RULES="groups" cellpadding="5"><caption><h5 class="docTableTitle">Table 4-28. Comparison Between shmflg in Solaris and Linux</h5></caption><colgroup align="left" span="3"><col width="150"><col width="150"><col width="200"></colgroup><thead><tr><th class="bottomBorder thead" scope="col" align="left" valign="top"><p class="docText">shmflg in Solaris</p></th><th class="bottomBorder thead" scope="col" align="left" valign="top"><p class="docText">shmflg in Linux</p></th><th class="bottomBorder thead" scope="col" align="left" valign="top"><p class="docText">Description</P></th></tr></thead><tr><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>SHM_RDONLY</tt></P></TD><TD class="docTableCell" align="left" valign="top"><p class="docText"><tt>SHM_RDONLY</tt></P></TD><td class="docTableCell" align="left" valign="top"><p class="docText">Attach read-only (else read-write)</p></td></TR><TR><TD class="docTableCell" align="left" valign="top"><p class="docText"><tt>SHM_RND</tt></P></TD><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>SHM_RND</tt></P></td><td class="docTableCell" align="left" valign="top"><p class="docText">Round attach address to <tt>SHMLBA</tt></P></TD></tr><tr><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>SHM_SHARE_MMU</tt></p></TD><td class="docTableCell" align="left" valign="top"><p class="docText">N/A</p></td><td class="docTableCell" align="left" valign="top"><p class="docText">Share VM resources such as page table</P></TD></tr><tr><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>SHM_PAGEABLE</tt></p></td><td class="docTableCell" align="left" valign="top"><p class="docText">N/A</p></td><td class="docTableCell" align="left" valign="top"><p class="docText">Share VM resources and the dynamic shared memory framework is created</p></td></tr><tr><td class="docTableCell" align="left" valign="top"><p class="docText">N/A</P></td><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>SHM_REMAP</tt></p></TD><TD class="docTableCell" align="left" valign="top"><p class="docText">Take over region on attach</P></TD></TR></table></p><br>
<p class="docText">In Linux, you can request a shared memory segment to be supported by large page by specifying <tt>SHM_HUGETLB</tt> in the <tt>shmflg</tt> argument of the function <tt>shmget</tt>.<a name="d0e32678"></a><a name="d0e32679"></a><a name="d0e32680"></a><a name="d0e32681"></a><a name="d0e32682"></a></p>
<p class="docText">In Solaris, shared memory segments must be explicitly removed (by using the <tt>shmctl</tt> function) when there is no reference to them. In Linux, you can specify that the shared memory segment be removed on last detach.</P>


<a name="ch04lev2sec52"></a>
<H4 id="title-IDAMFBXQ" class="docSection2Title">4.13.3. <a name="iddle1816"></a><a name="iddle1847"></a>Memory Placement Optimization (<a name="iddle1069"></a><a name="iddle2258"></a>MPO)</H4>
<p class="docText">Solaris's MPO<sup class="docFootnote"><a class="docLink" href="#ch04fn36">[36]</a></sup> provides performance improvements on systems in which each CPU accesses some area of memory more quickly than others. This architecture is also known as <a name="iddle1885"></a>NUMA (<a name="iddle1876"></a>Non-Uniform Memory Access)<a name="d0e32735"></a><a name="d0e32736"></a>. The essence of the NUMA architecture is the presence of multiple memory subsystems, as opposed to a single one on an SMP system. With MPO, Solaris can recognize the memory locality effects by ensuring that memory is as <span class="docEmphasis">close</span> as possible to the processors that access it while still maintaining balance in the system to avoid bottlenecks. Solaris also provides several APIs<sup class="docFootnote"><a class="docLink" href="#ch04fn37">[37]</a></sup> for developers who want to further optimize application performance through MPO. Some of those APIs include <tt>getcpuid, gethomelgroup, lgrp_affinity_get, lgrp_affinity_set, lgrp_children, lgrp_init, lgrp_mem_size</tt>, and <tt>lgrp_view</tt>.<a name="d0e32752"></a></P><blockquote><p class="docFootnote"><sup><a name="ch04fn36">[36]</a></sup> <a class="docLink" target="_blank" href="http://www.sun.com/software/solaris/performance.jsp">www.sun.com/software/solaris/performance.jsp</a></P></blockquote><blockquote><p class="docFootnote"><sup><a name="ch04fn37">[37]</a></sup> <a class="docLink" target="_blank" href="http://iforce.sun.com/protected/solaris10/adoptionkit/tech/mpo/mpo_man.html">http://iforce.sun.com/protected/solaris10/adoptionkit/tech/mpo/mpo_man.html</a></p></blockquote>
<p class="docText">The Linux community has made a tremendous effort to make the Linux kernel NUMA-aware. The 2.6 kernel features NUMA awareness in the scheduler so that the majority of processes execute in the <span class="docEmphasis">local</span> memory. With the advent of IBM Power5 and AMD Opteron systems, NUMA is becoming more prevalent in the marketplace, used in many servers, entry-level or high-end. For more information about how NUMA is supported in the kernel, consult &quot;Linux on NUMA Systems&quot; (<a class="docLink" target="_blank" href="http://www.kernel.org/pub/linux/kernel/people/mbligh/presentations/OLS2004-numa_paper.pdf">www.kernel.org/pub/linux/kernel/people/mbligh/presentations/OLS2004-numa_paper.pdf</a>). Enterprise-level Linux distributions such as SuSE SLES9 and Red Hat EL4 are preconfigured with NUMA support. Applications do not require any code changes to take advantage of the NUMA support provided in the Linux kernel. If the application binds its processes to a processor, the kernel attempts to allocate memory <span class="docEmphasis">closest</span> to those processes. However, if programmers would like to take an extra step to further optimize the performance of their applications, they can also use the NUMA API to instruct the kernel where memory should be allocated and how. The Linux NUMA API enables applications to assign specific allocation behaviors (<span class="docEmphasis">policies</span>) to regions of their own virtual memory space. There is also a user-space <tt>numactl</tt> utility that controls NUMA policy for processes or shared memory.<a name="d0e32773"></a><a name="d0e32774"></a><a name="d0e32775"></a></P>

<a name="ch04lev2sec53"></a>
<h4 id="title-IDA5JBXQ" class="docSection2Title">4.13.4. <a name="iddle2283"></a><a name="iddle2516"></a>vfstab</h4>
<p class="docText">Solaris filesystem routines employ <tt>vfstab</tt> structures and contain <tt>vfs</tt> in the function name, such as <tt>getvfsent</tt>. Linux provides equivalent interfaces, but the routines use <tt>fstab</tt> structures and contain <tt>fs</tt> in the routine name, such as <tt>getfsent</tt>. <tt>vfstab</tt> on Solaris is defined in /usr/include/sys/vfstab.h. The definition of <tt>fstab</tt> on Linux is in /usr/include/fstab.h.<a name="d0e32819"></a><a name="d0e32820"></a></P>

<a name="ch04lev2sec54"></a>
<H4 id="title-IDA0LBXQ" class="docSection2Title">4.13.5. <a name="iddle2021"></a><a name="iddle2263"></a>posix_spawn() and <a name="iddle2022"></a><a name="iddle2264"></a>posix_spawnp()</h4>
<p class="docText">In Solaris 10, these calls are implemented as a <tt>vfork/exec</tt> combination. That is, the fork handlers are not run when <tt>posix_spawn</tt> or <tt>posix_spawnp</tt> is called. These two calls have been available in Linux since <tt>glibc</tt> version 2.2 as user-level implementations. These calls use <tt>vfork</tt> if the <tt>POSIX_SPAWN_USEVFORK</tt> flag is set.<sup class="docFootnote"><a class="docLink" href="#ch04fn38">[38]</a></sup> You can find more information about <tt>posix_spawn</tt> and <tt>posix_spawnp</tt> at <a class="docLink" target="_blank" href="http://www.opengroup.org/onlinepubs/009695399/functions/posix_spawn.html">www.opengroup.org/onlinepubs/009695399/functions/posix_spawn.html</a>.<a name="d0e32891"></a><a name="d0e32892"></a><a name="d0e32893"></a><a name="d0e32894"></a></p><blockquote><p class="docFootnote"><sup><a name="ch04fn38">[38]</a></sup> The discussion on using <tt>vfork</tt> in <tt>posix_spawn()</tt> can also be found at <a class="docLink" target="_blank" href="http://sources.redhat.com/bugzilla/show_bug.cgi?id=378">http://sources.redhat.com/bugzilla/show_bug.cgi?id=378</a>.</p></blockquote>

<a name="ch04lev2sec55"></a>
<h4 id="title-IDAGPBXQ" class="docSection2Title">4.13.6. <a name="iddle1938"></a><a name="iddle2260"></a>plock()</H4>
<p class="docText">The Linux equivalent of the <tt>plock</tt> function is <tt><a name="iddle1840"></a>mlock</tt><a name="d0e32923"></a>. The <tt>mlock</tt> function call disables paging for the memory in the range starting at <tt>addr</tt> with length <tt>len</tt> bytes. All pages that contain a part of the specified memory range are guaranteed to be resident in RAM when the <tt>mlock</tt> call returns successfully.<a name="d0e32937"></a><a name="d0e32938"></a></p>

<a name="ch04lev2sec56"></a>
<h4 id="title-IDAPRBXQ" class="docSection2Title">4.13.7. <a name="iddle2284"></a><a name="iddle2524"></a>waitpid()</h4>
<p class="docText">This call suspends execution of the current process until a child as specified by one of the arguments has exited, or until a signal is delivered whose action is to terminate the current process or to call a signal-handling function. <a class="docLink" href="#ch04table29">Table 4-29</a> compares the options available for this call in Solaris and Linux.<a name="d0e32964"></a></p>
<a name="ch04table29"></a><P><table cellspacing="0" FRAME="hsides" RULES="groups" cellpadding="5"><caption><H5 class="docTableTitle">Table 4-29. Comparison of the Option for waitpid() Between Solaris and Linux</h5></caption><colgroup align="left" span="3"><col width="150"><col width="150"><col width="200"></colgroup><thead><tr><th class="bottomBorder thead" scope="col" align="left" valign="top"><p class="docText">Solaris</p></th><th class="bottomBorder thead" scope="col" align="left" valign="top"><p class="docText">Linux</p></th><th class="bottomBorder thead" scope="col" align="left" valign="top"><p class="docText">Description</p></th></tr></thead><tr><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>WNOHANG</tt></p></td><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>WNOHANG</tt></p></td><td class="docTableCell" align="left" valign="top"><p class="docText">Return immediately if status is not immediately available for one of the child processes specified by <span class="docEmphasis"><tt>pid</tt></span>.</P></td></tr><tr><TD class="docTableCell" align="left" valign="top"><p class="docText"><tt>WUNTRACED</tt></P></TD><TD class="docTableCell" align="left" valign="top"><p class="docText"><tt>WUNtrACED</tt></p></td><TD class="docTableCell" align="left" valign="top"><p class="docText">The status of any specified child processes that are stopped, and whose status has not yet been reported since they stopped, is also reported to the calling process.</P></TD></TR><TR><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>WCONTINUED</tt></P></td><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>WCONTINUED</tt> (since Linux 2.6.10)</P></TD><td class="docTableCell" align="left" valign="top"><p class="docText">Wait for processes continued.</p></td></tr><TR><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>WNOWAIT</tt></p></td><td class="docTableCell" align="left" valign="top"><p class="docText">N/A</P></TD><td class="docTableCell" align="left" valign="top"><p class="docText">Keep the process whose status is returned in a waitable state. The process may be waited for again with the identical result.</p></td></tr><tr><td class="docTableCell" align="left" valign="top"><p class="docText">N/A</p></td><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>__WCLONE</tt></p></td><td class="docTableCell" align="left" valign="top"><p class="docText">(Linux-specific option) Wait for the clone children only.</p></td></TR><tr><td class="docTableCell" align="left" valign="top"><p class="docText">N/A</p></TD><TD class="docTableCell" align="left" valign="top"><p class="docText"><tt>__WALL</tt></P></TD><TD class="docTableCell" align="left" valign="top"><p class="docText">(Linux-specific option) Wait for all children, regardless of type (clone or nonclone).</p></td></tr><TR><TD class="docTableCell" align="left" valign="top"><p class="docText">N/A</P></TD><TD class="docTableCell" align="left" valign="top"><p class="docText"><tt>__WNOTHREAD</tt></p></TD><td class="docTableCell" align="left" valign="top"><p class="docText">(Linux-specific option) Do not wait for children of other threads in the same thread group.</p></TD></TR></table></p><br>
<p class="docText">In Solaris, if the calling process has <tt>SA_NOCLDWAIT</tt> set or has <tt><a name="iddle2164"></a>SIGCHLD</tt> set to <tt>SIG_IGN</tt> and the process has no unwaited children that were transformed into zombie processes, it blocks until all of its children terminate, and <tt>waitpid()</tt> fails and sets <tt>errno</tt> to <tt>ECHILD</tt><a name="d0e33147"></a>. Linux 2.6 conforms to this behavior.</p>
<p class="docText">In Linux 2.4, if a <tt>wait()</tt> or <tt>waitpid()</tt> call is made while <tt>SIGCHLD</tt> is being ignored, the call behaves just as though <tt>SIGCHLD</tt> were not being ignored. That is, the call blocks until the next child terminates and then returns the PID and status of that child.</p>
<p class="docText">The <tt>waitid()</tt> system call (available since Linux 2.6.9) provides better control over which child state changes to wait for.<a name="d0e33171"></a></P>


<a href="9001536.html"><img src="images/pixel.jpg" alt="" width="1" height="1" border="0"></a></TD></TR></table>
<br>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<tr><td><div STYLE="MARGIN-LEFT: 0.15in;">
<a href=ch04lev1sec12.html><img src="images/prev.gif" width="60" height="17" border="0" align="absmiddle" alt="Previous Page"></a>
<td align="right"><div STYLE="MARGIN-LEFT: 0.15in;">
<a href=ch04lev1sec14.html><img src="images/next.gif" width="60" height="17" border="0" align="absmiddle" alt="Next Page"></a>
</div></td></tr></table>
</body></html>