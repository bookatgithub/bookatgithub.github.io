<html>
<META http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<head>
<title>Section 5.11.&nbsp; Selected AIX/Linux System API Comparisons</title>
<link rel="STYLESHEET" type="text/css" href="images/style.css">
<link rel="STYLESHEET" type="text/css" href="images/docsafari.css">
</head>
<body>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<tr><td><div STYLE="MARGIN-LEFT: 0.15in;">
<a href=ch05lev1sec10.html><img src="images/prev.gif" width="60" height="17" border="0" align="absmiddle" alt="Previous Page"></a>
<td align="right"><div STYLE="MARGIN-LEFT: 0.15in;">
<a href=ch05lev1sec12.html><img src="images/next.gif" width="60" height="17" border="0" align="absmiddle" alt="Next Page"></a>
</div></td></tr></table>
<br><table width="100%" border="0" cellspacing="0" cellpadding="0"><tr><TD valign="top"><a name="ch05lev1sec11"></a>

<H3 id="title-IDA0YRPF" class="docSection1Title">5.11. Selected <a name="iddle2321"></a>AIX/Linux System API Comparisons</H3>
<p class="docText">This section takes a selected set of system APIs and compares and contrasts them with AIX and Linux in a man-page format. The APIs were chosen based on how much difference existed between AIX and Linux. Unlike in the previous section, in which the only differences that existed were <span class="docEmphasis"><tt>ERRNO</tt></span> returns, the APIs listed in this section show differences that go beyond just <span class="docEmphasis"><tt>ERRNOs</tt></span>. In some cases, the information returned by AIX and Linux differs significantly and must be addressed early during the porting cycle.<a name="d0e40783"></a></P>
<p class="docText">Like a man page, each API listed in this section lists the API name, prototype for AIX and Linux, parameter listing, and the return value of the routine. In addition, a &quot;Detail Comparison&quot; section is included in each API section explaining the differences in the API between AIX and Linux (with examples and code snippets). If the API is not compatible between AIX and Linux, it is clearly marked with a &quot;**Not compatible**&quot; identifier. In such cases, examples and analytical reasoning are given as to why it is not compatible. Some are identified as &quot;**Compatible**&quot; but with differences, which will also be explained.</P>
<p class="docText">In some cases, additional operating system-specific (that is, AIX or Linux) information pertinent to the porting process follows the &quot;Detail Comparison&quot; section.</p>
<a name="ch05lev2sec17"></a>
<h4 id="title-IDAB0RPF" class="docSection2Title">5.11.1. <a name="iddle1406"></a><a name="iddle2330"></a>getfsent(), getfsfile(), getfstype(), <a name="iddle1408"></a>getfsspec()</h4>
<p class="docText">These calls retrieve information about a filesystem. See &quot;Additional Data: Linux-Specific&quot; for Linux-specific information.</P>
<a name="ch05lev3sec2"></a>
<H5 id="title-IDAN1RPF" class="docSection3Title">5.11.1.1. AIX Prototype</H5>
<div class="docText"><pre>#include &lt;fstab.h&gt;
struct fstab *getfsent();
struct fstab *<a name="iddle2332"></a>getfsspec ( char *special );
struct fstab *<a name="iddle1407"></a><a name="iddle2331"></a>getfsfile( char *file );
struct fstab *<a name="iddle1409"></a><a name="iddle2333"></a>getfstype( char* type );
void setfsent( );
void endfsent( );
</pre></div><BR>

<a name="ch05lev3sec3"></a>
<H5 id="title-IDA43RPF" class="docSection3Title">5.11.1.2. Linux Prototype</h5>
<div class="docText"><pre>#include &lt;fstab.h&gt;
void endfsent(void);
struct fstab *getfsent(void);
struct fstab *getfsfile(const char *mount_point);
struct fstab *getfsspec(const char *special_file);
int setfsent(void);
</pre></div><BR>

<a name="ch05lev3sec4"></a>
<h5 id="title-IDAS4RPF" class="docSection3Title">5.11.1.3. Detail Comparison</h5>
<p class="docText">**Not Compatible**</P>
<p class="docText">AIX and Linux implement their filesystem differently, and as a result different information must be returned. Both platforms return an <tt>fstab</tt> struct, but information is different.</P>
<p class="docText"><span class="docEmphasis">AIX</span></p>
<div class="docText"><pre>struct fstab{
    char *fs_spec;      /* block special device name */
    char *fs_file;      /* file system path prefix */
    char *fs_type;      /* read/write, etc see above defines */
    int fs_check;       /* true=0, false=-1, else "check" val */
    int fs_freq;        /* not used */
    int fs_passno;      /* not used */
};
</pre></div><br>
<p class="docText"><span class="docEmphasis">Linux</span></p>
<div class="docText"><pre>struct fstab {
   char *fs_spec;         /* block device name */
   char *fs_file;         /* mount point */
   char *fs_vfstype;      /* filesystem type */
   char *fs_mntops;       /* mount options */
   const char *fs_type;   /* rw/rq/ro/sw/xx option */
   int fs_freq;           /* dump frequency, in days */
   int fs_passno;         /* pass number on parallel dump */
};
</pre></div><br>

<a name="ch05lev3sec5"></a>
<H5 id="title-IDAZ5RPF" class="docSection3Title">5.11.1.4. Additional Data: Linux-Specific</h5>
<p class="docText">Here the field <span class="docEmphasis"><tt>fs_type</tt></span> contains (on a *BSD system) one of the five strings: <tt>rw, rq, ro, sw, xx</tt> (read-write, read-write with quotas, read-only, swap, ignore).</p>
<p class="docText">The function <tt>setfsent()</tt> opens the file when required and positions it at the first line.</p>
<p class="docText">The function <tt>getfsent()</tt> parses the next line from the file (after opening it when required).</p>
<p class="docText">The function <tt>endfsent()</tt> closes the file when required.</P>
<p class="docText">The function <tt>getfsspec()</tt> searches the file from the start and returns the first entry found for which the <tt>fs_spec</tt> field matches the <tt>special_file</tt> argument.<a name="d0e40961"></a><a name="d0e40962"></a><a name="d0e40963"></a><a name="d0e40964"></a><a name="d0e40965"></a><a name="d0e40966"></a><a name="d0e40967"></a><a name="d0e40968"></a></P>
<p class="docText">The function <tt>getfsfile()</tt> searches the file from the start and returns the first entry found for which the <tt>fs_file</tt> field matches the <tt>mount_point</tt> argument.</p>

<a name="ch05lev3sec6"></a>
<h5 id="title-IDAYCSPF" class="docSection3Title">5.11.1.5. Return Value</h5>
<p class="docText">Upon success, the functions <tt>getfsent(), getfsfile()</tt>, and <tt>getfsspec()</tt> return a pointer to a struct <tt>fstab</tt>, whereas <tt>setfsent()</tt> returns 1. Upon failure or end of file, these functions return NULL and 0, respectively.</p>


<a name="ch05lev2sec19"></a>
<h4 id="title-IDAODSPF" class="docSection2Title">5.11.2. <a name="iddle1646"></a>ioctl()</h4>
<p class="docText">The <tt>ioctl</tt><span class="docEmphStrong"></span> function manipulates the underlying device parameters of special files. In particular, many operating characteristics of character special files (for example, terminals) may be controlled with <tt>ioctl</tt> requests. The argument <tt>d</tt> must be an open file descriptor.</p>
<p class="docText">An <a name="iddle2335"></a>ioctl request has encoded in it whether the argument is an in parameter or out parameter and the size of the argument <span class="docEmphasis"><tt>argp</tt></span> in bytes. Macros and defines used in specifying an <tt>ioctl</tt> request are located in the file sys/ioctl.h.</p>
<a name="ch05lev3sec7"></a>
<h5 id="title-IDACFSPF" class="docSection3Title">5.11.2.1. AIX Prototype</h5>
<div class="docText"><pre>#include &lt;sys/ioctl.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;unistd.h&gt;
int ioctl (int <span class="docEmphasis">FileDescriptor</span>, int <span class="docEmphasis">Command</span>, void *<span class="docEmphasis">Argument</span>);
</pre></div><br>

<a name="ch05lev3sec8"></a>
<h5 id="title-IDA0FSPF" class="docSection3Title">5.11.2.2. Linux Prototype</h5>
<div class="docText"><pre>#include &lt;sys/ioctl.h&gt;
int ioctl(int <span class="docEmphasis">d</span>, int <span class="docEmphasis">request</span>, ...)
</pre></div><br>

<a name="ch05lev3sec9"></a>
<H5 id="title-IDAQGSPF" class="docSection3Title">5.11.2.3. Detail Comparison</h5>
<p class="docText">**Not Compatible**</p>
<p class="docText">In Linux, command values are generally driver-specific. This function is not considered portable.</p>
<a name="ch05lev4sec1"></a>
<H5 id="title-IDA5GSPF" class="docSection4Title">AIX</H5>
<p class="docText">In AIX, the <tt>ioctl</tt> subroutine performs a variety of control operations on the object associated with the specified open file descriptor. This function is typically used with character or block special files and sockets generic device support such as the termio general terminal interface.</P>
<p class="docText"><span class="docEmphasis">Parameters</span></P>
<UL><li><p class="docText"><span class="docEmphStrong"><tt>FileDescriptor</tt>.</span> Specifies the open file descriptor for which the control operation is to be performed.</p></li><LI><p class="docText"><span class="docEmphStrong"><tt>Command</tt>.</span> Specifies the control function to be performed. The value of this parameter depends on which object is specified by the <tt>FileDescriptor</tt> parameter.</P></LI><LI><p class="docText"><span class="docEmphStrong"><tt>Argument</tt>.</span> Specifies additional information required by the function requested in the <tt>Command</tt>. The data type of this parameter (a <tt>void</tt> pointer) is object-specific and is typically used to point to an object device-specific data structure. However, in some device-specific instances, this parameter is used as an integer. This parameter is passed on to the object associated with the specified open file descriptor. Although normally of type <tt>int</tt>, this parameter can be used as a pointer to a device-specific structure for some devices.</P></li></UL>
<p class="docText"><span class="docEmphasis">Linux</span></p>
<p class="docText">The <tt>ioctl</tt> function manipulates the underlying device parameters of special files. In particular, many operating characteristics of character special files (for example, terminals) may be controlled with <tt>ioctl</tt> requests.</p>
<UL><LI><p class="docList">Argument <span class="docEmphasis">d</span>. Must be an open file descriptor.</p></li><li><p class="docList"><span class="docEmphasis">Request</span>. The second argument is a device-dependent request code.</p></LI><li><p class="docList">Third argument(s). The third argument is an untyped pointer to memory. It is traditionally <tt>char *</tt><span class="docEmphasis"><tt>argp</tt></span> (from the days before <tt>void *</tt> was valid C).</p></li></ul>
<p class="docText">An <tt>ioctl</tt> request has encoded in it whether the argument is an <span class="docEmphasis">in</span> parameter or <span class="docEmphasis">out</span> parameter, and the size of the argument <span class="docEmphasis">argp</span> in bytes. Macros and defines used in specifying an <tt>ioctl</tt> request are located in the file sys/ioctl.h.<a name="d0e41218"></a><a name="d0e41219"></a></P>


<a name="ch05lev3sec10"></a>
<H5 id="title-IDA5KSPF" class="docSection3Title">5.11.2.4. Return Value</h5>
<p class="docText">Usually, on success, 0 is returned. A few <tt>ioctl</tt>s use the return value as an output parameter and return a nonnegative value on success. On error, 1 is returned, and <span class="docEmphasis"><tt>ERRNO</tt></span> is set appropriately.</p>

<a name="ch05lev3sec11"></a>
<h5 id="title-IDARLSPF" class="docSection3Title">5.11.2.5. Errors</h5>
<ul><li><p class="docText"><span class="docEmphStrong"><tt>EBADF</tt>.</span> <span class="docEmphasis"><tt>d</tt></span> is not a valid descriptor.</p></li><li><p class="docText"><span class="docEmphStrong"><tt>EFAULT</tt>.</span> <span class="docEmphasis"><tt>argp</tt></span> references an inaccessible memory area.</p></li><li><p class="docText"><span class="docEmphStrong"><tt>ENOTTY</tt>.</span> <span class="docEmphasis"><tt>d</tt></span> is not associated with a character special device.</p></li><LI><p class="docText"><span class="docEmphStrong"><tt>ENOTTY</tt>.</span> The specified request does not apply to the kind of object that the descriptor <span class="docEmphasis"><tt>d</tt></span> references.</p></li><li><p class="docText"><span class="docEmphStrong"><tt>EINVAL</tt>.</span> Request or <span class="docEmphasis"><tt>argp</tt></span> is not valid.</P></LI></UL>

<a name="ch05lev3sec12"></a>
<H5 id="title-IDADOSPF" class="docSection3Title">5.11.2.6. ERRNO(s) Not Supported in Linux</H5>
<ul><li><p class="docText"><span class="docEmphStrong"><tt>EINTR</tt>.</span> A signal was caught, and the process had not enabled restartable subroutines for the signal.</p></LI><LI><p class="docText"><span class="docEmphStrong"><tt>ENODEV</tt>.</span> The <tt>FileDescriptor</tt> parameter is associated with a valid character or block special file, but the supporting device driver does not support the <tt>ioctl</tt> function.</P></LI><LI><p class="docText"><span class="docEmphStrong"><tt>ENXIO</tt>.</span> The <tt>FileDescriptor</tt> parameter is associated with a valid character or block special file, but the supporting device driver is not in the configured state.</p></LI></ul>


<a name="ch05lev2sec20"></a>

<h4 id="title-IDA2PSPF" class="docSection2Title">5.11.3. <a name="iddle2098"></a><a name="iddle2353"></a>read(), <a name="iddle2531"></a>write()</H4>
<p class="docText">To read from a file descriptor into a buffer or to <a name="iddle2370"></a>write to a file descriptor from a buffer, use the <tt>read()</tt>/<tt>write()</tt> commands.</P>
<a name="ch05lev3sec13"></a>
<h5 id="title-IDA5RSPF" class="docSection3Title">5.11.3.1. AIX Prototype</h5>
<div class="docText"><pre>#include &lt;unistd.h&gt;
ssize_t read (int <span class="docEmphasis">FileDescriptor</span>, void *<span class="docEmphasis">Buffer</span>, size_t <span class="docEmphasis">NBytes</span>);
ssize_t write(int <span class="docEmphasis">fd</span>, const void *<span class="docEmphasis">buf</span>, size_t <span class="docEmphasis">NBytes</span>);
</pre></div><br>

<a name="ch05lev3sec14"></a>
<h5 id="title-IDA3SSPF" class="docSection3Title">5.11.3.2. Linux Prototype</H5>
<div class="docText"><pre>#include &lt;unistd.h&gt;
ssize_t read(int <span class="docEmphasis">fd</span>, void *<span class="docEmphasis">buf</span>, size_t <span class="docEmphasis">NBytes</span>);
ssize_t write(int <span class="docEmphasis">fd</span>, const void *<span class="docEmphasis">buf</span>, size_t NBytes;
</pre></div><br>

<a name="ch05lev3sec15"></a>
<h5 id="title-IDAZTSPF" class="docSection3Title">5.11.3.3. Detail Comparison</h5>
<p class="docText">**Compatible**</p>
<p class="docText">Functions are source-compatible, but <tt>ERROR</tt> return values differ. Refer to the &quot;Errors&quot; section that follows. On most UNIX systems, <tt>O_NONBLOCK</tt> is used on socket descriptors, in which read returns 1 and sets <span class="docEmphasis"><tt>ERRNO</tt></span> <tt>EAGAIN</tt>,<span class="docEmphStrong"></span> which signifies to the user that additional data is available on the descriptor. Linux, on the other hand, considered current available filesystems and disks to be fast enough and deemed <tt>O_NONBLOCK</tt> unnecessary. As a result, this <tt>O_NONBLOCK</tt><span class="docEmphStrong"></span> may not be implemented on some flavors of Linux.</P>

<a name="ch05lev3sec16"></a>
<H5 id="title-IDA0USPF" class="docSection3Title">5.11.3.4. Additional Info: AIX/Linux</h5>
<ul><li><p class="docText"><span class="docEmphStrong"><tt>FileDescriptor</tt></span><span class="docEmphasis">.</span> A file descriptor identifying the object to be read and written to.</p></li><li><p class="docText"><span class="docEmphStrong"><tt>Buffer</tt>.</span> Points to the buffer.</p></li><li><p class="docText"><span class="docEmphStrong"><tt>NBytes</tt>.</span> Specifies the number of bytes associated with the file descriptor for read or write.</p></li><li><p class="docText"><span class="docEmphStrong"><tt>FileDescriptor</tt>.</span> In the case of a write, identifies the size of the buffer.</p></li></UL>
<p class="docText">If <span class="docEmphasis"><tt>NBytes</tt></span> is 0, <tt>read()</tt> returns 0 and has no other results. If <span class="docEmphasis"><tt>NBytes</tt></span> is greater than <tt>SSIZE_MAX</tt>, the result is unspecified.</p>

<a name="ch05lev3sec17"></a>
<h5 id="title-IDA5WSPF" class="docSection3Title">5.11.3.5. Linux Restrictions</h5>
<p class="docText">On NFS filesystems, reading small amounts of data updates the timestamp only the first time; subsequent calls may not do so. This is caused by client-side attribute caching, because most if not all NFS clients leave <tt>atime</tt> updates to the server, and client-side reads satisfied from the client's cache will not cause <tt>atime</tt> updates on the server because there are no server-side reads. UNIX semantics can be obtained by disabling client-side attribute caching, but in most situations this substantially increases server load and decreases performance.</P>

<a name="ch05lev3sec18"></a>
<H5 id="title-IDAQXSPF" class="docSection3Title">5.11.3.6. Return Value</H5>
<p class="docText">On success, the number of bytes <a name="iddle1296"></a>read is returned (0 indicates end of file), and the file position is advanced by this number<a name="d0e41596"></a>. It is not an <a name="iddle1309"></a>error if this number is smaller than the number of bytes requested.<a name="d0e41605"></a> This may happen, for example, because fewer bytes are actually available right now (maybe because we were close to end of file, or because we are reading from a pipe or a terminal), or because <tt>read()</tt> was interrupted by a signal. On error, 1 is returned, and <span class="docEmphasis"><tt>ERRNO</tt></span> is set appropriately. In this case, it is left unspecified whether the file position (if any) changes.</P>

<a name="ch05lev3sec19"></a>
<H5 id="title-IDAJZSPF" class="docSection3Title">5.11.3.7. Errors</h5>
<ul><li><p class="docText"><span class="docEmphStrong"><tt>EINTR</tt>.</span> The call was interrupted by a signal before any data was read.</P></LI><LI><p class="docText"><span class="docEmphStrong"><tt>EAGAIN</tt>.</span> Nonblocking I/O has been selected using <tt>O_NONBLOCK</tt>, and no data was immediately available for reading.</P></LI><li><p class="docText"><span class="docEmphStrong"><tt>EIO</tt>.</span> I/O error. This happens, for example, when the process is in a background process group, tries to read from its controlling tty, and either it is ignoring or blocking <tt>SIGTTIN</tt> or its process group is orphaned. It may also occur when there is a low-level I/O error while reading from a disk or tape.</P></li><li><p class="docText"><span class="docEmphStrong"><tt>EISDIR</tt>.</span> <span class="docEmphasis"><tt>fd</tt></span> refers to a directory.</P></LI><li><p class="docText"><span class="docEmphStrong"><tt>EBADF</tt>.</span> <span class="docEmphasis"><tt>fd</tt></span> is not a valid file descriptor or is not open for reading.</p></li><li><p class="docText"><span class="docEmphStrong"><tt>EINVAL</tt>.</span> <span class="docEmphasis"><tt>fd</tt></span> is attached to an object that is unsuitable for reading.</P></li><li><p class="docText"><span class="docEmphStrong"><tt>EFAULT</tt>.</span> <span class="docEmphasis"><tt>buf</tt></span> is outside your accessible address space.</p></li></UL>
<p class="docText">Other errors may occur, depending on the object connected to <span class="docEmphasis"><tt>fd</tt></span>. POSIX allows a read that is interrupted after reading some data to return 1 (with <span class="docEmphasis"><tt>ERRNO</tt></span> set to <tt>EINTR</tt>) or to return the number of bytes already read.<a name="d0e41726"></a><a name="d0e41727"></a><a name="d0e41728"></a><a name="d0e41729"></a></P>
<a name="ch05lev4sec2"></a>
<h5 id="title-IDAP3SPF" class="docSection4Title">Conforming To</h5>
<p class="docText">SVr4, SVID, AT&amp;T, POSIX, X/OPEN, BSD 4.3</p>
<p class="docText"><span class="docEmphasis">ERRNO(s) Not Supported in Linux</span></p>
<ul><li><p class="docText"><span class="docEmphStrong"><tt>EBADMSG</tt>.</span> The file is a STREAM file that is set to control-normal mode, and the message waiting to be read includes a control part.</p></li><li><p class="docText"><span class="docEmphStrong"><tt>EDEADLK</tt>.</span> A deadlock would occur if the calling process were to sleep until the region to be read was unlocked.</p></li><li><p class="docText"><span class="docEmphStrong"><tt>EOVERFLOW</tt>.</span> An attempt was made to read from a regular file where <span class="docEmphasis"><tt>NBytes</tt></span> was greater than 0 and the starting offset was before the end of file and was greater than or equal to the offset maximum established in the open file description associated with file descriptor.</p></li><LI><p class="docText"><span class="docEmphStrong"><tt>ENXIO</tt>.</span> A request was made of a nonexistent device or the request was outside the capabilities of the device.</p></li><li><p class="docText"><span class="docEmphStrong"><tt>ESPIPE</tt>.</span> <span class="docEmphasis"><tt>fd</tt></span> is associated with a pipe or FIFO.</P></LI><LI><p class="docText"><span class="docEmphStrong"><tt>ETIMEDOUT</tt>.</span> The connection timed out.</P></LI></ul>



<a name="ch05lev2sec21"></a>
<h4 id="title-IDALATPF" class="docSection2Title">5.11.4. <a name="iddle1193"></a>confstr()</h4>
<p class="docText">The <tt>confstr()</tt> function provides a method for applications to get configuration-defined string values. Its use and purpose are similar to the <tt>sysconf()</tt> function; however, <tt>confstr()</tt> is used where string values (rather than numeric values) are returned.</P>
<a name="ch05lev3sec20"></a>
<H5 id="title-IDAGBTPF" class="docSection3Title">5.11.4.1. AIX Prototype</H5>
<div class="docText"><pre>#include &lt;unistd.h&gt;
size_t <a name="iddle2325"></a>confstr (int <span class="docEmphasis">name</span>, <span class="docEmphasis">char</span> * <span class="docEmphasis">buf</span>, size_t <span class="docEmphasis">len</span>);
</pre></div><BR>

<a name="ch05lev3sec21"></a>

<H5 id="title-IDARCTPF" class="docSection3Title">5.11.4.2. Linux Prototype</h5>
<div class="docText"><pre>#define _POSIX_C_SOURCE 2
or
#define _XOPEN_SOURCE
#include &lt;unistd.h&gt;

size_t confstr(int <span class="docEmphasis">name</span>, char * <span class="docEmphasis">buf</span>, size_t <span class="docEmphasis">len</span>);
</pre></div><BR>

<a name="ch05lev3sec22"></a>
<h5 id="title-IDAJDTPF" class="docSection3Title">5.11.4.3. Detail Comparison</h5>
<p class="docText">**Compatible**<a name="d0e41901"></a><a name="d0e41902"></a></P>
<p class="docText">Functions are source-compatible, but <tt>_POSIX_C_SOURCE</tt> or <tt>_XOPEN_SOURCE</tt> must be turned on in Linux.</P>


<a name="ch05lev2sec22"></a>
<h4 id="title-IDAIETPF" class="docSection2Title">5.11.5. <a name="iddle1891"></a><a name="iddle2345"></a>opendir()</h4>
<p class="docText">The <tt>opendir()</tt> function opens a directory stream corresponding to the directory named by the <span class="docEmphasis"><tt>name</tt></span> argument.</p>
<a name="ch05lev3sec23"></a>
<h5 id="title-IDAQFTPF" class="docSection3Title">5.11.5.1. AIX Prototype</H5>
<div class="docText"><pre>#include &lt;dirent&gt;
DIR *opendir(const char *<span class="docEmphasis">name</span>);
struct dirent *readdir (DIR *<span class="docEmphasis">DirectoryPointer</span>);
</pre></div><br>

<a name="ch05lev3sec24"></a>
<h5 id="title-IDAGGTPF" class="docSection3Title">5.11.5.2. Linux Prototype</h5>
<div class="docText"><pre>#include &lt;dirent.h&gt;
DIR *opendir(const char *<span class="docEmphasis">name</span>);
struct dirent *readdir(DIR *<span class="docEmphasis">dir</span>);
</pre></div><br>

<a name="ch05lev3sec25"></a>
<H5 id="title-IDA2GTPF" class="docSection3Title">5.11.5.3. Detail Comparison</H5>
<p class="docText">**Compatible**</p>
<p class="docText">Functions are source-compatible, but there are differences between the dirent structures in the two systems:</p>
<p><table cellspacing="0" FRAME="hsides" RULES="none" cellpadding="5"><colgroup align="left" span="2"><col width="150"><col width="350"></colgroup><thead></thead><tr><td class="bottomBorder" align="left" valign="top"><p class="docText">Linux<a name="d0e42007"></a><a name="d0e42008"></a></p></td><td class="bottomBorder" align="left" valign="top"><p class="docText">AIX</p></td></tr><tr><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>struct dirent</tt></p></TD><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>struct dirent</tt></p></td></TR><TR><TD class="docTableCell" align="left" valign="top"><p class="docText"><tt>d_ino</tt></P></TD><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>d_ino</tt></p></td></TR><TR><TD class="docTableCell" align="left" valign="top"><p class="docText"><tt>d_off</tt></P></TD><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>d_offset</tt></P></td></tr><TR><TD class="docTableCell" align="left" valign="top"><p class="docText"><tt>d_reclen</tt></p></td><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>d_reclen</tt></p></TD></tr><tr><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>d_type</tt></p></TD><TD class="docTableCell" align="left" valign="top"><p class="docText"><tt>d_namelen</tt></p></td></tr><tr><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>d_name[]</tt></p></td><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>d_name[]</tt></p></td></tr></table></p><br>

<a name="ch05lev3sec26"></a>

<h5 id="title-IDAMLTPF" class="docSection3Title">5.11.5.4. ERRNO</H5>
<p class="docText">When called in AIX, this function can return these <span class="docEmphasis"><tt>ERRNOs</tt></span> not documented in Linux:</p>
<ul><li><p class="docText"><span class="docEmphStrong"><tt>EBADF</tt>.</span> Indicates that the <span class="docEmphasis"><tt>DirectoryPointer</tt></span> parameter argument does not refer to an open directory stream (<tt>readdir</tt>).</P></LI><LI><p class="docText"><span class="docEmphStrong"><tt>ENAMETOOLONG</tt>.</span> Indicates that the string length pointed to by the <span class="docEmphasis"><tt>DirectoryPointer</tt></span> parameter argument exceeds the <tt>PATH_MAX</tt> value, or a path name component is longer than the <tt>NAME_MAX</tt> value while the <tt>POSIX_NO_TRUNC</tt> value is in effect (<tt>opendir</tt>).</P></LI></ul>


<a name="ch05lev2sec23"></a>
<h4 id="title-IDAINTPF" class="docSection2Title">5.11.6. <a name="iddle2099"></a><a name="iddle2352"></a>readdir()</h4>
<p class="docText"><tt>readdir()</tt> is a deprecated function. Instead, you should use <tt>geTDents()</tt>. Refer to the Linux documentation for more information on <tt>geTDents()</tt>.<a name="d0e42185"></a><a name="d0e42186"></a></P>

<a name="ch05lev2sec24"></a>

<H4 id="title-IDA4OTPF" class="docSection2Title">5.11.7. <a name="iddle2326"></a>fcntl()</H4>
<p class="docText">The <a name="iddle1343"></a><tt>fcntl</tt> subroutine performs controlling operations on the open file specified by the <tt>FileDescriptor</tt> (<span class="docEmphasis"><tt>fd</tt></span>) parameter. If Network File System (NFS) is installed on your system, the open file can reside on another node. The<span class="docEmphStrong"></span> <tt>fcntl</tt> subroutine is used to do the following:</p>
<UL><li><p class="docList">Duplicate open file descriptors</p></LI><LI><p class="docList">Set and get the file-descriptor flags</p></li><li><p class="docList">Set and get the file-status flags</p></LI><li><p class="docList">Manage record locks</p></li><li><p class="docList">Manage asynchronous I/O ownership</P></LI><li><p class="docList">Close multiple files</p></li></ul>
<p class="docText">The following commands are supported for all file types and are passed via the <span class="docEmphasis"><tt>cmd</tt></span> parameter:</p>
<ul><li><p class="docList"><tt><a name="iddle1370"></a>F_DUPFD</tt><a name="d0e42273"></a></p><p class="docList">Returns a new file descriptor that is the lowest numbered available (that is, not already open) file descriptor greater than or equal to the specified argument, which is of type <tt>int</tt>. The new file descriptor refers to the same open file description as the original file descriptor and shares any locks. The <tt>FD_CLOEXEC</tt> flag associated with the new file descriptor is cleared to keep the file open across calls to one of the <tt>exec()</tt> family of functions. The return value is the new file descriptor on success or 1 on error.</p></li><li><p class="docList"><tt><a name="iddle1376"></a>F_SETFD</tt><a name="d0e42295"></a></p><p class="docList">Sets the file descriptor flags for the specified file descriptor. The argument is the new set of flags, as a variable of type <tt>int</tt>. File descriptor flags are associated with a single file descriptor and do not affect other file descriptors that refer to the same file. The return value is 0 on success or 1 on error. The following file descriptor flags may be set. Any additional bits set from the flags specified for <tt>F_GETFD</tt> are ignored. If any bits not defined here are specified, behavior is undefined.</p></li><LI><p class="docList"><tt><a name="iddle1346"></a>FD_CLOEXEC</tt><a name="d0e42315"></a></p><p class="docList">If set, the file descriptor is closed when one of the <tt>exec()</tt> family of functions is called. If not set, the file descriptor is inherited by the new process image.</p></li><LI><p class="docList"><tt><a name="iddle1371"></a>F_GETFD</tt><a name="d0e42331"></a></P><p class="docList">Gets the file descriptor flags for the specified file descriptor. This command takes no argument. File descriptor flags are associated with a single file descriptor and do not affect other file descriptors that refer to the same file. The return value is the current file descriptor flags on success, or 1 on error. In addition to the flags specified for <tt>F_SETFD</tt>, the following flags may be returned:</P><p class="docList"><tt><a name="iddle1348"></a>FD_MANDATORYLOCK</tt><a name="d0e42346"></a></P><p class="docList">Mandatory locking is enabled for the file referred to by the specified file descriptor.</P><p class="docList"><tt><a name="iddle1345"></a>FD_ADVISORYLOCK</tt><a name="d0e42358"></a></p><p class="docList">Advisory locking is enabled for the file referred to by the specified file descriptor.</p><p class="docList"><tt><a name="iddle1347"></a>FD_DIRECTORY</tt><a name="d0e42370"></a></p><p class="docList">The specified file descriptor refers to a directory.</P></LI><LI><p class="docList"><tt><a name="iddle1377"></a>F_SETFL</tt><a name="d0e42383"></a></P><p class="docList">Sets the file status flags for the specified file descriptor. The argument is the new set of flags, as a variable of type <tt>int</tt>. These flags are as specified for the <tt>oflag</tt> argument to <tt>open()</tt>, along with the additional values specified later. Bits corresponding to the file access mode and any other <tt>oflag</tt> bits not listed here are ignored. If any bits not defined here or in <tt>open()</tt> are set, behavior is undefined. The return value is 0 on success, or 1 on error. The following file status flags can be changed with <tt>F_SETFL</tt>:</P><p class="docList"><tt><a name="iddle1897"></a>O_APPEND</tt><a name="d0e42413"></a></p><p class="docList">Valid only for file descriptors that refer to regular files. The file pointer is moved to the end of the file before each write.</P><p class="docList"><tt><a name="iddle1898"></a>O_ASYNC</tt><a name="d0e42426"></a></p><p class="docList">Valid only for file descriptors that refer to sockets and communications ports. If enabled for a file descriptor, and an owning process/process group has been specified with the <tt>F_SETOWN</tt> command to <tt>fcntl()</tt>, a <tt>SIGIO</tt> signal is sent to the owning process/process group when input is available on the file descriptor.</p><p class="docList"><tt><a name="iddle1899"></a>O_BINARY</tt><a name="d0e42447"></a></P><p class="docList">Sets the file descriptor to binary mode.</P><p class="docList"><tt><a name="iddle1900"></a>O_LARGEFILE</tt><a name="d0e42459"></a></p><p class="docList">Sets the file descriptor to indicate a large-file-aware application.</p><p class="docList"><tt><a name="iddle1901"></a>O_NDELAY</tt><a name="d0e42471"></a></p><p class="docList">Sets the file descriptor to no-delay mode.</p><p class="docList"><tt><a name="iddle1902"></a>O_NONBLOCK</tt><a name="d0e42483"></a></P><p class="docList">Sets the file descriptor to nonblocking mode. The distinction between nonblocking mode and no-delay mode is relevant only for a few types of special files such as pipes and FIFOs. Refer to <tt>read()</tt> and <tt>write()</tt> for more information.</p><p class="docList"><tt><a name="iddle1903"></a>O_SYNC</tt><a name="d0e42501"></a></p><p class="docList">Sets the file descriptor to synchronous-write mode. Writes do not return until file buffers have been flushed to disk.</p><p class="docList"><tt><a name="iddle1904"></a>O_TEXT</tt><a name="d0e42513"></a></p><p class="docList">Sets the file descriptor to text mode.</P><p class="docList"><tt><a name="iddle1339"></a>FAPPEND</tt><a name="d0e42525"></a></P><p class="docList">A synonym for <tt>O_APPEND</tt>.</p><p class="docList"><tt><a name="iddle1341"></a>FASYNC</tt><a name="d0e42540"></a></p><p class="docList">A synonym for <tt>O_ASYNC</tt>.</p><p class="docList"><tt><a name="iddle1357"></a>FNDELAY</tt><a name="d0e42555"></a></p><p class="docList">A synonym for <tt>O_NDELAY</tt>.</p></li><li><p class="docList"><tt><a name="iddle1372"></a>F_GETFL</tt><a name="d0e42572"></a></p><p class="docList">Gets the file status flags and file access modes for the specified file descriptor. These flags are as specified for the <tt>oflag</tt> argument to <tt>open()</tt>, along with the additional values described for <tt>F_SETFL</tt>. File status flags and file access modes are associated with the file description and do not affect other file descriptors that refer to the same file with different open file descriptions. The return value is the current file status flags and file access modes on success, or 1 on error. The following macros can be used to access fields of the return value:</p><p class="docList"><tt><a name="iddle1896"></a>O_ACCMODE</tt><a name="d0e42593"></a></p><p class="docList">Extracts the access-mode field, which is one of <tt>O_RDONLY, O_RDWR</tt>, or <tt>O_WRONLY</tt>. Refer to the documentation for <tt>open()</tt> for more information.</p><p class="docList">The following commands are supported only for sockets and communication ports:</p></li><li><p class="docList"><tt><a name="iddle1382"></a>F_SETOWN</tt><a name="d0e42618"></a></P><p class="docList">Sets the owning process ID or process group ID for the specified file descriptor. The owning process or process group can receive <tt>SIGURG</tt><span class="docEmphStrong"></span> signals for out-of-band data or sockets and/or <tt>SIGIO</tt> signals for readable data on sockets or communications ports. The argument is the process ID or the negative of the process group ID for the owner, as a variable of type <tt>pid_t</tt>. The return value is 0 on success or 1 on error.</p><p class="docList">To receive <tt>SIGURG</tt> signals, the process should establish a <tt>SIGURG</tt> handler prior to setting ownership of the file descriptor. A <tt>SIGURG</tt> signal is generated whenever out-of-band data is received.</p><p class="docList">To receive <tt>SIGIO</tt> signals, the process should establish a <tt>SIGIO</tt> handler prior to setting ownership of the file descriptor, and then must enable <tt>O_ASYNC</tt> with the <tt>F_SETFL</tt> command to <tt>fcntl()</tt>. A <tt>SIGIO</tt> signal is generated whenever there is data to be read on the file descriptor.</p></LI><LI><p class="docList"><tt><a name="iddle1375"></a>F_GETOWN</tt><a name="d0e42674"></a></P><p class="docList">Gets the owning process ID or process group ID for the specified file descriptor. The return value is the owner ID on success, or 1 on error. Behavior is undefined if no owner has been established with <tt>F_SETOWN</tt>.</P><p class="docList">The following commands are used for file locking. Locks may be advisory or mandatory. These command are supported only for regular files.</P></li><li><p class="docList"><tt><a name="iddle1373"></a>F_GETLK</tt><a name="d0e42694"></a></p><p class="docList">Gets the first lock that blocks a lock description for the file to which the specified file descriptor refers. The argument is a pointer to a variable of type struct <tt>flock</tt>, described later. The structure is overwritten with the returned lock information. If no lock is found that would prevent this lock from being created, the structure is unchanged except for the lock type, which is set to <tt><a name="iddle1383"></a>F_UNLCK</tt><a name="d0e42707"></a>. The return value is 0 on success or 1 or error.</P></LI><LI><p class="docList"><tt><a name="iddle1374"></a>F_GETLK64</tt><a name="d0e42718"></a></P><p class="docList">Equivalent to <tt>F_GETLK</tt>, but takes a struct <tt>flock64</tt> argument rather than a struct <tt>flock</tt> argument.</P></li><LI><p class="docList"><tt><a name="iddle1378"></a>F_SETLK</tt><a name="d0e42740"></a></p><p class="docList">Sets or clears a file segment lock for the file to which the specified file descriptor refers. The argument is a pointer to a variable of type struct <tt>flock</tt>, described later. <tt>F_SETLK</tt> is used to establish shared (or read) locks (<tt>F_RDLCK</tt>) or exclusive (or write) locks (<tt>F_WRLCK</tt>), as well as to remove either type of lock (<tt>F_UNLCK</tt>). The return value is 0 on success or 1 on error. If the lock cannot be immediately obtained, <tt>fcntl()</tt> returns 1 with <span class="docEmphasis"><tt>ERRNO</tt></span> set to <tt>EACCES</tt>.</p></LI><LI><p class="docList"><tt><a name="iddle1379"></a>F_SETLK64</tt><a name="d0e42778"></a></p><p class="docList">Equivalent to <tt>F_SETLK</tt>, but takes a struct <tt>flock64</tt> argument rather than a struct <tt>flock</tt> argument.</p></li><li><p class="docList"><tt><a name="iddle1380"></a>F_SETLKW</tt><a name="d0e42800"></a></P><p class="docList">This command is the same as <tt>F_SETLK</tt> except that if a shared or exclusive lock is blocked by other locks, the thread waits until the request can be satisfied. If a signal that is to be caught is received while <tt>fcntl()</tt> is waiting for a region, <tt>fcntl()</tt> is interrupted. Upon return from the signal handler, <tt>fcntl()</tt> returns 1 with <span class="docEmphasis"><tt>ERRNO</tt></span> set to <tt>EINTR</tt>, and the lock operation is not done.</p></li><li><p class="docList"><tt><a name="iddle1381"></a>F_SETLKW64</tt><a name="d0e42832"></a></p><p class="docList">Equivalent to <tt>F_SETLKW</tt>, but takes a struct <tt>flock64</tt> argument rather than a struct <tt>flock</tt> argument.</P></LI></ul>
<p class="docText">When a shared lock is set on a segment of a file, other processes can set shared locks on that segment or a portion of it. A shared lock prevents any other process from setting an exclusive lock on any portion of the protected area. A request for a shared lock fails if the file descriptor was not opened with read access.</p>
<p class="docText">An exclusive lock prevents any other process from setting a shared lock or an exclusive lock on any portion of the protected area. A request for an exclusive lock fails if the file descriptor is not opened with write access.</p>
<p class="docText">The <tt><a name="iddle1355"></a>flock</tt> and <tt><a name="iddle1356"></a>flock64</tt> structure contains the following fields:<a name="d0e42870"></a><a name="d0e42871"></a></p>
<ul><li><p class="docList"><tt><a name="iddle1791"></a>l_type</tt><a name="d0e42883"></a></p><p class="docList">Specifies the type of lock request. Valid settings are as follows:</p><p class="docList"><tt>F_RDLCK</tt></p><p class="docList">Creates a shared lock.</p><p class="docList"><tt>F_WRLCK</tt></p><p class="docList">Creates an exclusive lock.</p><p class="docList"><tt>F_UNLCK</tt></p><p class="docList">Removes a lock.</p></LI><li><p class="docList"><tt><a name="iddle1792"></a>l_whence</tt><a name="d0e42917"></a></p><p class="docList">Specifies the starting offset of the lock segment in the file. Valid settings are as follows:</p><p class="docList"><tt>SEEK_SET</tt></P><p class="docList"><tt>l_start</tt> specifies a position relative to the start of the file.</P><p class="docList"><tt>SEEK_CUR</tt></P><p class="docList"><tt>l_start</tt> specifies a position relative to the current file offset.</P><p class="docList"><tt>SEEK_END</tt></P><p class="docList"><tt>l_start</tt> specifies a position relative to the end of the file.</p><p class="docList">On a successful return from an <tt>F_GETLK</tt> or <tt>F_GETLK64</tt> command for which a lock was found, the <tt>l_whence</tt> field is set to <tt>SEEK_SET</tt>.</p></li><LI><p class="docList"><tt><a name="iddle1790"></a>l_start</tt><a name="d0e42973"></a></P><p class="docList">Specifies the relative offset of the start of the lock segment. This setting is used with <tt>l_whence</tt> to determine the actual start position.</P></LI><LI><p class="docList"><tt><a name="iddle1788"></a>l_len</tt><a name="d0e42989"></a></p><p class="docList">Specifies the number of consecutive bytes in the lock segment. This value may be negative.</P></li><li><p class="docList"><tt><a name="iddle1789"></a>l_pid</tt><a name="d0e43002"></a></P><p class="docList">On a successful return from an <tt>F_GETLK</tt> or <tt>F_GETLK64</tt> command for which a lock was found, this field contains the process ID of the process holding the lock.</P></li></ul>
<p class="docText">If <tt>l_len</tt> is positive, the affected area starts at <tt>l_start</tt> and ends at <tt>(l_start + l_len - 1)</tt>. If <tt>l_len</tt> is negative, the area affected starts at <tt>(l_start + l_len)</tt> and ends at <tt>(l_start - 1)</tt>. Locks may start and end beyond the current end of a file but must not be negative relative to the beginning of the file. Setting <tt>l_len</tt> to 0 sets a lock that can extend to the largest possible value of the file offset for that file. If such a lock also has <tt>l_start</tt> set to 0 and <tt>l_whence</tt> set to <tt>SEEK_SET</tt>, the whole file is locked.</p>
<p class="docText">There can be at most one type of lock set of each byte in the file. Before a successful return from an <tt>F_SETLK, F_SETLK64, F_SETLKW</tt>, or <tt>F_SETLKW64</tt> request when the calling process has previously existing locks on bytes in the region specified by the request, the previous lock type for each byte in the specified region is replaced by the new lock type. As specified earlier, an <tt>F_SETLK, F_SETLK64, F_SETLKW</tt>, or <tt>F_SETLKW64</tt> request fails or blocks, respectively, when another process has existing locks on bytes in the specified region and the type of any of those locks conflicts with the type specified in the request.</p>
<p class="docText">All locks associated with a file for a given process shall be removed when a file descriptor for that file is closed by that process or when the process holding that file descriptor terminates. Locks are not inherited by a child process.</P>
<p class="docText">A potential for deadlock occurs if a process controlling a locked region is put to sleep by attempting to lock another process's locked region. If the system detects that sleeping until a locked region is unlocked would cause a deadlock, <tt>fcntl()</tt> returns 1 with <span class="docEmphasis"><tt>ERRNO</tt></span> set to <tt>EDEADLK</tt>.<a name="d0e43077"></a></p>
<a name="ch05lev3sec27"></a>

<h5 id="title-IDAQ00QX" class="docSection3Title">5.11.7.1. AIX Prototype</h5>
<div class="docText"><pre>#include &lt;fcntl.h&gt;
int <a name="iddle1285"></a>fcntl (int <span class="docEmphasis">FileDescriptor</span>, int <span class="docEmphasis">cmd</span>, ...);
</pre></div><br>

<a name="ch05lev3sec28"></a>
<H5 id="title-IDAS10QX" class="docSection3Title">5.11.7.2. Linux Prototype</H5>
<div class="docText"><pre>#include &lt;unistd.h&gt;
#include &lt;fcntl.h&gt;
int fcntl(int <span class="docEmphasis">fd</span>, int <span class="docEmphasis">cmd</span>);
int fcntl(int <span class="docEmphasis">fd</span>, int <span class="docEmphasis">cmd</span>, long <span class="docEmphasis">arg</span>);
int fcntl(int <span class="docEmphasis">fd</span>, int <span class="docEmphasis">cmd</span>, struct flock *<span class="docEmphasis">lock</span>);
</pre></div><br>

<a name="ch05lev3sec29"></a>
<h5 id="title-IDAU20QX" class="docSection3Title">5.11.7.3. Detail Comparison</h5>
<p class="docText">**Compatible**</p>
<p class="docText">The user should take note of the different open modes and command values between AIX and Linux. In the preceding section, the command description is mainly Linux-specific. Refer to the &quot;File Bits&quot; section at the end of this chapter.</p>

<a name="ch05lev3sec30"></a>
<h5 id="title-IDAC30QX" class="docSection3Title">5.11.7.4. Return Value</h5>
<p class="docText">For a successful call, the return value depends on the operation performed:</p>
<ul><li><p class="docText"><span class="docEmphStrong"><tt>F_DUPFD</tt>.</span> The new descriptor.</p></li><li><p class="docText"><span class="docEmphStrong"><tt>F_GETFD</tt>.</span> Value of flag.</p></LI><li><p class="docText"><span class="docEmphStrong"><tt>F_GETFL</tt>.</span> Value of flags.</p></li><LI><p class="docText"><span class="docEmphStrong"><tt>F_GETOWN</tt>.</span> Value of descriptor owner.</P></LI><LI><p class="docText"><span class="docEmphStrong"><tt>F_GETSIG</tt>.</span> Value of signal sent when read or write becomes possible, or 0 for traditional <tt>SIGIO</tt> behavior.</P></li><li><p class="docText"><span class="docEmphStrong">All other commands.</span> 0.</p></LI></UL>
<p class="docText">On error, 1 is returned, and <span class="docEmphasis"><tt>ERRNO</tt></span> is set appropriately.</P>

<a name="ch05lev3sec31"></a>
<H5 id="title-IDAX50QX" class="docSection3Title">5.11.7.5. Errors</H5>
<ul><LI><p class="docText"><span class="docEmphStrong"><tt><a name="iddle1243"></a>EACCES</tt> or <tt><a name="iddle1245"></a>EAGAIN</tt>.</span> Operation is prohibited by locks held by other processes<a name="d0e43261"></a><a name="d0e43262"></a>. Or, operation is prohibited because the file has been memory mapped by another process.</p></li><LI><p class="docText"><span class="docEmphStrong"><tt><a name="iddle1246"></a>EBADF</tt>.</span> <span class="docEmphasis"><tt>fd</tt></span> is not an open file descriptor, or the command was <tt>F_SETLK</tt> or <tt>F_SETLKW</tt> and the file descriptor open mode does not match the type of lock requested.<a name="d0e43288"></a><a name="d0e43289"></a></P></li><li><p class="docText"><span class="docEmphStrong"><tt><a name="iddle1250"></a>EDEADLK</tt>.</span> It was detected that the specified <tt>F_SETLKW</tt> command would cause a deadlock.<a name="d0e43307"></a></p></li><LI><p class="docText"><span class="docEmphStrong"><tt><a name="iddle1251"></a>EFAULT</tt>.</span> The lock is outside your accessible address space.<a name="d0e43322"></a></p></li><li><p class="docText"><span class="docEmphStrong"><tt><a name="iddle1253"></a>EINTR</tt>.</span> For <tt>F_SETLKW</tt>, the command was interrupted by a signal<a name="d0e43340"></a>. For <tt>F_GETLK</tt> and <tt>F_SETLK</tt>, the command was interrupted by a signal before the lock was checked or acquiredmost likely when locking a remote file (for example, locking over NFS), but it can sometimes happen locally.</p></LI><LI><p class="docText"><span class="docEmphStrong"><tt><a name="iddle1254"></a>EINVAL</tt>.</span> For <tt>F_DUPFD</tt>, <span class="docEmphasis"><tt>arg</tt></span> is negative or is greater than the maximum allowable value<a name="d0e43369"></a>. For <tt>F_SETSIG</tt>, <span class="docEmphasis"><tt>arg</tt></span> is not an allowable signal number.</p></li><li><p class="docText"><span class="docEmphStrong"><tt><a name="iddle1263"></a>EMFILE</tt>.</span> For <tt>F_DUPFD</tt>, the process already has the maximum number of file descriptors open.<a name="d0e43395"></a></p></li><li><p class="docText"><span class="docEmphStrong"><tt><a name="iddle1270"></a>ENOLCK</tt>.</span> Too many segment locks are open, the lock table is full, or a remote locking protocol failed (for example, locking over NFS).<a name="d0e43410"></a></p></li><li><p class="docText"><span class="docEmphStrong"><tt><a name="iddle1276"></a>EPERM</tt>.</span> Attempted to clear the <tt>O_APPEND</tt> flag on a file that has the append-only attribute set.<a name="d0e43428"></a></p></li></ul>

<a name="ch05lev3sec32"></a>
<h5 id="title-IDAMJ1QX" class="docSection3Title">5.11.7.6. ERRNOs Not Supported in Linux</h5>
<UL><li><p class="docText"><span class="docEmphStrong"><tt><a name="iddle1312"></a>ESRCH</tt>.</span> The value of the <tt>Command</tt> parameter is <tt>F_SETOWN</tt>, and the process ID specified as the <tt>Argument</tt> parameter is not in use.<a name="d0e43461"></a></p></li><LI><p class="docText"><span class="docEmphStrong"><tt><a name="iddle1275"></a>EOVERFLOW</tt>.</span> The <tt>Command</tt> parameter was <tt>F_GETLK</tt> and the block lock could not be represented in the <tt>flock</tt> structure.<a name="d0e43485"></a></P></LI><LI><p class="docText"><span class="docEmphStrong"><tt><a name="iddle1322"></a>ETIMEDOUT</tt>.</span> The connection timed out.<a name="d0e43500"></a><a name="d0e43501"></a></P></li></ul>


<a name="ch05lev2sec25"></a>

<h4 id="title-IDA4M1QX" class="docSection2Title">5.11.8. <a name="iddle1768"></a><a name="iddle2336"></a><a name="iddle2378"></a>llseek(), lseek(), <a name="iddle1785"></a><a name="iddle2338"></a><a name="iddle2380"></a>lseek64()</H4>
<p class="docText">Sometimes you do not want to start at the beginning of an open file to start reading or writing to it. <tt>llseek(), lseek()</tt>, and <tt>lseek64()</tt> reposition the read/write pointer in a file that is associated with a file descriptor (<span class="docEmphasis"><tt>fd</tt></span>).</P>
<a name="ch05lev3sec33"></a>
<H5 id="title-IDA2P1QX" class="docSection3Title">5.11.8.1. AIX Prototype</H5>
<div class="docText"><pre>#include &lt;sys/types.h&gt;
#include &lt;unistd.h&gt;
offset_t llseek(int <span class="docEmphasis">fd</span>, offset_t <span class="docEmphasis">offset</span>, int <span class="docEmphasis">whence</span>);
offset_t lseek(int <span class="docEmphasis">fd</span>, offset_t <span class="docEmphasis">offset</span>, int <span class="docEmphasis">whence</span>);
offset_t lseek64(int <span class="docEmphasis">fd</span>, offset_t <span class="docEmphasis">offset</span>, int <span class="docEmphasis">whence</span>);
</pre></div><BR>

<a name="ch05lev3sec34"></a>
<h5 id="title-IDADR1QX" class="docSection3Title">5.11.8.2. Linux Prototype</H5>
<div class="docText"><pre>#include &lt;sys/types.h&gt;
#include &lt;unistd.h&gt;
off_t lseek(int <span class="docEmphasis">fildes</span>, off_t <span class="docEmphasis">offset</span>, int <span class="docEmphasis">whence</span>);
_syscall5(int, _llseek, uint, fd, ulong, hi, ulong, lo, loff_t *, res, uint, wh);
int _llseek(unsigned int <span class="docEmphasis">fd</span>, unsigned long <span class="docEmphasis">offset_high</span>, unsigned long
<span class="docEmphasis">offset_low</span>, loff_t *<span class="docEmphasis">result</span>, unsigned int <span class="docEmphasis">whence</span>);
</pre></div><br>

<a name="ch05lev3sec35"></a>
<h5 id="title-IDAFS1QX" class="docSection3Title">5.11.8.3. Detail Comparison</H5>
<p class="docText">**Compatible**</P>
<p class="docText">Although <tt>llseek</tt><span class="docEmphStrong"></span> is implemented in Linux, if you are writing new code <tt>lseek</tt> should be used instead of <tt>llseek</tt><span class="docEmphStrong"></span> for greater portability between UNIX platforms.</p>

<a name="ch05lev3sec36"></a>
<h5 id="title-IDA4S1QX" class="docSection3Title">5.11.8.4. Additional Info: AIX/Linux, <a name="iddle1784"></a><a name="iddle2337"></a><a name="iddle2379"></a>lseek Only</h5>
<ul><LI><p class="docText"><span class="docEmphStrong"><tt>fd</tt>.</span> Specifies a file descriptor obtained from a successful <tt>open</tt> or<span class="docEmphStrong"></span> <tt>fcntl</tt> subroutine.</p></li><li><p class="docText"><span class="docEmphStrong"><tt>offset</tt>.</span> Specifies a value, in bytes, that is used in conjunction with the <tt>Whence</tt> parameter to set the file pointer. A negative value causes seeking in the reverse direction.</p></LI><LI><p class="docText"><span class="docEmphStrong"><tt>whence</tt>.</span> Specifies how to interpret the <span class="docEmphasis"><tt>offset</tt></span> parameter by setting the file pointer associated with the <span class="docEmphasis"><tt>fd</tt></span> parameter to one of the following variables:</p><p class="docList"><tt>SEEK_SET</tt></p><p class="docList">Sets the file pointer to the value of the <span class="docEmphasis"><tt>offset</tt></span> parameter.<a name="d0e43759"></a><a name="d0e43760"></a><a name="d0e43761"></a><a name="d0e43762"></a><a name="d0e43763"></a><a name="d0e43764"></a><a name="d0e43765"></a><a name="d0e43766"></a><a name="d0e43767"></a></p><p class="docList"><tt>SEEK_CUR</tt></p><p class="docList">Sets the file pointer to its current location plus the value of the <span class="docEmphasis"><tt>offset</tt></span> parameter.</p><p class="docList"><tt>SEEK_END</tt></p><p class="docList">Sets the file pointer to the size of the file plus the value of the <span class="docEmphasis"><tt>offset</tt></span> parameter.</p></li></ul>

<a name="ch05lev3sec37"></a>
<h5 id="title-IDAPY1QX" class="docSection3Title">5.11.8.5. Return Value</h5>
<p class="docText">Upon successful completion, <tt><a name="iddle1289"></a><a name="iddle1290"></a><a name="iddle1288"></a>lseek</tt> returns the resulting offset location as measured in bytes from the beginning of the file<a name="d0e43821"></a><a name="d0e43822"></a>.<a name="d0e43824"></a> Otherwise, a value of <tt>(off_t)1</tt> is returned and <span class="docEmphasis"><tt>ERRNO</tt></span> is set to indicate the error.</p>

<a name="ch05lev3sec38"></a>
<h5 id="title-IDAW01QX" class="docSection3Title">5.11.8.6. Errors</h5>
<UL><li><p class="docText"><span class="docEmphStrong"><tt><a name="iddle1247"></a>EBADF</tt>.</span> <span class="docEmphasis"><tt>fd</tt></span> is not an open file descriptor.<a name="d0e43858"></a></p></li><LI><p class="docText"><span class="docEmphStrong"><tt><a name="iddle1311"></a>ESPIPE</tt>.</span> <span class="docEmphasis"><tt>fd</tt></span> is associated with a pipe, socket, or FIFO.<a name="d0e43876"></a></P></LI><LI><p class="docText"><span class="docEmphStrong"><tt><a name="iddle1255"></a>EINVAL</tt>.</span> <span class="docEmphasis"><tt>whence</tt></span> is not a proper value.<a name="d0e43894"></a></P></li></ul>

<a name="ch05lev3sec39"></a>
<h5 id="title-IDAZ31QX" class="docSection3Title">5.11.8.7. ERRNOs Not Supported in Linux</H5>
<UL><LI><p class="docText"><span class="docEmphStrong"><tt><a name="iddle1274"></a>EOVERFLOW</tt>.</span> The resulting offset is larger than can be returned properly.<a name="d0e43918"></a></P></LI></ul>
<p class="docText"><span class="docEmphasis">Conforming To</span></P>
<p class="docText">SVr4, POSIX, BSD 4.3</p>


<a name="ch05lev2sec26"></a>
<h4 id="title-IDAI51QX" class="docSection2Title">5.11.9. <a name="iddle2366"></a><a name="iddle2405"></a><a name="iddle2507"></a>uname()</H4>
<p class="docText">Occasionally, shell programmers as well as application developers need to know information about the system they are running on at runtime. This information could be used to set specific operating system environment variables and could aid in developing install packages for specific systems. To get the name and information about the current kernel and the machine the kernel is running on, use the <tt>uname()</tt> function.<a name="d0e43964"></a><a name="d0e43965"></a><a name="d0e43966"></a></P>
<a name="ch05lev3sec40"></a>
<h5 id="title-IDAPB2QX" class="docSection3Title">5.11.9.1. AIX Prototype</h5>
<div class="docText"><pre>#include &lt;sys/utsname.h&gt;
int uname (struct utsname *<span class="docEmphasis">Name</span>);
</pre></div><br>

<a name="ch05lev3sec41"></a>
<h5 id="title-IDADC2QX" class="docSection3Title">5.11.9.2. Linux Prototype</H5>
<div class="docText"><pre>#include &lt;sys/utsname.h&gt;
int uname(struct utsname *<span class="docEmphasis">buf</span>);
</pre></div><br>

<a name="ch05lev3sec42"></a>
<h5 id="title-IDAXC2QX" class="docSection3Title">5.11.9.3. Details Comparison</h5>
<p class="docText">**Not Compatible**</p>
<p class="docText">AIX does not define <tt>domainname</tt> as part of the <span class="docEmphasis"><tt>utsname</tt></span> structure. The <tt>domainname</tt> enTRy is technically not compatible because it is defined in Linux only if the program is compiled with <tt>_GNU_SOURCE</tt>.</P>


<a name="ch05lev2sec27"></a>
<h4 id="title-IDAQD2QX" class="docSection2Title">5.11.10. <a name="iddle2318"></a><a name="iddle2364"></a><a name="iddle2403"></a>syslog(), <a name="iddle1131"></a><a name="iddle2324"></a><a name="iddle2374"></a>closelog(), <a name="iddle1892"></a><a name="iddle2346"></a><a name="iddle2387"></a>openlog()</h4>
<p class="docText">These commands provide messaging services to the system logger:</p>
<ul><li><p class="docList"><span class="docEmphStrong"><tt>closelog()</tt></span> closes the descriptor being used to write to the system logger. The use of <tt>closelog()</tt> is optional.</p></li><li><p class="docList"><span class="docEmphStrong"><tt>openlog()</tt></span> opens a connection to the system logger for a program. The string pointed to by <span class="docEmphasis"><tt>ident</tt></span> is prepended to every message and is typically set to the program name. The <span class="docEmphasis"><tt>option</tt></span> argument specifies flags that control the operation of <tt>openlog()</tt> and subsequent calls to <tt>syslog()</tt>. The <span class="docEmphasis"><tt>facility</tt></span> argument establishes a default to be used if none is specified in subsequent calls to <tt>syslog()</tt>. Values for <span class="docEmphasis"><tt>option</tt></span> and <span class="docEmphasis"><tt>facility</tt></span> are given below. The use of <tt>openlog()</tt> is optional; it is automatically called by <tt>syslog()</tt> if necessary, in which case <span class="docEmphasis"><tt>ident</tt></span> defaults to NULL.</p></li><li><p class="docList"><span class="docEmphStrong"><tt>syslog()</tt></span> generates a log message, which is distributed by <tt>syslogd</tt>. The <span class="docEmphasis"><tt>priority</tt></span> argument is formed by ORing the <span class="docEmphasis"><tt>facility</tt></span> and the <span class="docEmphasis"><tt>level</tt></span> values (explained below). The remaining arguments are a <span class="docEmphasis"><tt>format</tt></span>, as in <tt>printf</tt>, and any arguments required by the <span class="docEmphasis"><tt>format</tt></span>, except that the two-character sequence <tt>%m</tt> is replaced by the error message string <tt>strerror(errno)</tt>. A trailing newline is added when needed.<a name="d0e44198"></a><a name="d0e44199"></a><a name="d0e44200"></a><a name="d0e44201"></a><a name="d0e44202"></a><a name="d0e44203"></a><a name="d0e44204"></a><a name="d0e44205"></a><a name="d0e44206"></a></p></li></ul>
<a name="ch05lev3sec43"></a>
<H5 id="title-IDAML2QX" class="docSection3Title">5.11.10.1. AIX Prototype</h5>
<div class="docText"><pre>#include &lt;syslog.h&gt;
void openlog(const char *<span class="docEmphasis">ident</span>, int <span class="docEmphasis">LogOption</span>, int <span class="docEmphasis">Facility</span>);
void syslog(int <span class="docEmphasis">Priority</span>, const char *<span class="docEmphasis">Value</span>,... );
int closelog(void);
</pre></div><br>

<a name="ch05lev3sec44"></a>
<h5 id="title-IDAIM2QX" class="docSection3Title">5.11.10.2. Linux Prototype</H5>
<div class="docText"><pre>#include &lt;syslog.h&gt;
void openlog( char *<span class="docEmphasis">ident</span>, int LogO<span class="docEmphasis">ption</span>, int <span class="docEmphasis">facility</span>);
void syslog( int <span class="docEmphasis">priority</span>, char *<span class="docEmphasis">format</span>, ...);
void closelog( void );
</pre></div><BR>

<a name="ch05lev3sec45"></a>
<H5 id="title-IDAEN2QX" class="docSection3Title">5.11.10.3. Details Comparison</H5>
<p class="docText">**Compatible**</P>
<p class="docText">The facilities will require additional code changes under Linux to make use of the following:</p>
<p class="docText">LOG_PERROR</p>
<p class="docText">LOG_AUTHPRIV</p>


<a name="ch05lev2sec28"></a>
<H4 id="title-IDAXN2QX" class="docSection2Title">5.11.11. <a name="iddle1303"></a><a name="iddle2314"></a><a name="iddle2361"></a><a name="iddle2400"></a>swapoff(), swapon()</H4>
<p class="docText">These commands are usually used for device programming for enabling paging on a device. <tt>swapon</tt> sets the swap area to the file or block device specified by <span class="docEmphasis"><tt>path</tt></span>. <tt>swapoff</tt> stops swapping to the file or block device specified by <span class="docEmphasis"><tt>path</tt></span>.</P>
<a name="ch05lev3sec46"></a>
<H5 id="title-IDA3P2QX" class="docSection3Title">5.11.11.1. AIX Prototype</H5>
<div class="docText"><pre>#include &lt;sys/vminfo.h&gt;
int <a name="iddle1304"></a><a name="iddle2315"></a><a name="iddle2362"></a><a name="iddle2401"></a>swapon (char *<span class="docEmphasis">PathName</span>);
int swapoff(char *<span class="docEmphasis">PathName</span>);<a name="d0e44377"></a><a name="d0e44378"></a><a name="d0e44379"></a><a name="d0e44380"></a>
</pre></div><br>

<a name="ch05lev3sec47"></a>
<H5 id="title-IDA4S2QX" class="docSection3Title">5.11.11.2. Linux Prototype</h5>
<div class="docText"><pre>#include &lt;unistd.h&gt;
#include &lt;asm/page.h&gt;
#include &lt;sys/swap.h&gt;
int swapon(const char *<span class="docEmphasis">path</span>, int <span class="docEmphasis">swapflags</span>);
int swapoff(const char *<span class="docEmphasis">path</span>);
</pre></div><br>

<a name="ch05lev3sec48"></a>
<H5 id="title-IDAWT2QX" class="docSection3Title">5.11.11.3. Details Comparision</H5>
<p class="docText">**Compatible**<a name="d0e44413"></a><a name="d0e44414"></a><a name="d0e44415"></a><a name="d0e44416"></a></p>
<p class="docText">Functions are compatible, but the <tt>swapflags</tt> must be added for Linux.</p>

<a name="ch05lev3sec49"></a>
<h5 id="title-IDA2U2QX" class="docSection3Title">5.11.11.4. Return Value</h5>
<p class="docText">On success, 0 is returned. On error, 1 is returned, and <span class="docEmphasis"><tt>ERRNO</tt></span> is set appropriately.</P>

<a name="ch05lev3sec50"></a>
<h5 id="title-IDAMV2QX" class="docSection3Title">5.11.11.5. Errors</h5>
<p class="docText">Many other errors can occur if <span class="docEmphasis"><tt>path</tt></span> is not valid:</p>
<ul><LI><p class="docText"><span class="docEmphStrong"><tt><a name="iddle1277"></a>EPERM</tt>.</span> The user is not the super user, or more than <tt>MAX_SWAPFILES</tt> (defined to be 8 in Linux 1.3.6) are in use.<a name="d0e44468"></a></P></li><li><p class="docList"><span class="docEmphStrong"><tt><a name="iddle1256"></a>EINVAL</tt></span> is returned if <span class="docEmphasis"><tt>path</tt></span> exists but is neither a regular path nor a block device.<a name="d0e44484"></a></p></li><li><p class="docList"><span class="docEmphStrong"><tt><a name="iddle1269"></a>ENOENT</tt></span> is returned if <span class="docEmphasis"><tt>path</tt></span> does not exist.</p></li><li><p class="docList"><span class="docEmphStrong"><tt><a name="iddle1271"></a>ENOMEM</tt></span> is returned if there is insufficient memory to start swapping.</p></li></ul>

<a name="ch05lev3sec51"></a>
<h5 id="title-IDA4Y2QX" class="docSection3Title">5.11.11.6. ERRNO(s) Not Implemented in Linux</h5>
<ul><LI><p class="docText"><span class="docEmphStrong"><tt>EINTR</tt>.</span> A signal was received during processing of a request.</p></li><li><p class="docText"><span class="docEmphStrong"><tt>ENOTBLK</tt>.</span> A block device is required.</P></LI><LI><p class="docText"><span class="docEmphStrong"><tt>ENOTDIA</tt>.</span> A component of the <span class="docEmphasis"><tt>PathName</tt></span> prefix is not a directory.</P></LI><li><p class="docText"><span class="docEmphStrong"><tt>ENXIO</tt>.</span> No such device address.</p></li></UL>


<a name="ch05lev2sec29"></a>

<H4 id="title-IDA302QX" class="docSection2Title">5.11.12. acct()</H4>
<p class="docText">Use this command to switch process accounting on or off.<a name="d0e44577"></a><a name="d0e44578"></a></P>
<a name="ch05lev3sec52"></a>
<H5 id="title-IDAT12QX" class="docSection3Title">5.11.12.1. Linux/AIX Prototype</h5>
<div class="docText"><pre>#include &lt;unistd.h&gt;
int <a name="iddle1283"></a><a name="iddle1017"></a><a name="iddle2322"></a><a name="iddle2372"></a><a name="iddle23721"></a>acct (char *<span class="docEmphasis">Path</span>);<a name="d0e44627"></a>
</pre></div><BR>

<a name="ch05lev3sec53"></a>
<h5 id="title-IDAJ42QX" class="docSection3Title">5.11.12.2. Detail Comparison</h5>
<p class="docText">**Compatible**</P>

<a name="ch05lev3sec54"></a>
<H5 id="title-IDAV42QX" class="docSection3Title">5.11.12.3. Return Value</h5>
<p class="docText">On success, 0 is returned. On error, 1 is returned, and <span class="docEmphasis"><tt>ERRNO</tt></span> is set appropriately.</p>

<a name="ch05lev3sec55"></a>
<h5 id="title-IDAF52QX" class="docSection3Title">5.11.12.4. Errors</h5>
<UL><li><p class="docText"><span class="docEmphStrong"><tt><a name="iddle1244"></a>EACCES</tt>.</span> Write permission is denied for the specified file.<a name="d0e44674"></a></p></li><li><p class="docText"><span class="docEmphStrong"><tt>EACCES</tt>.</span> The argument <span class="docEmphasis"><tt>filename</tt></span> is not a regular file.</P></LI><li><p class="docText"><span class="docEmphStrong"><tt><a name="iddle1252"></a>EFAULT</tt>.</span> <span class="docEmphasis"><tt>filename</tt></span> points outside your accessible address space.<a name="d0e44706"></a></p></li><li><p class="docText"><span class="docEmphStrong"><tt><a name="iddle1257"></a>EIO</tt>.</span> Error writing to the file <span class="docEmphasis"><tt>filename</tt></span>.<a name="d0e44725"></a></p></li><li><p class="docText"><span class="docEmphStrong"><tt><a name="iddle1258"></a>EISDIR</tt>.</span> <span class="docEmphasis"><tt>filename</tt></span> is a directory.<a name="d0e44743"></a></p></li><li><p class="docText"><span class="docEmphStrong"><tt><a name="iddle1262"></a>ELOOP</tt>.</span> Too many symbolic links were encountered in resolving <span class="docEmphasis"><tt>filename</tt></span>.<a name="d0e44762"></a></p></li><li><p class="docText"><span class="docEmphStrong"><tt><a name="iddle1266"></a>ENAMETOOLONG</tt>.</span> <span class="docEmphasis"><tt>filename</tt></span> was too long.<a name="d0e44780"></a></p></LI><li><p class="docText"><span class="docEmphStrong"><tt>ENOENT</tt>.</span> The specified filename does not exist.</p></li><LI><p class="docText"><span class="docEmphStrong"><tt>ENOMEM</tt>.</span> Out of memory.</P></LI><LI><p class="docText"><span class="docEmphStrong"><tt>ENOSYS</tt>.</span> BSD process accounting was not enabled when the operating system kernel was compiled. The kernel configuration parameter controlling this feature is <tt>CONFIG_BSD_PROCESS_ACCT</tt>.</P></li><li><p class="docText"><span class="docEmphStrong"><tt><a name="iddle1272"></a>ENOTDIR</tt>.</span> A component used as a directory in <span class="docEmphasis"><tt>filename</tt></span> is not in fact a directory.<a name="d0e44832"></a></p></LI><LI><p class="docText"><span class="docEmphStrong"><tt><a name="iddle1278"></a>EPERM</tt>.</span> The calling process has no permission to enable process accounting.<a name="d0e44848"></a><a name="d0e44849"></a><a name="d0e44850"></a><a name="d0e44851"></a></P></LI><LI><p class="docText"><span class="docEmphStrong"><tt><a name="iddle1280"></a>EROFS</tt>.</span> <span class="docEmphasis"><tt>filename</tt></span> refers to a file on a read-only file system.<a name="d0e44869"></a></p></LI><li><p class="docText"><span class="docEmphStrong"><tt><a name="iddle1323"></a>EUSERS</tt>.</span> There are no more free file structures or we ran out of memory.<a name="d0e44884"></a></p></LI></UL>

<a name="ch05lev3sec56"></a>
<h5 id="title-IDAOK3QX" class="docSection3Title">5.11.12.5. ERRNO(s) Not Implemented in Linux</h5>
<ul><li><p class="docText"><span class="docEmphStrong"><tt><a name="iddle1249"></a>EBUSY</tt>.</span> An attempt is made to enable accounting when it is already enabled.<a name="d0e44908"></a></P></li></ul>


<a name="ch05lev2sec30"></a>
<h4 id="title-IDAYL3QX" class="docSection2Title">5.11.13. mmap(), mmap64(),<sup class="docFootnote"><a class="docLink" href="#ch05fn17">[17]</a></sup> munmap()</h4><blockquote><p class="docFootnote"><sup><a name="ch05fn17">[17]</a></sup> Used on 64-bit machines and for Large File Support.</P></blockquote>
<p class="docText">These commands are memory-mapping functions. There comes a time when you want to read and write to and from files so that the information is shared between processes. Think of it this way: two processes both open the same file and both read and write from it, thus sharing the information. Wouldn't it be easier if you could just map a section of the file to memory and get a pointer to it? Then you could simply use pointer arithmetic to get (and set) data in the file.</P>
<p class="docText">Another great advantage to using memory-mapped files is to speed up performance. It would take a lot of I/O resources if more than one process needs to manipulate a large file. You would have to open, read and write to the file, and close it. If the file is already mapped in memory, access to the file is much quicker, which greatly improves I/O access.</p>
<p class="docText"><tt>mmap(), mmap64()</tt>, and <tt>munmap()</tt> enable you to map and unmap a file in memory to be shared by two or more processes for I/O processing, and they are really easy to use. A few simple calls, mixed with a few simple rules, and you are mapping like a mad person.</p>
<a name="ch05lev3sec57"></a>
<h5 id="title-IDAQM3QX" class="docSection3Title">5.11.13.1. AIX Prototype</h5>
<div class="docText"><pre>#include &lt;sys/types.h&gt;
#include &lt;sys/mman.h&gt;
void *<a name="iddle1841"></a><a name="iddle2340"></a><a name="iddle2382"></a>mmap (void *<span class="docEmphasis">addr</span>, size_t <span class="docEmphasis">len</span>, int <span class="docEmphasis">prot</span>, int <span class="docEmphasis">flags</span>, int <span class="docEmphasis">fildes</span>, off_t <span class="docEmphasis">off</span>);
void *mmap64 (void *<span class="docEmphasis">addr</span>, size_t <span class="docEmphasis">len</span>, int <span class="docEmphasis">prot</span>, int <span class="docEmphasis">flags</span>, int <span class="docEmphasis">fildes</span>, off_t <span class="docEmphasis">off</span>);
int <a name="iddle1861"></a><a name="iddle2344"></a><a name="iddle2386"></a>munmap (void *<span class="docEmphasis">addr</span>, size_t <span class="docEmphasis">len</span>);
</pre></div><br>

<a name="ch05lev3sec58"></a>

<h5 id="title-IDAPQ3QX" class="docSection3Title">5.11.13.2. Linux Prototype</h5>
<div class="docText"><pre>#include &lt;unistd.h&gt;
#include &lt;sys/mman.h&gt;
#ifdef _POSIX_MAPPED_FILES
void * mmap(void *<span class="docEmphasis">start</span>, size_t <span class="docEmphasis">length</span>, int <span class="docEmphasis">prot</span>, int <span class="docEmphasis">flags</span>, int <span class="docEmphasis">fd</span>, off_t <span class="docEmphasis">offset</span>);
void * mmap64(void *<span class="docEmphasis">start</span>, size_t <span class="docEmphasis">length</span>, int <span class="docEmphasis">prot</span>, int <span class="docEmphasis">flags</span>, int <span class="docEmphasis">fd</span>, off_t <span class="docEmphasis">off</span>);
int munmap(void *<span class="docEmphasis">start</span>, size_t <span class="docEmphasis">length</span>);
#endif
</pre></div><br>

<a name="ch05lev3sec59"></a>
<h5 id="title-IDA3R3QX" class="docSection3Title">5.11.13.3. Detail Comparison</h5>
<p class="docText">**Compatible**</p>
<p class="docText">Values for <tt>prot</tt> are identical to AIX. In AIX, <tt>mmap()</tt> and <tt>munmap()</tt> are system calls.</p>
<p class="docText">The <tt>mmap</tt> function asks to map <span class="docEmphasis"><tt>length</tt></span> bytes starting at <span class="docEmphasis"><tt>offset</tt></span> from the file (or other object) specified by the file descriptor <span class="docEmphasis"><tt>fd</tt></span> into memory, preferably at address <tt>start</tt>. If <tt><a name="iddle1803"></a>MAP_FIXED</tt> is used, the start address (<span class="docEmphasis"><tt>addr</tt></span>) is a hint only and is usually specified as 0<a name="d0e45143"></a>. The actual place where the object is mapped is returned by <tt>mmap</tt> and is never 0.</p>
<p class="docText">The <tt>prot</tt> argument describes the desired memory protection (and must not conflict with the open mode of the file). It is either <tt><a name="iddle2039"></a>PROT_NONE</tt> or is the bitwise OR of one or more of the other <tt>PROT_*</tt> flags:<a name="d0e45164"></a></p>
<UL><li><p class="docText"><span class="docEmphStrong"><tt><a name="iddle2038"></a>PROT_EXEC</tt>.</span> Pages may be executed.<a name="d0e45181"></a></p></li><LI><p class="docText"><span class="docEmphStrong"><tt><a name="iddle2040"></a>PROT_READ</tt>.</span> Pages may be read.<a name="d0e45196"></a></P></LI><LI><p class="docText"><span class="docEmphStrong"><tt><a name="iddle2041"></a>PROT_WRITE</tt>.</span> Pages may be written.<a name="d0e45211"></a></P></li><li><p class="docText"><span class="docEmphStrong"><tt>PROT_NONE</tt>.</span> Pages may not be accessed.</p></LI></UL>
<p class="docText">The <span class="docEmphasis"><tt>flags</tt></span> parameter specifies the type of the mapped object, mapping options, and whether modifications made to the mapped copy of the page are private to the process or are to be shared with other references. Bits (below) are used to tell the system how the file will be mapped:</P>
<UL><LI><p class="docList"><tt>MAP_FIXED</tt></p><p class="docList">If start address <span class="docEmphasis"><tt>addr</tt></span> is anything other than 0, do not select a different address than the one specified. If the nonzero specified address cannot be used, <tt>mmap</tt> will fail. If <tt>MAP_FIXED</tt> is specified, <span class="docEmphasis"><tt>start</tt></span> must be a multiple of the page size. Use of this option is discouraged since it may prevent a system from making the most effective use of its resources.</P></li><li><p class="docList"><tt><a name="iddle1808"></a>MAP_SHARED</tt><a name="d0e45265"></a></P><p class="docList">Share this mapping with all other processes that map this object. Storing to the region is equivalent to writing to the file. The file may not actually be updated until <tt>msync</tt> or <tt>munmap</tt> is called.</P></li><li><p class="docList"><tt><a name="iddle1807"></a>MAP_PRIVATE</tt><a name="d0e45284"></a></p><p class="docList">Create a private copy-on-write mapping. Stores to the region do not affect the original file. It is unspecified whether changes made to the file after the <tt>mmap</tt> call are visible in the mapped region.</p></LI></ul>
<p class="docText">You must specify exactly one of <tt>MAP_SHARED</tt> and <tt>MAP_PRIVATE</tt>.</p>
<p class="docText">The preceding three flags are described in POSIX.1b (formerly POSIX.4) and SUSv2. Linux also is aware of the following nonstandard flags:</p>
<ul><LI><p class="docList"><tt><a name="iddle1800"></a>MAP_DENYWRITE</tt><a name="d0e45315"></a></P><p class="docList">This flag is ignored. (Long ago, it signaled that attempts to write to the underlying file should fail with <tt>ETXTBUSY</tt>, but this was a source of denial-of-service attacks.)</p></li><li><p class="docList"><tt><a name="iddle1801"></a>MAP_EXECUTABLE</tt><a name="d0e45331"></a></p><p class="docList">This flag is ignored.</p></li><li><p class="docList"><tt><a name="iddle1806"></a>MAP_NORESERVE</tt><a name="d0e45344"></a></p><p class="docList">(Used together with <tt>MAP_PRIVATE</tt>.) Do not reserve swap space pages for this mapping. When swap space is reserved, you have the guarantee that it is possible to modify this private copy-on-write region. When it is not reserved, you might get <tt>SIGSEGV</tt> upon a write when no memory is available.</p></li><li><p class="docList"><tt><a name="iddle1805"></a>MAP_LOCKED</tt><a name="d0e45363"></a></p><p class="docList">This flag is ignored.</p></li><LI><p class="docList"><tt><a name="iddle1804"></a>MAP_GROWSDOWN</tt><a name="d0e45376"></a></p><p class="docList">Used for stacks. Indicates to the kernel VM system that the mapping should extend downward in memory.</p></li><LI><p class="docList"><tt><a name="iddle1798"></a><a name="iddle1799"></a>MAP_ANONYMOUS</tt><a name="d0e45394"></a><a name="d0e45395"></a></P><p class="docList">The mapping is not backed by any file; the <span class="docEmphasis"><tt>fd</tt></span> and <span class="docEmphasis"><tt>offset</tt></span> arguments are ignored. This flag in conjunction with <tt>MAP_SHARED</tt> has been implemented since Linux 2.4.</P></LI><LI><p class="docList"><tt>MAP_ANON</tt></p><p class="docList">Alias for <tt>MAP_ANONYMOUS</tt>. Deprecated.</p></li><LI><p class="docList"><tt><a name="iddle1802"></a>MAP_FILE</tt><a name="d0e45430"></a></P><p class="docList">Compatibility flag. Ignored.</P></LI></UL>
<p class="docText">Some systems document the additional flags <tt>MAP_AUTOGROW, MAP_AUTORESRV, MAP_COPY</tt>, and <tt>MAP_LOCAL</tt>.</p>
<p class="docText"><span class="docEmphasis"><tt>fd</tt></span> should be a valid file descriptor, unless <tt>MAP_ANONYMOUS</tt> is set, in which case the argument is ignored.</P>
<p class="docText"><span class="docEmphasis"><tt>offset</tt></span> should be a multiple of the page size as returned by <tt>getpagesize</tt>.</p>
<p class="docText">Memory mapped by <tt>mmap</tt> is preserved across <tt>fork()</tt>, with the same attributes.</p>
<p class="docText">A file is mapped in multiples of the page size. For a file that is not a multiple of the page size, the remaining memory is zeroed when mapped and writes to that region are not written out to the file. The effect of changing the size of the underlying file of a mapping on the pages that correspond to added or removed regions of the file is unspecified.</P>
<p class="docText">The <tt>munmap</tt> system call deletes the mappings for the specified address range and causes further references to addresses within the range to generate invalid memory references. The region is also automatically unmapped when the process is terminated. That said, closing the file descriptor does not unmap the region.</P>
<p class="docText">The address <span class="docEmphasis"><tt>start</tt></span> must be a multiple of the page size. All pages containing a part of the indicated range are unmapped, and subsequent references to these pages will generate <tt>SIGSEGV</tt>. It is not an error if the indicated range does not contain any mapped pages.</p>
<p class="docText">For file-backed mappings, the <tt>st_atime</tt> field for the mapped file may be updated at any time between the <tt>mmap()</tt> and the corresponding unmapping; the first reference to a mapped page will update the field if necessary.</p>
<p class="docText">The <tt>st_ctime</tt> and <tt>st_mtime</tt> fields for a file mapped with <tt>PROT_WRITE</tt> and <tt>MAP_SHARED</tt> will be updated after a write to the mapped region, and before a subsequent <tt>msync()</tt>, with the <tt>MS_SYNC</tt> or <tt>MS_ASYNC</tt> flag, if one occurs.</p>

<a name="ch05lev3sec60"></a>
<h5 id="title-IDASC4QX" class="docSection3Title">5.11.13.4. Return Value</H5>
<p class="docText">On success, <tt><a name="iddle1291"></a>mmap</tt> returns a pointer to the mapped area<a name="d0e45542"></a>. On error, <tt>MAP_FAILED</tt> (1) is returned, and <span class="docEmphasis"><tt>ERRNO</tt></span> is set appropriately. On success, <tt><a name="iddle1293"></a>munmap</tt> returns 0, on failure 1, and <span class="docEmphasis"><tt>ERRNO</tt></span> is set (probably to <tt>EINVAL</tt>).<a name="d0e45567"></a></p>

<a name="ch05lev3sec61"></a>
<h5 id="title-IDAQE4QX" class="docSection3Title">5.11.13.5. Errors</h5>
<ul><LI><p class="docText"><span class="docEmphStrong"><tt>EBADF</tt>.</span> <span class="docEmphasis"><tt>fd</tt></span> is not a valid file descriptor (and <tt>MAP_ANONYMOUS</tt> was not set).</P></li><li><p class="docText"><span class="docEmphStrong"><tt>EACCES</tt>.</span> The file descriptor (<span class="docEmphasis"><tt>fd</tt></span>) refers to a nonregular file. Or <tt>MAP_PRIVATE</tt> was requested, but <span class="docEmphasis"><tt>fd</tt></span> is not open for reading. Or <tt>MAP_SHARED</tt> was requested and <tt>PROT_WRITE</tt> is set, but <span class="docEmphasis"><tt>fd</tt></span> is not open in read/write (<tt>O_RDWR</tt>) mode. Or <tt>PROT_WRITE</tt> is set, but the file is append-only.</p></li><li><p class="docText"><span class="docEmphStrong"><tt>EINVAL</tt>.</span> <span class="docEmphasis"><tt>Start</tt></span>, <span class="docEmphasis"><tt>length</tt></span><span class="docEmphasis">,</span> or <span class="docEmphasis"><tt>offset</tt></span> are too large or are not aligned on a <tt>PAGESIZE</tt> boundary.</p></li><li><p class="docText"><span class="docEmphStrong"><tt>ETXTBSY</tt>.</span> <tt>MAP_DENYWRITE</tt> was set, but the object specified by <span class="docEmphasis"><tt>fd</tt></span> is open for writing.</p></li><li><p class="docText"><span class="docEmphStrong"><tt>EAGAIN</tt>.</span> The file has been locked, or too much memory has been locked.</p></li><li><p class="docText"><span class="docEmphStrong"><tt>ENOMEM</tt>.</span> No memory is available, or the process's maximum number of mappings would have been exceeded.</P></li><li><p class="docText"><span class="docEmphStrong"><tt>ENODEV</tt>.</span> The underlying filesystem of the specified file does not support memory mapping.</p></LI></UL>
<p class="docText">Use of a mapped region can result in these signals:</P>
<UL><LI><p class="docText"><span class="docEmphStrong"><tt>SIGSEGV</tt>.</span> Attempted write into a region specified to <tt>mmap</tt> as read-only.</p></li><li><p class="docText"><span class="docEmphStrong"><tt>SIGBUS</tt>.</span> Attempted access to a portion of the buffer that does not correspond to the file (for example, beyond the end of the file, including the case where another process has truncated the file).</P></LI></UL>

<a name="ch05lev3sec62"></a>

<H5 id="title-IDASJ4QX" class="docSection3Title">5.11.13.6. ERRNO(s) Not Implemented in Linux</H5>
<ul><LI><p class="docText"><span class="docEmphStrong"><tt>EFBIG</tt>.</span> The mapping requested extends beyond the maximum file size associated with <span class="docEmphasis"><tt>fildes</tt></span>.<a name="d0e45755"></a><a name="d0e45756"></a><a name="d0e45757"></a><a name="d0e45758"></a><a name="d0e45759"></a><a name="d0e45760"></a></p></li><LI><p class="docText"><span class="docEmphStrong"><tt>EMFILE</tt>.</span> The application has requested SPEC1170-compliant behavior,<sup class="docFootnote"><a class="docLink" href="#ch05fn18">[18]</a></sup> and the number of mapped regions would exceed an implementation-dependent limit (per process or per system).<blockquote><p class="docFootnote"><sup><a name="ch05fn18">[18]</a></sup> SPEC1170-complaint means that <tt>addr</tt> is 0, so let the system allocate a region in memory and return the pointer. If not, use the value specified by <tt>addr</tt>.</P></blockquote></p></li><li><p class="docText"><span class="docEmphStrong"><tt>ENXIO</tt>.</span> The addresses specified by the range (<tt>off, off+len</tt>) are invalid for the <span class="docEmphasis"><tt>fildes</tt></span> parameter.</p></LI><li><p class="docText"><span class="docEmphStrong"><tt>EOVERFLOW</tt>.</span> The mapping requested extends beyond the offset maximum for the file description associated with <span class="docEmphasis"><tt>fildes</tt></span>.</p></li></ul>
<a name="ch05lev4sec3"></a>
<H5 id="title-IDA5M4QX" class="docSection4Title">Conforming To</H5>
<p class="docText">SVr4, POSIX.1b (formerly POSIX.4), 4.4BSD, SUSv2. SVr4 documents additional error codes <tt>ENXIO</tt> and <tt>ENODEV</tt>. SUSv2 documents additional error codes <tt>EMFILE</tt> and <tt>EOVERFLOW</tt>.</p>



<a name="ch05lev2sec31"></a>
<h4 id="title-IDAWN4QX" class="docSection2Title">5.11.14. <a name="iddle2028"></a><a name="iddle2348"></a><a name="iddle2389"></a>pread(), <a name="iddle2067"></a><a name="iddle2350"></a><a name="iddle2391"></a>pwrite()</h4>
<p class="docText">This command reads from or writes to a file descriptor at a given offset.</p>
<a name="ch05lev3sec63"></a>
<h5 id="title-IDAPQ4QX" class="docSection3Title">5.11.14.1. Linux Prototype</h5>
<div class="docText"><pre>b#define _XOPEN_SOURCE 500
#include &lt;unistd.h&gt;
ssize_t pread(int fd, void *buf, size_t count, off_t offset);
ssize_t pwrite(int fd, const void *buf, size_t count, off_t offset);
</pre></div><br>

<a name="ch05lev3sec64"></a>

<h5 id="title-IDADR4QX" class="docSection3Title">5.11.14.2. AIX Prototype</h5>
<div class="docText"><pre>#include &lt;unistd.h&gt;
ssize_t pread(int fildes, void *buf, size_t nbyte, off_t offset);
ssize_t pwrite (int FileDescriptor, const void *Buffer, size_t NBytes, off_t
Offset);
</pre></div><br>

<a name="ch05lev3sec65"></a>
<h5 id="title-IDAVR4QX" class="docSection3Title">5.11.14.3. Detail Comparison</h5>
<p class="docText">**Compatible**</p>
<p class="docText"><tt>pread()</tt> reads up to <span class="docEmphasis"><tt>count</tt></span> bytes from file descriptor <span class="docEmphasis"><tt>fd</tt></span> at offset <span class="docEmphasis"><tt>offset</tt></span> (from the start of the file) into the buffer starting at <span class="docEmphasis"><tt>buf</tt></span>. The file offset is not changed.</p>
<p class="docText"><tt>pwrite()</tt> writes up to <span class="docEmphasis"><tt>count</tt></span> bytes from the buffer starting at <span class="docEmphasis"><tt>buf</tt></span> to the file descriptor <span class="docEmphasis"><tt>fd</tt></span> at offset <span class="docEmphasis"><tt>offset</tt></span>. The file offset is not changed.</P>
<p class="docText">The file referenced by <span class="docEmphasis"><tt>fd</tt></span> must be capable of seeking.</p>

<a name="ch05lev3sec66"></a>
<h5 id="title-IDAHT4QX" class="docSection3Title">5.11.14.4. Additional Data: Linux-Specific</h5>
<p class="docText">Functions are source-compatible, but note the #<tt>define _XOPEN_SOURCE 500</tt> for Linux. <tt>_XOPEN_SOURCE 500</tt> does not have to be explicitly defined by the user for all versions of Linux.</P>

<a name="ch05lev3sec67"></a>
<H5 id="title-IDAYT4QX" class="docSection3Title">5.11.14.5. Return Value</H5>
<p class="docText">On success, the number of bytes read or written is returned (0 indicates that nothing was written, in the case of <tt>pwrite</tt>, or end of file, in the case of <tt>pread</tt>), or 1 on error, in which case <span class="docEmphasis"><tt>ERRNO</tt></span> is set to indicate the error.</P>

<a name="ch05lev3sec68"></a>
<H5 id="title-IDAMU4QX" class="docSection3Title">5.11.14.6. Errors</h5>
<p class="docText"><tt>pread</tt> can fail and set <span class="docEmphasis"><tt>ERRNO</tt></span> to any error specified for <tt>read</tt> or <tt>lseek</tt>. <tt>pwrite</tt> can fail and set <span class="docEmphasis"><tt>ERRNO</tt></span> to any error specified for <tt>write</tt> or <tt>lseek</tt>.</p>

<a name="ch05lev3sec69"></a>
<h5 id="title-IDAKV4QX" class="docSection3Title">5.11.14.7. ERRNO(s) Not Implemented in Linux</H5>
<UL><LI><p class="docText"><span class="docEmphStrong"><tt>EBADMSG</tt>.</span> The file is a <tt>STREAM</tt> file that is set to control-normal mode, and the message waiting to be read includes a control part.</P></LI><li><p class="docText"><span class="docEmphStrong"><tt>EDEADLK</tt>.</span> A deadlock would occur if the calling process were to sleep until the region to be read was unlocked.</P></li><li><p class="docText"><span class="docEmphStrong"><tt>EOVERFLOW</tt>.</span> An attempt was made to read from a regular file where <span class="docEmphasis"><tt>NBytes</tt></span> was greater than 0 and the starting <span class="docEmphasis"><tt>offset</tt></span> was before the end of file and was greater than or equal to the <span class="docEmphasis"><tt>offset</tt></span> maximum established in the open file description associated with <tt>FileDescriptor</tt>.<a name="d0e46097"></a><a name="d0e46098"></a><a name="d0e46099"></a><a name="d0e46100"></a><a name="d0e46101"></a><a name="d0e46102"></a></P></LI><li><p class="docText"><span class="docEmphStrong"><tt>ENXIO</tt>.</span> A request was made of a nonexistent device, or the request was outside the capabilities of the device.</p></li><li><p class="docText"><span class="docEmphStrong"><tt>ESPIPE</tt>.</span> <span class="docEmphasis"><tt>fildes</tt></span> is associated with a pipe or FIFO.</P></li><li><p class="docText"><span class="docEmphStrong"><tt>ETIMEDOUT</tt>.</span> The connection timed out.</p></li></UL>
<a name="ch05lev4sec4"></a>
<H5 id="title-IDAIZ4QX" class="docSection4Title">Conforming To</h5>
<p class="docText">Unix98</p>



<a name="ch05lev2sec32"></a>
<h4 id="title-IDAWZ4QX" class="docSection2Title">5.11.15. stat(), lstat(), fstat()</h4>
<p class="docText">These functions return information about the specified file. You do not need any access rights to the file to get this information, but you need search rights to all directories named in the path leading to the file.</p>
<a name="ch05lev3sec70"></a>
<h5 id="title-IDAB04QX" class="docSection3Title">5.11.15.1. AIX Prototype</h5>
<div class="docText"><pre>#include &lt;sys/stat.h&gt;
int stat(const char * Path, struct <a name="iddle2298"></a><a name="iddle2359"></a><a name="iddle2398"></a>stat * Buffer);
int <a name="iddle1786"></a><a name="iddle2339"></a><a name="iddle2381"></a>lstat (const char * Path, struct stat * Buffer);
int <a name="iddle1368"></a><a name="iddle2327"></a><a name="iddle2375"></a>fstat (int FileDescriptor, struct stat * Buffer);
</pre></div><br>

<a name="ch05lev3sec71"></a>
<h5 id="title-IDAF44QX" class="docSection3Title">5.11.15.2. Linux Prototype</h5>
<div class="docText"><pre>#include &lt;sys/types.h&gt;
#include &lt;sys/stat.h&gt;
#include &lt;unistd.h&gt;
int stat(const char *file_name, struct stat * buf);
int fstat(int filedes, struct stat * buf);
int lstat(const char *file_name, struct stat * buf);
</pre></div><br>

<a name="ch05lev3sec72"></a>
<h5 id="title-IDAX44QX" class="docSection3Title">5.11.15.3. Detail Comparison</h5>
<p class="docText">**Compatible**</p>
<p class="docText">Functions are source-compatible. Code that references <tt>dev_t</tt>s may not work correctly unless the macros <tt>major(), minor()</tt>, and <tt>makedev()</tt> are used. These are found in sys/sysmacros.h.<a name="d0e46270"></a><a name="d0e46271"></a><a name="d0e46272"></a><a name="d0e46273"></a><a name="d0e46274"></a><a name="d0e46275"></a><a name="d0e46276"></a><a name="d0e46277"></a><a name="d0e46278"></a></P>

<a name="ch05lev3sec73"></a>
<h5 id="title-IDA3A5QX" class="docSection3Title">5.11.15.4. ERRNO(s) Not Implemented in AIX</h5>
<ul><LI><p class="docText"><span class="docEmphStrong"><tt>ESTALE</tt></span>. The root or current directory of the process is located in a virtual filesystem that has been unmounted.</P></LI><LI><p class="docText"><span class="docEmphStrong"><tt>ETIMEDOUT</tt>.</span> The connection timed out.</P></li><li><p class="docText"><span class="docEmphStrong"><tt>EIO</tt>.</span> An input/output (I/O) error occurred while reading from the filesystem.</p></LI></UL>


<a name="ch05lev2sec33"></a>
<H4 id="title-IDALC5QX" class="docSection2Title">5.11.16. <a name="iddle2049"></a><a name="iddle2349"></a><a name="iddle2390"></a>ptrace()</H4>
<p class="docText">The <tt>ptrace</tt> system call provides a means by which a parent process may observe and control the execution of another process and examine and change its core image and registers. It is primarily used to implement breakpoint debugging and system call tracing.</P>
<a name="ch05lev3sec74"></a>
<h5 id="title-IDA4D5QX" class="docSection3Title">5.11.16.1. AIX Prototype</H5>
<div class="docText"><pre>#include &lt;sys/reg.h&gt;
#include &lt;sys/ptrace.h&gt;
#include &lt;sys/ldr.h&gt;
int ptrace(int Request, int Identifier, int *Address, int Data, int *Buffer);
</pre></div><br>

<a name="ch05lev3sec75"></a>
<h5 id="title-IDAQE5QX" class="docSection3Title">5.11.16.2. AIX5L Prototype</H5>
<div class="docText"><pre>#define _LINUX_SOURCE_COMPAT
#include &lt;sys/ptrace.h&gt;
long int ptrace(enum ptrace_request request, pid_t pid, void *addr, void *data);
</pre></div><BR>

<a name="ch05lev3sec76"></a>
<h5 id="title-IDACF5QX" class="docSection3Title">5.11.16.3. Linux Prototype</h5>
<div class="docText"><pre>#include &lt;sys/ptrace.h&gt;
long int ptrace(enum ptrace_request request, pid_t pid, void *addr, void *data);
</pre></div><br>

<a name="ch05lev3sec77"></a>

<h5 id="title-IDAWF5QX" class="docSection3Title">5.11.16.4. Detail Comparison</H5>
<p class="docText">**Not Compatible**</p>
<p class="docText">Although the service the API provides is similar between AIX and Linux, the way the tracing service is implemented differs. In Linux, kernel-level thread debugging is not possible with the <tt>ptrace</tt> as in AIX. And, in AIX, code built with the <tt>_LINUX_SOURCE_COMPAT</tt> directive is more compatible with the Linux <tt>ptrace</tt>.</p>
<p class="docText">The parent can initiate a trace by calling <tt>fork</tt> and having the resulting child do a <tt><a name="iddle2066"></a>PTRACE_TRACEME</tt>, followed (typically) by an <tt>exec</tt><a name="d0e46426"></a>. Alternatively, the parent may commence trace of an existing process using <tt>PTRACE_ATTACH</tt>.</p>
<p class="docText">While being traced, the child will stop each time a signal is delivered, even if the signal is being ignored. (The exception is <tt>SIGKILL</tt>, which has its usual effect.) The parent will be notified at its next <tt>wait</tt> and may inspect and modify the child process while it is stopped. The parent then causes the child to continue, optionally ignoring the delivered signal (or even delivering a different signal instead).</p>
<p class="docText">When the parent is finished tracing, it can terminate the child with <tt>PTRACE_KILL</tt> or cause it to continue executing in a normal, untraced mode via <tt>PTRACE_DETACH</tt>.</P>
<p class="docText">The value of <span class="docEmphasis"><tt>request</tt></span> determines the action to be performed:</P>
<ul><li><p class="docList"><tt>PTRACE_TRACEME</tt></p><p class="docList">Indicates that this process is to be traced by its parent. Any signal (except <tt>SIGKILL</tt>) delivered to this process will cause it to stop and its parent to be notified via <tt>wait</tt>. Also, all subsequent calls to <tt>exec</tt> by this process will cause a <tt>SIGTRAP</tt> to be sent to it, giving the parent a chance to gain control before the new program begins execution. A process probably should not make this request if its parent is not expecting to trace it. (<span class="docEmphasis"><tt>pid</tt></span>, <span class="docEmphasis"><tt>addr</tt></span>, and <span class="docEmphasis"><tt>data</tt></span> are ignored.)</p><p class="docList">The preceding request is used only by the child process; the rest are used only by the parent. In the following requests, <span class="docEmphasis"><tt>pid</tt></span> specifies the child process to be acted on. For requests other than <tt>PTRACE_KILL</tt>, the child process must be stopped.</p></li><li><p class="docList"><tt><a name="iddle2057"></a>PTRACE_PEEKTEXT, <a name="iddle2056"></a>PTRACE_PEEKDATA</tt><a name="d0e46515"></a><a name="d0e46516"></a></p><p class="docList">Read a word at the location <span class="docEmphasis"><tt>addr</tt></span> in the child's memory, returning the word as the result of the <tt>ptrace</tt> call. Linux does not have separate text and data address spaces, so the two requests are currently equivalent. (The argument <span class="docEmphasis"><tt>data</tt></span> is ignored.)</p></li><li><p class="docList"><tt><a name="iddle2058"></a>PTRACE_PEEKUSR</tt><a name="d0e46540"></a></p><p class="docList">Reads a word at offset <span class="docEmphasis"><tt>addr</tt></span> in the child's USER area, which holds the registers and other information about the process (see sys/user.h). The word is returned as the result of the <tt>ptrace</tt> call. Typically, the offset must be word-aligned, although this might vary by architecture. (<span class="docEmphasis"><tt>data</tt></span> is ignored.)</p></li><LI><p class="docList"><tt><a name="iddle2060"></a>PTRACE_POKETEXT, <a name="iddle2059"></a>PTRACE_POKEDATA</tt><a name="d0e46569"></a><a name="d0e46570"></a></p><p class="docList">Copy the word <span class="docEmphasis"><tt>data</tt></span> to location <span class="docEmphasis"><tt>addr</tt></span> in the child's memory. As above, the two requests are currently equivalent.</p></li><LI><p class="docList"><tt><a name="iddle2061"></a>PTRACE_POKEUSR</tt><a name="d0e46591"></a></P><p class="docList">Copies the word <span class="docEmphasis"><tt>data</tt></span> to offset <span class="docEmphasis"><tt>addr</tt></span> in the child's user area. As above, the offset must typically be word-aligned. To maintain the integrity of the kernel, some modifications to the user area are disallowed.</P></LI><LI><p class="docList"><tt><a name="iddle2054"></a>PTRACE_GETREGS, <a name="iddle2053"></a>PTRACE_GETFPREGS</tt><a name="d0e46617"></a><a name="d0e46618"></a></p><p class="docList">Copy the child's general purpose or floating-point registers, respectively, to location <span class="docEmphasis"><tt>data</tt></span> in the parent. See sys/user.h for information on the format of this data. (<span class="docEmphasis"><tt>addr</tt></span> is ignored.)</p></li><LI><p class="docList"><tt><a name="iddle2063"></a>PTRACE_SETREGS, <a name="iddle2062"></a>PTRACE_SETFPREGS</tt><a name="d0e46644"></a><a name="d0e46645"></a></P><p class="docList">Copy the child's general purpose or floating-point registers, respectively, from location <span class="docEmphasis"><tt>data</tt></span> in the parent. As for <tt>PTRACE_POKEUSER</tt>, some general-purpose register modifications may be disallowed. (<span class="docEmphasis"><tt>addr</tt></span> is ignored.)</P></LI><LI><p class="docList"><tt><a name="iddle2051"></a>PTRACE_CONT</tt><a name="d0e46669"></a></p><p class="docList">Restarts the stopped child process. If <span class="docEmphasis"><tt>data</tt></span> is nonzero and not <tt>SIGSTOP</tt>, it is interpreted as a signal to be delivered to the child; otherwise, no signal is delivered. Thus, for example, the parent can control whether a signal sent to the child is delivered or not. (<span class="docEmphasis"><tt>addr</tt></span> is ignored.)</P></li><li><p class="docList"><tt><a name="iddle2065"></a>PTRACE_SYSCALL, <a name="iddle2064"></a>PTRACE_SINGLESTEP</tt><a name="d0e46699"></a><a name="d0e46700"></a><a name="d0e46701"></a><a name="d0e46702"></a><a name="d0e46703"></a></P><p class="docList">Restart the stopped child as for <tt>PTRACE_CONT</tt>, but arrange for the child to be stopped at the next entry to or exit from a system call, or after execution of a single instruction, respectively. (The child will also, as usual, be stopped upon receipt of a signal.) From the parent's perspective, the child will appear to have been stopped by receipt of a <tt>SIGTRAP</tt>. So, for <tt>PTRACE_SYSCALL</tt>, for example, the idea is to inspect the arguments to the system call at the first stop, and then do another <tt>PTRACE_SYSCALL</tt> and inspect the return value of the system call at the second stop. (<span class="docEmphasis"><tt>addr</tt></span> is ignored.)</P></li><li><p class="docList"><tt><a name="iddle2055"></a>PTRACE_KILL</tt><a name="d0e46732"></a></p><p class="docList">Sends the child a <tt>SIGKILL</tt> to terminate it. (<span class="docEmphasis"><tt>addr</tt></span> and <span class="docEmphasis"><tt>data</tt></span> are ignored.)</p></LI><li><p class="docList"><tt><a name="iddle2050"></a>PTRACE_ATTACH</tt><a name="d0e46756"></a></p><p class="docList">Attaches to the process specified in <span class="docEmphasis"><tt>pid</tt></span>, making it a traced &quot;child&quot; of the current process; the behavior of the child is as if it had done a <tt>PTRACE_TRACEME</tt>. The current process actually becomes the parent of the child process for most purposes (for example, it will receive notification of child events and appears in <tt>ps</tt> output as the child's parent), but a <tt>getppid</tt> by the child will still return the <tt>pid</tt> of the original parent. The child is sent a <tt>SIGSTOP</tt>, but will not necessarily have stopped by the completion of this call; use <tt>wait</tt> to wait for the child to stop. (<span class="docEmphasis"><tt>addr</tt></span> and <span class="docEmphasis"><tt>data</tt></span> are ignored.)</p></li><LI><p class="docList"><tt><a name="iddle2052"></a>PTRACE_DETACH</tt><a name="d0e46799"></a></P><p class="docList">Restarts the stopped child as for <tt>PTRACE_CONT</tt>, but first detaches from the process, undoing the reparenting effect of <tt>PTRACE_ATTACH</tt> and the effects of <tt>PTRACE_TRACEME</tt>. Although perhaps not intended, under Linux a traced child can be detached in this way regardless of which method was used to initiate tracing. (<span class="docEmphasis"><tt>addr</tt></span> is ignored.)</p></li></ul>

<a name="ch05lev3sec78"></a>
<h5 id="title-IDAVW5QX" class="docSection3Title">5.11.16.5. ERRNO(s) Not Implemented in Linux</h5>
<ul><li><p class="docText"><span class="docEmphStrong"><tt>ENOTSUP</tt>.</span> The request is not supported.</p></li><li><p class="docText"><span class="docEmphStrong"><tt>EINVAL</tt>.</span> The debugger and the traced process are the same; or the <tt>Identifier</tt> parameter does not identify the thread that caused the exception.</p></li></ul>


<a name="ch05lev2sec34"></a>

<h4 id="title-IDACY5QX" class="docSection2Title">5.11.17. <a name="iddle2141"></a><a name="iddle2357"></a><a name="iddle2396"></a>setgid(), <a name="iddle2142"></a><a name="iddle2358"></a><a name="iddle2397"></a>setregid()</H4>
<p class="docText">These commands are used to set the user and group permission on a particular file or device.<a name="d0e46906"></a><a name="d0e46907"></a><a name="d0e46908"></a><a name="d0e46909"></a><a name="d0e46910"></a><a name="d0e46911"></a></p>
<a name="ch05lev3sec79"></a>
<h5 id="title-IDAX15QX" class="docSection3Title">5.11.17.1. AIX/Linux Prototype</h5>
<div class="docText"><pre>#include &lt;unistd.h&gt;
int setgid(gid_t gid);
int setregid(gid_t rgid, gid_t egid);
</pre></div><BR>

<a name="ch05lev3sec80"></a>
<H5 id="title-IDAJ25QX" class="docSection3Title">5.11.17.2. Detail Comparison</H5>
<p class="docText">**Compatible**</P>
<p class="docText">Functions are source-compatible, but in AIX <tt>setgid</tt> sets the effective group ID of the current process. In Linux if the caller is the super user, the real and saved group IDs are also set.</P>
<p class="docText"><tt>setreuid</tt> sets real and effective user IDs of the current process. Unprivileged users may only set the real user ID to the real user ID or the effective user ID, and may only set the effective user ID to the real user ID, the effective user ID, or the saved user ID.</p>

<a name="ch05lev3sec81"></a>
<h5 id="title-IDA425QX" class="docSection3Title">5.11.17.3. Return Value</h5>
<p class="docText">On success, 0 is returned. On error, 1 is returned, and <span class="docEmphasis"><tt>ERRNO</tt></span> is set appropriately.</P>

<a name="ch05lev3sec82"></a>
<H5 id="title-IDAO35QX" class="docSection3Title">5.11.17.4. Errors</H5>
<UL><LI><p class="docText"><span class="docEmphStrong"><tt>EPERM</tt>.</span> The user is not the super user (does not have the <tt>CAP_SETGID</tt> capability), and <span class="docEmphasis"><tt>gid</tt></span> does not match the effective group ID or saved set-group-ID of the calling process.</p></LI></ul>

<a name="ch05lev3sec83"></a>
<h5 id="title-IDAN45QX" class="docSection3Title">5.11.17.5. ERRNO(s) Not Implemented in Linux</H5>
<UL><li><p class="docText"><span class="docEmphStrong"><tt>EINVAL</tt>.</span> Indicates that the value of the <span class="docEmphasis"><tt>gid</tt></span> parameter is invalid.</p></li></ul>


<a name="ch05lev2sec35"></a>

<H4 id="title-IDAO55QX" class="docSection2Title">5.11.18. <a name="iddle2317"></a><a name="iddle2363"></a><a name="iddle2402"></a>sync()</h4>
<p class="docText">Reading from a disk is very slow compared to accessing (real) memory. In addition, it is common to read the same part of a disk several times during relatively short periods of time. For example, one might first read an e-mail message, then read the letter into an editor when replying to it, and then make the mail program read it again when copying it to a folder. Or, consider how often the command <tt>ls</tt> might be run on a system with many users. By reading the information from disk only once and then keeping it in memory until no longer needed, one can speed up all but the first read. This is called <span class="docEmphasis">disk buffering</span>, and the memory used for this purpose is called the <span class="docEmphasis">buffer cache</span>. <tt>sync()</tt> commits buffer cache to disk.<a name="d0e47051"></a><a name="d0e47052"></a><a name="d0e47053"></a></p>
<a name="ch05lev3sec84"></a>
<h5 id="title-IDAZBARX" class="docSection3Title">5.11.18.1. AIX Prototype</h5>
<div class="docText"><pre>#include &lt;unistd.h&gt;
void sync(void);
</pre></div><BR>

<a name="ch05lev3sec85"></a>
<H5 id="title-IDALCARX" class="docSection3Title">5.11.18.2. Linux Prototype</h5>
<div class="docText"><pre>#include &lt;unistd.h&gt;
int sync(void);
</pre></div><br>

<a name="ch05lev3sec86"></a>
<h5 id="title-IDA3CARX" class="docSection3Title">5.11.18.3. Detail Comparison</h5>
<p class="docText">Functions are <span class="docEmphasis">not quite</span> compatible. In AIX, <tt>sync()</tt> is a void system call. In Linux, <tt>sync()</tt> always returns 0. Any code that tests or assigns the return value of <tt>sync()</tt> will cause compile errors.</p>


<a name="ch05lev2sec36"></a>
<h4 id="title-IDATDARX" class="docSection2Title">5.11.19. <a name="iddle2368"></a><a name="iddle2407"></a><a name="iddle2522"></a>wait3(), <a name="iddle2369"></a><a name="iddle2408"></a><a name="iddle2523"></a>wait4()</h4>
<p class="docText">Often in multiprocess-programming you want to suspend execution of one process until an event of some sort happens either in the current process or in another process. The <tt>wait3</tt><span class="docEmphStrong"></span> and<span class="docEmphStrong"></span> <tt>wait4</tt><span class="docEmphStrong"></span> functions control the running of processes.</p>
<p class="docText">The <tt>wait3</tt> function suspends execution of the current process until a child has exited, or until a signal is delivered whose action is to terminate the current process or to call a signal handling function. If a child has already exited by the time of the call (a so-called zombie process), the function returns immediately. Any system resources used by the child are freed.</p>
<p class="docText">The <tt>wait4</tt> function suspends execution of the current process until a child as specified by the <span class="docEmphasis"><tt>pid</tt></span> argument has exited, or until a signal is delivered whose action is to terminate the current process or to call a signal handling function. If a child as requested by <span class="docEmphasis"><tt>pid</tt></span> has already exited by the time of the call (a zombie process), the function returns immediately. Any system resources used by the child are freed.</p>
<a name="ch05lev3sec87"></a>
<h5 id="title-IDAHHARX" class="docSection3Title">5.11.19.1. AIX Prototype</h5>
<div class="docText"><pre>#define _ALL_SOURCE
#include &lt;sys/types.h&gt;
#include &lt;sys/resource.h&gt;
#include &lt;sys/wait.h&gt;
pid_t wait3(int *StatusLocation, int Options, struct rusage *ResourceUsage);
pid_t wait4(pid_t pid, int *status, int options, struct rusage *rusage);
</pre></div><br>

<a name="ch05lev3sec88"></a>
<h5 id="title-IDAZHARX" class="docSection3Title">5.11.19.2. Linux Prototype</H5>
<div class="docText"><pre>#define _USE_BSD
#include &lt;sys/types.h&gt;
<span class="docEmphStrong">#include &lt;sys/time.h&gt;</span>
<span class="docEmphStrong">#include &lt;sys/resource.h&gt;</span>
<span class="docEmphStrong">#include &lt;sys/wait.h&gt;</span>
pid_t wait3(int *status, int options, struct rusage *rusage);
pid_t wait4(pid_t pid, int *status, int options, struct rusage *rusage);
</pre></div><br>

<a name="ch05lev3sec89"></a>
<h5 id="title-IDA0IARX" class="docSection3Title">5.11.19.3. Detail Comparison</h5>
<p class="docText">**Compatible**</P>
<p class="docText">The value of <span class="docEmphasis"><tt>pid</tt></span> can be one of the following:</P>
<UL><LI><p class="docList">&lt; 1</P><p class="docList">Wait for any child process whose process group ID is equal to the absolute value of <span class="docEmphasis"><tt>pid</tt></span>.</p></li><li><p class="docList">1</P><p class="docList">Wait for any child process; this is equivalent to calling <tt>wait3</tt>.</P></LI><LI><p class="docList">0</P><p class="docList">Wait for any child process whose process group ID is equal to that of the calling process.</p></LI><li><p class="docList">&gt; 0</p><p class="docList">Wait for the child whose process ID is equal to the value of <span class="docEmphasis"><tt>pid</tt></span>.</P></LI></ul>
<p class="docText">The value of <span class="docEmphasis"><tt>options</tt></span> is a bitwise OR of zero or more of the following constants:</p>
<ul><li><p class="docList"><span class="docEmphStrong"><tt><a name="iddle2530"></a>WNOHANG</tt>,</span> which means to return immediately if no child is there to be waited for.<a name="d0e47297"></a></P></li><li><p class="docList"><span class="docEmphStrong"><tt><a name="iddle2535"></a>WUNTRACED</tt>,</span> which means to also return for children that are stopped and whose status has not been reported.<a name="d0e47310"></a></p></li></UL>
<p class="docText">If <span class="docEmphasis"><tt>status</tt></span> is not <a name="iddle1307"></a><tt>NULL, wait3</tt> or <a name="iddle1308"></a><tt>wait4</tt> stores status information in the location pointed to by <span class="docEmphasis"><tt>status</tt></span>.<a name="d0e47341"></a><a name="d0e47342"></a></P>
<p class="docText">This status can be evaluated with the following macros. (These macros take the stat buffer (an <tt>int</tt>) as an argument, not a pointer to the buffer!)</p>
<ul><li><p class="docList"><span class="docEmphStrong"><tt><a name="iddle2526"></a>WIFEXITED(status)</tt></span> is nonzero if the child exited normally.<a name="d0e47362"></a></p></li><li><p class="docList"><span class="docEmphStrong"><tt><a name="iddle2525"></a>WEXITSTATUS(status)</tt></span> evaluates to the least significant 8 bits of the return code of the child that terminated, which may have been set as the argument to a call to <tt>exit()</tt> or as the argument for a return statement in the main program<a name="d0e47377"></a>. This macro can only be evaluated if <tt>WIFEXITED</tt> returned nonzero.</p></li><li><p class="docList"><span class="docEmphStrong"><tt><a name="iddle2527"></a>WIFSIGNALED(status)</tt></span> returns true if the child process exited because of a signal that was not caught.<a name="d0e47393"></a></p></li><li><p class="docList"><span class="docEmphStrong"><tt><a name="iddle2534"></a>WTERMSIG(status)</tt></span> returns the number of the signal that caused the child process to terminate<a name="d0e47405"></a>. This macro can only be evaluated if <tt>WIFSIGNALED</tt> returned nonzero.</p></li><LI><p class="docList"><span class="docEmphStrong"><tt><a name="iddle2528"></a>WIFSTOPPED(status)</tt></span> returns true if the child process that caused the return is currently stopped; this is only possible if the call was done using <tt>WUNtrACED</tt>.<a name="d0e47424"></a></p></li><LI><p class="docList"><span class="docEmphStrong"><tt><a name="iddle2533"></a>WSTOPSIG(status)</tt></span> returns the number of the signal that caused the child to stop<a name="d0e47436"></a>. This macro can only be evaluated if <tt>WIFSTOPPED</tt> returned nonzero.</P></LI></UL>
<p class="docText">If <span class="docEmphasis"><tt>rusage</tt></span> is not <tt>NULL</tt>, the struct <tt>rusage</tt> as defined in sys/resource.h or bit/resource.h it points to will be filled with accounting information.<a name="d0e47456"></a><a name="d0e47457"></a><a name="d0e47458"></a><a name="d0e47459"></a><a name="d0e47460"></a><a name="d0e47461"></a></P>

<a name="ch05lev3sec90"></a>
<h5 id="title-IDA5TARX" class="docSection3Title">5.11.19.4. Return Value</h5>
<p class="docText">The process ID of the child that exited is 1 on error (in particular, when no unwaited-for child processes of the specified kind exist) or 0 if <tt>WNOHANG</tt> was used and no child was available yet. In the latter two cases, <span class="docEmphasis"><tt>ERRNO</tt></span> will be set appropriately.</p>

<a name="ch05lev3sec91"></a>
<H5 id="title-IDARUARX" class="docSection3Title">5.11.19.5. Errors</H5>
<UL><LI><p class="docText"><span class="docEmphStrong"><tt>ECHILD</tt>.</span> No unwaited-for child process as specified exists.</P></li><LI><p class="docText"><span class="docEmphStrong"><tt>EINTR</tt>.</span> If <tt>WNOHANG</tt> was not set and an unblocked signal or a <tt>SIGCHLD</tt> was caught.</p></li></UL>

<a name="ch05lev3sec92"></a>
<H5 id="title-IDAZVARX" class="docSection3Title">5.11.19.6. ERRNO(s) Not Implemented in Linux</h5>
<ul><li><p class="docText"><span class="docEmphStrong"><tt>EFAULT</tt>.</span> The <tt>StatusLocation</tt> or <tt>ResourceUsage</tt> parameter points to a location outside of the address space of the process.</p></LI></ul>


<a name="ch05lev2sec37"></a>
<h4 id="title-IDAYWARX" class="docSection2Title">5.11.20. <a name="iddle1405"></a><a name="iddle2329"></a><a name="iddle2377"></a>getcwd()</h4>
<p class="docText">The <tt>getcwd()</tt> function copies the absolute path name of the current working directory to the array pointed to by <span class="docEmphasis"><tt>buf</tt></span>, which is of length <span class="docEmphasis"><tt>size</tt></span>. If the current absolute path name would require a buffer longer than <span class="docEmphasis"><tt>size</tt></span> elements, <tt>NULL</tt> is returned, and <span class="docEmphasis"><tt>ERRNO</tt></span> is set to <tt>ERANGE</tt>; an application should check for this error and allocate a larger buffer if necessary.</p>
<p class="docText">As an extension to the POSIX.1 standard, <tt>getcwd()</tt> allocates the buffer dynamically using <tt>malloc()</tt> if <span class="docEmphasis"><tt>buf</tt></span> is <tt>NULL</tt> on call. In this case, the allocated buffer has the length <span class="docEmphasis"><tt>size</tt></span> unless <span class="docEmphasis"><tt>size</tt></span> is less than 0, when <span class="docEmphasis"><tt>buf</tt></span> is allocated as big as necessary. It is possible (and, indeed, advisable) to <tt>free()</tt> the buffers if they have been obtained this way.</P>
<p class="docText"><tt>get_current_dir_name</tt>, which is only prototyped if <tt>__USE_GNU</tt> is defined, will <span class="docEmphasis"><tt>malloc()</tt></span> an array big enough to hold the current directory name. If the environment variable <tt>PWD</tt> is set, and its value is correct, that value will be returned.<a name="d0e47642"></a><a name="d0e47643"></a><a name="d0e47644"></a></P>
<p class="docText"><tt>getwd</tt>, which is only prototyped if <tt>__USE_BSD</tt> is defined, will <span class="docEmphasis"><tt>malloc()</tt></span> an array big enough to hold the absolute path name of the current working directory.</p>
<a name="ch05lev3sec93"></a>
<h5 id="title-IDAZ0ARX" class="docSection3Title">5.11.20.1. AIX Prototype</h5>
<div class="docText"><pre>#include &lt;unistd.h&gt;
char *<a name="iddle1287"></a>getcwd (char *Buffer, size_t Size);
char *getwd(char *buf);<a name="d0e47674"></a>
</pre></div><br>

<a name="ch05lev3sec94"></a>
<h5 id="title-IDA31ARX" class="docSection3Title">5.11.20.2. Linux Prototype</h5>
<div class="docText"><pre>#include &lt;unistd.h&gt;
char *getcwd(char *buf, size_t size);
char *get_current_dir_name(void);
char *getwd(char *buf);
</pre></div><br>

<a name="ch05lev3sec95"></a>
<h5 id="title-IDAP2ARX" class="docSection3Title">5.11.20.3. Detail Comparison</h5>
<p class="docText">**Compatible**</p>
<p class="docText">AIX does not provide <tt>get_current_dir_name()</tt>.</p>

<a name="ch05lev3sec96"></a>
<h5 id="title-IDAA3ARX" class="docSection3Title">5.11.20.4. Errors</h5>
<ul><LI><p class="docText"><span class="docEmphStrong"><tt>EACCES</tt>.</span> Permission to read or search a component of the filename was denied.</p></li><li><p class="docText"><span class="docEmphStrong"><tt>EFAULT</tt>.</span> <span class="docEmphasis"><tt>buf</tt></span> points to a bad address.</P></LI><LI><p class="docText"><span class="docEmphStrong"><tt>EINVAL</tt>.</span> The <span class="docEmphasis"><tt>size</tt></span> argument is 0, and <span class="docEmphasis"><tt>buf</tt></span> is not a null pointer.</P></LI><li><p class="docText"><span class="docEmphStrong"><tt>ENOENT</tt>.</span> The corrent working directory has been unlinked.</p></li><LI><p class="docText"><span class="docEmphStrong"><tt>ERANGE</tt>.</span> The <span class="docEmphasis"><tt>size</tt></span> argument is less than the length of the working directory name. You need to allocate a bigger array (<span class="docEmphasis"><tt>buf</tt></span><span class="docEmphasis">)</span> and try again.</P></LI></UL>

<a name="ch05lev3sec97"></a>
<H5 id="title-IDAT5ARX" class="docSection3Title">5.11.20.5. ERRNO(s) Not Implemented in Linux</h5>
<UL><li><p class="docText"><span class="docEmphStrong"><tt>ENOMEM</tt>.</span> Indicates that insufficient storage space is available.</p></LI></UL>


<a name="ch05lev2sec38"></a>

<h4 id="title-IDATABRX" class="docSection2Title">5.11.21. <a name="iddle2341"></a><a name="iddle2383"></a><a name="iddle1845"></a>mount(), umount(), vmount()</h4>
<p class="docText">A file hierarchy is usually made available to the filesystem through the <tt>mount</tt> command. The <tt>umount</tt> command detaches the filesystem(s) mentioned from the file hierarchy. A filesystem is specified by giving the directory where it has been mounted. Giving the special device on which the filesystem lives may also work, but this is obsolete, mainly because it will fail in case this device was mounted on more than one directory.<a name="d0e47843"></a><a name="d0e47844"></a></p>
<p class="docText">Note that a filesystem cannot be unmounted when it is &quot;busy&quot;for example, when there are open files on it, or when some process has its working directory there, or when a swap file on it is in use. The offending process could even be <tt>umount</tt>.</p>
<a name="ch05lev3sec98"></a>
<H5 id="title-IDAXCBRX" class="docSection3Title">5.11.21.1. AIX Prototype</h5>
<div class="docText"><pre>#include &lt;sys/vmount.h&gt;
int <a name="iddle2367"></a><a name="iddle2406"></a><a name="iddle2518"></a>vmount <span class="docEmphStrong">(struct vmount *VMount, int size)</span>
int mount(char *Device, char *Path, int Flags)
int <a name="iddle2365"></a><a name="iddle2404"></a><a name="iddle2506"></a>umount (char *Device)
</pre></div><br>

<a name="ch05lev3sec99"></a>
<h5 id="title-IDAZFBRX" class="docSection3Title">5.11.21.2. Linux Prototype</h5>
<div class="docText"><pre>#include &lt;sys/mount.h&gt;
int mount(const char *specialfile, const char *dir, const char * filesystemtype,
unsigned long rwflag, const void *data);
int umount(const char *specialfile);
int umount(const char *dir);
int umount2(const char *target, int flags);
</pre></div><BR>

<a name="ch05lev3sec100"></a>
<H5 id="title-IDALGBRX" class="docSection3Title">5.11.21.3. Detail Comparison</h5>
<p class="docText">**Not Compatible**</p>
<p class="docText">Semantics differ between AIX and Linux.</p>
<p class="docText">Specifically, AIX users must convert their application usage of this API to that of Linux. Older applications that run on earlier versions of AIX (4.3.3 or before) will have an easier conversion as they most likely would have used an older <tt>mount</tt> subroutine instead of <tt>vmount</tt>.<span class="docEmphStrong"></span> But that comparison is only based on the equal number of arguments. The semantics still differ.</p>
<p class="docText"><tt>umount</tt> functions are compatible.</p>

<a name="ch05lev3sec101"></a>

<h5 id="title-IDAJHBRX" class="docSection3Title">5.11.21.4. Additional Data: Linux-Specific</h5>
<p class="docText">These functions are Linux-specific and should not be used in programs intended to be portable.</p>
<p class="docText"><tt>mount</tt> attaches the filesystem specified by <span class="docEmphasis"><tt>source</tt></span> (which is often a device name, but can also be a directory name or a dummy) to the directory specified by <span class="docEmphasis"><tt>target</tt></span>.</p>
<p class="docText"><tt>umount</tt> and <tt>umount2</tt> remove the attachment of the (topmost) filesystem mounted on <span class="docEmphasis"><tt>target</tt></span>.</p>
<p class="docText">Only the super user may mount and unmount filesystems. Since Linux 2.4, a single filesystem can be visible at multiple mount points, and multiple mounts can be stacked on the same mount point.</p>
<p class="docText">Values for the <span class="docEmphasis"><tt>filesystemtype</tt></span> argument supported by the kernel are listed in /proc/filesystems (<tt>minix, ext2, msdos, proc, nfs, iso9660</tt>, and so on). More types may become available when the appropriate modules are loaded.</p>
<p class="docText">The <span class="docEmphasis"><tt>mountflags</tt></span> argument may have the magic number 0xC0ED (<tt>MS_MGC_VAL</tt>) in the top 16 bits (this was required in kernel versions prior to 2.4 but is no longer required and is ignored if specified), and various mount flags (as defined in linux/fs.h for <tt>libc4</tt> and <tt>libc5</tt> and in sys/mount.h for <tt>glibc2</tt>) in the low-order 16 bits:</p>
<ul><LI><p class="docList"><tt><a name="iddle1848"></a>MS_BIND</tt><a name="d0e48030"></a></p><p class="docList">(Linux 2.4 onward) Perform a bind mount, making a file or a directory subtree visible at another point within a file system. Bind mounts may cross file system boundaries and span chroot jails. The <span class="docEmphasis"><tt>filesystemtype</tt></span>, <span class="docEmphasis"><tt>mountflags</tt></span>, and <span class="docEmphasis"><tt>data</tt></span> arguments are ignored.</p></li><LI><p class="docList"><tt><a name="iddle1849"></a>MS_MANDLOCK</tt><a name="d0e48055"></a></P><p class="docList">Permit mandatory locking on files in this filesystem. (Mandatory locking must still be enabled on a per-file basis, as described in <tt>fcntl</tt>.)</P></LI><LI><p class="docList"><tt><a name="iddle1850"></a>MS_MOVE</tt><a name="d0e48071"></a></p><p class="docList">Move a subtree. <span class="docEmphasis"><tt>source</tt></span> specifies an existing mount point, and <span class="docEmphasis"><tt>target</tt></span> specifies the new location. The move is atomic: At no point is the subtree unmounted. The <span class="docEmphasis"><tt>filesystemtype</tt></span>, <span class="docEmphasis"><tt>mountflags</tt></span>, and <span class="docEmphasis"><tt>data</tt></span> arguments are ignored.</p></li><LI><p class="docList"><tt><a name="iddle1851"></a>MS_NOATIME</tt><a name="d0e48106"></a></P><p class="docList">Do not update access times for (all types of) files on this filesystem.</P></LI><LI><p class="docList"><tt><a name="iddle1852"></a>MS_NODEV</tt><a name="d0e48119"></a></p><p class="docList">Do not allow access to devices (special files) on this filesystem.</P></li><li><p class="docList"><tt><a name="iddle1853"></a>MS_NODIRATIME</tt><a name="d0e48132"></a></P><p class="docList">Do not update access times for directories on this filesystem.</P></li><li><p class="docList"><tt><a name="iddle1854"></a>MS_NOEXEC</tt><a name="d0e48145"></a></p><p class="docList">Do not allow programs to be executed from this filesystem.</p></LI><li><p class="docList"><tt><a name="iddle1855"></a>MS_NOSUID</tt><a name="d0e48158"></a></p><p class="docList">Do not honor set-UID and set-GID bits when executing programs from this filesystem.</p></li><LI><p class="docList"><tt><a name="iddle1856"></a>MS_RDONLY</tt><a name="d0e48171"></a></P><p class="docList"><a name="iddle2342"></a><a name="iddle2384"></a>Mount filesystem read-only.<a name="d0e48193"></a><a name="d0e48194"></a></p></li><li><p class="docList"><tt><a name="iddle1857"></a>MS_REMOUNT</tt><a name="d0e48204"></a></p><p class="docList">Remount an existing mount. This allows you to change the <span class="docEmphasis"><tt>mountflags</tt></span> and <span class="docEmphasis"><tt>data</tt></span> of an existing mount without having to unmount and remount the file system. <span class="docEmphasis"><tt>source</tt></span> and <span class="docEmphasis"><tt>target</tt></span> should be the same values specified in the initial <tt>mount()</tt> call; <span class="docEmphasis"><tt>filesystemtype</tt></span> is ignored.</p></li><li><p class="docList"><tt><a name="iddle1858"></a>MS_SYNCHRONOUS</tt><a name="d0e48240"></a></p><p class="docList">Make writes on this filesystem synchronous (as though the <tt>O_SYNC</tt><span class="docEmphStrong"></span> flag to <tt>open</tt> were specified for all file opens to this filesystem).</p></li></ul>
<p class="docText">From Linux 2.4 onward, the <tt>MS_NODEV, MS_NOEXEC</tt>, and <tt>MS_NOSUID</tt> flags are settable on a per-mount point basis.</p>
<p class="docText">The <span class="docEmphasis"><tt>data</tt></span> argument is interpreted by the different file systems. Typically, it is a string of comma-separated options understood by this filesystem. See <tt>mount</tt> for details of the options available for each filesystem type.</p>
<p class="docText">Linux 2.1.116 added the <tt>umount2</tt>() system call, which, like <tt>umount</tt>(), unmounts a target, but allows additional <span class="docEmphasis">flags</span> controlling the behavior of the operation:</p>
<UL><li><p class="docText"><span class="docEmphStrong"><tt><a name="iddle1844"></a>MNT_FORCE</tt>.</span> Force unmount even if busy (since 2.1.116; only for NFS mounts).<a name="d0e48300"></a></p></li><LI><p class="docText"><span class="docEmphStrong"><tt><a name="iddle1843"></a>MNT_DETACH</tt>.</span> Perform a lazy unmount: make the <a name="iddle1292"></a>mount point unavailable for new accesses, and actually perform the unmount when the mount point ceases to be busy (since 2.4.11).<a name="d0e48322"></a><a name="d0e48323"></a></P></LI></UL>

<a name="ch05lev3sec102"></a>
<H5 id="title-IDAUWBRX" class="docSection3Title">5.11.21.5. Return Value</h5>
<p class="docText">On success, 0 is returned. On <a name="iddle1306"></a>error, 1 is returned, and <span class="docEmphasis"><tt>ERRNO</tt></span> is set appropriately.<a name="d0e48345"></a></p>

<a name="ch05lev3sec103"></a>
<h5 id="title-IDAVXBRX" class="docSection3Title">5.11.21.6. Errors</H5>
<p class="docText">The error values given next result from filesystem-type-independent errors. Each filesystem type may have its own special errors and its own special behavior. See the kernel source code for details.</P>
<UL><LI><p class="docText"><span class="docEmphStrong"><tt>EPERM</tt>.</span> The user is not the super user.</P></li><LI><p class="docText"><span class="docEmphStrong"><tt>ENODEV</tt>.</span> <span class="docEmphasis"><tt>Filesystemtype</tt></span> is not configured in the kernel.</p></li><LI><p class="docText"><span class="docEmphStrong"><tt>ENOTBLK</tt>.</span> <span class="docEmphasis"><tt>Source</tt></span> is not a block device (and a device was required).</P></li><li><p class="docText"><span class="docEmphStrong"><tt>EBUSY</tt>.</span> <span class="docEmphasis"><tt>Source</tt></span> is already mounted. Or, it cannot be remounted read-only, because it still holds files open for writing. Or, it cannot be mounted on <span class="docEmphasis"><tt>target</tt></span> because <span class="docEmphasis"><tt>target</tt></span> is still busy (it is the working directory of some task, the mount point of another device, has open files, and so on). Or, it could not be unmounted because it is busy.</p></li><LI><p class="docText"><span class="docEmphStrong"><tt>EINVAL</tt>.</span> <span class="docEmphasis"><tt>Source</tt></span> had an invalid superblock. Or, a remount was attempted, whereas <span class="docEmphasis"><tt>source</tt></span> was not already mounted on <span class="docEmphasis"><tt>target</tt></span>. Or, a move was attempted, whereas <span class="docEmphasis"><tt>source</tt></span> was not a mount point, or was /. Or, an <a name="iddle1305"></a>umount was attempted, whereas <span class="docEmphasis"><tt>target</tt></span> was not a mount point.<a name="d0e48450"></a></p></li><li><p class="docText"><span class="docEmphStrong"><tt>ENOTDIR</tt>.</span> The second argument, or a prefix of the first argument, is not a directory.</p></LI><LI><p class="docText"><span class="docEmphStrong"><tt>EFAULT</tt>.</span> One of the pointer arguments points outside the user address space.</p></li><li><p class="docText"><span class="docEmphStrong"><tt>ENOMEM</tt>.</span> The kernel could not allocate a free page to copy filenames or data into.<a name="d0e48482"></a><a name="d0e48483"></a><a name="d0e48484"></a><a name="d0e48485"></a><a name="d0e48486"></a><a name="d0e48487"></a><a name="d0e48488"></a></p></li><li><p class="docText"><span class="docEmphStrong"><tt>ENAMETOOLONG</tt>.</span> A path name was longer than MAXPATHLEN.</p></li><li><p class="docText"><span class="docEmphStrong"><tt>ENOENT</tt>.</span> A path name was empty or had a nonexistent component.</p></li><li><p class="docText"><span class="docEmphStrong"><tt>ELOOP</tt>.</span> Too many links encountered during pathname resolution. Or, a move was attempted, whereas <span class="docEmphasis"><tt>target</tt></span> is a descendant of <span class="docEmphasis"><tt>source</tt></span>.</p></li><LI><p class="docText"><span class="docEmphStrong"><tt>EACCES</tt>.</span> A component of a path was not searchable.</p><p class="docList">Or, <a name="iddle2343"></a><a name="iddle2385"></a>mounting a read-only filesystem was attempted without giving the <tt>MS_RDONLY</tt> flag.<a name="d0e48562"></a><a name="d0e48563"></a></p><p class="docList">Or, the block device <span class="docEmphasis"><tt>Source</tt></span> is located on a filesystem mounted with the MS_NODEV option.</p></LI><LI><p class="docText"><span class="docEmphStrong"><tt>ENXIO</tt>.</span> The major number of the block device <span class="docEmphasis"><tt>source</tt></span> is out of range.</P></LI><LI><p class="docText"><span class="docEmphStrong"><tt>EMFILE</tt>.</span> (In case no block device is required.) Table of dummy devices is full.</p></li></ul>
<a name="ch05lev4sec5"></a>
<H5 id="title-IDAIBCRX" class="docSection4Title"><a name="iddle1942"></a>Portability</H5>
<p class="docText">These functions are Linux-specific and should not be used in programs intended to be portable.<a name="d0e48608"></a></P>



<a name="ch05lev2sec39"></a>
<H4 id="title-IDAFCCRX" class="docSection2Title">5.11.22. <a name="iddle2101"></a><a name="iddle2354"></a><a name="iddle2393"></a>readv(), <a name="iddle2371"></a><a name="iddle2409"></a><a name="iddle2532"></a>writev()</H4>
<p class="docText">These commands read and write data into multiple buffers.</p>
<p class="docText"><tt>readv</tt><span class="docEmphStrong"></span> reads data from file descriptor <span class="docEmphasis"><tt>filedes</tt></span> and puts the result in the buffers described by <span class="docEmphasis"><tt>vector</tt></span>. The number of buffers is specified by <span class="docEmphasis"><tt>count</tt></span>. The buffers are filled in the order specified. It operates just like read except that data is put in <span class="docEmphasis"><tt>vector</tt></span> rather than a contiguous buffer.<span class="docEmphStrong"></span></P>
<p class="docText"><tt>writev</tt><span class="docEmphStrong"></span> writes data to file descriptor <span class="docEmphasis"><tt>filedes</tt></span> and from the buffers described by <span class="docEmphasis"><tt>vector</tt></span>. The number of buffers is specified by <span class="docEmphasis"><tt>count</tt></span>. The buffers are used in the order specified. It operates just like write except that data is taken from <span class="docEmphasis"><tt>vector</tt></span> rather than a contiguous buffer.</p>
<a name="ch05lev3sec104"></a>

<h5 id="title-IDADGCRX" class="docSection3Title">5.11.22.1. AIX Prototype</H5>
<div class="docText"><pre>#include &lt;sys/uio.h&gt;
ssize_t <a name="iddle1297"></a>readv (int FileDescriptor, const struct iovec *iov, int iovCount);
ssize_t <a name="iddle1310"></a>writev (int FileDescriptor, const struct iovec *iov, int iovCount);<a name="d0e48736"></a><a name="d0e48737"></a>
</pre></div><BR>

<a name="ch05lev3sec105"></a>
<h5 id="title-IDAYHCRX" class="docSection3Title">5.11.22.2. Linux Prototype</h5>
<div class="docText"><pre>#include &lt;sys/uio.h&gt;
int readv(int filedes, const struct iovec *vector, int count);
int writev(int filedes, const struct iovec *vector, int count);
</pre></div><br>

<a name="ch05lev3sec106"></a>
<h5 id="title-IDANICRX" class="docSection3Title">5.11.22.3. Detail Comparison</H5>
<p class="docText">**Not Compatible**</p>
<p class="docText">Functions return different types. On some systems this may be as simple as casting the return value to an <tt>int</tt>.</p>
<p class="docText">Other than return values, semantics are the same.</p>

<a name="ch05lev3sec107"></a>
<h5 id="title-IDAAJCRX" class="docSection3Title">5.11.22.4. Return Value</H5>
<p class="docText">On success <tt>readv</tt> returns the number of bytes read. On success <tt>writev</tt> returns the number of bytes written. On error, 1 is returned, and <span class="docEmphasis"><tt>ERRNO</tt></span> is set appropriately.</P>

<a name="ch05lev3sec108"></a>
<h5 id="title-IDAUJCRX" class="docSection3Title">5.11.22.5. Errors</h5>
<ul><li><p class="docText"><span class="docEmphStrong"><tt>EINVAL</tt>.</span> An invalid argument was given. For instance, <span class="docEmphasis"><tt>count</tt></span> might be greater than <tt>MAX_IOVEC</tt>, or 0. <span class="docEmphasis"><tt>filedes</tt></span> could also be attached to an object that is unsuitable for reading (for <tt>readv</tt>) or writing (for <tt>writev</tt>).</p></li><li><p class="docText"><span class="docEmphStrong"><tt>EFAULT</tt>.</span> &quot;Segmentation fault.&quot; Most likely <span class="docEmphasis"><tt>vector</tt></span> or some of the <span class="docEmphasis"><tt>iov_base</tt></span> pointers point to memory that is not properly allocated.</p></li><li><p class="docText"><span class="docEmphStrong"><tt>EBADF</tt>.</span> The file descriptor <span class="docEmphasis"><tt>filedes</tt></span> is not valid.</p></li><li><p class="docText"><span class="docEmphStrong"><tt>EINTR</tt>.</span> The call was interrupted by a signal before any data was read/written.</p></LI><li><p class="docText"><span class="docEmphStrong"><tt>EAGAIN</tt>.</span> Nonblocking I/O has been selected using <tt>O_NONBLOCK</tt>, and no data was immediately available for reading. (Or the file descriptor <span class="docEmphasis"><tt>filedes</tt></span> is for an object that is locked.)</p></li><LI><p class="docText"><span class="docEmphStrong"><tt>EISDIR</tt>.</span> <span class="docEmphasis"><tt>filedes</tt></span> refers to a directory.</P></LI><LI><p class="docText"><span class="docEmphStrong"><tt>EOPNOTSUPP</tt>.</span> <span class="docEmphasis"><tt>filedes</tt></span> refers to a socket or device that does not support reading/writing.<a name="d0e48910"></a><a name="d0e48911"></a><a name="d0e48912"></a><a name="d0e48913"></a><a name="d0e48914"></a><a name="d0e48915"></a></P></li><li><p class="docText"><span class="docEmphStrong"><tt>ENOMEM</tt>.</span> Insufficient kernel memory was available.</p></LI></UL>
<p class="docText">Other errors may occur, depending on the object connected to <span class="docEmphasis"><tt>filedes</tt></span>.</P>

<a name="ch05lev3sec109"></a>
<H5 id="title-IDA2OCRX" class="docSection3Title">5.11.22.6. ERRNO(s) Not Implemented in Linux</H5>
<ul><LI><p class="docText"><span class="docEmphStrong"><tt>EBADMSG</tt>.</span> The file is a <tt>STREAM</tt> file that is set to control-normal mode, and the message waiting to be read includes a control part.</p></li><LI><p class="docText"><span class="docEmphStrong"><tt>EDEADLK</tt>.</span> A deadlock would occur if the calling process were to sleep until the region to be read was unlocked.</P></li><li><p class="docText"><span class="docEmphStrong"><tt>EOVERFLOW</tt>.</span> An attempt was made to read from a regular file where <tt>NBytes</tt> was greater than 0 and the starting offset was before the end of file and was greater than or equal to the offset maximum established in the open file description associated with the file descriptor.</p></li><LI><p class="docText"><span class="docEmphStrong"><tt>ENXIO</tt>.</span> A request was made of a nonexistent device or the request was outside the capabilities of the device.</p></li><li><p class="docText"><span class="docEmphStrong"><tt>ESPIPE</tt>.</span> <span class="docEmphasis"><tt>fildes</tt></span> is associated with a pipe or FIFO.</p></LI><LI><p class="docText"><span class="docEmphStrong"><tt>ETIMEDOUT</tt>.</span> The connection timed out.</p></li></ul>
<a name="ch05lev4sec6"></a>
<h5 id="title-IDASRCRX" class="docSection4Title">Conforming To</h5>
<p class="docText">4.4BSD (the <tt>readv</tt> and <tt>writev</tt> functions first appeared in BSD 4.2), Unix98. Linux <tt>libc5</tt> used <tt>size_t</tt> as the type of the <span class="docEmphasis"><tt>count</tt></span> parameter.</p>



<a name="ch05lev2sec40"></a>
<h4 id="title-IDAMSCRX" class="docSection2Title">5.11.23. <a name="iddle2132"></a><a name="iddle2356"></a><a name="iddle2395"></a>select()</h4>
<p class="docText"><tt>select</tt> enables synchronous I/O multiplexing on a file descriptor. It checks the specified file descriptors and message queues (<span class="docEmphasis"><tt>fd_set</tt></span>) to see whether they are ready for reading (receiving) or writing (sending).</p>
<a name="ch05lev3sec110"></a>

<h5 id="title-IDADUCRX" class="docSection3Title">5.11.23.1. AIX Prototype</h5>
<div class="docText"><pre>#include &lt;sys/time.h&gt;
#include &lt;sys/select.h&gt;
#include &lt;sys/types.h&gt;
int select (int Nfdsmsgs, struct sellist *ReadList, struct sellist *WriteList,
struct sellist *ExceptList, struct timeval *TimeOut);
</pre></div><br>

<a name="ch05lev3sec111"></a>
<h5 id="title-IDAVUCRX" class="docSection3Title">5.11.23.2. Linux Prototype</h5>
<div class="docText"><pre>#include &lt;sys/time.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;unistd.h&gt;
int select(int n, fd_set *readfds, fd_set *writefds, fd_set *exceptfds, struct
timeval *timeout);
int pselect(int n, fd_set *readfds, fd_set *writefds, fd_set *exceptfds, const
struct timespec *timeout, const sigset_t *sigmask);
</pre></div><BR>

<a name="ch05lev3sec112"></a>
<h5 id="title-IDAHVCRX" class="docSection3Title">5.11.23.3. select(), pselect()</h5>
<p class="docText">**Not Compatible**</p>
<p class="docText">Functions are source-compatible, but semantics differ.</P>
<p class="docText">In AIX, the <tt>select</tt><span class="docEmphStrong"></span> is used for I/O multiplexing as well as exception and event handling. This is not so in Linux. For event and exception notification in Linux, you must use both <tt>select</tt><span class="docEmphStrong"></span> and <tt>sigprocmask</tt><span class="docEmphStrong"></span> system calls. Following is a brief example of how to handle the equivalent AIX exception and event notification in Linux:</P>
<div class="docText"><pre>sigprocmask (SIG_BLOCK, &amp;orig_sigmask, 0);
r = select (n, &amp;rd, &amp;wr, &amp;er, 0);
sigprocmask (SIG_BLOCK, &amp;sigmask, 0);
</pre></div><BR>
<p class="docText">In AIX, users call <tt>select</tt> with all three sets empty, <span class="docEmphasis">n</span> zero, and a non-null timeout as a fairly portable way to sleep with subsecond precision.</P>
<p class="docText">On Linux, the function <tt>select</tt> modifies timeout to reflect the amount of time not slept, which is different from most other implementations. This causes problems both when porting to Linux from other platforms and vice versa because the timeout is unusable after the call to <tt>select</tt> in Linux. Therefore, in Linux, consider timeout to be undefined after <tt>select</tt> returns.</P>
<p class="docText">The file sys/time.h contains compatibility defines for <span class="docEmphasis"><tt>fd_set</tt></span> and the prototype for <tt><a name="iddle1299"></a>select()</tt><a name="d0e49170"></a>. The <tt>FD_*</tt> macros are also defined there. The sizes of the <span class="docEmphasis"><tt>fd_set</tt></span> types differ, but code is source-compatible. In AIX, <tt>select</tt> is a system call.</p>
<p class="docText">In Linux, an <tt>fd_set</tt> is 128 bytes. In AIX, it is 4096 bytes. If your set is larger than 128 bytes in AIX, this will have to be shortened.</p>

<a name="ch05lev3sec113"></a>
<h5 id="title-IDAFYCRX" class="docSection3Title">5.11.23.4. Return Value</H5>
<p class="docText">On success, <tt>select</tt> and <tt>pselect</tt> return the number of descriptors contained in the descriptor sets, which may be zero if the timeout expires before anything interesting happens. On error, 1 is returned, and <span class="docEmphasis"><tt>ERRNO</tt></span> is set appropriately; the sets and timeout become undefined, so do not rely on their contents after an error.</P>

<a name="ch05lev3sec114"></a>
<H5 id="title-IDAZYCRX" class="docSection3Title">5.11.23.5. Errors</H5>
<UL><li><p class="docText"><span class="docEmphStrong"><tt>EBADF</tt>.</span> An invalid file descriptor was given in one of the sets.</P></li><li><p class="docText"><span class="docEmphStrong"><tt>EINTR</tt>.</span> A nonblocked signal was caught.</P></LI><li><p class="docText"><span class="docEmphStrong"><tt>EINVAL</tt>.</span> <span class="docEmphasis">n</span> is negative.</p></li><li><p class="docText"><span class="docEmphStrong"><tt>ENOMEM</tt>.</span> <tt>select</tt> was unable to allocate memory for internal tables.</P></li></ul>

<a name="ch05lev3sec115"></a>
<h5 id="title-IDAU0CRX" class="docSection3Title">5.11.23.6. Example</h5>
<div class="docText"><pre>#include &lt;stdio.h&gt;
#include &lt;sys/time.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;unistd.h&gt;

int
main(void) {
 fd_set rfds;
 struct timeval tv;
 int retval;

 /* Watch stdin (fd 0) to see when it has input. */
 FD_ZERO(&amp;rfds);
 FD_SET(0, &amp;rfds);
 /* Wait up to five seconds. */
 tv.tv_sec = 5;
 tv.tv_usec = 0;

 retval = select(1, &amp;rfds, NULL, NULL, &amp;tv);
 /* Don't rely on the value of tv now! */

 if (retval)
 printf("Data is available now.\n");
 /* FD_ISSET(0, &amp;rfds) will be true. */
 else
 printf("No data within five seconds.\n");

 return 0;
}
</pre></div><BR>

<a name="ch05lev3sec116"></a>
<H5 id="title-IDAI1CRX" class="docSection3Title">5.11.23.7. ERRNO(s) Not Implemented in Linux</h5>
<ul><li><p class="docText"><span class="docEmphStrong"><tt>EAGAIN</tt>.</span> Allocation of internal data structures was unsuccessful.<a name="d0e49292"></a><a name="d0e49293"></a><a name="d0e49294"></a></p></li><li><p class="docText"><span class="docEmphStrong"><tt>EFAULT</tt>.</span> The <tt>ReadList, WriteList, ExceptList</tt>, or <tt>TimeOut</tt> parameter points to a location outside of the address space of the process.</p></li><li><p class="docText"><span class="docEmphStrong"><tt>ETIMEDOUT</tt>.</span> The connection timed out.</p></li></ul>
<a name="ch05lev4sec7"></a>
<h5 id="title-IDAJ3CRX" class="docSection4Title">Conforming To</h5>
<p class="docText">4.4BSD (the <tt>select</tt> function first appeared in 4.2BSD). Generally portable to/from non-BSD systems supporting clones of the BSD socket layer (including System V variants). However, note that the System V variant typically sets the timeout variable before exit, but the BSD variant does not.</P>
<p class="docText">The <tt>pselect</tt> function is defined in IEEE Std 1003.1g-2000 (POSIX.1g) and part of POSIX 1003.1-2001. It is found in <tt>glibc</tt> 2.1 and later. <tt>glibc</tt> 2.0 has a function with this name, but it does not take a <span class="docEmphasis"><tt>sigmask</tt></span> parameter.</p>



<a name="ch05lev2sec41"></a>
<h4 id="title-IDAG4CRX" class="docSection2Title">5.11.24. reboot()</h4>
<p class="docText">Use <tt>reboot</tt> to enable or disable rebooting of a system.</P>
<a name="ch05lev3sec117"></a>
<H5 id="title-IDAU4CRX" class="docSection3Title">5.11.24.1. AIX Prototype</H5>
<div class="docText"><pre>#include &lt;sys/reboot.h&gt;
void <a name="iddle2102"></a><a name="iddle2355"></a><a name="iddle2394"></a>reboot (int HowTo, void *Argument)
#define _LINUX_SOURCE_COMPAT
#include &lt;sys/reboot.h&gt;
int reboot (int flag);
</pre></div><BR>

<a name="ch05lev3sec118"></a>

<H5 id="title-IDARADRX" class="docSection3Title">5.11.24.2. Linux Prototype</h5>
<p class="docText">Under <tt>glibc</tt>, some of the constants involved have gotten symbolic names <tt>RB_*</tt>, and the library call is a one-argument wrapper around the three-argument system call:</p>
<div class="docText"><pre>#include &lt;unistd.h&gt;
#include &lt;sys/reboot.h&gt;
int reboot (int flag);
</pre></div><br>
<p class="docText">For <tt>libc4</tt> and <tt>libc5</tt>, the library call and the system call are identical, and since kernel version 2.1.30 there are symbolic names <tt>LINUX_REBOOT_*</tt> for the constants and a fourth argument to the call:</P>
<div class="docText"><pre>#include &lt;unistd.h&gt;
#include &lt;linux/reboot.h&gt;
int reboot(int magic, int magic2, int flag, void *arg);
</pre></div><BR>

<a name="ch05lev3sec119"></a>
<H5 id="title-IDA1BDRX" class="docSection3Title">5.11.24.3. Detail Comparison</H5>
<p class="docText">**Not Compatible**</P>
<p class="docText">In AIX, <tt>reboot</tt> is a system call.</p>
<p class="docText">This command is a platform-specific command and is generally not portable for obvious reasons. However, IBM has made this command portable from Linux to AIX by providing the following flags when <tt>_LINUX_SOURCE_COMPAT</tt> is defined (the list also shows the Linux to AIX mapping if enabled [only on AIX5L]):</P>
<div class="docText"><pre>LINUX_REBOOT_CMD_RESTART -&gt;  RB_SOFTIPL

LINUX_REBOOT_CMD_HALT -&gt; RB_HALT_POWERED

LINUX_REBOOT_CMD_POWER_OFF -&gt;  RB_HALT

LINUX_REBOOT_CMD_RESTART2 -&gt;  RB_POWIPL

LINUX_REBOOT_CMD_CAD_ON -&gt; return(ENOSYS)

LINUX_REBOOT_CMD_CAD_OFF -&gt;  return(0)
</pre></div><br>
<p class="docText">AIX did not implement CAD (Ctrl-Alt-Del) for Linux compatibility.</p>

<a name="ch05lev3sec120"></a>

<H5 id="title-IDA3CDRX" class="docSection3Title">5.11.24.4. Return Value</H5>
<p class="docText">On success, the system <a name="iddle1298"></a>reboots<a name="d0e49486"></a>. On error, 1 is returned, and <span class="docEmphasis"><tt>ERRNO</tt></span> is set appropriately.<a name="d0e49492"></a><a name="d0e49493"></a><a name="d0e49494"></a></p>

<a name="ch05lev3sec121"></a>
<h5 id="title-IDAOEDRX" class="docSection3Title">5.11.24.5. Errors</h5>
<ul><LI><p class="docText"><span class="docEmphStrong"><tt>EINVAL</tt>.</span> Bad magic numbers or <span class="docEmphasis"><tt>flag</tt></span>.</p></li><li><p class="docText"><span class="docEmphStrong"><tt>EPERM</tt>.</span> A nonroot user attempts to call <tt>reboot</tt>.</p></LI></UL>

<a name="ch05lev3sec122"></a>
<h5 id="title-IDAYFDRX" class="docSection3Title">5.11.24.6. ERRNO(s) Not Implemented in Linux</h5>
<ul><li><p class="docText"><span class="docEmphStrong"><tt>ENOSYS</tt>.</span> Function not supported (<tt>LINUX_REBOOT_CMD_CAD_ON</tt> only)</p></li></ul>


<a name="ch05lev2sec42"></a>
<h4 id="title-IDAVGDRX" class="docSection2Title">5.11.25. <a name="iddle1129"></a><a name="iddle2323"></a><a name="iddle2373"></a>chroot()</h4>
<p class="docText"><tt>chroot()</tt> is a UNIX system call that is often used to provide an additional layer of security when untrusted programs are run. The call to <tt>chroot()</tt> is normally used to ensure that code run after it can only access files at or below a given directory. Generally this is <tt>/</tt>, but the <tt>chroot()</tt> system call can change this. When <tt>chroot()</tt> is successfully called, the calling process has its idea of the root directory changed to the directory given as the argument to <a name="iddle1284"></a><tt>chroot()</tt>. The root directory is inherited by all children of the current process.<a name="d0e49608"></a></p>
<p class="docText">Only the super user may change the root directory.</p>
<a name="ch05lev3sec123"></a>
<h5 id="title-IDAGJDRX" class="docSection3Title">5.11.25.1. AIX/Linux Prototype</h5>
<div class="docText"><pre>#include &lt;unistd.h&gt;
int chroot(const char *path);
</pre></div><br>

<a name="ch05lev3sec124"></a>
<H5 id="title-IDAYJDRX" class="docSection3Title">5.11.25.2. Details Comparison</h5>
<p class="docText">**Compatible**</p>
<p class="docText">In AIX, this is a system call.</p>

<a name="ch05lev3sec125"></a>

<H5 id="title-IDAIKDRX" class="docSection3Title">5.11.25.3. Return Value</H5>
<p class="docText">On success, 0 is returned. On error, 1 is returned, and <span class="docEmphasis"><tt>ERRNO</tt></span> is set appropriately.<a name="d0e49650"></a><a name="d0e49651"></a><a name="d0e49652"></a></P>

<a name="ch05lev3sec126"></a>
<H5 id="title-IDAHLDRX" class="docSection3Title">5.11.25.4. Errors</H5>
<p class="docText">Depending on the filesystem, other errors can be returned. The more general errors are listed here:</p>
<ul><li><p class="docText"><span class="docEmphStrong"><tt>EPERM</tt>.</span> The effective UID is not 0.</P></LI><LI><p class="docText"><span class="docEmphStrong"><tt>EFAULT</tt>.</span> <span class="docEmphasis"><tt>path</tt></span> points outside your accessible address space.</P></LI><li><p class="docText"><span class="docEmphStrong"><tt>ENAMETOOLONG</tt>.</span> <span class="docEmphasis"><tt>path</tt></span> is too long.</P></li><li><p class="docText"><span class="docEmphStrong"><tt>ENOENT</tt>.</span> The file does not exist.</P></LI><li><p class="docText"><span class="docEmphStrong"><tt>ENOMEM</tt>.</span> Insufficient kernel memory was available.</p></li><li><p class="docText"><span class="docEmphStrong"><tt>ENOTDIR</tt>.</span> A component of <span class="docEmphasis"><tt>path</tt></span> is not a directory.</P></li><li><p class="docText"><span class="docEmphStrong"><tt>EACCES</tt>.</span> Search permission is denied on a component of the path prefix.</p></li><LI><p class="docText"><span class="docEmphStrong"><tt>ELOOP</tt>.</span> Too many symbolic links were encountered in resolving <span class="docEmphasis"><tt>path</tt></span>.</P></li><li><p class="docText"><span class="docEmphStrong"><tt>EIO</tt>.</span> An I/O error occurred.</p></li></ul>

<a name="ch05lev3sec127"></a>
<h5 id="title-IDAAPDRX" class="docSection3Title">5.11.25.5. ERRNO(s) Not Implemented in Linux</h5>
<ul><li><p class="docText"><span class="docEmphStrong"><tt>ESTALE</tt>.</span> The root or current directory of the process is located in a virtual file system that has been unmounted.</p></li><li><p class="docText"><span class="docEmphStrong"><tt>ETIMEDOUT</tt>.</span> The connection timed out.</p></li></UL>
<a name="ch05lev4sec8"></a>
<h5 id="title-IDAFQDRX" class="docSection4Title">Conforming To</h5>
<p class="docText">SVr4, SVID, 4.4BSD, X/OPEN. This function is not part of POSIX.1. SVr4 documents additional <tt>EINTR, ENOLINK</tt>, and <tt>EMULTIHOP</tt> error conditions. X/OPEN does not document <tt>EIO, ENOMEM</tt>, or <tt>EFAULT</tt> error conditions. This interface is marked as legacy by X/OPEN.</p>



<a name="ch05lev2sec43"></a>

<H4 id="title-IDA5QDRX" class="docSection2Title">5.11.26. <a name="iddle1369"></a><a name="iddle2328"></a><a name="iddle2376"></a>fstatfs(), statfs()</H4>
<p class="docText"><span class="docEmphasis"><tt>statfs</tt></span> returns information about a mounted filesystem. <span class="docEmphasis"><tt>path</tt></span> is the path name of any file within the mounted filesystem. <span class="docEmphasis"><tt>buf</tt></span> is a pointer to a <span class="docEmphasis"><tt>statfs</tt></span> structure. Refer to the &quot;Detail Comparison&quot; section for the definition of <span class="docEmphasis"><tt>statfs</tt></span> structure</P>
<p class="docText"><span class="docEmphasis"><tt>fstatfs</tt></span> returns the same information about an open file referenced by descriptor <span class="docEmphasis"><tt>fd</tt></span>.</P>
<a name="ch05lev3sec128"></a>
<H5 id="title-IDAGTDRX" class="docSection3Title">5.11.26.1. AIX/Linux Prototype</h5>
<div class="docText"><pre>#include &lt;sys/vfs.h&gt;
int statfs(const char *path, struct <a name="iddle2299"></a><a name="iddle2360"></a><a name="iddle2399"></a>statfs *buf);
int fstatfs(int fd, struct statfs *buf);
</pre></div><br>

<a name="ch05lev3sec129"></a>
<h5 id="title-IDA4UDRX" class="docSection3Title">5.11.26.2. Detail Comparison</H5>
<p class="docText">Functions are compatible. In AIX, the sys/vfs.h file includes sys/statfs.h. Although compatible, the definitions of <tt>struct statfs</tt> are not identical. Refer to the following struct to identify differences.</P>
<a name="ch05lev4sec9"></a>
<H5 id="title-IDAMVDRX" class="docSection4Title">Linux</H5>
<div class="docText"><pre>struct statfs {
 long f_type;     /* type of filesystem (see below) */
 long f_bsize;    /* optimal transfer block size */
 long f_blocks;   /* total data blocks in file system */
 long f_bfree;    /* free blocks in fs */
 long f_bavail;   /* free blocks avail to non-superuser */
 long f_files;    /* total file nodes in file system */
 long f_ffree;    /* free file nodes in fs */
 fsid_t f_fsid;   /* file system id */
 long f_namelen;  /* maximum length of filenames */
 long f_spare[6]; /* spare for later */
};

File system types:

linux/affs_fs.h:
 AFFS_SUPER_MAGIC 0xADFF
linux/efs_fs.h:
 EFS_SUPER_MAGIC 0x00414A53
linux/ext_fs.h:
 EXT_SUPER_MAGIC 0x137D
linux/ext2_fs.h:
 EXT2_OLD_SUPER_MAGIC 0xEF51
 EXT2_SUPER_MAGIC 0xEF53
linux/hpfs_fs.h:
 HPFS_SUPER_MAGIC 0xF995E849
linux/iso_fs.h:
 ISOFS_SUPER_MAGIC 0x9660
linux/minix_fs.h:
 MINIX_SUPER_MAGIC 0x137F /* orig. minix */
 MINIX_SUPER_MAGIC2 0x138F /* 30 char minix */
 MINIX2_SUPER_MAGIC 0x2468 /* minix V2 */
 MINIX2_SUPER_MAGIC2 0x2478 /* minix V2, 30 char names */
linux/msdos_fs.h:
 MSDOS_SUPER_MAGIC 0x4d44
linux/ncp_fs.h:
 NCP_SUPER_MAGIC 0x564c
linux/nfs_fs.h:
 NFS_SUPER_MAGIC 0x6969
linux/proc_fs.h:
 PROC_SUPER_MAGIC 0x9fa0
linux/smb_fs.h:
 SMB_SUPER_MAGIC 0x517B
linux/sysv_fs.h:
 XENIX_SUPER_MAGIC 0x012FF7B4
 SYSV4_SUPER_MAGIC 0x012FF7B5
 SYSV2_SUPER_MAGIC 0x012FF7B6
 COH_SUPER_MAGIC 0x012FF7B7
linux/ufs_fs.h:
 UFS_MAGIC  0x00011954
linux/xfs_fs.h:
 XFS_SUPER_MAGIC 0x58465342
linux/xia_fs.h:
 _XIAFS_SUPER_MAGIC 0x012FD16D
</pre></div><BR>

<a name="ch05lev4sec10"></a>
<h5 id="title-IDAAWDRX" class="docSection4Title">AIX</H5>
<div class="docText"><pre>struct statfs {
 int f_version;       /* version/type of statfs, 0 for now */
 int f_type;          /* type of info, zero for now */
 ulong_t f_bsize;     /* optimal file system block size */
 fsblkcnt_t f_blocks; /* total data blocks in file system */
 fsblkcnt_t f_bfree;  /* free block in fs */
 fsblkcnt_t f_bavail; /* free blocks avail to non-superuser */
 fsfilcnt_t f_files;  /* total file nodes in file system */
 fsfilcnt_t f_ffree;  /* free file nodes in fs */
#if !defined(_KERNEL) &amp;&amp; defined(__64BIT__)
 fsid64_t f_fsid;      /* file system id */
#else
 fsid_t f_fsid;        /* file system id */
#endif
 int f_vfstype;       /* what type of vfs this is */
 ulong_t f_fsize;     /* fundamental file system block size */
 int f_vfsnumber;     /* vfs indentifier number */
 int f_vfsoff;        /* reserved, for vfs specific data offset */
 int f_vfslen;         /* reserved, for len of vfs specific data */
 int f_vfsvers;        /* reserved, for vers of vfs specific data *
 char f_fname[32];    /* file system name (usually mount pt.) */
 char f_fpack[32];    /* file system pack name */
 int f_name_max;      /* maximum component name length for posix */
};
</pre></div><br>
<p class="docText">Fields that are undefined for a particular filesystem are set to 0.</p>


<a name="ch05lev3sec130"></a>
<H5 id="title-IDAXWDRX" class="docSection3Title">5.11.26.3. Return Value</H5>
<p class="docText">On success, 0 is returned. On error, 1 is returned, and <span class="docEmphasis"><tt>ERRNO</tt></span> is set appropriately.</p>

<a name="ch05lev3sec131"></a>
<h5 id="title-IDAHXDRX" class="docSection3Title">5.11.26.4. Errors</h5>
<p class="docText">For <tt><a name="iddle1301"></a>statfs</tt>:<a name="d0e49990"></a></p>
<UL><li><p class="docText"><span class="docEmphStrong"><tt>ENOTDIR</tt>.</span> A component of the path prefix of <span class="docEmphasis"><tt>path</tt></span> is not a directory.</p></li><li><p class="docText"><span class="docEmphStrong"><tt>ENAMETOOLONG</tt>.</span> <span class="docEmphasis"><tt>path</tt></span> is too long.</P></LI><li><p class="docText"><span class="docEmphStrong"><tt>ENOENT</tt>.</span> The file referred to by <span class="docEmphasis"><tt>path</tt></span> does not exist.</p></li><li><p class="docText"><span class="docEmphStrong"><tt>EACCES</tt>.</span> Search permission is denied for a component of the path prefix of <span class="docEmphasis"><tt>path</tt></span>.</p></li><li><p class="docText"><span class="docEmphStrong"><tt>ELOOP</tt>.</span> Too many symbolic links were encountered in translating <span class="docEmphasis"><tt>path</tt></span>.</p></li><li><p class="docText"><span class="docEmphStrong"><tt>EFAULT</tt>.</span> <span class="docEmphasis"><tt>buf</tt></span> or <span class="docEmphasis"><tt>path</tt></span> points to an invalid address.</p></li><li><p class="docText"><span class="docEmphStrong"><tt>EIO</tt>.</span> An I/O error occurred while reading from or writing to the filesystem.</p></LI><li><p class="docText"><span class="docEmphStrong"><tt>ENOMEM</tt>.</span> Insufficient kernel memory was available.</p></li><LI><p class="docText"><span class="docEmphStrong"><tt>ENOSYS</tt>.</span> The filesystem path does not support <tt>statfs</tt>.</P></LI></UL>
<p class="docText">For <tt><a name="iddle1286"></a>fstatfs</tt>:<a name="d0e50125"></a></P>
<ul><li><p class="docText"><span class="docEmphStrong"><tt>EBADF</tt>.</span> <span class="docEmphasis"><tt>fd</tt></span> is not a valid open file descriptor.</p></LI><LI><p class="docText"><span class="docEmphStrong"><tt>EFAULT</tt>.</span> <span class="docEmphasis"><tt>buf</tt></span> points to an invalid address.</P></LI><LI><p class="docText"><span class="docEmphStrong"><tt>EIO</tt>.</span> An I/O error occurred while reading from or writing to the filesystem.</p></LI><li><p class="docText"><span class="docEmphStrong"><tt>ENOSYS</tt>.</span> The filesystem <span class="docEmphasis"><tt>fd</tt></span> is open but does not support <tt>statfs</tt>.</p></LI></UL>

<a name="ch05lev3sec132"></a>

<h5 id="title-IDAW4DRX" class="docSection3Title">5.11.26.5. ERRNO(s) Not Implemented in Linux</h5>
<ul><li><p class="docText"><span class="docEmphStrong"><tt>ESTALE</tt>.</span> The root or current directory of the process is located in a virtual filesystem that has been unmounted.<a name="d0e50202"></a><a name="d0e50203"></a><a name="d0e50204"></a><a name="d0e50205"></a><a name="d0e50206"></a><a name="d0e50207"></a></P></li><li><p class="docText"><span class="docEmphStrong"><tt>ETIMEDOUT</tt>.</span> The connection timed out.</p></li><LI><p class="docText"><span class="docEmphStrong"><tt>EIO</tt>.</span> An input/output (I/O) error occurred while reading from the filesystem.</P></li></ul>
<a name="ch05lev4sec11"></a>
<h5 id="title-IDAEBERX" class="docSection4Title">Conforming To</h5>
<p class="docText">The Linux <tt>statfs</tt> was inspired by the 4.4BSD <tt>statfs</tt> (but they do not use the same structure).</p>



<a name="ch05lev2sec44"></a>
<h4 id="title-IDAXBERX" class="docSection2Title">5.11.27. <a name="iddle1941"></a><a name="iddle2347"></a><a name="iddle2388"></a>poll()</h4>
<p class="docText"><tt>poll()</tt> (alone with <tt>select()</tt>) indicates when a procedure is safe to execute on an open file descriptor without any delays. For instance, a programmer can use these calls to know when there is data to be read on a socket. By delegating responsibility to <tt>select()</tt> and <tt>poll()</tt>, you do not have to constantly check whether there is data to be read. Instead, <tt>select()</tt> and <tt>poll()</tt> can be placed in the background by the operating system and woken up when the event is satisfied or a specified timeout has elapsed. This process can significantly increase execution efficiency of a program.</p>
<a name="ch05lev3sec133"></a>
<h5 id="title-IDATDERX" class="docSection3Title">5.11.27.1. AIX Prototype</h5>
<div class="docText"><pre>#include &lt;sys/poll.h&gt;
int poll(void *ListPointer, unsigned long Nfdsmsgs, long Timeout);
</pre></div><br>

<a name="ch05lev3sec134"></a>
<h5 id="title-IDAFEERX" class="docSection3Title">5.11.27.2. Linux Prototype</h5>
<div class="docText"><pre>#include &lt;sys/poll.h&gt;
int poll(struct pollfd *ufds, unsigned int nfds, int timeout);
</pre></div><br>

<a name="ch05lev3sec135"></a>
<H5 id="title-IDAXEERX" class="docSection3Title">5.11.27.3. Detail Comparison</h5>
<p class="docText">**Not Compatible**</p>
<p class="docText"><tt>poll</tt>: wait for some event on a file descriptor.</p>
<p class="docText">Functions are source-compatible, but the <tt>pollfd</tt> structs differ.</P>
<p class="docText">For maximum performance and scalability, Linux introduced <tt>epoll</tt><span class="docEmphStrong"></span> in version 2.5, but in Linux 2.6 the function was deprecated and is no longer supported.</P>
<a name="ch05lev4sec12"></a>
<H5 id="title-IDATFERX" class="docSection4Title">AIX</H5>
<div class="docText"><pre>struct pollist {
 struct pollfd fds[3];
 struct pollmsg msgs[2];
 } list;
</pre></div><BR>

<a name="ch05lev4sec13"></a>
<h5 id="title-IDAFGERX" class="docSection4Title">Linux</h5>
<p class="docText"><tt>poll</tt> is a variation on the theme of <tt>select</tt>. It specifies an array of <span class="docEmphasis"><tt>nfds</tt></span> structures of the following type (and a timeout in milliseconds):</p>
<div class="docText"><pre>struct pollfd {
 int fd;  /* file descriptor */
 short events; /* requested events */
 short revents; /* returned events */
};
</pre></div><BR>
<p class="docText">A negative value means infinite timeout. The field <span class="docEmphasis"><tt>fd</tt></span> contains a file descriptor for an open file. The field <span class="docEmphasis"><tt>events</tt></span> is an input parameter, a bitmask specifying the events the application is interested in. The field <span class="docEmphasis"><tt>revents</tt></span> is an output parameter, filled by the kernel with the events that actually occurred, either of the type requested, or of one of the types <tt>POLLERR</tt> or <tt>POLLHUP</tt> or <tt>POLLNVAL</tt>. (These 3 bits are meaningless in the <span class="docEmphasis"><tt>events</tt></span> field and are set in the <span class="docEmphasis"><tt>revents</tt></span> field whenever the corresponding condition is true.) If none of the events requested (and no error) has occurred for any of the file descriptors, the kernel waits for <span class="docEmphasis">timeout</span> milliseconds for one of these events to occur. The following possible bits in these masks are defined in &lt;sys/poll.h&gt;:</P>
<div class="docText"><pre>#define POLLIN 0x0001 /* There is data to read */
#define POLLPRI 0x0002 /* There is urgent data to read */
#define POLLOUT 0x0004 /* Writing now will not block */
#define POLLERR 0x0008 /* Error condition */
#define POLLHUP 0x0010 /* Hung up */
#define POLLNVAL 0x0020 /* Invalid request: fd not open */
</pre></div><BR>
<p class="docText">In asm/poll.h, too, the values <tt>POLLRDNORM, POLLRDBAND, POLLWRNORM, POLLWRBAND</tt>, and <tt>POLLMSG</tt> are defined.</P>


<a name="ch05lev3sec136"></a>

<H5 id="title-IDAPIERX" class="docSection3Title">5.11.27.4. Return Value</h5>
<p class="docText">On success, a positive number is returned, where the number returned is the number of structures that have nonzero <span class="docEmphasis"><tt>revents</tt></span> fields (in other words, those descriptors with events or errors reported). A value of 0 indicates that the call timed out and no file descriptors have been selected. On error, 1 is returned, and <span class="docEmphasis"><tt>ERRNO</tt></span> is set appropriately.<a name="d0e50449"></a><a name="d0e50450"></a><a name="d0e50451"></a></P>

<a name="ch05lev3sec137"></a>
<h5 id="title-IDARJERX" class="docSection3Title">5.11.27.5. Errors</h5>
<UL><LI><p class="docText"><span class="docEmphStrong"><tt>EBADF</tt>.</span> An invalid file descriptor was given in one of the sets.</p></li><li><p class="docText"><span class="docEmphStrong"><tt>ENOMEM</tt>.</span> There was no space to allocate file descriptor tables.</p></LI><li><p class="docText"><span class="docEmphStrong"><tt>EFAULT</tt>.</span> The array given as argument was not contained in the calling program's address space.</p></li><li><p class="docText"><span class="docEmphStrong"><tt>EINTR</tt>.</span> A signal occurred before any requested event.</P></LI></ul>

<a name="ch05lev3sec138"></a>
<h5 id="title-IDAILERX" class="docSection3Title">5.11.27.6. ERRNO(s) Not Implemented in Linux</h5>
<ul><li><p class="docText"><span class="docEmphStrong"><tt>EAGAIN</tt>.</span> Allocation of internal data structures was unsuccessful.</p></li><li><p class="docText"><span class="docEmphStrong"><tt>EINVAL</tt>.</span> The number of <tt><a name="iddle1294"></a>pollfd</tt> structures specified by the <tt>Nfdsmsgs</tt> parameter is greater than the maximum number of open files, <tt>OPEN_MAX</tt><a name="d0e50543"></a>. This error is also returned if the number of <tt>pollmsg</tt> structures specified by the <tt>Nfdsmsgs</tt> parameter is greater than the maximum number of allowable message queues.</p></li></ul>
<a name="ch05lev4sec14"></a>
<h5 id="title-IDAGNERX" class="docSection4Title">Conforming To</h5>
<p class="docText">XPG4-UNIX</p>



<a name="ch05lev2sec45"></a>
<H4 id="title-IDAUNERX" class="docSection2Title">5.11.28. <a name="iddle2075"></a><a name="iddle2351"></a><a name="iddle2392"></a>quotactl()</h4>
<p class="docText">The <tt>quotactl()</tt> call manipulates disk quotas. <span class="docEmphasis"><tt>cmd</tt></span> indicates a command to be applied to UID <span class="docEmphasis"><tt>id</tt></span> or GID <span class="docEmphasis"><tt>id</tt></span>. To set the type of quota, use the <span class="docEmphasis"><tt>QCMD(cmd, type)</tt></span> macro. <span class="docEmphasis"><tt>special</tt></span> is a pointer to a null-terminated string containing the path name of the block special device for the filesystem being manipulated. <span class="docEmphasis"><tt>addr</tt></span> is the address of an optional, command-specific data structure that is copied in or out of the system. The interpretation of <span class="docEmphasis"><tt>addr</tt></span> is given with each of the following commands.</p>
<a name="ch05lev3sec139"></a>
<h5 id="title-IDA4PERX" class="docSection3Title">5.11.28.1. AIX Prototype</H5>
<div class="docText"><pre>#include &lt;jfs/quota.h&gt;
int quotactl (char *Path, int Cmd, int ID, char *Addr);
</pre></div><BR>

<a name="ch05lev3sec140"></a>
<H5 id="title-IDATQERX" class="docSection3Title">5.11.28.2. Linux Prototype</H5>
<div class="docText"><pre>#include &lt;sys/types.h&gt;
#include &lt;sys/quota.h&gt;
int quotactl(int cmd, const char *special, qid_t id, caddr_t addr);
</pre></div><BR>

<a name="ch05lev3sec141"></a>
<h5 id="title-IDAFRERX" class="docSection3Title">5.11.28.3. Detail Comparison</h5>
<p class="docText">**Not Compatible**</p>
<p class="docText">The header is in a different location for AIX and Linux. The arguments are in a different order. The Linux <span class="docEmphasis"><tt>cmd</tt></span><span class="docEmphStrong"></span> includes all the AIX commands as a subset plus their own. The remaining documentation is from the Linux man page.</P>
<UL><LI><p class="docList"><tt><a name="iddle2080"></a>Q_QUOTAON</tt><a name="d0e50677"></a></P><p class="docList">Turn on quotas for a filesystem. <span class="docEmphasis"><tt>addr</tt></span> points to the path name of the file containing the quotas for the filesystem. The quota file must exist; it is normally created with the <span class="docEmphasis"><tt>quotacheck</tt></span> program. This call is restricted to the super user.</P></li><LI><p class="docList"><tt><a name="iddle2079"></a>Q_QUOTAOFF</tt><a name="d0e50698"></a></p><p class="docList">Turn off quotas for a filesystem. <span class="docEmphasis"><tt>addr</tt></span> and <span class="docEmphasis"><tt>id</tt></span> are ignored. This call is restricted to the super user.</p></LI><LI><p class="docList"><tt><a name="iddle2077"></a>Q_GETQUOTA</tt><a name="d0e50719"></a></p><p class="docList">Get disk quota limits and current usage for user or group <span class="docEmphasis"><tt>id</tt></span>. <span class="docEmphasis"><tt>addr</tt></span> is a pointer to a <tt>mem_dqblk</tt> structure (defined in linux/quota.h). Only the super user may get the quotas of a user other than himself.</p></li><li><p class="docList"><tt><a name="iddle2085"></a>Q_SETQUOTA</tt><a name="d0e50743"></a></P><p class="docList">Set disk quota limits and current usage for user or group <span class="docEmphasis"><tt>id</tt></span>. <span class="docEmphasis"><tt>addr</tt></span> is a pointer to a <tt>mem_dqblk</tt> structure (defined in linux/quota.h). This call is restricted to the super user.</p></li><li><p class="docList"><tt><a name="iddle2084"></a>Q_SETQLIM</tt><a name="d0e50768"></a></p><p class="docList">Set disk quota limits for user or group <span class="docEmphasis"><tt>id</tt></span>. <span class="docEmphasis"><tt>addr</tt></span> is a pointer to a <tt>mem_dqblk</tt> structure (defined in linux/quota.h). This call is restricted to the super user.</P></LI><li><p class="docList"><tt><a name="iddle2086"></a>Q_SETUSE</tt><a name="d0e50792"></a></p><p class="docList">Set current usage for user or group <span class="docEmphasis"><tt>id</tt></span>. <span class="docEmphasis"><tt>addr</tt></span> is a pointer to a <tt>mem_dqblk</tt> structure (defined in linux/quota.h). This call is restricted to the super user.</p></li><li><p class="docList"><tt><a name="iddle2087"></a>Q_SYNC</tt><a name="d0e50816"></a></p><p class="docList">Update the on-disk copy of quota usages for a filesystem. If <span class="docEmphasis"><tt>special</tt></span> is null, all filesystems with active quotas are synced. <span class="docEmphasis"><tt>addr</tt></span> and <span class="docEmphasis"><tt>id</tt></span> are ignored.</p></li><li><p class="docList"><tt><a name="iddle2078"></a>Q_GETSTATS</tt><a name="d0e50841"></a></p><p class="docList">Get statistics and other generic information about the quota subsystem. <span class="docEmphasis"><tt>addr</tt></span> should be a pointer to the <tt>dqstats</tt> structure (defined in linux/quota.h) in which data should be stored. <span class="docEmphasis"><tt>special</tt></span> and <span class="docEmphasis"><tt>id</tt></span> are ignored.</p></li></ul>
<p class="docText">The new quota format also allows following additional calls:</p>
<UL><li><p class="docList"><tt><a name="iddle2076"></a>Q_GETINFO</tt><a name="d0e50875"></a></p><p class="docList">Get information (such as grace times) about <tt>quotafile</tt>. <span class="docEmphasis"><tt>addr</tt></span> should be a pointer to the <tt>mem_dqinfo</tt> structure (defined in linux/quota.h). <span class="docEmphasis"><tt>id</tt></span> is ignored.</p></LI><LI><p class="docList"><tt><a name="iddle2083"></a>Q_SETINFO</tt><a name="d0e50902"></a></P><p class="docList">Set information about <tt>quotafile</tt>. <span class="docEmphasis"><tt>addr</tt></span> should be a pointer to the <tt>mem_dqinfo</tt> structure (defined in linux/quota.h). <span class="docEmphasis"><tt>id</tt></span> is ignored. This operation is restricted to super user.</P></LI><li><p class="docList"><tt><a name="iddle2082"></a>Q_SETGRACE</tt><a name="d0e50929"></a></p><p class="docList">Set grace times in information about <tt>quotafile</tt>. <span class="docEmphasis"><tt>addr</tt></span> should be a pointer to the <tt>mem_dqinfo</tt> structure (defined in linux/quota.h). <span class="docEmphasis"><tt>id</tt></span> is ignored. This operation is restricted to super user.</p></LI><LI><p class="docList"><tt><a name="iddle2081"></a>Q_SETFLAGS</tt><a name="d0e50956"></a></P><p class="docList">Set flags in information about <tt>quotafile</tt>. These flags are defined in linux/quota.h. Note that there are currently no defined flags. <span class="docEmphasis"><tt>addr</tt></span> should be a pointer to <tt>mem_dqinfo</tt> structure (defined in linux/quota.h). <span class="docEmphasis"><tt>id</tt></span> is ignored. This operation is restricted to super user.</P></LI></ul>
<p class="docText">For XFS filesystems making use of the XFS Quota Manager (XQM), the preceding commands are bypassed and the following commands are used:</P>
<ul><li><p class="docList"><tt><a name="iddle2091"></a>Q_XQUOTAON</tt><a name="d0e50991"></a></P><p class="docList">Turn on quotas for an XFS filesystem. XFS provides the ability to turn on/off quota limit enforcement with quota accounting. Therefore, XFS expects the <span class="docEmphasis"><tt>addr</tt></span> to be a pointer to an unsigned <tt>int</tt> that contains either the flags <tt>XFS_QUOTA_UDQ_ACCT</tt> and/or <tt>XFS_QUOTA_UDQ_ENFD</tt> (for user quota) or <tt>XFS_QUOTA_GDQ_ACCT</tt> and/or <tt>XFS_QUOTA_GDQ_ENFD</tt> (for group quota), as defined in linux/xqm.h. This call is restricted to super user.</P></li><li><p class="docList"><tt><a name="iddle2090"></a>Q_XQUOTAOFF</tt><a name="d0e51023"></a></p><p class="docList">Turn off quotas for an XFS filesystem. As in <tt>Q_QUOTAON</tt>, XFS filesystems expect a pointer to an unsigned <tt>int</tt> that specifies whether quota accounting and/or limit enforcement needs to be turned off. This call is restricted to the super user.</p></LI><li><p class="docList"><tt><a name="iddle2089"></a>Q_XGETQUOTA</tt><a name="d0e51042"></a></p><p class="docList">Get disk quota limits and current usage for user <span class="docEmphasis"><tt>id</tt></span>. <span class="docEmphasis"><tt>addr</tt></span> is a pointer to an <tt>fs_disk_quota</tt> structure (defined in linux/xqm.h). Only the super user may get the quotas of a user other than himself.</p></li><LI><p class="docList"><tt><a name="iddle2093"></a>Q_XSETQLIM</tt><a name="d0e51066"></a></P><p class="docList">Set disk quota limits for user <span class="docEmphasis"><tt>id</tt></span>. <span class="docEmphasis"><tt>addr</tt></span> is a pointer to an <tt>fs_disk_quota</tt> structure (defined in linux/xqm.h). This call is restricted to super user.</p></li><li><p class="docList"><tt><a name="iddle2088"></a>Q_XGETQSTAT</tt><a name="d0e51090"></a></p><p class="docList">Return an <tt>fs_quota_stat</tt> structure containing XFS filesystem-specific quota information. This is useful in finding out how much space is spent to store quota information and to get quota on/off status of a given local XFS filesystem.</p></li><li><p class="docList"><tt><a name="iddle2092"></a>Q_XQUOTARM</tt><a name="d0e51107"></a><a name="d0e51108"></a><a name="d0e51109"></a><a name="d0e51110"></a></p><p class="docList">Free the disk space taken by disk quotas. Quotas must have already been turned off.</p></li></ul>
<p class="docText">There is no command equivalent to <tt>Q_SYNC</tt> for XFS because <span class="docEmphasis"><tt>sync</tt></span> writes quota information to disk (in addition to the other filesystem metadata it writes out).</p>

<a name="ch05lev3sec142"></a>
<h5 id="title-IDADEFRX" class="docSection3Title">5.11.28.4. Return Values</h5>
<p class="docText"><tt><a name="iddle1295"></a>quotactl()</tt> returns 0 on success and 1on failure and sets <span class="docEmphasis"><tt>ERRNO</tt></span> to indicate the error.<a name="d0e51146"></a></P>

<a name="ch05lev3sec143"></a>
<h5 id="title-IDAFFFRX" class="docSection3Title">5.11.28.5. Errors</h5>
<ul><LI><p class="docText"><span class="docEmphStrong"><tt>EFAULT</tt>.</span> <span class="docEmphasis"><tt>addr</tt></span> and <span class="docEmphasis"><tt>special</tt></span> are invalid.</P></LI><LI><p class="docText"><span class="docEmphStrong"><tt>EINVAL</tt>.</span> The kernel has not been compiled with the <span class="docEmphasis">QUOTA</span> option. <span class="docEmphasis"><tt>cmd</tt></span> is invalid.</P></li><li><p class="docText"><span class="docEmphStrong"><tt>ENOENT</tt>.</span> The file specified by <span class="docEmphasis"><tt>special</tt></span> or <span class="docEmphasis"><tt>addr</tt></span> does not exist.</p></LI><LI><p class="docText"><span class="docEmphStrong"><tt>ENOTBLK</tt>.</span> <span class="docEmphasis"><tt>special</tt></span> is not a block device.</P></LI><LI><p class="docText"><span class="docEmphStrong"><tt>EPERM</tt>.</span> The call is privileged and the caller was not the super user.</p></LI><li><p class="docText"><span class="docEmphStrong"><tt>ESRCH</tt>.</span> No disc quota is found for the indicated user. Quotas have not been turned on for this filesystem.</p></LI><LI><p class="docText"><span class="docEmphStrong"><tt>EUSERS</tt>.</span> The quota table is full.</p></li></ul>
<p class="docText">If <span class="docEmphasis"><tt>cmd</tt></span> is <tt>Q_QUOTAON, quotactl()</tt> may set <span class="docEmphasis"><tt>ERRNO</tt></span> to the following:</p>
<UL><li><p class="docList"><tt>EACCES</tt></p><p class="docList">The quota file pointed to by <span class="docEmphasis"><tt>addr</tt></span> exists but is not a regular file. The quota file pointed to by <span class="docEmphasis"><tt>addr</tt></span> exists but is not on the filesystem pointed to by <span class="docEmphasis"><tt>special</tt></span>.</p></li><LI><p class="docList"><tt>EBUSY</tt></P><p class="docList"><tt>Q_QUOTAON</tt> attempted even though another <tt>Q_QUOTAON</tt> has already taken place.</p></li></ul>


</TD></TR></table>
<br>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<tr><td><div STYLE="MARGIN-LEFT: 0.15in;">
<a href=ch05lev1sec10.html><img src="images/prev.gif" width="60" height="17" border="0" align="absmiddle" alt="Previous Page"></a>
<td align="right"><div STYLE="MARGIN-LEFT: 0.15in;">
<a href=ch05lev1sec12.html><img src="images/next.gif" width="60" height="17" border="0" align="absmiddle" alt="Next Page"></a>
</div></td></tr></table>
</body></html>