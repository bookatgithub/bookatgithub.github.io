<html>
<META http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<head>
<title>Section 5.15.&nbsp; Interprocess Communications</title>
<link rel="STYLESHEET" type="text/css" href="images/style.css">
<link rel="STYLESHEET" type="text/css" href="images/docsafari.css">
</head>
<body>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<tr><td><div STYLE="MARGIN-LEFT: 0.15in;">
<a href=ch05lev1sec14.html><img src="images/prev.gif" width="60" height="17" border="0" align="absmiddle" alt="Previous Page"></a>
<td align="right"><div STYLE="MARGIN-LEFT: 0.15in;">
<a href=ch05lev1sec16.html><img src="images/next.gif" width="60" height="17" border="0" align="absmiddle" alt="Next Page"></a>
</div></td></tr></table>
<br><table width="100%" border="0" cellspacing="0" cellpadding="0"><tr><TD valign="top"><a name="ch05lev1sec15"></a>
<H3 id="title-IDAE4JIV" class="docSection1Title">5.15. Interprocess Communications</H3>
<p class="docText"><a name="iddle2133"></a>Semaphores, <a name="iddle1829"></a>message queues, and <a name="iddle2149"></a>shared memory make up the Interprocess Communications (<a name="iddle1027"></a>IPC) facility available in AIX<a name="d0e53974"></a><a name="d0e53975"></a><a name="d0e53976"></a><a name="d0e53977"></a>. A <span class="docEmphasis">semaphore</span> is synchronization primitive, a <span class="docEmphasis">message queue</span> is a kernel-resident linked list of messages, and <span class="docEmphasis">shared memory</span> is memory that is shared between processes mapped into the address space of the process sharing the memory.</P>
<a name="ch05lev2sec48"></a>

<H4 id="title-IDA0QKIV" class="docSection2Title">5.15.1. <a name="iddle1631"></a><a name="iddle1030"></a><a name="iddle2134"></a>Semaphores<a name="d0e54016"></a></h4>
<p class="docText">There are two forms of synchronization mechanisms within the UNIX world. One is the System V IPC version, and the other is POSIX 1003.1b. System V semaphores allows for semaphore sets, meaning that a unique semaphore identifier may contain multiple semaphores. Whether a semaphore identifier contains one semaphore or a set of semaphores, each is determined when the semaphore is created with the <tt>semget</tt> system call. The second argument to <tt>semget</tt> determines the number of semaphores that will be associated with the semaphore identifier returned by <tt>semget</tt>. The <tt>semctl()</tt> or <tt>semop()</tt> system allows the programmer to control and operate on the semaphore set as needed.<a name="d0e54035"></a></p>
<p class="docText">The POSIX 1003.1b semaphore mechanism allows programmers to create individual named and unnamed semaphores. The basic operation goes like this. The semaphore is created with the <tt>sem_init()</tt>. Once created, the semaphore can be used to synchronize access to shared resources by forcing the calling thread or process to wait on the semaphore before entering the critical section by calling <tt>sem_wait()</tt>. After the calling process is finished with the shared resource, it signals to the other processes or threads waiting that it is finished by posting the semaphore, <tt>sem_post()</tt>. These semaphores are ideal when resources must be shared between either two or more distinct processes (named semaphores) or individual threads within the same process (unnamed semaphore).</p>
<p class="docText">AIX and Linux support both mechanisms. <a class="docLink" href="#ch05table11">Table 5-11</a> gives a side-by-side comparison between AIX and Linux.</P>
<a name="ch05table11"></a><P><table cellspacing="0" FRAME="hsides" RULES="groups" cellpadding="5"><caption><H5 class="docTableTitle">Table 5-11. AIX and Linux IPC API Comparison: POSIX Semaphores</H5></caption><colgroup align="left" span="5"><col width="75"><col width="75"><col width="75"><col width="75"><col width="200"></colgroup><thead><TR><th class="bottomBorder thead" scope="col" align="left" valign="bottom"><p class="docText">AIX</p></th><th class="bottomBorder thead" scope="col" align="left" valign="bottom"><p class="docText">Linux</P></th><th class="bottomBorder thead" scope="col" align="left" valign="bottom"><p class="docText">AIX ERRNO(s)</p></th><th class="bottomBorder thead" scope="col" align="left" valign="bottom"><p class="docText">Linux ERRNO(s)</p></th><th class="bottomBorder thead" scope="col" align="left" valign="bottom"><p class="docText">Description</P></th></TR></thead><tr><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>sem_init</tt></p></td><TD class="docTableCell" align="left" valign="top"><p class="docText"><tt>sem_init</tt></p></td><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>EFAULT EINVAL ENFILE ENOMEM ENOSPC ENOTSUP</tt></p></TD><TD class="docTableCell" align="left" valign="top"><p class="docText"><tt>EINVAL ENOSYS</tt></p></td><td class="docTableCell" align="left" valign="top"><p class="docText">Initializes the semaphore object.</p></td></tr><tr><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>sem_wait</tt></p></td><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>sem_wait</tt></p></td><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>EACCES EAGAIN (semwait only) EFAULT EIDRM</tt></P></td><td class="docTableCell" align="left" valign="top"><p class="docText">Does not set <span class="docEmphasis"><tt>ERRNO</tt></span>. Always returns 0.</p></TD><TD class="docTableCell" align="left" valign="top"><p class="docText">Suspends the calling thread until the semaphore pointed to by <tt>sem</tt> has a nonzero count.</P></TD></TR><tr><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>sem_trywait</tt></p></TD><TD class="docTableCell" align="left" valign="top"><p class="docText"><tt>sem_trywait</tt></P></TD><TD class="docTableCell" align="left" valign="top"><p class="docText"><tt>EINTR EINVAL ENOMEM ENOTSUP</tt></p></TD><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>EAGAIN</tt></p></TD><TD class="docTableCell" align="left" valign="top">&nbsp;</td></tr><tr><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>sem_post</tt></P></td><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>sem_post</tt></p></td><TD class="docTableCell" align="left" valign="top"><p class="docText"><tt>EACCES EFAULT EIDRM EINVAL ENOMEM ENOTSUP</tt></P></td><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>ERANGE</tt></p></td><td class="docTableCell" align="left" valign="top"><p class="docText">Unlocks a semaphore.</p></td></tr><tr><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>sem_getvalue</tt></p></td><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>sem_getvalue</tt></p></TD><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>EACCES EFAULT EINVAL ENOMEM ENOTSUP</tt></p></td><TD class="docTableCell" align="left" valign="top"><p class="docText">Does not set <span class="docEmphasis"><tt>ERRNO</tt></span> Always returns 0.</P></TD><TD class="docTableCell" align="left" valign="top"><p class="docText">Gets the value of a semaphore.</P></td></tr><tr><TD class="docTableCell" align="left" valign="top"><p class="docText"><tt>sem_destroy</tt></P></TD><TD class="docTableCell" align="left" valign="top"><p class="docText"><tt>sem_destroy</tt></P></td><TD class="docTableCell" align="left" valign="top"><p class="docText"><tt>EACCES EFAULT EINVAL ENOTSUP</tt></p></td><TD class="docTableCell" align="left" valign="top"><p class="docText"><tt>EBUSY</tt></P></td><td class="docTableCell" align="left" valign="top"><p class="docText">Destroys a semaphore object, freeing the resources it might hold.</p></td></TR><tr><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>sem_timedwait</tt></p></td><TD class="docTableCell" align="left" valign="top"><p class="docText"><tt>sem_timedwait</tt></P></td><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>EFAULT EINVAL ETIMEDWAIT EDEADLK ENTR</tt></p></td><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>EENVAL ETIMEDWAIT EDEADLK ENTR</tt></p></td><td class="docTableCell" align="left" valign="top"><p class="docText">Advanced real-time wait.</p></td></tr><tr><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>sem_unlink</tt></p></TD><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>sem_unlink</tt></p></td><TD class="docTableCell" align="left" valign="top"><p class="docText"><tt>EACCES EFAULT ENAMETOOLONG ENOENT ENOTSUP</tt></P></TD><TD class="docTableCell" align="left" valign="top"><p class="docText"><tt>EACCES ENAMETOLONG ENOENT</tt></P></td><td class="docTableCell" align="left" valign="top"><p class="docText">Removes a named semaphore.</p></TD></TR><TR><TD class="docTableCell" align="left" valign="top"><p class="docText"><tt>sem_close</tt></P></td><TD class="docTableCell" align="left" valign="top"><p class="docText"><tt>sem_close</tt></p></td><TD class="docTableCell" align="left" valign="top"><p class="docText"><tt>EFAULT EINVAL ENOMEM ENOTSUP</tt></P></td><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>EINVAL</tt></p></td><TD class="docTableCell" align="left" valign="top"><p class="docText">Closes a named semaphore.</p></td></tr><tr><TD class="docTableCell" align="left" valign="top"><p class="docText"><tt>sem_open</tt></P></td><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>sem_open</tt></p></td><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>EACCES EEXIST EFAULT EINVAL EMFILE ENAMETOOLONG ENOMEM ENOTSUP ENOSPC</tt></p></td><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>EACCES EEXIST EINTR EENVAL EMFILE ENAMETOOLONG ENFILE ENOENT ENOSPC</tt></p></td><td class="docTableCell" align="left" valign="top"><p class="docText">Opens a named semaphore.</p></td></tr></table></P><br>
<p class="docText"><a name="iddle1632"></a><a name="iddle2135"></a>Semaphores are the primitive synchronization mechanism in many operating systems<a name="d0e54400"></a>.<a name="d0e54402"></a> The APIs mentioned are standard within the UNIX community. Semaphore sets are also a standard within UNIX, as discussed in detail in the next section.<a name="d0e54404"></a></p>

<a name="ch05lev2sec49"></a>
<h4 id="title-IDAGAQTX" class="docSection2Title">5.15.2. <a name="iddle1032"></a><a name="iddle1643"></a><a name="iddle2140"></a><a name="iddle2436"></a>System V Semaphore sets</H4>
<p class="docText">The System V version of semaphore functions are <tt>semget(), semctl()</tt>, and <tt>semop()</tt>. They perform operations on sets of semaphores associated with a predefined identifier. In Linux, the <tt>semget(), semctl()</tt>, and <tt>semop()</tt> functions are completely compatible with AIX versions. The only noticeable difference is in <tt>semop()</tt>. In AIX, the <tt>semop()</tt> sets the <tt>ENOSPC</tt> <span class="docEmphasis"><tt>ERRNO</tt></span> and in Linux it does not. However, this <span class="docEmphasis"><tt>ERRNO</tt></span> is defined in Linux, which means no coding changes are necessary when migrating to Linux because any code that handles this error in AIX will be ignored in Linux.<a name="d0e54468"></a><a name="d0e54469"></a><a name="d0e54470"></a><a name="d0e54471"></a></P>

<a name="ch05lev2sec50"></a>
<H4 id="title-IDAIDQTX" class="docSection2Title">5.15.3. <a name="iddle1028"></a><a name="iddle1629"></a><a name="iddle1830"></a>Message Queues (mqueue.h)<a name="d0e54499"></a></H4>
<p class="docText">Both AIX and Linux provide fully POSIX.1b-compliant message queues. On Linux prior to version 2.6.6.rtl, message queues were implemented in a separate required linkable library (libmqueue) that was shipped for certain distributions of Linux. In Linux kernel version 2.6.6.rtl, the Linux team decided to include the <tt>libmqueue</tt> library in the <tt>glibc</tt> 2.3.4 (04/08/2004 in changelog). Although both AIX and Linux provide support for message queues, the <span class="docEmphasis"><tt>ERRNO</tt></span>s they return for certain errors sometimes differ. Minor changes may be necessary in your code if your application takes certain actions based on these <span class="docEmphasis"><tt>ERRNO</tt></span>s. <a class="docLink" href="#ch05table12">Table 5-12</a> compares the <span class="docEmphasis"><tt>ERRNO</tt></span> differences between AIX and Linux.<a name="d0e54527"></a><a name="d0e54528"></a></P>
<a name="ch05table12"></a><p><table cellspacing="0" FRAME="hsides" RULES="groups" cellpadding="5"><caption><h5 class="docTableTitle">Table 5-12. AIX and Linux IPC API Comparison: Message Queues</h5></caption><colgroup align="left" span="4"><col width="125"><col width="125"><col width="125"><col width="125"></colgroup><thead><TR><th class="bottomBorder thead" scope="col" align="left" valign="bottom"><p class="docText">AIX-&gt;Linux</P></th><th class="bottomBorder thead" scope="col" align="left" valign="bottom"><p class="docText">AIX<BR>ERRNO(s)</P></th><th class="bottomBorder thead" scope="col" align="left" valign="bottom"><p class="docText">Linux<BR>ERRNO(s)</p></th><th class="bottomBorder thead" scope="col" align="left" valign="bottom"><p class="docText">Description</P></th></tr></thead><tr><TD class="docTableCell" align="left" valign="top"><p class="docText"><tt>mq_close</tt></P></td><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>EBADF ENOMEM ENOTSUP</tt></p></td><TD class="docTableCell" align="left" valign="top"><p class="docText"><tt>EBADF EBUSY</tt></p></td><td class="docTableCell" align="left" valign="top"><p class="docText">Closes a message queue</p></TD></TR><tr><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>mq_open</tt></p></td><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>EACCES EEXIST EFAULT EINVAL ENOMEM ENOSPC ENOTSUP ENOENT ENFILE ENAMETOOLONG</tt></p></td><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>EACCES EEXIST EINTR EINVAL EMFILE ENOSPC ENOENT ENFILE ENAMETOOLONG</tt></p></td><td class="docTableCell" align="left" valign="top"><p class="docText">Opens a message queue</p></td></tr><TR><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>mq_notify</tt></p></td><TD class="docTableCell" align="left" valign="top"><p class="docText"><tt>EBADF EBUSY EFAULT ENOMEM ENOTSUP EINVAL</tt></P></TD><TD class="docTableCell" align="left" valign="top"><p class="docText"><tt>EBADF EBUSY</tt></P></td><td class="docTableCell" align="left" valign="top"><p class="docText">Notifies a process that a message is available</p></TD></TR><TR><TD class="docTableCell" align="left" valign="top"><p class="docText"><tt>mq_getattr</tt></P></td><TD class="docTableCell" align="left" valign="top"><p class="docText"><tt>EBADF EFAULT ENOMEM EINVAL ENOTSUP</tt></p></td><TD class="docTableCell" align="left" valign="top"><p class="docText">EBADF</P></td><td class="docTableCell" align="left" valign="top"><p class="docText">Gets message queue attributes</p></td></TR><tr><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>mq_unlink</tt></p></td><TD class="docTableCell" align="left" valign="top"><p class="docText"><tt>EACCES EFAULT EINVAL ENAMETOOLONG ENOTSUP</tt></P></td><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>EACCES ENOENT ENAMETOOLONG</tt></p></td><td class="docTableCell" align="left" valign="top"><p class="docText">Removes a message queue</p></td></tr><tr><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>mq_send</tt></p></td><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>EAGAIN EFAULT EBADF EIDRM EINTR EINVAL EMSGSIZE ENOMEM ENOTSUP</tt></p></TD><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>EAGAIN EBADF EINTR EINVAL EMSGSIZE</tt></p></td><TD class="docTableCell" align="left" valign="top"><p class="docText">Sends a message to the message queue</P></TD></TR><TR><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>mq_setattr</tt></p></td><TD class="docTableCell" align="left" valign="top"><p class="docText"><tt>EBADF EFAULT EINVAL ENOMEM ENOTSUP</tt></P></TD><TD class="docTableCell" align="left" valign="top"><p class="docText"><tt>EBADF</tt></P></td><TD class="docTableCell" align="left" valign="top"><p class="docText">Sets message queue attributes</p></td></TR><TR><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>mq_send, mq_timedsend</tt></p></td><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>EAGAIN EBADF EFAULT EIDRM EINTR EINVAL EMSGSIZE ENOTSUP ETIMEDOUT</tt></P></td><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>EAGAIN EBADF EINTR EINVAL EMSGSIZE ETIMEDOUT</tt></p></td><TD class="docTableCell" align="left" valign="top"><p class="docText">Sends a message to a message queue (real time)</P></td></tr><tr><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>mq_receive</tt></p></td><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>EAGAIN EBADF EFAULT EIDRM EINTR EINVAL EMSGSIZE ENOMEM ENOTSUP</tt></p></td><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>EAGAIN EBADF EINVAL EMSGSIZE EINTR EINVAL ETIMEOUT</tt></p></td><td class="docTableCell" align="left" valign="top"><p class="docText">Receives a message from a message queue</p></TD></tr><tr><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>msgctl</tt></P></TD><TD class="docTableCell" align="left" valign="top"><p class="docText"><tt>EACCES EPERM EFAULT EINVAL</tt></P></TD><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>EACCES EPERM EDIRM EFAULT EINVAL</tt></p></td><TD class="docTableCell" align="left" valign="top"><p class="docText">Provides message control operations</P></TD></TR><TR><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>msgget</tt></P></td><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>EACCES ENOENT EEXIST ENOSPC</tt></P></TD><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>ENOMEM EACCES ENOENT EEXIST ENOSPC</tt></p></td><td class="docTableCell" align="left" valign="top"><p class="docText">Gets a <a name="iddle1831"></a>message queue identifier<a name="d0e54823"></a></P></td></tr><tr><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>msgrcv</tt></P></TD><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>E2BIG EACCES ENOMSG EFAULT EINTR EIDRM EINVAL</tt></p></td><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>E2BIG EACCES ENOMSG EFAULT EINTR EIDRM EINVAL</tt></p></td><td class="docTableCell" align="left" valign="top"><p class="docText">Reads a message from a queue</p></td></tr><tr><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>msgsnd</tt></p></td><TD class="docTableCell" align="left" valign="top"><p class="docText"><tt>EAGAIN EACCES EFAULT EIDRM EINTR EINVAL ENOMEM</tt></p></td><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>EAGAIN EACCES EFAULT EIDRM EINTR EINVAL ENOMEM</tt></P></TD><TD class="docTableCell" align="left" valign="top"><p class="docText">Sends a message</P></TD></tr></table></p><br>
<p class="docText">The default maximum size of a <a name="iddle1029"></a><a name="iddle1630"></a>message queue (<tt>msg_qbytes</tt>) on Linux is set to the system parameter <tt>MSGMNB</tt> (16384 bytes)<a name="d0e54898"></a><a name="d0e54899"></a>. The <tt>msg_qbytes</tt> value can be raised beyond <tt>MSGMNB</tt> by using the <tt>msgctl</tt> function with the appropriate privileges. On Linux, the maximum size for a message text is set to <tt>MSGMAX</tt> (8192 bytes).</P>

<a name="ch05lev2sec51"></a>
<H4 id="title-IDASTQTX" class="docSection2Title">5.15.4. <a name="iddle1031"></a><a name="iddle1633"></a><a name="iddle2150"></a>Shared Memory</H4>
<p class="docText">On most UNIX systems, including Linux, the system administrator can edit a master file in the /etc directory to define limits for IPC mechanisms such as shared memory. AIX uses a different method. In AIX, upper limits are defined for IPC mechanisms, which are not configurable. The individual IPC data structures are allocated and deallocated as needed, so memory requirements depend on the current system usage of IPC mechanisms.</P>
<p class="docText">In AIX, the maximum size of a shared memory segment for 64-bit processes is 32TB. A 32-bit process cannot attach a shared memory segment larger than 2GB. 32-bit applications can use the <tt>shmat</tt> capability to obtain more than 11 segments when using the very large address space model without having to use extended <tt>shmat</tt>.</P>
<p class="docText">In Linux, the default maximum shared memory size is 32MB. For applications that require large address space, this value is often too small. To allow for applications to allocate memory above the 32MB mark (for instance, 512MB), the Linux systems administrator must take the steps listed in the following example (which sets the shared memory maximum to 512MB):</p>
<a name="ch05pro04"></a>



<table border="0" class="docText"><TR><td width="25" valign="top"><div class="docText"><b>1. </b></div></TD><TD><div class="docText">Edit the file /etc/sysctl.conf.<br><br></div></td></tr><TR><td width="25" valign="top"><div class="docText"><b>2. </b></div></td><td><div class="docText">Set the shared memory size to 512MB (or higher) by adding the two lines listed here to the end of the file:<BR><BR>
<div class="docText"><pre>kernel.shmmax = 536870912
kernel.shmall = 536870912
</pre></div><br></div></td></tr><tr><td width="25" valign="top"><div class="docText"><b>3. </b></div></td><td><div class="docText">Run the following command from the UNIX prompt:<br><br>
<div class="docText"><pre>/sbin/sysctl -p
</pre></div><br></div></td></tr></table>
<p class="docText">Every time the machine reboots, the shared memory will be set to this value. A more permanent solution is to change the value of <tt>SHMMAX</tt> in /usr/src/linux/include/asm/shmparam.h and rebuild your kernel:</p>
<div class="docText"><pre>The maximum value of SHMMAX can be set to 4GB-1
</pre></div><BR>
<p class="docText">Both AIX and Linux define the standard <span class="docEmphasis"><tt>shmid_ds</tt></span> and <span class="docEmphasis"><tt>ipc_perm</tt></span> structures, and member variable names are the same; however, the Linux version does not contain all the members that AIX has. The following member variables are not defined in the Linux <span class="docEmphasis"><tt>shmid_ds</tt></span> structure:</p>
<div class="docText"><pre>__shm_cnattch (shm_cnattch<sup class="docFootnote"><a class="docLink" href="#ch05fn21">[21]</a></sup>) /* In memory number attachments */
shm_handle   /* segment identifier */
__shm_extshm (shm_extshm21) /* page granularity shmat */
</pre></div><br><blockquote><p class="docFootnote"><sup><a name="ch05fn21">[21]</a></sup> If_ALL_SOURCE is defined in AIX.</p></blockquote>
<p class="docText">There are two different shared memory types available for most flavors of UNIXSystem V IPC and BSD mmap. <a name="iddle2013"></a>AIX and Linux implement both<a name="d0e55032"></a>. The functions provide a rich set of APIs that enable two or more processes to share access to a single chunk of memory. <a class="docLink" href="#ch05table13">Table 5-13</a> shows there is no difference between AIX and Linux in their implementation of shared memory.<a name="d0e55038"></a><a name="d0e55039"></a></P>
<a name="ch05table13"></a><P><table cellspacing="0" FRAME="hsides" RULES="groups" cellpadding="5"><caption><H5 class="docTableTitle">Table 5-13. AIX and Linux IPC API Comparison: Shared Memory</H5></caption><colgroup align="left" span="3"><col width="100"><col width="100"><col width="300"></colgroup><thead><TR><th class="bottomBorder thead" scope="col" align="left" valign="top"><p class="docText">AIX</p></th><th class="bottomBorder thead" scope="col" align="left" valign="top"><p class="docText">Linux</p></th><th class="bottomBorder thead" scope="col" align="left" valign="top"><p class="docText">Description</p></th></TR></thead><TR><TD class="docTableCell" align="left" valign="top"><p class="docText"><tt>shmat</tt></P></TD><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>shmat</tt></P></td><td class="docTableCell" align="left" valign="top"><p class="docText">Attach shared memory to data segment</P></TD></tr><tr><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>shmctl</tt></p></TD><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>shmctl</tt></p></td><td class="docTableCell" align="left" valign="top"><p class="docText">Shared memory control operations</P></TD></tr><tr><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>shmdt</tt></p></td><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>shmdt</tt></p></td><td class="docTableCell" align="left" valign="top"><p class="docText">Detach shared memory from data segment</p></td></tr><tr><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>shmget</tt></P></td><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>shmget</tt></p></TD><TD class="docTableCell" align="left" valign="top"><p class="docText">Get shared memory segment</P></TD></TR><tr><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>shmop</tt></p></TD><TD class="docTableCell" align="left" valign="top"><p class="docText"><tt>shmop</tt></P></TD><TD class="docTableCell" align="left" valign="top"><p class="docText">Shared memory operations</p></TD></tr><tr><TD class="docTableCell" align="left" valign="top"><p class="docText"><tt>mmap, mmap64</tt></P></td><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>mmap, mmap64</tt></p></td><TD class="docTableCell" align="left" valign="top"><p class="docText">Maps a file system object into virtual memory; mmap should be used on 64-bit machines</p></td></tr><tr><TD class="docTableCell" align="left" valign="top"><p class="docText"><tt>munmap</tt></P></td><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>munmap</tt></p></td><td class="docTableCell" align="left" valign="top"><p class="docText">Unmaps pages of memory</p></td></tr></table></p><br>
<p class="docText">Without IPC programming interfaces, processes and computers cannot share information across the network. A number of platform-independent APIsincluding Common Object Request Broker Architecture (CORBA), Distributed Computing Environment (DCE), and Message Bus (MBUS)use IPC calls to implement their services.<a name="d0e55200"></a></p>


</TD></TR></table>
<br>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<tr><td><div STYLE="MARGIN-LEFT: 0.15in;">
<a href=ch05lev1sec14.html><img src="images/prev.gif" width="60" height="17" border="0" align="absmiddle" alt="Previous Page"></a>
<td align="right"><div STYLE="MARGIN-LEFT: 0.15in;">
<a href=ch05lev1sec16.html><img src="images/next.gif" width="60" height="17" border="0" align="absmiddle" alt="Next Page"></a>
</div></td></tr></table>
</body></html>