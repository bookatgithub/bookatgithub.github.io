<html>
<META http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<head>
<title>Section 5.16.&nbsp; POSIX Threads</title>
<link rel="STYLESHEET" type="text/css" href="images/style.css">
<link rel="STYLESHEET" type="text/css" href="images/docsafari.css">
</head>
<body>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<tr><td><div STYLE="MARGIN-LEFT: 0.15in;">
<a href=ch05lev1sec15.html><img src="images/prev.gif" width="60" height="17" border="0" align="absmiddle" alt="Previous Page"></a>
<td align="right"><div STYLE="MARGIN-LEFT: 0.15in;">
<a href=ch05lev1sec17.html><img src="images/next.gif" width="60" height="17" border="0" align="absmiddle" alt="Next Page"></a>
</div></td></tr></table>
<br><table width="100%" border="0" cellspacing="0" cellpadding="0"><tr><TD valign="top"><a name="ch05lev1sec16"></a>
<H3 id="588026-876" class="docSection1Title">5.16. <a name="iddle1049"></a><a name="iddle2012"></a>POSIX Threads</H3>
<p class="docText">A thread is the most basic independent flow of control that operates within the address space of a process. Although this characteristic is consistent across UNIX systems, the architecture is not, which is why standards have been created. The universal standard for implementing threads within the UNIX world today is POSIX 1003.1, better known as pthreads. POSIX defines a set of strict standardized APIs that operating system vendors must adhere to and provide for application programmers. The idea here is to enable programmers to make their applications portable from one machine to the next. As of the writing of this book, the newest version of the POSIX thread library supported on Linux is the Native POSIX Thread Library (NPTL) developed by Ulrich Drepper.<a name="d0e55223"></a></P>
<a name="ch05lev2sec52"></a>

<H4 id="title-IDAWIMKU" class="docSection2Title">5.16.1. <a name="iddle2014"></a><a name="iddle1156"></a><a name="iddle1052"></a>Linux Versus AIX Thread Models<a name="d0e55253"></a><a name="d0e55254"></a><a name="d0e55255"></a></h4>
<p class="docText">AIX supports both the <span class="docEmphasis">M</span>:<span class="docEmphasis">N</span> and 1:1 threading models, configurable by the user. The <span class="docEmphasis">M</span>:<span class="docEmphasis">N</span> model means the operating system implements <span class="docEmphasis">N</span> kernel threads to service <span class="docEmphasis">M</span> user threads. The 1:1 model means the system implements one kernel thread for every user thread. Linux NPTL threads only support the 1:1 model. This may affect process scheduling and performance tuning considerations.</p>
<p class="docText">Additionally, in AIX and Linux, thread and process characteristics are somewhat obscured. In AIX, a thread is a schedulable entity within a process that has properties that ensure its independent flow of control. These properties include the following:</p>
<blockquote><P><p class="docList">Stack</P></P><P><p class="docList">Scheduling properties (such as policy or priority)</P></p><P><p class="docList">Set of pending and blocked signals</p></p><P><p class="docList">Some thread-specific data (such as an <span class="docEmphasis"><tt>ERRNO</tt></span>)</P></p></blockquote>
<p class="docText">In Linux, a thread is considered a &quot;lightweight process&quot; (LWP), which has properties of a process but is not as heavy. Those properties include the following:</p>
<blockquote><p><p class="docList">Code (or &quot;text&quot;)</p></P><p><p class="docList">Data</p></p><p><p class="docList">Stack</P></P><p><p class="docList">File I/O</p></p><p><p class="docList">Signal tables</p></p></blockquote>
<p class="docText">Finally, threads are created architecturally different in AIX than in Linux. Traditionally, to protect the operating system, on most UNIX-like environments, <a name="iddle1053"></a><a name="iddle1657"></a><a name="iddle2016"></a><a name="iddle2470"></a>kernel space threads and user space threads are implemented separately within strict processing boundaries.<a name="d0e55361"></a><a name="d0e55362"></a><a name="d0e55363"></a><a name="d0e55364"></a></p>

<a name="ch05lev2sec53"></a>
<h4 id="title-IDAYOMKU" class="docSection2Title">5.16.2. Kernel Space Threads</h4>
<p class="docText">Kernel-supported threads fall into two classes. In a &quot;pure&quot; kernel-supported system, the kernel is responsible for scheduling all threads. Systems in which the kernel cooperates with a user-level library to do scheduling are known as <span class="docEmphasis">two-level</span>, or <span class="docEmphasis">hybrid</span>, systems. Typically, the kernel schedules LWPs, and the <a name="iddle1054"></a><a name="iddle2017"></a><a name="iddle2477"></a><a name="iddle2510"></a>user-level library schedules threads onto LWPs.<a name="d0e55410"></a><a name="d0e55411"></a><a name="d0e55412"></a><a name="d0e55413"></a></p>
<p class="docText">Both AIX and Linux support this thread model. Linux implementation of kernel threads is somewhat less strict than AIX. Linux uses the <tt>clone()</tt> system call to create threads. In the past, this raised questions as to whether these were truly kernel threads. After version 2.6, however, the <tt>clone()</tt> system call was modified under Linux to adhere strictly to the POSIX standards of a kernel thread. Linus Torvalds and other Linux kernel developers consider this model to be more simplistic and have done a pretty good job of making kernel-level context switches between threads efficient.</p>

<a name="ch05lev2sec54"></a>
<h4 id="title-IDAZRMKU" class="docSection2Title">5.16.3. User-Space Threads</h4>
<p class="docText">User-space threads live with limited support from the kernel; they maintain all of their state in user space. In addition, user-space threads have their own user scheduler independent of the kernel scheduler. The user scheduler makes it possible for user-space threads to schedule themselves on a kernel thread to execute code. Different implementations of user-space threads exist. On AIX, user-space threads are implemented to run with a ratio of eight user-space threads to one kernel thread by default.</p>
<p class="docText">Linux does not support user-space threads and does not anticipate supporting it in the future.</P>

<a name="ch05lev2sec55"></a>
<h4 id="title-IDAHSMKU" class="docSection2Title">5.16.4. <a name="iddle1050"></a>AIX to Linux POSIX Threads <a name="iddle1198"></a><a name="iddle2015"></a>Cross-Reference</h4>
<p class="docText">The POSIX threads implementations of AIX and Linux have little differences. As long as the AIX multithreaded application does not use nonportable POSIX extensions, porting should be straightforward. <a class="docLink" href="#ch05table14">Tables 5-14</a> and <a class="docLink" href="#ch05table15">5-15</a> list the POSIX thread attribute, data type, and API differences between AIX and Linux, respectively.</p>

<p class="docText"></P><a name="ch05table14"></a><P><table cellspacing="0" FRAME="hsides" RULES="groups" cellpadding="5"><caption><H5 class="docTableTitle">Table 5-14. AIX and Linux POSIX Threads Comparison: Attributes</H5></caption><colgroup align="left" span="3"><col width="150"><col width="150"><col width="300"></colgroup><thead><TR><th class="bottomBorder thead" scope="col" align="left" valign="top"><p class="docText">AIX</p></th><th class="bottomBorder thead" scope="col" align="left" valign="top"><p class="docText">Linux</p></th><th class="bottomBorder thead" scope="col" align="left" valign="top"><p class="docText">Comment</p></th></TR></thead><TR><TD class="docTableCell" align="left" valign="top"><p class="docText"><tt>pthread_t</tt></P></TD><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>pthread_t</tt></P></td><td class="docTableCell" align="left" valign="top"><p class="docText">Identifies a thread.</P></TD></tr><tr><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>pthread_attr_t</tt></p></TD><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>pthread_attr_t</tt></p></td><td class="docTableCell" align="left" valign="top"><p class="docText">Identifies a thread attribute object.</P></TD></tr><tr><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>pthread_cond_t</tt></p></td><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>pthread_cond_t</tt></p></td><td class="docTableCell" align="left" valign="top"><p class="docText">Identifies a condition variable.</p></td></tr><tr><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>pthread_condattr_t</tt></P></td><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>pthread_condattr_t</tt></p></TD><TD class="docTableCell" align="left" valign="top"><p class="docText">Identifies a condition attribute.</P></TD></TR><tr><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>pthread_key_t</tt></p></TD><TD class="docTableCell" align="left" valign="top"><p class="docText"><tt>pthread_key_t</tt></P></TD><TD class="docTableCell" align="left" valign="top"><p class="docText">Identifies a thread-specific data key.</p></TD></tr><tr><TD class="docTableCell" align="left" valign="top"><p class="docText"><tt>pthread_mutex_t</tt></P></td><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>pthread_mutex_t</tt></p></td><TD class="docTableCell" align="left" valign="top"><p class="docText">Identifies a mutex.</p></td></tr><tr><TD class="docTableCell" align="left" valign="top"><p class="docText"><tt>pthread_mutexattr_t</tt></P></td><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>pthread_mutexattr_t</tt></p></td><td class="docTableCell" align="left" valign="top"><p class="docText">Identifies a mutex attributes object.</p></td></tr><tr><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>pthread_once_t</tt></p></td><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>pthread_once_t</tt></p></TD><td class="docTableCell" align="left" valign="top"><p class="docText">Identifies a one-time initialization object.</p></td></TR><TR><TD class="docTableCell" align="left" valign="top"><p class="docText"><tt>struct sched_param {<BR>int sched_priority; int sched_policy;<BR>int sched_reserved; }</tt></p></td><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>struct __sched_param { int __sched_priority; }</tt></P></TD><TD class="docTableCell" align="left" valign="top"><p class="docText">Used for setting thread attributes. AIX: Intended for developer use and contains three member variables. Linux: Not intended for developer use and contains one member variable.</P></TD></tr></table></P><br>
<a name="ch05table15"></a><p><table cellspacing="0" FRAME="hsides" RULES="groups" cellpadding="5"><caption><H5 class="docTableTitle">Table 5-15. AIX and Linux POSIX Threads Comparison: APIs</H5></caption><colgroup align="left" span="3"><col width="150"><col width="150"><col width="300"></colgroup><thead><tr><th class="bottomBorder thead" scope="col" align="left" valign="top"><p class="docText">AIX</p></th><th class="bottomBorder thead" scope="col" align="left" valign="top"><p class="docText">Linux</p></th><th class="bottomBorder thead" scope="col" align="left" valign="top"><p class="docText">Comment</p></th></TR></thead><tr><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>pthread_atfork</tt></p></td><TD class="docTableCell" align="left" valign="top"><p class="docText"><tt>pthread_atfork</tt></P></td><td class="docTableCell" align="left" valign="top"><p class="docText">Registers fork cleanup handlers.</p></td></tr><tr><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>pthread_attr_destroy</tt></p></td><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>pthread_attr_destroy</tt></p></td><td class="docTableCell" align="left" valign="top"><p class="docText">Deletes a thread attribute.</p></TD></tr><tr><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>pthread_attr_ getdetachstate pthread_attr_ setdetachstate</tt></P></TD><TD class="docTableCell" align="left" valign="top"><p class="docText"><tt>pthread_attr_ getdetachstate pthread_attr_ setdetachstate</tt></P></TD><td class="docTableCell" align="left" valign="top"><p class="docText">Sets and returns the value of the <tt>detachstate</tt> attribute of a thread attributes object.</p></td></TR><TR><TD class="docTableCell" align="left" valign="top"><p class="docText"><tt>pthread_attr_ setstackaddr pthread_attr_ getstackaddr</tt></P></TD><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>pthread_attr_ setstackaddr pthread_attr_ getstackaddr</tt></P></td><td class="docTableCell" align="left" valign="top"><p class="docText">Returns and sets the value of the <tt>stackaddr</tt> attribute of a thread attributes object.</P></TD></tr><tr><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>pthread_attr_init</tt></p></TD><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>pthread_attr_init</tt></p></td><td class="docTableCell" align="left" valign="top"><p class="docText">Creates a thread attributes object and initializes it with default values.</P></TD></tr><tr><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>pthread_attr_ setstacksize pthread_attr_ getstacksize</tt></p></td><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>pthread_attr_ setstacksize pthread_attr_ getstacksize</tt></p></td><td class="docTableCell" align="left" valign="top"><p class="docText">Returns and sets the value of the <tt>stacksize</tt> attribute of a thread attributes object.</p></td></tr><tr><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>pthread_cancel</tt></P></td><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>pthread_cancel</tt></p></TD><TD class="docTableCell" align="left" valign="top"><p class="docText">Request cancellation of a pthread.</P></TD></TR><tr><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>pthread_cleanup_pop pthread_cleanup_push</tt></p></TD><TD class="docTableCell" align="left" valign="top"><p class="docText"><tt>pthread_cleanup_pop pthread_cleanup_push</tt></P></TD><TD class="docTableCell" align="left" valign="top"><p class="docText">Activates and deactivates thread cancellation handlers.</p></TD></tr><tr><TD class="docTableCell" align="left" valign="top"><p class="docText"><tt>pthread_detach</tt></P></td><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>pthread_detach</tt></p></td><TD class="docTableCell" align="left" valign="top"><p class="docText">Used to indicate to the implementation that storage for the thread whose thread ID is in the location thread can be reclaimed when that thread terminates.</p></td></tr><tr><TD class="docTableCell" align="left" valign="top"><p class="docText"><tt>pthread_equal</tt></P></td><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>pthread_equal</tt></p></td><td class="docTableCell" align="left" valign="top"><p class="docText">Compares two thread IDs to determine if they refer to the same thread.</p></td></tr><tr><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>pthread_exit</tt></p></td><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>pthread_exit</tt></p></TD><td class="docTableCell" align="left" valign="top"><p class="docText">Terminates the calling thread and stores the status in the return value.</p></td></TR><TR><TD class="docTableCell" align="left" valign="top"><p class="docText"><tt>pthread_getspecific pthread_setspecific</tt></P></TD><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>pthread_getspecific pthread_setspecific</tt></p></td><TD class="docTableCell" align="left" valign="top"><p class="docText">Returns and sets the thread-specific data associated with the specified key.</P></TD></TR><TR><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>pthread_join</tt></P></td><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>pthread_join</tt></P></TD><td class="docTableCell" align="left" valign="top"><p class="docText">Blocks the calling thread until the specified thread terminates.</p></td></tr><TR><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>pthread_key_create pthread_key_delete</tt></p></td><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>pthread_key_create pthread_key_delete</tt></P></TD><td class="docTableCell" align="left" valign="top"><p class="docText">Creates and deletes a thread-specific data key. <tt>pthread_key_create</tt> also accepts a ptr to a function that will be called upon destruction.</p></td></tr><tr><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>pthread_kill</tt></p></td><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>pthread_kill</tt></p></td><td class="docTableCell" align="left" valign="top"><p class="docText">The <tt>pthread_kill</tt> subroutine sends the signal signal to the thread thread. It acts with threads like the <tt>kill</tt> subroutine with single-threaded processes.</p></td></TR><tr><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>pthread_mutex_destroy pthread_mutex_init</tt></p></TD><TD class="docTableCell" align="left" valign="top"><p class="docText"><tt>pthread_mutex_destroy pthread_mutex_init</tt></P></TD><TD class="docTableCell" align="left" valign="top"><p class="docText">Initializes or destroys a mutex. Passing in NULL initializes all attributes to default values. Behavior is consistent between AIX and Linux.</p></td></tr><TR><TD class="docTableCell" align="left" valign="top"><p class="docText"><tt>pthread_mutexattr_init pthread_mutexattr_destroy</tt></P></TD><TD class="docTableCell" align="left" valign="top"><p class="docText"><tt>pthread_mutexattr_init pthread_mutexattr_destroy</tt></p></TD><td class="docTableCell" align="left" valign="top"><p class="docText">Initializes and destroys mutex attributes.</p></TD></TR><tr><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>pthread_mutexattr_ getpshared pthread_mutexattr_ setpshared</tt></p></td><TD class="docTableCell" align="left" valign="top"><p class="docText"><tt>pthread_mutexattr_getpshared pthread_mutexattr_setpshared</tt></p></td><td class="docTableCell" align="left" valign="top"><p class="docText">Sets and gets process-shared attribute.</p></TD></TR><tr><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>pthread_once</tt></p></td><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>pthread_once</tt></p></td><td class="docTableCell" align="left" valign="top"><p class="docText">Executes a routine exactly once in a process.</p></td></tr><tr><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>pthread_self</tt></p></TD><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>pthread_self</tt></p></td><TD class="docTableCell" align="left" valign="top"><p class="docText">Returns the indentifier of the current thread.</P></TD></TR></table></P><br>
<p class="docText"><a class="docLink" href="#ch05table16">Table 5-16</a> shows APIs that were found to have differences between <a name="iddle1199"></a>AIX and Linux and will require some coding changes when porting from <a name="iddle1051"></a>AIX to Linux.<a name="d0e56091"></a><a name="d0e56092"></a></p>

<p class="docText"></p><a name="ch05table16"></a><P><table cellspacing="0" FRAME="hsides" RULES="groups" cellpadding="5"><caption><H5 class="docTableTitle">Table 5-16. AIX and Linux POSIX Threads Comparison: Nonportable</H5></caption><colgroup align="left" span="2"><col width="200"><col width="300"></colgroup><thead><TR><th class="bottomBorder thead" scope="col" align="left" valign="top"><p class="docText">API</P></th><th class="bottomBorder thead" scope="col" align="left" valign="top"><p class="docText">Differences</p></th></TR></thead><tr><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>pthread_attr_init</tt></P></TD><td class="docTableCell" align="left" valign="top"><p class="docText">Creates a new thread attribute with default values with the following exceptions. AIX: Contention scope = <tt>PTHREAD_SCOPE_PROCESS Sched param.sched_prio</tt> = 1 Linux: Contention scope = <tt>PTHREAD_SCOPE_SYSTEM Sched param.sched_priority</tt> = 0</p></td></tr><TR><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>pthread_mutex_lock pthread_mutex_trylock pthread_mutex_unlockj</tt></p></td><td class="docTableCell" align="left" valign="top"><p class="docText">Lock mechanism between AIX and Linux is not compatible. The conditions for deadlocking differ, and the attribute values differ. AIX: Possible attribute values <tt>PTHREAD_MUTEX_NORMAL PTHREAD_MUTEX_ERRORCHECKING PTHREAD_MUTEX_RECURSIVE PTHREAD_MUTEX_DEFAULT</tt> Linux: Possible attribute values #ifdef <tt>__USE_GNU<BR>PTHREAD_MUTEX_INITIALIZER PTHREAD_RECURSIVE_MUTEX_INITIALIZER_NP PTHREAD_ERRORCHECK_MUTEX_INITIALIZER_NP</tt><BR>#ifdef <tt>__USE_UNIX98 PTHREAD_MUTEX_NORMAL PTHREAD_MUTEX_ERRORCHECKING PTHREAD_MUTEX_RECURSIVE PTHREAD_MUTEX_DEFAULT</tt> Refer to the Linux and AIX documentation on the different behavior conditions that could cause a deadlock.</p></td></tr><tr><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>pthread_mutexattr_gettype pthread_mutexattr_settype</tt></p></td><td class="docTableCell" align="left" valign="top"><p class="docText">Gets or sets a mutex type to the following values: AIX: Possible attribute values <tt>PTHREAD_MUTEX_NORMAL PTHREAD_MUTEX_ERRORCHECKING PTHREAD_MUTEX_RECURSIVE PTHREAD_MUTEX_DEFAULT</tt> <br>Linux: Possible attribute values <tt>#ifdef __USE_GNU PTHREAD_MUTEX_INITIALIZER PTHREAD_RECURSIVE_MUTEX_INITIALIZER_NP PTHREAD_ERRORCHECK_MUTEX_INITIALIZER_NP #ifdef __USE_UNIX98 PTHREAD_MUTEX_NORMAL PTHREAD_MUTEX_ERRORCHECKING PTHREAD_MUTEX_RECURSIVE PTHREAD_MUTEX_DEFAULT</tt></p></td></tr></table></p><br>
<p class="docText">NPTLcreated by Ulrich <a name="iddle1232"></a>Drepperwas first released September 20, 2002<a name="d0e56198"></a>. With the sponsorship of Red Hat and a collaborative effort among kernel and runtime developers, <a name="iddle1880"></a>NPTL quickly replaced the old LinuxThreads library and became part of the GNU C Library distribution<a name="d0e56205"></a>. It corrected some shortfalls on POSIX standards in the old LinuxThreads library and, with its thin layer, significantly increased performance. See <a class="docLink" href="ch03.html#ch03">Chapter 3</a> for more information about the Linux Native POSIX Threads Library.<a name="d0e56213"></a><a name="d0e56214"></a><a name="d0e56215"></a></P>


</TD></TR></table>
<br>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<tr><td><div STYLE="MARGIN-LEFT: 0.15in;">
<a href=ch05lev1sec15.html><img src="images/prev.gif" width="60" height="17" border="0" align="absmiddle" alt="Previous Page"></a>
<td align="right"><div STYLE="MARGIN-LEFT: 0.15in;">
<a href=ch05lev1sec17.html><img src="images/next.gif" width="60" height="17" border="0" align="absmiddle" alt="Next Page"></a>
</div></td></tr></table>
</body></html>