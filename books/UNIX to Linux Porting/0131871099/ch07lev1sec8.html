<html>
<META http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<head>
<title>Section 7.8.&nbsp; Performance Monitoring Tools</title>
<link rel="STYLESHEET" type="text/css" href="images/style.css">
<link rel="STYLESHEET" type="text/css" href="images/docsafari.css">
</head>
<body>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<tr><td><div STYLE="MARGIN-LEFT: 0.15in;">
<a href=ch07lev1sec7.html><img src="images/prev.gif" width="60" height="17" border="0" align="absmiddle" alt="Previous Page"></a>
<td align="right"><div STYLE="MARGIN-LEFT: 0.15in;">
<a href=ch07lev1sec9.html><img src="images/next.gif" width="60" height="17" border="0" align="absmiddle" alt="Next Page"></a>
</div></td></tr></table>
<br><table width="100%" border="0" cellspacing="0" cellpadding="0"><TR><td valign="top"><a href="9001536.html"><img src="images/pixel.jpg" alt="" width="1" height="1" border="0"></a><a name="ch07lev1sec8"></a>
<H3 id="title-IDAALNOT" class="docSection1Title">7.8. <a name="iddle1918"></a><a name="iddle2496"></a><a name="iddle1483"></a>Performance Monitoring Tools</h3>
<p class="docText">Both application performance and application behavior on the Linux platform need to be checked before the newly ported application is made available. Familiarize yourself with performance monitoring tools available on Linux to find problems or performance bottlenecks. Some of these tools are already available with the standard Linux distributions; others are open-source tools that you can download from the Internet.<a name="d0e78871"></a><a name="d0e78872"></a></P>
<p class="docText">We approach application tuning from two viewsinternal and external. As the names imply, the <a name="iddle1618"></a><a name="iddle1925"></a>internal view deals with the functions internal to the application; the external view deals with the environment the application runs on<a name="d0e78887"></a><a name="d0e78888"></a>. Both have a direct effect on a customer's perception of the application; a fast-performing application will have more content users than a slow-performing application. We discuss both views next.</p>
<a name="ch07lev2sec20"></a>
<h4 id="title-IDAYNNOT" class="docSection2Title">7.8.1. Internal View</h4>
<p class="docText">The first view to application tuning is the internal view. The internal view is where we get to look inside the application. The application is best viewed internally with a profiling tool. A profiling tool tells you where your program spent its time and which functions called which functions. This information can show you which functions of your program are slower than you expected. You can then analyze the code for slow functions to determine whether they can be optimized.</p>
<a name="ch07lev3sec1"></a>
<H5 id="title-IDADONOT" class="docSection3Title">7.8.1.1. <a name="iddle1619"></a><a name="iddle1926"></a>gprof</H5>
<p class="docText">Linux provides a profiling tool called <tt>gprof</tt>.<sup class="docFootnote"><a class="docLink" href="#ch07fn14">[14]</a></sup> We use <a class="docLink" href="#ch07ex07">Example 7-7</a> to run <tt>gprof</tt> against and show an example output.</P><blockquote><p class="docFootnote"><sup><a name="ch07fn14">[14]</a></sup> <a class="docLink" target="_blank" href="http://www.gnu.org/software/binutils/manual/gprof-2.9.1/html_mono/gprof.html">www.gnu.org/software/binutils/manual/gprof-2.9.1/html_mono/gprof.html</a></p></blockquote>

<p class="docText"></P><a name="ch07ex07"></a><h5 id="title-IDAEQNOT" class="docExampleTitle">Example 7-7. Source Code for gprof_1.c</h5><p><table cellspacing="0" width="90%" border="1" cellpadding="5"><tr><TD>



<pre>#include &lt;pthread.h&gt;
#include &lt;errno.h&gt;
#include &lt;stdlib.h&gt;

static unsigned int v = 40;
static count = 0;
pthread_mutex_t count_lck;

/*
  A Fibonacci sequence is a sequence of numbers {f0, f1, f2 ....}
  in which the first two values are equal to 1 and each succeeding
  number is the sum of the previous two numbers.
  Here are the first few sequence of numbers of the Fibonacci sequence:
  1 1 2 3 5 8 13 21 ...
*/



/* function to return the kth Fibonacci number */
unsigned long fibonacci(unsigned long k)
{
  unsigned long x, y, z, n;

  x = 1;

  if (k &gt; 1)
  {
    y = z = 1;
    for (n=2; n&lt;=k; n++)
    {
      x = y + z;
      y = z;
      z = x;
    }

  }

  /* return the kth Fibonacci number */
  return x;
}

unsigned long rec_fibonacci(unsigned long k)
{
  unsigned long x;

  x = 1;
  if (k &gt; 1)
    x = rec_fibonacci(k-1) + rec_fibonacci(k-2);

  /* return the kth Fibonacci number */
  return x;
}

void *compute(void *arg)
{
  pthread_mutex_lock(&amp;count_lck);
  if (count == 0)
  {
    count++;
    pthread_mutex_unlock(&amp;count_lck);
    printf("recursive = %ld\n", rec_fibonacci(v));
  }
  else
  {
    count++;
    pthread_mutex_unlock(&amp;count_lck);
    printf("non recursive = %ld\n", fibonacci(v));
  }
}



main()
{
  int rc;
  int i;
  pthread_t tid[2];

  pthread_mutex_init(&amp;count_lck, NULL);

  for (i=0; i&lt;2; i++)
  {
    if( (rc = pthread_create(&amp;tid[i], NULL, compute, NULL)) != 0)
    {
      printf("pthread_create failed: %d\n", errno);
      exit(1);
    }
  }

  for (i=0; i&lt;2; i++)
  {
    pthread_join(tid[i], NULL);
  }

  pthread_mutex_destroy(&amp;count_lck);

}
</pre><BR>

</td></tr></table></p>
<p class="docText">Compile with the <tt>pg</tt> flag to turn on profiling:</p>
<div class="docText"><pre>$ gcc gprof_1.c -o gprof_1 -lpthread -D_REENTRANT pg
</pre></div><BR>
<p class="docText">Run the program:</p>
<div class="docText"><pre>$ ./gprof_1
non recursive = 165580141
recursive = 165580141
</pre></div><br>
<p class="docText">The program <tt>gprof_1</tt> produces a file named gmon.out. <tt>gprof</tt> interprets gmon.out<sup class="docFootnote"><a class="docLink" href="#ch07fn15">[15]</a></sup> and prints the profile information in readable form.</p><blockquote><p class="docFootnote"><sup><a name="ch07fn15">[15]</a></sup> Note that if gmon.out does not exist, <span class="docEmphSmaller">gprof</span> will complain that it cannot find the file gmon.out.</P></blockquote>
<p class="docText">Run <tt>gprof</tt> against the application:</p>
<div class="docText"><pre>$ gprof ./gprof_1 &gt; outfile

$ cat outfile



--- some information cut ---

           Call graph (explanation follows)



granularity: each sample hit covers 4 byte(s) no time propagated

index % time  self children  called   name
        0.00  0.00    1/1      compute [10]
[1]   0.0  0.00  0.00    1     fibonacci [1]
-----------------------------------------------
               331160279       rec_fibonacci [2]
        0.00  0.00    1/1      compute [10]
[2]   0.0  0.00  0.00    1+331160279 rec_fibonacci [2]
               331160279       rec_fibonacci [2]

--- some information cut ---
</pre></div><br>
<p class="docText">Notice that this output indicates the number of times the function <tt>rec_fibonacci()</tt> was called but not how much time was spent on each call. However, it does not give you any number in the self column. Apparently, in some operating system kernels (such as Linux), <tt>gprof</tt> measures only the main thread. Basically, <tt>gprof</tt> uses the internal <tt>ITIMER_PROF</tt> timer, which makes the kernel deliver a signal to the application whenever it expires. This timer data needs to be passed on to all spawned threads. <a class="docLink" href="app05.html#app05">appendix E</a>, &quot;gprof helper,&quot; includes a module to wrap <tt>pthread_create()</tt> to pass on the needed timer data. Compile the module to produce a shared library as follows:</P>
<div class="docText"><pre>$ gcc -shared -fPIC gprof_helper.c -o gprof-helper.so -lpthread ldl
</pre></div><br>
<p class="docText">This produces a library <tt>gprof_helper.so</tt>. Run the example <tt>gprof_1</tt> application again but this time with the following command:</p>
<div class="docText"><pre>$ LD_PRELOAD=./gprof-helper.so ./gprof_1
pthreads: using profiling hooks for gprof
non recursive = 165580141
recursive = 165580141
</pre></div><br>
<p class="docText">This produces a new gmon.out file on which we can run <tt>gprof</tt>:</p>
<div class="docText"><pre>$ gprof ./gprof_1

Flat profile:

Each sample counts as 0.01 seconds.
 %  cumulative  self       self   total
 time  seconds  seconds  calls  s/call  s/call name
100.00  135.95  135.95    1  135.95  135.95 rec_fibonacci

 %     the percentage of the total running time of the
time    program used by this function.

cumulative a running sum of the number of seconds accounted
 seconds  for by this function and those listed above it.

 self   the number of seconds accounted for by this
seconds  function alone. This is the major sort for this
      listing.

calls   the number of times this function was invoked, if
      this function is profiled, else blank.

 self   the average number of milliseconds spent in this
ms/call  function per call, if this function is profiled,
      else blank.

 total   the average number of milliseconds spent in this
ms/call  function and its descendents per call, if this
    function is profiled, else blank.

name    the name of the function. This is the minor sort
      for this listing. The index shows the location of
      the function in the gprof listing. If the index is
      in parenthesis it shows where it would appear in
      the gprof listing if it were to be printed.

           Call graph (explanation follows)
granularity: each sample hit covers 4 byte(s) for 0.01% of 135.95 seconds

index % time  self children  called   name
               331160280       rec_fibonacci [1]
       135.95  0.00    1/1      compute [2]
[1]  100.0 135.95  0.00    1+331160280 rec_fibonacci [1]
               331160280       rec_fibonacci [1]
-----------------------------------------------
                         &lt;spontaneous&gt;
[2]  100.0  0.00 135.95        compute [2]
       135.95  0.00    1/1     rec_fibonacci [1]
-----------------------------------------------

--- rest of the output cut ---
</pre></div><br>
<p class="docText">Notice that the self column has been filled up. Because the time for executing the function <tt>fibonacci()</tt> was negligible compared to the time spent executing <tt>rec_fibonacci(), gprof</tt> did not print a line for it. Refer to the GNU <tt>gprof</tt> manual<sup class="docFootnote"><a class="docLink" href="#ch07fn16">[16]</a></sup> for more details about using <tt>gprof</tt> and interpreting its output.<a name="d0e79084"></a><a name="d0e79085"></a><a name="d0e79086"></a></p><blockquote><p class="docFootnote"><sup><a name="ch07fn16">[16]</a></sup> <a class="docLink" target="_blank" href="http://www.gnu.org/software/binutils/manual/gprof-2.9.1/html_mono/gprof.html">www.gnu.org/software/binutils/manual/gprof-2.9.1/html_mono/gprof.html</a></p></blockquote>
<p class="docText">In our simple example, you just saw how slow a recursive function can be. In real applications, <tt>gprof</tt> data can show which functions are called and by whom and how fast these functions perform. This data can help you decide whether there is a need to rewrite some of these functions.</p>

<a name="ch07lev3sec2"></a>
<h5 id="title-IDARVNOT" class="docSection3Title">7.8.1.2. <a name="iddle1620"></a><a name="iddle1893"></a><a name="iddle1927"></a>OProfile</h5>
<p class="docText"><tt>OProfile</tt> (<a class="docLink" target="_blank" href="http://oprofile.sf.net">http://oprofile.sf.net</a>) is a system-wide profiler capable of profiling all running code, including hardware and software interrupt handlers, kernel modules, kernels, shared libraries, and user-space applications. Unlike <tt>gprof, OProfile</tt> does not require code to be compiled with special profiling options or even the <tt>g</tt> option (unless you want samples to be mapped back to the source code). Therefore, you can profile applications running in production environments using <tt>OProfile</tt>. In addition, <tt>OProfile</tt> collects samples on all processes and threads running on the system and enables the user to examine data from processes that are still running.</p>
<p class="docText"><tt>OProfile</tt> can be configured to take samples periodically (time-based samples) to identify which parts of code consumed computing resources. On many architectures, <tt>OProfile</tt> provides access to the performance counter registers, allowing samples to be collected based on other events such as cache misses, TLB misses, memory references, and instructions retired. Users can also request reports that have the source trees annotated with the profile information. The generated profiling report enables developers to determine whether performance problems exist in the code and to modify the code accordingly.</p>
<p class="docText">Here we show you how to profile the code in <a class="docLink" href="#ch07ex07">Example 7-7</a> using OProfile. In this example, we use only the time-based event. As mentioned previously, you do not need to compile your code with any special option:</p>
<div class="docText"><pre># gcc o oprof1 gprof_1.c lpthread D_REENTRANT
</pre></div><BR>
<p class="docText">Execute the following command as root to clear out previous samples:</p>
<div class="docText"><pre># opcontrol reset
</pre></div><br>
<p class="docText">Next, configure and start <tt>OProfile</tt> by running the following two commands:</P>
<div class="docText"><pre># opcontrol --setup --no-vmlinux --separate=thread \
  --event=CYCLES:1000
# opcontrol --start
Using 2.6+ OProfile kernel interface.
Using log file /var/lib/oprofile/oprofiled.log
Daemon started.
Profiler running.
</pre></div><br>
<p class="docText">The <tt>no-vmlinux</tt> option indicates that we do not want samples for the kernel. The <tt>--separate=thread</tt> option gives separation for each thread. The <tt>--event</tt> option specifies measuring the time-based <tt>CYCLES</tt> event with a sample recorded for every 1,000 events. You can issue the command <tt>opcontrol list-events</tt> to list all supported events on your platform. The <tt>--start</tt> option starts <tt>OProfile</tt>'s data collection.</P>
<p class="docText">Now we can start the program:</p>
<div class="docText"><pre># ./oprof1
non recursive = 165580141
recursive = 165580141
</pre></div><BR>
<p class="docText">To ensure that all the current profiling data is flushed to the sample files before each analysis of profiling data, we issue the following command:</p>
<div class="docText"><pre># opcontrol dump
</pre></div><br>
<p class="docText">Shut down <tt>OProfile</tt> with the following command:</p>
<div class="docText"><pre># opcontrol --shutdown
Stopping profiling.
Killing daemon.
</pre></div><br>
<p class="docText">Analysis can be performed on the collected data as a normal user with <tt>opreport</tt> and <tt>opannotate</tt> commands:</P>
<div class="docText"><pre># opreport l ./oprof1
CPU: ppc64 POWER5, speed 1650.35 MHz (estimated)
Counted CYCLES events (Processor cycles) with a unit mask of 0x00 (No unit mask)
count 1000
Processes with a thread ID of 15047
Processes with a thread ID of 15048
samples %    samples %    symbol name
1232110 100.000 0       0 rec_fibonacci
0       0 2    100.000 fibonacci
</pre></div><BR>
<p class="docText">The output shows a separate report for each thread. As expected, the function <tt>rec_fibonacci</tt> consumes most of the CPU time (1,232,110 samples, 100 percent) within a thread. Another function, <tt>fibonacci</tt>, received 2 samples, accounting for 100 percent within another thread. If you want to relate samples back to the source code, you need to recompile with the <tt>g</tt> option. Following is a portion of the output from the <tt>opannotate --source ./oprof1</tt> command:</P>
<div class="docText"><pre>...
             :unsigned long rec_fibonacci(unsigned long k)
0    0  298 27.9288  :{ /* rec_fibonacci total:   0
                    0 1067 100.000 */
             :  unsigned long x;
             :
0    0   1 0.0937  :  x = 1;
0    0  44 4.1237  :  if (k &gt; 1)
0    0  364 34.1143  :  x = rec_fibonacci(k-1) +
                  rec_fibonacci(k-2);
             :
             : /* return the kth Fibonacci number */
0    0  62 5.8107  :  return x;
0    0  298 27.9288  :}

...
</pre></div><br>
<p class="docText">The first nonzero number on each line is the number of samples; the second nonzero number is the relative percentage of total samples. Refer to the <tt>OProfile</tt> manual<sup class="docFootnote"><a class="docLink" href="#ch07fn17">[17]</a></sup> for more detailed information about using <tt>OProfile</tt> and interpreting its output.</P><blockquote><p class="docFootnote"><sup><a name="ch07fn17">[17]</a></sup> <a class="docLink" target="_blank" href="http://oprofile.sourceforge.net/docs/">http://oprofile.sourceforge.net/docs/</a></p></blockquote>
<p class="docText">Here are some white papers that you may find useful to learn more about OProfile:</p>
<ul><li><p class="docList">Smashing Performance with OProfile(<a class="docLink" target="_blank" href="http://www-128.ibm.com/developerworks/linux/library/l-oprof.html">www-128.ibm.com/developerworks/linux/library/l-oprof.html</a>)<a name="d0e79300"></a><a name="d0e79301"></a><a name="d0e79302"></a></P></LI><li><p class="docList">Red Hat: OProfile instruction (<a class="docLink" target="_blank" href="http://www.centos.org/docs/4/html/rhel-sag-en-4/s1-oprofile-configuring.html">www.centos.org/docs/4/html/rhel-sag-en-4/s1-oprofile-configuring.html</a>)</p></li><li><p class="docList">OProfile for Linux on POWER (<a class="docLink" target="_blank" href="http://www-128.ibm.com/developerworks/library/l-pow-oprofile/">www-128.ibm.com/developerworks/library/l-pow-oprofile/</a>)</P></li><li><p class="docList">Five easy-to-use performance tools for Linux on PowerPC (<a class="docLink" target="_blank" href="http://www-128.ibm.com/developerworks/eserver/library/es-PerformanceInspectoronpLinux.html">www-128.ibm.com/developerworks/eserver/library/es-PerformanceInspectoronpLinux.html</a>)</p></LI><li><p class="docList">Tuning Programs with OProfile (<a class="docLink" target="_blank" href="http://people.redhat.com/wcohen">http://people.redhat.com/wcohen</a>)</p></LI></ul>
<p class="docText">Both <tt>gprof</tt> and <tt>OProfile</tt> have their own niche in application profiling. Depending on the application's profiling requirements, porting engineers and software developers may choose to favor one tool over another. <a class="docLink" href="#ch07table02">Table 7-2</a> compares the characteristics of <tt>gprof</tt> and <tt>OProfile</tt>.</p>
<a name="ch07table02"></a><p><table cellspacing="0" FRAME="hsides" RULES="groups" cellpadding="5"><caption><h5 class="docTableTitle">Table 7-2. Comparison Between gprof and OProfile</h5></caption><colgroup align="left" span="2"><col width="250"><col width="250"></colgroup><thead><tr><th class="bottomBorder thead" scope="col" align="left" valign="top"><p class="docText">gprof</p></th><th class="bottomBorder thead" scope="col" align="left" valign="top"><p class="docText">OProfile<sup class="docFootnote"><a class="docLink" href="#ch07fn18">[18]</a></sup></p></th></tr></thead><tr><td class="docTableCell" align="left" valign="top"><p class="docText">Does not require root permission</p></td><TD class="docTableCell" align="left" valign="top"><p class="docText">Requires root permission</p></td></TR><tr><TD class="docTableCell" align="left" valign="top"><p class="docText">Cannot measure hardware effects such as cache misses</p></TD><td class="docTableCell" align="left" valign="top"><p class="docText">Can measure hardware effects such as cache misses</p></td></tr><TR><TD class="docTableCell" align="left" valign="top"><p class="docText">Only profiles at the application level</P></td><TD class="docTableCell" align="left" valign="top"><p class="docText">Can capture performance behavior of entire system</p></td></tr><tr><TD class="docTableCell" align="left" valign="top"><p class="docText">Need to recompile source code with <tt>-pg</tt></P></td><td class="docTableCell" align="left" valign="top"><p class="docText">No need to recompile source code with extra flags</p></td></TR><tr><td class="docTableCell" align="left" valign="top"><p class="docText">Can profile interpreted code (such as Java)<sup class="docFootnote"><a class="docLink" href="#ch07fn19">[19]</a></sup></p></TD><td class="docTableCell" align="left" valign="top"><p class="docText">Cannot profile interpreted code<sup class="docFootnote"><a class="docLink" href="#ch07fn20">[20]</a></sup></p></TD></tr><tr><td class="docTableCell" align="left" valign="top"><p class="docText">Can profile application and shared libraries (only if shared libraries were compiled with <tt>pg</tt>)</p></td><td class="docTableCell" align="left" valign="top"><p class="docText">Can profile application and shared libraries (no need to recompile shared libraries with profiling flags)</p></td></tr></table></p><br><blockquote><p class="docFootnote"><sup><a name="ch07fn18">[18]</a></sup> See <a class="docLink" target="_blank" href="http://oprofile.sourceforge.net/doc/introduction.html">http://oprofile.sourceforge.net/doc/introduction.html</a>#applications for more information.</p></blockquote><blockquote><p class="docFootnote"><sup><a name="ch07fn19">[19]</a></sup> Compile your Java code using GNU compiler for Java (gcj).</p></blockquote><blockquote><p class="docFootnote"><sup><a name="ch07fn20">[20]</a></sup> We did not try profiling Java code that was compiled with gcj.</P></blockquote>
<p class="docText">In summary, profiling application code is a way to get an internal view of the application. The internal view gives us an idea about what parts of the code are frequently used and which functions take up the most CPU time. You can use this view to identify <span class="docEmphasis">hot spots</span> within the application that can be optimized to produce a better-<a name="iddle2497"></a>performing application.</p>


<a name="ch07lev2sec21"></a>
<h4 id="title-IDABEEE0" class="docSection2Title">7.8.2. <a name="iddle1333"></a><a name="iddle1919"></a>External View</H4>
<p class="docText">The second view to application tuning is the external view. This is where we view the application from a systems point of view. When an application runs, it uses system resources. These system resources are small at startup and gradually increase as more users use the application or more functions of the application are utilized. We call the resources used by the application its <span class="docEmphasis">resource signature.</span> The resource signature tells us how much memory, CPU, disk space, and other system resources must be available to the application to function at optimal levels. This view is most useful for system architects, who need to plan for resource capacity, and the view is generally obtained by performing an application benchmark.<a name="d0e79505"></a><a name="d0e79506"></a></p>
<p class="docText">During application benchmarking, an environment is set up to simulate application use. Usually, this is done through scripts that simulate users utilizing the application to perform different operations. System tools that monitor memory, CPU, disk I/O, and network traffic are then used to observe the overall resource utilization. Information gathered through these tools helps systems architects plan which resources the application will need. We discuss some of these tools next.</P>
<a name="ch07lev3sec3"></a>
<h5 id="title-IDAPFEE0" class="docSection3Title">7.8.2.1. <a name="iddle1338"></a><a name="iddle1924"></a><a name="iddle2519"></a>vmstat</H5>
<p class="docText"><tt>vmstat</tt> displays real-time information about processes, memory, paging, block I/O, traps, and CPU activity. The first line provides the average system activity since the last reboot, which can usually be ignored. Additional lines give the information on a sampling period of length <span class="docEmphasis">delay</span> (a user-specified parameter). The output from <tt>vmstat</tt> can be used to identify unusual system behaviors such as high page faults or excessive context switches. A sample output of <tt>vmstat</tt> follows:</p>
<div class="docText"><pre>procs -------memory---------- ---swap-- -----io---- --system-----cpu---
 r b swpd free      buff    cache  si so  bi   bo  in  cs us sy id  wa
 0  0  0  14936464  221040  467720  0  0   0    1  1   9  0  0  100  0
 0  0  0  14936528  221040  467720  0  0   0    6  5  39  0  0  100  0
 0  0  0  14936528  221040  467720  0  0   0    0  3  37  0  0  100  0
 0  0  0  14936528  221040  467720  0  0   0    2  4  40  0  0  100  0
 0  0  0  14936528  221040  467720  0  0   0    0  3  37  0  0  <span class="docEmphStrong">100</span>  0
 0  0  0  14936464  221040  467720  0  0   0    0  3  37  0  0  <span class="docEmphStrong">100</span>  0
</pre></div><br>
<p class="docText">The output shows the id column as 100 (100 percent idle), which indicates a fairly quiet system. If this were a busy system, we would see the id column at less than 100 and the us (user), sy (system), and wa (wait) columns with significantly high numbers. The us, sy, and id columns indicate the overall usage of the system. And the wa column indicates number of waiting processes to be run.</p>
<p class="docText">Consider <a class="docLink" href="#ch07ex08">Example 7-8</a>. In this example, we create four threads that execute the <tt>rec_fibonacci</tt> function. Because we already know that one thread executing the <tt>rec_fibonacci</tt> function uses a significant number of CPU resources, with four threads we can expect the application to put an even higher load on the CPUs. Let's find out whether that is the case.</p>
<a name="ch07ex08"></a><H5 id="title-IDANIEE0" class="docExampleTitle">Example 7-8. Source Code for vmstat_1.c</H5><P><table cellspacing="0" width="90%" border="1" cellpadding="5"><tr><TD>



<pre>#include &lt;pthread.h&gt;
#include &lt;errno.h&gt;
#include &lt;stdlib.h&gt;

static unsigned int v = 40;

/*
  A Fibonacci sequence is a sequence of numbers {f0, f1, f2 ....}
  in which the first two values are equal to 1 and each
  succeeding number is the sum of the previous two numbers.
  Here are the first few sequence of numbers of the Fibonacci
  sequence:
  1 1 2 3 5 8 13 21 ...
*/



unsigned long rec_fibonacci(unsigned long k)
{
  unsigned long x;

  x = 1;
  if (k &gt; 1)
    x = rec_fibonacci(k-1) + rec_fibonacci(k-2);

  /* return the kth Fibonacci number */
  return x;
}

void *compute(void *arg)
{
  printf("recursive = %ld\n", rec_fibonacci(v));
}



main()
{
  int rc;
  int i;
  pthread_t tid[2];

  for (i=0; i&lt;4; i++)
  {
    if( (rc = pthread_create(&amp;tid[i], NULL, compute, NULL)) != 0)
    {
      printf("pthread_create failed: %d\n", errno);
      exit(1);
    }
  }

  for (i=0; i&lt;4; i++)
  {
    pthread_join(tid[i], NULL);
  }

}
</pre><br>

</td></tr></table></p>
<p class="docText">Compile the example:</P>
<div class="docText"><pre>$ gcc vmstat_1.c -o vmstat_1 -lpthread -D_REENTRANT
</pre></div><BR>
<p class="docText">Run the example:</p>
<div class="docText"><pre>$ ./vmstat_1
</pre></div><br>
<p class="docText">Run <tt>vmstat</tt>:</p>
<div class="docText"><pre>$ vmstat 2
procs -----------memory---------- ---swap-- -----io---- --system-- ----cpu----
 r b   swpd   free   buff   cache  si  so    bi    bo    in   cs    us sy id wa
 0 0   116    23168  69832  522428  0   0    0     0     0     2    0  0  100 0
 0 0   116    23168  69832  522428  0   0    0     4     2    96    0  0  100 0
 <span class="docEmphMark">0 0   116    22848  69832  522428  0   0    0     0     4   115    0  0  100 0</span>
 <span class="docEmphStrong"><span class="docEmphMark">7 0   116    22704  69832  522428  0   0    0    18     5   107   19  0   81 1</span></span>
 <span class="docEmphStrong"><span class="docEmphMark">6 0   116    22704  69832  522428  0   0    0     0     2   80    100 0    0 0</span></span>
 <span class="docEmphStrong"><span class="docEmphMark">4 0   116    22704  69832  522428  0   0    0     0     3   80    100 0    0 0</span></span>
 <span class="docEmphStrong"><span class="docEmphMark">4 0   116    22704  69832  522428  0   0    0    14     2   82    100 0    0 0</span></span>
 <span class="docEmphStrong"><span class="docEmphMark">4 0   116    22704  69832  522428  0   0    0     0     1   75    100 0    0 0</span></span>
 6 0   116    22704  69832  522428  0   0    0     0     1   82    100 0    0 0
 0 0   116    22704  69832  522428  0   0    0     0     3  100     42 0   59 0
 0 0   116    22736  69832  522428  0   0    0     0     1   92      0 0  100 0
 0 0   116    22736  69832  522428  0   0    0     0     2  102      0 0  100 0
 0 0   116    22768  69832  522428  0   0    0     0     2   92      0 0  100 0
</pre></div><br>
<p class="docText">The <tt>vmstat</tt> output shows that the system got really busy when the application was started and went back to an idle state after the application exited. In this case, the user (us) column went up to 100, indicating a busy system in which all the CPU cycles (100 percent) were spent running the application code in the user space. For more information about <tt>vmstat</tt>, consult the vmstat(8) man pages.<a name="d0e79654"></a><a name="d0e79655"></a><a name="d0e79656"></a></P>

<a name="ch07lev3sec4"></a>
<h5 id="title-IDAZLEE0" class="docSection3Title">7.8.2.2. <a name="iddle1334"></a><a name="iddle1647"></a><a name="iddle1920"></a>iostat</h5>
<p class="docText"><tt>iostat</tt> generates a report about the system I/O activities. If no display interval is given, <tt>iostat</tt> displays I/O information since the last reboot. If a display interval is given, the first set of output represents total activity since boot time, and the subsequent outputs show only the delta activities. The report is divided into two sections: CPU utilization and device utilization. On multiprocessor systems, CPU statistics are calculated system-wide as averages among all processors:<a name="d0e79690"></a><a name="d0e79691"></a><a name="d0e79692"></a></p>
<div class="docText"><pre>avg-cpu: %user  %nice  %sys %iowait  %idle
              0.21   0.00   0.80     2.07   96.92

Device:     tps     Blk_read/s     Blk_wrtn/s     Blk_read             Blk_wrtn
sda        2.49            0.05       1443.46         2778              9552392
sdb        4.94            0.10       2871.73         5322            158268008
sdc        4.95            0.10       2860.91         5330            157671720
sdd       30.20         1518.55          0.42     83690898                23288
sde       60.25         2902.76          0.92    159978258                50896
sdf        0.00            0.01          0.00          378                   24
sdg       59.49         2883.87          0.90    158937034                49520
</pre></div><BR>
<p class="docText"><tt>iostat</tt> can indicate how busy disk devices can be during I/O operations. Depending on where files used by the application are placed, some disks can have more I/O operations than others. A disk that gets too busy can lead to large I/O waits, resulting in poor application performance. <tt>iostat</tt> information can help point out where the disk I/O bottlenecks are. This information can then be used by the application architect to redesign the filesystem layout policies.<sup class="docFootnote"><a class="docLink" href="#ch07fn21">[21]</a></sup></p><blockquote><p class="docFootnote"><sup><a name="ch07fn21">[21]</a></sup> Filesystems can be designed to be striped across disks to increase throughput.</p></blockquote>
<p class="docText">In our example printout, we can see that devices sdd, sde, and sdg have done the bulk of read operations, whereas devices sda, sdb, and sdc have done mostly write operations. This example also shows the tps (transaction per second) column of both the read and write operations. While comparing the tps rate of all disks, one can wonder why the write operations have low tps rates compared to the disks involved in performing read operations. This question can prompt us to investigate how<sup class="docFootnote"><a class="docLink" href="#ch07fn22">[22]</a></sup> files in these disks are accessed by the application to give us more clues as to why this is happening. This is just one example of how to use <tt>iostat</tt> to view the profile of the I/O operations of the application. For more information about <tt>iostat</tt>, refer to the iostat(1) man pages.</P><blockquote><p class="docFootnote"><sup><a name="ch07fn22">[22]</a></sup> Perhaps the block transfer rates differ.</p></blockquote>

<a name="ch07lev3sec5"></a>
<h5 id="title-IDA0OEE0" class="docSection3Title">7.8.2.3. <a name="iddle1337"></a><a name="iddle1923"></a>top</h5>
<p class="docText"><a name="iddle2500"></a><tt>top</tt> provides a continuously updated view of a running system.<a name="d0e79755"></a> It displays real-time information on CPU utilization, process statistics, and memory utilization, as shown here:<a name="d0e79757"></a><a name="d0e79758"></a></p>
<div class="docText"><pre>top - 16:23:43 up 27 days,7:07, 2 users, load average: 0.00, 0.00, 0.00
Tasks: 108 total,  1 running, 107 sleeping,  0 stopped,  0 zombie
Cpu0:0.0% us, 0.0% sy, 0.0% ni, 100.0% id, 0.0% wa, 0.0% hi, 0.0% si
Cpu1:0.1% us, 0.1% sy, 0.0% ni, 99.6% id,  0.1% wa, 0.0% hi, 0.0% si
Cpu2:0.0% us, 0.0% sy, 0.0% ni, 100.0% id, 0.0% wa, 0.0% hi, 0.0% si
Cpu3:0.1% us, 0.0% sy, 0.0% ni, 99.9% id,  0.0% wa, 0.0% hi, 0.0% si
Mem:  16190476k total, 2390180k used, 13800296k free,  223624k buffers
Swap: 37760724k total,       0k used, 37760724k free,  912316k cached

5775  root      15   0 31764  12m 2296 S  0.2  0.1 148:53.89 X
21463 root      16   0  2472 1520 1108 R  0.1  0.0   0:00.37 top
    1 root      16   0   628  284  248 S  0.0  0.0   0:04.34 init
    2 root      RT   0     0    0    0 S  0.0  0.0   0:00.00 migration/0
    3 root      34  19     0    0    0 S  0.0  0.0   0:00.00 ksoftirqd/0
    4 root      RT   0     0    0    0 S  0.0  0.0   0:00.00 migration/1
    5 root      34  19     0    0    0 S  0.0  0.0   0:00.00 ksoftirqd/1
    6 root      RT   0     0    0    0 S  0.0  0.0   0:00.01 migration/2
    7 root      34  19     0    0    0 S  0.0  0.0   0:00.00 ksoftirqd/2
</pre></div><br>
<p class="docText"><tt>top</tt>'s output is divided into two parts. The first part contains useful information related to overall system status such as CPU status, process counts, uptime, load average, and utilization statistics for both memory and swap space. The second part shows process-level statistics.</p>

<a name="ch07lev3sec6"></a>
<h5 id="title-IDAJREE0" class="docSection3Title">7.8.2.4. <a name="iddle1336"></a><a name="iddle1922"></a>ps</h5>
<p class="docText">The <a name="iddle2042"></a><tt>ps</tt> command displays information about active processes. Unlike <tt>top</tt>, the output is a single snapshot in time. You can view the information about how the memory and CPU are used by a particular process by using the <tt>ps</tt> command:</p>
<div class="docText"><pre>$<a name="iddle2043"></a>ps aux<a name="iddle1148"></a>
USER   PID   <span class="docEmphMark"><span class="docEmphStrong">%CPU %MEM VSZ  RSS</span>  TTY</span>  STAT START TIME COMMAND
root   10712 <span class="docEmphMark"> <span class="docEmphStrong">99.9 0.7 119196 118528</span></span>  pts/4 R+ 8:53 2:24  ./ofreqde
root   10720 <span class="docEmphMark"> <span class="docEmphStrong">0.0 0.0   2612    1064</span></span>  pts/0 R+ 8:55 0:00  ps aux
root   10721 <span class="docEmphMark"> <span class="docEmphStrong">0.0 0.0   2172     892</span></span>  pts/0 S+ 8:55 0:00  more
</pre></div><br>
<p class="docText">The output of the <tt>ps aux</tt> command shows not only the total percentage of system memory that each process uses, but also its virtual memory footprint (VSZ) and the amount of physical memory that the process is currently using (RSS).<a name="d0e79852"></a><a name="d0e79853"></a><a name="d0e79854"></a><a name="d0e79855"></a><a name="d0e79856"></a></p>

<a name="ch07lev3sec7"></a>
<h5 id="title-IDAXVEE0" class="docSection3Title">7.8.2.5. <a name="iddle1335"></a><a name="iddle1875"></a><a name="iddle1921"></a>nmon</h5>
<p class="docText">Although primarily used to monitor system performance when benchmarking an application, you can also use <tt>nmon</tt> to monitor the application's use of system resources. <tt>nmon</tt> is a free performance tool for Linux running on different supported platforms. You can use it to monitor or gather performance data, including CPU utilization, memory usage, disk I/O rates, network I/O rates, free space on filesystems, and more. Unlike <tt>top, nmon</tt> can record data to a file that can be analyzed at a later time. A companion tool called nmon analyzer is also available. The nmon analyzer is designed to take input files produced by <tt>nmon</tt> and turn them into spreadsheets containing high-quality graphs.</P>
<p class="docText">At the time of this writing, the <tt>nmon</tt> tool runs on the following:</p>
<ul><LI><p class="docList">Linux SUSE SLES 9, Red Hat EL 3 and 4, Debian on pSeries p5, and OpenPower</p></LI><li><p class="docList">Linux SUSE, Red Hat, and many recent distributions on x86 (Intel and AMD in 32-bit mode)</P></li><li><p class="docList">Linux SUSE and Red Hat on zSeries or mainframe</p></li><LI><p class="docList">AIX 4.1.5, 4.2.0, 4.3.2, and 4.3.3 (<tt>nmon</tt> version 9a: This version is functionally established and will not be developed further.)</P></LI><li><p class="docList">AIX 5.1, 5.2, and 5.3 (<tt>nmon</tt> version 10: This version now supports AIX 5.3 and POWER5 processor-based machines, with SMT and shared CPU micropartitions.)</P></li></ul>
<p class="docText">The nmon tool is available at <a class="docLink" target="_blank" href="http://www-128.ibm.com/developerworks/eserver/articles/analyze_aix/">www-128.ibm.com/developerworks/eserver/articles/analyze_aix/</a>.<sup class="docFootnote"><a class="docLink" href="#ch07fn23">[23]</a></sup></p><blockquote><p class="docFootnote"><sup><a name="ch07fn23">[23]</a></sup> Or at <a class="docLink" target="_blank" href="http://www.ibm.com/developer">www.ibm.com/developer</a> (search for nmon)</p></blockquote>
<p class="docText">We just discussed some of the most commonly used tools that will help the porting engineer gather information about the application's resource signature. For more information about performance tuning on Linux, refer to the following:<a name="d0e79948"></a><a name="d0e79949"></a><a name="d0e79950"></a></P>
<UL><li><p class="docList"><span class="docEmphasis">Performance Tuning for Linux Server</span>, by Sandra K. Johnson et al. (IBM Press, 2005)</p></li><li><p class="docList"><span class="docEmphasis">Optimizing Linux Performance: A Hands-on Guide to Linux Performance Tools</span>, by Phillip G. Ezolt (Prentice Hall, 2005)</P></li><li><p class="docList">Tuning IBM eServer xSeries Servers for Performance, by David Watts et al. (<a class="docLink" target="_blank" href="http://www.redbooks.ibm.com/Redbooks.nsf/RedbookAbstracts/sg245287.html?Open">www.redbooks.ibm.com/Redbooks.nsf/RedbookAbstracts/sg245287.html?Open</a>)</p></LI></ul>
<p class="docText">With more and more companies relying on their software applications for increased productivity, application performance will play a larger and larger role in contributing to that productivity. Both the internal and external views to application tuning will give us the necessary information we need to help us tune the application to perform to its maximum potential on the Linux platform.</p>


<a name="ch07lev2sec22"></a>
<H4 id="title-IDAT0EE0" class="docSection2Title">7.8.3. Other Tools</h4>
<p class="docText">Other open-source tools exist that help in profiling and system performance on Linux that we thought are worth mentioning. They are <a name="iddle1917"></a><a name="iddle1929"></a>Performance Inspector, System Tap, and Kprobes. Performance Inspector helps in application profiling; the other two tools deal more with the Linux kernel.</p>
<a name="ch07lev3sec8"></a>
<h5 id="title-IDAU1EE0" class="docSection3Title">7.8.3.1. Performance Inspector<sup class="docFootnote"><a class="docLink" href="#ch07fn24">[24]</a></sup></h5><blockquote><p class="docFootnote"><sup><a name="ch07fn24">[24]</a></sup> <a class="docLink" target="_blank" href="http://perfinsp.sourceforge.net/">http://perfinsp.sourceforge.net/</a></p></blockquote>
<p class="docText">Performance Inspector (<a class="docLink" target="_blank" href="http://sourceforge.net/projects/perfinsp">http://sourceforge.net/projects/perfinsp</a>) is a suite of tools that enables you to identify performance problems in your applications and shows you how your application interacts with the Linux kernel. It consists of the following tools:</p>
<ul><li><p class="docList">TProf is a CPU profiling tool. TProf interrupts the system periodically by time or the hardware performance monitor counters, and then determines the address of the interrupted code along with its process ID and thread ID. The sampling information is then processed and used to report hot spots in your code.<a name="d0e80020"></a><a name="d0e80021"></a></p></li><li><p class="docList">PTT collects per-thread statistics, such as the number of CPU cycles, number of interrupts, and number of times the thread was dispatched.</p></li><LI><p class="docList">JLM provides statistics on locks based on the Java 2 technology.</p></li><LI><p class="docList">JProf is a shared library that interfaces with the Java <tt>jvmpi</tt> interface.</p></LI><li><p class="docList">Hdump is used to analyze the live objects in a Java heap. Hdump provides a live object heap usage summary by object class.</P></li><li><p class="docList">ITrace for PPC64 is a software tracing mechanism that enables you to trace through both application and kernel code. ITrace proves most useful in situations where you have located a specific performance hot spot in your code and would like to optimize that hot spot at the assembly instruction level.</p></li></UL>
<p class="docText">The majority of code within Performance Inspector is released under the <a name="iddle1481"></a><a name="iddle1450"></a>GNU General Public License (GPL)<a name="d0e80059"></a>.<a name="d0e80061"></a> Some shared libraries are under the GNU LGPL. At the time of this writing, there are three different packages for the different set of tools and methods for installation, as follows:</P>
<UL><li><p class="docText"><span class="docEmphStrong"><a name="iddle1915"></a>PerfInsp.</span> This package uses kernel patches and therefore requires the kernel rebuild<a name="d0e80077"></a>. It is for the 2.4 kernel-based distributions.</P></li><li><p class="docText"><span class="docEmphStrong"><a name="iddle1231"></a>Dpiperf.dynamic.</span> This package is primarily intended for the 2.6 kernel-based distributions<a name="d0e80091"></a>. In this package, TProf and Java tools can be used without rebuilding the kernel. Other tools such as PTT and AI depend on <a name="iddle1660"></a><a name="iddle1928"></a>Kprobes. They therefore require a kernel patch until Kprobe is included in the distributions.</p></li><LI><p class="docText"><span class="docEmphStrong"><a name="iddle1916"></a>PerfInsp.ITrace.PPC64.</span> This package includes the version of ITrace for PPC64 that utilizes the Kprobe kernel feature<a name="d0e80116"></a>. The package contains the kernel patch for Kprobe, and therefore requires the kernel rebuild. This package has been tested on SLES9 and RHEL4.</P></li></ul>

<a name="ch07lev3sec9"></a>
<h5 id="title-IDA4BFE0" class="docSection3Title">7.8.3.2. SystemTap and Kprobes</h5>
<p class="docText">SystemTap (<a class="docLink" target="_blank" href="http://sources.redhat.com/systemtap">http://sources.redhat.com/systemtap</a>) is a dynamic instrumentation <a name="iddle1930"></a><a name="iddle2429"></a>system for Linux. SystemTap is built on top of Kprobes, a facility that provides insight into the operation of the Linux kernel without recompiling or rebooting because it is built as a kernel module. Kprobes allows locations in the kernel to be instrumented with code that will be executed when the processor encounters that probe point. After the instrumentation code completes execution, the kernel resumes the normal operation. Kprobes is now included in the mainline 2.6<sup class="docFootnote"><a class="docLink" href="#ch07fn25">[25]</a></sup> Linux kernel.<a name="d0e80148"></a><a name="d0e80149"></a><a name="d0e80150"></a><a name="d0e80151"></a></P><blockquote><p class="docFootnote"><sup><a name="ch07fn25">[25]</a></sup> Linux 2.6.12, to be exact</p></blockquote>
<p class="docText">Here are some other publications that will help you learn more about SystemTap and Kprobe:</p>
<ul><LI><p class="docList">Kernel debugging with Kprobes (<a class="docLink" target="_blank" href="http://www-106.ibm.com/developerworks/library/l-kprobes.html?ca=dgr-lnxw42Kprobe">www-106.ibm.com/developerworks/library/l-kprobes.html?ca=dgr-lnxw42Kprobe</a>)</p></li><LI><p class="docList">Gaining insight into the Linux kernel with Kprobes (<a class="docLink" target="_blank" href="http://www.redhat.com/magazine/005mar05/features/kprobes/">www.redhat.com/magazine/005mar05/features/kprobes/</a>)</p></li><li><p class="docList">Architecture of systemtap: a Linux trace/probe tool (<a class="docLink" target="_blank" href="http://sourceware.org/systemtap/archpaper-0505.pdf">http://sourceware.org/systemtap/archpaper-0505.pdf</a>)</p></li><li><p class="docList">Locating System Problems Using Dynamic Instrumentation, by Vara Prasad et al. Proceeding of Linux Symposium. July 2005, Ottawa, Canada.</p></li></ul>
<p class="docText">SystemTap is safe and lightweight enough to use with live production systems. It is able to instrument both kernel and user space programs even in the absence of source code. SystemTap's probe language will be easy to use, and users will be able to reuse general scripts written by others.</p>



<a href="9001536.html"><img src="images/pixel.jpg" alt="" width="1" height="1" border="0"></a></TD></TR></table>
<br>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<tr><td><div STYLE="MARGIN-LEFT: 0.15in;">
<a href=ch07lev1sec7.html><img src="images/prev.gif" width="60" height="17" border="0" align="absmiddle" alt="Previous Page"></a>
<td align="right"><div STYLE="MARGIN-LEFT: 0.15in;">
<a href=ch07lev1sec9.html><img src="images/next.gif" width="60" height="17" border="0" align="absmiddle" alt="Next Page"></a>
</div></td></tr></table>
</body></html>