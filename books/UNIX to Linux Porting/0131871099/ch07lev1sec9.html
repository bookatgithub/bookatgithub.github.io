<html>
<META http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<head>
<title>Section 7.9.&nbsp; Summary</title>
<link rel="STYLESHEET" type="text/css" href="images/style.css">
<link rel="STYLESHEET" type="text/css" href="images/docsafari.css">
</head>
<body>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<tr><td><div STYLE="MARGIN-LEFT: 0.15in;">
<a href=ch07lev1sec8.html><img src="images/prev.gif" width="60" height="17" border="0" align="absmiddle" alt="Previous Page"></a>
<td align="right"><div STYLE="MARGIN-LEFT: 0.15in;">
<a href=app01.html><img src="images/next.gif" width="60" height="17" border="0" align="absmiddle" alt="Next Page"></a>
</div></td></tr></table>
<br><table width="100%" border="0" cellspacing="0" cellpadding="0"><TR><td valign="top"><a name="ch07lev1sec9"></a>
<H3 id="title-IDAK1RQ0" class="docSection1Title">7.9. Summary</h3>
<p class="docText">Testing and debugging is an iterative process. Whenever a bug is found and then fixed, the application needs to go through another round of testing. Whether the application goes through a complete test cycle or just through a set of regression tests is a matter of choice. The main reason we go through a complete test cycle is to make sure a patch not only fixes the bug it was meant to fix, but that it does not cause other parts of the application to fail. If the patch was applied to a common library that is used by a large number of application functionalities, it is more advisable to run the application through a complete test cycle. If the patch only applies to some self-contained part of the code, however, it is safe to only run the application through a few tests that exercise that part of the code.</P>
<p class="docText">The GNU debugger is the debugger of choice on Linux.</p>
<p class="docText"><tt>Cscope</tt> is one of the best productivity tools recommended for use when porting or developing software applications. It alleviates the work of finding and cross-referencing symbols and functions used in small to very large application code.</p>
<p class="docText">Use of memory-debugging tools is a matter of preference. Some tools come in libraries that need to be linked in with the application; others wrap the application and analyze it without the need to link any libraries with the application.</p>
<p class="docText">Two views to application tuning exist. The internal view can help find application functions that can be optimized to perform better. The external view can help find the application's resource signature for systems planning. System utility tools such as <tt>top</tt> display application memory and CPU usage; code profilers such as <tt>OProfile</tt> can pinpoint what part of the application uses the most CPU.</p>
<p class="docText">With regard to the list of tools presented in this chapter, any seasoned software developer or porting personnel might say, &quot;The more tools I have, the better.&quot; Indeed, to develop or port applications and to do this well, you must have the right tools. Although there may be other debugging and performance tools for Linux we forgot to mention, the tools described here are the most generally available and widely used in the open-source community. The beauty of open source is if a tool does not come standard with a particular Linux distribution, anyone can go to the specific tool's Web site and download it.</P>

</TD></TR></table>
<br>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<tr><td><div STYLE="MARGIN-LEFT: 0.15in;">
<a href=ch07lev1sec8.html><img src="images/prev.gif" width="60" height="17" border="0" align="absmiddle" alt="Previous Page"></a>
<td align="right"><div STYLE="MARGIN-LEFT: 0.15in;">
<a href=app01.html><img src="images/next.gif" width="60" height="17" border="0" align="absmiddle" alt="Next Page"></a>
</div></td></tr></table>
</body></html>