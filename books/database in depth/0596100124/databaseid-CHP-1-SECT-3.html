<html>
<head>
<META http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<title>A Review of the Original Model</title>
<link rel="STYLESHEET" type="text/css" href="images/style.css">
<link rel="STYLESHEET" type="text/css" href="images/docsafari.css">
</head>
<body >
<table width="100%" border="0" cellspacing="0" cellpadding="0" bgcolor="#e6e6e6">
<tr style="background-image: url(images/tile_back.gif);">
<td class="v2" align="left" width="30%">
<a href="databaseid-CHP-1-SECT-2.html"><img src="images/previous.gif" width="70" height="19" border="0" align="absmiddle" alt="Previous Section"></a>
</td>
<td class="v2" align="center" width="40%">
<a href="main.html" style="color:white;text-decoration:none;text-underline:none">&nbsp;&lt;&nbsp;Day Day Up&nbsp;&gt;&nbsp;</a>
</td>
<td class="v2" align="right" width="30%">
<a href="databaseid-CHP-1-SECT-4.html"><img src="images/next.gif" width="70" height="19" border="0" align="absmiddle" alt="Next Section"></a>
</td>
</tr>
</table>
<br>
<table width="100%" border="0" cellspacing="0" cellpadding="0"><tr><TD valign="top"><a name="databaseid-CHP-1-SECT-3"></a>
<H3 class="docSection1Title">A Review of the Original Model</h3>
<a name="IDX-CHP-1-0081"></a><a name="IDX-CHP-1-0082"></a><a name="IDX-CHP-1-0083"></a>
<p class="docText">You're a database professional, so you already have some familiarity with the relational model. The purpose of this section is to serve as a kickoff point for our subsequent discussions; it reviews some of the most basic aspects of that model as originally defined. Note the qualifier "as originally defined"! One widespread misconception about the relational model is that it's a totally static thing. It's not. It's like mathematics in that respect: mathematics too is not a static thing but changes over time. In fact, the relational model can itself be seen as a small branch of mathematics; as such, it evolves over time as new theorems are proved and new results discovered. What's more, those new contributions can be made by anyone who's competent to do so. Like mathematics again, the relational model, though originally invented by one man, has become a community effort and now belongs to the world.</p>
<p class="docText">By the way, in case you don't know, that one man was E. F. Codd, at the time a researcher at IBM.<sup class="docFootnote"><a class="docLink" href="#databaseid-CHP-1-FNOTE-2">[*]</a></sup> It was late in 1968 that Codd, a mathematician by training, first realized that the discipline of mathematics could be used to inject some solid principles and rigor into the field of database management, which was all too deficient in such qualities prior to that time. His original definition of the relational model appeared in an IBM Research Report in 1969, and I'll have a little more to say about that paper in <a class="docLink" href="databaseid-appb.html#databaseid-appb">Appendix B</a>.</p><blockquote><p class="docFootnote"><sup><a name="databaseid-CHP-1-FNOTE-2">[*]</a></sup> E for Edgar and F for Frank—but he always signed with his initials. To his friends, among whom I was proud to count myself, he was Ted.</p></blockquote>
<a name="databaseid-CHP-1-SECT-3.1"></a>
<H4 class="docSection2Title">Structural Features</h4>
<a name="IDX-CHP-1-0084"></a><a name="IDX-CHP-1-0085"></a><a name="IDX-CHP-1-0086"></a><a name="IDX-CHP-1-0087"></a><a name="IDX-CHP-1-0088"></a><a name="IDX-CHP-1-0089"></a><a name="IDX-CHP-1-0090"></a><a name="IDX-CHP-1-0091"></a><a name="IDX-CHP-1-0092"></a>
<p class="docText">The original model had three major components—structure, integrity, and manipulation—and I'll briefly describe each in turn. Please note right away, however, that all of the "definitions" I'll be giving are very loose; I'll make them more precise as and when appropriate in later chapters.</P>
<p class="docText">First of all, then, structure. The principal structural feature is, of course, the relation<a name="IDX-CHP-1-0093"></a> itself, and as everybody knows it's common to picture relations as tables on paper (see <a class="docLink" href="#databaseid-CHP-1-FIG-1">Figure 1-1</a> for a self-explanatory example). Relations are defined over <span class="docEmphasis">types</span> (also known as <span class="docEmphasis">domains</span>); a type<a name="IDX-CHP-1-0094"></a> is basically a conceptual pool of values from which actual attributes in actual relations take their actual values. With reference to the simple departments-and-employees database illustrated in <a class="docLink" href="#databaseid-CHP-1-FIG-1">Figure 1-1</a>, for example, there might be a type called DNO ("department numbers"), which is the set of all valid department numbers. The attribute called DNO in the DEPT relation and the attribute called DNO in the EMP relation then would each contain values that are taken from that conceptual pool. (By the way, it isn't necessary for attributes to have the same name as the corresponding type, and often they won't. We'll see plenty of counterexamples later.)</p>
<a name="databaseid-CHP-1-FIG-1"></a><P><center>
<H5 class="docFigureTitle">Figure 1-1. The departments-and-employees database—sample values</H5>
<img border="0" alt="" width="409" height="129" SRC="images/0596100124/figs/databaseid_01_01.gif"></center></P><br>
<p class="docText">As I've said, tables like those in <a class="docLink" href="#databaseid-CHP-1-FIG-1">Figure 1-1</a> depict <span class="docEmphasis">relations: n</span>-ary relations, to be precise. An <span class="docEmphasis">n</span>-ary relation<a name="IDX-CHP-1-0095"></a> can be pictured as a table with <span class="docEmphasis">n</span> columns; the columns in the picture correspond to <span class="docEmphasis">attributes</span> of the relation and the rows correspond to <span class="docEmphasis">tuples</span>. Also, the value <span class="docEmphasis">n</span> can be any nonnegative integer. A 1-ary relation is said to be <span class="docEmphasis">unary;</span> a 2-ary relation, <span class="docEmphasis">binary;</span> a 3-ary relation, <span class="docEmphasis">ternary;</span> and so on.</p>
<p class="docText">The relational model also supports various kinds of <span class="docEmphasis">keys</span>. To begin with, every relation has at least one <span class="docEmphasis">candidate key</span>.<sup class="docFootnote"><a class="docLink" href="#databaseid-CHP-1-FNOTE-3">[*]</a></sup> A candidate key is just a unique identifier; in other words, it's a combination of attributes—often, but not always, a "combination" involving just one attribute—such that every tuple in the relation has a unique value for the combination in question. In <a class="docLink" href="#databaseid-CHP-1-FIG-1">Figure 1-1</a>, for example, every department has a unique department number and every employee has a unique employee number, so we can say that {DNO} is a candidate key for DEPT and {ENO} is a candidate key for EMP. Note the braces, by the way: candidate keys are always <span class="docEmphasis">combinations</span>, or <span class="docEmphasis">sets</span>, of attributes—even when the set contains just one attribute—and braces are conventionally used to enclose sets of things.</p><blockquote><p class="docFootnote"><sup><a name="databaseid-CHP-1-FNOTE-3">[*]</a></sup> Strictly speaking, this sentence should read "Every <span class="docEmphasis">relvar</span> has at least one candidate key" (see the section "<a class="docLink" href="databaseid-CHP-1-SECT-6.html#databaseid-CHP-1-SECT-6">Relations Versus Relvars</a>," later in this chapter). Similar remarks apply at various places elsewhere in this chapter, too (see <a class="docLink" href="databaseid-CHP-1-SECT-9.html#databaseid-CHP-1-SECT-9.1.1">Exercise 1-1</a> at the end of the chapter).</p></blockquote>
<p class="docText">Next, a <span class="docEmphasis">primary key</span><a name="IDX-CHP-1-0096"></a> is a candidate key that's been singled out for special treatment in some way. If a given relation has just one candidate key, then it obviously makes no real difference if we say it's the primary key. But if the relation has two or more candidate keys, then we're supposed to choose one of them as primary, meaning it's somehow "more equal than the others." Suppose, for example, that every employee has a unique employee number <span class="docEmphasis">and</span> a unique employee name, so that {ENO} and {ENAME} are both candidate keys for EMP. Then we might choose {ENO}, say, to be the primary key.</p>
<p class="docText">Notice I said we're <span class="docEmphasis">supposed</span> to choose a primary key. If there's just one candidate key, then there's no choice and no problem. But if there are two or more, then choosing one and making it primary smacks a little bit of arbitrariness (at least to me); certainly there are situations where there don't seem to be any good reasons for making such a choice. In this book, I usually <span class="docEmphasis">will</span> follow the primary key discipline—and in pictures like <a class="docLink" href="#databaseid-CHP-1-FIG-1">Figure 1-1</a> I'll mark primary key attributes by double underlining<a name="IDX-CHP-1-0097"></a>—but I stress the point that it's really candidate keys, not primary keys, that are significant from a relational point of view. Partly for this reason, from this point forward I'll use the term <span class="docEmphasis">key</span>, unqualified, to mean a candidate key specifically. (In case you were wondering, the "special treatment" enjoyed by primary keys over other candidate keys is mainly syntactic in nature, anyway; it isn't fundamental, and it isn't very important.)</p>
<p class="docText">Finally, a <span class="docEmphasis">foreign key</span><a name="IDX-CHP-1-0098"></a> is a set of attributes in one relation whose values are required to match the values of some candidate key in some other relation (or possibly in the same relation). With reference to <a class="docLink" href="#databaseid-CHP-1-FIG-1">Figure 1-1</a>, for example, {DNO} is a foreign key in EMP whose values are required to match values of the candidate key {DNO} in DEPT (as I've tried to suggest by means of a suitably labeled arrow in the figure). By <span class="docEmphasis">required to match</span>, I mean that if, for example, EMP includes a tuple in which DNO has the value D2, then DEPT had better also include a tuple in which DNO has the value D2; otherwise, EMP would show some employee as being in a nonexistent department, and the database wouldn't be "a faithful model of reality."</p>

<a name="databaseid-CHP-1-SECT-3.2"></a>
<h4 class="docSection2Title">Integrity Features</h4>
<a name="IDX-CHP-1-0099"></a>
<p class="docText">An <span class="docEmphasis">integrity constraint</span> (<span class="docEmphasis">constraint</span> for short) is basically just a boolean expression that must evaluate to TRUE. In the case of departments and employees, for example, we might have a constraint to the effect that SALARY values must be greater than zero. Now, any given database will be subject to numerous constraints, but those constraints will necessarily be expressed in terms of the relations in that particular database and will be specific to that database. By contrast, the relational model (at least as originally formulated) includes two <span class="docEmphasis">generic</span> integrity rules—generic in the sense that they apply to every database, loosely speaking. One has to do with primary keys and the other with foreign keys:</p>
<dl class="docList"><br><p><dt><span class="docPubcolor"><span class="docEmphasis">Entity integrity</span></span></dt></p>
<dd><p class="docList">Primary key attributes don't permit nulls.</p></dd><BR><p><dt><span class="docPubcolor"><span class="docEmphasis">Referential integrity</span></span></dt></p>
<dd><p class="docList">There mustn't be any unmatched foreign key values.</p></dd>
</dl>
<p class="docText">Let me explain the second first. By the term <span class="docEmphasis">unmatched foreign key value</span>, I mean a foreign key value for which there doesn't exist an equal value of the corresponding candidate key. Thus, for example, the departments-and-employees database would be in violation of the referential integrity<a name="IDX-CHP-1-0100"></a> rule if it included an EMP tuple with, say, a DNO value of D2 but no corresponding DEPT tuple. So the referential integrity rule simply spells out the semantics of foreign keys; the name <span class="docEmphasis">referential integrity</span> derives from the fact that any given foreign key value can be regarded as a <span class="docEmphasis">reference</span> to the tuple with that same value for the corresponding candidate key. In effect, therefore, the rule just says: "If <span class="docEmphasis">B</span> references <span class="docEmphasis">A</span>, then <span class="docEmphasis">A</span> must exist."</p>
<p class="docText">As for the entity integrity<a name="IDX-CHP-1-0101"></a> rule, well, here I have a problem. The fact is, I reject the concept of "nulls" entirely; that is, it is my very strong opinion that <span class="docEmphasis">nulls have no place in the relational model</span>. (Codd thought otherwise, obviously, but I have strong reasons for taking the position I do.) In order to explain the entity integrity rule, therefore, I need to suspend disbelief, as it were (at least for the time being), but please understand that I'll be revisiting the whole issue of nulls in <a class="docLink" href="databaseid-CHP-3.html#databaseid-CHP-3">Chapter 3</a>.</P>
<p class="docText">In essence, then, a null<a name="IDX-CHP-1-0102"></a> is a "marker" that means <span class="docEmphasis">value unknown</span> (crucially, it's not itself a value; it is, to repeat, a <span class="docEmphasis">marker</span>, or <span class="docEmphasis">flag</span>). For example, suppose we don't know employee E2's salary. Then, instead of entering some real SALARY value in the tuple for that employee in relation EMP—we <span class="docEmphasis">can't</span> enter a real value, by definition, precisely because we don't know what that value should be—we <span class="docEmphasis">mark</span> the SALARY position within that tuple as null:</P>
<a name="databaseid-CHP-1-FIG-u01"></a><p><center>
<H5 class="docFigureTitle"></H5>
<img border="0" alt="" width="189" height="50" SRC="images/0596100124/figs/databaseid_01_u01.gif"></center></P><br>
<p class="docText">As you can see, this tuple contains <span class="docEmphasis">nothing at all</span> in the SALARY position. In this book I'll use shading as just shown to highlight such empty positions; you can think of that shading as constituting the null "marker" or flag.</P>
<p class="docText">In terms of relation EMP, then, the entity integrity rule says, loosely, that an employee might have an unknown name, department, or salary, but <span class="docEmphasis">not</span> an unknown employee number—because if the employee number were unknown, we wouldn't even know which employee (that is, which "entity") we were talking about.</P>
<p class="docText">That's all I want to say about nulls for now. Forget about them until <a class="docLink" href="databaseid-CHP-3.html#databaseid-CHP-3">Chapter 3</a>.</P>

<a name="databaseid-CHP-1-SECT-3.3"></a>
<H4 class="docSection2Title">Manipulative Features</H4>
<a name="IDX-CHP-1-0103"></a><a name="IDX-CHP-1-0104"></a>
<p class="docText">The manipulative part of the model consists of:</P>
<ul><li><p class="docList">A set of relational operators, such as difference (or MINUS), collectively called the <span class="docEmphasis">relational algebra</span><a name="IDX-CHP-1-0105"></a>, together with</P></LI><li><p class="docList">A <span class="docEmphasis">relational assignment</span><a name="IDX-CHP-1-0106"></a> operator that allows the value of some relational expression, such as <span class="docEmphasis">r</span> MINUS <span class="docEmphasis">s</span> (where <span class="docEmphasis">r</span> and <span class="docEmphasis">s</span> are relations), to be assigned to some relation.</p></li></ul>
<p class="docText">The relational assignment operator is fundamentally how updates are done in the relational model,<sup class="docFootnote"><a class="docLink" href="#databaseid-CHP-1-FNOTE-4">[*]</a></sup> and I'll have more to say about it later, in the section "<a class="docLink" href="databaseid-CHP-1-SECT-6.html#databaseid-CHP-1-SECT-6">Relations Versus Relvars</a>." As for the relational algebra, it consists of a set of operators that allow "new" relations to be derived from "old" ones (speaking very loosely). More precisely, each operator takes at least one relation as input and produces another relation as output; for example, difference (or MINUS) takes two relations as input and "subtracts" one from the other to derive another relation as output. And it's very important that the output is another relation: that's the well-known <span class="docEmphasis">closure</span><a name="IDX-CHP-1-0107"></a> property of the relational algebra. The closure property is what lets us write <span class="docEmphasis">nested relational expressions</span>; since the output from every operation is the same kind of thing as the input, the output from one operation can become the input to another—meaning, for example, that we can take the difference between <span class="docEmphasis">r</span> and <span class="docEmphasis">s</span>, feed the result as input to a union with some relation <span class="docEmphasis">u</span>, feed that result as input to an intersection with some relation <span class="docEmphasis">v</span>, and so on.</P><blockquote><p class="docFootnote"><sup><a name="databaseid-CHP-1-FNOTE-4">[*]</a></sup> I follow convention throughout this book in using the generic term "update" to refer to the INSERT, DELETE, and UPDATE (and assignment) operators considered collectively. When I want to refer to the UPDATE operator specifically, I'll set it in all caps as just shown.</p></blockquote>
<p class="docText">Now, any number of operators can be defined that fit the simple definition of "at least one relation in, exactly one relation out." In the following list I'll briefly describe what are usually thought of as the original eight operators (essentially the ones Codd defined in his earliest papers); in <a class="docLink" href="databaseid-CHP-5.html#databaseid-CHP-5">Chapter 5</a> I'll introduce a number of additional operators and describe them in more detail. <a class="docLink" href="#databaseid-CHP-1-FIG-2">Figure 1-2</a> is a pictorial representation of the original eight operators. <span class="docEmphasis">Note:</span> If you're unfamiliar with any of these operators—especially divide!—and find the following brief descriptions hard to follow, don't worry about it; I'll be going into much more detail, with lots of examples, later (mostly in <a class="docLink" href="databaseid-CHP-5.html#databaseid-CHP-5">Chapter 5</a>).</P>
<a name="IDX-CHP-1-0108"></a><a name="IDX-CHP-1-0109"></a><a name="IDX-CHP-1-0110"></a><a name="IDX-CHP-1-0111"></a><a name="IDX-CHP-1-0112"></a><dl class="docList"><br><P><dt><span class="docPubcolor"><span class="docEmphasis">Restrict</span></span></dt></P>
<dd><p class="docList">Returns a relation containing all tuples from a specified relation that satisfy a specified condition. For example, we might restrict<a name="IDX-CHP-1-0108"></a> relation EMP to just the tuples where the DNO value is D2.</P></dd><BR><p><dt><span class="docPubcolor"><span class="docEmphasis">Project</span></span></dt></p>
<dd><p class="docList">Returns a relation containing all (sub)tuples that remain in a specified relation after specified attributes have been removed. For example, we might project<a name="IDX-CHP-1-0109"></a> relation EMP on just the ENO and SALARY attributes.</p></dd><br><p><dt><span class="docPubcolor"><span class="docEmphasis">Product</span></span></dt></p>
<dd><p class="docList">Returns a relation containing all possible tuples that are a combination of two tuples, one from each of two specified relations. Product is also known variously as <span class="docEmphasis">cartesian product</span>, <span class="docEmphasis">cross product, cross join</span>, and <span class="docEmphasis">cartesian join</span> (in fact, itis just a special case of join, as we'll see in <a class="docLink" href="databaseid-CHP-5.html#databaseid-CHP-5">Chapter 5</a>).</p>
<a name="databaseid-CHP-1-FIG-2"></a><p><center>
<h5 class="docFigureTitle">Figure 1-2. The original relational algebra (results shaded)</h5>
<img border="0" alt="" width="463" height="581" SRC="images/0596100124/figs/databaseid_01_02.gif"></center></p><br>
</dd>
<br><p><dt><span class="docPubcolor"><span class="docEmphasis">Intersect</span></span></dt></P>
<dd><p class="docList">Returns a relation containing all tuples that appear in both of two specified relations. (Actually, intersect<a name="IDX-CHP-1-0110"></a> also is a special case of join<a name="IDX-CHP-1-0111"></a>.)</p></dd><br><p><dt><span class="docPubcolor"><span class="docEmphasis">Union</span></span></dt></p>
<dd><p class="docList">Returns a relation containing all tuples that appear in either or both of two specified relations.</P></dd><BR><p><dt><span class="docPubcolor"><span class="docEmphasis">Difference</span></span></dt></P>
<dd><p class="docList">Returns a relation containing all tuples that appear in the first and not the second of two specified relations.</P></dd><BR><p><dt><span class="docPubcolor"><span class="docEmphasis">Join</span></span></dt></P>
<dd><p class="docList">Returns a relation containing all possible tuples that are a combination of two tuples, one from each of two specified relations, such that the two tuples contributing to any given result tuple have a common value for the common attributes of the two relations (and that common value appears just once, not twice, in that result tuple).</P>
<a name="databaseid-CHP-1-NOTE-2"></a><div class="docNote"><p class="docNormalTitle">NOTE</P><P><p class="docText">This kind of join was originally called the <span class="docEmphasis">natural</span> join. Since natural join<a name="IDX-CHP-1-0112"></a> is far and away the most important kind, however, it's become standard practice to take the unqualified term <span class="docEmphasis">join</span> to mean the natural join specifically, and I'll follow that practice in this book.</P></P></div></dd><br><p><dt><span class="docPubcolor"><span class="docEmphasis">Divide</span></span></dt></P>
<dd><p class="docList">Takes two relations, one binary and one unary, and returns a relation consisting of all values of one attribute of the binary relation that match (in the other attribute) all values in the unary relation.</P></dd></dl>
<p class="docText">One last point to close this subsection: as you probably know, there's also something called the <span class="docEmphasis">relational calculus</span><a name="IDX-CHP-1-0113"></a>. The relational calculus can be regarded as an alternative to the relational algebra; that is, instead of saying the manipulative part of the relational model consists of the relational algebra (plus relational assignment), we can equally well say it consists of the relational calculus (plus relational assignment). The two are equivalent and interchangeable, in the sense that for every algebraic expression there's a logically equivalent expression of the calculus and vice versa. I'll have a little more to say about the calculus in <a class="docLink" href="databaseid-appa.html#databaseid-appa">Appendix A</a>.</p>

<a name="databaseid-CHP-1-SECT-3.4"></a>
<h4 class="docSection2Title">The Running Example</h4>
<a name="IDX-CHP-1-0114"></a><a name="IDX-CHP-1-0115"></a><a name="IDX-CHP-1-0116"></a><a name="IDX-CHP-1-0117"></a>
<p class="docText">I'll finish up this brief review by introducing the example I'll use as the basis for most if not all of the discussions in the rest of the book: the well-known suppliers-and-parts database (see <a class="docLink" href="#databaseid-CHP-1-FIG-3">Figure 1-3</a>). To elaborate:</p>
<dl class="docList"><BR><p><dt><I><span class="docPubcolor">Suppliers</span></i></dt></P>
<dd><p class="docList">Relation S denotes suppliers (more accurately, suppliers under contract). Each supplier has one supplier number (SNO), which is unique to that supplier (and so {SNO} is the primary key); one name (SNAME), not necessarily unique (though the SNAME values in <a class="docLink" href="#databaseid-CHP-1-FIG-3">Figure 1-3</a> do happen to be unique); one rating or status value (STATUS); and one location (CITY).</P></dd><BR><P><dt><i><span class="docPubcolor">Parts</span></i></dt></p>
<dd><p class="docList">Relation P denotes parts (more accurately, kinds of parts). Each kind of part has one part number (PNO), which is unique (so {PNO} is the primary key); one name (PNAME); one color (COLOR); one weight (WEIGHT); and one location where parts of that kind are stored (CITY).</p></dd><br><p><dt><i><span class="docPubcolor">Shipments</span></i></dt></p>
<dd><p class="docList">Relation SP denotes shipments (it shows which parts are supplied by which suppliers). Each shipment has one supplier number (SNO), one part number (PNO), and one quantity (QTY). For the sake of the example, I assume there's at most one shipment at any given time for a given supplier and a given part (and so {SNO,PNO} is the primary key; also, {SNO} and {PNO} are both foreign keys, matching the primary keys of S and P, respectively). Note that the database shown in <a class="docLink" href="#databaseid-CHP-1-FIG-3">Figure 1-3</a> includes one supplier, supplier S5, with no shipments at all.</p>
<a name="databaseid-CHP-1-FIG-3"></a><p><center>
<h5 class="docFigureTitle">Figure 1-3. The suppliers-and-parts database—sample values</h5>
<img border="0" alt="" width="425" height="270" SRC="images/0596100124/figs/databaseid_01_03.gif"></center></p><BR>
</dd>
</dl>


<ul></ul></td></tr></table>
<table width="100%" border="0" cellspacing="0" cellpadding="0" bgcolor="#e6e6e6">
<tr style="background-image: url(images/tile_back.gif);">
<td class="v2" align="left" width="30%">
<a href="databaseid-CHP-1-SECT-2.html"><img src="images/previous.gif" width="70" height="19" border="0" align="absmiddle" alt="Previous Section"></a>
</td>
<td class="v2" align="center" width="40%">
<a href="main.html" style="color:white;text-decoration:none;text-underline:none">&nbsp;&lt;&nbsp;Day Day Up&nbsp;&gt;&nbsp;</a>
</td>
<td class="v2" align="right" width="30%">
<a href="databaseid-CHP-1-SECT-4.html"><img src="images/next.gif" width="70" height="19" border="0" align="absmiddle" alt="Next Section"></a>
</td>
</tr>
</table>
</body>
</html>
