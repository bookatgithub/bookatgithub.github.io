<html>
<head>
<META http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<title>So What's a Type?</title>
<link rel="STYLESHEET" type="text/css" href="images/style.css">
<link rel="STYLESHEET" type="text/css" href="images/docsafari.css">
</head>
<body >
<table width="100%" border="0" cellspacing="0" cellpadding="0" bgcolor="#e6e6e6">
<tr style="background-image: url(images/tile_back.gif);">
<td class="v2" align="left" width="30%">
<a href="databaseid-CHP-2-SECT-2.html"><img src="images/previous.gif" width="70" height="19" border="0" align="absmiddle" alt="Previous Section"></a>
</td>
<td class="v2" align="center" width="40%">
<a href="main.html" style="color:white;text-decoration:none;text-underline:none">&nbsp;&lt;&nbsp;Day Day Up&nbsp;&gt;&nbsp;</a>
</td>
<td class="v2" align="right" width="30%">
<a href="databaseid-CHP-2-SECT-4.html"><img src="images/next.gif" width="70" height="19" border="0" align="absmiddle" alt="Next Section"></a>
</td>
</tr>
</table>
<br>
<table width="100%" border="0" cellspacing="0" cellpadding="0"><tr><td valign="top"><a name="databaseid-CHP-2-SECT-3"></a>
<h3 class="docSection1Title">So What's a Type?</h3>
<a name="IDX-CHP-2-0205"></a><a name="IDX-CHP-2-0206"></a><a name="IDX-CHP-2-0207"></a><a name="IDX-CHP-2-0208"></a><a name="IDX-CHP-2-0209"></a><a name="IDX-CHP-2-0210"></a><a name="IDX-CHP-2-0211"></a><a name="IDX-CHP-2-0212"></a><a name="IDX-CHP-2-0213"></a><a name="IDX-CHP-2-0214"></a><a name="IDX-CHP-2-0215"></a><a name="IDX-CHP-2-0216"></a><a name="IDX-CHP-2-0217"></a><a name="IDX-CHP-2-0218"></a><a name="IDX-CHP-2-0219"></a><a name="IDX-CHP-2-0220"></a><a name="IDX-CHP-2-0221"></a><a name="IDX-CHP-2-0222"></a>
<p class="docText">From this point forward I'll switch to the term <span class="docEmphasis">type</span> in preference to <span class="docEmphasis">domain</span>. What is a type, exactly? In essence, it's <span class="docEmphasis">a named, finite set of value</span> s<sup class="docFootnote"><a class="docLink" href="#databaseid-CHP-2-FNOTE-8">[*]</a></sup>드ll possible values of some specific kind: for example, all possible integers, or all possible character strings, or all possible supplier numbers, or all possible XML documents, or all possible relations with a certain heading (and so on). Moreover:</p><blockquote><p class="docFootnote"><sup><a name="databaseid-CHP-2-FNOTE-8">[*]</a></sup> Finite because we're dealing with computers, which are finite by definition. Also, note that qualifier <span class="docEmphasis">named;</span> types with different names are different types.</P></blockquote>
<ul><li><p class="docList">Every value is of some type들n fact, of exactly one type, except possibly if type inheritance is supported, a concept that's beyond the scope of this book. Note, therefore, that types are <span class="docEmphasis">disjoint</span> or <span class="docEmphasis">nonoverlapping</span>. (To elaborate briefly: as one reviewer said, surely types WarmBloodedAnimal and FourLeggedAnimal overlap? Indeed they do; but what I'm saying is that if types overlap, then for a variety of reasons we're getting into the realm of type inheritance들n fact, into <span class="docEmphasis">multiple</span> inheritance. Since those reasons, and indeed the whole topic of inheritance, are independent of the context we're in, be it relational or something else, I'm not going to discuss them in this book.)</p></li><LI><p class="docList">Every variable, every attribute, every operator that returns a result, and every parameter of every operator is declared to be of some type. And to say that (for example) variable <span class="docEmphasis">V</span> is declared to be of type <span class="docEmphasis">T</span> means, precisely, that every value <span class="docEmphasis">v</span> that can legally be assigned to <span class="docEmphasis">V</span> is itself of type <span class="docEmphasis">T</span>.</P></li><LI><p class="docList">Every expression denotes some value and is therefore of some type: namely, the type of the value in question, which is to say the type of the value returned by the outermost operator in the expression (where by "outermost" I mean the operator that's executed last). For example, the type of the expression (<span class="docEmphasis">A</span>+<span class="docEmphasis">B</span>)*(<span class="docEmphasis">X</span>-<span class="docEmphasis">Y</span>) is the declared type of the operator "*", whatever that happens to be.</P></LI></ul>
<p class="docText">The fact that parameters in particular are declared to be of some type touches on an issue that I've mentioned but haven't properly discussed yet: namely, the fact that every type has an associated set of operators for operating on values and variables of the type in question. For example, integers have the usual arithmetic operators; dates and times have special calendar arithmetic operators; XML documents have what are called "XPath" operators; relations have the operators of the relational algebra; and <span class="docEmphasis">every</span> type has the operators of assignment (":=") and equality comparison ("="). Thus, any system that provides proper type support드nd "proper type support" here certainly includes allowing users to define their own types듨ust provide a way for users to define their own operators, too, because types without operators are useless.</P>
<p class="docText">It's important to understand also that values and variables of a given type can be operated upon <span class="docEmphasis">solely</span> by means of the operators defined for that type. For example, in the case of the system-defined type INTEGER:</P>
<UL><LI><p class="docList">The system provides an assignment operator ":=" for assigning integer values to integer variables.</P></LI><li><p class="docList">It also provides comparison operators "=", "&lt;", and so on, for comparing integer values.</p></LI><LI><p class="docList">It also provides arithmetic operators "+", "*", and so on, for performing arithmetic on integer values.</p></li><li><p class="docList">It does <span class="docEmphasis">not</span> provide string operators "||" (concatenate), SUBSTR (substring), and so on, for performing string operations on integer values; in other words, string operations on integer values are not supported.</p></LI></ul>
<p class="docText">By contrast, in the case of the user-defined type<a name="IDX-CHP-2-0223"></a> SNO, we would certainly define assignment and comparison operators (":=", "=", "<img src=images/ent/U2260.GIF border=0>", possibly "&gt;", and so on); however, we probably wouldn't define operators "+", "*", and so on, which would mean that arithmetic on supplier numbers wouldn't be supported (why would we ever want to add or multiply two supplier numbers?).</P>
<p class="docText">From everything I've said so far, then, it should be clear that defining a new type involves at least all of the following:</p>
<div style="font-weight:bold"><ol class="docList" type="1"><LI><div style="font-weight:normal"><p class="docList">Specifying a name for that type (obviously enough).</P></div></LI><LI><div style="font-weight:normal"><p class="docList">Specifying the values that make up that type. I'll discuss this aspect in more detail in <a class="docLink" href="databaseid-CHP-6.html#databaseid-CHP-6">Chapter 6</a>.</p></div></li><li><div style="font-weight:normal"><p class="docList">Specifying the hidden physical representation for values of that type. As noted earlier, this is an implementation issue, not a model issue, and I won't discuss it further in this book.</p></div></li><li><div style="font-weight:normal"><p class="docList">Specifying the operators that apply to values and variables of that type (see below).</p></div></li><li><div style="font-weight:normal"><p class="docList">For those operators that return a result, specifying the type of that result (again, see below).</p></div></li></ol></div>
<p class="docText">Observe that points 4 and 5 taken together imply that the system knows precisely which expressions are legal, as well as the type of the result for each such legal expression.</p>
<p class="docText">By way of example, suppose we have a user-defined type POINT, representing geometric points in two-dimensional space. Here then is the <span class="docEmphStrong">Tutorial D</span> definition<sup class="docFootnote"><a class="docLink" href="#databaseid-CHP-2-FNOTE-9">[*]</a></sup> for an operator called REFLECT which, given a point P with cartesian coordinates (<span class="docEmphasis">x,y</span>), returns the "reflected" or "inverse" point with cartesian coordinates (<span class="docEmphasis">-x,-y</span>):</p><blockquote><p class="docFootnote"><sup><a name="databaseid-CHP-2-FNOTE-9">[*]</a></sup> I could have used SQL, but operator definitions in SQL involve a number of details that I don't want to get into here.</p></blockquote>
<pre>
    1 OPERATOR REFLECT ( P POINT ) RETURNS POINT ;
    2    RETURN ( POINT ( - THE_X ( P ) , - THE_Y ( P ) ) ) ;
    3 END OPERATOR ;</pre><BR>

<p class="docText"><span class="docEmphasis">Explanation</span>:</p>
<ul><li><p class="docList">Line 1 shows that the operator is called REFLECT, takes a single parameter P of type POINT, and returns a result also of type POINT (so the declared type of the operator is POINT).</p></LI><LI><p class="docList">Line 2 is the operator implementation code. It consists of a single RETURN statement. The value to be returned is, of course, a point, and it's obtained by invoking the POINT <span class="docEmphasis">selector</span> operator; that invocation has two arguments, corresponding to the X and Y coordinates of the point in question. Each of those arguments involves a <span class="docEmphasis">THE_ operator</span> invocation; those invocations yield the X and Y coordinates of the point argument corresponding to parameter P, and negating those coordinates leads us to the desired result.</p></LI><LI><p class="docList">Line 3 marks the end of the definition.</P></li></UL>
<p class="docText">Now, for the most part, I've been talking so far about user-defined types specifically. For a system-defined or built-in type, similar considerations apply, of course, but in this case the definitions are furnished by the system instead of by some user. For example, if INTEGER is a built-in type, then it's the system that defines the name, specifies legal integers, defines the hidden representation, and defines the corresponding operators. Of course, to someone who merely makes use of some user-defined type that's been defined by somebody else, that type looks just like a system-defined type anyway; indeed, in many ways that's the whole object of the exercise.</P>
<p class="docText">I don't propose to go into much more detail regarding type and operator definitions, because they aren't specifically relational topics, for the most part.</P>

<UL></UL></TD></tr></table>
<table width="100%" border="0" cellspacing="0" cellpadding="0" bgcolor="#e6e6e6">
<tr style="background-image: url(images/tile_back.gif);">
<td class="v2" align="left" width="30%">
<a href="databaseid-CHP-2-SECT-2.html"><img src="images/previous.gif" width="70" height="19" border="0" align="absmiddle" alt="Previous Section"></a>
</td>
<td class="v2" align="center" width="40%">
<a href="main.html" style="color:white;text-decoration:none;text-underline:none">&nbsp;&lt;&nbsp;Day Day Up&nbsp;&gt;&nbsp;</a>
</td>
<td class="v2" align="right" width="30%">
<a href="databaseid-CHP-2-SECT-4.html"><img src="images/next.gif" width="70" height="19" border="0" align="absmiddle" alt="Next Section"></a>
</td>
</tr>
</table>
</body>
</html>
