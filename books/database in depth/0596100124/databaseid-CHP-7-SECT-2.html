<html>
<head>
<META http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<title>Functional Dependencies and Boyce/Codd Normal Form</title>
<link rel="STYLESHEET" type="text/css" href="images/style.css">
<link rel="STYLESHEET" type="text/css" href="images/docsafari.css">
</head>
<body >
<table width="100%" border="0" cellspacing="0" cellpadding="0" bgcolor="#e6e6e6">
<tr style="background-image: url(images/tile_back.gif);">
<td class="v2" align="left" width="30%">
<a href="databaseid-CHP-7-SECT-1.html"><img src="images/previous.gif" width="70" height="19" border="0" align="absmiddle" alt="Previous Section"></a>
</td>
<td class="v2" align="center" width="40%">
<a href="main.html" style="color:white;text-decoration:none;text-underline:none">&nbsp;&lt;&nbsp;Day Day Up&nbsp;&gt;&nbsp;</a>
</td>
<td class="v2" align="right" width="30%">
<a href="databaseid-CHP-7-SECT-3.html"><img src="images/next.gif" width="70" height="19" border="0" align="absmiddle" alt="Next Section"></a>
</td>
</tr>
</table>
<br>
<table width="100%" border="0" cellspacing="0" cellpadding="0"><tr><TD valign="top"><a name="databaseid-CHP-7-SECT-2"></a>
<H3 class="docSection1Title">Functional Dependencies and Boyce/Codd Normal Form</H3>
<p class="docText">It's well known that the notions of <span class="docEmphasis">second normal form</span><a name="IDX-CHP-7-0516"></a> (2NF), <span class="docEmphasis">third normal form</span> (3NF), and <span class="docEmphasis">Boyce/Codd normal form</span> (BCNF) all depend on the notion of <span class="docEmphasis">functional dependency</span><a name="IDX-CHP-7-0517"></a>. Here's a precise definition:</P>
<blockquote><p class="docText"><span class="docEmphasis">Definition:</span> Let <span class="docEmphasis">A</span> and <span class="docEmphasis">B</span> be subsets of the heading of relvar <span class="docEmphasis">R</span>. Then relvar <span class="docEmphasis">R</span> satisfies the <span class="docEmphasis">functional dependency</span> (FD<a name="IDX-CHP-7-0518"></a>) <span class="docEmphasis">A</span> <img src=images/ent/U2192.GIF border=0> <span class="docEmphasis">B</span> if and only if, in every relation that's a legal value for <span class="docEmphasis">R</span>, whenever two tuples have the same value for <span class="docEmphasis">A</span>, they also have the same value for <span class="docEmphasis">B</span>.</P></blockquote>
<p class="docText">The FD <span class="docEmphasis">A</span> <img src=images/ent/U2192.GIF border=0> <span class="docEmphasis">B</span> is read as "<span class="docEmphasis">B</span> is functionally dependent on <span class="docEmphasis">A</span>," or "<span class="docEmphasis">A</span> functionally determines <span class="docEmphasis">B</span>," or, more simply, just "<span class="docEmphasis">A</span> arrow <span class="docEmphasis">B</span>."</P>
<p class="docText">By way of example, suppose there's an integrity constraint to the effect that if two suppliers are in the same city, then they must have the same status (see <a class="docLink" href="#databaseid-CHP-7-FIG-2">Figure 7-2</a>, where I've changed the status for supplier S2 from 10 to 30 in order to conform to this hypothetical new constraint). Then the FD:</p>
<pre>
  { CITY } <img src=images/ent/U2192.GIF border=0> { STATUS }
</pre><br>

<p class="docText">is satisfied by this revised form—let's call it RS—of the suppliers relvar S. Note the braces, by the way; I use braces to stress the point that both sides of the FD are <span class="docEmphasis">sets</span> of attributes, even when (as in the example) the sets in question involve just a single attribute.</P>
<a name="databaseid-CHP-7-FIG-2"></a><P><center>
<h5 class="docFigureTitle">Figure 7-2. Revised suppliers relvar RS—sample value</h5>
<img border="0" alt="" width="320" height="102" SRC="images/0596100124/figs/databaseid_07_02.gif"></center></p><br>
<p class="docText">As the example indicates, the fact that some relvar <span class="docEmphasis">R</span> satisfies a given FD constitutes a database constraint in the sense of the previous chapter; more precisely, it constitutes a (single-relvar) constraint on that relvar <span class="docEmphasis">R</span>. For instance, the FD in the example is equivalent to the following <span class="docEmphStrong">Tutorial D</span> constraint:</P>
<pre>
  CONSTRAINT RSC COUNT ( RS { CITY } ) =
                 COUNT ( RS { CITY, STATUS } ) ;
</pre><br>

<p class="docText">By the way, here's a useful thing to remember: if relvar <span class="docEmphasis">R</span> satisfies the FD <span class="docEmphasis">A</span> <img src=images/ent/U2192.GIF border=0> <span class="docEmphasis">B</span>, it necessarily satisfies the FD <span class="docEmphasis">A'</span> <img src=images/ent/U2192.GIF border=0> <span class="docEmphasis">B'</span> for all supersets <span class="docEmphasis">A'</span> of <span class="docEmphasis">A</span> and all subsets <span class="docEmphasis">B'</span> of <span class="docEmphasis">B</span>. In other words, you can always add attributes to the left side or subtract them from the right side, and what you get will still be a valid FD.</P>
<p class="docText">At this point I need to introduce a couple of terms. The first is <i>superkey</I><a name="IDX-CHP-7-0519"></a>. Basically, a superkey is a superset of a key (not necessarily a proper superset, of course); equivalently (with reference to the formal definition of <span class="docEmphasis">key</span> from <a class="docLink" href="databaseid-CHP-4.html#databaseid-CHP-4">Chapter 4</a>), a subset <span class="docEmphasis">SK</span> of the heading of relvar <span class="docEmphasis">R</span> is a superkey for <span class="docEmphasis">R</span> if and only if it possesses the uniqueness property but not necessarily the irreducibility property. Thus, every key is a superkey, but most superkeys aren't keys; for example, {SNO,CITY} is a superkey for relvar S but not a key. Observe in particular that the heading of relvar <span class="docEmphasis">R</span> is always a superkey for <span class="docEmphasis">R</span>.</P>
<a name="databaseid-CHP-7-NOTE-21"></a><div class="docNote"><p class="docNormalTitle">NOTE</P><P><p class="docText"><span class="docEmphasis">Important:</span> If <span class="docEmphasis">SK</span> is a superkey for <span class="docEmphasis">R</span> and <span class="docEmphasis">A</span> is any subset of the heading of <span class="docEmphasis">R, R</span> necessarily satisfies the FD <span class="docEmphasis">SK</span> <img src=images/ent/U2192.GIF border=0> <span class="docEmphasis">A—</span> because if two tuples of <span class="docEmphasis">R</span> have the same value for <span class="docEmphasis">SK</span>, then by definition they're the very same tuple, and so they <span class="docEmphasis">obviously</span> have the same value for <span class="docEmphasis">A</span>. (I did touch on this point in <a class="docLink" href="databaseid-CHP-4.html#databaseid-CHP-4">Chapter 4</a>, but there I talked in terms of keys, not superkeys.)</p></p></div>
<p class="docText">The other new term is <span class="docEmphasis">trivial<a name="IDX-CHP-7-0520"></a> FD</span>. Basically, an FD is <span class="docEmphasis">trivial</span> if there's no way it can possibly be violated. For example, the following FDs are all trivially satisfied by any relvar that includes attributes called SNO, STATUS, and CITY:</p>
<pre>
  { CITY, STATUS } <img src=images/ent/U2192.GIF border=0> { CITY }
  { SNO, CITY }    <img src=images/ent/U2192.GIF border=0> { CITY }
  { CITY }         <img src=images/ent/U2192.GIF border=0> { CITY }
  { SNO }          <img src=images/ent/U2192.GIF border=0> { SNO }
</pre><br>

<p class="docText">In the first case, for instance, if two tuples have the same value for CITY and STATUS, they certainly have the same value for CITY. In fact, an FD is trivial if and only if the left side is a superset of the right side (again, not necessarily a proper superset). Of course, we don't usually think about trivial FDs when we're doing database design, because they're, well, trivial; but when we're trying to be formal and precise about these matters, we need to take <span class="docEmphasis">all</span> FDs into account, trivial ones as well as nontrivial.</p>
<p class="docText">Having pinned down the notion of FD precisely, I can now say that Boyce/Codd normal form<a name="IDX-CHP-7-0521"></a> (BCNF) is <span class="docEmphasis">the</span> normal form with respect to FDs—and, of course, I can also define it precisely:</p>
<blockquote><p class="docText"><span class="docEmphasis">Definition:</span> Relvar <span class="docEmphasis">R</span> is in BCNF if and only if, for every nontrivial FD <span class="docEmphasis">A</span> <img src=images/ent/U2192.GIF border=0> <span class="docEmphasis">B</span> satisfied by <span class="docEmphasis">R, A</span> is a superkey for <span class="docEmphasis">R</span>.</p></blockquote>
<p class="docText">In other words, in a BCNF relvar, the only FDs are either trivial ones (we can't get rid of those, obviously) or "arrows out of superkeys" (we can't get rid of those, either). Or as some people like to say: <span class="docEmphasis">Every fact is a fact about the key, the whole key, and nothing but the key—</span> though I must immediately add that this informal characterization, intuitively pleasing though it is, isn't really accurate, because it assumes among other things that there's just one key.</p>
<p class="docText">I need to elaborate slightly on the previous paragraph. When I talk about "getting rid of" some FD, I fear I'm being a little sloppy once again. For example, the revised suppliers relvar RS of <a class="docLink" href="#databaseid-CHP-7-FIG-2">Figure 7-2</a> satisfies the FD {SNO} <img src=images/ent/U2192.GIF border=0> {STATUS}; but if we decompose it—as we're going to do in a moment—into relvars SNC and CS (where SNC has attributes SNO, SNAME, and CITY, and CS has attributes CITY and STATUS), that FD "disappears," in a sense, and thus we have indeed "gotten rid of it." But what does it mean to say the FD has disappeared? What's happened is that it's become a multi-relvar constraint (that is, a constraint that involves two or more relvars).<sup class="docFootnote"><a class="docLink" href="#databaseid-CHP-7-FNOTE-1">[*]</a></sup> So the constraint certainly still exists—it just isn't an FD any more. Similar remarks apply to all of my uses of the phrase "get rid of" in this chapter.</p><blockquote><p class="docFootnote"><sup><a name="databaseid-CHP-7-FNOTE-1">[*]</a></sup> It's also, in this particular example, an <span class="docEmphasis">implied</span> constraint (as it was before, in fact, since it was implied by the constraint KEY{SNO} for RS). To be specific, it's implied by the combination of constraints KEY{SNO} (for SNC), KEY{CITY} (for CS), and the foreign key constraint from SNC to CS.</p></blockquote>
<p class="docText">Finally, as I assume you know, the normalization discipline says that if relvar <span class="docEmphasis">R</span> is not in BCNF, it should be decomposed into smaller ones that are (where "smaller" means, basically, having fewer attributes). For example:</p>
<ul><li><p class="docList">Relvar STP (see <a class="docLink" href="databaseid-CHP-7-SECT-1.html#databaseid-CHP-7-FIG-1">Figure 7-1</a>) satisfies the FD {SNO} <img src=images/ent/U2192.GIF border=0> {STATUS}, which is neither trivial nor "an arrow out of a superkey"—{SNO} isn't a superkey for STP—and the relvar is thus not in BCNF (and of course it suffers from redundancy, as we saw earlier). So we decompose it into relvars SP and SS, say, where SP has attributes SNO, PNO, and QTY (as usual) and SS has attributes SNO and STATUS. (As an exercise, show sample values for relvars SP and SS corresponding to the STP value in <a class="docLink" href="databaseid-CHP-7-SECT-1.html#databaseid-CHP-7-FIG-1">Figure 7-1</a>; convince yourself that SP and SS are in BCNF and that the decomposition eliminates the redundancy.)</p></LI><li><p class="docList">Similarly, relvar RS (see <a class="docLink" href="#databaseid-CHP-7-FIG-2">Figure 7-2</a>) satisfies the FD {CITY} <img src=images/ent/U2192.GIF border=0> {STATUS} and should therefore be decomposed into, say, SNC (with attributes SNO, SNAME, and CITY) and CS (with attributes CITY and STATUS). (As an exercise, show sample values for SNC and CS corresponding to the RS value in <a class="docLink" href="#databaseid-CHP-7-FIG-2">Figure 7-2</a>; convince yourself that SNC and CS are in BCNF and that the decomposition eliminates the redundancy.)</p></li></ul>
<a name="databaseid-CHP-7-SECT-2.1"></a>
<H4 class="docSection2Title">Nonloss Decomposition</H4>
<a name="IDX-CHP-7-0522"></a><a name="IDX-CHP-7-0523"></a>
<p class="docText">We know that if some relvar isn't in BCNF, it should be decomposed into smaller ones that are. Of course, it's important that the decomposition be <span class="docEmphasis">nonloss</span> (also called <span class="docEmphasis">lossless</span>): we must be able to get back to where we came from—the decomposition mustn't lose any information. Consider relvar RS once again (see <a class="docLink" href="#databaseid-CHP-7-FIG-2">Figure 7-2</a>), with its FD {CITY} <img src=images/ent/U2192.GIF border=0> {STATUS}. Suppose we were to decompose that relvar, not as before into relvars SNC and CS, but instead into relvars <span class="docEmphasis">SNS</span> and CS as illustrated in <a class="docLink" href="#databaseid-CHP-7-FIG-3">Figure 7-3</a>. (Relvar CS is the same in both decompositions, but SNS has attributes SNO, SNAME, and STATUS instead of SNO, SNAME, and CITY.) Then I hope it's clear that (a) SNS and CS are both in BCNF, but (b) the decomposition is not nonloss but "lossy"—for example, we can't tell whether supplier S2 is in Paris or Athens, and so we've lost information.</p>
<a name="databaseid-CHP-7-FIG-3"></a><P><center>
<H5 class="docFigureTitle">Figure 7-3. Relvars SNS and CS—sample values</H5>
<img border="0" alt="" width="329" height="104" SRC="images/0596100124/figs/databaseid_07_03.gif"></center></p><BR>
<p class="docText">What exactly is it that makes some decompositions nonloss and others lossy? Well, note that the decomposition process is, formally, <span class="docEmphasis">a process of taking projections;</span> all of the "smaller" relvars in all of our examples so far have been projections of the original relvar. In other words, the decomposition operator is, precisely, the projection operator of relational algebra.</P>
<a name="databaseid-CHP-7-NOTE-22"></a><div class="docNote"><p class="docNormalTitle">NOTE</P><P><p class="docText">I'm being sloppy again. Like all of the algebraic operators, projection really applies to relations, not relvars. But we often say things like <span class="docEmphasis">relvar CS is a projection of relvar RS</span> when what we really mean is <span class="docEmphasis">the relation that's the value of relvar CS at any given time is a projection of the relation that's the value of relvar RS at that time</span>.I hope that's clear!</P></P></div>
<p class="docText">Onward. When we say a certain decomposition is nonloss, what we really mean is that <span class="docEmphasis">if we join the projections together again, we get back to the original relvar</span>. Observe in particular that, with reference to <a class="docLink" href="#databaseid-CHP-7-FIG-3">Figure 7-3</a>, relvar RS is <span class="docEmphasis">not</span> equal to the join of its projections SNS and CS, and that's why the decomposition is lossy. With reference to <a class="docLink" href="#databaseid-CHP-7-FIG-2">Figure 7-2</a>, by contrast, it <span class="docEmphasis">is</span> equal to the join of its projections SNC and CS; that decomposition is indeed nonloss.</p>
<p class="docText">To say it again, then, the decomposition operator is projection and the recomposition operator is join. And the formal question that lies at the heart of normalization theory is this:</p>
<blockquote><p class="docText">Let <span class="docEmphasis">R</span> be a relvar and let <span class="docEmphasis">R1, R2</span>, . . . <span class="docEmphasis">, Rn</span> be projections of <span class="docEmphasis">R</span>. What conditions must be satisfied in order for <span class="docEmphasis">R</span> to be equal to the join of those projections?</P></blockquote>
<p class="docText">An important, though partial, answer to this question was provided by Ian Heath in 1971 when he proved the following theorem:</P>
<blockquote><p class="docText">Let <span class="docEmphasis">A, B</span>, and <span class="docEmphasis">C</span> be subsets of the heading of relvar <span class="docEmphasis">R</span> such that the (set-theoretic) union of <span class="docEmphasis">A, B</span>, and <span class="docEmphasis">C</span> is equal to that heading. Let <span class="docEmphasis">AB</span> denote the (set-theoretic) union of <span class="docEmphasis">A</span> and <span class="docEmphasis">B</span>, and similarly for <span class="docEmphasis">AC</span>. If <span class="docEmphasis">R</span> satisfies the FD <span class="docEmphasis">A</span> <img src=images/ent/U2192.GIF border=0> <span class="docEmphasis">B</span>, then <span class="docEmphasis">R</span> is equal to the join of its projections on <span class="docEmphasis">AB</span> and <span class="docEmphasis">AC</span>.</p></blockquote>
<p class="docText">By way of example, consider relvar RS once again (<a class="docLink" href="#databaseid-CHP-7-FIG-2">Figure 7-2</a>). That relvar satisfies the FD {CITY} <img src=images/ent/U2192.GIF border=0> {STATUS}. Thus, taking <span class="docEmphasis">A</span> as {CITY}, <span class="docEmphasis">B</span> as {STATUS}, and <span class="docEmphasis">C</span> as {SNO,SNAME}, Heath's theorem<a name="IDX-CHP-7-0524"></a> tells us that RS can be nonloss-decomposed into its projections on {CITY,STATUS} and {CITY,SNO,SNAME}—as indeed we already know.</p>
<a name="databaseid-CHP-7-NOTE-23"></a><div class="docNote"><p class="docNormalTitle">NOTE</p><p><p class="docText">In case you're wondering why I said Heath's theorem provides only a partial answer to the original question, let me explain in terms of the foregoing example. Basically, the theorem does tell us that the decomposition of <a class="docLink" href="#databaseid-CHP-7-FIG-2">Figure 7-2</a> is nonloss; however, it doesn't tell us that the decomposition of <a class="docLink" href="#databaseid-CHP-7-FIG-3">Figure 7-3</a> is lossy. That is, it gives a <span class="docEmphasis">sufficient</span> condition, but not a <span class="docEmphasis">necessary</span> one, for a decomposition to be nonloss. (A stronger form of Heath's theorem, giving both necessary and sufficient conditions, was proved by Ron Fagin in 1977, but the details are beyond the scope of the present discussion. See <a class="docLink" href="databaseid-CHP-7-SECT-8.html#databaseid-CHP-7-SECT-8.1.18">Exercise 7-18</a> at the end of the chapter.)</P></p></div>
<p class="docText">As an aside, I remark that in the paper in which he proved his theorem, Heath also gave a definition of what he called "third" normal form that was in fact a definition of BCNF. Since that definition predated Boyce and Codd's own definition by some three years, it seems to me that BCNF ought by rights to be called <span class="docEmphasis">Heath</span> normal form. But it isn't.</P>
<p class="docText">One last point: it follows from the discussions of this subsection that the constraint I showed earlier for relvar RS:</p>
<pre>
  CONSTRAINT RSC COUNT ( RS { CITY } ) =
                 COUNT ( RS { CITY, STATUS } ) ;
</pre><BR>

<p class="docText">could alternatively be expressed thus:</P>
<pre>
  CONSTRAINT RSC
     RS = JOIN { RS { SNO, SNAME, CITY }, RS { CITY, STATUS } } ;
</pre><BR>

<p class="docText">("At all times, relvar RS is equal to the join of its projections on {SNO,SNAME,CITY} and {CITY,STATUS}"; I'm using the prefix version of JOIN here.)</P>

<a name="databaseid-CHP-7-SECT-2.2"></a>
<h4 class="docSection2Title">But Isn't It All Just Common Sense?</h4>
<a name="IDX-CHP-7-0525"></a><a name="IDX-CHP-7-0526"></a>
<p class="docText">I noted earlier that normalization theory has been criticized on the grounds that it's all basically just common sense. Consider relvar STP again, for example (see <a class="docLink" href="databaseid-CHP-7-SECT-1.html#databaseid-CHP-7-FIG-1">Figure 7-1</a>). That relvar<a name="IDX-CHP-7-0527"></a> is <span class="docEmphasis">obviously</span> badly designed; the redundancies are obvious, the consequences are obvious too, and any competent human designer would "naturally" decompose that relvar into its projections SP and SS as previously discussed, even if that designer had no knowledge of BCNF whatsoever. But what does "naturally" mean here? What <span class="docEmphasis">principles</span> is the designer applying in opting for that "natural" design?</p>
<p class="docText">The answer is: they're exactly the principles of normalization. That is, competent designers already have those principles in their brain, as it were, even if they've never studied them formally and can't put a name to them. So yes, the principles <span class="docEmphasis">are</span> common sense—but they're <span class="docEmphasis">formalized</span> common sense. (Common sense might be common, but it's not so easy to say exactly what it is!) What normalization theory does is state in a precise way what certain aspects of common sense consist of. In my opinion, that's the real achievement of normalization theory: it formalizes certain commonsense principles, thereby opening the door to the possibility of mechanizing those principles (that is, incorporating them into mechanical design tools). Critics of normalization usually miss this point; they claim, quite rightly, that the ideas are really just common sense, but they typically don't realize that it's a significant achievement to state what common sense means in a precise and formal way.</p>

<a name="databaseid-CHP-7-SECT-2.3"></a>
<h4 class="docSection2Title">1NF, 2NF, 3NF</h4>
<a name="IDX-CHP-7-0528"></a><a name="IDX-CHP-7-0529"></a>
<p class="docText">Normal forms below BCNF are mostly of historical interest; as noted in the introductory section, in fact, I don't even want to bother to give the definitions here. I'll just remind you that <span class="docEmphasis">all</span> relvars are at least in 1NF,<sup class="docFootnote"><a class="docLink" href="#databaseid-CHP-7-FNOTE-2">[*]</a></sup> even ones with relation-valued attributes (RVAs). From a design point of view, however, relvars with RVAs are usually—though not invariably—contraindicated. Of course, this doesn't mean you should never have RVAs (in particular, there's no problem with query results that include RVAs); it just means we don't usually want RVAs "designed into the database," as it were (and we can always eliminate them, thanks to the availability of the UNGROUP operator of relational algebra). I don't want to get into a lot of detail on this issue here; let me just say that relvars with RVAs look very like the hierarchies found in older, nonrelational systems like IMS<a name="IDX-CHP-7-0530"></a>, and all of the old problems that used to arise with hierarchies therefore raise their head again. Here for purposes of reference is a brief list of some of those problems:</p><blockquote><p class="docFootnote"><sup><a name="databaseid-CHP-7-FNOTE-2">[*]</a></sup> In earlier chapters I said it was <span class="docEmphasis">relations</span>, not relvars, that were always in 1NF, but no harm is done if we extend the term to apply to relvars as well.</p></blockquote>
<ul><li><p class="docList">The fundamental problem is that hierarchies are asymmetric. Thus, though they might make some tasks "easy," they certainly make others difficult. (See <a class="docLink" href="databaseid-CHP-5-SECT-11.html#databaseid-CHP-5-SECT-11.1.27">Exercises 5-27</a>, <a class="docLink" href="databaseid-CHP-5-SECT-11.html#databaseid-CHP-5-SECT-11.1.29">5-29</a>, and <a class="docLink" href="databaseid-CHP-5-SECT-11.html#databaseid-CHP-5-SECT-11.1.30">5-30</a> at the end of <a class="docLink" href="databaseid-CHP-5.html#databaseid-CHP-5">Chapter 5</a> for some illustrations of this point.)</p></li><li><p class="docList">Queries are therefore asymmetric too, as well as being more complicated than their symmetric counterparts.</p></LI><li><p class="docList">The same goes for integrity constraints.</p></li><li><p class="docList">The same goes for updates, but more so.</P></LI><li><p class="docList">There's no guidance as to how to choose the "best" hierarchy.</P></LI><LI><p class="docList">Even "natural" hierarchies like organization charts are still best represented, usually, by nonhierarchic designs.</p></LI></UL>
<p class="docText">To repeat, however, RVAs can occasionally be OK, even in base relvars. See <a class="docLink" href="databaseid-CHP-7-SECT-8.html#databaseid-CHP-7-SECT-8.1.14">Exercise 7-14</a> at the end of the chapter.</P>


<UL></UL></TD></tr></table>
<table width="100%" border="0" cellspacing="0" cellpadding="0" bgcolor="#e6e6e6">
<tr style="background-image: url(images/tile_back.gif);">
<td class="v2" align="left" width="30%">
<a href="databaseid-CHP-7-SECT-1.html"><img src="images/previous.gif" width="70" height="19" border="0" align="absmiddle" alt="Previous Section"></a>
</td>
<td class="v2" align="center" width="40%">
<a href="main.html" style="color:white;text-decoration:none;text-underline:none">&nbsp;&lt;&nbsp;Day Day Up&nbsp;&gt;&nbsp;</a>
</td>
<td class="v2" align="right" width="30%">
<a href="databaseid-CHP-7-SECT-3.html"><img src="images/next.gif" width="70" height="19" border="0" align="absmiddle" alt="Next Section"></a>
</td>
</tr>
</table>
</body>
</html>
