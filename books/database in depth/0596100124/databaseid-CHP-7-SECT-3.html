<html>
<head>
<META http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<title>Join Dependencies and Fifth Normal Form</title>
<link rel="STYLESHEET" type="text/css" href="images/style.css">
<link rel="STYLESHEET" type="text/css" href="images/docsafari.css">
</head>
<body >
<table width="100%" border="0" cellspacing="0" cellpadding="0" bgcolor="#e6e6e6">
<tr style="background-image: url(images/tile_back.gif);">
<td class="v2" align="left" width="30%">
<a href="databaseid-CHP-7-SECT-2.html"><img src="images/previous.gif" width="70" height="19" border="0" align="absmiddle" alt="Previous Section"></a>
</td>
<td class="v2" align="center" width="40%">
<a href="main.html" style="color:white;text-decoration:none;text-underline:none">&nbsp;&lt;&nbsp;Day Day Up&nbsp;&gt;&nbsp;</a>
</td>
<td class="v2" align="right" width="30%">
<a href="databaseid-CHP-7-SECT-4.html"><img src="images/next.gif" width="70" height="19" border="0" align="absmiddle" alt="Next Section"></a>
</td>
</tr>
</table>
<br>
<table width="100%" border="0" cellspacing="0" cellpadding="0"><tr><TD valign="top"><a name="databaseid-CHP-7-SECT-3"></a>
<H3 class="docSection1Title">Join Dependencies and Fifth Normal Form</H3>
<a name="IDX-CHP-7-0531"></a>
<p class="docText">Fifth normal form (5NF) is—in a certain special sense which I'll explain later in this section—"the final normal form." In fact, just as BCNF is <span class="docEmphasis">the</span> normal form with respect to functional dependencies, so fifth normal form<a name="IDX-CHP-7-0532"></a> is <span class="docEmphasis">the</span> normal form with respect to what are called <span class="docEmphasis">join</span> dependencies:</P>
<blockquote><p class="docText"><span class="docEmphasis">Definition:</span> Let <span class="docEmphasis">A, B</span>, . . . <span class="docEmphasis">, Z</span> be subsets of the heading of relvar <span class="docEmphasis">R</span>. Then <span class="docEmphasis">R</span> satisfies the <span class="docEmphasis">join dependency</span> (JD<a name="IDX-CHP-7-0533"></a>)</P>
<pre>
  <div><img border="0" alt="" width="7" height="9" SRC="images/0596100124/figs/databaseid_in_07_01.gif"></div>{ <span class="docEmphasis">A</span>, <span class="docEmphasis">B</span>, ..., <span class="docEmphasis">Z</span> }
</pre><BR>

<p class="docText">if and only if every relation that's a legal value for <span class="docEmphasis">R</span> is equal to the join of its projections on <span class="docEmphasis">A, B</span>, . . . <span class="docEmphasis">, Z</span>.</p></blockquote>
<p class="docText">The JD <img border="0" alt="" width="7" height="9" SRC="images/0596100124/figs/databaseid_in_07_01.gif">{<span class="docEmphasis">A,B</span>, . . . <span class="docEmphasis">,Z</span>} is read as "star <span class="docEmphasis">A, B</span>, . . . <span class="docEmphasis">, Z</span>." Points arising from this definition:</p>
<UL><LI><p class="docList">It's immediate that <span class="docEmphasis">R</span> can be nonloss-decomposed into its projections on <span class="docEmphasis">A, B</span>, . . . <span class="docEmphasis">, Z</span> if and only if it satisfies the JD <img border="0" alt="" width="7" height="9" SRC="images/0596100124/figs/databaseid_in_07_01.gif">{<span class="docEmphasis">A,B</span>, . . . <span class="docEmphasis">,Z</span>}.</p></li><li><p class="docList">It's also immediate that every FD is a JD because (as we know from the previous section) if <span class="docEmphasis">R</span> satisfies a certain FD, then it can be nonloss-decomposed into certain projections (in other words, it satisfies a certain JD).</p></LI></ul>
<p class="docText">As an example of this latter point, consider relvar RS once again (<a class="docLink" href="databaseid-CHP-7-SECT-2.html#databaseid-CHP-7-FIG-2">Figure 7-2</a>). That relvar satisfies the FD {CITY} <img src=images/ent/U2192.GIF border=0> {STATUS} and can therefore be nonloss-decomposed into its projections SNC (on SNO, SNAME, and CITY) and CS (on CITY and STATUS). It follows that relvar RS satisfies the JD <img border="0" alt="" width="7" height="9" SRC="images/0596100124/figs/databaseid_in_07_01.gif">{SNC,CS}—if you'll allow me to use the names SNC and CS, just for the moment, to refer to the applicable subsets of the heading of that relvar as well as to the projections as such.</P>
<p class="docText">Now, we saw in the previous section that there are always "arrows out of superkeys"; that is, certain functional dependencies are implied by superkeys<a name="IDX-CHP-7-0534"></a>, and we can never get rid of them. More generally, in fact, certain <span class="docEmphasis">join</span> dependencies are implied by superkeys, and we can never get rid of those, either. To be specific, the JD <img border="0" alt="" width="7" height="9" SRC="images/0596100124/figs/databaseid_in_07_01.gif">{<span class="docEmphasis">A,B</span>, . . . <span class="docEmphasis">,Z</span>} is <span class="docEmphasis">implied by superkeys</span> if and only if each of <span class="docEmphasis">A, B</span>, . . . <span class="docEmphasis">, Z</span> is a superkey for the pertinent relvar <span class="docEmphasis">R</span>. For example, consider our usual suppliers relvar S. The fact that {SNO} is a superkey (actually a key) for that relvar implies among other things that the relvar satisfies this JD:</p>
<pre>
  <div><img border="0" alt="" width="7" height="9" SRC="images/0596100124/figs/databaseid_in_07_01.gif"></div> { SN, SS, SC }
</pre><BR>

<p class="docText">where SN is {SNO,SNAME}, SS is {SNO,STATUS}, and SC is {SNO,CITY} (note that each of these is a superkey for S). And it's certainly true that we could nonloss-decompose S, if we wanted to, into its projections on SN, SS, and SC—though whether we would actually want to is another matter.</P>
<p class="docText">We also saw in the previous section that certain FDs are trivial<a name="IDX-CHP-7-0535"></a>. As you're probably expecting by now, certain JDs are trivial too. To be specific, the JD <img border="0" alt="" width="7" height="9" SRC="images/0596100124/figs/databaseid_in_07_01.gif">{<span class="docEmphasis">A,B</span>, . . . <span class="docEmphasis">,Z</span>} is <span class="docEmphasis">trivial</span> if and only if at least one of <span class="docEmphasis">A, B</span>, . . . <span class="docEmphasis">, Z</span> is equal to the entire heading of the pertinent relvar <span class="docEmphasis">R</span>. For example, here's one of the many trivial JDs that relvar S satisfies:</P>
<pre>
  <div><img border="0" alt="" width="7" height="9" SRC="images/0596100124/figs/databaseid_in_07_01.gif"></div> { S, SN, SS, SC }
</pre><BR>

<p class="docText">I'm using the name S here, just for the moment, to refer to the set of all attributes—the heading—of relvar S (corresponding, of course, to the <span class="docEmphasis">identity</span> projection of the relvar S). I hope it's obvious that any relvar can always be nonloss-decomposed into a given set of projections if one of the projections in that set is the pertinent identity projection<a name="IDX-CHP-7-0536"></a>. (Though it's a bit of a stretch to talk about "decomposition" in such a situation, because one of the projections in that "decomposition" is identical to the original relvar; I mean, there's not much "decomposing" going on here!)</p>
<p class="docText">Having pinned down the notion of JD precisely, I can now give a precise definition of 5NF:</p>
<blockquote><p class="docText"><span class="docEmphasis">Definition:</span> Relvar <span class="docEmphasis">R</span> is in 5NF if and only if every nontrivial JD satisfied by <span class="docEmphasis">R</span> is implied by the superkeys of <span class="docEmphasis">R</span>.</p></blockquote>
<p class="docText">In other words, the only JDs satisfied by a 5NF relvar are ones we can't get rid of; it's if a relvar satisfies any <span class="docEmphasis">other</span> JDs that it's not in 5NF (and therefore suffers from redundancy problems), and so probably needs to be decomposed.</p>
<a name="databaseid-CHP-7-SECT-3.1"></a>
<h4 class="docSection2Title">The Significance of 5NF</h4>
<a name="IDX-CHP-7-0537"></a><a name="IDX-CHP-7-0538"></a><a name="IDX-CHP-7-0539"></a><a name="IDX-CHP-7-0540"></a><a name="IDX-CHP-7-0541"></a>
<p class="docText">I'm sure you noticed that I didn't show an example in the foregoing discussion of a relvar that was in BCNF but not in 5NF (and so could be nonloss-decomposed to adavantage). The reason I didn't is this: while JDs that aren't just simple FDs do exist, (a) those JDs tend to be unusual in practice, and (b) they also tend to be a little complicated, more or less by definition. Because they're complicated, I decided not to give an example right away (I'll give one in the next subsection, however); because they're unusual, they aren't so important anyway from a practical point of view. Let me elaborate.</p>
<p class="docText">First of all, if you're a database designer, you certainly do need to know about JDs and 5NF; they're tools in your toolkit, as it were, and (other things being equal) you should generally try to ensure that all of the relvars in your database are in 5NF. But most relvars (not all) that occur in practice, if they're at least in BCNF, are in 5NF as well; that is, it's quite rare in practice to find a relvar that's in BCNF and not also in 5NF. Indeed, there's a theorem that addresses this issue:</p>
<blockquote><p class="docText">Let <span class="docEmphasis">R</span> be a BCNF relvar and let <span class="docEmphasis">R</span> have no composite keys (that is, no keys consisting of two or more attributes). Then <span class="docEmphasis">R</span> is in 5NF.</p></blockquote>
<p class="docText">This theorem is quite useful. What it says is that if you can get to BCNF (which is easy enough) and there aren't any composite keys in your BCNF relvar (which is often but not always the case), you don't have to worry about the complexities of general JDs and 5NF—you know without having to think about the matter any further that the relvar simply <span class="docEmphasis">is</span> in 5NF.</p>
<p class="docText">As an aside, I remark in the interests of accuracy that the foregoing theorem actually applies to 3NF, not BCNF; that is, it really says a <span class="docEmphasis">3NF</span> relvar with no composite keys is necessarily in 5NF. But every BCNF relvar is in 3NF, and in any case BCNF is much more important than 3NF, pragmatically speaking.</p>
<p class="docText">So 5NF as a concept is perhaps not all that important from a practical point of view. But it's <span class="docEmphasis">very</span> important from a theoretical one, because (as I said at the beginning of this section) it's "the final normal form" and—what amounts to the same thing—it's <span class="docEmphasis">the</span> normal form with respect to general join dependencies. For if relvar <span class="docEmphasis">R</span> is in 5NF, the only nontrivial JDs are ones implied by superkeys. Hence, the only nonloss decompositions are ones in which every projection is on the attributes of some superkey; in other words, every such projection includes some key of <span class="docEmphasis">R</span>. As a consequence, the corresponding "recomposition" joins are all one-to-one, and no redundancies are or can be eliminated by the decomposition.</p>
<p class="docText">Let me put this point another way. To say that relvar <span class="docEmphasis">R</span> is in 5NF is to say that further nonloss decomposition of <span class="docEmphasis">R</span> into projections, while it might be possible, certainly won't eliminate any redundancies. <span class="docEmphasis">Note very carefully, however, that to say that R is in 5NF is not to say that R is redundancy-free</span>. There are many kinds of redundancy that projection as such is powerless to remove—which is an illustration of the point I made earlier, in the section "The Place of Design Theory," to the effect that there are numerous issues that design theory simply doesn't address. By way of example, consider <a class="docLink" href="#databaseid-CHP-7-FIG-4">Figure 7-4</a>, which shows a sample value for a relvar, SPJ, that's in 5NF and yet suffers from redundancy. For example, the fact that supplier S2 supplies part P3 appears several times; so does the fact that part P3 is supplied to project J4—JNO stands for <span class="docEmphasis">project number—</span> and so does the fact that project J1 is supplied by supplier S2. (The relvar predicate is <span class="docEmphasis">Supplier SNO supplies part PNO to project JNO in quantity QTY</span>, and the sole key is {SNO,PNO,JNO}.) The only nontrivial join dependency satisfied by this relvar is this <span class="docEmphasis">functional</span> dependency:<sup class="docFootnote"><a class="docLink" href="#databaseid-CHP-7-FNOTE-3">[*]</a></sup></p><blockquote><p class="docFootnote"><sup><a name="databaseid-CHP-7-FNOTE-3">[*]</a></sup> Equivalently, using the name SPJQ to refer to the set of all attributes of SPJ, the relvar satisfies the trivial JD <img border="0" alt="" width="7" height="9" SRC="images/0596100124/figs/databaseid_in_07_01.gif">{SPJQ}. (Recall from <a class="docLink" href="databaseid-CHP-5.html#databaseid-CHP-5">Chapter 5</a> that the join of a single relation <span class="docEmphasis">r</span> is just <span class="docEmphasis">r</span> itself.)</p></blockquote>
<pre>
  { SNO, PNO, JNO } <img src=images/ent/U2192.GIF border=0> { QTY }
</pre><BR>

<p class="docText">which is an "arrow out of a superkey." In other words, QTY depends on all three of SNO, PNO, and JNO, and it can't appear in a relvar with anything less than all three. Hence, there's no nonloss decomposition that can remove the redundancies.</p>
<p class="docText">There are a few further points I need to make here. First, I didn't mention the point previously, but you probably know that 5NF is always achievable; that is, it's always possible to decompose a non-5NF relvar into 5NF projections.</p>
<a name="databaseid-CHP-7-FIG-4"></a><p><center>
<h5 class="docFigureTitle">Figure 7-4. The 5NF relvar SPJ—sample value</H5>
<img border="0" alt="" width="173" height="176" SRC="images/0596100124/figs/databaseid_07_04.gif"></center></P><br>
<p class="docText">Second, every 5NF relvar<a name="IDX-CHP-7-0542"></a> is in BCNF, of course; so to say that <span class="docEmphasis">R</span> is in BCNF certainly doesn't preclude the possibility that <span class="docEmphasis">R</span> is in 5NF as well. Informally, however, it's very common to interpret statements to the effect that <span class="docEmphasis">R</span> is in BCNF as meaning that <span class="docEmphasis">R</span> is in BCNF <span class="docEmphasis">and not in any higher normal form</span>. I have <span class="docEmphasis">not</span> followed this practice in this chapter (and will continue not to do so).</P>
<p class="docText">Third, because it's "the final normal form," 5NF is sometimes called <span class="docEmphasis">projection/join</span> normal form (PJ/NF), to stress the point that it's <span class="docEmphasis">the</span> normal form so long as we limit ourselves to projection as the decomposition operator and join as the recomposition operator. But I should immediately add that it's possible to consider other operators and therefore, possibly, other normal forms. In particular, it's possible, and desirable, to define (a) generalized versions of the projection and join operators, and hence (b) a generalized form of join dependency, and hence (c) a new "sixth" normal form, 6NF. It turns out that these developments are particularly important in connection with support for temporal data, and they're discussed in detail in the book <span class="docEmphasis">Temporal Data and the Relational Model</span> by Hugh Darwen, Nikos Lorentzos, and myself (Morgan Kaufmann, 2003). However, all I want to do here is give a definition of 6NF that works for "regular" (that is, nontemporal) relvars. Here it is:</P>
<blockquote><p class="docText"><span class="docEmphasis">Definition:</span> Relvar <span class="docEmphasis">R</span> is in 6NF if and only if it satisfies no nontrivial JDs at all.</P></blockquote>
<p class="docText">Equivalently, a "regular" relvar is in 6NF if and only if it consists of a single key, plus at most one additional attribute. Our usual shipments relvar SP is in 6NF, as is relvar SPJ (see <a class="docLink" href="#databaseid-CHP-7-FIG-4">Figure 7-4</a>); by contrast, our usual suppliers and parts relvars S and P are in 5NF but not 6NF.</p>
<a name="databaseid-CHP-7-NOTE-24"></a><div class="docNote"><p class="docNormalTitle">NOTE</P><P><p class="docText">A 6NF relvar is sometimes said to be <span class="docEmphasis">irreducible</span>, because it can't be nonloss-decomposed via projection at all. Any 6NF relvar is necessarily in 5NF.</P></P></div>
<p class="docText">To close this subsection, observe that it follows from all of the above that any relvar that's "all key" or consists of a key plus one additional attribute, since it's in 6NF, is certainly in BCNF. However, it does <span class="docEmphasis">not</span> follow that such relvars are always well designed! For example, if relvar RS (see <a class="docLink" href="databaseid-CHP-7-SECT-2.html#databaseid-CHP-7-FIG-2">Figure 7-2</a>) satisfies the FD {CITY} <img src=images/ent/U2192.GIF border=0> {STATUS}, the projection of RS on {SNO,STATUS} is in BCNF—in fact, it's in 6NF—but it certainly isn't well designed. (See the discussion of <span class="docEmphasis">dependency preservation</span> in the section "<a class="docLink" href="databaseid-CHP-7-SECT-4.html#databaseid-CHP-7-SECT-4">Two Cheers for Normalization</a>," later, for a more detailed explanation.)</P>

<a name="databaseid-CHP-7-SECT-3.2"></a>
<H4 class="docSection2Title">More on 5NF</h4>
<p class="docText">Consider <a class="docLink" href="#databaseid-CHP-7-FIG-5">Figure 7-5</a>, which shows a sample value for a simplified version of relvar SPJ from the previous subsection. Suppose that simplified version satisfies the join dependency <img border="0" alt="" width="7" height="9" SRC="images/0596100124/figs/databaseid_in_07_01.gif">{SP,PJ,SJ}, where SP, PJ, and SJ stand for {SNO,PNO}, {PNO,JNO}, and {SNO,JNO}, respectively. What does that JD mean from an intuitive point of view? The answer is as follows:</p>
<a name="databaseid-CHP-7-FIG-5"></a><P><center>
<H5 class="docFigureTitle">Figure 7-5. Simplified relvar SPJ—sample value</h5>
<img border="0" alt="" width="135" height="86" SRC="images/0596100124/figs/databaseid_07_05.gif"></center></p><br>
<ul><LI><p class="docList">The JD means the relvar is equal to the join of, and so can be nonloss-decomposed into, its projections SP, PJ, and SJ. (Note that now I'm using the names SP, PJ, and SJ to refer to the projections as such, instead of to the corresponding subsets of the heading of relvar SPJ; I hope this kind of punning on my part doesn't confuse you.)</p></LI><li><p class="docList">It follows that the following constraint is satisfied:</P><pre>
  IF <span class="docEmphasis">&lt;</span><span class="docEmphasis">s,p</span><span class="docEmphasis">&gt;</span> <img src=images/ent/U220A.GIF border=0> SP AND <span class="docEmphasis">&lt;</span><span class="docEmphasis">p,j</span><span class="docEmphasis">&gt;</span> <img src=images/ent/U220A.GIF border=0> PJ AND <span class="docEmphasis">&lt;</span><span class="docEmphasis">s,j</span><span class="docEmphasis">&gt;</span> <img src=images/ent/U220A.GIF border=0> SJ THEN <span class="docEmphasis">&lt;</span><span class="docEmphasis">s,p,j</span><span class="docEmphasis">&gt;</span> <img src=images/ent/U220A.GIF border=0> SPJ
</pre><BR>
<p class="docList">because if <span class="docEmphasis">&lt;s,p&gt;, &lt;p,j&gt;</span>, and <span class="docEmphasis">&lt;s,j&gt;</span> appear in SP, PJ, and SJ, respectively, then <span class="docEmphasis">&lt;s,p,j&gt;</span> certainly appears in the join of SP, PJ, and SJ, and that join is supposed to be equal to SPJ (that's what the JD says). Given the sample value of <a class="docLink" href="#databaseid-CHP-7-FIG-5">Figure 7-5</a>, for example, the tuples &lt;S1,P1&gt;, &lt;P1,J1&gt;, and &lt;S1,J1&gt; appear in SP, PJ, and SJ, respectively, and the tuple &lt;S1,P1,J1&gt; appears in SPJ. (I'm using what I hope is a self-explanatory shorthand notation for tuples, and I remind you that the symbol "<img src=images/ent/U220A.GIF border=0>" can be read as "appears in.")</P></LI><li><p class="docList">Now, the tuple <span class="docEmphasis">&lt;s,p&gt;</span> obviously appears in SP if and only if the tuple <span class="docEmphasis">&lt;s,p,z&gt;</span> appears in SPJ for some <span class="docEmphasis">z</span>. Likewise, the tuple <span class="docEmphasis">&lt;p,j&gt;</span> appears in PJ if and only if the tuple <span class="docEmphasis">&lt;x,p,j&gt;</span> appears in SPJ for some <span class="docEmphasis">x</span>, and the tuple <span class="docEmphasis">&lt;s,j&gt;</span> appears in SJ if and only if the tuple <span class="docEmphasis">&lt;s,y,j&gt;</span> appears in SPJ for some <span class="docEmphasis">y</span>. So the foregoing constraint is logically equivalent to this one:</p><pre>
  IF for some <span class="docEmphasis">x</span><span class="docEmphasis">,</span> <span class="docEmphasis">y</span><span class="docEmphasis">,</span> <span class="docEmphasis">z</span> <span class="docEmphasis">&lt;s</span><span class="docEmphasis">,</span><span class="docEmphasis">p</span><span class="docEmphasis">,</span><span class="docEmphasis">z&gt;</span> <img src=images/ent/U220A.GIF border=0> SPJ AND
                   <span class="docEmphasis">&lt;x</span><span class="docEmphasis">,</span><span class="docEmphasis">p</span><span class="docEmphasis">,</span><span class="docEmphasis">j&gt;</span> <img src=images/ent/U220A.GIF border=0> SPJ AND
                   <span class="docEmphasis">&lt;s</span><span class="docEmphasis">,</span><span class="docEmphasis">y</span><span class="docEmphasis">,</span><span class="docEmphasis">j&gt;</span> <img src=images/ent/U220A.GIF border=0> SPJ
  THEN             <span class="docEmphasis">&lt;s</span><span class="docEmphasis">,</span><span class="docEmphasis">p</span><span class="docEmphasis">,</span><span class="docEmphasis">j&gt;</span> <img src=images/ent/U220A.GIF border=0> SPJ
</pre><br>
<p class="docList">With reference to <a class="docLink" href="#databaseid-CHP-7-FIG-5">Figure 7-5</a>, for example, the tuples &lt;S1,P1,J2&gt;, &lt;S2,P1,J1&gt;, and &lt;S1,P2,J1&gt; all appear in SPJ, and therefore so does the tuple &lt;S1,P1,J1&gt;.</p></li></ul>
<p class="docText">So the original JD is equivalent to the foregoing constraint. But what does that constraint mean in real-world terms? Well, here's a concrete illustration. Suppose relvar SPJ contains tuples that tell us that all three of the following are true propositions:</p>
<div style="font-weight:bold"><ol class="docList" type="1"><li><div style="font-weight:normal"><p class="docList">Smith supplies monkey wrenches to some project.</p></div></li><li><div style="font-weight:normal"><p class="docList">Somebody supplies monkey wrenches to the Manhattan project.</p></div></li><li><div style="font-weight:normal"><p class="docList">Something is supplied to the Manhattan project by Smith.</P><p class="docList">Then the JD says the relvar must contain a tuple that tells us that the following is a true proposition too:</p></div></li><li><div style="font-weight:normal"><p class="docList">Smith supplies monkey wrenches to the Manhattan project.</p></div></LI></ol></div>
<p class="docText">Now, propositions 1, 2, and 3 together would normally <span class="docEmphasis">not</span> imply proposition 4. If we know only that propositions 1, 2, and 3 are true, then we know that Smith supplies monkey wrenches to <span class="docEmphasis">some</span> project (say, project <span class="docEmphasis">z</span>), that <span class="docEmphasis">some</span> supplier (say, supplier <span class="docEmphasis">x</span>) supplies monkey wrenches to the Manhattan project, and that Smith supplies <span class="docEmphasis">some</span> part (say, part <span class="docEmphasis">y</span>) to the Manhattan project—but we cannot validly infer that <span class="docEmphasis">x</span> is Smith or <span class="docEmphasis">y</span> is monkey wrenches or <span class="docEmphasis">z</span> is the Manhattan project. False inferences such as this one are examples of what's sometimes called <span class="docEmphasis">the connection trap</span><a name="IDX-CHP-7-0543"></a>. In the case at hand, however, the existence of the JD tells us <span class="docEmphasis">there is no trap</span>; that is, we <span class="docEmphasis">can</span> validly infer proposition 4 from propositions 1, 2, and 3 in this particular case.</P>
<p class="docText">Observe now the <span class="docEmphasis">cyclic nature</span> of the constraint ("IF <span class="docEmphasis">s</span> is connected to <span class="docEmphasis">p</span> and <span class="docEmphasis">p</span> is connected to <span class="docEmphasis">j</span> and <span class="docEmphasis">j</span> is connected back to <span class="docEmphasis">s</span> again, THEN <span class="docEmphasis">s</span> and <span class="docEmphasis">p</span> and <span class="docEmphasis">j</span> must all be directly connected, in the sense that they must all appear together in the same tuple"). It's precisely if such a cyclic constraint occurs that we might have a relvar that's in BCNF and not in 5NF. In my experience, however, such cyclic constraints are very rare in practice—which is why I said in the previous subsection that I don't think they're very important from a practical point of view.</p>
<p class="docText">I'll close this section with a brief remark on <span class="docEmphasis">fourth</span> normal form (4NF). In the subsection "The Significance of 5NF," I said that if you're a database designer, you need to know about JDs and 5NF. In fact, you also need to know about <span class="docEmphasis">multi-valued</span> dependencies (MVDs) and fourth normal form<a name="IDX-CHP-7-0544"></a>. However, I mention these concepts for completeness only; like 2NF and 3NF, they're mainly of historical interest. I'll just note for the record that:</P>
<UL><LI><p class="docList">An MVD<a name="IDX-CHP-7-0545"></a> is a JD that involves no more than two projections (in practice, usually exactly two).</p></LI><LI><p class="docList">A relvar is in 4NF if and only if every nontrivial MVD it satisfies is implied by some superkey.</P></LI></UL>
<p class="docText">Details of what it means for an MVD to be trivial or implied by some superkey are beyond the scope of this discussion (see <a class="docLink" href="databaseid-CHP-7-SECT-8.html#databaseid-CHP-7-SECT-8.1.19">Exercise 7-19</a> at the end of the chapter)—but let me at least point out that it follows from these definitions that repeated nonloss-decomposition into exactly two projections is sufficient to take us at least as far as 4NF. By contrast, the JD in the previous subsection involved three projections, as I'm sure you noticed. In fact, we can say that in order to reach 5NF, decomposition into <span class="docEmphasis">n</span> projections (where <span class="docEmphasis">n</span> &gt; 2) is necessary only if the relvar in question satisfies an <span class="docEmphasis">n</span>-way cyclic constraint: equivalently, only if it satisfies a JD involving <span class="docEmphasis">n</span> projections and not one involving fewer.</P>


<ul></ul></TD></TR></table>
<table width="100%" border="0" cellspacing="0" cellpadding="0" bgcolor="#e6e6e6">
<tr style="background-image: url(images/tile_back.gif);">
<td class="v2" align="left" width="30%">
<a href="databaseid-CHP-7-SECT-2.html"><img src="images/previous.gif" width="70" height="19" border="0" align="absmiddle" alt="Previous Section"></a>
</td>
<td class="v2" align="center" width="40%">
<a href="main.html" style="color:white;text-decoration:none;text-underline:none">&nbsp;&lt;&nbsp;Day Day Up&nbsp;&gt;&nbsp;</a>
</td>
<td class="v2" align="right" width="30%">
<a href="databaseid-CHP-7-SECT-4.html"><img src="images/next.gif" width="70" height="19" border="0" align="absmiddle" alt="Next Section"></a>
</td>
</tr>
</table>
</body>
</html>
