<html>
<head>
<META http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<title>What Remains to Be Done?</title>
<link rel="STYLESHEET" type="text/css" href="images/style.css">
<link rel="STYLESHEET" type="text/css" href="images/docsafari.css">
</head>
<body >
<table width="100%" border="0" cellspacing="0" cellpadding="0" bgcolor="#e6e6e6">
<tr style="background-image: url(images/tile_back.gif);">
<td class="v2" align="left" width="30%">
<a href="databaseid-CHP-8-SECT-4.html"><img src="images/previous.gif" width="70" height="19" border="0" align="absmiddle" alt="Previous Section"></a>
</td>
<td class="v2" align="center" width="40%">
<a href="main.html" style="color:white;text-decoration:none;text-underline:none">&nbsp;&lt;&nbsp;Day Day Up&nbsp;&gt;&nbsp;</a>
</td>
<td class="v2" align="right" width="30%">
<a href="databaseid-CHP-8-SECT-6.html"><img src="images/next.gif" width="70" height="19" border="0" align="absmiddle" alt="Next Section"></a>
</td>
</tr>
</table>
<br>
<table width="100%" border="0" cellspacing="0" cellpadding="0"><tr><td valign="top"><a name="databaseid-CHP-8-SECT-5"></a>
<H3 class="docSection1Title">What Remains to Be Done?</H3>
<p class="docText">All of the above is not to say we won't continue to make progress or there isn't still work to be done. In fact, I see at least four areas, somewhat interrelated, where developments are either under way or are needed: implementation, foundations, higher-level abstractions, and higher-level interfaces.</p>
<a name="databaseid-CHP-5-SECT-5.1"></a>
<H4 class="docSection2Title">Implementation</H4>
<p class="docText">In some ways the message of this book can be summed up very simply:</P>
<blockquote><p class="docText"><span class="docEmphStrong">Let's implement the relational model!</span></p></blockquote>
<p class="docText">I think it's clear from earlier chapters that it's being extremely charitable to describe SQL as a relational language, and hence that SQL products can be considered relational only to a first approximation. The truth is, the relational model has never been properly implemented in commercial form, and users have never really enjoyed the benefits that a truly relational product would bring. Indeed, that's one of the reasons why Hugh Darwen and I have been working for so long on <span class="docEmphasis">The Third Manifesto</span>. <span class="docEmphasis">The Third Manifesto--</span> the <span class="docEmphasis">Manifesto</span> for short—is a formal proposal for a solid foundation for future DBMSs. And it goes without saying that what it really does, in as careful and precise a manner as the authors are capable of, is define the relational model and spell out some of the implications of that definition. (It also goes into a great deal of detail on the impact of type theory on that model; in particular, it proposes a comprehensive model of type inheritance as a logical consequence of that type theory.)</P>
<p class="docText">So we'd really like to see the ideas of the <span class="docEmphasis">Manifesto</span> implemented properly in commercial form ("we" here meaning Darwen and myself). We believe such an implementation would serve as a solid basis on which to build so many other things—for example, "object/relational<a name="IDX-CHP-8-0596"></a>" DBMSs; spatiotemporal DBMSs; DBMSs used in connection with the World Wide Web; and "rule engines" (also known as "business logic servers"), which some people see as the next generation of general-purpose DBMS products. We further believe we would then have the right framework for supporting the other items that are suggested in the rest of this section as also being desirable. Personally, in fact, I would go further: I would suggest that trying to implement those items in any other kind of framework is likely to prove more difficult than doing it correctly. To quote the well-known mathematician Gregory Chudnovsky: "If you do it the stupid way, you will have to do it again" (from an article in <span class="docEmphasis">The New York Times</span>, December 24, 1997).</P>
<p class="docText">To repeat, I want the model to be properly implemented. And in the previous chapter, I tried to suggest that a promising new implementation technology called <span class="docEmphasis">The TransRelational? Model</span> looks as if it might be well suited to that task. This possibility is under active investigation.</P>

<a name="databaseid-CHP-5-SECT-5.2"></a>
<H4 class="docSection2Title">Foundations</H4>
<a name="IDX-CHP-8-0597"></a><a name="IDX-CHP-8-0598"></a><a name="IDX-CHP-8-0599"></a>
<p class="docText">There's still much interesting work to be done on theoretical foundations (it's certainly not the case that all of the foundation problems have been solved). Here are three examples:</P>
<ul><li><p class="docList">Let <span class="docEmphasis">rx</span> be some relational expression. By definition, the relation <span class="docEmphasis">r</span> denoted by <span class="docEmphasis">rx</span> satisfies a constraint <span class="docEmphasis">rc</span> that's derived from the constraints satisfied by the relations in terms of which <span class="docEmphasis">rx</span> is expressed. Can that constraint <span class="docEmphasis">rc</span> be computed?</P></LI><li><p class="docList">Can we inject more science into the database design process? In particular, can we come up with a precise characterization of the notion of redundancy?</p></li><li><p class="docList">In the previous chapter I sketched an approach to the missing information problem based on 6NF. What are the implications of that approach?</P></li></UL>

<a name="databaseid-CHP-5-SECT-5.3"></a>
<h4 class="docSection2Title">Higher-Level Abstractions</H4>
<a name="IDX-CHP-8-0600"></a><a name="IDX-CHP-8-0601"></a>
<p class="docText">One way we make progress in computer languages and applications is by <span class="docEmphasis">raising the level of abstraction</span>. For example, I pointed out in <a class="docLink" href="databaseid-CHP-4.html#databaseid-CHP-4">Chapter 4</a> that the familiar KEY and FOREIGN KEY specifications are really just shorthand for constraints that can be expressed more longwindedly using the general integrity features of any relationally complete language like <span class="docEmphStrong">Tutorial D</span>. But those shorthands are <span class="docEmphasis">useful:</span> quite apart from the fact that they save us some writing, they also serve to raise the level of abstraction, by allowing us to talk in terms of certain bundles of concepts that naturally belong together. In a sense, they make it easier for us to see the forest as well as the trees.</P>
<p class="docText">By way of another illustration, consider the relational algebra. I showed in <a class="docLink" href="databaseid-CHP-5.html#databaseid-CHP-5">Chapter 5</a> that many of the operators of the algebra—including ones we use all the time (even if we don't realize it), such as semijoin—are really shorthand for certain combinations of other operators.<sup class="docFootnote"><a class="docLink" href="#databaseid-CHP-8-FN-6">[*]</a></sup> Indeed, there are other useful operators that I didn't discuss in that chapter at all, for space reasons, for which these remarks might be regarded as "even more true," in a sense. Again, what's really going on here is a raising of the level of abstraction (rather like macros raise the level of abstraction in a conventional programming language).</P><blockquote><p class="docFootnote"><sup><a name="databaseid-CHP-8-FN-6">[*]</a></sup> As a matter of fact, Darwen and I show in our <span class="docEmphasis">Manifesto</span> that every algebraic operator can be expressed in terms of just two primitives, <span class="docEmphasis">remove</span> (which is basically project) and either <span class="docEmphasis">nand</span> or <span class="docEmphasis">nor</span>.</P></blockquote>
<p class="docText">Raising the level of abstraction in the relational world can be regarded as a kind of building on top of the relational model; it doesn't change the model, but it does make it more directly useful for certain tasks. And one area where this approach looks as if it's going to prove really fruitful is temporal databases. In our book <span class="docEmphasis">Temporal Data and the Relational Model</span> (Morgan Kaufmann, 2003), Hugh Darwen, Nikos Lorentzos, and I—building on original work by Lorentzos—introduce <span class="docEmphasis">interval types</span> as a basis for supporting temporal data in a relational framework. For example, consider the "temporal relation" in <a class="docLink" href="#databaseid-CHP-8-FIG-1">Figure 8-1</a>, which shows that certain suppliers supplied certain parts during certain intervals of time (you can read <span class="docEmphasis">d04</span> as "day 4," <span class="docEmphasis">d06</span> as "day 6," and so on; likewise, you can read [<span class="docEmphasis">d04</span>:<span class="docEmphasis">d06</span>] as "the interval from day 4 to day 6 inclusive," and so on). Attribute DURING in that relation is interval-valued.</p>
<a name="databaseid-CHP-8-FIG-1"></a><p><center>
<h5 class="docFigureTitle">Figure 8-1. A relation with an interval attribute</h5>
<img border="0" alt="" width="157" height="182" SRC="images/0596100124/figs/databaseid_08_01.gif"></center></p><br>
<p class="docText">Support for interval attributes (and hence for temporal databases) involves, among other things, support for generalized versions of the regular algebraic operators. For reasons that aren't important here, we call those generalized operators U_ operators; thus, there's a <span class="docEmphasis">U_restrict</span> operator, a <span class="docEmphasis">U_join</span> operator, a <span class="docEmphasis">U_union</span> operator, and so on. But—and here comes the point—those <i>U_ operators</i> are all, in the last analysis, nothing but shorthand for certain combinations of regular algebraic operators. Once again, then, what's fundamentally going on is a raising of the level of abstraction.</p>
<p class="docText">Two more points on this topic. First, our relational approach to temporal data involves not just "U_" versions of the algebraic operators but also (a) "U_" keys and foreign keys, (b) "U_" comparison operators, and (c) "U_" versions of INSERT, DELETE, and UPDATE—but, again, all of these constructs turn out to be essentially just shorthand. Second, it also turns out that the <span class="docEmphasis">Manifesto's</span> type inheritance model has a crucial role to play in that temporal support—so once again we see an example of the interconnectedness of all of these issues.</p>

<a name="databaseid-CHP-5-SECT-5.4"></a>
<h4 class="docSection2Title">Higher-Level Interfaces</h4>
<a name="IDX-CHP-8-0602"></a>
<p class="docText">There's another way in which we can build on top of the relational model, and that's by means of various kinds of applications that run above the relational interface and provide various specialized services. One example might be decision support; another might be data mining; another might be a natural-language frontend. For the users of such applications, the relational model obviously disappears under the covers, at least to some degree. (Though even if it does, and even if most users interact with the database only through some such frontend, I think database design and the like will still necessarily be based on solid relational principles.)</p>
<p class="docText">By the way, suppose it's your job to implement one of those frontend applications. Which would you prefer as a target—a relational DBMS or some other kind, say an object-oriented DBMS? And if you opt for the former, as I obviously think you should, which would you prefer—a DBMS that supports the relational model or one that supports SQL?</p>
<p class="docText">In case it's not clear, my point is this: we've come a long way from the early days when SQL was being touted as a language that end users could use for themselves, and I know many people will dismiss my numerous criticisms of SQL as mere carping for that very reason. Real users don't use it anyway, right? Only programmers use it. And in any case, much of the SQL code that's actually executed is never written by a human programmer at all but is generated by some frontend application. However, it seems to me that SQL is bad as a <span class="docEmphasis">target</span> language for all of the same reasons that it's bad as a <span class="docEmphasis">source</span> language. And it further seems to me, therefore, that my criticisms are still germane.</P>

<a name="databaseid-CHP-5-SECT-5.5"></a>
<h4 class="docSection2Title">So What About SQL?</h4>
<p class="docText">SQL is incapable of providing the kind of firm foundation we need for future growth and development. Instead, it's the relational model that has to provide that foundation. In <span class="docEmphasis">The Third Manifesto</span>, therefore, Darwen and I reject SQL as such; in its place, we argue that some truly relational language like <span class="docEmphStrong">Tutorial D</span> should be implemented as soon as possible. Of course, we aren't so na&iuml;ve as to think that SQL will ever disappear. Rather, we hope that <span class="docEmphStrong">Tutorial D</span>, or some other true relational language, will be sufficiently superior that it will become the database language of choice (by a process of natural selection), and SQL will become "the database language of last resort." In fact, we see a parallel with the world of programming languages, where COBOL has never disappeared (and never will); but COBOL has become "the programming language of last resort" for developing applications, because better alternatives exist. We see SQL as a kind of database COBOL, and we would like to see some other language become available as a better alternative to it.</p>
<p class="docText">Of course, we do realize that SQL databases and applications are going to be with us for a long time—to think otherwise would be quite unrealistic—and so we do have to pay some attention to the question of what to do about today's SQL legacy. The <span class="docEmphasis">Manifesto</span> therefore does include some specific proposals in this regard. In particular, it offers some suggestions for implementing SQL on top of a true relational language, so that existing SQL applications can continue to work. Detailed discussion of those proposals would be out of place here, however.</p>


<UL></UL></td></TR></table>
<table width="100%" border="0" cellspacing="0" cellpadding="0" bgcolor="#e6e6e6">
<tr style="background-image: url(images/tile_back.gif);">
<td class="v2" align="left" width="30%">
<a href="databaseid-CHP-8-SECT-4.html"><img src="images/previous.gif" width="70" height="19" border="0" align="absmiddle" alt="Previous Section"></a>
</td>
<td class="v2" align="center" width="40%">
<a href="main.html" style="color:white;text-decoration:none;text-underline:none">&nbsp;&lt;&nbsp;Day Day Up&nbsp;&gt;&nbsp;</a>
</td>
<td class="v2" align="right" width="30%">
<a href="databaseid-CHP-8-SECT-6.html"><img src="images/next.gif" width="70" height="19" border="0" align="absmiddle" alt="Next Section"></a>
</td>
</tr>
</table>
</body>
</html>
